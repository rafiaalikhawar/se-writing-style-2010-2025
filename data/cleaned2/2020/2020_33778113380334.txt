sfuzz an efficient adaptive fuzzer for solidity smart contracts tai d. nguyen singapore management university singapore dtnguyen.
smu.edu.sglong h. pham singapore management university singapore longph1989 gmail.comjun sun singapore management university singapore sunjunhqq gmail.com yun lin national university of singapore singapore llmhyy gmail.comquang tran minh ho chi minh city university of technology vietnam quangtran hcmut.edu.vn abstract smart contracts are turing complete programs that execute on the infrastructure of the blockchain which often manage valuable digital assets.
solidity is one of the most popular programming languages for writing smart contracts on the ethereum platform.
like traditional programs smart contracts may contain vulnerabilities.
unlike traditional programs smart contracts cannot be easily patched once they are deployed.
it is thus important that smart contracts are tested thoroughly before deployment.
in this work we present an adaptive fuzzer for smart contracts on the ethereum platform called sfuzz.
compared to existing solidity fuzzers sfuzz combines the strategy in the afl fuzzer and an efficient lightweight multi objective adaptive strategy targeting those hard to cover branches.
sfuzz has been applied to more than thousand smart contracts and the experimental results show that sfuzz is efficient e.g.
two orders of magnitude faster than state of the art tools sfuzz is effective in achieving high code coverage and discovering vulnerabilities and the different fuzzing strategies in sfuzz complement each other.
acm reference format tai d. nguyen long h. pham jun sun yun lin and quang tran minh.
.
sfuzz an efficient adaptive fuzzer for solidity smart contracts.
in42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction nowadays smart contracts are implemented as turingcomplete programs that execute on the infrastructure of the blockchain .
it provides a framework that potentially allows any program equivalently contract to be executed in an autonomous distributed and trusted way.
smart contracts thus have the potential to revolutionize many industries.
popular applications of smart contracts include crowd fundraising online gambling and so on.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
is the first to introduce the functionality of smart contracts.
based on the ethereum platform solidity is the most popular programming language for smart contracts .
like traditional c or java programs smart contracts may contain vulnerabilities.
unlike traditional programs smart contracts cannot be modified easily once they are deployed on the blockchain .
as a result a vulnerability renders the smart contract forever vulnerable which significantly magnifies the problem.
in recent years there has been an increasing number of news reports on attacks which exploit security vulnerabilities in ethereum smart contracts.
one particularly noticeable example is the dao attack i.e.
an attacker stole more than .
million ether which is equivalent to about million usd at the time exploiting a vulnerability in the dao contract.
to fix the vulnerability a hard fork was launched which was not only expensive but also caused much controversy .
it is thus desirable to develop tools for validating smart contracts to identify vulnerabilities ideally before they are deployed.
among the range of complementary techniques for validating smart contracts we focus on automatic testing of smart contracts in this work as testing is often the least expensive and thus the most applicable.
to automatically test smart contracts we must solve the following three problems the test automation problem i.e.
how to run test cases the test generation problem i.e.
what to test and the oracle problem i.e.
what are vulnerabilities .
in the literature several approaches have been developed for automatic testing smart contracts each of which answers these three problems in slightly different ways.
for instance contractfuzzer builds a network with pre deployed contracts and generates transactions to run smart contracts generates test cases based on a set of predefined parameter values and targets a set of oracles specific for smart contracts.
oyente runs smart contracts symbolically through symbolic execution generates test cases for covering different program paths in single functions through constraint solving and supports multiple oracles to identify kinds of vulnerabilities.
teether similarly applies symbolic execution to generate test cases covering program paths and focuses on oracles which are related to financial transactions.
in this work we propose a fully automatic testing engine for smart contracts running on ethereum called sfuzz.
sfuzz is inspired by afl a well known fuzzer for c programs i.e.
sfuzz is a feedback guided fuzzing engine and is inexpensive to apply.
sfuzz ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea tai d. nguyen long h. pham jun sun yun lin and quang tran minh complements existing testing engines based on symbolic execution like oyente and teether as it is known that fuzzing and symbolic execution are complementary .
while afl based fuzzing is often effective it has its limitation as well i.e.
it is often expensive in covering branches guarded with strict conditions.
to tackle the problem sfuzz integrates afl based fuzzing with an efficient lightweight adaptive strategy for selecting seeds.
although inspired by search based software testing the latter distinguishes itself by having a lightweight objective function designed considering characteristics of solidity programs as well as a novel multi objective optimization strategy.
sfuzz is built based on aleth i.e.
an ethereum vm written in c has a system architecture similar to afl and is extensible to different ethereum vms and oracles as well as fuzzing strategies.
sfuzz has been systematically applied to a set of more than thousand smart contracts.
the experimental results show that sfuzz is on average more than two orders of magnitudes faster than contractfuzzer covers more branches and reveals many more vulnerabilities.
a comparison between sfuzz and oyente shows that they are complementary.
furthermore experiments with prolonged fuzzing time show that the adaptive strategy improves code coverage.
sfuzz is available online and has been adopted by multiple companies.
the remainder of the paper is organized as follows.
section illustrates how sfuzz works through examples.
section presents the details of the approach.
section shows implementation details of sfuzz.
section reports evaluation results.
section reviews related work and concludes.
illustrative examples in this section we show how sfuzz works step by step through two illustrative examples.
note that solidity source codes for both examples are shown for simplicity.
sfuzz requires only the evm i.e.
ethereum virtual machine bytecode to fuzz smart contracts.
given a smart contract sfuzz automatically configures a blockchain network deploys the smart contract and generates multiple transactions each of which calls a function in the contract.
the transactions are then executed with an evm enriched with a set of oracles for identifying vulnerabilities.
sfuzz monitors the execution of the transactions to collect certain feedback e.g.
whether a certain branch has been covered and how far the branch is covered.
whenever a vulnerability is revealed the transactions and the network configuration i.e.
a test case are saved and reported to the user later on.
otherwise some of the test cases are selected as seeds based on feedback collected during the transaction execution according to certain seed selection criteria.
afterwards the seeds are mutated to generate the next generation of test cases.
this process repeats until a time out occurs.
in the following we describe how sfuzz works using the contract shown in figure .
the contract implements a simple quiz game.
the contract is based on contract opposite ame1with minor modification for simplicity.
a quiz can be created by calling function start quiz ame.
the response is hashed and then saved in the responsehash variable.
the user then calls the tryfunction with their answer as the argument and pays a fee of 100f inney which 1address 0x467532e79222670a2044c9b168bcbaa33b390ef51pragma solidity .
.
2contract opposite game string public question address questionsender bytes32 responsehash function try string response external payable if responsehash keccak256 response msg.value finney msg.sender .send this .balance function start quiz game string question string answer public payable if responsehash x0 responsehash keccak256 answer question question questionsender msg.sender function public payable figure an example with single objective function is a unit of the token for each try.
if the answer is correct a reward is sent to the user.
this contract suffers from a vulnerability known as gasless send when line is executed and a costly fallback function is called.
that is when function send at line is executed if the receiver is a contract its fallback function is executed automatically.
because function send only forwards units of gas i.e.
price to pay for executing the function an out of gas exception is thrown if the fallback function is costly e.g.
costs more than units of gas .
in this case the send function simply returns f alse and because the returned value is not checked and handled accordingly the owners of the contract can keep the reward for themselves.
to expose this vulnerability first a network is configured with several addresses and associated balances.
this contract is then deployed at one of the addresses.
in addition an attacker contract with a costly fallback function is deployed automatically.
to expose the vulnerability a test case i.e.
a sequence of transactions with such a network configuration must first call function start quiz ame and then function trywith parameters such that all conditions in function tryat line and are satisfied.
the condition at line is satisfied with a test case that sets all the parameters and contract variables to the default value of .
note that responsehash is set to keccak answer at line and is compared to keccak response at line .
however generating a test case which satisfies the second condition by randomly generated test values is highly unlikely.
the variable ms .value has a size of bytes and thus we have only1 2256probability to generate the value if we generate random values with a uniform distribution among all possible values .
existing fuzzing strategy in afl is ineffective in this case as well i.e.
afl selects test cases that cover new branches as seeds .
since all test cases generated through mutation are unlikely to cover the then branch at line they are equally bad according to the afl seed selection strategy.
sfuzz complements afl s seed selection strategy with an adaptive strategy that prioritizes the seeds according to a quantitative measure i.e.
a distance on how far a seed is from covering 779sfuzz an efficient adaptive fuzzer for solidity smart contracts icse may seoul republic of korea 1pragma solidity .
.
2contract multiple objective function function foo int x int y x x if y ... if y ... figure an example with multiple objective functions any just missed branch.
for this example the distance for covering the just missed branch i.e.
the then branch is computed as ms .value based on the value of ms .value when the branch at line is reached in the test case.
intuitively the smaller the distance is the closer the test case is to cover the branch i.e.
with a ms .value closer to .
in particular when ms .value is exactly the distance value reaches the minimum value of .
based on this measurement sfuzz iteratively selects seeds which gradually gets closer and closer to satisfying the condition at line .
in our experiment after generations sfuzz generates a test case which covers the branch and reveals the vulnerability.
the above example shows a simplistic situation where there is only one just missed branch.
in general there may be multiple just missed branches and thus sfuzz measures a distance for each pair of test case and just missed branch i.e.
how far is the branch from being covered by the test case.
then for each just missed branch sfuzz selects the test case with the minimum distance as theseed.
for instance the contract in figure shows a function which performs some basic arithmetic operations.
there are two different branches i.e.
the condition at line for comparing ywith 110and the one at line for comparing ywith .
assume that both then branches are yet to be covered.
given any test case sfuzz computes two distances one for covering the first then branch and the other for covering the second then branch.
given a set of test cases sfuzz selects for each of these two branches a test case which has minimum distance as seed to generate further test cases.
after repeating the process multiple times sfuzz generates two test cases that cover the two then branches.
we remark that for this example due to the non linear computation at line approaches based on symbolic execution like oyente and teether are ineffective due to the limitation of underlying constraint solvers.
fuzzing smart contracts in this section we define our problem and then present our approach in detail step by step.
.
problem definition a smart contract stypically has a number of instance variables a constructor and multiple functions some of which are public.
it can be equivalently viewed in the form of a control flow graph cfg s n i e where nis a finite set of control locations in the program i nis the initial control location i.e.
the start of the contract and e n c nis a set of labeled edges each of which is of the form n c n where cis either a condition for conditional branches like if then else or while loops or a command i.e.
an assignment .
note that for simplicity we define the smart contract as one single graph rather than defining one graph foreach function and then connecting them through a call graph.
a node in the graph is branching if and only if it has multiple child nodes and its outgoing edges are labeled with conditions.
we refer to an outgoing edge of a branching node as a branch.
test cases.
a test case for sis a pair 0 where 0is a configuration of the blockchain network and is a sequence of transactions i.e.
function calls .
the configuration 0contains all information on the setup of the network which is relevant to the execution of the smart contract.
formally 0is a tuple b ts sa sb v where b is the current block number tsis the current block timestamp sa is a set of the addresses of the smart contracts including the smart contract under test as well as other invoked contracts sbis a function which assigns an initial balance to each address and vis the initial valuation of the persistent state.
m0 p0 m1 p1 is a sequence of public function calls of the smart contract under test each of which has an optional sequence of concrete input parameters pi.
note that m0must be a call of the constructor.
the task of fuzzing a smart contract is thus to generate a set of test cases a.k.a.
test suite according to certain testing criteria.
the execution of a test case ttraverses through a path in the cfg s which visits a set of nodes and edges.
for simplicity we assume that one test execution covers one unique path i.e.
there is no nondeterminism .
furthermore a trace generated by tis a sequence of pairs of the form 0 n0 1 n1 where n0 n1 is the sequence of nodes visited by tand iis the configuration at the time of visiting node nifor all i. code coverage.
ideally we aim to generate a test suite which reveals all vulnerabilities in the contract.
however as we do not know where the vulnerabilities are we must instead aim to achieve something more measurable.
in this work our answer is to focus on code coverage in particular branch coverage.
we remark that our approach can be extended to support different coverage at the cost of additional code instrumentation.
a branch in sis covered by a test suite if and only if there is a test case tin the suite that visits the edge at least once.
the branch coverage of a test suite is calculated as the percentage of the covered branches over the total number of branches.
note that identifying the total number of feasible branches statically in a smart contract is often infeasible for two reasons.
first some branches might be infeasible i.e.
there does not exist any test case that visits the branch and knowing whether a branch is feasible or not is a hard problem.
second evm has a stack based implementation which makes identifying all potentially feasible branches hard as we will explain in more detail in section .
our problem is thus reduced to generate a test suite which maximizes the number of covered branches.
to achieve maximum code coverage one way is to generate a large test suite e.g.
through random test generation .
however in practice we often have limited resources in terms of time or the number of computer processes and thus our problem is refined as to generate a test suite which maximizes the number of covered branches as efficiently as possible .
our solution to the problem is feedback guided adaptive fuzzing.
fuzzing is one of the most popular methods to create test cases .
a feedback guided fuzzing system a.k.a.
fuzzer takes a program 780icse may seoul republic of korea tai d. nguyen long h. pham jun sun yun lin and quang tran minh algorithm the test generation algorithm 1letsuite be an empty test suite 2letseeds initpopulation 3while not time out do add tests in seeds which covers new branches into suite letseeds f itt osur vive seeds letseeds crosso ver mutation seeds 7return suites under test and an initial test suite as input monitors the execution of the test cases to obtain certain feedback generates new test cases based on the existing ones in certain ways and then repeats the process until a stopping criteria is satisfied.
we present details of our feedback guided adaptive fuzzing process in section .
.
oracles the remaining problem is then how to tell whether a test case reveals a vulnerability.
in this work we adopt a set of oracles from previous approaches including gasless send exception disorder timestamp dependency block number dependency dangerous delegatecall reentrancy integer overflow underflow and freezing ether.
we refer the readers to section for details.
.
feedback guided adaptive fuzzing the general idea of feedback guided fuzzing is to transform the test generation problem into an optimization problem and use some form of feedback as an objective function in solving the optimization problem.
our fuzzing strategy is adaptive as we change the objective function adaptively based on the feedback.
at the top level sfuzz employs a genetic algorithm which is inspired by the wellknown afl fuzzer to evolve the test suite in order to iteratively improve its branch coverage.
the overall workflow is shown in algorithm .
variable suite is the test suite to be generated.
it is initially empty.
whenever a test case covers a new branch it is added into suite .
variable seeds is a set of seed test cases based on which new test cases are generated.
first we generate an initial test suite using function initpopulation .
the loop from line to then iteratively evolves the test suite.
in particular we add those test cases in seeds which cover new branches i.e.
any branch which is not covered by test cases in suite into suite at line .
at line we filter the test cases inseeds through function f ittosurvive so as to focus on those seeds which are more likely to lead to test cases covering new branches later.
at line function crossovermuatation generates more test cases based on the test cases in seeds .
the loop continues until a pre set time out is triggered.
while algorithm resembles the one in afl the differences are in the details of each function.
in the following we present each function in detail.
generating initial population function initpopulation generates an initial population containing multiple test cases.
as mentioned above to generate a test case we need to generate an initial configuration 0as well as a sequence of public function calls with concrete parameters.
the initial configuration by default is as follows in hexadecimal b ts sa 0xf0 sb 0xff00... andvis set using the declared initial value for each variable representing the persistent state.
sfuzz additionally allows a user to customize the initial configuration i.e.
the user is allowed to provide an initial set of test cases.
next we generate multiple sequences of transactions each of which is a function call with concrete parameters.
for a contract with nfunctions we generate nsequences.
in each sequence a different function is called once after the constructor is called.
this makes sure that each function is tested at least once i.e.
function coverage is .
for each function call we generate a random value for each parameter based on its type.
note that if the parameter type has a fixed length e.g.
of type uint256 this is straightforward.
if the type does not have a fixed length e.g.
an array or a string we first randomly generate a number with a range from to bound where bound is a bound on maximum length with a default value of representing the number of elements in the parameter e.g.
number of characters and then generate a corresponding number of element values.
each test case is encoded in form of a bit vector.
in the terminology of genetic algorithms such bit vectors can be naturally regarded as chromosomes.
the size of the bit vector equals to the number of bits for encoding the configuration plus the number of bits encoding the function calls.
note that for each test case we keep a list of function calls which always includes the constructor in the contract and then encode each parameter value.
if the parameter value is of variable length we use logbound where bound is a bound on the maximum length with a default value of to encode the length of the parameter value.
for example given the contract shown in figure part of the encoding of a test case is shown in figure where each part of encoding is labeled in the figure.
it contains bytes of which the first bytes are initial configuration and the last bytes are a sequence of two function calls and the corresponding input parameters.
as there are three string parameters the first bytes including 0x05 0x05 and0x05 encode the length of response question and answer respectively.
the remaining 0x05 values are used when there are more than dynamic variables.
before executing the test case the bit vector is decoded to a test case according to our internally defined protocol.
note that the bits in the bit vector may be correlated with each other in multiple ways.
for instance the bits presenting the length of a variablelength value must be equal to the length of the value.
fitness after executing the seeds at line in algorithm function f ittosurvive is called to evaluate the fitness of the seeds according to a fitness function.
note that the fitness function plays an extremely important role.
in sfuzz we combine two complementary strategies.
one is adopted from afl which works as follows.
while seeds are executed sfuzz monitors the execution and records the branches that each test case cover.
a test case is deemed fit to survive if it covers a new branch in the contract e.g.
a branch which is not covered by any test case in suite .
this strategy has been shown to be effective in many settings and indeed our experimental results show that it is effective in covering most of the branches see section .
781sfuzz an efficient adaptive fuzzer for solidity smart contracts icse may seoul republic of korea figure a generated test case although the afl strategy allows us to quickly cover most of the branches it often makes very slow progress in covering the remaining ones afterwards i.e.
often those branches which are with strict conditions.
the reason is that most likely the randomly generated test cases would fail to satisfy the strict condition.
in such a case the above fitness function offers little feedback and guideline on how to generate new test cases.
for instance the probability of satisfying the second condition at line of figure is as low as1 if we assume that every value is equally likely to be generated .
intuitively however it is clear that a test input with ms .value 200is closer to satisfy the condition than a test input with ms .value .
sfuzz thus integrates an adaptive strategy which selects seeds based on a quantitative measure on how far a test case is from covering any just missed branch.
letbrnbe a just missed branch in s i.e.
an uncovered outgoing edge from a branching node ninsandnhas been covered.
the idea is to define a function distance t brn where tis a test case to return a quantitative measure on how far the branch brnis from being covered by t. assume that brnis labeled with a condition c. note that ccan be either true f alse a b a!
b a b a b a b ora b at the byte code level where aandbare variables or constants.
in our setting since brnis assumed to be a just missed branch c must not be true otherwise brnmust be covered already .
function distance t brn is then defined as follows.
distance t brn k ifcisf alse a b kifcisa b k ifcisa!
b b a k ifcisa bora b a b k ifcisa bora b where kis a constant which represents the minimum distance.
it is set to be in sfuzz.
intuitively distance t brn is defined such that the closer the branch is from being covered the smaller the resultant value is.
with the above function f ittosurvive seeds then selects the seeds as shown in algorithm .
the loop from line to goes through every test case to select those which cover a new branch.
afterwards for each just missed branch brnin the smart contract the loop from line to line selects a test case from seeds which is the closest to cover the branch according to distance t brn .
note that one seed is selected for each just missed branch which makes this algorithm a lightweight multi objective optimization approach.
all selected seeds are then used for crossover and mutation toalgorithm algorithm f ittosurvive seeds 1letnewseeds be an empty set of test cases 2foreach seed inseeds do ifseed covers a new branch then addseed intonewseeds 5foreach uncovered branches brndo letmin be let tbe a dummy test case foreach seed inseeds do ifdistance t brn min then letmin bedist t brn lettbeseed addtintonewseeds 12return newseeds generate more test cases in the next step.
we refer the readers to section for an example.
remark the above described strategy is inspired by search based software testing sbst and yet it differs from sbst in several ways.
the high level reason for the difference is that having an afl based approach for fuzzing requires us to run test cases efficiently whereas existing sbst s seed selection strategy is timeconsuming.
furthermore due to the stack based implementation of evm implementing existing the sbst strategy is infeasible.
in the following we present the differences in detail.
first existing state of the art sbst techniques i.e.
the one in evosuite measures how far a test case tis from covering any uncovered branch not only those just missed ones in a more complicated way.
that is given cfg s n i e let the distance from a node n1to node n2to be the minimum number of edges along any path from n1ton2.
letbrnbe any uncovered branch and mbe a node covered by twhich is the nearest node to n i.e.
mhas a minimum distance to ncompared to any other node covered by t. sbst uses the following function to measure how far tis from covering brn.
dist t brn appr dist t brn norm distance t brm where brmis an outgoing edge of mwhich is along the shortest path from mton.
note that if misn i.e.
in case brnis just missed brmis simply brn.
function appr dist t brn is a measurement of how far branch brnis from being covered by test case t i.e.
the distance from mtonplus .
for instance given a control flow graph as in figure 782icse may seoul republic of korea tai d. nguyen long h. pham jun sun yun lin and quang tran minh iftcovers only the edge a b e appr dist t c 1since there is one branch from bto reach cand there are two branches from ato reach cviad.
similarly appr dist t f .
lastly function norm x is a normalization function which normalizes the results of distance t brm to a value between and .
one such function is norm x .
x .
applying the above strategy in fuzzing solidity smart contracts is inefficient if not infeasible for multiple reasons.
first calculating appr dist t brn would require us to construct the complete cfg.
however constructing the cfg based on bytecode only is highly nontrivial.
in evm branches are realized with the opcode jumpi with a value representing the target program counter dynamically at runtime.
the only way to know the target is to fully simulate the stack which is expensive.
second even if we have the cfg computing appr dist t brn is still expensive.
given a cfg with kuncovered nodes.
to maintain a list of best test cases for each uncovered node we have to calculate appr dist t brn for all k uncovered nodes i.e.
by building a table of the shortest paths from all nodes to these knodes.
furthermore whenever a new node is covered appr dist t brn must be updated.
the overhead is unreasonable given that efficiency is key for afl based fuzzing.
by focusing on just missed branches sfuzz avoids both problems.
that is appr dist t brn is always for any just missed branch brnsince node nmust have been covered.
furthermore because it is constant for any uncovered branch we can simply skip it in dist t brn and so that dist t brn is reduced to distance t brn without even the need to normalize.
this further reduces the overhead.
another key difference between sfuzz s strategy and existing sbst s is the multi objective searching strategy.
the multi objective search strategies in existing sbst consider each uncovered branch as an objective and select pareto optimal seeds to evolve in next generation.
given a set of uncovered branch b1 b2 ... bm a set of seeds t1 t2 ... tn we say tiis more pareto optimal than tjif k ..m distance ti bk distance tj bk .
otherwise we say that ti andtjare pareto equivalent.
all pareto equivalent seeds form a pareto frontier and the seeds can fall into several pareto frontiers.
existing sbst selects the most pareto optimal seeds to evolve.
a known problem for such a strategy is that the number of seeds in the same pareto frontier soars with the increase of the number of objectives i.e.
uncovered branches .
for example there could be hundreds of seeds in the most pareto optimal frontier with only objectives which makes it hard to select the most promising seeds and increases the runtime overhead.
in contrast sfuzz keeps one best seed for each just missed branch line in algorithm and as a result the number of seeds remains small i.e.
equivalent to the number of just missed branches .
our experimental results show that such a strategy balances effectiveness in identifying good seeds and efficiency well.
.
crossover and mutation function crossovermutation generates new test cases based on those in seeds through crossover and mutation.
sfuzz adopts all of the crossover strategies from afl and introduces news ones specific for smart contracts.
furthermore due to correlation between parameters of a test case sfuzz additionally makes sure the generated test cases are valid.
for instance sfuzz randomly chooses figure a control flow graph table mutations for fix length values name prunemethodcall new addmethodcall new swapmethodcall new singlewalkingbit twowalkingbit fourwalkingbit consecutive bits singlewalkingbyte twowalkingbyte fourwalkingbyte singlearith twoarith fourarith singleinterest twointerest fourinterest overwritewithdictionary overwritewithaddressdictionary two test cases from seeds breaks the two test cases into two pieces at a selected position and swaps the second pieces to form two new test cases.
note that due to correlations between the bits representing a test case there is no guarantee that the resultant test cases are valid and thus sfuzz always checks for validity and discard those invalid ones.
mutation is another way of generating new test cases.
given aseed encoded in the form of a bit vector sfuzz supports a set of mutation operators to generate new test cases.
all mutation operators are shown in table .
recall that a test case is in the form of an initial configuration and a sequence of function calls with concrete parameters.
the first three mutation operators aim to alter the sequence of function calls by pruning a function call adding a function call or swapping two function calls.
when a function call is pruned or added or swapped the corresponding concrete parameters are pruned or added or swapped accordingly.
for those values in a test case other than those representing the called functions sfuzz categorizes them into two groups.
the first group contains those values which have fixed length e.g.
a parameter of type uint256 .
sfuzz systematically applies the remaining mutation operators shown in table to generate new values which are inspired by the mutation operators in afl.
note that account addresses and balances are handled slightly differently refer to the last row in the table as there are special format requirements.
each address has bytes in which the last bytes contain the address value and the first bytes contain the balance of the address.
for instance the value 0xff00... ...00f0 represent an address 0xf0 with balance 0xff0000000000000000000000.
the second group contains those values which have variablelength e.g.
a parameter of type array .
for such values their lengths are encoded as part of the test case as well.
we thus first mutate the value representing the length in such a way that the result is a random value between and where is an upper bound.
if the new length is less than the current one the corresponding value is shortened accordingly by pruning the additional bits.
if 783sfuzz an efficient adaptive fuzzer for solidity smart contracts icse may seoul republic of korea the length is more than the current one random type compatible values are padded accordingly.
note that we discard identical test cases generated through either crossover or mutation.
furthermore although we do not set a limit on the number of mutations generated from a test case we apply multiple heuristics adopted from afl to reduce the number of mutations.
for instance if applying the walkingbyte mutation to a block of bytes does not result in any test case which covers a new branch in the next stages sfuzz will not mutate that block.
we refer the readers to afl for details on these heuristics .
implementation sfuzz is implemented in c with an estimated lines of code.
it is publically available it has main components runner libfuzzer andliboracles.
component runner manages the execution of the test cases.
sfuzz takes as input the bytecode of a smart contract along with the abi i.e.
application binary interface which can be generated automatically using existing tools of the contract.
the runner then generates a bash script file which contains a list of commands to analyze the abi and set options for the other two components.
the runner sets up a test network based on which smart contracts are deployed and transactions are executed.
to generate test cases for functions with address type parameters sfuzz deploys a pool of externally owned accounts in the test network with random balances.
the pool size is less than or equal to the number of address type parameters because it is possible to set the same address to multiple address type parameters.
the values for address type parameters are then chosen randomly from this pool.
in addition sfuzz deploys two special smart contracts as attackers i.e.
a normal attacker and a reentrancy attacker.
each attacker is set as the owner of the contract under test in turn.
the normal attacker throws an exception whenever other contracts call its payable fallback function.
the reentrancy attacker calls back the function which makes a call to its payable fallback function.
if the attacker fails to call back it acts as a normal attacker.
note that the reentrancy attacker is only loaded to detect reentrancy vulnerability.
otherwise the normal attacker is loaded to avoid call loops of reentrancy attacker which significantly reduces the speed of sfuzz.
component libfuzzer solves the test generation problem i.e.
how to selectively generate test cases by implementing the fuzzing strategy presented in the previous sections.
it is responsible for multiple tasks.
first it constructs the cfg of the given smart contract on the fly.
ideally we would like to construct the cfg statically before fuzzing.
however constructing the cfg based on bytecode only is highly nontrivial.
in evm branches are realized with the opcode jumpi with a value representing the target program counter dynamically at runtime.
the only way to know the target is to fully simulate the stack which is expensive.
therefore sfuzz constructs the cfg on the fly while fuzzing.
that is whenever the opcode jumpi is executed the two destinations are recorded.
if these two destinations are not part of the cfg yet two new nodes are created accordingly representing the two destinations in the cfg.second component libfuzzer implements the fuzzing algorithm discussed in section .
one optimization is that we identify view functions i.e.
those which do not change any variables and exclude them from test case generation.
the justification is that these view functions do not change the states and having them does not additionaly expose those vulnerabilities sfuzz targets at see below .
note that view functions are marked by view pure orconstant keywords sfuzz reads abi file to recognize them.
component liboracles solves the oracle problem i.e.
it monitors the execution of a test case and checks whether there is a vulnerability according to an extensible library of oracles used in sfuzz.
sfuzz monitors the execution of test cases through the hooking mechanism supported by evm.
whenever evm executes an opcode it creates an event containing read only execution information such as the values of the stack memory program counter and the current executed opcode.
sfuzz monitors these events for constructing the cfg and computing distance t brn as well as logs the events for vulnerability detection.
to reduce the execution overhead vulnerability detection is conducted offline in batches i.e.
once for every test cases .
this design allows sfuzz to easily support different versions of solidity i.e.
by simply replacing the evm packed in sfuzz.
sfuzz has an extensible architecture which allows it to easily support different oracles as well.
currently sfuzz supports oracles inspired by the previous work .
since these oracles are not our main contribution we refer the readers to for details.
these oracles are checked based on the logs of test cases.
for instance to check if a test case expose the gasless send vulnerability we check that whether test case executes a call instruction with some data greater than when the gas is equal to .
the test cases that expose vulnerabilities in the contract are kept in a separate test suite and reported to the user together with the vulnerabilities that they expose.
note that by design sfuzz always reports true positives according to our definition of vulnerability except in the case of freezing ether.
however in practice a reported vulnerability might be a false positive as it may be what the user intended i.e.
our definition of vulnerability is too strict .
in the case of freezing ether the identified warning might be a false positive if there exist some test cases which call send ortrans f er but such test cases are never generated.
technically the problem of checking whether there is freezing ether vulnerability can only be solved if we cover all feasible opcode which is often infeasible .
experiments and evaluation in this section we evaluate sfuzz through multiple experiments.
the experiments are designed to answer the following research questions rq .
rq1 how efficient is sfuzz?
rq2 is sfuzz effective in finding smart contract vulnerabilities and obtaining high code coverage?
rq3 is the adaptive strategy useful?
our test subjects include smart contracts which we collect from etherscan .
these contracts are implemented using solidity .
.
which is the most popular version of solidity.
moreover the source code for these contracts are available which makes 784icse may seoul republic of korea tai d. nguyen long h. pham jun sun yun lin and quang tran minh the evaluation more accurate.
we note that sfuzz can run with bytecode only.
for a baseline comparison we compare sfuzz with a fuzzer named contractfuzzer reported in and a symbolic execution tool named oyente reported in .
other fuzzers for smart contracts have been mentioned in .
however we fail to find the reported tools online or through the authors.
we run the experiments times and report the average as the result.
all experimental results reported below are obtained on an ubuntu .
.
lts machine with intel core i7 and 16gb of memory.
we use the default initial configuration as presented in section .
.
.
efficiency to answer rq1 we systematically apply sfuzz contractfuzzer and oyente on all smart contracts.
to save time each contract is run for minute in this experiment.
note that in general the adaptive fuzzing strategy takes time to show its effectiveness as we will show later and thus this setting gives an edge to other tools.
we measure the efficiency of sfuzz by counting how many test cases are generated and executed per second.
naturally a test case for a more complicated contract e.g.
with many loop iterations takes more time to execute.
thus we show how efficiency varies for different contracts.
figure summarizes the result where each bar represents about of the fuzzed contracts and the y axis shows the number of test cases generated and executed per second.
the contracts are sorted according to how efficiently it can be fuzzed.
from the figure we observe that the efficiency varies significantly over different contracts i.e.
sfuzz generates and executes more than test cases per second on average for the top of the contracts and less than test cases for the bottom .
on average sfuzz generates and executes more than test cases per second.
figure also compares the efficiency of sfuzz with oyente and contractfuzzer.
from the results we observe that sfuzz is significantly more efficient than other tools.
on average contractfuzzer and oyente generate and execute .
and test cases per second respectively.
there are multiple reasons why sfuzz is much faster.
first contractfuzzer simulates the whole network and manages the blockchain e.g.
commit state changes to storage and append new mined blocks to blockchain after function calls whereas sfuzz simulates only details of network or blockchain which are relevant to vulnerabilities in smart contracts.
second sfuzz has a highly optimized implementation in c whereas contractfuzzer is based on node.js and go language.
in the case of oyente because it is a symbolic execution tool oyente is expected to run slower than a fuzzer like sfuzz.
we further conduct an experiment to measure the overhead of monitoring the execution of a test case using the hooking mechanism and the overall overhead of the fuzzing process including the overall of monitoring the execution constructing the cfg mutating the test cases and comparing them etc.
.
we apply sfuzz to a set of randomly selected contracts and measure the time spent on executing the test cases monitoring the execution and other steps of the fuzzing process.
the results show that on average the monitoring consumes about of the total execution time and the overhead of the fuzzing process including monitoring is about figure efficiency comparison between sfuzz oyente and contractfuzzer figure coverage comparison between sfuzz and contractfuzzer figure coverage comparison between sfuzz and oyente .
this is very efficient compared to the reported overhead in other fuzzers .
.
effectiveness to answer rq2 we aim to measure the branch coverage achieved by the test suite generated for each smart contract as well as count the number of vulnerabilities identified.
however measuring branch coverage precisely is highly non trivial due to for instance the problem of infeasible branches.
thus we instead measure the number of distinct branches covered by the generated test suite.
figure summarizes a comparison between sfuzz and contractfuzzer in terms of the number of distinct branches covered.
the y axis is the number of branches covered by sfuzz minus that of contractfuzzer and each point on the x axis represents a smart contract.
the contracts are sorted by their y axis value.
similarly figure shows the comparison between sfuzz and oyente.
for most of the smart contracts i.e.
of contracts sfuzz covers more branches than contractfuzzer.
to our surprise contractfuzzer managed to cover more branches for contracts.
785sfuzz an efficient adaptive fuzzer for solidity smart contracts icse may seoul republic of korea 1contract a mapping address uint balances uint id function main uint x uint y if id if balances uint sum x y figure oyente visits infeasible branches a closer investigation shows that the number of branches covered by contractfuzzer is inflated for the following reasons.
first as sfuzz does not execute view functions for efficiency reasons all branches in these functions are not counted.
because view functions do not modify the state of a smart contract they are considered irrelevant to vulnerabilities.
second contractfuzzer sometimes generates invalid test cases which fail mandatory constraints and cover additional branches.
mandatory constraints are generated by the compiler i.e.
the solidity compiler and are embedded in the bytecode to assert the correctness logic of function calls or data types.
for example contractfuzzer invokes a fallback function of a non fallback contract or sends ethereum to functions which are not marked with the payable keyword.
as a result the mandatory constraints are failed which lead to branches which signal an error in the test case being covered.
in the case of oyente in contracts oyente covers more branches than sfuzz.
an investigation shows that oyente analyzes every function separately and thus has to assume that state variables can take arbitrary values without considering their initial values or constraints on how the values are updated .
as a result oyente can easily satisfy almost all conditions in smart contracts.
given the sample contract a in figure oyente covers .
evm code and discovers an integer overflow vulnerability.
it means that these conditions id 9andbalances 10are satisfied.
however it is impossible as there is no way to change values ofidandbalances .
often a condition in smart contract is the comparison between local parameter variables and state variables e.g.
balances value whether sender has enough ethereum to deduce .
in such cases sfuzz must call the function which sets certain values to the state variables before satisfying them whereas oyente assigns arbitrary values directly to state variables.
it is apparent to us that oyente s approach is flawed and would cover many infeasible paths.
in the following we summarize the number of vulnerable contracts discovered by sfuzz in each category.
the results are shown in table .
the first column shows the type of vulnerability.
the next three columns show the number of vulnerable contracts found by sfuzz contractfuzzer and oyente respectively.
the sub column show the number of contracts that have the vulnerability according to each vulnerability type and the second sub column is the percentage of true positives of the identified vulnerabilities.
for all categories sfuzz finds more vulnerable contracts than contractfuzzer.
note that contractfuzzer removes freezing ether from their source code and does not check integer overflow underflow.
in total sfuzz finds vulnerabilities in contracts i.e.
times more than that of contractfuzzer.table vulnerabilities vulnerability typesfuzz contractfuzzer oyente true posi.
true posi.
true posi.
gasless send n.a.
exception disorder n.a.
reentrancy timestamp dependency block number dependency n.a.
dangerous delegatecall n.a.
integer overflow n.a.
integer underflow n.a.
freezing ether n.a.
n.a.
to evaluate the soundness of sfuzz we manually examine the identified vulnerable contracts to check whether they are true positives or not.
however we are unable to manually check all the identified vulnerability for two reasons.
first there is an overwhelming number of vulnerabilities.
instead we randomly sample vulnerable contracts with source code in each category and manually check whether the identified vulnerability is a true positive or not.
if there are fewer than vulnerable contracts with source code in the category we check all of them.
forgasless send exception disorder andreentrancy vulnerability all sampled vulnerable contracts are true positives.
for timestamp dependency out of the sampled vulnerable contracts of them are true positives.
in the remaining contracts although block.timestamp and or now is used in a condition they are irrelevant to the ether sending part i.e.
no control data dependency .
rather their values are saved in global variables to record the creation time of specific events.
sfuzz mistakenly claims that such cases are vulnerable.
for block number dependency out of the sampled vulnerable contracts are true positives.
similarly the reason for the false positives is the value of block.number is assigned to global variables but they are irrelevant to ether sending process.
for dangerous delegatecall all sampled contracts are indeed vulnerable.
similarly so for integer overflow.
for integer underflow of the identified contracts are indeed vulnerable.
the reason for the false positives is because it is non trivial to identify the correct type of a variable based on bytecode only e.g.
whether it is uint256 oruint128 sfuzz conservatively assumes that all arithmetic operations returning a negative value may be vulnerable.
this can be improved by adopting the approach in to infer types based on evm bytecode.
lastly for freezing ether of the identified contracts are true positives.
the reason for the false positives is that although there is a program path which allows the contract to send ether the program path is not covered and sfuzz falsely assumes that there is no such program path.
this percentage of such false positives is expected to be reduced if sfuzz is applied for a longer time with more branches covered .
the last column in table shows the results of oyente.
the results should be taken with a grain of salt since oyente requires the source code.
for instance it is trivial to know the type of variables with the source code and thus oyente identifies many more problems with integer overflow underflow.
for the remaining vulnerabilities oyente does not support of them identifies a higher number of vulnerable contracts for reentrancy but with a higher false positive rate and identifies much fewer vulnerable contracts fortimestamp dependency.
786icse may seoul republic of korea tai d. nguyen long h. pham jun sun yun lin and quang tran minh figure percentage of test cases due to adaptive strategy figure effective of adaptive strategy over time .
adaptiveness to answer rq3 we systematically analyze the test suite generated by sfuzz for each smart contract.
note that each test case covers at least one branch which is not covered by any other test cases.
to measure how the two fuzzing strategies implemented in sfuzz complement each other we count how many test cases in the resultant test suites are generated due to the afl strategy and how many are due to the adaptive strategy.
note that a test case is judged to be due to the adaptive strategy if and only if it is generated based on a seed selected by line at algorithm .
the results are shown in figure where the y axis is the percentage of test cases generated by the strategy.
each bar represents of the contracts.
we remark that the two strategies have different targets and thus whether they are effective largely depends on what branching conditions are in the smart contracts.
we thus sort the contracts according to the speed of sfuzz.
the bar on the rightmost thus represents the top contracts.
we observe that as expected the afl strategy easily covers most of the branches since the conditions for executing most branches are not strict .
for about of the smart contracts the adaptive strategy makes a noticeable contribution i.e.
contributing an average of of the generated test cases.
given that sfuzz is applied for each contract only for minutes the result is encouraging as we hypothesize that the effect of the adaptive strategy would be more apparent if sfuzz is applied for a longer period of time.
to test our hypothesis we record the percentage of test cases generated by the adaptive strategy every seconds.
the results are shown in figure where the x axis is the fuzzing time and each bar shows the percentage after certain number of seconds.
we can observe that the percentage of generated test cases by adaptive strategy increases with more fuzzing time.
on average the percentage rises from after seconds fuzzing to after minutesfuzzing.
from the results we conclude the adaptive strategy is useful in increasing the coverage of the generated test suites.
threat to validity there are both internal threats and external threats to our work.
for external threats it is probable that sfuzz s performance will vary with the choice of the initial population as other researchers have noted .
for internal threats the percentage of true positives in table may not be accurate as they are approximated by a sample of contracts for each type of vulnerability.
in addition the exact intention of the author of the contract is not always clear even if we try our best to read the source code.
related work and conclusion sfuzz is closely related to existing fuzzers for smart contracts.
contractfuzzer is a fuzzer which can check different types of vulnerabilities.
its approach however does not use any feedback to improve the test suite.
echidna is another fuzzer that is reportedly capable of checking if the contract violates some user defined properties.
however we fail to find any publication about it.
sfuzz is complementary to existing symbolic execution engines for smart contracts.
in luu et al.
presented an engine to find potential security bugs in smart contracts.
the tool however is neither sound nor complete.
in krupp and rossow presented teether which is focused on financial transactions and related vulnerabilities.
in nikolic et al.
presented a tool named maian which can find types of trace vulnerabilities.
in torres et al.
presented osiris a tool which combines symbolic execution and taint analysis to discover types of integer bugs in smart contracts.
different from the above works sfuzz is a fuzzer and it can be combined with the above engines to form a hybrid fuzzing engine.
sfuzz is related to work on formal verification of smart contracts.
zeus is a framework which verifies the correctness and fairness of smart contracts based on llvm.
bhargavan et al.
proposed a framework to verify smart contracts formally by transforming the source code and the bytecode to f a language designed for verification .
in the author presented an attempt to verify the deed contract using isabelle hol .
sfuzz is broadly related to work on analyzing smart contracts.
in delmolino et al.
showed that writing a safe smart contract is not a trivial task.
in atzei et al.
provided a taxonomy for common vulnerabilities in smart contracts with real world attacks.
in the authors performed a call graph analysis and showed that only of smart contracts are truthless as their control flows are immutable.
in chen et al.
presented gas cost programming patterns and showed that most of the contracts suffer from these gas cost patterns.
to conclude in this work we present sfuzz an adaptive fuzzing engine for evm smart contracts.
experimental results show that sfuzz is significantly more reliable faster and more effective than existing fuzzers.
sfuzz is currently under rapid development and has already gained interest from multiple companies and research organizations.