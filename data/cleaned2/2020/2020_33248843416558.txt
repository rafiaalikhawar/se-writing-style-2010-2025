broadening horizons of multilingual static analysis semantic summary extraction from c code for jni program analysis sungho lee eshaj cnu.ac.kr chungnam national university south koreahyogun lee aasr4r4 kaist.ac.kr kaist south koreasukyoung ryu sryu.cs kaist.ac.kr kaist south korea abstract most programming languages support foreign language interoperation that allows developers to integrate multiple modules implemented in different languages into a single multilingual program.
while utilizing various features from multiple languages expands expressivity differences in language semantics require developers to understand the semantics of multiple languages and their interoperation.
because current compilers do not support compile time checking for interoperation they do not help developers avoid interoperation bugs.
similarly active research on static analysis and bug detection has been focusing on programs written in a single language.
in this paper we propose a novel approach to analyze multilingual programs statically.
unlike existing approaches that extend a static analyzer for a host language to support analysis of foreign function calls our approach extracts semantic summaries from programs written in guest languages using a modular analysis technique and performs a whole program analysis with the extracted semantic summaries.
to show practicality of our approach we design and implement a static analyzer for multilingual programs which analyzes jni interoperation between java and c. our empirical evaluation shows that the analyzer is scalable in that it can construct call graphs for large programs that use jni interoperation and useful in that it found genuine interoperation bugs in real world android jni applications.
ccs concepts software and its engineering automated static analysis operational analysis.
keywords multilingual program analysis language interoperability java native interface acm reference format sungho lee hyogun lee and sukyoung ryu.
.
broadening horizons of multilingual static analysis semantic summary extraction from c code for jni program analysis.
in 35th ieee acm international conference on automated software engineering ase september virtual permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn .
.
.
.
australia.
acm new york ny usa pages.
.
introduction from desktop to mobile developing multilingual programs has become one of the dominant options to implement software systems.
multilingual programs are implemented in a host language and one or more guest languages and the implementation languages interoperate with each other via a foreign function interface ffi .
ffis enable programs written in one language to call functions and exchange data written in different languages.
different programming languages provide ffis in different ways.
python rust and julia provide language level ffis java and javascript support runtime environment specific ffis such as java native interface jni and node.js c addons and go uses an external tool cgo to support interaction with c. multilingual programs take advantage of various features provided by multiple languages using cross language interoperation.
because different languages support different features their interoperation expands the expressivity of developers.
developers can implement specific modules in the most appropriate languages for the modules and compose them together via seamless interoperation between the languages.
one of the popular approaches to develop multilingual programs is to use both high level and lowlevel languages which improves not only programmability but also performance.
in addition cross language interoperation enables a program to reuse existing modules implemented in different languages.
for example game programs often reuse existing c or c modules to surmount restrictions of host languages.
also hybrid mobile applications use both javascript to handle user interaction and native languages to access device resources.
however developing reliable multilingual programs is a challenging task.
because programming with multiple languages requires programmers to understand the semantics of different languages and the complex interoperation semantics between them.
for example to call a foreign function a developer should understand the ffi calling convention and compatible argument values between the languages.
if the developer fails to satisfy the ffi requirements programs may behave unexpectedly or crash at run time.
even though compilers can detect such problems for programs in a single language they cannot for multilingual programs.
static analysis for multilingual programs is a challenging task as well.
since most static analyzers can analyze programs in one language they often ignore foreign function calls during analysis and produce partial and unreliable analysis results.
some static analyzers support multiple languages like wala which can analyze java programs and javascript programs but not programs written 35th ieee acm international conference on automated software engineering ase ase september virtual event australia sungho lee hyogun lee and sukyoung ryu in both.
by using wala previous work could analyze one kind of multilingual programs android hybrid applications in both android java and javascript.
while the analyses worked well for android hybrid applications because precise analysis requires complex language specific models extending an existing analyzer for one language to support different languages is not trivial.
in this paper we propose a novel approach to analyze multilingual programs statically.
our approach utilizes two static analyzers one for a host language and another for a guest language.
first using the guest language static analyzer we perform a modular analysis that extracts semantic summaries from program modules written in the guest language.
a semantic summary looks like a simplified function representing the semantics of a guest language function.
it captures interoperation between program modules written in the host and guest languages but does not contain the semantics unrelated to the interoperation.
then the host language static analyzer performs a whole program analysis for the program written in the host language.
when it encounters foreign function calls during analysis it analyzes semantic summaries corresponding to the callee guest language functions.
while ignoring foreign function calls during analysis would produce unsound and imprecise analysis results our approach can analyze more control flows with more data flows by analyzing program flows between modules written in different languages.
moreover an analyzer for one language does not need to consider the semantics of the other language.
for interoperation semantics we only need to build models for the ffi semantics in the host static analyzer.
to evaluate the practicality of the approach we design and implement a multilingual analysis model for jni programs written in both java and c. jni programs are widely used not only as desktop programs but also as mobile applications .
we first define a c like guest language and describe a formal abstract semantics for semantic summary extraction from the language.
then we implement a semantic summary extractor on top of infer a modular static analysis framework for c developed by facebook .
because c is the most frequently used guest language our abstract semantics for summary extraction and the analyzer can be used to analyze other multilingual programs that use c code.
for the java side we build analysis models on top of flowdroid a static analyzer for java and android applications .
we support both native function calls where java invokes c functions and jni function calls where c gets sets values from to java fields and invokes java methods.
our formal abstract semantics and tools are publicly available1.
the contributions of this paper include the following we propose a novel approach to statically analyze multilingual programs using automatically extracted semantic summaries from modules written in a guest language.
our approach utilizes both static analyzers of a host and a guest languages separately.
we describe a formal abstract semantics of semantic summary extraction for a c like language.
since c is the most used guest language it provides a formal ground to analyze various multilingual programs that use c code.
host languageguest languagehost languageguest language host languageguest languagehost languageguest languagef host languageguest languagef fbidirectional interoperation explicit implicit interoperation static dynamic bindingfigure three properties of cross language interoperation we design and implement an open source jni program analyzer which broadens the analysis scope of java static analyzers to jni programs.
we show feasibility and usefulness of the jni program analyzer with real world android jni applications.
in the empirical experiments our tool detected genuine jni interoperation bugs in real world applications.
cross language interoperation this section describes properties of multilingual programs as shown in figure .
for a given multilingual program we call the language that provides an ffi a host language and the others guest languages.
for jni programs java is a host language and c is a guest language.
bidirectional interoperation.
while each host language provides its own ffi most ffis support bidirectional interoperation that enables a host language to call the functions of a guest language and vice versa.
a host language makes foreign function calls by its external function call feature.
for example java calls c functions via native function calls that invoke methods declared with the native keyword.
ocaml first imports c functions as external functions and then calls them.
python and go import c code as an external module and call functions available from the module.
finally julia uses a special keyword ccall to call c functions.
as for the other direction c calls java python and ocaml functions indirectly via c functions defined in libraries that each language provides.
on the contrary in julia c uses function pointers that refer to julia functions propagated from julia.
lastly go provides both ways c can define external functions for go functions and call them as external functions or it can use function pointers as in julia.
explicit and implicit language boundary.
foreign function calls are syntactically distinguishable from normal function calls in some multilingual programs which expose the language boundaries explicitly.
since java and ocaml denote foreign functions using special keywords native andexternal respectively one can easily identify language boundaries by syntactic checks.
because go uses a fixed module named cto denote the bridge module to c code and julia uses a special keyword ccall to call c functions they also expose language boundaries.
however python does not show language boundaries since it imports c code in the same way as it imports an external python module.
when c initiates interoperation it has explicit language boundaries for java python and ocaml because c calls predefined library functions for them.
however for julia and go because c uses function pointers as the same way as calls for c functions the language boundary is implicit.
128broadening horizons of multilingual static analysis ase september virtual event australia void java com example app calljava jnie nv env jobject app jclass klass env getobjectclass e nv app .c void java com example app calljava jnie nv env jobject app jclass klass env getobjectclass env app .c void java com example app calljava jnienv env jobject app jclass klass env getobjectclass e nv app .g class app static system.loadlibrary example void exec calljava void foo do something... .java class app static system.load library example void exec calljava void foo do something... .java class app static system.load library example void exec calljava void foo do something... .hsummary extractionsummary to host lang.
host static analyzer ... callgraphcode injection class app static system.loadlibrary example void exec calljava void foo do something... .java class app static system.load library example void exec calljava void foo do something... .java class app static system.loadlibrary example void exec calljava void foo do something... .hguest lang.
code host lang.
codemodified host lang.
codesemantic summaries class app static system.load library example void exec calljava void foo do something... .java class app static system.load library example void exec calljava void foo do something... .java class app static system.loadlibrary example void exec calljava void foo do something... .h summaries in host lang.
figure multilingual program analysis with summaries static and dynamic function binding.
in most cross language interoperations function bindings between a host and a guest languages are determined at linking time and the bindings do not change at run time.
thus the same foreign function call from a host language always invokes the same c function.
however jni supports such static function bindings by default and it also supports dynamic function bindings.
in jni programs c code can modify existing bindings via a jni function call of registernatives which makes java methods declared with the native keyword be bound to c functions.
thus after calling it the same native function call in java may invoke a different c function at run time.
overview of our approach we propose a new approach to statically analyze multilingual programs.
our approach supports bidirectional interaction explicit language boundaries and static function binding with partial support for dynamic function binding.
the overall structure of the approach is illustrated in figure .
we split a given multilingual program into guest lang.
code andhost lang.
code depending on the implementation languages.
then summary extraction takes guest lang.
code as an input performs an interprocedural modular static analysis and extracts semantic summaries for all the guest language functions in the code.
the modular analysis abstracts the behavior of a function as a relation between an input state and an output state of the function in general the input and output states are abstract heaps such as memory states.
to support bidirectional interoperation we modify the output state of a function so that it captures not only the final abstract heap at the end of the function but also the sequence of foreign function calls with their argument values at language boundaries in the function.
for each function callable from the host language summary extraction converts its input and output states to a semantic summary.
a semantic summary consists of three parts parameters for inputs from the host language function call statements for foreign function calls to the host language and return statements for the return value to the host language.
then summary to host lang.
transforms the summaries to host language functions and code injection integrates the functions with the host language program host lang.
code so that the input multilingual program gets converted to a new program implemented in the host language only.
finally host static analyzer analyzes the new program and produces analysis results.p sdfd sd struct a k fd f x s s x e e e ix f e ix f e return e e x x x.k c a figure language syntax note that even though host static analyzer does not need to analyze the guest language semantics it should provide analysis models for the ffi semantics because ffis have their own semantics and restrictions like value conversion between languages.
in addition when a host language cannot support some features that a guest language uses via foreign function calls code injection does not encode the features in the host language but lets host static analyzer provide analysis models for them.
in the following sections we describe how we extract a semantic summary from a c like language section and how to perform jni program analysis with handling of dynamic function bindings section in detail.
semantic summary extraction .
target guest language figure shows the syntax of a c like language that we use as a guest language.
a program pis a sequence of struct declarations sdfollowed by a sequence of function declarations fd.
a struct declaration sdhas a struct name aand a sequence of fields and their types k .
a function declaration fdhas a return type a function name f a sequence of parameters and their types x and a sequence of statements s. a statement sis one of five kinds a load statement x e a store statement e e a function call statement ix f e where i denotes the call site a foreign function call statement ix f e and a return statement return e. an expression eis also one of five kinds a variable x a variable reference x a field access x.k a struct creation and a constant c. for simplicity we assume that a field access expression returns the address of a field kof a struct referred by x. in other words a load statement x1 x2.k assigns a value of the field kofx2to a variable x1.
we also assume that a string is a constant value c. a type is a pointer type a struct type a or a primitive type .
.
modular analysis for semantic summary extraction figure shows an overview of the semantic summary extraction mechanism.
for a given function f it aims to generate a semantic summary f as an abstraction of f s semantics.
after constructing a control flow graph cfg for f it performs a modular analysis to extract f in four steps.
first during the initialization stage it takes a function fand generates a parameter environment dand the initial heap hiat the function entry.
we define the parameter environment and the 129ase september virtual event australia sungho lee hyogun lee and sukyoung ryu initialization fcfg construction intra procedural analysishi li heap log composition ho lo summary generationd0 h0 o l0 o semantic summaryf0section .
.
section .
.
section .
.
section .
.4semantic summary extraction d ho locfg h l h0 l0 d figure overview of semantic summary extraction void set thiz hobj x hobj y hobj x o getfield thiz f x x o y o getfield thiz g y y o void call thiz hobj arg hobj invoke thiz foo arg void f1 obj1 hobj set obj1 a b call a b void f2 obj2 hobj set obj2 c c call c c a example code in the target guest language in f1 arg obj1 loc s6 ffi getfield arg obj1 const f loc s7 ffi getfield arg obj1 const g loc s9 ffi invoke loc s6 const foo loc s7 in f2 arg obj2 loc s6 ffi getfield arg obj2 const f loc s7 ffi getfield arg obj2 const g loc s9 ffi invoke loc s7 const foo loc s7 b semantic summaries for f1andf2 figure example for semantic summary extraction initial heap differently due to heap decomposition as we describe in section .
.
.
second with the initial heap hi it performs intra procedural analysis based on abstract interpretation .
it analyzes statements offand produces an output state ho lo where hoandlo denote a final heap and a foreign function call log containing foreign function call information respectively.
then it stores the analysis result d ho loto a storage so that it can reuse the result at call sites of the function while analyzing other functions.
third heap log composition enables the modular analysis to handle interprocedural semantics.
it composes the current state h lwith f s analysis result d h o l oat a function call site and generates a new state h l as an abstract state right after execution of the function call.
finally it transforms the output state of each function faccessible from the host language to its semantic summary f .we formally define a whole abstract semantics of the semantic summary extraction.
figure shows a running example for this section.
figure a presents a simple program implemented in the guest language we defined.
the guest language interoperates with a host language via a jni like foreign function interface.
the type hobj is a primitive type denoting a host object value.
functions f1andf2are callable from the host language and getfield and invoke are the interface functions that get the value of a host object s field and call a host object s method respectively.
for simplicity we omit return value assignments when they are unnecessary.
semantic summaries in figure b look similar to the original program but capture only foreign function call information by analyzing the complex language semantics.
in the following sections we describe each step of the semantic summary extraction.
.
.
initialization.
theinitialization stage constructs a parameter environment dand an initial heap hiof a function fusing the function s parameters and their types.
the initial heap represents an abstract memory at the function entry.
because the modular analysis analyzes a function without any call site information the initial heap contains symbolic locations denoting arbitrary argument values.
the intra procedural analysis handles symbolic locations like normal values but they are substituted with argument values at call sites during heap log composition.
a heap hmaps an abstract address to an abstract value set of abstract value constraint pairs which we design in a way to support heap decomposition v v k c l s true false where k is a struct value cis a constant lis a normal location and sis a symbolic location.
the constraint operators have the same meaning with their corresponding boolean operators except for equality.
the equality operator does not evaluates if any of its operands is a symbolic location because a symbolic location represents an arbitrary value.
when a constraint becomes false a pair of an abstract value and the constraint is removed from an abstract value set.
while pointer alias relations among parameters make multiple ways to construct an initial heap heap decomposition allows a single heap to represent multiple heaps.
for example if two pointer parameters xandypoint to the same location the initial heap maps their locations lxandly to one symbolic location s. otherwise it maps lxandlytosxandsy respectively.
using heap decomposition we can unify the two heaps to and decompose it by resolving the constraints.
a parameter environment dis a points to map from locations to locations.
heap log composition instantiates symbolic locations in a final heap of a callee using the parameter environment as we describe in section .
.
.
the initial heap and the parameter environment of setfunction in figure a are as follows 130broadening horizons of multilingual static analysis ase september virtual event australia lx lys2 s4s3 s5true s2 s 4s2 s4 s2 s 4true ltmp lx lys1 s2 s5true s1 s s1 s 2true s1 s2s1 s s1 s2ho s1d lx lys2 s4s3 s5hi lthiz s1 s1true lthiz where lthiz lx and lyare locations of thiz x and y respectively circles denote symbolic locations and labeled directed edges denote points to relations with constraints.
since lxandlypossibly point to the same location due to the method call on line lypoints to s2under the constraint s2 s4meaning the two arguments are the same or points to s4 otherwise.
the parameter environment dis constructed from parameter types.
for each pair of a parameter location lpand the type of the parameter we allocate a new symbolic location stolp.
if the type is we recursively allocate a new symbolic location to a pair of sand .
theinit rule defines how to construct input states a h0 i n.b hi d initp e xi i true hi e b d init x 1 ...xn n hn b d s b h d initp h c d s b s 1 ... n h1 h 7 i n. i j i.s j s i 1 i n.s i h2 h1 b h2 d initp s 1 h3 b h d initp h3 where eis an environment map from variables to their locations and bis an alias map from symbolic locations to sets of peer locations that are possibly referred by alias pointers.
while one can construct alias maps using heuristics because an imprecise alias map may increase analysis overhead dramatically we construct it using steensgaard s points to analysis as a pre analysis.
theinit rule a is the entry of input state construction.
starting from an empty heap h0 it subsequently updates heap for each triple of a parameter location a parameter type and the trueconstraint.
theinitp rule b handles a location of a primitive type such aslthiz s2 and s4inhiofset.
it obtains a symbolic location sof the address from the parameter environment dand simply maps the location to a pair of sand the current constraint inh.
theinitp rule c is for a location of a pointer type such as lxandly.
it first obtains a symbolic location sof the address from the parameter environment d. then for each peer location iofs it allocates ito under the constraint j i.s j s i which denotes that points to iifsis equal to only iand exists.
it also allocates sto under the constraint i n.s i meaning that sis not equal to any other locations and exists.
finally it recursively updates heap for s under the existence constraint of s. .
.
intra procedural analysis.
intra procedural analysis abstracts the semantics of a function fas an output state ho loby applying abstract transfer functions through control flows.
the analysis captures foreign function call information on line as follows h ho lx lys2 s4s3 s5true s2 s 4s2 s4 falsefalselthiz s1true s6 s7s2 s s2 s4ho lo s6 getfieldv l l2 s7 getfieldv l l4 s2 s 4lx lys2 s4s3 s5true s2 s 4s2 s4falselthiz s1true s6ho true s2 s lx lys2 s4s3 s5true s2 s 4s2 s4 falsefalselthiz s1true s6 s7s2 s s2 s4ho lo s6 getfieldv l l2 s7 getfieldv l l4 s2 s 4lx lys2 s4s3 s5true s2 s 4s2 s4falselthiz s1true s6ho true s2 s lo s6 getfield l1 l2 s7 getfield l3 l4 figure heap after line and the output state of set s6 getfield l1 l2 where the first component is a list of call sites the second is a symbolic location representing a return value the third is the name of a foreign function the fourth is a list of normal locations that point to argument values and the last is a heap snapshot.
the following rule specifies how to capture foreign function call information s symbolic loc l normal loc e h e h1 slice h h2 h1 l1 l i s f l h2 e h l ix f e h e x s true l1 where symbolic loc creates a new symbolic location normal loc creates a new normal location and slice h creates a new heap that includes only reachable locations from inh.
this rule evaluates all the argument expressions eto abstract value sets and captures the foreign function call information with h2that contains mappings from argument locations lto .
by this rule the analysis also updates the initial heap to h hi for capturing the return value assignment.
figure presents the heap after line and the output state of the function set.
on line the analysis maps s2pointed by lxto s6pointed by lx ovia the following abstract transfer function e h e1 e h e2 h1 h 7 h e h l e1 e2 h1 l the operator is defined as follows v1 1 ... vn n i n. vi i which means that when storing to an address that exists under a constraint it allocates to only if is satisfied.
in other words it preserves the previous value of if is not satisfied.
thus the mapping from s2tos3becomes infeasible by negating the constraint and a new mapping from s2tos6is created.
on line a new foreign function call is captured and added to the log in a similar way.
on line the analysis maps both s2ands4 pointed by lytos7pointed by ly o. it first changes the constraint of a mapping from s2tos6tos2 s4 because s2points to s7under 131ase september virtual event australia sungho lee hyogun lee and sukyoung ryu s2 s4 then it creates a new mapping from s2tos7.
similarly it changes a mapping from s4tos5and maps s4tos7.
.
.
heap log composition.
our analysis handles interprocedural semantics by composing a callee s analysis result with the state at a call site.
it first constructs an instantiation environment iby structurally mapping symbolic locations in dof a callee to argument values.
on line in figure the first argument is sobj1 true the second is la true and the third is lb true .
by structurally mapping symbolic locations in dofsetto the arguments we can construct ias follows i s17 sobj1 true s27 la true s47 lb true s37 s57 where s3ands5map to the empty set denoting the bottom value since both laandlbdo not point to any values at the call site.
using the instantiation environment the analysis instantiates the output state of a callee and composes it with the current state hr i inst heap he h1 hr i compose heap hr he h1 le s1 f1 l1 h1 ... n sn fn ln hn i n.hr i inst heap hi h i l1 lr i n. r i si fi li h i hr i compose log r lr le l1 where hrandlrare caller s heap and log heandleare callee s and ris the call site.
using hrandi inst heap substitutes symbolic locations in callee s heap with the argument locations and compose heap composes callee s heap with caller s heap.
similarly compose log instantiates all the heap snapshots of foreign function calls in callee s log and composes it with caller s log.
the composition results on lines and are as follows h lobj17 sobj1 true la7 s6 true lb7 s7 true l s6 getfield l1 l2 l17 sobj1 true l27 f true s7 getfield l3 l4 l37 sobj1 true l47 g true h l s6 getfield l1 l2 l17 sobj2 true l27 f true s7 getfield l3 l4 l37 sobj2 true l47 g true note that on line s2 s4istrueands2 s4isfalse because the constraints are instantiated to la lbandla lb respectively.
on the contrary on line s2 s4isfalse ands2 s4istruebecause both s2ands4are instantiated to lc.
finally by composition on lines and the analysis produces final logs of f1andf2as shown in figure .
.
.
semantic summary generation.
as shown in figure b a semantic summary is a function like structure that consists of parameters a sequence of statements and a return value.
a statement is one of a foreign function call a conditional branch and a philf1 o s6 getfield l1 l2 l17 sobj1 true l27 f true s7 getfield l3 l4 l37 sobj1 true l47 g true s9 invoke l5 l6 l7 l57 s6 true l67 foo true l77 s7 true lf2 o s6 getfield l1 l2 l17 sobj2 true l27 f true s7 getfield l3 l4 l37 sobj2 true l47 g true s9 invoke l5 l6 l7 l57 s7 true l67 foo true l77 s7 true figure final foreign function call logs of f1and f2 1package com.
example 2public class app static system .
loadlibrary example obj foo ... obj bar obj arg ... obj exec return callc native obj callc a java code jobject java com example app callc jnienv env jobject thiz jclass cls env getobjectclass env thiz jmethodid mid env getmethodid env cls foo lobj jobject res env callobjectmethod env thiz mid return res b c code in example.c figure java and c interoperation statement.
conditional branches represent control flows among foreign function calls which are useful for client analyses and phi statements represent join points.
the summary generator converts the output state of each function callable from the host language to a semantic summary.
it obtains a return value from a final heap and extracts a sequence of foreign function call statements from a log.
then it constructs control flows among foreign function calls and converts each foreign function call to a foreign function call statement by substituting each argument location and symbolic location with its mapped value in a heap snapshot and a variable respectively.
when the heap snapshot maps a location to a set of multiple values the summary generator inserts a phi statement to join the set of values and substitutes the location with the return variable of the phi statement.
when a parameter location points to a symbolic location the summary generator converts the symbolic location to the parameter variable.
for example it converts the first foreign function call of lf1 oin figure to loc s6 ffi getfield arg obj1 const f .
132broadening horizons of multilingual static analysis ase september virtual event australia jni program analysis .
jni interoperation jni is an ffi supported by jvm which supports interoperation between java and c. using jni java code can call c functions and c code can call java methods and get or set values of java objects.
figure shows a simple example of java and c interoperation.
the java method callc of class appon line is a native method declared with the native keyword which does not have any method body.
when jvm loads a c library named example on line it binds the native method callc with a c function in the example library.
the target c function to bind is usually determined by jni naming convention the name begins with the prefix java the mangled fully qualified class name and the mangled method name of the native method where the names are separated by one underscore and optionally followed by parameter signatures with two underscores for overloaded native methods.
therefore the native function callc is bound to the java com example app callc function.
when invoking the native method the bound c function is called.
on the other hand c code invokes a java method via jni functions pre defined in the jni.h file.
the example c code has three jni function calls getobjectclass that returns a class identifier of a java object passed as its argument getmethodid that returns a method identifier using a given class identifier and a method name and a signature and callobjectmethod that calls a java method denoted by the class identifier and method identifier which returns a value of type object .
on line the java com example app callc function calls the foojava method and returns a value that fooreturns.
note that jni supports bidirectional and explicit interoperation and static binding using its naming convention by default.
in addition it also supports the dynamic binding feature which enables c code to create and change bindings at run time.
when calling the registernatives jni function with a class identifier a method name and signature and a c function pointer in c jvm creates a new binding between the java method denoted by the class and method information and the c function.
.
jni program analysis using c summaries now we explain how we implemented the multilingual program analysis illustrated in figure for jni programs.
we implement summary extraction on top of infer a modular static analysis framework for c and c developed by facebook.
it analyzes the c code in a given jni program and extracts semantic summaries for the c functions accessible from the java code in the jni program.
then summary to host lang.
transforms the extracted summaries to java code and code injection injects the transformed java code to the jni program by substituting a java native method body with its corresponding java code.
forhost static analyzer we use flowdroid a static analyzer for java and android java programs built on top of soot.
the transformed jni program still contains some opaque method calls for jni function calls like getobjectclass getmethodid and callobjectmethod in figure .
to handle them we extended flowdroid by building models for the jni function semantics accordingto the jni specification .
using the models flowdroid analyzes transformed jni programs and produces their call graphs as analysis results.
for the example in figure flowdroid analyzes the transformed java method corresponding to the native method callc and infers the reachable method fooon line from exec on line and the return value of exec as the return value of foo.
we also partially support the dynamic binding feature of jni.
since registernatives takes arrays containing strings and function pointers as an input precise analysis of the argument value is challenging.
moreover because it changes bindings between a java native method and c function at run time our analysis cannot substitute the body of a native method with a c function summary.
thus we reflect the dynamic binding semantics only under two conditions the arguments are analyzed precisely in the summary extraction phase and the dynamic binding occurs in the onload c function executed right after loading the c library which is a common programming pattern in android jni programming .
if the two conditions are satisfied we bind a java native method and a c function using the argument information instead of the static binding based on its naming convention.
note that the code injection is performed in bytecode level by flowdroid rather than source code level in the current implementation because of the practical reason that the front end of soot for java source code analysis is outdated .
thus our analysis takes both a compiled jni program and its source code injects the bytecode of extracted c semantic summaries from the source code and analyzes the jni program.
.
client analyses for bug detection we implemented a client analyzer that detects two kinds of jni interoperation bugs.
the first kind of jni interoperation bugs is wrong foreign function calls.
as described in section .
the jni specification defines how java code calls c functions and c code calls java methods.
when executing a foreign function call in a wrong way either a runtime error occurs or an unexpected behavior happens because such cases are unspecified in the specification.
we implemented a client analyzer on top of flowdroid it inspects wrong static bindings between java native methods and their corresponding c functions and wrong java method calls from c code.
the second one is mishandling of java exceptions.
when a java exception is pending c code should handle the exception explicitly or return to java immediately to handle the exception in the java side .
otherwise the behaviors of subsequent jni function calls are unspecified.
our analyzer tracks exception flows in a similar way to li and tan but analyzes more program flows by tracking exception flows over the language boundaries between java and c. evaluation to show effectiveness of the proposed approach we evaluated our jni program analysis in two perspectives feasibility and practical usefulness.
for feasibility we analyzed a benchmark set of android jni applications nativeflowbench which contains android applications that use various interoperation features such as uni and bidirectional interoperation native method overloading dynamic binding and so on.
we use out of benchmarks 133ase september virtual event australia sungho lee hyogun lee and sukyoung ryu table analysis results of real world android jni applications call c j getfield c j setfield c j time sec.
name loc c precise resolved total precise resolved total precise resolved total c java graph .
.
apv pdf viewer .
.
lumicall .
.
timidity ae .
.
plumble .
.
commonslab .
.
crosswords .
.
sipdroid .
.
xmp mod player .
.
droidzebra .
.
fwknop2 .
.
taps of fire .
.
agram .
.
votar .
.
total table analysis results of nativeflowbench benchmarks benchmark result benchmark result native complexdata icc nativetojava native compexdata stringop native heap modify native dynamic register multiple native leak native leak dynamic register native leak array native method overloading native noleak native multiple interaction native noleak array native multiple libraries native nosource native set field from arg native source native set field from arg field native source clean native set field from native because four applications are inappropriate for evaluating the proposed jni program analysis three benchmarks do not use interoperation and the remaining one has a sole entry point in c code which flowdroid cannot analyze.
for practical usefulness we analyzed real world android jni applications available from f droid which is an open source repository collecting android applications.
finally we report genuine interoperation bugs detected from ten android jni applications.
.
feasibility table shows the analysis results of benchmarks in nativeflowbench.
the first and third columns denote benchmark names and the second and fourth columns show whether the analysis results succeeded or failed .
an analysis result succeeds if all foreign function call sites are resolved precisely and it fails otherwise.
a foreign function call site may perform one of four kinds of interoperation java to c function call call j c c to java method call call c j c to java field access getfield c j and c to java field update setfield c j .
because c accesses and updates the values of java object fields via jni function calls in the same way as java method calls a foreign function call site may perform getfield c j and setfield c jas well.
for call j cand call c j we counted the number of outgoing edges at call sites in a call graph and considered them as precise if the number is one.
for getfield c jand setfield c j we checked the number of field accesses at call sites instead of value propagation because flowdroid does not propagate constant values.table jni interoperation bug detection results name wrong ff call exception mishandling graph 89wrongdesc typemismatching apv pdf viewermissingfun typemismatching lumicall missingfun unsafesubsequentcall sipdroid missingfun unsafesubsequentcall votar wrongdesc taps of fire wrongdesc xmp mod player wrongdesc crosswords missingfun droidzebra missinghandling netguard inappositehandling our jni program analysis successfully analyzed out of benchmarks which use bidirectional interoperation dynamic function binding and native method overloading as well as complex data structures in c code.
it failed to analyze one benchmark that concatenates two string values via the strcat built in c function and uses it to obtain an identifier of a java method.
because our analysis does not handle such kinds of built in c functions it could not analyze native compexdata stringop.
.
practical usefulness we experimentally evaluated call graph construction of our jni analyzer with real world android jni applications.
table summarizes the analysis results of out of applications which have accesses of java fields and methods in c. the first column shows package names of the applications the second column shows the size of c code in the application the third to fifth columns denote the numbers of resolved c to java method calls c to java field accesses and c to java field updates respectively.
the last column shows the analysis time of semantic summary extraction c and whole program analysis java .
the sub columns precise resolved and total denote the numbers of precisely resolved call sites resolved call sites and total call sites respectively.
we considered a resolved foreign function call as precise when the analysis 134broadening horizons of multilingual static analysis ase september virtual event australia produces a single target method or field for the call.
because no applications use dynamic binding and because java to c method calls are resolved by syntactic naming convention we omit call j c. our jni program analysis resolved out of c to java method calls out of c to java field accesses and out of c to java field updates.
in addition out of resolved foreign function calls are precise.
as the analysis time shows the analysis is scalable enough to analyze large size jni programs.
the most time consuming process is extracting semantic summaries.
the extraction time is almost linear to the size of c code but it took only about minutes at most to analyze over lines of c code.
note that once we extract a semantic summary for a c function we can reuse the summary multiple times in a whole program analysis until the c function code changes.
the analysis failed to resolve out of foreign function calls in total due to two reasons.
first since our semantic extractor does not handle opaque functions like built in libraries the analysis may miss them and the analysis results could be unsound.
second because the semantic extractor does not precisely handle all complex c features like pointer arithmetic operations the analysis results may be imprecise.
for such complex features the analysis over approximates unknown locations as the top location and ignores store operations on the top location to avoid too much imprecision while making analysis results unsound.
we also analyzed the apps using jn saf a state of theart android jni app analyzer that analyzes both java and binary code.
it constructs call graphs of jni apps and performs data flow analysis through call flows to identify sensitive data leakage.
in our experiment jn saf failed for all apps it exceeded its internal time limit for six apps produced errors for two apps did not analyze binary code at all for four apps and did not analyze jni function calls for two apps.
this experiment shows that our jni analysis is more effective than the state of the art analyzer when jni programs source code is available.
.
jni interoperation bug detection we detected wrong foreign function call bugs in eight and java exception mishandling bugs in four out of android jni applications.
we categorized the detected bugs into six types missingfun typemismatching and wrongdesc for wrong foreign function call bugs and unsafesubsequentcall missinghandling and inappositehandling for java exception mishandling bugs.
table presents the bug detection results for each application it shows the name and the number of each bug type.
.
.
wrong foreign function call bugs.
figure presents example wrong foreign function call bugs in real world jni applications.
figure a shows a code snippet with the missingfun bug in sipdroid.
while a native method inheritedchannelimpl is declared in java the corresponding c function is commented out.
when java code calls such a native java method that is not bound to any c function it results in throwing runtimeexception .
note that because the bug exists in a library module that is publicly available it may make other applications vulnerable as well.
indeed we observed that our tool detected the same bug in lumicall which integrates the library module.
osnetworksystem .
java native channel inheritedchannelimpl osnetworksystem .cpp jobject java org sipdroid net impl osnetworksystem inheritedchannelimpl a missingfun pdf.
java synchronized private native int parsefile pdfview2 .c void java cx hell android lib pdf pdf parsefile b typemismatching dbus .c jmethodid method dbusjnienv getstaticmethodid dbusjnienv class receivefile ljava lang string ljava lang string v dbusjnienv callstaticintmethod dbusjnienv class method jsrc jdst c wrongdesc figure three types of wrong foreign function call bugs figure b shows a code fragment with the typemismatching bug in apv pdf viewer where the native method that returns intis bound to a c function that returns void .
figure c shows a c code snippet with the wrongdesc bug in graph .
even though the code receives an identifier of a java method that returns void it calls the method as it returns intviacallstaticintmethod .
these two bugs may not lead to errors if the return values are not used by their subsequent instructions.
however because the jni specification does not specify how the jni interoperation works in such cases they may have different behaviors on different jvms.
actually the third case introduces a runtime error on android runtime even when the return value is not used but not on the oracle jvm.
.
.
java exception mishandling bugs.
figure presents simplified examples of java exception mishandling bugs we detected.
figure a shows a code snippet with the unsafesubsequentcallbug in sipdroid.
if getstaticmethodid on line returns null it implies that an exception is thrown in java and it is pending.
the jni specification describes that when an exception is pending subsequent jni function calls except for a small number of jni functions are unsafe .
in this example the call of jnithrowexception on line invokes findclass on line and thrownew on line which are jni functions leading to unsafe behaviors in jni interoperation.
figure b shows a code fragment with the missinghandling bug in droidzebra.
the droidzebra json get int function calls the getint method of the jsonobject class via a sequence of jni function calls on lines to and returns 1on line if the method throws jsonexception .
unfortunately it checks only the existence of an exception without handling it and the java side does not handle the exception either.
thus because the exception is not handled appropriately the application may terminate abnormally.
figure c shows a code snippet with the inappositehandling bug in netguard.
the jninewobject function prints a log on line 135ase september virtual event australia sungho lee hyogun lee and sukyoung ryu c 2int jnithrowexception ... jclass ec env findclass classname if ec null return if env thrownew ec msg !
jni ok assert !
failed to throw return 9void onetimeinitializationimpl ... jmethodid m env getstaticmethodid ... if m null jnithrowexception ... return ... a unsafesubsequentcall java 2public void run zeplay null c 5jint droidzebra json get int jobject json jclass cls env getobjectclass json jmethodid mid env getmethodid cls getint ... value env callintmethod json mid ... if env exceptioncheck return return value void jnifn droidzebra zebraengine zeplay ... ... evt.
type droidzebra json get int json if evt.
type ui event exit force exit break ... b missinghandling c 2jobject jninewobject ... jobject obj env newobject ... if object null log android ... else jnicheckexception env return object c inappositehandling figure three types of java exception mishandling bugs when newobject returns null .
otherwise it handles a pending exception via jnicheckexception .
however a java exception is pending during newobject execution if and only if it returns null .
thus the exception handling is unreachable and the pending exception may cause unexpected behaviors in subsequent instructions.
.
remaining challenges complex language semantics.
while our semantic summary extraction generated precise summaries for our target guest language the actual c language has more complex syntax and semantics than the target language like global variables arrays and arithmetic operations.
because it is challenging to analyze such language constructs statically we over and under approximate their semantics which leads to the semantic summary extraction missing someinteroperation behaviors as shown in the evaluation.
our future work includes extending the target guest language close to c. implicit language boundary.
because semantic summary extraction collects the information of foreign function calls at language boundaries explicit language boundaries are essential to apply our approach.
however some languages like java and javascript interoperate with each other over implicit language boundaries which make our approach inapplicable .
it may be able to support implicit language boundaries by making the boundaries explicit first via a pre analysis before extracting summaries.
client analysis.
in addition to two interoperation bugs we detected more buggy cases in jni programs may originate from differences between java and c. for example their different memory management models can cause reference bugs .
we plan to extend our analysis to detect various kinds of jni interoperation bugs.
related work static analysis for jni programs.
researchers have proposed compilation based approaches that transform one language to another to statically analyze jni programs.
droidnative transforms java bytecode to binary code and performs signature based malicious pattern matching for both transformed binary and android native code.
ilea compiles c code to extended java virtual machine language jvml and detects a null related bug using modified jlint.
since java and c have different expressiveness the approach requires extension in jvml as well as modification in java static analyzers.
in addition it extremely over approximates c pointer operations like load andstore via pointers because the extended jvml cannot simulate the c memory model.
unlike ilea our approach properly handles c pointer operations even without modifications in host languages and host language static analyzers.
jn saf performs a modular analysis for java bytecode and symbolic execution for binary code separately and composes their data flows to detect malicious behaviors.
unlike jn saf we propose a general purpose multilingual analysis and bug finding mechanism.
our approach is scalable to analyze large real world android applications while jn saf has the scalability issue due to the path explosion problem of symbolic execution.
hybrid analysis for jni programs.
hirzel et al .
proposed a hybrid approach that executes jni programs during static analysis to utilize run time values propagated between java and native code using an instrumented jvm.
while the approach is acceptable when only native code is available they always over approximate return values at all locations.
on the other hand our semantic summaries capture the bidirectional interoperation semantics including foreign function calls and return values if source code is available.
static analysis for other multilingual programs.
recent researchers have proposed static analysis techniques for android hybrid applications implemented in java and javascript.
brucker and herzberg construct call graphs for java and javascript separately and compose the call graphs using several heuristics.
hybridroid performs a pointer analysis over language boundaries using interoperation semantic models and produces unified call graphs.
bae 136broadening horizons of multilingual static analysis ase september virtual event australia et al.
have devised a bug detection technique for hybrid applications using a javascript type checker with pre analysis results for java.
because all of them focus on a specific application domain they are not applicable to other multilingual program analysis like jni programs.
conclusion multilingual programs take advantage of various features provided by multiple languages expanding expressivity.
however existing static analysis techniques do not help developers implement reliable multilingual programs.
in this paper we propose a novel static analysis approach for multilingual programs.
our approach extracts semantic summaries from programs written in guest languages.
with the extracted semantic summaries a static analyzer for a host language performs a whole program analysis.
to evaluate the practicality of our approach we developed a static analyzer that analyzes jni interoperation between java and c. we showed that our analyzer can analyze large scale real world jni programs that use various kinds of interoperation precisely and efficiently.
moreover we detected genuine jni interoperation bugs caused by developer mistakes in real world android applications.
we believe that our approach can broaden the analysis scope of static analyzers for multilingual programs and our open source jni program analyzer can help developers find interoperation bugs in their programs.