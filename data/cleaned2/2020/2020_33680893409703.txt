calm energyaccountingformultithreaded java applications timur babakol tbabako1 binghamton.edu suny binghamton binghamton ny usaanthony canino acanino1 binghamton.edu suny binghamton binghamton ny usakhaled mahmoud kmahmou1 binghamton.edu sunybinghamton binghamton ny usa rachitsaxena rsaxena3 binghamton.edu suny binghamton binghamton ny usayu davidliu davidl binghamton.edu suny binghamton binghamton ny usa abstract energy accounting is a fundamental problem in energy management defined as attributing global energy consumption to individual components of interest.
in this paper we take on this problem attheapplicationlevel wherethecomponentsforaccountingare application logical units such as methods classes and packages.
givenajavaapplication ournovelruntimesystem chappie producesan energyfootprint i.e.
therelativeenergyconsumptionof allprogrammingabstractionunitswithin the application.
the design of chappie is unique in several dimensions.
first relative to targeted energy profiling where the profiler determines theenergyconsumptionofapre definedapplicationlogicalunit e.g.
a specific method chappie istotal the energy footprint encompassesallmethodswithinanapplication.second chappie is concurrency aware energyattributionisfullyawareofthemultithreadedbehaviorofjavaapplications includingjvmbookkeeping threads.third chappieisanembodimentofanovelphilosophyfor application levelenergyaccountingandprofiling whichstatesthat the accounting run should preserve the temporal phased power behavioroftheapplication andthe spatialpowerdistributionamong the underlying hardware system.
we term this important property ascalmness.againststate of the artdacapobenchmarks weshow that the energy footprint generated by chappie is precise while incurring negligible overhead.
in addition all results are produced withahigh degree ofcalmness.
ccs concepts software andits engineering software performance .
keywords energy accounting energy profiling power disturbance concurrency permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse november 8 13 virtual event usa associationfor computing machinery.
acm isbn ... .
format timur babakol anthony canino khaled mahmoud rachit saxena and yu david liu.
.
calm energy accounting for multithreadedjava applications.inproceedingsofthe28thacmjointeuropeansoftwareengineering conferenceandsymposium on the foundationsof softwareengineering esec fse november 8 13 virtual event usa.
acm new york ny usa 13pages.
introduction application levelenergymanagementhasemergedasanimportant dimensionofenergy efficientcomputing withsolutionssharing acommonpremise the logicalunits withinanapplicationmatter in energy management.
in this paper we revisit energy accounting a fundamental problem that has been extensively studied at the lower layers of the computing stack .
our new focus is on the application level determining the energy consumption of individual application logical units given the total energy consumption of the application.
this problem subsumes important questions in green software development e.g.
which methods consumethemostenergyinanapplication whichmethodsleadthe underlying system to a higher power state or how to compare the energy power consumption of two methods.
answering these questionssystematicallymaysignificantlyimpactthestateofthe art of energy aware programming energyadaptive software framework design energy testing and debugging and energy oriented approximation .
at first glance the problem of application level energy accountingmayappeardeceptivelysimple.todeterminetheenergyconsumption of method m a naive approach may reduce it to a trivial energymeasurement problem onemayinstrument matitsentrance and exit program points obtain a pair of energy readings from the underlying hardware and compute the difference of the two.
this naive approach however is flawed or at best impractical for tworeasons.
accounting totality.
important questions such as which method consumesthemostenergyinanapplicationrequirestheknowledge of energy consumption for all methods in an application.
iterating overeverymethodwithaninstrumentationapproachdoesnotscale forrealisticapplications theoverheadbecomesunrealisticallyhigh see 2 when allmethodsare accountedfor at the same time.
multi threading.
morefundamentally theinstrumentation based approach is concurrency oblivious whichmay leadtosignificant esec fse november8 virtualevent usa timur babakol anthonycanino khaledmahmoud rachitsaxena andyudavid liu foo barfoo time garbage collector figure the challenge of accounting for the energy consumptionofmethod foowithamulti threadedapplication over accounting.this is particularly badnews for server type applicationswheremulti threadedprogramsonparallelplatformsare therule nottheexception.considerfigure .theinstrumentationbasedapproachmayattributetheentireenergyconsumptionduring the execution of footo the method without considering a portion of such consumption results from the execution of bar or even anotherinstanceof foo.inaddition managedlanguageruntimes may have co running virtual machine vm bookkeeping threads such as the garbagecollector.
beyondthesetwochallengesinenergyaccountingsystemdesign athirdone existsagainst producing high qualityresults.
disturbance.
any runtime system design that profiles the applicationneedstoensurethattheruntimeprofilingmechanismsdo not significantly alter the behavior of the original application.
this well knownproblemisusuallycopedwiththroughensuringthe executiontimeoverheadoftheprofilerunisnegligiblecompared to the original run.
profiling for energy however introduces a new layerofsubtlety.theprofilerbehaviormayalterthepowerstate oftheunderlyinghardware leadingtotwoconsequences.first a changeinthepowerstatesiscorrelatedwiththecpufrequency change sothatexecutiontimeisnolongerareliableindicatorof disturbance.
second as energyistheaccumulated effectof power thedisturbanceofpowerconsumptionalterstheverybehaviorthat theprofilertriestoaobserve challengingthevalidityoftheresults from energy accounting.
.1chappie wepresent chappie atotal concurrency aware disturbance mitigated application levelenergyaccountingsystemforjavaapplications.
withchappie the execution of each application can produce an energyfootprint i.e.
therelativeenergyconsumptionofallprogramming logical units within the application.
for example figure isatop 10energyfootprintforarealisticjavaapplication h2 .
itshowsvaluedatatype.compare isthemostenergy consuming methodintheapplication.furthermore itshowstherelativeenergy consumption difference between any pair of methods such aspage.binarysearch andvaluedatatype.comparevalues .
in additiontomethods chappieiscustomizablesothattheunitinan energyfootprintcanbecourser grainedasclassesandpackages orfiner grainedas callingcontextsto methods.
at its heart chappie is a novel sampling based runtime system thatdrawsinformationfrommultiplelayersofthecomputingstack and composes it to provide the energy footprint.
on the jvm level chappie samples the per thread call stacks determining which methods are currently executing at each sample.
on the hardware level chappie is able to sample the raw energy readings.
when .
.
.
.
.
.
.
.
.
aware vs oblivious attributed energy ratiomethod valuedatatype.getmemorytransactionstore.getoperationidobjectdatatype longtype.comparevalue.comparetypesafecursor.fetchnextmvmap.comparevaluearray.getmemorypage.createvaluedatatype.comparepage.binarysearchfigure method grained energy footprint for h2 the xaxis represents the percentage of energy consumption consumedbyaparticularmethod.they axisliststhemethods with top energy consumption with the most consuming oneat thetop.
multiplethreadsareactiveuponthereceiptofarawenergysample chappieisabletodistributeashareofthelatteramongallrunning methods eachofwhichresidesonthecallstackofanactivethread.
thecorealgorithmof chappie combinesthehigh levelinformationwiththelower levelone withfullawarenessofconcurrency.
despiteitscross layernature chappieisalightweight designwith nomodificationstotheapplicationcode thecompiler thejdk the jvm the os orthe hardware.
anotherhighlightof chappieisittreatsaccountingdisturbance as a first class concern.
while overall execution time overhead and overallenergyconsumptionoverheadmayprovidesomeinsight into how an accounting system may affect the application to be accountedfor theyareinsufficienttoquantifydisturbanceinenergy accounting.
.
calmenergy accounting chappiefeaturescalm energy accounting with a novel fine grained metric to ensure the accounting system does not temporally and spatiallydisturb the energy behavior of the original application so thattheenergyfootprintfaithfullycaptures thecharacteristicsof theoriginalapplication.toelaborate letusconsiderthescenario infigure whereanapplicationrunsona2 coremachine cpu1 andcpu2 eachofwhichmayoperateattwocpufrequencies 1ghz and2ghz.the metric of calmness subsumestwoideas.
temporal calmness.
the accounting run should preserve the powerphasedbehavior oftheoriginalapplication i.e.
the power consumption of an application may vary from timestamp to timestampandtogethertheymayformapattern.thiswell known phenomenonresultsfrom time dependentapplicationcharacteristics such as parallel vs. serial phases latent in multi threaded applications andcpu intensivevs.i o intensivephasedbehaviors.
the power variation is usually enabled by dynamic voltage and frequencyscaling dvfs astandardfeaturesupportedbythe vast majority of cpus and enabled as default by most operating systems.
in figure 3b observe that the accounting run drives both 977calmenergyaccountingformultithreadedjava applications esec fse november8 virtualevent usatemporalcpu ghz ghz ghz cpu ghz ghz ghzoriginal run t1 t2 t3sampling epoch a temporalcpu ghz ghz ghz cpu ghz ghz ghzaccounting run t1 t2 t3sampling epoch b spatialcpu ghz ghz ghz cpu ghz ghz ghzoriginal run t1 t2 t3sampling epoch c spatialcpu ghz ghz ghz cpu ghz ghz ghzaccounting run t1 t2 t3sampling epoch d figure temporalpowerdisturbance figure a b andspatial powerdisturbance figure c d cpu1andcpu2to operate at 2ghz at an earlier timestamp than the original application as shown in figure 3a.
even though the accumulatedenergyofthetworunsmaywellcorrespond thetworuns do not exhibit the same power behavior which we call temporal powerdisturbance .inanutshell temporalpowerdisturbanceisa symptom ofthe phasedbehaviorchangeofthe application.
spatialcalmness.
theaccountingrunshouldpreservethe power distributionbehavior oftheoriginalrun i.e.
thepowerconsumptionoftheunderlyingsystemmayvaryfromcpucoretocpucore andtogethertheymayformapattern.thiswell knownphenomenon results from application characteristics such as symmetric vs. asymmetricworkloads and the level of parallelism enabled by the application scheduler interaction.
the power variation is again enabledbydvfs whereahigherworkloadusuallydrivesthecpu toahigher frequencystate hencehigher powerconsumption andviceversa.infigure 3c thepowerdistributionbetween cpu1 andcpu2are lopsided whereas in figure 3d the two are more balanced.
even though the accumulated energy of the two runs maywellcorrespond whichwecall spatialpowerdisturbance .in essence spatialpowerdisturbanceisasymptomoftheworkload behaviorchangeofthe application.
we evaluate chappie over state of the art dacapo benchmarkswithdiverseandrealisticworkloads.weshowthat chappie cansuccessfullyproducetheenergyfootprintforallbenchmarks.
by judiciously setting the sampling rates chappie can achieve bothtemporalcalmnessandspatialcalmnessforallbenchmarks.
when calmness is achieved the time and energy overhead are negligible with an average runtime overhead of .
.
and anaverage energy overhead is .
.
across all benchmarks.
we furthershowthattheproducedenergyfootprintsareprecise the energy footprint converges when samples from additional runs are included.
contribution.
this paper makes the following contributions a novel and customizable energy accounting design that produces an energy footprint illustrating the relative energy consumption ofallprogram logic units.
asampling basedcross layer designthatallowsfor concurrencyawareenergy accounting for multi threaded java applications a novelcalmness metric for quantifying power disturbance inapplication level energy accounting anevaluationdemonstratingtheeffectivenessof chappie in understanding the energy behavior of realistic java application chappie is an open source project hosted at an anonymous website .
2chappie motivation in thissection we briefly motivatethe need for chappie quantitatively.
accounting totality with instrumentation.
in order to support totality in energy accounting an instrumentation based approach would either need to iteratively instrument each method or instrumentallmethodsatonce.theformerwouldleadtoalargespace toconsider.thelatterapproach despiterequiringfewruns may 978esec fse november8 virtualevent usa timur babakol anthonycanino khaledmahmoud rachitsaxena andyudavid liu table overhead with the instrumentation based approach the instrumentation x column shows the time overhead when every method in the benchmark is instrumented and x of the invocations are randomly selected to take energy readings.
the instrumentation was performed through javassist .
all benchmarks appearing in this section are fromthedacapobenchmarksuite .
instrumentation100 instrumentation5 sunflow 189x 164x batik 118x 117x xalan 30x 29x h2 25x 16x table energy over attribution due to concurrencyobliviousaccounting thefirstcolumnliststop consuming h2methods reported by chappie and the second column reports the ratio of over attribution if concurrency were ignored.
methodname over attribution valuedatatype.compare .88x page.binarysearch .20x mvmap.compare .82x mvmap.binarysearch .27x localresult.next .43x sampling rate ms 50normalized energy time power h2 energy time power figure h2disturbance the x axis represents different sampling rates.
the y axis represents the normalized difference between the accounting run and the original nonaccounting run.
each group consists of three bars the energy time powerconsumption.theerrorbarsindicatestandard deviation.
leadtosevereoverhead.table 1showstheoverheadofthelatter approach.evenwiththeaggressiveomissionofenergyreadings that approach still yields a significant overhead.
a compiler based approach ofselectiveinstrumentationmayhelp butwiththegap beingsolarge itisunlikelysuchanapproachwouldproduceresults withpracticallyviable overhead.note that even if the instrumentation based approach can get overthehurdleoflongiterationorsignificantoverhead suchan approach is still fundamentally concurrency oblivious during the executionbetweenthemethodstartandend othermethodsmay be co running.
concurrency oblivious accounting.
to quantify the impact of concurrency awareness we construct an experiment to show how muchenergyover attributioncouldhappenshould chappieignore multi threading.asthisexperimentisonlyformotivationpurposes we take the simple approach of assigning of each energy sample to a method if its host thread is active in that sampling interval whenmultiple threadsare active duplicated assignments are possible.
we show these results in table .
the take away message here is that a concurrency oblivious energy accounting designmayleadtosignificantover attributionofmethodenergy consumption.
power disturbance.
our investigation into calmness was motivatedbythecounter intuitivebehaviorofsomebenchmarksduring the early stageofthe chappie evaluation.
ourintuitionwasthatthebookkeepingofaccountingmaycarry some overhead so the accounting run would be slower than the originalrun.someexperimentshoweverrevealedanoppositetrend.
as shown in figure ifchappie had set the sampling rate at millisecond ms theexecutionof h2wouldturnouttobenearly fasterthanthe originalnon accounting run!
thekeytoresolvingthisbafflingmysteryispowerconsumption.
as it turns out the sampling rate of 1ms would lead to nearly a ofpowerincrease thesampling basedapproachperiodically pokes theapplication preventingtheapplicationfromsleeping duringdowntime.inthesescenarios dvfslikelyincreasescpu frequency to handle the higher workload which in turn allows the applicationto run faster.
themoralofthestoryisthataccounting ifdesignednaively may introducedisturbanceandsignificantlyaltertheenergybehaviorof theoriginalapplication.the good newsis powerdisturbancewill be reduced as the sampling rate decreases as sampling slows to 32ms thepowerconsumptiondifferencebetweentheaccounting run andthe originalrun isonly .
3chappie design inthissection weprovideahigh levelspecificationfor chappie runtimeandmetric design.
.
runtime design on the top level the chappie runtime is specified by the chappieruntime function in algorithm .
here chappie continuously samples raw energy consumption line and jvm stack information line andcombinesthetwotoproducean attribution line17 i.e.
howeachlogicalunitofthemonitoredapplication suchasamethod maybeassignedwithaportionoftheenergy consumptionreading obtained from theunderlying system.
structurally each attribution ais a mapping from a logical application unitlunittoitsshare ofenergyconsumption etypewhichisan abstractrepresentationofjoules.notation representsanempty map.
979calmenergyaccountingformultithreadedjava applications esec fse november8 virtualevent usa algorithm1 chappie sampling 1typedeftidint thread id 2typedefetype float energy in joules 3typedeflunitstring accountinglogicalunit 4epoch int vmsampling interval 5a map lunit etype output attribution 6t set tid vmthreads 7v map tid lunit thread indexed logicalunits 8function chappieruntime 9a 10loop atrate epoch 11v 12 esample 13fortintdo 14v abstract stack t 15 t v 16forvinvandv do 17a a 18function esample etype obtain energy reading 19function stack tid stack obtain thread stack 20function abstract stack lunit transform stack to logical unit the goal of each jvm sampling step line is to obtain an abstract representation the abstract function of the runtime stackoftherunningthreads the stackfunction .thelatterreturns either the runtime stack frame information if a threadis active or emptyotherwise with abstract .givenanenergysample thealgorithmfirstcountsthenumberofactivethreads andeach active thread and its associated logical unit will be attributed withafraction1 of .theshareofenergyattributedtoeachlogical unitisaccumulatedin a at line17.
chappie features an extensible and customizable design.
depending on how the abstract function and the lunittype are concretized the algorithm can express a variety of granularities in application levelenergyaccounting.ourdefaultimplementation supports energyaccounting over deep application methods which assigns energy consumption to an application i.e.
non library method when either the said method is at the stack top or it is the callingcontexttoalibrarymethodthatisatthestacktop.
chappie allows users to customize the abstract function.
currently additionalversionshavebeenimplementedfor context sensitive method energy accounting and class package thread energy accounting see 5 .
.
metricdesign we now provide a rigorous definition for calmness.
its essence lies uponthesimilaritybetweentheruntimecharacteristicsofanaccountingrunagainsta referencerun i.e.
theoriginalapplicationrun when the accounting system is not at work.
to simplify the matter wefirstconsidertheidealizedcasewhereoneinstanceofapplicationexecutionissufficienttocapturetheruntimecharacteristics.
letepochrepresentthesetofepochsintheformof n withthe firstepochofeachrunstartingatepoch1.let corethesetofcpu coresandfreqthesetofobservablecpufrequencies.eachrunbenchmark workload methods total threads active threads execution time s avrora large .
batik large .
biojava default .
eclipse default .
graphchi huge .
h2 large .
jython default .
pmd large .
sunflow large .
tomcat large .
xalan default .
figure benchmark statistics workload refers to the data size specified by dacapo for each benchmark.
methods showsthenumberofuniquemethodsappearedinthetrace.
total threads shows the number of the threads created throughout the lifetime of the application.
active threads shows the maximum number of the concurrent threads at anyepoch.
benchmark ratebatches pcc sermse avrora .
.
.
batik .
.
.
biojava .
.
.
eclipse .
.
.
graphchi .
.
.
h2 .
.
.
jython .
.
.
pmd .
.
.
sunflow .
.
.
tomcat .
.
.
xalan .
.
.
figure accounting parameters rate refers to the sampling rate for each benchmark.
batches refers to the numberofdatacollectionrunsfortheaccountingofeachbenchmark.
pcc shows the correlation between the energy footprint produced from n batches and that produced from n batches.
se shows the standard error of the pcc.
rmse showstheroot meanssquare error.
producesasetofsamples s p epoch core freq where eachsample e c f intuitivelysaysthecpufrequencyofcore c at epocheisf.first letusintroduce someauxiliary functions.
definition3.
epochcount .
wesayarunwithsamples sconsists ofecount s epochswhere ecount s s core .
definition .
core count .
we say there are ccount s e f number of cores operating at frequency fand epoch e. where ccount s e f c e c f s .fromnowon weusemetavariablem to represent the core count.
to study temporal calmness we intuitively wish to characterize how the power consumption manifested by cpu frequencies flows and ebbs over time.
we first introduce a function for computing the cpu frequencies given a particular epoch ein a particular run.observe that inoursample space there are core numberofsamplesforeachepoch onefromeachcore.ratherthan assuming a fixed distribution we represent the frequencies as a distribution to preserve generality.specifically 980esec fse november8 virtualevent usa timur babakol anthonycanino khaledmahmoud rachitsaxena andyudavid liu epoch frequency ghz .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
a no method sampling epoch frequency ghz .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
b 32ms method sampling epoch frequency ghz .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c 1ms method sampling figure temporal distribution of cpu core frequency for h2 the x axis represents the epoch series of the benchmark execution withthefirstepochandthelastepochindicatesthebeginningandendofexecution.eachbarrepresentsaparticular frequencyrange whoseheightindicatesthenormalizednumberofcpucoresatthatfrequencyatthatepoch.forillustration we divide all frequencies into ranges.
for example throughout the majority of a the orange bars show that of cores executebetween .
.
ghz untilthetail end where ofcoresexecute at that range.
definition3.
temporalcharacterization .
weusetc s tocompute thetemporal characterization for a run over samples s.tc s computes to an element in epoch freq i.e.
from each epoch to a frequency distribution .
formally for each e ecount s andeach f freq tc s e f ccount s e f core .
indeed if we treat the frequency at epoch ein the sample space sas a random variable tc s e is its probability mass function pmf .
to study spatial calmness we intuitively wish to characterize how cpu frequencies spread out across cores.
an intuitive representationistoshowwhichcoresoperateoneachfrequency.this intuitioncarriessomesubtlety.first thereare ecount s number of snapshots for the characterization of spreading out to be considered.
the overall spatial characterization throughout an entire run canbeintuitivelyviewedaseachepochintroducinganobservation characterizing how cpu frequencies are spread out for that epoch.
second schedulingisfundamentallynon deterministicandthreads maymigratefromoneanother.fordesigningacomparativemetric like ours this means that a comparative study for a fixed core s behavior is meaningless.
what matters is how many cores operate at a particular cpu frequency.
with these two elaborations we define definition3.
spatialcharacterization .
weusesc s tocompute thespatial characterization for a run over samples s.sc s computes to an element in freq ccount i.e.
a frequency corecountbivariatedistribution definedas sc s f m e m ccount s e f ecount s .
indeed if we treat both the frequency and the core count in the samplespace sasa random variable sc s istheirbivariate pmf.
definition3.
calmness .
wesayanaccountingrunwithsamplessiscalmrelative to areference run withsamples s0iff ecount s ecount s0 for anyesuch that e min ecount s ecount s0 tc s e tc s0 e sc s sc s0 where and abstractly represent the similarity between two naturalnumbers andtwo distribution respectively which we will contretize in .
time correspondence captures that the accounting run must have similar execution time as the reference run.
the temporal correspondenceandspatialcorrespondenceenforcethatthetwo runsmusthavesimilarpowercharacteristics.withenergybeingaccumulatedpowerovertime thecriteriaabovetogethersaythatthe energycharacteristicsbetweentheaccountingrunandreference run are similar the essenceof calm energyaccounting .
multi iterationruns.
thediscussionsofarhasidealisticallyassumed that there is only onereference run and oneaccounting run.
as most experiments are repeated to take into the fundamental non determinisminthesoftware hardwarestack thereferencerun as well as the accounting run may consist of multiple executions of theapplication eachofwhich wecall an iteration.
ourcalmness metric can be defined for multi iteration runs in a nearly identical manner as definition .
with small changes.
let us assume ak iterationrunproducessamples s1 ... skrespectively wecan followdefinition .5toconstructthecalmnessmetricoversamples s1 sk with core redefinedasthenumberofcpusmultiplied byk.
intuitively this implies we can conceptually view the k iteration run as one parallel run of kinstances of the application overktimes of physical cpus.
this formal view simplifies our algorithm specification we do not need to repeat all definitions we introduced earlier for multi iterations runs.
practically this means we can merge all the samples we collected from different iterations byreusingtheformaldefinitionwehavegivenforasingleiteration.
for example fig.
8shows the equivalentview of a three iteration run on a two core machine with cpu1andcpu2 of an application 981calmenergyaccountingformultithreadedjava applications esec fse november8 virtualevent usa cpu 1cpu 2app in iteration 1app in iteration 2app in iteration cpu 1cpu 2cpu 1cpu figure amulti iterationrun app.sincebothourreferencerunandprofilerunconsistofmultiiterations in our experiments this view has been adopted in our data analysisover calmness to be reportedinthe nextsections.
4chappie implementation threadmodeloverview.
weimplementthe chappieruntimeasa threadofitsown inthesamejvmruntimeastheapplicationbeing accountedfor.thetop levelloopconstructinthespecificationis implemented with a timer.
the thread periodically wakes up with nobusy waiting.
the globalstructure tin the specificationrequiresthread safe access.
to prevent it from becoming a bottleneck we implement it with a delayed buffer .
whenever a thread is started or exited an entry is added or removed from this delayed buffer to indicate the change.
periodically at every epoch the thread that runs the chappieruntimewillretrievefromthebufferandapplythechanges adding a thread or removing a thread to its exclusively held tstructure.asaresult tdoesnotrequiresynchronization and only the delayedbuffer isimplementedas asynchronized queue.
call stack sampling.
traditional approaches for accessing the thread stacks such as through the thread.getstacktrace incursignificantoverhead.tocircumventthisrestriction weresort to a hotspot vm api the asyncgetcalltrace method to sample thecallstack amethodalsousedbypopularprofilerssuchasthe asyncprofiler whichourimplementationbuildson.tointegrate with the async tool which supports asynchronous stack sampling wemaintainabuffertokeepthestacksamples andusetimestamps to align themintoeachepoch.
the async profiler can sample both java stacks and the native stacks the latter may result from either though jni invocation or jitcompilation and chappie can handle both as aresult.
hardwareenergyreadingandcpuaffinity.
werelyonintel s rapl interface to obtain energy samples at the granularity ofcpupowerdomains sockets .energysampleswerecollected using jrapl a java library for interfacing with rapl.
we are able to sample both cpu package and dram energy.
as our experimental platform consist of multiple sockets we treat each socketasaseparatelocaleforattribution algorithm andcombine data together.
as the os scheduler may migrate a thread from one socket to another we maintain the cpu affinity information to keeptrackofthesocket andhencethelocaleofattribution a thread belongs to.
metricimplementation.
predicate e e indefinition .5isimplemented as the normalized difference between eande is less than5 .thesimilaritybetweendistributions isimplementedthroughthestandardmetricofpearson scorrelationcoefficient pcc between the pair of distributions.
two distributions are considered similar iff their pcc .
.
in general pcc above .
is consideredstrongly correlated.
thetcandscfunctions both usepmfs to represent the distributions.althoughmoderncpusonlypublishasmallnumberof cpu frequencies the observed cpu frequencies are much more diverse.
for example in our experiments we observed distinct frequencies in our data samples.
this implies that if the original pmf is used there are a large number of elements in the vector for pcc computation.
this is a well known problem and we have appliedfreedman diaconisruletobinsimilarfrequenciestogether.
temporal correspondence in definition .5relies on epoch wise distribution similarity.
while time correspondence establishes that the number of epochs for the reference run and those for the accountingrunaresimilar asmalldifferencemaystillexist.definition3.5takes the approach of only considering the less number oftheepochsbetweenthetworuns.inpractice wefoundthatif anaccountingrunis slightly slowerthanthereferencerun the delayed effect w.r.t.
the frequency behavior often exhibits gradually as time goes on.
to capture this gradual shift we use a simple interpolationapproachtomakethetworunsmatchonepochs if the number of epochs for the reference accounting run is e0and e 0respectively weadjusteachrawsampleintheaccountingrun e c f to e c f wheree e e e0.
sincee0ande 0are similar this adjustmentonly affectsasmall portion of samples.
5chappie evaluation .
evaluationmethodology we evaluated chappie on a dual socket intel e5 v4 .
ghz cpuserver with10coresineachsocketand64ddr4ram.hyperthreadingisenabled.themachinerunsdebian4.9os linuxkernel .
with the default debian powersave governor.all experiments were run with java on top of hotspot vm build .
.
lts.
wheneachexperimentisperformed theoshasnootherworkload.
chappie isevaluatedoverthedacapobenchmarksuite of its recent version evaluation git 8b7a2dc released in june .
this release includes state of the art workloads such as graphchi andbiojava.aslong er runningapplicationsaremoreinteresting w.r.t.
energy management we focus onbenchmarks whose executiontimeisaroundorabove10seconds.amongthe13benchmarks thatfitintothiscriterion weexcluded2ofthem themajorityof application code of tradesoap andtradebeans is run in a new process asopposedtoanew thread whoseaccounting chappie currentlydoesnotsupportwithoutmodifyingbenchmarksource code.
the statistics of the benchmarks are shown in figure .
here theexecutiontimereferstoaveragethebenchmarkrunningtime over all of its iterations which we discuss shortly.
the dacapo harnesssetuptimeisexcluded.thebenchmarksarerealisticjava applications with thousands of methods and diverse characteristicsinmulti threading bothintermsoftotalcreatedthreadsand concurrently running threads.
figure6summarizestheparametersettingsusedfortheaccountingofeachbenchmark.recallthatcalmenergyaccountingrequires 982esec fse november8 virtualevent usa timur babakol anthonycanino khaledmahmoud rachitsaxena andyudavid liu cores operating at frequency .
.
.
.
.
.
.
.
.
chance of occurance frequency ghz .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
a no method sampling cores operating at frequency .
.
.
.
.
.
.
.
.
chance of occurance frequency ghz .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
b 32ms method sampling cores operating at frequency .
.
.
.
.
.
.
.
.
chance of occurance frequency ghz .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c 1ms method sampling figure spatial distribution of cpu core frequency for h2 the x axis shows the number of cores observing the same frequency in the same epoch.
the y axis shows the probability that a frequency is observed.
for illustration we divide all frequencies into ranges.
for example the red bar on the 3rd tick on c says that there is a chance that cores run in frequencyrange .
.
ghzat thesametime.the sum ofheightsofallbars equals to .
minimaldisturbancetotheoriginalbenchmark chappiesetsadistinctsamplingrate asdefinedby epochinalgorithm foreach benchmarktoensurecalmness showninthe ratecolumn.thesection of this rate will be the focus of .
.
to gain confidence in the precisionoftheenergyfootprints chappiereliesonacombination ofcold hot executionsto collectdata each batchisadistinct jvm instance that subsumes iterations i.e.
hot execution instances of a benchmark.
we elaborate on the number of batches in section .
.
witheachbatch weperform10iterationsbydefaultandfollowthe standard practice of discarding thedata from the first2 iterations.
as exceptions we perform iterations and discard the first forsunflowandjython because ofthe relatively large standard deviationoftheirexecutiontime iffeweriterationsareused for data collection.
.
achievingcalmness in this section we study how the calmness metric is used for determining the judicious sampling rate for each benchmark.
before we presenttheresultforallbenchmarks webegin withavisualelaborationontemporalcorrespondenceandspatialcorrespondence the cornerstones ofcalmness.
figure7shows the temporal behavior of h2under different settings the reference run the chappie accounting run under the selectedsamplingrate32ms andthe chappie accountingrunifthe samplingrateweresetat1ms.withineachsub figure timeelapses from left to right.
its time dependent variation is an illustration of power phased behaviors.
as one can see the shape of the 32mssamplingresultissignificantlymoresimilartothatofthereference run thanthe1ms samplingresult.thetemporalcorrespondence definitionindef.
.5isintendedtocapturethesimilarityoftheformer and the disimilarity of the latter .one interesting observation isthatthe1ms samplingresultshowsmorecpucoresarelikelyto be driven into a higher frequency this is consistent with our intuition that a higher sampling rate may have significantly increased activity in cpu cores rendering them into higher frequencies due to dvfs.
finally observe that figure c consists of fewer epochs becausetheruncompletessignificantlyfasterthanthereference run.
figure7showsthespatialbehaviorof h2underthesame3differentsettingsasearlier.here wecareabouthowafrequency spreads out across cores.
if all cores have the same frequency at the same time it indicates a perfectly balanced power consumption across cores.
within each sub figure this is indicated by the rightmost pointonthex axis.asonecansee theshapeofthe32ms sampling result is again significantly more similar to that of the reference run thanthe1ms samplingresult.thespatialcorrespondencedefinition in def.
.5is intended to capture the similarity of the former and the disimilarity of the latter .
specific to h2 the relative unbalancednessisnotsurprising h2asanin memorydatabaseisknown to be an i o intensive benchmark with a low degree of parallelism.
finally figure 10summarizes the components used to determine calmness time overhead temporal correspondence and spatialcorrespondenceacrossallbenchmarks.thefullresultsincludingstandard deviationaredeferredtotheappendix.ifadata point is missing it means the data is out of the range of our interest .basedonourprofilingcalmnessstudies wehaveselected the sampling rate for each benchmark with results shown in the secondcolumn offigure .
.
producingenergy footprints method grainedaccounting.
theenergyfootprintreportedby chappie can be of various logical units of abstraction.
the default unit i.e.
each entry in the energy footprint is the deep application method asdiscussedin .inourreporteddata amethodisviewed as a library method if it belongs to a class whose qualified name startswith java jdk sun andapache.commons .amethodbelongingtoanyadditionalthird partylibraryistreatedasanapplication method.
fig.11illustratesaportionofthisfootprint thetop 10energyconsuming methods for graphchi a concrete instance of the 983calmenergyaccountingformultithreadedjava applications esec fse november8 virtualevent usa sampling rate ms 15runtime overhead avrora batik biojava eclipse graphchi h2 jython pmd sunflow tomcat xalan a time overhead sampling rate ms .
.
.
.
.
.00temporal correspondence avrora batik biojava eclipse graphchi h2 jython pmd sunflow tomcat xalan b temporal correspondence sampling rate ms .
.
.
.
.
.00spatial correspondence avrora batik biojava eclipse graphchi h2 jython pmd sunflow tomcat xalan c spatial correspondence figure a summary of benchmark calmness for both sub figures each line indicates a benchmark and the axis indicates themethod samplingrate.
namesake data intensive graph processing system .
the dacapo s benchmarkimplements als matrixfactorization an iterativealgorithmwithgraphtraversalandupdates.theenergyfootprint generated by chappie corroborates the nature of this benchmark withthetoprankedmethodbeing alsmatrixfactorization .update.
the next three highest ranked methods are related to graphtraversal withmethods chivertex.outedge andchivertex .inedgeforaccessingtheedgesofavertex and datablockmanager.
dereference for fetchingthe valueassociatedwithan edge.
itisinterestingtoobserve that energyconsumption and executiontimedonotalwayscorrespond.in graphchi methodalsmatrix factorization.update hasahighernormalizedenergyconsumption than its execution time indicating that the system is in a higher power state.
this method is mathematical in nature and our results can be intuitively explained through a well known phenomenon with default governors compute intensive workloads often lead the cpu to a higher power state.
as a counter example .
.
.
.
.
.
.
.
.
normalized energy consumptionmethod buffereddatainputstream.readchivertex.addinedgememoryshard.loadadjchunkfloatconverter.getvaluehugedoublematrix.getrowdatablockmanager.getrawblockchivertex.inedgedatablockmanager.dereferencechivertex.outedgealsmatrixfactorization.update time energyfigure top energy consuming application methods forgraphchi each green red bar indicates the normalized energy time of a top consuming method.
energy is directly computedby chappie accordingtoouralgorithmspecification.
time is approximated by the number of samples multiplied by thelength ofthe samplinginterval.
page.binarysearch figure context sensitive method accounting for top energy consuming method of h2.
each slice with context indicatesthatamethodiscalledbyywhichinturnis calledbyx.notethatoneofthecallingcontextisrecursive.
memoryshard.loadadjchunk has a lower power consistent with the fact that this methodisi o intensive.
callingcontext grainedaccounting.
throughprovidingdifferent concrete abstract functions see section chappieis a generalframeworkthatcanbecustomizedtoaccountforprogramming abstractionsatdifferentlevelsofgranularity.forexample chappie canreportmethodenergyconsumptioninacontext sensitivemanner i.e.
accounting for different calling contexts separately.
fig.
provides a finer grained view into two top consuming methods forh2 an in memory database.
our results show that the majority of energy consumption for page.binarysearch comes from the recursive calling context of mvmap.binarysearch which aligns with our understanding of binary search algorithms.
this example showsthat chappie atthecontext sensitive granularity provides additionalcontextthatpaintsafine grainedpictureforunderstandingthe energy behaviorof h2.
984esec fse november8 virtualevent usa timur babakol anthonycanino khaledmahmoud rachitsaxena andyudavid liu .
.
.
.
.
.
.
normalized energy consumptionclass compositegraphicsnodesvgclippathelementbridgeparsedurldefaultprotocolhandlersvgomdocumentpngencodeparamabstractgraphicsnodefillshapepaintercssenginestrokeshapepainterpngimageencoder energy a class .
.
.
.
.
.
.
normalized energy consumptionpackage org.apache.batik.css.engine.valueorg.apache.batik.css.parserorg.apache.xerces.implorg.apache.batik.utilorg.apache.batik.domorg.apache.batik.bridgeorg.apache.batik.anim.domorg.apache.batik.css.engineorg.apache.batik.gvtorg.apache.batik.ext.awt.image.codec.png energy b package figure top energy consuming application classes and packages each green normalized energy of a top consuming class orpackage.
class and package grainedaccounting.
alternatively chappie can be customized with an abstract for java class and packagelevel granularity.
figure 13shows the result for batik an apache toolkit for transforming and rendering scalable vector graphics svg .
the dacapo benchmark focuses on the use scenarios of transformingsvgfilesintoportablenetworkgraphic png images and rendering them.
our results show that pngimageencoder andstrokeshapepainter classes are responsible for a majority of batikenergy consumption which happens to be aligned with the main features of this application transformation and rendering.
as classes are often the abstraction units for dividing programming tasks among developers in large scale software development chappie class level energy footprint provides insight on which programmers are the critical link on developing energy conscious software.
one granularity coarser chappie can further demonstrate energy consumption at the package level.
for batik half of itsenergyconsumptionresultsfrompngcodec asshowninthe packageorg.apache.batik.ext.awt.image.codec.png .
.
overhead andprecision as a disturbance mitigated approach chappie is fundamentally overhead averse it selects a sampling rate only when calmness isachieved leadingtominimaltimeoverhead accordingtotime correspondenceindef.
.
andminimalpower energyoverhead accordingtotemporal spatialcorrespondenceindef.
.
.forall benchmarks operating at the selected sampling rate the average time overhead is .
.
and the average energy overhead is .
.
.
withmulti batchrunsaspartofthedesign chappieisalsoconstructed with precision as an inherent goal.
intuitively the ground truth of energy consumption of a method is the accumulation of the energy consumption from all of its instructions.
this is equivalenttoasampling basedapproachwherethenumberofsamples approachesinfinity.onestandardmetrictostudytheapproximation to the ground truth is the convergence of results i.e.
whether introducing more samples maysignificantly changethe results.toachievethisgoal westudytheextentthattheenergyfootprint may change when data from an additional batch are introduced.
intuitively if introducing additional batches of samples can lead to little change in the energy footprint convergence is achieved.
we compute the pcc between the data of n 1batches and that of n batches and set the batch parameter for the benchmark as nif the pccisgreaterthan0.
.the batchescolumnoffigure 6showsthe batchsettingforeachbenchmark.mostbenchmarksrequireonly2 batches theminimumnumberina relationalapproachwetake to achieve pcc .
.
the remaining benchmarks e.g.
avrora exhibithighervariability butobservethateachstillconvergesto our high pccrequirement within alimitednumber of batches.
related work energy accounting is a classic problem at lower layers of the computing stack.
examples include icount at the digital circuit level and currentcy at the os level.
with the primary goal of attributing a global energy budget to individual components totalityisimplicitinenergyaccountingsolutions.thispaperisa systematic study of bringing energy accounting to the application level where the individual components at concern are methods callingcontexts classes andpackages.
at the application level energy accounting and energy profiling overlap in their overall goal of characterizing the runtime characteristics of an application.
while accounting is implicitly total profilingmayormaynot.thisiswhyinstrumentationremainsa viableapproachinexistingenergyprofilersastheymanychoose to study the runtime characteristics of individual logical units one by one.
this approach is particularly common in empirical studies where the energy consumption of specific program features isreportedbasedoninstrumentingsuchfeatures.withafeature focus e.g.
theuseoftheconcurrentcollectionsapi or the impact of data access patterns instrumentation can be a feasible solution as it can be placed for one code block at a time.
in thisusescenario chappiemaybeusefulinimprovingtheprecision ofprofiling by makingtheprofiler concurrency aware.eprof accounts for smartphone energy consumption through tracking 985calmenergyaccountingformultithreadedjava applications esec fse november8 virtualevent usa i osystemcallsandpre definedsdk ndkroutines producinga breakdownonimportantsmartphoneusescenariosrelatedtothe use of 3g network screen etc.
e android is a profiler that detects android collateral energy consumption through tracing a set ofpre definedenergy criticalevents.theseenergyprofilersmay profilepre definedapplicationcomponents suchasthesoftware componentfor3gnetworkinteractionorscreentracking buttheir designs are geared toward physical components of the platform without a full account of general logical units as chappie does.
bokharietal.
definesaconceptualenergyprofilingframework for resampling in the presence of measurement inaccuracy.
earlier energyprofilerssuchasjouletrack andpowerscope focus onmeasurementframeworkdesign addressing e.g.
howtoprovide high rate energy samples and how to synchronize the execution withthe measurements.
anotherkeyfeatureuniqueto chappie isitssystematicinvestigation into power disturbance.
we are unaware of existing energy profilersthatprovide metricstoquantify andovercomeit.
in non energy profiler design that a profiler may intervene and alter thebehavioroftheoriginalapplicationisabasicfact motivating designers to reduce the overhead introduced by the profiler.
for non energyprofilers sayamemoryconsumptionprofiler theeffect of power disturbance if any is of a lesser concern.
this is in contrast with energy profiling power disturbance may alter the verycharacteristictheprofilerintendstocapture.
sampling based non energy profilers are standard .
one area chappie may positively impact on is application level energymanagementandoptimization withsolutionsrangingfrom energy aware programming languages and energy adaptive frameworks.
severalexamplesmaydemonstrate this synergy.green relies on online energy accounting to perform qos calibration.
powerdial andjouleguard mayuseenergyfeedbackto make control decisions.
lab needs to continuously account forenergyconsumptiontobalancelatency accuracy andbattery.
eco must track energy consumption to match the application demand and the system resource supply.
aeneas relies on online energy readings to enable energy optimization guided byreinforcementlearning.with chappie theseapplication level energyeffortscangracefullyextendtothemorecomplexusescenarios where the application may be multi threaded and multiple applicationsmayco exist.anotherarea chappie mayprovideessentialsupportforisenergytestinganddebugging anemerging research direction .
as energy and performance often go hand in hand this direction may unify with performancebugstudies toprovidecomprehensive software lifecyclesupport for software non functionalproperties.
thedualofenergyaccountingisenergyanalysis abottom up approachtodeterminetheenergyconsumptionofaprogrambased on its building blocks.
with a bottom up design principle these approachesarefine grainedbydesign.instruction levelpoweranalysis mayassociateinstructionswithpowerprofiles.additional designsexisttoperformenergyanalysisinawcet likesetting on the bytecode level and the llvm ir level for instance.
energy analysis has a nearly orthogonal interest in illuminating programenergyconsumptiontoours andthetwoapproachesmayname rate avrora .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
batik .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
biojava .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eclipse .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
graphchi .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
h2 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jython .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
pmd .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
sunflow .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tomcat .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xalan .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
a overhead name rate avrora .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
batik .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
biojava .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eclipse .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
graphchi .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
h20.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jython .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
pmd .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
sunflow .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tomcat .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xalan .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
b temporal correspondence name rate avrora .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
batik .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
biojava .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eclipse .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
graphchi .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
h20.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jython .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
pmd .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
sunflow .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tomcat .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xalan .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
c spatial correspondence figure calmness statistics rate refers to the sampling rate.
followaclassicdualityinsoftwareresearch reasoningvs.monitoring.practically itisunclearhowrelatedworkadapttoscenarios withmulti threadedexecutions.
conclusion chappie is a novel runtime design for application level energy accounting of multi threaded java applications with calmness as a new metric to quantify power disturbance in energy accounting.
theprojectrepositorycontainsalldataforallbenchmarks anda report for additionalfigures coveringallbenchmarks.