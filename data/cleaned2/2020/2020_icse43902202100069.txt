extracting concise bug fixing patches from human written patches in version control systems yanjie jiang1 hui liu1 nan niu2 lu zhang3 yamin hu1 1school of computer science and technology beijing institute of technology china 2department of electrical engineering and computer science university of cincinnati usa 3key laboratory of high confidence software technologies peking university china email fyanjiejiang liuhui08 ymhu g bit.edu.cn nan.niu uc.edu zhanglu sei.pku.edu.cn abstract high quality and large scale repositories of real bugs and their concise patches collected from real world applications are critical for research in the software engineering community.
in such a repository each real bug is explicitly associated with its fix.
therefore on one side the real bugs and their fixes may inspire novel approaches for finding locating and repairing software bugs on the other side the real bugs and their fixes are indispensable for rigorous and meaningful evaluation of approaches for software testing fault localization and program repair.
to this end a number of such repositories e.g.
defects4j have been proposed.
however such repositories are rather small because their construction involves expensive human intervention.
although bug fixing code commits as well as associated test cases could be retrieved from version control systems automatically existing approaches could not yet automatically extract concise bug fixing patches from bug fixing commits because such commits often involve bug irrelevant changes.
in this paper we propose an automatic approach called bugbuilder to extracting complete and concise bug fixing patches from human written patches in version control systems.
it excludes refactorings by detecting refactorings involved in bug fixing commits and reapplying detected refactorings on the faulty version.
it enumerates all subsets of the remaining part and validates them on test cases.
if none of the subsets has the potential to be a complete bug fixing patch the remaining part as a whole is taken as a complete and concise bug fixing patch.
evaluation results on real bug fixing commits in defects4j suggest that bugbuilder successfully generated complete and concise bug fixing patches for forty percent of the bug fixing commits and its precision was even higher than human experts.
index terms defect bug testing patch repository dataset i. i ntroduction high quality and large scale repositories of real bugs and their concise patches collected from real world applications are critical for research in the software engineering community.
on one side such real bugs patches are indispensable for rigorous evaluation of numerous automatic or semi automatic approaches to identifying faulty software applications to locating faulty statements and to repairing faulty applications .
such approaches are expected to work on real world applications.
consequently it is critical to evaluate such approaches with a large number of real bugs patches from real world applications before they could be widely applied in the wild .
on the other side real bugs and patches may also corresponding author hui liuinspire novel ideas in finding locating and repairing software bugs.
for example by analyzing real bugs researchers could identify what kind of statements are more error prone and thus try to repair such statements first during automatic program repair .
another typical example is the common fix patterns learned from human written patches .
leveraging such patterns significantly increased the performance of automatic program repair .
finally data driven and learning based approaches in automatic program repair and bug detection usually depend on a large number of diverse real bugs patches.
bug repositories have been proposed to facilitate bugrelated research.
the first category of bug repositories is constructed manually.
typical examples of this category include sir bugbench introclass codeflaws quixbugs droixbench and dbgbench .
these repositories are constructed by hand and thus are quite limited in scale and diversity.
the second category of bug repositories is constructed automatically or semi automatically.
ibugs and manybugs are typical bug repositories constructed by automatically extracting bug fixing commits as patches.
however existing studies suggest that bugfixing commits often contain both bug fixing changes and bug irrelevant changes e.g.
refactorings.
as a result it is risky to take all of the changes in a bug fixing code commit as the patch of the associated bug report the resulting patch may contain code changes irrelevant to the bug.
code changes are deemed as bug irrelevant if they are changing adding removing functionalities that are not associated with the bug report or they are function irrelevant common refactorings that could be conducted independently before bug fixing changes are made.
a bug fixing patch extracted from a bug fixing commit is deemed as complete and concise if and only if the patch is composed of all bug relevant changes complete but no bug irrelevant changes are included concise .
to extract complete and concise bug fixing patches defects4j takes all changes in a bug fixing commit as a patch and then manually excludes bug irrelevant changes from the generated patch.
as a result the resulting patches in defects4j are highly accurate often both complete and concise but the scale and diversity of the patches remain limited.
notably applying the bug irrelevant changes to the original buggy version called vn results in a new version called vbug and applying ieee acm 43rd international conference on software engineering icse .
ieee the concise patch in defects4j to vbugfixes the bug and results in the fixed version called vn .
although bug fixing commits could be identified automatically by comparing bug ids in bug tracking systems and code commit messages in version control systems it remains challenging to extract automatically bug fixing changes i.e.
patches from bug fixing commits.
to fully automate the construction of bug patch repositories in this paper we propose an automatic approach called bugbuilder to extracting concise bug fixing patches from human written patches in version control systems.
it first leverages refactoring mining and reapplication to remove refactorings from human written patches.
it validates whether the remaining part is a complete and concise bug fixing patch by enumerating all subsets of the remaining part and validating them on test cases.
if none of the subsets can be a complete patch the remaining part as a whole is deemed as a complete and concise patch.
consequently if the human written patch is composed of both refactorings and bug fixing changes bugbuilder splits it into two ordered patches a refactoring patch and a following bug fixing patch.
it is highly similar to defects4j which splits an existing patch into a bug irrelevant patch and a following bug fixing patch.
notably directly applying the bug fixing patch to the original buggy version would not work.
consequently to evaluate automated program repair tools algorithms called apr tools for short with the extracted bug fixing patches we should first apply the refactoring patch to the original buggy version called vn take the resulting version called v0 n as the buggy program to be fixed generate patches for v0 n 1with the apr tools and compare the generated patches against the bug fixing patch extracted by bugbuilder.
besides apr tools fault localization tools algorithms may also leverage the patches extracted by bugbuilder for quantitative evaluation taking v0 n 1as the buggy program to be fixed .
bugbuilder has been evaluated on real bug fixing commits collected by defects4j.
on each of the evaluated commits we leveraged bugbuilder to extract concise patches automatically.
if a patch was successfully generated we compared it against the manually constructed patch provided by defects4j.
on the bug fixing commits bugbuilder automatically generates patches where were identical to manually constructed patches in defects4j.
for the other patches that are different from manually constructed patches we manually analyzed the associated bug reports as well as the code commits.
evaluation results suggest that out of the pairs of mismatched patches were caused by incomplete patches in defects4j whereas the generated patches were complete and concise.
only four out of the generated patches were inaccurate complete but not concise and all of them are caused by incomplete detection of refactorings.
the paper makes the following contributions first we propose an automatic approach to extracting complete and concise bug fixing patches from human written patches in version control systems.
to the best of our knowledge it is the first fully automatic approach for this purpose.
the approach makes it practical to automaticallybuild large scale high quality bug patch repositories which may significantly facilitate future bug related research especially automated program repair and fault localization.
second we evaluate the proposed approach on real bugfixing code commits.
it successfully extracted complete and concise bug fixing patches for of the bug fixing commits with a high precision of .
the replication package including the source code of bugbuilder is publicly available at .
ii.
r elated work because of the importance of real bugs patches a number of bug repositories have been proposed.
to the best of our knowledge the software artifact infrastructure repository sir is the first attempt to provide a database of bugs.
it consists of c programs and java programs.
each of the programs has several different versions together with a set of known bugs and test suites.
however most of the programs are very small and the bugs mostly are hand seeded or obtained from mutation .
spacco et al.
collected real bugs made by students during programming tasks.
their bug repository contains hundreds of faulty projects accompanied with test cases.
however most of the collected student projects are small and they could be significantly different from real world software applications in industry.
introclass proposed by le et al.
codeflaws proposed by tan et al.
and quixbugs proposed by lin et al.
contain real bugs from programming competitions challenges.
however such bugs made in programming assignments or competitions could be significantly different from real bugs in industry.
to this end lu et al.
manually collected real bugs from programs.
besides that tan et al.
manually collected reproducible crashes from open source android apps and b ohme et al.
requested twelve experts to collect real bugs from open source c projects.
bugsjs is composed of real manually validated javascript bugs from javascript server side programs.
manual collection of real bugs is tedious and timeconsuming.
consequently automatic and semi automatic approaches have been proposed to collect real bugs.
ibugs is a semi automatic approach to collecting real bugs.
it extracts bugs from version control systems automatically assuming that all changes in the bug fixing commits are bugrelated.
however an existing study suggests that the assumption is not always true and bug fixing commits often contain bug irrelevant changes like refactorings and implementation of new features.
consequently taking all changes in bug fixing commits may result in unconcise patches that contain both bug fixing changes and bug irrelevant changes.
similar to ibugs manybugs also takes the whole bugfixing commit as a patch and does not exclude irrelevant changes within the commit.
to exclude such bug irrelevant changes defects4j relies on manual isolation of bugfixing changes from bug irrelevant changes.
as a result of the manual isolation bugs and patches in defects4j are highly accurate.
consequently defects4j becomes one of the most 687frequently used bug repositories in the community.
another significant advantage of defects4j is that it also provides an extensible framework to enable reproducible studies in software testing research.
however the manual intervention requested by defects4j prevents it from being fully automatic and thus the dataset remains limited in scale and diversity.
bugs.jar is another large bug repository containing real bugs and patches collected from open source applications apache github .
similar to defects4j it locates bug fixing commits by comparing the id of bug fixing issues in jira a popular issue tracking system and commit messages in github source code version control system .
it differs from defects4j in that it requests experts to manually verify that the involved bug reports are real bugs i.e.
they are not misclassified as bugs in the jira repository.
bears proposed by madeiral et al.
collects bugs based on continuous integration ci instead of source code version control systems.
the core step of its bug collection is the execution of the test suite of the program on two consecutive versions.
if a test failure is found in the faulty version and no test failure is found in its patched version bears takes the two versions as the faulty and the fixed versions whereas their difference is taken as the associated patch.
however bears does not distinguish bug fixing changes from bug irrelevant changes within the same source code commit.
similar to bears bugswarm also collects bugs patches from ci and fails to exclude bug irrelevant changes from the collected patches as well.
we conclude based on the preceding analysis that existing bug repositories are limited in either scale or quality.
manually or semi automatically constructed repositories are limited in scale because they request expensive human intervention.
in contrast automatically constructed ones are limited in quality because the automatically extracted patches often contains bug irrelevant changes.
to this end in this paper we propose a fully automatic approach to extracting high quality patches that are both complete and concise.
diffcat proposed by kawrykow and robillard identifies non essential changes especially refactorings in version histories highly similar to refactoringminer that our approach leverages to identify refactorings.
however at best it may serve as only the first step for concise patch generation see fig for more details .
simply recommending refactoring excluded patches output of diffcat would result in numerous unconcise patches when commits contain nonrefactoring bug irrelevant changes.
as a result developers need to manually check clean all of the recommended patches to guarantee the quality.
thung et al.
identify root causes of bugs i.e.
lines of code in the buggy version that is responsible for the bug .
such root causes are essentially different from concise patches.
consequently these approaches do not address the same issue automatically constructing bug patch repositories as we do.
notably neither of them leverages off the shelf refactoring mining tools and neither of them reapplies discovered refactorings as we do.
fig.
.
a bug fixing commit from google closure compiler iii.
m otivating example in this section we illustrate the challenges in the automatic extraction of concise patches from bug fixing commits.
an example is presented in fig.
where the changes involved in the commit are highlighted in standard diff style.
lines beginning with are removed by the commit whereas lines beginning with are inserted by the commit.
other lines are untouched.
this bug fixing source code commit comes from google closure compiler and the associated bug report is publicly available online .
the modified method caninline line checks whether the provided reference and declaration can be safely inlined.
the bug report complains that singleton getters are inlined although such methods should not be inlined.
to fix this bug developers inserted an ifstatement lines that declares singleton getters could not be inlined i.e.
forcing the method to return false .
such changes constitute the bug s complete and concise patch in defects4j.
however we also notice that the bug fixing commit made more changes than the insertion of an ifstatement i.e.
the complete and concise patch for the bug .
changes on lines and are bug irrelevant.
such changes are in fact a typical extract variable refactoring.
consequently extracting all changes in the bug fixing commit as the patch would result in unconcise patch that contains bug irrelevant changes.
bugbuilder successfully generates the complete and concise patch from the bug fixing commit as follows.
first it identifies theextract variable refactoring by analyzing the changes made in the commit.
second it reapplies the identified refactoring to the faulty version which results in a new version v0 n called refactoring included version.
third it computes all changes noted as chs between v0 n 1and the fixed version vn .
notably chs does not include the extract variable refactoring because the variable convention line is defined in both v0 n 1andvn.chs is composed of the changes on lines only.
fourth bugbuilder enumerates and validates all possible subsets of chs.
however applying any proper subset ofchs tov0 n 1results in compiler errors or fails to pass any new test cases in the fixed version.
consequently such proper subsets could not be taken as candidate patches.
finally bugbuilder applies all of the changes together i.e.
chs to 688fig.
.
overview of bugbuilder v0 n resulting in a compilable version that passes all test cases associated with the faulty version or the fixed version.
consequently all of the changes together make up the only candidate patch and thus bugbuilder outputs it as the patch for the associated bug.
iv.
a pproach a. overview an overview of the proposed approach is presented in fig.
.
it takes as input two consecutive versions of a software application i.e.
vn 1andvn.
the latter version vnis called vfixor the fixed version in defects4j and vn 1is called the faulty version .
notably the two consecutive versions are accompanied by their test cases noted as tn 1andtn respectively.
tn 1andtnexclude such test cases that fail on their associated version of the application.
the evolution from vn 1tovnis driven by a bug fixing commit whose commit message contains an id of a validated bug report.
with such input the proposed approach bugbuilder works as follows first it leverages refactoringminer to discover refactorings that have been applied to vn .refactoringminer is a state of the art approach to mining software refactorings by comparing two consecutive versions of the same application.
it would result in a list of refactorings noted as r. second if any refactorings have been discovered in the preceding step i.e.
ris not empty bugbuilder leverages refactoring apis to apply all of the discovered refactorings tovn .
applications of such refactorings on vn 1results in a new version v0 n 1that is different from both vn andvn.
for convenience we call it the refactoring included version .
third bugbuilder computes the difference between the refactoring included version v0 n and the fixed version vn.
the difference is represented as a sequence of changes e.g.
removing or inserting a token noted as chgs .
fourth bugbuilder enumerates all possible subsequences of chgs and validates whether the subsequence represents a candidate patch.
to validate a subsequence schg chgs bugbuilder applies all changes in schg tov0 n which results in a new version v00 n .schg represents a candidate patch if and only if v00 n 1passes all test cases in tn 1and passes some test cases in tnthat fail on vn .
finally if only a single candidate patch is generated by bugbuilder bugbuilder outputs it as a patch for the associated bug report.
otherwise no patch would be outputted.
notably the patches generated by bugbuilder are intended to be applied to v0 n refactoring included version instead ofvn the original buggy version .
consequently applying such patches to the original buggy version may result in compilation errors and may fail to fix the defects.
although we may revise bugbuilder to generate patches that could be directly applied to the original buggy version we decide to follow the widely used defects4j whose patches are also intended to be applied to v0 n called vbugin defects4j so that existing tools and algorithms could seamlessly switch from defects4j to ours.
b. detecting and reapplying refactorings the key to exclude refactorings from bug fixing patches is to discover refactorings involved in bug fixing commits and remove such refactorings before patches are generated.
a few automatic approaches have been proposed to discover refactorings from version control systems for various reasons e.g.
to facilitate the evaluation of automatic refactoring recommendation algorithms empirical studies on code evolution and library api migration.
however to the best of our knowledge such approaches have not yet been applied to automatic extraction of patches.
a brief introduction to automatic refactoring detection is presented as follows to make the paper self contained and more details are referred to related work .
an automatic refactoring detection algorithm takes as input two consecutive versions noted as vn 1andvn respectively of the same application and matches elements e.g.
classes methods and variables across versions.
based on the matched elements the algorithm identifies which elements in the former version i e. vn have been removed which elements in the latter version i.e.
vn have been added and which elements are kept untouched.
the algorithm then defines a list of rules to detect refactorings based on the removed added and untouched elements.
for example if a method min class c1 of version vn matches a method m0in class c2 of version vn and c1does not match c2 the algorithm recognizes the changes as a move method refactoring that moves method m from class c1to class c2.
the performance of the algorithm depends on the accuracy of the employed element matching algorithm as well as the quality of the employed heuristic rules.
refactoringminer is more accurate than the alternative algorithms because it leverages an ast based statement matching algorithm that does not require any user defined thresholds .
to this end we leverage refactoringminer to discover refactorings in bug fixing code commits excluding those on test cases .
our approach excludes the discovered refactorings by reapplying such refactorings on the faulty version vn and employs the resulting version called v0 n instead of the original faulty version vn 1to generate patches.
the rationale is that we can divide the revision bug fixing commit into two 689steps i applying refactorings on vn which results in an intermediate version v0 n and ii fixing bugs and implementing new features if there is any on v0 n .
for convenience we call the intermediate version v0 n 1refactoring included version .
notably reapplication of the discovered refactorings is accomplished by calling eclipse refactoring apis .
such apis are widely used and well established.
for example if a bug fixing commit contains a rename refactoring that changes the name of method mfrom oldname tonewname we reapply the refactoring as follows 1rename m newname 2public void rename ijavaelement element string newname ... renamejavaelementdescriptor descriptor createrenamedescriptor element newname renamesupport renamesupport renamesupport.create descriptor shell shell platformui.getworkbench .getactiveworkbenchwindow .getshell renamesupport.perform shell platformui.getworkbench .getactiveworkbenchwindow invocations of eclipse refactoring apis are highlighted with gray background in the code snippet.
notably we have to customize the code snippet for different categories of refactorings to forward refactoring information from refactoringminer to refactoring apis because the required refactoring information and refactoring apis vary significantly among different categories of refactorings.
currently we have customized the code snippet for eight most common refactorings including rename classes rename methods rename variables rename fields rename parameters rename packages extract methods and extract variables .
such refactorings account for of the refactorings discovered in the bugfixing commits in defects4j.
c. generating potential patches for a given intermediate version v0 n 1and the bug fixing version vn the proposed approach generates all possible patches.
to this end it computes the difference between v0 n 1andvn excluding their differences in test cases .
the difference is represented as a sequence of token level changes e.g.
removing or inserting a token noted as chgs chg1 chg chg k .
each of the token level changes is composed of three parts position token and edition type.
edition type is either remove orinsert .
the proposed approach enumerates all subsequences of chgs .
each subsequence schg chgs represents a potential patch that makes all of the token level changes in schg on v0 n and ignores other changes in chgs .
to reduce the number of potential patches we also introduce coarse grained changes line level changes.
if a whole line of source code has been removed from v0 n we represent it as a linelevel change instead of a sequence of token level changes.
insertion of a new line of source code is handled in the same way as a line level change.
consequently a potential patch is finally represented as a sequence of token level and or linelevel changes.d.
validating potential patches the validation of a potential patch ptis conducted in two phases.
in the first phase the proposed approach applies this potential patch to the intermediate version v0 n resulting in a new version v00 n .
ifv00 n 1could not compile successfully the potential patch is discarded as an illegal patch and its validation terminates.
in the second phase v00 n 1is further validated with test cases associated with the faulty version noted as tn and those associated with the fixed version noted as tn as follows if any test case in tn 1fails on v00 n ptis not a valid patch and its validation terminates the proposed approach collects all test cases in tnthat fail onvn and notes such test cases as potential triggering test cases that may expose the associated bug ptis a candidate patch if v00 n 1passes at least one potential triggering test cases.
otherwise ptis not a valid patch and its validation terminates.
if and only if the proposed approach generates exactly a single candidate patch from a bug fixing code commit the approach recommends the candidate patch for the associated bug report.
otherwise no patch would be recommended.
v. e valuation a. research questions in this section we evaluate the proposed approach by investigating the following research questions rq1 how often do bug fixing commits contain bugirrelevant changes and what percentage of the changes in bug fixing commits are bug irreverent?
rq2 is bugbuilder accurate in extracting complete and concise bugs patches?
what percentage of real bugs patches could be extracted accurately by bugbuilder?
rq3 to what extent does the refactoring detection and replication affect the precision and recall of bugbuilder?
rq4 is bugbuilder scalable?
b. dataset our evaluation is based on the raw data in defects4j.
defects4j contains real bugs collected from real world applications.
for each bug it provides the bug fixing code commit the versions immediately following preceding the bug fixing commit called vnandvn respectively and the manually confirmed patch for the bug.
vnandvn 1are taken from version control history by defects4j without any modification.
vn 1is different from the faulty version vbug provided by defects4j because vbugis manually constructed to exclude refactorings and feature modifications whereas vn is an exact copy from the version control history.
notably only vnandvn 1are leveraged as the input of bugbuilder whereas the manually constructed patches provided by defects4j are leveraged only to assess the performance of bugbuilder i.e.
whether the automatically generated patches are identical to the manually constructed ones.
defects4j contains bug fixing commits from projects.
690however we failed to retrieve the vn 1version for project chart because the version ids for this project are invalid.
consequently this project was excluded from our evaluation.
as a result the evaluation was conducted on bug fixing commits from projects.
other bug patch datasets like ibugs and manybugs are not leveraged for the evaluation because they do not exclude bug irrelevant changes from the final bug fixing patches.
c. experiment design rq1 prevalence of bug irrelevant changes within bugfixing commits as introduced in section i bug irrelevant changes within bug fixing commits are preventing us from accepting the whole code commits as patches.
to investigate how often bug fixing commits contain bug irrelevant changes we compared the manually constructed patches in defects4j against their associated code commits.
the comparison was conducted in two steps.
first we investigated how often the patches are identical to their associated code commits psame number of commits identical to associated patches number of bug fixing commits assuming that patches in defects4j are complete and concise bug fixing commits that are not identical to the associated patches must contain bug irrelevant changes.
consequently pdi psame is essentially the percentage of bug fixing commits that contain bug irrelevant changes.
second we investigated what percentage of changes in bugfixing commits are bug fixing changes and what percentage of changes are bug irrelevant changes.
because patches in defects4j have been manually constructed to exclude bugirrelevant changes we took the size of the patches in defects4j as the size of bug fixing changes in the associated bug fixing commits while the size of the commit is the size of the whole patch in the version control history.
rq2 performance of bugbuilder to investigate the performance of bugbuilder we evaluated it on each of the bug fixing commits in defects4j as follow first we retrieved its associated vnandvn 1versions as well as the manually constructed patch pt4jassociated with the bug fixing commit second we leveraged bugbuilder to generate patches takingvn 1andvnas input third if bugbuilder resulted in a patch pt we compared it against the manually constructed patch pt4jto reveal whether the automatically generated patch is identical to the manually constructed one.
in case they are identical we call the generated patch a matched patch .
notably the comparison between generated patches and the ground truth is pure textual comparison of the patches and it is fully automatic.
an automatically generated patch is taken as a complete and concise patch if and only if it is a matched patch i.e.
it is identical to the manually constructed patch provided by defects4j associated with the same bug fixing commit.table i bug fixing and bug irrelevant changes in bug fixing commits projectsize of commits n1 size of bug fixing changes n2 n2 n1 commons cli closure compiler commons codec commons collections commons compress commons csv gson jackson core jackson databind jackson dataformat xml119 jsoup commons jxpath commons lang commons math mockito joda time total rq3 effect of refactoring detection and reapplication as specified in section iv b bugbuilder excludes refactorings from generated patch by detecting refactorings contained in the bug fixing commit and reapplying such refactoring to the associated faulty version vn .
to investigate to what extent the leveraged refactoring detection and reapplication may affect the precision and recall of bugbuilder we disabled refactoring detection and reapplication and repeated the evaluation as specified in section v c2 .
rq4 scalability to investigate the scalability of bugbuilder we depicted the quantitative relation between the run time of bugbuilder and the size of involved commits.
d. results and analysis rq1 bug irrelevant changes are common in bug fixing commits for each bug fixing commit cin defects4j we counted the size of the commit in lines and the size of bug fixing changes within the commit.
evaluation results are presented in table i. from this table we make the following observations first bug fixing changes account for of the changes made in bug fixing commits.
in other words of the changes in bug fixing commits are bug irrelevant and thus should not be included in patches for the associated bugs.
consequently taking the whole bug fixing commits as patches would result in unconcise patches.
such unconcise patches if employed by the evaluation of bugrelated approaches e.g.
automatic program repair could be misleading.
second the percentage of bug fixing changes i.e.
the last column of table i varies significantly from project to project.
it varies from on project commons csv to on project jackson dataformat xml .
one possible 691table ii performance of bugbuilder project bug fixing commits generated patches matched patches precision recall commons cli closure compiler commons codec commons collections commons compress commons csv gson jackson core jackson databind jackson dataformat xml jsoup commons jxpath commons lang commons math mockito joda time total reason for the variation is that different projects often pose different guidelines on how patches should be committed.
however regardless of the various guidelines posed by different applications it is unlikely to exclude bug irrelevant changes completely from all bug fixing commits.
we also investigated how often bug fixing commits contain bug irrelevant changes i.e.
pdi in section v c1.
evaluation results suggest that out of the bug fixing commits contain bug irrelevant changes and thus pdi .
it confirms the conclusion that simply taking the whole bugfixing commits as patches may frequently at a chance of result in unconcise patches.
from the preceding analysis we conclude that bug fixing commits often contain significant bug irrelevant changes.
consequently excluding such bug irrelevant changes from bugfixing commits is critical for automatic patch extraction.
rq2 bugbuilder is accurate and effective to answer rq2 we applied bugbuilder to each of the bug fixing code commits in defects4j and compared its generated patches against the manually constructed patches in defects4j.
if the generated patch is identical to the corresponding patch provided by defects4j we call it a matched patch .
evaluation results are presented in table ii.
the first two columns present project names and the number of bugfixing commits in the projects.
the third column presents the number of automatically generated patches.
the fourth column presents the number of the generated matched patches i.e.
generated patches that are identical to the manually constructed patches in defects4j.
the last two columns present the precision and recall of bugbuilder.
from this table we make the following observations first bugbuilder can generate complete and concise patches on of the bug fixing commits.
we notice that bugbuilder generated patches from bug fixing commits.
we also notice that of the automatically generatedpatches are identical to manually constructed ones which results in a recall of .
second bugbuilder is highly accurate.
among the automatically generated patches are identical to manually constructed ones.
we also notice that on out of the projects bugbuilder achieves precision i.e.
all patches generated from such projects are both complete and concise.
we notice that out of the automatically generated patches are different from their corresponding patches in defects4j.
we call them mismatched patches .
we manually analyzed such mismatched patches referring to the corresponding patches in defects4j associated bug reports and the associated code commits.
we notice that all of the mismatched patches are supersets of their corresponding patches in defects4j.
consequently the reason for the mismatch should be either or both of the following the patches generated by bugbuilder include some bugirrelevant changes i.e.
bugbuilder s patches are complete but not concise the manually constructed patches in defects4j miss some bug fixing changes i.e.
defects4j s patches are incomplete.
notably the comparison is based on the specification for concise bug fixing patches we proposed in section i. defects4j may have followed different specifications which could be a potential reason for the difference between the patches in bugbuilder and defects4j.
a surprising finding is that the automatically generated patches are often even better than manually constructed patches out of the mismatched patches are manually confirmed as correct i.e.
both complete and concise whereas their corresponding patches in defects4j miss some bug fixing changes i.e.
incomplete .
counting in such complete and concise patches the precision of bugbuilder 692fig.
.
duplicate changes in multiple places ignored by human experts fig.
.
throw statements ignored by human experts increases to and its recall increases to .
its precision is even higher than the experts who manually constructed the defects4j patches on the commits where bugbuilder generates patches bugbuilder generates only unconcise patches whereas the experts resulted in incomplete patches.
a major reason for incomplete patches in defects4j is that fixing a bug may require duplicate or highly similar changes in multiple places e.g.
multiple documents whereas human experts missed some places.
a typical example is presented in fig.
.
this is a bug fixing commit from project apache commons codec whose associated bug report is available at .
as the bug report explains the return statements return new string bytes charsets.xxx in a sequence of newstringxxx methods lines and could not handle null input and thus they should be replaced with return newstring bytes charsets.xxx .
however the patch in defects4j contains only the changes in one of the methods i.e.
the first method in fig.
and thus it is incomplete.
in contrast our approach successfully generates the complete patch containing all of the similar changes in all newstringxxx methods.
the second reason for the incomplete patches in defects4jis that they ignore the required changes in method declarations and or variable declarations.
a typical example is presented in fig.
.
the associated commit comes from apache commons csv whose associated bug report is available at and its manually constructed patch is available at .
as the bug report explains csvformat with header does not work with csvprinter .
to fix the bug the developers added the whole ifstatement lines to print the header if it is not null.
notably the method declaration of printrecord explicitly specifies that it has the potential to throw ioexception .
consequently inserting an invocation of this method line forces the enclosing method and its caller method print on line to explicitly specify the ioexception in their method declarations line and line .
otherwise the revision would result in compiler errors.
however the patch in defects4j ignores such changes in method declarations and thus it is incomplete.
in contrast our approach generated the complete patch including the changes in method declarations.
we also analyzed the four unconcise patches generated by our approach.
analysis results suggest that all of the unconcise patches are created because the leveraged refactoringmining tool missed some refactorings in the involved code commits and thus such uncovered refactorings were taken as part of the bug fixing patches.
a typical example is presented in fig.
.
this example comes from google gson and the associated bug report is publicly available at .
the bug report complains that the method more specially the return statement on line would result in null pointer exceptions when typeadapter is null.
to fix the bug developers inserted anifstatement line to validate that typeadapter is not null.
the patch provided by defects4j is composed of two changes only line and line .
other changes are ignored.
in contrast our approach takes all of the changes on the figure as bug fixing changes.
one possible rationale for defects4j to exclude other changes from the patch is that they could be taken as refactorings decomposing statement return typeadapter.nullsafe line into two statements typeadapter typeadapter.nullsafe on line and return typeadapter on line .
because variable typeadapter would not be used anywhere after the return statement line it could be used as a temporary variable safely.
as a result of the usage the keyword final line should be removed from the declaration of variable typeadapter because it is assigned changed on line as a temporary variable.
we will not argue that such changes should not be taken as refactorings.
however it is a rather complex and unusual extract variable refactoring if it is because an extract variable refactoring usually defines a new variable instead of employing an existing variable temporarily.
such an unusual refactoring is far beyond the capability of the state of the art refactoring mining tools.
consequently bugbuilder failed to recognize let alone reapplying this refactoring and thus took all of the changes as bug fixing changes.
the example in fig.
illustrates how unusual refactorings affect bugbuilder whereas the following example in fig.
illustrates how bugbuilder is affected by unsupported refac693fig.
.
imperfect patch caused by undiscovered refactorings fig.
.
imperfect patch caused by unsupported refactorings torings.
the bug fixing commit in fig.
comes from google closure compiler and the associated bug report is available at .
the bug fixing changes include the changes on thewhile condition lines and the ifstatement line .
such changes are included in both the automatically generated patch and the manually constructed defects4j patch.
however other changes i.e.
moving the declaration of local variables parameter and argument from the interior of the while iteration lines and to the outside of the while iteration lines are not taken by defects4j as bug fixing changes because they should be taken as refactorings the movement would not change the functionality of the method but improves its performance by avoiding the repeating definition of the same variables.
however this kind of refactorings is not yet supported by the refactoring mining tool that is leveraged by bugbuilder.
consequently bugbuilder failed to remove such refactorings from its generated patches.
notably it remains controversial whether the refactorings should be excluded from the patch because without such refactorings it is impossible to use variable parameter in the while condition as the patch does .
however in this paper we conservatively take it as a false positive of bugbuilder to avoid controversies.
we conclude based on the preceding analysis that bugbuilder can generate patches on a significant part of bug fixing commits in real world applications and the generated patches are highly accurate with an average precision of .
bugbuilder is even more accurate than human experts.
on bug fixing commits on which bugbuilder generates patches bugbuilder results in unconcise patches whereas human experts resulted in incomplete patches that miss some bug fixing changes.
rq3 refactoring detection and reapplication improves recall by to answer rq3 we disabled refactoring detection and reapplication in bugbuilder and repeated the evaluation on bug fixing commits collected by defects4j.
evaluation results are presented in fig.
where default setting enables refactoring detection and reapplication.
from this figure we make the following observations first enabling or disabling refactoring detection and reapplication has significant impact on the recall of bugbuilder.
enabling it improves the recall of bugbuilder from to resulting in a significant increase of .
second enabling or disabling refactoring detection and reapplication has no significant impact on the precision of bugbuilder.
the precision keeps stable regardless of the changes in the setting.
a possible reason for the stable precision is that the last part section iv c and section iv d of the approach can exclude incomplete unconcise patches which guarantees high precision regardless of the output of the first part refactoring mining of the approach.
enabling the detection and reapplication of refactoring increases the number of correctly generated patches and thus improves the recall because bug fixing commits often contain refactorings.
we successfully discover refactorings from out of the involved bug fixing commits which we call refactoring containing commits .
we also notice that out of the refactoring containing commits contain no refactorings except for the supported refactorings that the current implementation of our approach can identity and reapply.
from such commits bugbuilder with default setting successfully generates complete and concise patches.
disabling the detection and reapplication of refactoring however fails to generate such patches.
notably if the implementation of bugbuilder can support additional categories of refactorings in the future the recall of bugbuilder could be further improved.
an intuitive baseline approach noted iba is that iba takes the whole bug fixing commit as a patch if the commit does not contain any refactorings not limited to the eight categories of refactorings supported by the current implementation of bugbuilder .
in such a way iba would generate patches from bug fixing commits in defects4j.
however out the patches are unconcise i.e.
containing bug irrelevant changes.
consequently its precision is significantly lower than that of bugbuilder.
we conclude based on the preceding analysis that detecting and reapplying refactorings help improve recall of bugbuilder whereas its precision keeps stable.
694fig.
.
impact of refactoring detection and replication fig.
.
commit size influences average run time rq4 scalability fig.
presents a scatter diagram with a trendline depicting the relationship between the size of bug fixing commits and the run time of bugbuilder on such commits.
notably bugbuilder terminates when its run time reaches minutes on a single commit.
from fig.
we observe that the run time increases significantly with the increase in commit size.
we also notice that bugbuilder can efficiently handle bug fixing commits that contain up to thirty lines of changes.
by increasing the maximal time slot minutes at present for each commit bugbuilder can even handle larger commits in the future.
currently around of the commits ran out of the maximal time slot.
detecting and reapplying refactorings improves the efficiency of bugbuilder.
bugbuilder has reapplied refactorings on commits and its average run time on such commits was minutes.
we disabled the detection and reapplication of refactorings and reapplied bugbuilder to such commits.
our evaluation results suggest that disabling the detection and reapplication of refactorings increased the average run time on such commits significantly by .
we conclude based on the preceding analysis that bugbuilder is scalable and most of the commits could be handled within minutes.
e. threats to validity the primary threat to external validity is the limited number of involved bug fixing commits.
in the evaluation we evaluated bugbuilder on bug fixing commits collected by defects4j.
special characteristics of such commits may bias the conclusions of the evaluation.
we selected such commits for evaluation because defects4j provides manually constructed concise patches that exclude bug irrelevant changes.
as aresult we can leverage such patches as the ground truth to evaluate the quality of automatically generated patches.
to the best of our knowledge defects4j is the only bug repository that provides manually constructed concise patches for real bugs in open source applications and thus the evaluation was confined to the bug fixing commits in defects4j.
however to reduce the threat we should evaluate bugbuilder on more bug fixing commits in the future.
a threat to construct validity is that the manual checking of the generated patches and patches in defects4j could be inaccurate.
during the evaluation we manually checked the generated patches and their corresponding patches in defects4j when they did not match each other.
such manual checking could be biased and inaccurate.
to reduce the threat we presented typical examples in section v d2 and made all of the generated patches publicly available at .
another threat to construct validity is that the evaluation is based on the assumption that matched patches are complete and concise.
if an automatically generated patch is identical to the manually constructed patch in defects4j for the same commit we simply assumed that they are complete and concise.
however as discussed in section v d2 human experts may also make incorrect especially incomplete patches occasionally and thus the assumption may not always hold.
vi.
d iscussion a. it is critical to detect and reapply refactorings a bug fixing commit may contain three categories of changes bug fixing changes refactorings and functionalityrelated changes e.g.
implementation of new features .
bugbuilder can generate patches for pure bug fixing commits without any bug irrelevant changes with the potential patch generation section iv c and validation section iv d .
if a bug fixing commit contains both bug fixing changes and refactorings bugbuilder leverages the r efactoring d etection and r eapplication rdr for short to turn the commit into a pure bug fixing commit and then generates patches from it.
notably of the bug fixing commits in defects4j contain refactorings which quantitatively suggests the importance of rdr section iv b .
rdr has the potential to rescue such commits.
however the current implementation of bugbuilder supports only eight categories of refactorings which prevents rdr from reaching its maximal potential it improved recall by only in the evaluation.
another significant benefit of rdr is the significant improvement on the bugbuilder s efficiency.
excluding refactorings significantly reduces the size of commits and thus reduces the number of potential patches.
evaluation results in section v d4 suggest that disabling rdr increased bugbuilder s run time by on refactoring contained commits.
b. extremely high precision vs fairish recall high precision of bugbuilder is critical for the success of its future application.
we expect it to build highquality bug repositories without any human intervention and thus the generated patches should be comparable to manually 695constructed ones.
otherwise the resulting bug repositories could be misleading and may bias research and evaluation depending on them.
evaluation results in section v confirm that the automatically generated patches are comparable to and sometimes better than patches manually constructed by human experts.
in contrast a fairish recall is acceptable because it could be remedied by applying bugbuilder to massive bug fixing commits outside defects4j.
c. limitations bugbuilder succeeds on a substantial part of the bugfixing commits but fails on around of the commits as well.
bugbuilder works on a bug fixing commit only if the commit is composed of bug fixing changes only or the commit is composed of only bug fixing changes and refactorings.
notably if the refactorings within the commit are only applicable after the bug fixing changes existing refactoring mining tools like refactoringminer cannot identify such refactorings by comparing the bug fixed version vn and the original buggy version vn .
for example if developers insert a fragment of source code to fix a bug and then apply extract method refactoring to extract the inserted source code as a new method refactoringminer cannot identify the extract method refactoring because the extracted source code is not available in the original buggy version.
as a result bugbuilder would fail to split the commit accurately into a refactoring patch and a following bug fixing patch.
if the refactorings are required by the bug fix and thus applied before the fix or independent of the fix and thus could be applied before the fix bugbuilder has the potential to split the bug fixing commit into a refactoring patch and its following bug fixing patch.
if the commit contains bug irrelevant and non refactoring changes e.g.
implementing new features bugbuilder cannot work either.
take the bug fixing commit in fig.
as an example.
adding the functionality to print headers ofcsvformat is taken as a bug fixing action there.
however it could be taken as an implementation of a new feature printing herders of csvformat as well if this functionality has not been specified in the original requirements.
consequently it is challenging even for human experts to distinguish bug fixing changes from other functionality related changes without the help of requirements and bug reports.
however automatic and accurate comprehension of requirements and bug reports in plain texts remains challenging let alone requirements are often unavailable.
most of the bug fixing commits where bugbuilder fails contain functionality related bug irrelevant changes and this is the major reason for the low recall of bugbuilder.
although bugbuilder misses of the bugs patches it enables automatic construction of large bug patch repositories for the following reasons.
first bugbuilder is fully automated with extremely high precision.
second bugbuilder is not biased by the types of bugs but affected by only whether the fixes are mixed with other functionality related changes.
finally although defects4j extracts bug patches from only projects there are numerous open source projects to beexploited.
applying bugbuilder to such projects automatically could significantly increase the capacity of bug patch repositories thus offsetting bugbuilder s weakness low recall .
d. further improvement on recall in theory bugbuilder should be able to generate complete and concise patches for all pure bug fixing commits without any bug irrelevant changes .
however bugbuilder succeeded on only out of the pure bug fixing commits called pure commits for short in defects4j.
the major reason for the failure is the setting of the maximal time slots of the failed pure commits ran out of the maximal time slots.
increasing the time slots may improve the recall in the future.
another reason for the failure is the redundancy of some patches.
for example rejecting some changes i.e.
changes on lines of the defects4j patch publicly available at master framework projects lang patches .src.patch but not presented in the paper for space limitation would not change the semantics of the program.
consequently bugbuilder generated multiple candidate patches from it and thus bugbuilder did not known which one should be recommended.
improving the implementation of the proposed approach to support additional categories of refactorings may also significantly improve recall in future.
notably of the refactoring containing commits in defects4j contain some refactorings unsupported by the current implementation.
consequently supporting all such refactoring in future has the potential to double the effect of rdr that currently improves recall by .
vii.
c onclusions and future work large scale and high quality repositories of real bugs are critical for bug related research.
however existing approaches to building such repositories either fail to exclude bugirrelevant changes from patches or require human intervention.
to this end in this paper we propose a novel approach called bugbuilder to extracting complete and concise patches from bug fixing commits automatically.
bugbuilder has been evaluated on bug fixing commits in defects4j.
evaluation results suggest that it successfully generates complete and concise patches for forty percent of the bug fixing commits and its precision was even higher than human experts.
with the help of bugbuilder we plan to build large scale and high quality repositories of real bugs automatically in the future.
it is also practical and meaningful to build repositories of bugs in specific domains or planform e.g.
real bugs in mobile applications and real bugs in machine learning applications.
automatic approaches e.g.
bugbuilder to generating complete and concise patches from bug fixing commits may make such challenging tasks practical.