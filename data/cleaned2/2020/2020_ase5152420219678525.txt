learning patterns in configuration ranjita bhagwan microsoft research bhagwan microsoft.comsonu mehta microsoft research someh microsoft.comarjun radhakrishna microsoft arradha microsoft.comsahil garg university of california berkeley sahil garg berkeley.edu abstract large services depend on correct configuration to run efficiently and seamlessly.
checking such configuration for correctness is important because services use a large and contin uously increasing number of configuration files and parameters.y et very few such tools exist because the permissible values fora configuration parameter are seldom specified or documented existing at best as tribal knowledge among a few domain experts.
in this paper we address the problem of configuration pattern mining learning configuration rules from examples.
using pro gram synthesis and a novel string profiling algorithm we showthat we can use file contents and histories of commits to learnpatterns in configuration.
we have built a tool called confminerthat implements configuration pattern mining and have evaluatedit on four large repositories containing configuration for a large scale enterprise service.
our evaluation shows that confminerlearns a large variety of configuration rules with high precisionand is very useful in flagging anomalous configuration.
i. i ntroduction configuration management is an integral part of the development and deployment of large services.
these services depend heavily on correct configuration to run uninterrupted be flexible to changing environments and to scale seamlessly.this ubiquitous use of configuration in services poses severaldaunting challenges one of which is to ensure that everyconfiguration parameter is set to a suitable value.
to makematters worse the amount of configuration that a serviceneeds to manage grows significantly with time as the servicescales out and as developers add new features and capabilities.for instance the microsoft email service more thandoubled the number of configuration files in just a period ofsix months.
unlike code for which compilers and static analysis tools catch several types of errors well before the developer commitstheir changes very few tools exist to perform such checks onconfiguration.
this is because rules governing which config uration values are appropriate for a particular configurationparameter are very specific to the scenario in which the serviceuses the configuration value.
for instance a configurationvalue may capture a timeout for a particular microservicewhich the microservice expects to be a few minutes.
if adeveloper were to set this timeout value to a few millisecondsby mistake while she would be syntactically correct themicroservice may fail because of a lower bound check on thetimeout value.
worse if no such check exists the microservicewould start timing out much too soon in deployment andthereby cause service disruption.
such requirements of config uration correctness are seldom documented.
v ery often theyare subtle very specific to the context in which they are used and difficult to catch through specification and hard codedrule based checking.
consequently misconfigurations in largeservices occur much too often cause build and test failures and sometimes significant disruption and data breaches .
for instance in january microsoft exposed250 million customer records inadvertently because a databasespecified personally identifiable information e.g.
email ad dresses in an anomalous format .
towards addressing this we observe a unique opportunity driven by two recent trends.
first modern services maintainconfiguration in files separate from code such as yaml json or xml files.
engineers process configuration changes similarto code changes they commit changes to the configurationthrough a version control system.
we can therefore treatconfiguration as data by tapping into the version control system.
through commit logs and file histories we have access toa rich history of configuration file snapshots and changes fromwhich we can learn patterns in configuration values.
also since configuration is gated by version control systems wealso have the opportunity to automate configuration checks atcommit time and catch errors early well before deployment.
second the field of program synthesis for data processing has seen rapid progress in recent years.
tools like flashfilllearn programs that capture patterns in values structure andsequences and have been used successfully in various domainssuch as automated manipulation of tabular data and semi structured data extraction .
in this paper we bring the ideas of program synthesis and configuration as data together to perform configuration pattern mining.
we introduce a novel program synthesis based stringprofiling procedure to learn regular expression based rulesthat capture patterns in configuration values.
this procedure isbased on the techniques presented in but is significantlymore efficient and robust to noise.
for instance given enoughexamples the string profiling procedure can learn that atimeout value in a configuration file is always specified as anumber followed by the character s the regular expression s .
if a developer erroneously specifies a timeout value of 1ms or a timeout value of without specifyingthe units it will not match the learned regular expression andhence we can flag the mismatch as a potential configurationerror.
we use two types of input data or examples to the string profiling algorithm to learn to different kinds of rules forconfiguration values.
first we learn history based rules by using versions of the same configuration value in previous 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee commits and detect patterns in them.
second we learn filebased rules that learn patterns in different configuration values within the same version of a single configuration file.
we find that both rule types capture various configuration patterns andcan be used to flag misconfigurations auto suggest correctvalues to developers as they edit configuration and therebycontribute to improving configuration management.
we have built confminer a tool that uses the algorithms described here to implement configuration pattern mining.
wehave evaluated confminer on repositories that are usedto manage configuration for a large scale enterprise serviceused by hundreds of millions of users.
our results show thatconfminer is very generally applicable and learns a widevariety of rules.
we also observe that confminer s rulescatch many different kinds of misconfigurations very earlyin the development process.
this can help accelerate thedevelopment cycle of services and improve service reliability.
this paper makes the following novel contributions.
we introduce the problem of configuration pattern min ing i.e.
learning patterns in configuration from examplesthat we get from file version histories and commit histo ries.
to the best of our knowledge this is the first workto target the problem of pattern mining in configurationvalues.
we describe two types of configuration patternmining value based and structure based.
we develop a novel program synthesis string profilingprocedure and apply this to configuration as data to learnvalue based rules pertaining to configuration.
this pro cedure outperforms the state of the art string profilingalgorithm by .3x and is of independent interest outsidethe context of configuration mining.
we have built a tool called confminer that implementsour algorithms for value based rule mining.
we haveevaluated it on configuration repositories for a large popular service.
our results show that confminer is in deed effective in learning patterns in configuration values.
the rest of the paper is organized as follows.
section ii describes the problem of configuration pattern mining outlinesour solution and describes the scope of this work.
section iiidescribes the algorithm and system components in detail.section iv presents our evaluation of confminer and the stringmatching algorithm.
section v discusses threats to validity.section vi discusses related literature and section vii providesa conclusion to the paper.
ii.
p roblem definition and scope in this section we first explain configuration pattern mining with an example configuration file.
next we provide anoverview of how confminer performs configuration patternmining and how applications can use these patterns.
finally we discuss the scope of our work and bring out its inherentlimitations.
a. configuration pattern mining any configuration file be it in json xml yaml or any other format can be expressed as a hierarchical tree structure.
each google app engine application config file application foobar version 5runtime php55 manifest files url .
appcache static files upload static .
appcache mime type text cache manifest expiration 0s url .
webapp static files upload .
webapp mime type app x web app manifest json expiration 5s css javascript text etc url .
css js xml txt static files upload .
css js xml txt expiration 5m html pages url .
html static files upload .
html expiration 10m fig.
.
example configuration file derived from google appengine s app.yaml.
we have modified this file for illustrative purposes here.
node is a key value pair where the key is the configuration parameter and the value is the value that the configurationparameter is set to.
an edge connecting two nodes capturesa parent child relationship between configuration parameters.given this we envision two types of configuration patternmining value based and structure based.
v alue based pattern mining this is the process of learning patterns in the values of a configuration parameter.we use regular expression learning to do this.
consider theapp.yaml configuration file in figure which is an abridged example of a google app engine s configuration file .
theparameterexpiration highlighted in blue is set four times in different sections of the file and all values follow a certainpattern a number followed by an s for seconds or an m for minutes .
from this we can learn patterns for the value or a rule as the regular expression .
since we learn this rule based on the contents of the file alone we callthis a file based rule.
now notice the parameter version highlighted in red on the second line.
this is specified onlyonce in the file as but say previous values of this parameter in earlier revisions of this file were 3and4.
from all these values we can learn that this parameter is alwaysa number i.e.
follows the pattern specified as the regular 818fig.
.
confminer system overview expression .
we can learn this rule from a history of commits to this specific configuration parameter.
we call this a history based rule.
notice that the generalizations these rules provide are not unique.
for any given set of values we can learn multiple regu lar expressions.
for instance in the case of the expiration parameter we could learn a more general expression such as which allows any letter not just s or m .
or we could learn a more specific regular expression e.g.
which only allows numbers 5and10.
structure based pattern mining configuration files have a rigid structure.
in figure the file specifies a list of four ele ments each element is prefixed by a .
each list element hasa specified set of configuration parameters.
all four elementshave parameter expiration specified in blue whereas only two out of four elements have mime type specified in green .
from this we could infer that expiration is potentially a mandatory parameter whereas mime type is not.
another form of structural pattern is that there maybe an implicit ordering requirement of parameters.
certainparameters may have to be specified before others.
a commonexample of this is firewall configurations where the configuredrules are applied in order to determine whether a networkconnection should be allowed or denied.
each rule overridesall other rules that appear after it in the ordering.
thispaper concentrates on value based mining we leave work onstructure based pattern mining algorithms to future work.
b. system overview confminer s goal is to learn patterns for configuration that can be used by several applications to detect misconfiguration suggest changes and build automatic checkers.
figure showsan overview of the system.
first confminer runs a stringprofiling procedure on a specific file s contents to generatefile based rules for every configuration parameter that has alarge enough number of example values in the file e.g.
theparameterexpiration in figure .
next confminer uses commit histories for a specific configuration parameter to learnhistory based rules in a similar manner.
all learned rules their confidence and support are stored in a database.
therule learning algorithm runs periodically on file contents andhistories e.g.
in our deployment confminer learns rules oncea day.
applications query confminer through a simple interface which given a parameter and its value return all rulesthat match that value.
applications can use this interface inmultiple ways.
for instance an auto checker can at reviewtime post an automated comment if a commit to a particularparameter does not match any of the learned rules.
thisapplication is similar to commit recommendation systems suchas rex .
an ide can also use the rules to suggest changesto configuration parameters as the developer starts to typein the change.
this scenario is similar to intellisense invisualstudio or content assist in eclipse .
a thirdapplication is to enable building automated configuration com pilers and verifiers which can run along with code compilers perhaps as plugins to generate warnings etc.
this usage issimilar to stylecop .
c. scope we believe that configuration pattern mining is a vast subject which needs to be tackled through a significant body of research.
in this paper we concentrate primarily on value basedpatterns that can be captured through regular expressions.
hereis what the paper does not try to achieve.
building a sound complete system confminer is fundamentally a best effort system and since it learns from examplevalues it cannot be sound or complete.
notice that given a setof sample configuration values our example in section ii ashowed that confminer could learn more than one validregular expression given a set of inputs.
an application sefficacy will vary depending upon how specific the rules are.the more specific the rules the more strict an applicationwill be in enforcing them.
the more generic the rules are the application will be less strict but may miss out on validmisconfigurations.
to handle both scenarios confminer learnsa combination of rules that are very specific as well as verygeneric.
an application can then use thresholds to select morespecific or more general rules depending on its tolerance tofalse positives and false negatives.
going beyond regular expressions our work concentrates only on patterns that can be captured via regular ex pressions.
not all value based rules can be captured by regularexpressions.
for instance values of different parameters couldbe correlated.
or in certain cases the value of a particularparameter may change in a very specific way over time suchas theversion parameter in section ii a goes up by every time it is changed.
we leave learning such rules and propertiesto future work.
designing applications our goal is to design a pattern mining algorithm for configuration.
while we do not concen trate on building applications that can use the mined config uration patterns we have emulated an automated commentgenerator which in real time flags many misconfigurationsmade by developers in deployment.
section iv describes ourevaluation and application emulation in detail.
iii.
c onf miner design in this section we first give some background on string profiling and describe our program synthesis based string pro filing algorithm while providing details on the configuration specific parameters.
next we describe the data generationengine and the rule learning engine.
finally we describe the 819fig.
.
confminer components.
api that confminer exposes and that applications can use.
figure gives a summary of confminer s components andhow they interact.
a. profiling configuration v alues the string profiling problem.
first we address the problem of characterizing all the values a configuration parameter may take.
given the known set sof string values for a configuration parameter the string profiling problem is to produce a set of disjoint regular expressions rand a set of outliers o s such that s s.s o r r.s r. that is every string inseither matches one of the regular expressions in ror is in the outlier set o. here we use the notation s rto represent that a string smatches a regular expression r. the set of regular expressions ris called the profile ofs.
intuitively each r r defines a cluster of similar strings in s. we will use the set of known values obtained from the file or the history for a configuration parameter to learn a profilerand use the profile as a specification for any new values of the configuration parameter.
the correctness requirements of the string profiling problem are rather easy to satisfy.
the profile consisting the singleregular expression .
i.e.
the expression to match all strings is always a valid solution.
to obtain useful solutions weneed to define an optimality criterion.
we do not providethe full formal details of the criterion but instead refer thereader to .
intuitively an optimal profile is one such that summationtext r rscore r is minimized where score is a custom defined ranking function.
we use the same score function used in in particular in the microsoft program synthesis using examples sdk prose implementation of .
thisversion of score was tuned using over sample datasets across different application and data domains beyond justconfiguration mining.
the function score assigns scores based on two factors specificity and simplicity.
for example regular expressions that use the character class .
i.e.
class that matches all characters are given a high score while expressions usinglong constant strings are given a lower score.
on the otherhand the expression would be given a lower score than despite the latter being more specific the former is a simpler pattern.
we extend the optimality criterion to a noisy setting as summationtext r rscore r o o where o r is the outlier penalty.
we explicitly penalize outliers using the parameter o and tuning the value of ocontrols the balance between patterns and outliers.example iii.
.
consider the following set of values that the resourcepath configuration parameter takes s resource first.xml resource second.xml ... resource third.xml deployed main.xml deployed secondary.xml ... deployed tertiary.xml test resource.xml bracerightbig here the values fall into the following categories a v alues that match the regular expression r resource xml b v alues that match the regular expression r2 deployed xml and c the outlier value test resource.xml.
ideally a string profiling procedure will characterize the patterns in swith the regular expressions r r1 r2 and the outlier set o text resource.
xml .
this profile would signify that any new values for the configuration parametershould match either r 1orr2.
the stochastic string profiling procedure.
algorithm describes a stochastic algorithm for the string profiling problem.at its core the algorithm uses the learnregex to learn a single regular expression rfrom a set of generators g s .
in general the set gis small between 5strings.
we use the learnregex procedure from as implemented in the microsoft program synthesis using examples sdk prose .
algorithm stochastic string profiling algorithm require set of strings s require ranking score score ensure regular expressions rand outliers o s clusters while do g sample s clusters r learnregex g clusters clusters g mapsto r end while r approxexactsetcover clusters score o s s r r.s negationslash r return r o given a set of strings s algorithm maintains a dictionary clusters that maps subsets gofsto the regular expression r learnregex g .
each item g mapsto rinclusters is a potential cluster in the learned profile representing the strings s s s r .
the procedure proceeds through the following stages generate.
we repeatedly sample small subsets size o f sand learn a regular expression using the learnregex procedure.
during sampling we do not construct gby uniformly 820sampling from s. instead we obtain gas follows we start with an empty gand extend gwith one of the following randomly chosen options times string s s that does not belong to any cluster all the generators gof a cluster g mapsto rinclusters and string swhere s s does belong to a cluster in clusters this biased sampling attempts to achieve one of the following a construct a new cluster out of the strings that do not belongto any cluster b merge or extend existing clusters to forma larger one and c construct new clusters independently ofexisting ones.
ideally the sample and learn loop is run untilall patterns in the desired profile are added to the clusters collection.
however we do not know the desired patterns inpractice we sample until no new regular expressions have beenadded to clusters for10iterations.
select.
now given a set of candidate clusters and the score function we use an approximation algorithm for the minimalexact set cover to pick a near optimal subset of clusters.
givena set xand a set of its subsets y x ... x n with a cost function mapping xito reals the exact set cover problem asks to choose a subset of y prime ysuch that each xi xj y prime are disjoint and uniontext xi y primexi x. of all such possible y primewe prefer the one with the minimal total cost.
in our setting a x is the set of all strings s b ycontains the set of candidate clusters clusters and c the cost function is score.
the approximation algorithm follows standard greedy set cover algorithms it maintains a partial solution in this case a set of regular expressions r r2 ... r k .
in each iteration the cluster g mapsto rwhich maximizes s s s r i.s negationslash ri score r is added to the partial solution and all clusters which intersect with riare discarded from clusters .
however we do not proceed until all strings in sare covered in the solution.
instead we stop adding to the partialsolution when the value s s s r i.s negationslash r i score r drops below the outlier penalty o 1for all rinclusters .
the strings in sthat are not matched by any riin the solution are deemed outliers o. our implementation additionally returns the confidence and support for each pattern which are definedas the fraction and the number of strings respectively that arematched by the corresponding regular expression.
it should be noted here that the fact that the procedure ignores a small fraction of outliers is particularly of importanceto us since this ensures that any rare examples of thatconfiguration parameter which might be existing or historicalmisconfigurations are not matched in the learnt profile.
example iii.
.
consider the set of strings sfrom example iii.
.
in the first phase of the algorithm we sample subsets of sand learn regular expressions from these samples.
here we have 4separate cases a the sample only contains strings of form resource date file name .xml in this case learnregex returns r .
b the sample only contains strings of formdeployed file name .xml.
in this case learnregex returns r .
c sample contains strings of both forms.
here r3 xml is returned.
d the sample contains the outlier stringtest resource.xml.
here r xml is returned.
by design the ranking score score function produces scores with score r1 score r2 score r3 score r4 b yt h e principle of specificity.
during the second phase selection the clusters are chosen using the greed heuristic with r1and r2picked in sequence.
for the rest of the clusters the normalized scoreis less than the outlier penalty o .
hence the string test resource.xml is deemed an outlier .
note that the selection of regular expressions depends heavily on the score function.
with different score functions there are cases where the preferred cluster may be r3orr4.
comparison to we do not go into a full comparison of algorithm with as it is not related to the mainthesis of this paper.
summarizing the performance aspectof the comparison algorithm is .3x faster than on the set of benchmarks from see figure .
thisperformance improvement can be attributed to avoiding theexpensive agglomerative hierarchical clustering ahc basedapproximation which is o n in the number of input strings.
the time taken by algorithm is dominated by the sample fig.
.
performance comparison of algorithm vs. flashprofile phase.
the number of sampling iterations to produce goodprofiles depends on the number of patterns in the desiredprofile as opposed to the number of input strings.
as thenumber of patterns in the profile is significantly smaller thanthe number of input strings algorithm is often more efficientthan ahc.
further algorithm often produces profiles of a higher quality than .
in the string profiling setting ahc issensitive to incorrect decisions in a manner that is not possiblefor numerical data.
ahc proceeds by initially considering eachstring to be a cluster by itself and then iteratively mergingthe two clusters that are the closest to each other.
here thenotion of distance is given by the score value of the regular expression generated by the strings in the cluster.
one incorrectmerging decision often due to outliers or similar strings ofdifferent patterns has a cascading effect and may produceundesirable profiles.
example iii.
.
consider a set of strings representing dates 821of the forms january and23 feb .
suppose the set contains the strings may and may .
it is likely that the first merge performed by ahc will group these strings together to obtain theregular expression may .
this is because the resulting regular expression is very specific and will havea low score value.
after this point all subsequent clusters will either include both these strings or exclude both of them.hence we can never obtain the desired regularexpressions and .
instead ahc returns a profile that has the single regular expression which mixes the two formats.
similarly in the presence of outliers one incorrect decision merging an outlier with a non outliercluster will cause significant degradation of the final results.algorithm avoids these issues even if the sampling groupsstrings incorrectly the clusters that arise from these groupswill be safely ignored during the selection phase.
b. token dsl for configuration mining.
we use the prose sdk implementation of the learnregex procedure.
however this procedure had to be customized to the context of configuration mining.
during the learningprocess learnregex constructs regular expressions using a domain specific language dsl of generic tokens such as for digits and for uppercase letters.
confminer has had to modify the dsl to make it more configuration specific.
consider the following example scenarios.
we found that configurations often capture names such as file names test names and firewall rule names.names can have an arbitrary number of camel casedterms.
for instance a parameter testname captures the names of tests to run on a particular code base.
sayconfminer s data collection found three unique values for it testcomponent testdata testsystem .given the generic dsl confminer would learn the regularexpression test which allows only one camel cased term to follow test.
hence if an application queries confminer with the value testappdata for this parameter the regular expression will not match it since ithas two camel cased terms following test.
to accommodate this scenario the configuration specific dsl ignores the token and hence confminer learns the regular expression test which is much more general and allows an arbitrary number of camel cased terms in the name.
the configuration specific dsl also includes new tokens.
for instance we found that values often capture lists ofarbitrary sizes where a delimiter such as a comma separatesthe list elements.
to allow for lists of arbitrary size theconfiguration specific dsl includes tokens such as w which covers comma separated lists or arbitrary size.
if thedsl does not include such list specific patterns confminerlearns regular expressions only towards a specific number ofelements in the list which again causes incorrect matchingbehavior in a large number of cases.
c. data generation engine we now describe the data generation process for file based and history based rules.
file based data generation to learn file based rules is triggered every time a configuration file is changed.
confminer s data generation engine parses the configura tion file using format specific parsers.
currently our im plementation supports different file types including xml json yaml and ini.
each parser gives us a tree objectthat captures all the configuration in a structured for mat.
from this confminer extracts tuples of the form file name param name list of values .aparameter name such as expiration in figure can exist under different parent configurations.
we made the choiceto ignore the ancestry of each parameter and as long astheir names are identical confminer combines all values ofparameters within the same tuple and into one list of val ues.
hence for the mentioned example confminer generatesthe tuple app.yaml expiration 0s 5s 5m 10m .
this increases the number of values foreach parameter and more data allows for rules with higherconfidence and support from the string profiling algorithm.
history based data generation for history based rules is triggered every time a commit changes an existingparameter in a configuration file.
for every file commit confminer runs a differential analysis on the file to detectwhich particular configuration parameter has changed.
atextual difference which version control systems readilyprovide does not suffice because it is possible that the valueof a parameter spans multiple lines and if only some ofthose lines are changed one cannot tell what the changedparameter is.
confminer therefore performs the differenceat a syntactic level.
to do this it uses configuration parsersto learn the tree object for the old version of the file doesthe same for the new version of the file and compares themusing heuristic approaches.
from these comparisons it findsa the changed configuration parameter and b the new valueit is set to.
from this confminer creates tuples of the formfile name param name list of values .
in addition confminer also generates new tuples that combine data across files if the configuration parameter name param name is the same.
this aggregated data isparticularly useful towards learning rules that govern genericdatatypes such as ip addresses and dll version numberswhich could have the same format across different files.section iv c shows several examples of file based rules andhistory based rules that confminer learned in deployment.this includes examples of generic patterns that exist acrossfiles as well.
depending on file format configurations could have slightly varying structure.
for instance in the xml format a config uration parameter apart from having a value could have attributes which themselves have set values.
confminer accom822modates all these specific details for different formats.
more details on the implementation are provided in section iv a. d. rule learning engine once confminer generates data for file based and historybased rules separately it uses the string profiling algorithm which returns a list of regular expressions with the confidenceand support for each.
while rules with higher confidence andsupport are indicative of well behaved values of a config uration parameter rules with very low confidence or supportmay be equally important and useful.
at first glance this ap pears counter intuitive.
but several configuration parameters in reality have very varied patterns like the url parameter in figure .
learning one regular expression that capturesall these parameters would make the regular expression toogeneric albeit with high confidence and support.
we havefound that it is indeed better to learn a small number ofregular expressions that capture the whole set of values witheach regular expression having relatively low confidence andsupport.
we use the score parameter in the string profiling algorithm to strike this balance and set a very low threshold onthe confidence and support of the rules learned.
the confidencethreshold is set to .
i.e.
if a cluster contains of known file based or history based values for a configurationparameter the corresponding rule is considered valid.
for ruleswith confidence lower than this threshold the correspondingvalues are considered accidental or outliers i.e.
even if anew configuration value matches this rule it is consideredpotentially incorrect and flagged.
currently confminer s rule learning engine is triggered once a day.
using all commits within that day it learns history based rules using a commit history of months.
it learns file based rules for any configuration file that has been changedon that day.
finally confminer stores all learned rules in acentral database indexed by file name and or parameter name.
e. confminer api the above sections have described the process by which confminer learns regular expressions given input examples.
we now describe the api using which applications can useconfminer.
the primary call that confminer supports isfindmatches file name param name value .the call returns a list of all file based and history based rulesthat the value matches along with the confidence and supportfor each rule.
the application can then further filter the set ofrules based on its own confidence and support requirements.if no matching rule is found the function returns a null value.confminer also returns matches using generic history basedrules which hold across different file names.
again theapplication can decide to keep these rules or eliminate them.
iv .
e v alua tion we first describe details of the confminer implementation and describe our deployment of confminer on repositories ofmicrosoft a large scale widely used enterprise service.
wethen evaluate the string profiling algorithm using real data fromthese repositories.
we emulate an automated misconfigurationchecker and show that confminer rules flag several miscon figurations as and when developers commit them.
finally weexamine real world configuration issues as reported in thectest dataset to determine how often configuration patternmining can help find real misconfigurations.
a. implementation confminer is implemented using lines of c code and works with git .
the data generation engine interfaces with both github and azure devops .
it supportsa total of file types that typically store configuration including xml json yaml csproj config and ini.
for eachformat the data generation engine implements parsers whichfirst translate the file contents into the xml format.
confminerthen inputs the xml for the old version and the new version to adifference module which implements the differential syntactic analysis required to learn history based rules.
the differencemodule is built using the xmldiffandpatch library.
the confminer api is implemented using approximately 1500lines of c code.
in our azure devops implementation weuse service hooks to capture commits to configurationfiles as and when they happen.
b. deployment we have deployed confminer on four repositories belonging to a large continuously deployed service within our enterprise as shown in table i. r1 contains both code and configu ration of core features in the service.
r2 contains informationregarding physical configuration such as datacenter specificconfiguration and network specific configuration.
r3 containscode and configuration related to the devops environment i.e.build test and deployment pipeline for the service.
finally r4contains code and configuration for all applications built ontop of the core features that the service provides.
most configuration for these repositories sits in xml json and ini files.
the config changes column tells us the numberof configuration parameters that have been changed in thelast six months.
this is as high as in the case of r4.the rule learning engine uses these changes to learn history based rules.
increasing history beyond six months makes thecomputation of rules slow and also biases the rules towardsolder data that may not be relevant.
the file changes columngives the number of configuration files changed in the last sixmonths.
this is much lower than the configuration changesbecause every file captures multiple configuration parameters.finally the history based rules column and the file basedrules column show the number of rules confminer learns inthese two categories using six months of data.
c. example rules table ii gives some example rules that confminer has learned in deployment.
both file based and history based techniques learned similar rules.
as can be seen the supporti.e.
the number of input examples that match each learnt rulecan vary widely sometimes reaching a few thousand.
also 823t able i det ails of repositories tha t conf miner is deployed on .f ile changes and configura tion file commits are for the last six months .
repository config file counts config changes history based rules file changes file based rules json xml ini r1 r2 r3 r4 t able ii example rules learned .
no.
file type config name rule examples support xml servername srdc nlb a srdc nlb 01a srdc nlb 03a config version .
.
.
.
.
.
.
.
.
xml runtime .
.
.
csproj include tbuild db .xml tbuild db3.xml tbuild db9f.xml xml duration timeservers .
.
.
.
.
.
json normal 0x 0x212838 0x7c68b2 json testprofiles search suggestions search teams recommendations search suggestions ini orderby userrelation desc userrelation trendingweight desc userrelation lastaccesstime desc ini itemname autosuggest .
autosuggest.l0rankercontrolcsgindex autosuggest.l1v3rankercsgindex confminer learns many rules across all major configuration file types such as xml json andcsproj.
rules learned many different kinds of patterns.
row shows how confminerlearns formats in machine names.
row demonstrates thatversion numbers in a particular configuration file consist offour numbers separated by a .
.
rows and capture twodifferent time formats.
row shows an example pattern inincluded file names in a project file.
row is an example of anaggregated history based rule across many files.
it learns twovery specific ip addresses.
row infers a digit hexadecimalpattern.
row learns a list of strings with a specific pattern i.e.
the word search is always second in the list.
finally row9 and row show miscellaneous examples of configurationvalue patterns that specify an ordering relationship and anauto suggest algorithm.
as these examples show patterns of very different types exist across various configuration values that have a wide arrayof semantics.
using a generic program synthesis frameworkenables confminer to be relevant in a large number of scenar ios which are very different from each other.
moreover thisvaried set of rules shows that specifying such rules manuallyis a formidable task which cannot be achieved at scale withoutdevelopers making a huge investment in time and effort.
d. precision we perform an online evaluation of confminer on these four repositories.
notice that since confminer is actually deployed on these repositories evaluation is more realisticthan a standard train test split based evaluation.
when adeveloper completes a pull request that changes a configu ration file confminer first determines which configurationparameter is changed and what value it is changed to.
to dothis confminer uses the same difference algorithm as usedto generate the data to learn history based rules.
then foreach changed parameter we call the findmatches function provided by the confminer api.
confminer checks if thechange matches any of the rules learned in the previous day confminer s rule learning engine runs once a day.
.
if it does the change is labeled a true positive tp i.e.
confminer has indeed learned a rule that the new value matches.
if nomatch is found the change is labeled a false positive fp i.e.
confminer was not able to learn a rule that matchesthe new value.
the precision of confminer is calculated as tp tp fp .
note that we assume that if a developer iscompleting a pull request with a changed configuration file itmust be correct.
it is of course possible that the value is wrong and the developer corrects it later.
we make the reasonableassumption that such situations arise only rarely.
table iii shows the total precision precision due to filebased rules and precision due to history based rules for allconfiguration changes made from 18th of july to date.total precision lies between .
and .
.
in general history based learning shows overall better precision than file basedlearning with the value being as high as .
.
the slightlylower precision of file based rules is because a lot of theserules learn patterns in file paths and file names.
thus whendevelopers introduce a new file path or change the format 824t able iii overall precision file based precision and history based precision tha t conf miner achieves .
repository total file based history based tp fp precision tp fp precision tp fp precision r1 .
.
.
r2 .
.
.
r3 .
.
.
r4 .
.
.
fig.
.
example manual comment that can be replaced by confminer.
all de anonymizing information is elided.
of a file name slightly this is recorded as a false positive.
sometimes these new file paths or name format changes arerequired and therefore our rules are indeed wrong.
however very often we found that our rules though marked as false positives were indeed valid because they required the formatof the file path or name to be fully consistent with previouslyseen examples and the developer had committed a path orname in a slightly different format.
we explain one suchexample in detail in section iv e3.
such rules though they donot flag misconfigurations do point to style defects addressingwhich can improve hygiene and readability of configuration.
e. application emulation section iv d gives us confidence in the inherent ability of confminer to learn rules with high precision.
now we ask how useful these rules are in flagging misconfiguration.
forthis we have built a misconfiguration detection applicationon top of confminer which tracks every commit to a config uration file.
if the commit does not match any rules a flagis raised that this is a potential misconfiguration.
the flag issilent i.e.
the developer is not informed of the flag.
hence wecall this an emulation of the application.
if before completing the pull request the developer changes the configuration valueagain so that it now matches a learned rule it indicates thatthe previous value was indeed incorrect and the flag that ourapplication raised was valid.
we now present a few examplemisconfigurations that our emulation flagged.
we have usedredacted screenshots to keep them anonymous.
path based misconfiguration we notice that configuration values that hold file names and file paths are oftenmisconfigured with relative paths rather than absolute paths.confminer has been very effective at flagging this.
figure 5shows an example pull request that confminer flagged.
a fig.
.
confminer flagged this since the timestamp did not match the rule.
reviewer manually calls out this error for correction throughthe comment thereby confirming that the flag was indeedvalid.
given that confminer flagged this error by the devel oper we believe that the comments on such errors which arecurrently entirely manual can be automated.
moreover sinceconfminer takes at most a few seconds to flag such errors i.e.
the time it takes to call the confminer api it can flagsuch errors much faster than the manual review process.
numerical misconfigurations in figure we see that in line the developer changed a valueforbootstraptimestamp from1.
to .
.
however in multiple other sections of thefile for instance in line the same configuration has beenset to2.
.
a file based rule therefore learned that this configuration should be set such that the first number thatappears is a single digit and not two digits as in .
noticethat the reviewer also made this comment albeit with muchmore semantics saying that the developer has set the numberof days as and not the number of hours.
this exampleshows that confminer through its simple regular expresslearning can sometimes flag subtle misconfigurations evenwithout understanding the semantics.
the challenge though if we are to automate comments based on this is to makeautomated comments capture semantics like the reviewer hasin this example.
we leave this to future work.
fig.
.
confminer flagged this change because of an anomalous file name.
style recommendations confminer flags several stylerelated recommendations as well.
figure shows an example 825where confminer learns a specific file format a string based name followed by a hyphen and a date.
the shown commit online uses an underscore instead of the hyphen.
confminerflagged this commit but unlike previous examples since thisis merely an issue of style no reviewer specifically calledthis out.
in fact past interviews we have conducted haveshown that reviewers hesitate from calling out such nits tomaintain professional courtesy.
we believe that automatingsuch flagging of format issues can greatly improve readabilityand hygiene for configuration while directing potential irefrom developers at a bot rather than a human reviewer.
f .
real world misconfigurations to see how often such pattern based misconfigurations occur in the wild we manually examined the ctest dataset which contains real world configuration induced failurescollected from open source projects.
we found that of the64 issues were due to misconfiguration while the remaining13 were due to bugs in code that parsed the configurations.
we studied the misconfigurations in detail and found misconfigurations could potentially be caught using patternmining.
of these misconfigurations were due to incor rect string formats in the value specified.
for example inhdfs the configuration parameter has to be parsedas an http address any other string would cause a failure.the remaining were due to numerical values lying outsidea permissible range.
for example in hbase the configuration parameter should either be a float value lessthan .0or an integer greater than .
regular expressions can capture such specification.
however in the other cases we found that regular expressions would not capture the specification for the configu ration.
for example in issue zookeeper the user has to specify two configuration parameters or neither specifyingonly one of the two caused an error.
in issue hadoop a configuration parameter has to be set to a directory path and not a file path.
regular expressions cannot tell a file apartfrom a directory.
hence of all misconfigurations of51 were amenable to pattern mining.
with enough trainingexamples confminer can learn such patterns.
v. t hrea ts to validity as mentioned in section ii c confminer is a best effort system built on an inherent assumption that new configurationvalues will be similar to previous ones.
hence if a developerknowingly changes the value format confminer will not find amatch and hence will generate a false positive.
however this isunavoidable unless the developer provides hints to confminerbefore hand that the pattern is about to change.
manual inputof this nature while useful is error prone and does not scale tolarge services that uses millions of configuration parameters.hence our effort has been to drive false positives down asmuch as possible by fine tuning the string profiling algorithm.
also since we depend upon commit histories and our difference module that performs a syntactic analysis of configurationfiles for our implementation to be effective configurationshould be stored in well formed files that are easy to parse andwell separated from code.
if specification of configuration isinter twined with code or if they use non standard formats itbecomes difficult to fine tune our difference module to do therequired syntactic analysis.
while we do see examples of suchscenarios in most cases we observe that developers maintaingood hygiene and keep configuration and code files separate.
our approach only considers the syntactic format of configuration values and ignores the semantics altogether.
forexample even when the format of a timeout parameter iscorrect the value may be incorrect in practice due to beingvery large or very small.
in practice it is not feasible to builda general and completely automated configuration mining toolthat takes semantics into account.
vi.
r ela ted work a. configuration management previous work has used configuration files to learn correct data types and flag misconfigurations when they occur.configuration spellcheck uses program analysisto detect configuration data types as well.
we believe thatdetecting patterns based on data types is very useful butcannot capture the nuanced fine grained and varied patterns inconfiguration that are prevalent in today s large scale services as shown in table ii.
further apart from the basic data types configuration spellcheck requires the user to manually enterregular expression specifications for each configuration pat tern.
we believe that the number of configuration parametersin modern systems make manual authoring of specificationsdifficult or impossible.
several other tools exist to check andvalidate a configuration file against a given specification .
however most specification is high level and has to bemanually entered by developers.
recent work has focused on multiple data driven and program analysis based techniques to detect various differentkinds of misconfiguration.
rex and encore useassociation rule mining to detect configurations that are cor related and flag misconfigurations based on the learned rules.pcheck by performing static analysis on code generatesfast configuration checkers that emulate the code that usesthe configuration.
code analyzes event logs to detectanomalous event sequences and flag potential errors in con figuration.
though not related to configuration getafix uses pattern mining in code to detect missing null referencechecks in code.
all these techniques are complementary to theprogram synthesis based approach we take.
several tools address how large services run by facebook microsoft and akamai have dealt withthe problem of configuration management.
these tools helpengineers manage configuration across large deployments thatspan several geographies.
a number of commercially availablethird party tools also target configuration management .
facebook s holistic configuration specifically illus trates the effort required to detect misconfigurations early byusing automated canary testing for changed configurations andusing user defined invariants to drive configuration changes.
826we believe that techniques such as ours can work well in tandem with such configuration management systems to checkfor correctness before deploying configuration widely.
b. profiling and program synthesis previous work on data profiling has focused more on statistical profiling of numerical data .
see for a survey of techniques.
several works in thedatabases literature have considered mining specifications thatrelate the values of one attribute to values of another throughfunctional dependencies .
while we focus moreon string typed values of a single configuration parameter onepotential direction for future work is to extend the work tolearn from both numerical and string data possibly relatingthe configuration values of one parameter to another.
program synthesis has recently found significant success in the data manipulation cleaning and transformation fields .
in these settings the synthesis takes the form ofprogramming by example where the user provides a few input output examples.
however in the string profiling setting theuser does not provide examples of each cluster in the profile instead the synthesizer predictively learns the profile.
in thismanner string profiling is closer in nature to other predictivesynthesis works in the domain for data extraction .
c. regular expression and automata learning.
the l algorithm was the first technique that learned finite automata from examples.
many variants of l have been studied over the past few decades extending it to other automata variants including non deterministic fi nite automata alternating automata and symbolicautomata .
however unlike our technique l and its variants depend on an active teacher i.e.
an oracle that canproduce counter examples to intermediate guesses made bythe learning algorithm.
there have also been recent worksthat learn regular expressions from natural language using bothsequence to sequence models and program synthesistechniques .
there are several key differences between the current work and previous techniques driven by the underlying setting andmotivation.
the setting of our problem requires a techniquethat can learn multiple simple regular expressions that togethermatch the examples as opposed to a single complex one whileignoring noise in the provided examples.
flashprofile is able to produce multiple regular expressions.
however asdepicted in section iii our technique produces higher qualityprofiles more efficiently as compared to flashprofile.
l and other language theoretic algorithms optimize either the sizeof the output automata or regular expression or minimalityunder language inclusion resulting in complex and over fittedregular expressions making them unsuitable for our purposes.
vii.
c onclusion we have described a string profiling algorithm that learns various patterns in configuration used by large services.
wehave realized this through a tool called confminer which isdeployed on four repositories that maintain configuration fora large enterprise service.
using two sets of data that areavailable through version control systems file based andhistory based we show that our techniques learn a largenumber of varied patterns in configuration.
these patternscapture various kinds of semantics thereby making the casefor a generic algorithm that works across multiple domains.finally we also show that using these patterns we can capturevarious kinds of misconfiguration at commit time.
r eferences microsoft microsoft .
.
salesforce acccess issue may and june .
salesforce.com incidents .
.
google google cloud networking incident .
google.com incident cloud networking .
.
sophos the state of cloud security .
https secure2.sophos.com en us medialibrary pdfs whitepaper sophos the state of cloud security wp.pdf.
.
o. moolchandani cloud waterhole a novel cloud attack observed on twilio.
accessed august .
m. s. r. center access misconfiguration for customer support database.
.
s. gulwani automating string processing in spreadsheets using inputoutput examples in proceedings of the 38th acm sigplan sigact symposium on principles of programming languages popl austin tx usa january t. ball and m. sagiv eds.
pp.
acm .
v .
le and s. gulwani flashextract a framework for data extraction by examples in acm sigplan conference on programming language design and implementation pldi edinburgh united kingdom june m. f. p .
o boyle and k. pingali eds.
pp.
acm .
r. singh blinkfill semi supervised programming by example for syntactic string transformations proc.
vldb endow.
vol.
no.
pp.
.
r. martins j. chen y .
chen y .
feng and i. dillig trinity an extensible synthesis framework for data science proc.
vldb endow.
vol.
no.
pp.
.
a. s. iyer m. jonnalagedda s. parthasarathy a. radhakrishna and s. k. rajamani synthesis and machine learning for heterogeneousextraction in proceedings of the 40th acm sigplan conference on programming language design and implementation pldi phoenix az usa june k. s. mckinley and k. fisher eds.
pp.
acm .
m. raza and s. gulwani automated data extraction using predictive program synthesis in proceedings of the thirty first aaai conference on artificial intelligence february san francisco california usa s. p .
singh and s. markovitch eds.
pp.
aaai press .
s. padhi p .
jain d. perelman o. polozov s. gulwani and t. d. millstein flashprofile a framework for synthesizing data profiles proc.
acm program.
lang.
vol.
no.
oopsla pp.
.
google google app engine app.yaml reference.
com appengine docs standard python config appref.
.
s. mehta r. bhagwan r. kumar c. bansal c. maddila b. ashok s. asthana c. bird and a. kumar rex preventing bugs and miscon figuration in large services using correlated change analysis in 17th usenix symposium on networked systems design and implementation nsdi santa clara ca pp.
usenix association feb. .
visual studio code intellisense in visual studio code.
visualstudio.com docs editor intellisense.
.
content assist in eclipse.
assist.htm.
.
stylecop analyzers for the .net compiler platform.
dotnetanalyzers stylecopanalyzers.
.
microsoft microsoft program synthesis using examples prose sdk.
.
x. sun r. cheng j. chen e. ang o. legunsen and t. xu testing configuration changes in context to prevent production failures in 14th usenix symposium on operating systems design and implementation osdi pp.
usenix association nov. .
the git v ersion control system.
github inc. .
microsoft azure devops.
devops .
.
microsoft generating diffgrams of xmlfiles.
packages xmldiffpatch .
.
microsoft azure cloud services.
azure cloud services cloud services choose me.
.
m. santolucito e. zhai and r. piskac probabilistic automated language learning for configuration files in computer aided v erification s. chaudhuri and a. farzan eds.
cham pp.
springerinternational publishing .
a. rabkin using program analysis to reduce misconfiguration in open source systems software tech.
rep. electrical engineering andcomputer sciences university of california at berkeley .
a. rabkin the conf spellchecker tool.
jchord tree master conf spellchecker.
.
v alidating xml files using xsd in c .
article how to validate xml using xsd in c sharp .
.
configcop a swift command line application that verifies .xcconfig files against a template.. accessed august .
t. xu x. jin p .
huang y .
zhou s. lu l. jin and s. pasupathy early detection of configuration errors to reduce failure damage in 12th usenix symposium on operating systems design and implementation osdi savannah ga pp.
usenix association .
d. y uan y .
xie r. panigrahy j. y ang c. v erbowski and a. kumar context based online configuration error detection in proceedings of the usenix conference on usenix annual technical conference usenixa tc usa p. usenix association .
a. scott j. bader and s. chandra getafix learning to fix bugs automatically corr vol.
abs .
.
c. tang t. kooburat p .
v enkatachalam a. chander z. wen a. narayanan p .
dowell and r. karl holistic configuration manage ment at facebook in proceedings of the 25th symposium on operating systems principles pp.
acm .
a. sherman p .
a. lisiecki a. berkheimer and j. wein acms the akamai configuration management system in proceedings of the 2nd conference on symposium on networked systems design implementa tion v olume nsdi berkeley ca usa pp.
usenixassociation .
p .
huang w .
j. bolosky a. singh and y .
zhou confvalley a systematic configuration validation framework for cloud services inproceedings of the tenth european conference on computer systems eurosys new y ork ny usa pp.
acm .
the puppet configuration management tool.
.
ansible for it automation.
online accessed august .
g. cormode m. garofalakis p .
j. haas and c. jermaine synopses for massive data samples histograms wavelets sketches found.
trends databases vol.
p. jan. .
p .
j. haas j. f. naughton s. seshadri and l. stokes samplingbased estimation of the number of distinct values of an attribute inproceedings of the 21th international conference on v ery large databases vldb san francisco ca usa p. morgankaufmann publishers inc. .
y .
ioannidis the history of histograms abridged in proceedings of the 29th international conference on v ery large data bases v olume29 vldb p. vldb endowment .
p .
karras and n. mamoulis the haar tree a refined synopsis data structure in ieee 23rd international conference on data engineering pp.
.
z. abedjan l. golab and f. naumann profiling relational data a survey the vldb journal vol.
p. aug. .
a. heise j. a. quian ruiz z. abedjan a. jentzsch and f. naumann scalable discovery of unique column combinations proc.
vldb endow.
vol.
p. dec. .
t. papenbrock j. ehrlich j. marten t. neubert j. p .
rudolph m. sch nberg j. zwiener and f. naumann functional dependencydiscovery an experimental evaluation of seven algorithms proc.
vldb endow.
vol.
p. june .
y .
zhang z. guo and t. rekatsinas a statistical perspective on discovering functional dependencies in noisy data in proceedings of the acm sigmod international conference on management ofdata sigmod new y ork ny usa p. associationfor computing machinery .
r. singh blinkfill semi supervised programming by example for syntactic string transformations proc.
vldb endow.
vol.
p. june .
m. raza and s. gulwani web data extraction using hybrid program synthesis a combination of top down and bottom up inference inproceedings of the international conference on management ofdata sigmod conference online conference june d. maier r. pottinger a. doan w .
tan a. alawini and h. q. ngo eds.
pp.
acm .
d. angluin learning regular sets from queries and counterexamples inf.
comput.
vol.
p. nov. .
r. parekh and v .
honavar an incremental interactive algorithm for regular grammar inference in international colloquium on grammatical inference pp.
springer .
r. parekh and v .
honavar learning dfa from simple examples machine learning vol.
no.
pp.
.
r. l. rivest and r. e. schapire inference of finite automata using homing sequences in proceedings of the twenty first annual acm symposium on theory of computing stoc new y ork ny usa p. association for computing machinery .
f. denis a. lemay and a. terlutte learning regular languages using non deterministic finite automata in icgi .
d. angluin s. eisenstat and d. fisman learning regular languages via alternating automata.
in ijcai pp.
.
s. drews and l. d antoni learning symbolic automata in tools and algorithms for the construction and analysis of systems 23rdinternational conference tacas held as part of the europeanjoint conferences on theory and practice of software etaps uppsala sweden april proceedings part i a. legay and t. margaria eds.
vol.
of lecture notes in computer science pp.
.
n. locascio k. narasimhan e. deleon n. kushman and r. barzilay neural generation of regular expressions from natural language withminimal domain knowledge .
z. zhong j. guo w. y ang j. peng t. xie j. g. lou t. liu and d. zhang semregex a semantics based approach for generatingregular expressions from natural language specifications in emnlp .
x. y e q. chen x. wang i. dillig and g. durrett sketch driven regular expression generation from natural language and examples trans.
assoc.
comput.
linguistics vol.
pp.
.
m. lee s. so and h. oh synthesizing regular expressions from examples for introductory automata assignments in proceedings of the acm sigplan international conference on generative program ming concepts and experiences gpce new y ork ny usa p. association for computing machinery .