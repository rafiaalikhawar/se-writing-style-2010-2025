intelligent change operators for multi objective refactoring chaima abid1 james ivers2 thiago do n. ferreira1 marouane kessentini1 fares e. kahla1and ipek ozkaya2 1university of michigan dearborn dearborn usa 2carnegie mellon university software engineering institute pittsburgh usa cabid thiagod marouane umich.edu jivers ozkaya sei.cmu.edu and benkahlafares gmail.com abstract in this paper we propose intelligent change operators and integrate them into an evolutionary multi objective search algorithm to recommend valid refactorings that addressconflicting quality objectives such as understandability andeffectiveness.
the proposed intelligent crossover and mutationoperators incorporate refactoring dependencies to avoid creatinginvalid refactorings or invalidating existing refactorings.
further the intelligent crossover operator is augmented to create offspringthat improve solution quality by exchanging blocks of validrefactorings that improve a solution s weakest objectives.
weused our intelligent change operators to generate refactoringrecommendations for four widely used open source projects.
theresults show that our intelligent change operators improve thediversity of solutions.
diversity is important in genetic algorithmsbecause crossing over a homogeneous population does not yieldnew solutions.
given the inherent nature of design trade offs insoftware giving developers choices that reflect these trade offs isimportant.
higher diversity makes better use of developers timethan lots of incredibly similar solutions.
our intelligent changeoperators also accelerate solution convergence to a feasiblesolution that optimizes the trade off between the conflictingquality objectives.
finally they reduce the number of invalidrefactorings by up to .
compared to existing search basedrefactoring approaches and increase the quality of the solutions.our approach outperformed the state of the art search basedrefactoring approaches and an existing deterministic refactoringtool based on manual validation by developers with an averagemanual correctness precision and recall of .
.
and .
.
index t erms refactoring dependencies intelligent change operators multi objective refactoring recommendation.
i. i ntroduction even for the most competent organizations building and maintaining high performing software applications with high quality is a challenging and expensive endeavor .
workingin fast paced environments that demand frequent releasesacross several products and deployment environments oftenforces developers to compromise high quality standards infavor of meeting deadlines .
as software systems continueto grow in size and complexity their maintenance continuesto become more challenging and costly .
to improvethe quality and maintainability of software systems developerstake advantage of refactoring as a means to improve thestructure of code without affecting its external behavior .
manual refactoring is generally a labor intensive ad hoc and potentially error prone process .
to improve this gap a wide range of work has focused on automating refactoringrecommendations using a variety of techniques that includetemplate rule based tools static and lexical anal ysis and search based software engineering .recent surveys show that search based software engineeringhas been increasingly used to find refactoring recommenda tions to address the trade offs among conflictingquality metrics and the large search space of potential refac toring strategies.
for instance o keeffe et al.
compareddifferent local search based algorithms such as hill climbingand simulated annealing to generate refactoring recommen dations that improve static quality metrics .
harman etal.
proposed using multi objective search for refactoringsthat improve coupling and reduce cohesion.
ouni et al.
and mkaouer et al.
proposed multi objective and many objective techniques to balance conflicting quality metricswhen finding refactoring recommendations.
hall et al.
and alizadeh et al.
improved the state of the art of search based refactoring by enabling interaction with developersand learning their preferences.
more detailed descriptions ofexisting search based refactoring studies can be found in thefollowing surveys .
despite the promising resultsof search based refactoring on both open source and industryprojects several limitations that reduce their effectivenessremain unaddressed.
while these limitations apply in general in most applications of search based reasoning approaches tosoftware engineering problems we focus onsearch based refactoring in this paper.
existing refactoring recommendation tools including those that use non search based approaches routinely generate so lutions that include invalid refactorings because they do notaccount for dependencies among refactorings.
manually apply ing a sequence of refactorings is common practice in existingtools however these tools treat each refactoringin the sequence in isolation.
for instance cinn ide et al.
investigated the impact only of individual refactorings onquality attribute metrics such as using move method to reducethe coupling of a class without studying the impact of asequence of refactorings.
figure shows an example of therefactoring recommendations generated by jdeodorant where similar to other refactoring recommendation tools thedependencies between the refactorings are not apparent thusleaving the challenging task of dealing with invalid refac torings to developers.
consequently developers often prefermanually applying refactorings to using such tools.
a keycontributor to this problem is that search based refactoring 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee approaches employ random change operators e.g.
crossover and mutation to evolve solutions without considering thedependencies among refactorings.
without detecting whichrefactoring dependencies exist the change operators used byalgorithms routinely invalidate solutions by breaking refactor ing dependencies or introducing refactorings whose dependen cies are not satisfied.
furthermore refactoring dependenciesprovide clues that could be exploited in more intelligentcrossover operations to improve decisions on which part s of solutions to exchange to produce higher quality offspring.
fig.
sample refactoring recommendations from jdeodorant.
in this paper we propose intelligent change operators and integrate them into a multi objective search algorithm based on nsga ii to recommend valid refactoringsthat address conflicting quality objectives such as reusability understandability and effectiveness.
the proposed intelligentcrossover and mutation operators use i the dependenciesdetected among refactorings to decompose a solution intoblocks of refactorings and ii the effects of these blocks onobjectives to identify good genes from parents to generatehigh quality offspring.
a refactoring dependency exists whenone refactoring cannot be successfully applied without firstapplying another.
partitioning refactorings into blocks suchthat no dependencies span blocks allows change operatorsto use blocks as the unit of change to avoid invalidatingrefactorings.
our tool calculates the effect of each block withina solution on the objectives and uses this data to select whichblocks to exchange between solutions to improve the firstsolution s weaknesses e.g.
the objective with smallest values .
we applied our intelligent change operators to generate refactoring recommendations for four widely used open sourceprojects and compared this approach to five existing refac toring techniques in terms of the diversity of the solutions number of invalid refactorings and the quality of generatedsolutions.
we also conducted a survey with developersto evaluate the correctness and relevance of the refactoringsgenerated by the different algorithms for these projects.
the results show that our technique performed significantly better than the four existing search based refactoringapproaches and an existing refactoringtool not based on heuristic search jdeodorant with anaverage manual correctness precision and recall of .
.
and .
respectively.
we used these five refactoring toolsand open source projects because i they are representativeof automated multi objective search based refactoring recom mendation techniques ii they are publicly available includingthe non search based tool and iii the familiarity of theparticipants with these open source systems.
replication package.
all material and data used in our study are available in our replication package .
ii.
d ependency awa r e refactoring recommenda tion system a. background multi objective refactoring using nsga ii multi objective optimization has been widely applied to refactoring problems to find trade offs when searching for so lutions.
non dominated sorting genetic algorithm ii nsga ii algorithm is the dominant multi objective opti mization algorithm that has been used in search based softwareengineering including for search based refactoring .
nsga ii is designed to find a set of non dominated solutions a pareto front in which each solution isa sequence of refactorings that provides a compromise amongconflicting objectives e.g.
quality metrics .
algorithm nsga ii algorithm.
input system to evaluate and list of refactoring types output non dominated refactoring solutions 1generate a random population pand evaluate the objectives 2while the stopping condition is not reached do select individuals m from pusing binary tournament selection apply crossover operation on m to generate the offspring population o apply mutation operation on o update pby combining the parent and offspring populations 7end 8return p initially a starting population pis created using a random procedure.
these solutions then undergo crossover and muta tion producing offspring o and the process is repeated until the stopping condition is reached in our case a maximumnumber of generations .
the objective values of the solutionsare computed and change operators are applied to create thenext generation.
in most of existing adaptations including thispaper the algorithm finds non dominated solutions balancingseveral conflicting objectives such as the six qmood qualitymetrics .
the different objectives can be normalized if theyhave different scales.
each objective can be written as follow objective i qafter i qbeforei qbeforei whereqbefore i andqafteriare the values of the quality metrics ibefore and after applying a solution or sequence of refactorings respectively.
the search space explored by nsga ii consists of different refactoring operations applied to different code locations where each operation is represented by a refactoring type e.g.
move method and its parameters e.g.
source class targetclass attributes .
in this paper we selected refactoringtypes that are frequently used in practice based on existingstudies encapsulate field decrease fieldsecurity decrease method security increase field security 769increase method security pull up field pull up method push down field push down method extract sub class extract super class extract class move field and movemethod.
a vector in which each element represents a refactor ing operation is used to represent a solution.
each refactoringoperation must satisfy a set of pre and post conditions definedby opdyke to maintain the behavior of the system.
the most common change operators used in search based refactoring approaches are the random crossover and muta tion operators.
in these operators refactorings are selectedrandomly from solutions for exchange or replacement withothers which can generate invalid refactorings or invalidateother refactorings e.g.
by removing a refactoring another onedepends on .
we developed three components to improve thechange operators used in the nsga ii algorithm i a refactor ing dependency detection algorithm ii an intelligent crossoverthat factors in dependency correctness and the implicationsof collections of refactorings on fitness functions and iii adependency aware mutation.
finally we note that the proposedapproach as described later can be integrated for both nsga ii and nsga iii as they are using the same change operators.the difference between them is that nsga iii uses a set ofreference directions identified via a nitching function whilensga ii uses a more adaptive scheme through its crowdingdistance operator for the same purpose.
this difference doesnot affect our goal of comparing the impact of our intelligentchange operators on the final pareto front.
b. refactoring dependency theory our dependency aware refactoring recommendation technique relies on an ordering dependency between pairs of refactorings.
specifically an ordering dependency rf mapsto rf1 between two refactorings rf 1andrf2 exists when rf2 can only be successfully applied after rf1has been applied.
that is rf1makes a change to code that is necessary in order to apply rf2.
this condition can be evaluated based on the combination of pre and post conditions of the types ofrefactorings involved and the parameters of each refactoring.for example to apply move method a type of refactoring to move method m 1from class c1to classc2 m1 c1 andc2 being the parameters of the refactoring several pre conditionsmust hold e.g.
m c1 andc2must all exist and m1must be defined on c1 .
the pre and post conditions of each type of refactoring are described in our online appendix andwere extensively validated for correctness and completenessin current literature .
figure shows a simplified example of a refactoring solution that is composed of refactoring operations that dependon each other.
three of the refactorings dependon another refactoring because the extract super classrefactoring creates a new class client on which refac torings and operate.
if the new class is not createdfirst then refactorings and will fail.
thus thereexists an ordering dependency from each of to .
refactoring solutions have traditionally been represented as a sequence likely originating with the common vector .
.
!
.
.. !
!
fig.
a simplified example of refactorings that depend oneach other.
representation used in many genetic algorithms.
in some cases a solution could be appropriately represented as a set ofsequences but only if the refactoring graphs are simplistic enough.
a refactoring graph is a weakly connected directed acyclic graph composed of refactoring vertices and orderingdependency edges.
in practice there are many examples wherea sequence vs. graph representation is misleading.
for exam ple if two refactorings rf2 and rf3 both depend on a commonrefactoring rf1 we have a graph for which a sequencerepresentation would be misleading.
rf1 must precede rf2 andrf3 but there is no dependency between rf2 and rf3.
rf1 rf2 rf3 would be as acceptable as rf1 rf3 rf2 .
a sequencerepresentation indicates an ordering and the choice of a graphover a sequence allows us to unambiguously indicate only real dependencies.
as for the initial refactoring sequence itis true that the order in that sequence does shape the originalgraphs.
however the initial sequence is generated randomlyfor each solution in the population much as if random graphswere generated.
using the ordering dependencies as the basis for forming refactoring graphs algorithm results in a set of graphs withthe following traits each refactoring in a solution is an element of exactlyone refactoring graph.
some graphs contain a single refactoring because thatrefactoring is independent of all others.
we call thesetrivial graphs.
the remaining graphs contain multiple refactorings eachof which is part of one or more dependencies.
we callthese non trivial graphs.
each refactoring graph is independent of every othergraph in the solution.
the dependencies as described in algorithm are detected based on comparisons between pre and post conditions ofrefactorings.
the algorithm takes a list of refactorings as inputand generates a set of refactoring graphs as output.
line initializes the lists of refactorings nodes v and refactoring dependencies edges e .
then the postconditions of each refactoring of the solution c collection of refactorings are evaluated for matching with the remainingrefactorings in c lines .
specifically the algorithm looks for any match between predicates of pre and post conditions.
that is if any predicate of the post condition ofone refactoring any element of p matches any predicate of 770algorithm dependency detection algorithm.
input refactoring solution c r1 r2 r3 ... r n output set of refactoring graphs f f1 f2 f3 ... f m 1v e 2foreach ri cdo v v ri p post conditions r i foreach rj c j i do q pre conditions r j m p q if m negationslash 0then e e rj ri end end 12end 13g v e 14f partition g 15return f the pre condition of another refactoring any element of q then a dependency has been detected and an edge is added to the graph between those refactorings lines .
we repeatthis process until all the refactorings have been visited.
c. proposed intelligent change operators dependency aware crossover we developed a baseline dependency aware crossover that only preserves the dependencies among refactorings e.g.
without fixing the weaknesses ofrefactoring solutions .
this version as shown in algorithm reduces the occurrence of invalid refactorings in solutionsbecause it preserves refactoring dependencies.
algorithm dependency aware crossover algorithm.
input population s s1 s2 s3 ... s n and a probability p output offspring population s prime s prime s prime s prime ... s prime n 1s prime 2fori 1to s 2do sa sb select random solutions from s ifrandom number pthen ba group refactorings of sainto blocks bb group refactorings of sbinto blocks s prime a s prime b apply single point crossover on b a bb s prime s prime uniontext s prime a s prime b else s prime s prime uniontext sa sb end 12end 13return s prime we start by randomly selecting two solutions saandsb as parents for new offspring line .
then we group therefactorings of s aandsbinto blocks lines based on the dependencies detected by algorithm .
each blockcontains a single trivial or non trivial graph.
we then performa single point crossover line that exchanges blocks ofrefactorings rather than individual refactorings which avoidsinvalidating refactorings because all dependencies are isolatedwithin blocks.
this results in two offspring each with geneticinformation from both parents.
intelligent crossover our intelligent crossover operator is an improvement over random crossover in two ways it usesrefactoring dependencies to reduce the occurrence of invalidrefactorings and it chooses blocks of refactorings for exchangethat will improve a solution s weaknesses producing higherquality offspring.
the pseudo code of our proposed intelligentcrossover operator is presented in algorithm .
algorithm intelligent crossover algorithm.
input population s s1 s2 s3 ... s n and a probability p output offspring population s prime s prime s prime s prime ... s prime n 1s prime 2fori 1to s 2do sa sb select random solutions from s ifrandom number pthen sbest higher quality solution of saandsb sworst lower quality solution of saandsb bbest group refactorings of sbest into blocks bworst group refactorings of sworst into blocks wbest get all weaknesses of sbest ifwbest then wbest get the objective that improves the least with sbest end i sort the blocks of bworst based on potential improvement to sbest i prime select the blocks from ithat improve sbest n select random number between 0and i prime s prime best s prime worst apply single point crossover exchanging nblocks between bbest andi s prime s prime uniontext s prime best s prime worst else s prime s prime uniontext sa sb end 21end 22return s prime in essence the intelligent crossover operator mixes the best genes of the weaker solution with random genes of the bettersolution figure .
first we randomly select two solutions s aandsb line .
we then determine the better solution by computing how much each solution improves the objectives using a weighted sum of the project to be refactored lines5 .
as before we group refactorings of both solutions intoblocks lines to preserve refactoring dependencies duringcrossover.
we then determine which objectives are consideredthe weaknesses of the better solution s best lines part a in figure .
any objectives that are worse after applyingthe better solution are considered weaknesses e.g.
objective 2in figure part a .
if no objectives are worse after applying thebetter solution we select the objective that improves the leastafter applying the solution as the sole weakness.
then we sortthe blocks of the weaker solution b worst based on how each would impact the objectives using a weighted sum of thebetter solution s best line part b in figure .
in part c of algorithm we pick a random number between and thenumber of blocks in the weaker solution that would improvethe better solution line to determine the number of blocksfor crossover.
finally we create two offspring using singlepoint crossover line that moves the nblocks from the weaker solution with the best impact on the stronger solution s 771objectives to the stronger solution and nrandom blocks from the stronger solution to the weaker solution.
dependency aware mutation our proposed dependency aware mutation operator is defined in algorithm and illustrated in figure .
we modifiedthe random mutation operator to preserve refactoringdependencies.
for each solution s we randomly select a floating point value.
if this value is less than the mutationprobability line we detect refactoring dependencies parta in figure and identify mutable refactorings line partb in figure .
a mutable refactoring must satisfy at leastone of the following it does not participate in any dependencies e.g.
eand cin figure .
it is part of a non trivial graph but no other refactoringsdepend on it e.g.
g iandhin figure .
it is part of a non trivial graph but it has an unsatisfiedpre condition and is already invalid e.g.
ain figure .
then we chose a random number between and the number of mutable refactorings line .
this number represents thenumber of refactorings that we will mutate in refactoringsolution s. finally we replace n refactorings in swith random refactoring operations and parameters line partc in figure .
algorithm dependency aware mutation algorithm.
input solution s r1 r2 r3 ... r n and a probability p output mutated solution s 1ifrandom number pthen m detect mutable refactorings from s n random number between and m fori 0tonby1do rj random refactoring from m replace rjinswith a random refactoring end 8end 9return s iii.
e mpirical study a. research questions the following research questions guide the evaluation of our proposed approach rq1.
correctness.
to what extent can our approach reduce the number of invalid refactorings compared toother multi objective refactoring recommendation tech niques?
rq2.
quality.
to what extent can our approach generate refactoring solutions with better diversity convergence and quality improvement compared to other multi objective refactoring techniques?
rq3.
relevance.
how do developers evaluate the impact of our approach in practice?
to answer item rq1 we chose the algorithm proposed by mkaouer et al.
based on nsga iii because it outper forms the existing multi objective techniques that use random change operators.
please note that nsga ii and nsga iii are using the same change operators asexplained in the previous section.
we also considered twooperation variants of nsga ii that optimize the same qualityobjectives as summarized in table i. table i the three operation variants of the nsga ii algorithm.
algorithm definition nsga iinsga ii with random single point crossover and bit flip mutation mkaouer et al.
dep nsga iinsga ii with dependency aware change operators sections ii c1 and ii c3 intel nsga iinsga ii with intelligent crossover and dependency aware mutation sections ii c2 and ii c3 we selected four open source java projects show in table ii that were used in the work of mkaouer et al.
.
these projects are from different domains and have differentsizes along with a significant number of contributors over morethan years.
furthermore the selected projects are widelyused and extensively involved over time which may justify theneed for refactoring.
also we checked the validity of pre and post conditions of all refactorings in all solutions in each generation for allthree algorithms on the four projects.
we measured the totalnumber of conflicts for each generation as the percentage ofinvalid refactorings among all refactorings in all solutions inthat generation.
we also measured the percentage of invalidrefactorings per solution in each generation to see the distri bution of invalid refactorings across solutions.
table ii open source projects studied.
system release of classes kloc argouml v0.
jhotdraw v7.
.
ganttproject v1.
.
apache ant v1.
.
to answer item rq2 we compared the three algorithms in terms of execution time performance indicators and im provement in quality metrics of the pareto front solutions.due to the stochastic and non deterministic nature of meta heuristic algorithms different runs of the same algorithmsolving the same problem typically give different outcomes.for this reason we performed runs for each algorithmon each project to make sure that the results are statisticallysignificant.
finally to answer item rq3 we conducted a survey with a group of active developers to identify and manuallyevaluate the relevance of the refactorings generated by ourapproach.
at the top of the criteria mentioned above theprojects used for answering item rq1 were selected since the participants are familiar with them so they can providerelevant feedback given their knowledge.
b. evaluation metrics we validate our results using the following metrics.
.
!
.
.. .
.. .
!
.
.
!
.
.
.. .
.
.
.
.. .
!
.
!
.
.
!
.
.
.
.
.
.
.
!
.
.. !
.
.. .
2 .
!
.
!
.
.
fig.
an illustration of the intelligent crossover.
!
.
!
.
!
.
!
.
qydolg uhidfwrulqj .
!
.
.
.
!
.
hshqgv rq 0xwdeoh uhidfwrulqjv 0xwdeoh uhidfwrulqjv fig.
an illustration of the dependency aware mutation.
for item rq1 we want to estimate the correctness of the solutions generated by the three algorithms.
for that we compute the percentage of invalid refactorings in each gen eration by inspecting the validity of pre and post conditionsof each refactoring operation.
these conditions are discussedby opdyke et al.
.
the exhaustive list can be found inthe online appendix .
we also computed the percentage ofinvalid refactorings per refactoring solution generated by thethree algorithms at each generation.
for item rq2 we use the following three metrics as performance indicators to evaluate the quality of solutionsgenerated by the three algorithms contributions ic measures the proportion of solutions that lie on the reference front rs .
the higherthis proportion the better the quality of solutions.
inverted generational distance igd is a convergence measure that corresponds to the average euclideandistance between the approximate pareto front providedby an algorithm and the reference pareto front.
smallvalues are desirable.
hypervolume ihv measures the volume covered by members of a pareto front in objective space delimitedby a reference point.
an important feature of this metricis its ability to capture diversity and convergence ofsolutions.
a higher hypervolume value is desirable.we also calculated another metric based on qmood that estimates the quality improvement for the project by compar ing the quality before and after refactorings generated by thethree algorithms.
for each refactoring solution s the quality improvement after applying sis estimated as qs summationdisplay i 1qqiwhere q qi q prime i qi whereqiandq prime irepresent the value of qmood quality attribute ibefore and after applying s respectively.
for each algorithm we average the normalized quality improve ments across solutions in the pareto front generated by eachalgorithm and we compare them.
in addition we compute theexecution time of each generation using the three algorithms.
finally for item rq3 we validated the generated refactoring solutions quantitatively and qualitatively.
for qualitativeassessment we compared our solutions to a baseline of solu tions generated by other multi objective techniques and by jdeodorant a tool not based on heuristicsearch.
all the search based refactoring techniques are basedon multi objective search but each uses different objectivesand solution representations.
all use the same random changeoperators which helps to confirm whether good recommenda tions result from using our intelligent change operators.
the 773current eclipse plug in version of jdeodorant identifies some types of design defects using quality metrics and proposesa list of refactorings to fix them.
for the comparison withjdeodorant we limited the comparison to the same refactor ing types supported by both our approach and jdeodorant.for the quantitative assessment we calculated precision andrecall scores by comparing the refactorings recommended byeach of the multi objective algorithms and jdeodorant withthose refactoring manually suggested by the participants theexpected refactorings .
p recision recommended refactorings expected refactorings recommended refactorings recall recommended refactorings expected refactorings expected refactorings after the developers manually suggested refactorings for the projects we asked them to evaluate the tools recommenda tions since their suggestions may not be the only reasonablesolution.
we asked the participants to assign or toevery refactoring solutions generated by the multi objectivealgorithms and jdeodorant.
a means that the refactoringis not relevant or invalid and means that the refactoring ismeaningful and relevant.
we computed manual correctness as the number of meaningful refactorings divided by the total number of recom mended refactorings.
meaningful refactorings were identifiedby considering the majority opinion across participants foreach refactoring.
manual correctness meaningful refactorings recommended refactorings c. parameters tuning in order to fairly compare the results among the three algorithms in table i and the multi objective algorithms usedin our survey we performed the samenumber of evaluations per run 3k and used the same initialpopulation size .
we used the maximum number ofevaluations as our stopping criterion.
the crossover and mu tation probabilities are set to .
and .
respectively.
theminimum and maximum number of refactorings per solutionsare set to and respectively.
d. subjects we evaluated our approach with active industry developers who volunteered to participate in our survey as part of an industry sponsored research collaboration.
we selectedindividuals with extensive experience applying refactorings inindustry and using the selected open source projects in theirwork.
each filled out a pre study survey that collects back ground information such as their programming experience andtheir role within their companies.
we divided the participants into four groups balancing skill level and familiarity with the open source projects.
thedetails of the participants and the projects they evaluated arefound in table iii.
we gave participants a two hour lectureabout software quality assessment and refactoring.
duringthe two hour lecture we did not reveal to the participantswhich refactorings were generated by which app to avoidany possible bias.
we provided general knowledge regardingrefactoring and showed them how to read and interpret therefactoring solutions and focused on explaining the requiredsteps to complete the survey.
we assessed their knowledge on the open source projects and their performance in evaluating and suggesting refactoringsolutions.
the participants were asked to assess the correctnessand relevance of the refactorings recommended by the multi objective algorithms and jdeodorant on all four projects.
they were shown refactoring recommen dations per project without knowing where the recommenda tions came from.
since the multi objective algorithms generate many refactoring solutions in the pareto front it was not feasible toask the participants to evaluate all the solutions.
therefore to perform meaningful and fair comparisons for each projectand algorithm we selected the solution using a knee pointstrategy .
the knee point corresponds to the solution withthe maximal trade off among the objectives which could beseen as the mono objective solution with equally weightedobjectives if the objectives do not conflict.
thus we selectedthe solution with the median hypervolume ihv value.
theaverage number of refactorings evaluated by each participantis .
we ensured that each refactoring was evaluated by twodevelopers and we considered it relevant if both agreed theoverall cohen s kappa was .
.
table iii participant details.
system o f subjectsavg.
prog.
experience y ears refactoring experience argouml high jhotdraw .
v ery high ganttproject .
high apache ant v ery high e. results rq1 correctness figure shows the percentage of invalid refactorings across all solutions in each generation foreach algorithm for each open source project.
all algorithmshave non dominated solutions in the final pareto front.
the highest percentages of invalid refactorings for all projects was produced by nsga ii though it does reducethe percentage of invalid refactorings by a negligible amountas generations progress.
dep nsga ii reduces the percentageof invalid refactorings compared to regular nsga ii by44.
.
.
and .
for ant argouml gantt and jhotdraw respectively.
intel nsga ii however outperformed the other algorithms and reduces the percentageof invalid refactorings compared to nsga ii by .
.
.
and .
for ant argouml gantt and jhotdraw respectively.
intel nsga ii also reduces the .
.
.
.
.
.
of invalid refactorings generationsnsga ii dep nsga ii intel nsga ii a argouml.
.
.
.
.
.
.
of invalid refactorings generationsnsga ii dep nsga ii intel nsga ii b ant.
.
.
.
.
.
.
of invalid refactorings generationsnsga ii dep nsga ii intel nsga ii c gantt.
.
.
.
.
.
.
of invalid refactorings generationsnsga ii dep nsga ii intel nsga ii d jhotdraw.
fig.
percentage of invalid refactorings across all solutions per generation for nsga ii dep nsga ii and intel nsga ii.
.
.
.
.
of invalid refactorings in refactoring solutions generationsnsga ii dep nsga ii intel nsga ii a argouml .
.
.
.
of invalid refactorings in refactoring solutions generationsnsga ii dep nsga ii intel nsga ii b ant .
.
.
.
of invalid refactorings in refactoring solutions generationsnsga ii dep nsga ii intel nsga ii c gantt .
.
.
.
of invalid refactorings in refactoring solutions generationsnsga ii dep nsga ii intel nsga ii d jhotdraw fig.
percentage of invalid refactorings in refactoring solutions using nsga ii dep nsga ii and intel nsga ii.
percentage of invalid refactorings more quickly than the other algorithms at the population level.
also figure reveals that nsga ii generates a roughly constant percentage of invalid refactorings equal to or greaterthan .
by introducing the dependency aware change op erators dep nsga ii reduced the number of invalid refac torings to roughly in the 30th generation.
figure alsoreveals a major decrease in the number of invalid refactorings 775caused by intel nsga ii in the first generations then it becomes roughly constant and equal to less than .
thus the number of generations to reach a stable fraction of invalidrefactorings is almost the same per algorithm independentlyfrom the evaluated project.
finally we examined the impact of our proposed change operators at the solution level.
figure shows the distributionof the percentage of invalid refactorings within solutions.
intel nsga ii achieves the lowest percentage of invalid refactoringsin solutions across all generations for all projects followed bydep nsga ii and nsga ii respectively.
1key findings intel nsga ii reduces the percentage of invalid refactorings in the population and refactoringsolutions by an average of .
and .
comparedto nsga ii and dep nsga ii respectively.
table iv performance indicators results for nsga ii dep nsga ii and intel nsga ii.
system algorithm ic igd ihv argoumlnsga ii .
.
.
.
.
dep nsga ii .
.
.
.
.
intel nsga ii .
.
.
.
.
antnsga ii .
.
.
.
.
dep nsga ii .
.
.
.
.
intel nsga ii .
.
.
.
.
ganttprojectnsga ii .
.
.
.
.
dep nsga ii .
.
.
.
.
intel nsga ii .
.
.
.
.
jhotdrawnsga ii .
.
.
.
.
dep nsga ii .
.
.
.
.
intel nsga ii .
.
.
.
.
rq2 quality table iv shows the average ic igd and ihv of the runs of the three algorithms.
the values in bold are the best values achieved for each performance indicator perproject.
intel nsga ii achieved the highest i hv andicand the lowest igd for all projects.
dep nsga ii was able to improve the ihv ic igd compared to nsga ii by up to .
.
and .
respectively.
intel nsga iiwas able to improve the i hv ic igd compared to nsgaii by up to .
.
and .
respectively.this shows that intel nsga ii produces better convergence and diversity than the other algorithms.
table v shows the average quality improvement of solutions as well as their standard deviations.
the bold values arethe best values obtained for each metric for each project.
intelnsga ii produced the best quality improvement in almost all cases.
nsga ii produced the lowest quality improvement in out of cases.
dep nsga ii was able to improve the effectiveness extendibility flexibility functionality reusability and understandability compared to nsga ii by an average of .
.
.
.
.
.
respectively.intel nsga ii was able to improve the effectiveness extendibility flexibility functionality reusability and under standability compared to nsga ii by an average of .
.
.
.
.
and .
respectively.this demonstrates that our intelligent crossover strategy thattargets fixing a solution s weaknesses leads to higher qualitysolutions in the final pareto front.
there is however a per formance penalty for the extra work performed by intelligentchange operators on average execution time doubled.
in mostcases this is a more than acceptable trade off for higher qualityrefactoring recommendations.
we noticed that nsga ii never produced the best quality improvement in any cases which means that the dependency aware change operators play a significant role in improvingthe quality of the pareto front.
in addition whenever intel nsga ii does not produce the best quality improvement the difference between the quality values of intel nsga ii anddep nsga ii is very small.
indeed the quality improvementsrate depends on the number of code smells size and evolutionof the analyzed projects.
in our future work we are planningto validate our approach using more projects to have a clearerunderstanding of when and why intel nsga ii does notproduce the best quality improvement .
1 key findings intel nsga ii outperforms the other algorithms in terms of diversity convergence and qualityimprovement of the pareto front using the different evalu ation metrics i c igd andihv by at least with a modest sacrifice in execution time.
rq3 relevance figure presents the results of manual correctness precision and recall for our intel nsga iialgorithm and state of the art refactoring techniques.
thedetailed responses of the participants can be found in ourappendix .
intel nsga ii achieved better manual evaluationscores than and existing approaches in all the metrics forall projects.
indeed the average manual correctness precisionand recall of our algorithm compared to that of mkaoueret al.
are .
.
and .
to .
.
and .67respectively and much better than the remaining tools.
thus the participants found our refactoring recommendations appli cable and consistent with the source code and their designissues.
all participants agreed on the benefits of consideringdependencies among refactorings when generating refactoringsolutions.
they mentioned that intel nsga ii increases theirtrust in refactoring tools and would save them time and efforton filtering out invalid refactorings.
1key findings intel nsga ii provided more relevant and meaningful refactorings than state of the art refactoringrecommendation techniques based on manual evaluation ofrecommended refactorings.
iv .
t hrea ts to validity conclusion validity.
we used design of experiments doe to mitigate the threat related to parameter tuning.doe is a methodology for systematically applying statisticsto experimentation and is one of the most efficient techniquesfor tuning parameter settings of evolutionary algorithms.
eachparameter has been uniformly discretized in intervals.
tomitigate the stochastic nature of the search algorithms we 776table v average quality improvement of the solutions generated by nsga ii dep nsga ii and intel nsga ii.
system algorithm effectiveness extendibility flexibility functionality reusability understandability argoumlnsga ii .
.
.
.
.
.
.
.
.
.
.
.
dep nsga ii .
.
.
.
.
.
.
.
.
.
.
.
intel nsga ii .
.
.
.
.
.
.
.
.
.
.
.
apache antnsga ii .
.
.
.
.
.
.
.
.
.
.
.
dep nsga ii .
.
.
.
.
.
.
.
.
.
.
.
intel nsga ii .
.
.
.
.
.
.
.
.
.
.
.
ganttprojectnsga ii .
.
.
.
.
.
.
.
.
.
.
.
dep nsga ii .
.
.
.
.
.
.
.
.
.
.
.
intel nsga ii .
.
.
.
.
.
.
.
.
.
.
.
jhotdrawnsga ii .
.
.
.
.
.
.
.
.
.
.
.
dep nsga ii .
.
.
.
.
.
.
.
.
.
.
.
intel nsga ii .
.
.
.
.
.
.
.
.
.
.
.
mc intel nsga ii mc mkaouer et al.
mc harman et al.
mc ouni et al.
mc mel et al.
mc jdeodorant pr intel nsga ii pr mkaouer et al.
pr harman et al.
pr ouni et al.
pr mel et al.
pr jdeodorant rc intel nsga ii rc mkaouer et al.
rc harman et al.
rc ouni et al.
rc mel et al.
rc jdeodorant .
.
.
.
.
.
.
.
.
.
.
2argouml jhotdraw ganttproject apache ant fig.
manual evaluation of refactoring recommendations generated by the existing multi objective techniques and the jdeodorant eclipse plugin .
performed runs per project and algorithm and analyzed the mean results along with the appropriate statistical tests usingthe wilcoxon test with a confidence level .
internal validity.
v alidation exercise participants had different programming skills and familiarity with refactoringtools.
to counter this we assigned developers to groupsaccording to their experience to reduce the gap between thegroups and we adopted a counter balanced design.
asking theparticipants to evaluate the refactoring recommendations forall projects would be too much work for them and wouldreduce the quality of the survey responses.
for this reason wedivided the participants into four groups balancing skill leveland familiarity with the open source projects and we askedeach one of them to evaluate a single project.
we groupedthe participants based on their familiarity with the projectsto be evaluated.
indeed it is critical that the participants areknowledgeable about the code of the evaluated projects sothey can make accurate judgment about the recommendedrefactorings.
also the relatively small number of participantscould also be considered a threat to validity.
we selected 14developers to participate in our validation targeting developerswith knowledge of the studied projects.
in depth interviewswith a relatively small number of developers familiar withthe studied projects yields deep quality insights that are moreuseful than those extracted using an online survey with randomparticipants who are not familiar with the studied projects.
construct validity.
developers might have different opinions about the relevance of recommended refactorings whichmay impact our results.
some might think that it is importantto refactor while others might think otherwise.
to mitigatethis threat we ensured that each refactoring was evaluated bytwo developers and we considered it relevant if both agreed.the overall cohen s kappa was .
which confirms that thereis a significant consensus among developers.
external threats.
external threats concern the generalization of our findings.
our validation includes only four projects.one reason for this is to attract more quality responses fromsurvey participants.
the more tedious the task that participantsmust complete the lower the quality of their responses.
thesecond reason is that running all of the algorithms on all ofthe projects times takes considerable time.
v. r ela ted work a. search based software refactoring many studies have used search based techniques to automate software refactoring by optimizing different sets ofquality metrics .
kessentini etal.
proposed a single objective combinatorial optimiza tion using a genetic algorithm to find the best sequence ofrefactoring operations that improve the quality of the code byminimizing as much as possible the number of design defectsin the source code.
harman and tratt were the first touse the concept of pareto optimality in search based softwarerefactoring to address conflicting quality objectives such ascoupling and cohesion.
they showed that their multi objectivetechnique generates better results than a mono objective ap proach.
cinn ide et al.
also proposed multi objectivesearch based refactoring to conduct an empirical investigationto explore relationships between several structural metrics.
777they used different search techniques such as pareto optimal search and semi random search guided by a set of cohesionmetrics.
ouni et al.
presented a multi objective refactoringapproach to minimize the number of detected defects andmaximize the semantic similarity of code elements.
all the above studies used traditional random change operators e.g.
point crossover random mutation etc.
thatcan destroy relevant patterns inside good refactoring solutionswhen applied randomly as illustrated in the validation section.
b. refactoring dependencies chavez et al.
investigated how refactoring types affect five quality attributes based on the version history of open source projects.
they found that of refactorings areapplied to code with at least one low quality attribute value with of refactorings improving attributes and of allrefactorings being neutral on the system.
similarly cinn ide etal.
studied the impact of individual refactorings on qualityattributes such as using move method to reduce the couplingof a class.
none of these studies considered the impact of asequence of refactorings on quality attributes.
bibiano et al.
analyzed batch refactoring characteristics and their effects on code smells in open and closed sourceprojects and concluded that of batches patterns are simplecompositions of only two types of refactorings.
they high light lack of tool support to automatically detect refactoringdependencies as a barrier.
however this study is based onthe assumption that refactorings are only related if applied tothe same code location which often is not the case for typesof refactorings that modify multiple code fragments.
menset al.
analyzed dependencies at the model level workingwith uml.
our work is at the code level working directly withtransformations on the code rather than on uml models wherethe type of refactorings are different and simplified whencompared to the code level refactorings.
overall existing stud ies mainly define what might be better considered similarityrelations such as a collection of refactorings that have similareffects fixing a code smell or similar context applied bythe same developer or to the same code location .none of the existing studies rigorously define refactoringdependencies to integrate them into recommendation tools including search based refactoring.
c. genetic operators in search based software engineering search based software engineering studies proposed few studies on improving the change operators in order to optimize the performance and convergence of search algorithms as wellas the quality of generated solutions.
however none of themaddressed the refactoring problem or designed new changeoperators to deal with the issues of solution correctness orthe impact of random change operators on solution quality.oliveira et al.
propose a reformulation of program repairoperators such that they explicitly traverse three subspaces thatunderlie the search problem i.e.
operator fault space andfix space .
they implemented new crossover operators thatrespect the subspace division.zhu et al.
propose two mechanisms to avoid premature convergence of genetic algorithms i dynamic application ofcrossover and mutation operators and ii population partialre initialization.
they implemented two crossover and twomutation operators and dynamically choose one crossover andone mutation operators to apply in each generation based ona selection probability that is dependent on average progress.abido et al.
propose improved crossover and mutationalgorithms to directly devise feasible offspring chromosomes.
vi.
c onclusion to improve the correctness and quality of refactoring recommendations and increase developer trust in search basedrefactoring recommendation tools we proposed a dependency aware multi objective refactoring approach with intelligentchange operators that find a balance among quality objec tives while reducing the number of invalid refactorings.
weevaluated this approach on four open source projects.
wecompared our results to existing refactoring techniques that userandom change operators as well as to a dependency awaretechnique to understand the impact of considering refactoringdependencies and fixing quality weaknesses in refactoringsolutions.
the comparisons show that our proposed approachperforms significantly better than the baselines in terms ofconvergence diversity and correctness with a reasonable costin terms of increased execution time.
the survey with 14practitioners confirmed the relevance of our approach.
for future work we plan to validate this study with additional programming languages developers and projects togeneralize our results.
we also plan to implement an intel ligent mutation operator that targets fixing quality objectivesin refactoring solutions.
also we intend to investigate howmany refactoring operations actually depend on each other andhow many operations can be executed independently.
anotherresearch direction could be to explore further techniques toimplement the change operators and compare them with eachother.
in fact there are multiple ways of how we choose therefactorings that participate in the mutation and the crossoverprocesses as well as how we perform the change opera tors.
there is a practical balance to study between smartermutations more expensive but more reliable vs. simpler more error prone mutations faster but not guaranteed .
thisoperation shows benefits from introducing modest constraintsin the selection of mutable refactorings.
there are certainlyother variants that explore different trade offs between speedand error reduction and that is just for mutating a singlerefactoring at a time.
a cknowledgements this material is based upon work funded and supported by the department of defense under contract no.
fa8702 d with carnegie mellon university for the operation ofthe software engineering institute a federally funded researchand development center.
dm21 778references m. a. abido and a. elazouni.
improved crossover and mutation operators for genetic algorithm project scheduling.
in ieee congress on evolutionary computation pages .
ieee .
w. afzal r. torkar and r. feldt.
a systematic review of search based testing for non functional system properties.
information and software technology .
v .
alizadeh and m. kessentini.
reducing interactive refactoring effort via clustering based multi objective search.
in proceedings of the 33rd acm ieee international conference on automated software engineering pages .
v .
alizadeh m. kessentini w. mkaouer m. ocinneide a. ouni and y .
cai.
an interactive and dynamic search based approach tosoftware refactoring recommendations.
ieee transactions on software engineering .
anonymous authors s .
study appendix .
view asedependency.
j. bansiya and c. g. davis.
a hierarchical model for object oriented design quality assessment.
ieee transactions on software engineering .
g. bavota a. d. lucia a. marcus and r. oliveto.
recommending refactoring operations in large software systems.
in recommendation systems in software engineering pages .
springer berlin hei delberg berlin heidelberg .
g. bavota a. d. lucia m. d. penta r. oliveto and f. palomba.
an experimental investigation on the innate relationship between quality andrefactoring.
journal of systems and software .
a. c. bibiano e. fernandes d. oliveira a. garcia m. kalinowski b. fonseca r. oliveira a. oliveira and d. cedrim.
a quantitativestudy on characteristics and effect of batch refactoring on code smells.inproceedings of 13th the acm ieee international symposium on empirical software engineering and measurement esem pages1 porto de galinhas brazil .
ieee.
a. ch vez i. ferreira e. fernandes d. cedrim and a. garcia.
how does refactoring affect internal quality attributes?
a multi projectstudy.
in proceedings of the 31st brazilian symposium on software engineering sbes pages fortaleza brazil .
acm.
s. das w. g. lutters and c. b. seaman.
understanding documentation value in software maintenance.
in proceedings of the symposium on computer human interaction for the management of informationtechnology pages es .
m. c. de oliveira d. freitas r. bonif cio g. pinto and d. lo.
finding needles in a haystack leveraging co change dependencies torecommend refactorings.
journal of systems and software .
k. deb a. pratap s. agarwal and t. meyarivan.
a fast and elitist multiobjective genetic algorithm nsga ii.
ieee transactions on evolutionary computation .
f. ferrucci m. harman j. ren and f. sarro.
not going to take this anymore multi objective overtime planning for software engineeringprojects.
in 35th international conference on software engineering icse pages .
ieee .
m. fowler.
refactoring improving the design of existing code.
addison wesley longman publishing co. inc. boston ma usa .
m. fowler.
refactoring improving the design of existing programs.
addison wesley professional edition .
m. hall n. walkinshaw and p .
mcminn.
supervised software modularisation.
in 28th ieee international conference on software maintenance icsm pages .
ieee .
m. harman and p .
mcminn.
a theoretical and empirical study of searchbased testing local global and hybrid search.
ieee transactions on software engineering .
m. harman and l. tratt.
pareto optimal search based refactoring at the design level.
in proceedings of the 9th annual conference on genetic and evolutionary computation pages .
g. huang h. mei and q. x. wang.
towards software architecture at runtime.
acm sigsoft software engineering notes .
m. kessentini w. kessentini h. sahraoui m. boukadoum and a. ouni.design defects detection and correction by example.
in ieee 19th international conference on program comprehension pages .
ieee .
m. kim t. zimmermann and n. nagappan.
an empirical study of refactoring challenges and benefits at microsoft.
ieee transactions on software engineering .
j. koehler and a. owen.
computer experiments.
handbook of statistics.
elsevier science pages .
m. kuutila m. m ntyl u. farooq and m. claes.
time pressure in software engineering a systematic review.
information and software technology .
t. mariani and s. r. v ergilio.
a systematic review on search based refactoring.
information and software technology .
h. melton and e. tempero.
identifying refactoring opportunities by identifying dependency cycles.
in proceedings of the 29th australasian computer science conference acsc pages australia .
acm.
t. mens g. taentzer and o. runge.
detecting structural refactoring conflicts using critical pair analysis.
electronic notes in theoretical computer science .
h. meunier e. g. talbi and p .
reininger.
a multiobjective genetic algorithm for radio network optimization.
in proceedings of the congress on evolutionary computation.
cec00 cat.
no.
00th8512 volume pages .
ieee .
m. w. mkaouer m. kessentini s. bechikh m. .
cinn ide and k. deb.
on the use of many quality attributes for software refactoring amany objective search based software engineering approach.
empirical software engineering .
m. w. mkaouer m. kessentini m. .
cinn ide s. hayashi and k. deb.
a robust multi objective approach to balance severity and importance ofrefactoring opportunities.
empirical software engineering .
m. mohan and d. greer.
a survey of search based refactoring for software maintenance.
journal of software engineering research and development .
e. murphy hill c. parnin and a. p .
black.
how we refactor and how we know it.
ieee transactions on software engineering .
m. cinn ide l. tratt m. harman s. counsell and i. hemati moghadam.
experimental assessment of software metricsusing automated refactoring.
in proceedings of the acm ieee international symposium on empirical software engineering andmeasurement pages .
m. o keeffe and m. o. cinn ide.
a stochastic approach to automated design improvement.
in proceedings of the 2nd international conference on principles and practice of programming in java pppj pages59 kilkenny city ireland .
acm.
v .
p .
l. oliveira e. f. souza c. le goues and c. g. camilojunior.
improved crossover operators for genetic programming forprogram repair.
in international symposium on search based software engineering pages .
springer .
w. f. opdyke.
refactoring object oriented frameworks.
phd thesis university of illinois at urbana champaign champaign il usa .
a. ouni m. kessentini h. sahraoui and m. s. hamdi.
searchbased refactoring towards semantics preservation.
in 28th ieee international conference on software maintenance icsm pages .
ieee .
a. ouni m. kessentini h. sahraoui k. inoue and k. deb.
multicriteria code refactoring using search based software engineering anindustrial case study.
acm transactions on software engineering and methodology tosem .
a. ouni m. kessentini h. sahraoui k. inoue and k. deb.
multicriteria code refactoring using search based software engineering anindustrial case study.
acm transactions on software engineering and methodology .
a. ouni m. kessentini h. sahraoui k. inoue and m. s. hamdi.
improving multi objective code smells correction using developmenthistory.
journal of systems and software .
a. ouni r. g. kula m. kessentini t. ishio d. m. german and k. inoue.
search based software library recommendation using multi objective optimization.
information and software technology .
m. o keeffe and m. o. cinn ide.
search based refactoring for software maintenance.
journal of systems and software .
f. palomba g. bavota m. di penta r. oliveto a. de lucia and d. poshyvanyk.
detecting bad smells in source code using changehistory information.
in 28th ieee acm international conference on automated software engineering ase pages .
ieee .
r. terra m. t. v alente k. czarnecki and r. s. bigonha.
recommending refactorings to reverse software architecture erosion.
in 16th european conference on software maintenance and reengineering pages .
ieee .
e. tom a. aurum and r. vidgen.
an exploration of technical debt.
journal of systems and software .
n. tsantalis t. chaikalis and a. chatzigeorgiou.
jdeodorant identification and removal of type checking bad smells.
in 12th european conference on software maintenance and reengineering pages .
ieee .
n. tsantalis and a. chatzigeorgiou.
identification of move method refactoring opportunities.
ieee transactions on software engineering .
d. a. v an v eldhuizen and g. b. lamont.
multiobjective evolutionary algorithm research a history and analysis.
technical report citeseer .
n. y oshida y .
higo t. kamiya s. kusumoto and k. inoue.
on refactoring support based on code clone dependency relation.
inproceedings of the 11th ieee international software metrics symposium metrics pages pp como italy .
ieee.
x. zhang y .
tian and y .
jin.
a knee point driven evolutionary algorithm for many objective optimization.
ieee transactions on evolutionary computation .
f. l. zhu h. w. deng f. li and s. g. cheng.
improved crossover operators and mutation operators to prevent premature convergence.
sci technol eng .
e. zitzler and l. thiele.
multiobjective evolutionary algorithms a comparative case study and the strength pareto approach.
ieee transactions on evolutionary computation .