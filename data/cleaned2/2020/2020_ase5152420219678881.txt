data driven design and evaluation of smt meta solving strategies balancing performance accuracy and cost malte mues tu dortmund university dortmund germany malte.mues tu dortmund.defalk howar tu dortmund university dortmund germany falk.howar tu dortmund.de abstract many modern software engineering tools integrate smt decision procedures and rely on the accuracy and performance of smt solvers.
we describe four basic patterns forintegrating constraint solvers earliest verdict majority vote feature based solver selection and verdict based second attempt that can be used for combining individual solvers into meta decision procedures that balance accuracy performance and cost or optimize for one of these metrics.
in order to evaluatethe effectiveness of meta solving we analyze and minimize existing benchmark suites and benchmark seven state of the art smt solvers on 17k unique instances.
from the obtained performance data we can estimate the performance of differentmeta solving strategies.
we validate our results by implementingand analyzing two strategies.
as additional results we obtain a the first benchmark suite of unique smt string problems withvalidated expected verdicts b an extensive dataset containingdata on benchmark instances as well as on the performance ofindividual decision procedures and several meta solving strategieson these instances and c a framework for generating data thatcan easily be used for similar analyses on different benchmarkinstances or for different decision procedures.
i. i ntroduction modern software analysis tools are complex and rely on smt solvers for automated reasoning.
since the introduction of z3 and cvc4 many research solvers have beendeveloped and specialize in different aspects of certain smttheories.
researchers and industry frequently use these solversin their own tools.
decision procedures for constraints overstring variables and string operations e.g.
are one key enablerfor the formal analysis of web applications that rely heavilyon string variables for passing urls and request parameters e.g.
.
the development of securityanalysis tools and advances in the area of string theory solving e.g.
are closely connected.
inthe field of j ava web application analysis the j ava string analyzer was presented more than 15years ago and evolved into the integration of string method encoding basedon modern smt solvers in symbolic execution engines likesymbolic pathfinder .
nevertheless until today newer j ava analyzers still report about problems and challenges in the encodings of string operations whileexploring j ava code.recent advances in string theory solving have been accompanied by new tools for testing and fuzzing smt solvers e.g.
.
these tools uncovered variousbugs in the implementation of decision procedures.
moreover at smt comp the only two competing solvers in thestring related categories cvc4 and z3str4 had a couple of disagreements on the correct solutions for the providedbenchmark tasks .
while this is natural for cutting edge research tools users of this technology need strategies for integrating such compo nents without jeopardizing the validity of obtained researchresults and for minimizing the harmful potential of bugs or at least methods for analyzing potential bias andconfidence in obtained analysis results.
existing approachesthat are employed by individual tool developers or researchcommunities are constructive and analytical and include thedevelopment of proof witness producing analyses e.g.
portfolio techniques e.g.
tool integrationplatforms and benchmarking e.g.
.
we propose to increase accuracy and validity through integration of multiple decision procedures.
in this paper wedemonstrate that a data driven design of such meta solvingstrategies is possible.
we discuss a set of four basic patternsfor the integration of multiple solvers balancing response time performance accuracy and cost for obtaining the results.
weuse these basic patterns for constructing integrated analysesfrom seven constraint solvers.
we validate the design pat terns by evaluating the performance of these seven individualsolvers and four integrated solvers.
to run the evaluation we pre processed and prepared existing string benchmarksleading to the first string benchmark suite of smt stringproblems with validated expected verdicts.
we describe aframework for analyzing data that can be used for the designand evaluation of meta solving strategies.
we propose fourdifferent meta solving strategies using the framework and haveimplemented two of them.
we simulated the other two withthe available data and evaluate all four strategies against the 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee seven individual solvers on the benchmark set.
our evaluation shows that all tested solvers have individual performance profiles and that no solver dominates on all benchmark instances.
nevertheless cvc4 is the best single solver in the evaluation and can only be outperformed bymore expensive meta solving strategies.
moreover the earliest verdict strategy which is often touted as a viable solution was prone to incorrect verdicts in our experiments.
using theintroduced verdict based second attempt pattern allows us to increase performance and reliability at moderate costs.
we accompany our paper with a corresponding artifact that consists of all data produced in the experiments in adatabase along with all the scripts used for generating the datareported in tables and figures in this paper as well as of theinfrastructure that was used for conducting the experiments.
itcontains the per instance performance of each solver allowingbetter comparison between solvers in the future and make iteasy to extend the comparison by other solvers.
this data isavailable for others interested in detailed performance data ofa solver .
outline.
in the next section we present a selection of relevant related work for this paper.
section iii presents solver integration pattern and section iv describes our preparation of thebenchmarks used for the data driven design of concrete meta solving strategies presented in section v and their evaluationin section vi.
we discuss the results and draw conclusions insection vii and section viii.
ii.
r elated work the presented approach builds on ideas from three areas integration of formal methods meta smt solving and stringtheory solving.
a. integration of f ormal methods the integration of formal methods is still challenging as many formal methods tend to be designed as single method but the recent history shows that integration becames more im portant.
h ahnle et al.
discuss this challenge for deductive verification tools.
damiani et al.
demonstrate how tool re finement can be used to orchestrate multiple verification toolsin a divide and conquer style.
the electronic tool integrationplatform was an early approach to standardize how toolscould be combined.
the sv comp uses competition tools toconfirm produced witnesses enforcing some kind of provabilityof the verdict .
b. meta solving the idea of solver abstraction layers and meta solving support have been proposed for the first time more than a decade ago c.f.
.
the solver abstractions are oftendeveloped hand in hand with a verification tool.
they allowto access the solvers as a library in the language of the tooland support features the developer of the software verificationtool have been interested in.
cpa checker e.g.
comes along with j avasmt jd art introduced the abstraction library jconstraints and cok developed jsmtlib along with the development of smt lib.
in the python eco system pysmt is very popular as an abstraction layer and for c meta smt formed around the k lee tool.
machsmt is a recently introduced approach for machinelearning based selection of an smt solver based on expectedperformance.
meta smt supports parallel solving in the k lee solving chain and is used for speeding up k lee.
in the original meta smt paper the authors described and already noticed the importance of cross checking solver results adecade ago.
they crosschecked all the results obtained fromdifferent solver backends of meta smt against z3.
it does not support any kind of inter solver checking or unsatisfiable corevalidation on the fly.
pysmt has a parallel solving support as well but no other advanced meta solving strategies comparableto the c vcseqcores solving strategy we propose in this paper c.f.
section iii .
a unique feature of jc onstraints is that it supports the validation of smt lib models in the j ava semantics.
this is useful in the case of ground truth label validation and weadapted the code for model validation to match the completeunicode theory of smt lib .
.
zaligvinder is a framework executing multiple solvers on different benchmarks and visualises the results per bench mark.
while this is useful tool and similiar to parts of theproposed workflow in this paper the zaligvinder s authorshave not run any analysis of the results nor the benchmarks.
c. string theory solver abc aydin et al.
presented a model counting string theory solver called abc in and still maintain it.
this research project is embedded into bultan et al.
s book onstring analysis for software verification .
the tool is notdistributed as a pre built release binary so we have built themaster 3branch and used the resulting binary without any further adoptions.
ostrich chen et al.
presented o strich more recently in and the development is still active.
the solver is supposed to be easily extensible and has one solving strategythat relies on simple functions.
for more complex functionsand nondeterministic string operations the solver incorporatesthe s loth solver in the background.
s loth relies on model checking algorithms like ic3.
in this comparison weused o strich s official release version .
.
.
since ostrich appears to include s loth and is presented as the more efficient string solver in the paper on o strich we excluded sloth from our experiments.
norn abdulla et al.
introduced n orn in .
the paper also established the norn benchmark used until today.
one focus of the norn solver are regular membership queries andthis is also dominant in the norn benchmark.
while n orn shines on the regular membership queries in smt problems the older versions of cvc4 and the z3 str family used for 3on 180problem a b n vote verdictwait for allproblem a b n verdictearliest w conditionproblem a b c verdictoneverdict based decisionproblem a b verdictoneinput based decision fig.
basic constraint solver integration patterns majority vote earliest verdict verdict based second attempt or validation feature based capability based solver selection from left to right .
comparison in the original paper have already been better than norn back in on the kaluza benchmark.
however we excluded n orn from the experiments.
n orn might have its place in a a meta solver tackling workloads with many regularexpression membership constraints.
trau abdulla et al.
presented t rau in .
it is a cegar based solver but is not actively maintained5.
therefore we excluded it from the comparison in this paper in favor of actively maintained solvers but data for trau is included inthe artifact.
z3 sequence solver seq z3 with its own sequence solver is one of the smt solvers that have been around for over a decade now.
as there are a couple of other stringbackends in z3 available that have been integrated over time we refer in the paper to the sequence solver backend as seq.we used z3 in a slightly newer version than the official .
.10release build from its master branch .
z3str family ganesh et al.
developed the z3str solver family.
the newest member in the family is z3str47 while z3 str3 is part of the official z3 distribution.
whenever we run z3 str3 it is the above mentioned z3 binary configured to use the appropriate backend.
cvc4 barett et al.
introduced cvc4 a very com petitive main stream smt solver that is often used as z3 s counterpart in evaluations.
cvc4 is a dpll t style solver with many different specialized theory backends also one for strings .we used the official .
release version .
princess r ummer et al.
presented p rincess a full smt solver written in scala.
while the others are written in c .princess is based on presburger arithmetic.
we used a recentofficial release .
s3trinh et al.
presented s3 the symbolic string solver for vulnerability analysis with a competitive performance.
withthe introduction of n orn some soundness issues have been reported.
there was s3p as a follow up version butit is not actively maintained at the moment.
we excluded it our experiments.
there was only one update version in2020 requiring an outdated ubuntu .
iii.
s olver integration patterns the goal of the integration of multiple smt solvers is usually an increase in the number of solved tasks or somekind of cross validation between solvers.
depending on thechosen strategy this increase in performance and reliability iseither paid for by longer response times or increased hardwaredemands.
we derive four basic patterns from portfolio solversproposed in literature c.f.
.
figure 1sketches them.
the remainign section explains these integra tion in detail.
these four basic patterns can be combinedhierarchically as a basis for more complex meta solver ormulti solver decision procedures.
a. majority v ote the majority v ote pattern left of figure integrates different constraint solvers or multiple instances of the same solver atonby analyzing a problem instance with all solvers.
after the return of all solvers or the exhaustion ofthe resource share per solver e.g.
time limit a majority vote or any other aggregation of the obtained individual verdicts is computed as a final verdict.
benefits vs. cost.
this pattern can increase the confidence in obtained results and can help with identifying potential bugs in underlying constraint solvers.
but it is very expensive asusingnsolvers can lead to an n fold increase in response time if solvers are executed sequentially and or resources in case solvers are executed in parallel .
solvers that solvea problem fast or fail early are optimal candidates for thispattern.
solvers that tend to timeout in the given resource limitwithout reaching a result are less helpful as they increase thecost without hardening the result in the worst case.
b. earliest v erdict the earliest v erdict pattern center left of figure integrates constraint solvers atonby analyzing a problem instance with all solvers.
the first obtained verdict is used as the final verdict errors and unknowns may be disregarded.
181benefits vs. cost.
this pattern optimizes response times and the number of successful analyses at the expense of parallel resource consumption.
it is often instantiated by calling the sameconstraint solver with different random seeds or configurationoptions in order to profit from effects of randomization .
as we will show in figure this pattern is not suitedfor improving correctness and requires sufficient trust in theinvolved solvers.
the invested resources pay off if the totalnumber of solved instances is more important than correctnessor if all solvers are known to be reliable upfront.
c. v erdict based second attempt or validation this pattern center right of figure integrates multiple constraint solvers by first calling solver aand then deciding on a next step on the basis of the obtained verdict.
potential next steps can be a using the verdict of aas final verdict b invoking another solver on the original problem e.g.
inthe case that adid not provide a verdict or c using another solver or tool to validate the result computed by a. strategies for validation comprise i evaluating the problem instancewith an obtained model ii checking an unsatisfiable coreby a second solver iii checking an obtained model and theoriginal problem with another solver or iv switching theencoding or tactic e.g.
the f eal solver integration .
benefits vs. cost.
while this pattern can increase confidence in obtained results and the number of successful analyses ina more meaningful way than the previous two patterns itrequires deeper integration between solvers for communicatingmodels and unsatisfiable cores or additional tools for evaluat ing instances and models.
this leads to higher running timesand requires support in the solvers for tracking unsatisfiablecores.
d. feature based capability based solver selection.
this pattern center right of figure integrates multiple solvers by selecting one constraint solver for a problem instance based on features of the problem instance e.g.
usedoperators and sorts and based on capabilities of individualsolvers.
the pattern is e.g.
instantiated in works that trainmodels for selecting a solver that will most likely analyze aproblem instance successfully.
benefits vs. cost.
feature based or capability based solver selection can optimize performance and the number of successful analyses with fewer resources than for example the earliestverdict pattern but relies on the existence and identificationof characteristic features in problem instances and or solvers.this can add additional complexity to the task of designingan integration of constraint solvers and may easily be biasedthrough training sets that are not representative.
iv .
smt s tring benchmarks we need a representative benchmark set that includes expected verdicts as a basis for data driven design decisions andas a basis for the comparative evaluation of the meta solving solvingstrategies to be developed.
since a we have no means ofdeciding if a given benchmark set is representative of all smtstring problems or even of some particular application arealike program analysis and since b most of the existingbenchmark sets from the literature do not include expectedverdicts we simply collected all the benchmarks sets wecould find.
we use the combined problem instances as thebasis for a new benchmark set after removing duplicatesto reduce potential bias and optimize resource consumptionduring experiments.
in order to gain at least some confidencein the adequacy of the new benchmark set we analyze itscomposition and diversity.
finally we compute and validateexpected verdicts for all instances.
a. collection and pre processing of instances we use the following benchmark suites from the literature.
pyex pisa norn13 trau light14 leetcode strings15 ibm appscan16 sloth woorpje17 kaluza18 stringfuzz19 z3str320 cashew joaco stranger kausler and banditfuzz21 .
we extend this set with smt problems obtained by running jd art a j ava program analysis tool with a modification that exports smt verification tasks on the j ava programs of sv comp and refer to the corresponding subset of instances as svcomp.
duplicate removal.
duplicates of the same task in a benchmark inflate the task set artificially without any contributionto the explanatory power of the benchmark set regardingtool performance and even worse may introduce bias intoconclusions that can be drawn.
we use a form of structural identity for removing duplicates for a set xof variables let f xdenote the set of syntactically correct benchmark instances over variables from x. let fxbe a benchmark instance.
we can rename variables in and write for the instance that is obtained by replacing all occurrences of variable ywith variable xand all occurrences of variable zwith variable ysimultaneously in .
a renaming then is a mapping x mapsto xand we write to denote the application of to i.e.
the instance forx1 x2 ... x. definition identity up to renaming .
two benchmark instances fxareidentical up to renaming iff there exists a bijective renaming x mapsto xfor which .
identity up to renaming is an equivalence relation on fx.
expressions assert x abc and assert 12taken from 13taken form jarst116 norn 14taken from trau light 15taken from leetcode strings 16taken from ibm appscan 17taken from woorpje word equations 18taken from 20taken from z3str3 regression public 182kaluza cashew stranger sloth norn stringfuzz joaco appscan svcomp z3str3 banditfuzz pyex leetcode pisa kausler wwe trau light size unique general not type cast ite or and exists assert string to re in re at substr prefixof suffixof contains indexof replace replace all to int from int lower upper regular expressions none allchar union inter range numeric str.len neg mod table i no benchmark suite contained operations str.
str.
re.all str.replace re str.replace re all re.comp re.diff re.
re.loop str.is digit str.to code str.from code re.opt y abc e.g.
are identical up to renaming since we can renamextoyand vice versa.
we have removed all duplicate instances based on identity up to renaming from the original benchmark sets reducingthem from a total of to tasks .
detailed resultsare reported in the first two rows of table i size and unique .four benchmark suites shrunk significantly in size more than10 reduction kaluza reduced by joaco reduced by24 and stringfuzz reduced by and svcomp reduced by .
for the kaluza set we found more than identical instances in one extreme case.
a similar observation has been made by brennan et al.
in their workon string normalization .
they report that the subset ofthe kaluza benchmark used for their research on constraintcaching contains many binary duplicates i.e.
identical files.
after removing duplicates the benchmark sets still contains many symmetries e.g.
instances assert x abc and assert abc x or assert x and assert x .
we did not attempt to reduce symmetry since structure may have an influence onthe performance of search heuristics in solvers.
character encoding.
one problem encountered in the existing benchmarks are inconsistencies in the unicode encoding.
the unicode theory requires e.g.
using u for encoding the tab character while some solvers also acceptthe escaping t and z3 traditionally used a hex encoding for characters x09 for tab .
in order to avoid inconsistent results as a consequence from these differences we prepare a 183unsat 7sat018 fig.
the figure shows verdict combinations for seven solvers on all benchmark instances.
each cell in row iand column jhasisatisfiable verdicts and junsatisfiable verdicts.
the heatmap yellow highlights clustering of instances.
every cellshows number of contained instances bold as well as numberof confirmed models checked unsatisfiable cores.
green andred coloring indicates the voting based expected verdict satand unsat in cases where verdicts could not be validated.
corresponding variant of benchmark instances and used these where appropriate without further mention.
b. features in benchmark suites we analyze the composition and diversity in the combined benchmark set by counting occurrences of relevant operations in instances from every source.
table i lists the used operatorsorganized into four groups general smt string theory regularexpressions and numeric.
we arranged the benchmarks intogroups as well focusing on string concatenation with regularexpression membership queries on the left to pure wordequation benchmarks on the right.
we observe that the group between appscan and kausler use string operations str.prefixof str.suffixof and str.contains which from our experience occur frequently in program security analysis.benchmark sets right of and including pyex do not use any regular expressions.
none of the benchmarks contain thestring order operations str.
orstr.
.
only svcomp has instances that use str.lower andstr.upper which are not yet included in the official smt lib v2.
standardbut are already supported by some solvers.
the benchmark sets contain relatively few instances that combine numeric values and strings the functions for con version between code points and strings str.to codeandstr.from code do not appear in any benchmark suite andjoaco is the only benchmark that contains the str.from int andstr.to int operations.
since parsing unicode byte patterns into string characters and numericvalues from strings occurs frequently in web applications weconjecture that the set of presented benchmarks is not adequatefor predicting solver performance for analyses in this domain.c.
generating expected v erdicts.
while expected verdicts are essential as ground truth when comparing the performance of decision procedures verdictscan only be found for the cashew joaco kaluza kausler stranger and z3str3 benchmark sets in the literature.
we compute expected verdicts for the combinedbenchmark set in three steps first we compute the verdictsof seven smt solvers abc cvc4 o strich princess seq z3 str3 z3 str4 for every problem.
as cvc4 and seq return most definitive verdicts cf.
section vi we try to validate the verdicts of these solvers in a second step satisfiable verdicts from either solver are validated by evaluating corresponding models on problem instances using the jc onstraints library.
unsatisfiable verdicts from cvc4 are validated by checking the corresponding unsatisfiable corewith seq.
validated verdicts are used as expected verdicts.for satisfiable verdicts a model with confirming evaluation ofthe model in the context of the problem is a proof of theverdict.
for unsatisfiable verdicts a confirmed unsatisfiablecore is at least an argument that two solvers agree on theunsatisfiable part of the problem.
for the cases in whichvalidation was not successful we determine the likely correct expected verdict by majority vote.
we have not observed aconfirmed satisfiable model and a confirmed unsatisfiable coreon the same problem.
if it happens the confirmed satisfiablemodel should define the expected verdict.
the test of asatisfiable model is easier from a theoretical point of viewthan the proof of unsatisfiability and we have implementedthe conformance test independent of a solver.
in any case a manual root cause analysis on the instance to identify thereasons for the disagreeing verdicts is recommended.
results are summarized in figure .
cells group problem instances according to the respective number of obtainedsatisfiable and unsatisfiable votes.
cells show the number of corresponding problems bold and the number of val idated models and validated unsatisfiable cores m c .
wehighlighted accumulations of verdicts with increase in theintensity of yellow as background color in the cell.
thebiggest cluster containing instances got satisfiablevotes and unsatisfiable votes.
in the data a cluster with 997instances received satisifiable votes and unsatisfiable votescatching attention.
the other larger cluster manifested withclear satisfiable or unsatisfiable votes.
overall we can providevalidated verdicts for .
of all benchmark problems using cross checking for unsastisfiable cores and model tests forprovided models with jc onstraints .
we cannot provide expected verdicts for the 36instances on which validation failed and voting led to a tie cells and .
pleasenote that validated models reported in these cells are not anerror but were obtained by using seq in a mode that tracksunsatisfiable cores and performs differently from the defaultconfiguration of seq used for voting.
v. d ata driven design of meta solving strategies using the benchmark suite described in the previous section and the performance data of the seven individual smt solvers 184abccvc4 ostrichprincessseq z3str3z3str404 sat.
instances abccvc4 ostrichprincessseq z3str3z3str402 unsat.
instancesunsat sat unknown error out of memory timeout fig.
verdicts and inconclusive results of smt solvers abc cvc4 o strich princess seq z3 str3 and z3 str4o n the benchmark suite presented in section iv for satisfiable instances left and unsatisfiable instances right .
table ii performance of individual smt solvers and meta solving strategies likely correct verdicts likely incorrect verdicts unknowns errors timeouts and cpu time estimated for simulated meta solving strategies .
v ote is omitted as it is used as basis for computing expected verdicts.
the table contains tasks for wich we could establish a ground truth ofthe tasks in the benchmark.
earliestearliesttrusted cvcseqcores cvcseqeva l abc cvc4 seq z3str3 z3str4 princessostrich correct unknown error timeout incorrect cpu time s s s s s s s s s s s s abc cvc4 o strich p rincess seq z3 str3 and z3str4 on this benchmark we design five meta solving strategies.
let us start by analyzing the performance databefore discussing the resulting design decisions.
a. performance data from benchmarks we focus primarily on analyzing correct verdicts in this section and will analyze resource consumption in section vi.
figure summarizes the performance of the individual solvers split into satisfiable instances left and unsatisfiable instances right .
we can make two observations abc and z3 str4 produce many incorrect verdicts compared to our expected verdicts for unsatisfiablebenchmark instances.
22we perform an online transformation of character encodings as detailed in theprevious section.
moreover the ground truth labels arevalidated but not proven.
both may contribute to theobserved behavior.
for the data driven design of meta solving strategies we simply observe that these two 22for z3 str4 we checked the incorrectly satisfiable instances through z3str4 s java api which does yield the expected unsatisifable answers.
we assume a bug in the smt lib frontend of z3 str4 but were not able to locate it.
for abc it was not possible to analyze returned models to find a root cause as abc s api for accessing models is currently not compatible withthe model validator in jc onstraints .
these types of bugs are to expected in research tools and will hopefully be fixed soon and must not be taken as an indicator of bad solver performance!solvers frequently produce verdicts that deviate from the majority of solvers on instances deemed unsatisfiable i.e.
we will be skeptical about their satisfiable verdicts.
p rincess and o strich solve significantly fewer instances than the other solvers.
we will not considerthese solvers when optimizing for resource consumptionand definitive verdicts without analyzing features ofbenchmark instances.
b. designing meta solving strategies for the remainder of this paper we focus on five metasolving strategies v ote e arliest e arliest trusted cvcseqeva l and c vcseqcores implementing three integration patterns majority vote earliest verdict and verdictbased second attempt .
while we do not present a metasolving strategy based on the input based decision pattern we provide some results on training input based predictors forsolver performance in section vi.
v ote .the v ote strategy instantiates the majority vote pattern executing all seven individual solvers in parallel.
allobtained results are aggregated into a final verdict ignoringtimeouts errors and out of memory failures.
we have not actu ally implemented this design and instead compute its expectedperformance i.e.
correct verdicts from the performance dataof the individual solvers.
the meaningfulness of the results 185obtained with this strategy is limited within the scope of this paper since it was used to compute expected verdicts on thebenchmark suite.
e arliest .the e arliest strategy instantiates the earliest verdict pattern in a straightforward manner all solvers are run in parallel and the earliest satisfiable orunsatisfiable verdict is returned immediately.
failing solvers or unknown verdicts are ignored.
as for v ote we have not actually implemented this strategy and only compute its expected performance.
earliest trusted .this strategy refines the e arliest strategy based on the first observation reported in the previoussubsection an earliest unsatisfiable verdict is returned immediately.
any earliest satisfiable verdict is disregarded from abc and z3 str4 and only used if it is reported by one of the other solvers.
we have not implemented this strategy and computeits expected performance.
c vcseqeva l .the c vcseqeva l strategy instantiates the verdict based second attempt or validation pattern and is based on two observations.
first p rincess and o strich solve significantly fewer benchmark instances than the othersolvers cf.
above .
second cvc4 and seq use dif ferent theories internally and we expect complementing performanceprofiles.
hence c vcseqeva l starts by calling cvc4 with a timeout of one minute.
then if cvc4 returns an unsatisfiable verdict it simply returns the verdict.
if cvc4 returns a satisfiable verdict and a model c vcseqeva l validates the model by evaluating it on the problem in question using the jconstraints library cf.
section ii .
in case the model can be validated the satisfiable verdict is returned.
in all other cases c vcseqeva l invokes seq for a final verdict.
as for cvc4 models are checked for satisfiable verdicts and in case the model cannot be validated reported as unknown.
we expect that c vcseqeva l computes definitive verdicts for most benchmark instances.
cvcseqcores .the c vcseqcores strategy refines the cvcseqeva l strategy in cases were cvc4 returns an unsatisfiable verdict in these cases c vcseqcores tries to validate the verdict by checking the returned unsatisfiable corewith seq.
as for unvalidated satisfiable verdicts unconfirmed unsatisfiable cores are reported as unknown.
we expect that c vcseqcores produces only very few incorrect verdicts at the price of computing slightly fewer definitive verdicts than cvcseqeva l since both solvers have to agree on unsatisfiable verdicts.
as the unsatisfiable core might be a smaller problem than the original task we expect that c vcseqcores solves more tasks than a solver alone as the unsat corevalidation is less expensive.
while we only consider individual patterns in this work it would be easy to combine multiple patterns into complexermeta solving strategies e.g.
for validating earliest verdicts ina second attempt balancing response time and accuracy.
18000response time s per problem solved problemsabc cvc4 cvcseqcores cvcseqevalearliest earliesttrusted seq z3str3z3str4 ostrich princess fig.
number of benchmark instances solved with satisfiableor unsatisfiable answer by individual solvers and meta solvingstrategies sorted by increasing response time.
e arliest and earliest trusted are predictions other times are measured.
vi.
e v aluation we conduct a series of experiments in order to evaluate the effectiveness of our data driven approach to designing meta solving strategies by addressing the following three concreteresearch questions.
rq1.
do meta solving strategies beat individual solvers interms of response time correctness and cost?
rq2.
what are the observable trade offs between responsetime correctness and cost?
rq3.
can we reliably predict if a solver will return adefinitive and correct verdict based on features ofa problem instance?
we have implemented the c vcseqeva l and c vcseqcores strategies on top of the jc onstraints solver abstraction layer in j ava and have used these implementations to obtain data on performance and resource consumption on thebenchmark suite.
for the three meta solving strategies that wedid not implement we estimate resource consumption basedon the data recorded in the experiments with the individualsolvers and the instantiated integration pattern.
all results were obtained using the benchexec framework for executing the seven individual solvers abc cvc4 o strich princess seq z3 str3 and z3 str4 as well as two meta solving strategies c vcseqeva l and c vcseqcores on the benchmark suite presented in section iv.
we used an intel i9 7920x cpu vcores with gib ramrunning ubuntu .
lts.
each run i.e.
one solver on onebenchmark problem was provisioned with .
gb ram 1vcore and a minute timeout in the benchexec configuration.
table ii reports the number of correct and incorrect verdicts other results and accumulated cpu time for the seven indi186vidual constraint solvers and for four meta solving strategies analyzing v ote would not be meaningful since it was used to compute expected verdicts .
figure plots response time needed time to solve an instance against correctly solved in stances sorted by increasing response time showing detailedresource profiles in terms of wall time consumption.
a. effectiveness of meta solving rq1 as can be seen in table ii the meta solving strategies outperform the individual constraint solvers with respect to the number of correct verdicts exceeding thebest individual solver cvc4 by correct verdicts or .
e arliest trusted .
only the c vcseqcores metasolving strategy produces 67fewer correct verdicts as cvc4.
the results are more mixed for the number of incorrect results e arliest inherits a very high number of incorrect results from abc and z3 str4 and while the e arliest trusted strategy was explicitly designed to disregard potentially incorrect verdicts from these two solvers it still producesa greater number of incorrect verdicts than cvc4 seq and p rincess .
the more conservative c vcseqeva l strategy also suffers from 2incorrect verdicts which is comparable to seq solver and only slightly worse than cvc4.
only the cvcseqeva l strategy produces no incorrect verdicts and is on par with cvc4 and the p rincess solver in this respect.
with respect to accumulated cpu time e arliest is estimated to be almost as cheap as the cheapest individual solver earliest trusted on the other hand is only better than z3str3 and more expensive than most individual solvers.
as this strategy require seven cores to run the paid cputime masks the fast response time.
figure shows that e arliest answers close to 16k problems in less than one second response time per problem.
e arliest trusted still answers over 15k problems in less than one second response time.
the best single solver answers around 14k of the problems in less than one second.
the c vcseqeva l and cvcseqcores meta solving strategies are almost on par with the faster constraint solvers where checking of unsatisfiablecores increases resource consumption by .
in terms of response times we observe for these two strategies a constantoverhead compared to the solving times of cvc4 and seq that vanishes if the response time passes two seconds.
thisoverhead originates from the startup time of the jvm as thisstrategy is implemented as part of jc onstraints in j ava while booth solvers are written in c .
the jvm startup isincluded in the in measured time presented in the figure.
thesame overhead is included for o strich and p rincess .
b. trade offs rq2 comparing the profiles of the meta solving strategies we disregard the e arliest meta solving strategy that seems to be problematic on the concrete benchmark suite and for theconcrete selection of solvers as it is strongly affected by incor rect verdicts.
the e arliest trusted strategy pays for a very competitive response time with a high resource consumption.this may be an interesting performance profile in scenarioswere horizontal scaling is cheap if the strategy can be furtherrefined to exclude likely incorrect verdicts.
the c vcseqeva l strategy balances correct verdicts resource consumption andresponse time very well.
the c vcseqcores strategy pays for zero incorrect verdicts with a increase in resource consumption compared to c vcseqeva l .
the increase in response time seems to be negligible.
c. feature based solver selection rq3 while we do not present an instance of the input based decision integration pattern in this paper we want to evaluate if the obtained data could help designing such a meta solving strategy especially since other works have presented input based decision strategies.
to this end we have trained randomforest classifiers to predict whether a solver can solve a bench mark instance correctly based on the number of occurrencesfor each smt primitive in the instance.
training of classifierswas implemented using python s sklearn library and the implementation is available as part of the provided artifact.
table iii shows the achieved precision recall and f score as well as the most influential features for individualsolvers.
reported numbers are averages std.
deviations froma five fold cross validation with a randomized split into training set and test set.
for individual runs precision recall andf 1score are computed as weighted averages of the metrics for each label to account for the imbalance in the size ofthe different classes some solvers can solve many benchmarkinstances correctly .
as can be seen in the table the trainedclassifiers achieve very high values for precision recall andf 1score.
when using input based decisions with the goal of reducing resource consumption precision is the most relevant metric as it expresses the percentage of correct solver can solveinstance predictions.
the very high values for the precisionof the trained models seems encouraging but has of course been achieved with strongly biased training and test sets for thesolvers that solve many benchmark instances correctly whichraises the suspicion that simply always predicting that a solvercan solve an instance would already yield a high precision.
a more detailed report of the classification results not included in the paper but can easily obtained from the dataand scripts in the artifact shows however that the trainedclassifiers do not fall in this trap even for the solvers thatcan solve many instances the trained classifiers achieve highprecision and reasonable recall for the smaller i.e.
cannotsolve class.
for this class individually recall is the moreinteresting metric as it indicates how frequently the classifierwould be able to prevent us from using a solver that cannotsolve an instance successfully.
precision ranges from to88 and recall ranges from to75 in these cases showing that even though the training set is very unbalanced classifiers identify features that predict performance.
for thesolvers with reasonably balanced training sets precision andrecall are high for both classes.
the identified important variables provide additional explanation and validation of the achieved precision.
as an example 187table iii prediction of solver behavior definitive correct verdict or not based on features of problem instances features count contained smt operations occurrences per type of operation precision recall f1score and five most important features for seven individual solvers.
solver precision recall f1score important variables abc .
.
.
.
.
.
str eq .
.
str to re .
.
emptystr .
.
re concat .
.
str concat .
.
cvc4 .
.
.
.
.
.
cast .
.
emptystr .
.
str to re .
.
and op .
.
re union .
.
ostrich .
.
.
.
.
.
indexof .
.
contains .
.
str concat .
.
not op .
.
and op .
.
princess .
.
.
.
.
.
str eq .
.
contains .
.
indexof .
.
not op .
.
uminus .
.
seq .
.
.
.
.
.
len .
.
str concat .
.
str eq .
.
equals .
.
str to re .
.
z3str3 .
.
.
.
.
.
plus .
.
indexof .
.
str eq .
.
contains .
.
not op .
.
z3str4 .
.
.
.
.
.
replace .
.
str concat .
.
plus .
.
len .
.
substr .
.
for cvc4 the cast operator is identified as an important variable in the experiments cf.
in table iii .
this matchesour observation that cvc4 is good in casting between data types.
for z3 str3 theplus andindexof operators are important for the decision as z3 str3 does not support the combination of integer theory and string theory.
these observations show that the the learned classifiers to some degree use features that relate benchmark instances andsolver capabilities.
this suggests that learned classifiers couldbe used for instantiating the input based decision and that a proper evaluation of the achievable performance is worthwhileof further investigation.
finally the information on importantfeatures could alternatively be used for the data driven manualdesign of input based decisions.
vii.
d iscussion and threats to validity we can now summarize our observations draw some initial conclusions about the application of meta solving strategies and discuss some threats to the validity of the obtained results.
concept validity.
the different performance profiles of the analyzed meta solving strategies w.r.t.
accuracy resource consumption and response time demonstrate that it is possibleto optimize for different application scenarios.
we can easilyderive ideas for more involved combinations of solvers basedon the four patterns if horizontal scaling is cheap as suffi ciently many cpu cores are available taking the first returningsolver with filter conditions seems the best strategy and mightlead to a further improvement over e arliest trusted .i f less cpu cores are available adding more solvers to improvethe checking of unsatisfiable cores of c vcseqcores so that the results get closer to the ones obtained with c vcseqeva l may be the right strategy.
currently the timeouts for checkingunsatisfiable cores are a limit for this strategy.
moreover we were able to draw conclusions from performance data of individual solvers that guided our designdecisions.
since we did not actually implement the strategieswe simulated and did not simulate the strategies we imple mented we did not actually demonstrate that our analysis ofthe response time and resource consumption of meta solvingstrategies is accurate.
especially for the large group of bench mark instances that can be solved in fractions of a second forking of processes and inter process communication maylead to slower response times and higher resource consumptionthan estimated especially if many solvers are used in parallel.
threats to internal validity.
we identify two threats to internal validity of results obtained for the analyzed meta solving strategies seeding of smt solvers may impact results and expected verdicts may be wrong.
smt solvers use heuristics that are traditionally seeded.
z3 and cvc4 tend to be seeded with fix seeds unless they are altered by passing seeds explicitly.
therefore we havenot observed varying results originating from seeding in ourexperiments.
nevertheless running the same solver with dif ferent seeds might impact the performance.
as most problemsin the combined benchmark set have only few variables andthe run times for many problems are milliseconds we do notexpect this to have a significant impact in obtained results.
wedo not expect different random choices in these small sets ofvariables to change this.
naturally majority votes do not guarantee correctness and may lead to spurious results.
one could argue that majorityvotes should hence not be used for the computations of groundtruth labels.
following such an argument would not changethe reported results in a significant way in the presented data validated result are computed for .
of all benchmark instances.
majority votes are only used for the remaining2.
of instances and among these a significant fraction are unanimous.
on the other hand disagreement of solvers mayprovide guidance towards difficult features and bugs.
finally even validated verdicts can theoretically be spurious but wedeem this highly unlikely as models and unsatisfiable coreswere confirmed with independently developed tools.
we want to emphasize the importance of cross checking smt solver results and the method for the evaluation of metasolving strategies rather than establishing a single strategy.
theexperiments need to be repeated periodically to be valuable inthe long run.
a consequence is that our ground truth labelsmay be wrong if a bug in a solver leads to consistently votingfor the wrong answers.
due to the model and unsatisfiablecore validation applied along with the majority vote we donot expect this to be the case in a significant amount of casesin this data set.
threats to external validity results obtained in this study on the performance of individual meta solving strategies may not generalize well for several reasons.
first we evaluated the multi solver strategies and solver only on unicode theory benchmarks which is only a subset ofthe whole smt world.
then the study does not consider cloudsettings where horizontal scaling is achieved by splitting workacross the network layer.
we do not expect the earliest v erdict based strategies to perform comparably in such a setting dueto the short run times in most cases.
third the string theory 188solver field advances quickly and the measurements in this paper will be outdated in the future.
we report on a snapshotview on the state of implementations.
finally as shown intable i the benchmarks have slightly different profiles but arestill quite homogeneous and skip certain parts in terms ofoperators of the smt lib standard.
we tried to control forthis by using all benchmarks we could find in the literature.still the observations made on the used benchmarks set maynot extrapolate well to the complete smt lib unicode stringtheory.
summarizing we are confident that data driven design of meta solving strategies is possible and beneficial.
concreteresults depend on the benchmarks that are used for analysisand tuning as well as on the distribution of capabilities insolvers.
viii.
c onclusion in this paper we evaluated different smt meta solving strategies for string theory solvers in terms of performance accuracy and costs.
to this end we first collected benchmarksets used in the literature to evaluate the performance ofseven smt solvers on these benchmarks.
after collection weremoved duplicates form the benchmarks reducing the overallsize from to tasks.
these tasks are analyzedin more detail regarding their homogeneity in the benchmarksets.
we used the computed performance data to generate anexpected verdict for each task based on either a validatedsatisfiable model or a confirmed unsatisfiable core.
otherwise we use majority voting to define a expected result label.
the paper presents four integration patterns for smt metasolving strategies.
based on these patterns we defined fourdifferent meta solving strategies in addition to the vote strategyused to establish the expected result labels.
the evaluationdemonstrates that the earliest verdict strategies are only suit able in the smt domain on string problems if some kindof solver selection is performed upfront.
otherwise a earliestverdict strategy will return incorrect results compared to theestablished ground truth.
cheaper meta solving strategies thatcombine in this concrete example only cvc4 and seq with answer validation require less parallelization power of thecpu compared to the fastest solver approach and archivecomparable results.
we conclude that for the string theorydomain meta solving strategies are well suited for boostingthe capability of the smt decision layer in an analysis.
theinfluence of the smt solver choice should be mentioned inthe evaluation of an algorithm implementation more often inthe future.
future work should investigate the portability ofthe results to other smt domains.
r eferences l. de moura and n. bj rner z3 an efficient smt solver in international conference on tools and algorithms for the construction and analysis of systems.
springer pp.
.
c. barrett c. l. conway m. deters l. hadarean d. jovanovi c t. king a. reynolds and c. tinelli cvc4 in computer aided v erification g. gopalakrishnan and s. qadeer eds.
springer pp.
.
f. yu m. alkhalaf and t. bultan stranger an automata based string analysis tool for php in tools and algorithms for the construction and analysis of systems j. esparza and r. majumdar eds.
berlin heidelberg springer berlin heidelberg pp.
.
m. t. trinh d. h. chu and j. jaffar s3 a symbolic string solver for vulnerability detection in web applications in proceedings of the acm sigsac conference on computer and communications security .
acm pp.
.
a. s. christensen a. m ller and m. i. schwartzbach precise analysis of string expressions in proc.
10th international static analysis symposium sas ser.
lncs vol.
.
springer verlag june pp.
available from .
p. saxena d. akhawe s. hanna f. mao s. mccamant and d. song a symbolic execution framework for javascript in ieee symposium on security and privacy pp.
.
m. mues t. schallau and f. howar jaint a framework for userdefined dynamic taint analyses based on dynamic symbolic executionof java programs in integrated f ormal methods b. dongol and e. troubitsyna eds.
cham springer international publishing pp.
.
m. berzish v .
ganesh and y .
zheng z3str3 a string solver with theory aware heuristics pp.
.
n. bj rner n. tillmann and a. v oronkov path feasibility analysis for string manipulating programs in international conference on tools and algorithms for the construction and analysis of systems.
springer pp.
.
a. reynolds m. woo c. barrett d. brumley t. liang and c. tinelli scaling up dpll t string solvers using context dependent simplifi cation in international conference on computer aided v erification.
springer pp.
.
p. a. abdulla m. faouzi atig y .
chen b. p. diep l. hol k a. rezine and p. r ummer trau smt solver for string constraints in f ormal methods in computer aided design fmcad oct pp.
.
t. chen m. hague a. w. lin p. r ummer and z. wu decision procedures for path feasibility of string manipulating programs withcomplex operations proceedings of the acm on programming languages vol.
no.
popl pp.
.
t. bultan f. yu m. alkhalaf and a. aydin string analysis for software v erification and security.
springer .
g. redelinghuys w. visser and j. geldenhuys symbolic execution of programs with strings in proceedings of the south african institute for computer scientists and information technologists conference pp.
.
m. mues and f. howar jdart dynamic symbolic execution for java bytecode competition contribution in international conference on tools and algorithms for the construction and analysis of systems.springer pp.
.
a. shamakhi h. hojjat and p. r ummer towards string support in jayhorn competition contribution in international conference on tools and algorithms for the construction and analysis of systems j. f. groote and k. g. larsen eds.
cham springer internationalpublishing pp.
.
d. blotsky f. mora m. berzish y .
zheng i. kabir and v .
ganesh stringfuzz a fuzzer for string solvers in international conference on computer aided v erification.
springer pp.
.
j. scott f. mora and v .
ganesh banditfuzz a reinforcement learning based performance fuzzer for smt solvers in software v erification m. christakis n. polikarpova p. s. duggirala and p. schrammel eds.cham springer international publishing pp.
.
d. winterer c. zhang and z. su on the unusual effectiveness of type aware operator mutations for testing smt solvers proc.
acm program.
lang.
vol.
no.
oopsla nov. .
.
available validating smt solvers via semantic fusion in proceedings of the 41st acm sigplan conference on programming language designand implementation pp.
.
f. besson p. e. cornilleau and d. pichardie modular smt proofs for fast reflexive checking inside coq in certified programs and proofs j. p. jouannaud and z. shao eds.
berlin heidelberg springer berlinheidelberg pp.
.
d. beyer m. dangl d. dietsch and m. heizmann correctness witnesses exchanging verification results between verifiers in pro189ceedings of the 24th acm sigsoft international symposium on f oundations of software engineering pp.
.
d. beyer m. dangl t. lemberger and m. tautschnig tests from witnesses in international conference on tests and proofs.
springer pp.
.
l. kotthoff algorithm selection for combinatorial search problems a survey in data mining and constraint programming.
springer pp.
.
b. steffen t. margaria and v .
braun the electronic tool integration platform concepts and design international journal on software tools for technology transfer vol.
no.
pp.
.
m. kulczynski f. manea d. nowotka and d. b. poulsen the power of string solving simplicity of comparison in proceedings of the ieee acm 1st international conference on automation of software test pp.
.
m. mues and f. howar reproduction package for the ase aec committee jul.
.
.
available r. h ahnle and m. huisman deductive software v erification from penand paper proofs to industrial tools.
cham springer internationalpublishing pp.
.
f. damiani r. h ahnle and m. lienhardt abstraction refinement for the analysis of software product lines in tests and proofs s. gabmeyer and e. b. johnsen eds.
cham springer international publishing pp.
.
c. m. wintersteiger y .
hamadi and l. de moura a concurrent portfolio approach to smt solving in international conference on computer aided v erification.
springer pp.
.
e. g. karpenkov k. friedberger and d. beyer javasmt a unified interface for smt solvers in java in working conference on v erified software theories tools and experiments.
springer pp.
.
f. howar f. jabbour and m. mues jconstraints a library for working with logic expressions in java in models mindsets meta the what the how and the why not?
springer pp.
.
d. r. cok jsmtlib tutorial validation and adapter tools for smt libv2 innasa f ormal methods symposium.
springer pp.
.
m. gario and a. micheli pysmt a solver agnostic library for fast prototyping of smt based algorithms in smt workshop vol.
.
h. riener f. haedicke s. frehse m. soeken d. gro e r. drechsler and g. fey metasmt focus on your application and not on solverintegration international journal on software tools for technology transfer vol.
no.
pp.
.
j. scott a. niemetz m. preiner s. nejati and v .
ganesh machsmt a machine learning based algorithm selector for smt solvers in tools and algorithms for the construction and analysis of systems j .f .groote and k. g. larsen eds.
cham springer international publishing pp.
.
h. palikareva and c. cadar multi solver support in symbolic execution in computer aided v erification n. sharygina and h. veith eds.
berlin heidelberg springer berlin heidelberg pp.
.
a. aydin l. bang and t. bultan automata based model counting for string constraints in international conference on computer aided v erification.
springer pp.
.
l. hol k p. jank u a. w. lin p. r ummer and t. v ojnar string constraints with concatenation and transducers solved efficiently proc.
acm program.
lang.
vol.
no.
popl dec. .
.
available p. a. abdulla m. f. atig y .
f. chen l. hol k a. rezine p. r ummer and j. stenman norn an smt solver for string constraints in international conference on computer aided v erification.
springer pp.
.
y .
zheng x. zhang and v .
ganesh z3 str a z3 based string solver for web application analysis in proceedings of the 9th joint meeting on f oundations of software engineering pp.
.
y .
zheng v .
ganesh s. subramanian o. tripp m. berzish j. dolby and x. zhang z3str2 an efficient solver for strings regular ex pressions and length constraints f ormal methods in system design vol.
no.
pp.
.
p. r ummer a constraint sequent calculus for first order logic with linear integer arithmetic in proceedings 15th international conference on logic for programming artificial intelligence and reasoning ser.lncs vol.
.
springer pp.
.
m. t. trinh d. h. chu and j. jaffar progressive reasoning over recursively defined strings in international conference on computer aided v erification.
springer pp.
.
m. mues and f. howar jdart portfolio solving breadth first search and smt lib strings competition contribution tools and algorithms for the construction and analysis of systems vol.
p. .
t. tateishi m. pistoia and o. tripp path and index sensitive string analysis based on monadic second order logic acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
j. d. day t. ehlers m. kulczynski f. manea d. nowotka and d. b. poulsen on solving word equations using sat in international conference on reachability problems.
springer pp.
.
p. saxena d. akhawe s. hanna f. mao s. mccamant and d. song a symbolic execution framework for javascript in ieee symposium on security and privacy.
ieee pp.
.
t. brennan n. tsiskaridze n. rosner a. aydin and t. bultan constraint normalization and parameterized caching for quantitativeprogram analysis in proceedings of the 11th joint meeting on f oundations of software engineering pp.
.
j. thom e l. k. shar d. bianculli and l. briand benchmark suite for an integrated approach for effective injection vulnerabilityanalysis of web applications through security slicing and hybridconstraint solving .
.
available j. thom e l. k. shar d. bianculli and l. briand an integrated approach for effective injection vulnerability analysis of web appli cations through security slicing and hybrid constraint solving ieee transactions on software engineering vol.
no.
pp.
.
s. kausler and e. sherman evaluation of string constraint solvers in the context of symbolic execution in proceedings of the 29th acm ieee international conference on automated software engineering pp.
.
k. luckow m. dimja sevi c d. giannakopoulou f. howar m. isberner t. kahsai z. rakamari c and v .
raman jdart a dynamic symbolic analysis framework in international conference on tools and algorithms for the construction and analysis of systems.
springer pp.
.
d. beyer software verification 10th comparative evaluation svcomp tools and algorithms for the construction and analysis of systems vol.
p. .
d. beyer s. l owe and p. wendler reliable benchmarking requirements and solutions international journal on software tools for technology transfer vol.
no.
pp.
.