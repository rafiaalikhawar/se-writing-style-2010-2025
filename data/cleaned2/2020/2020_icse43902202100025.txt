siri write the next method fengcai wen emad aghajani csaba nagy michele lanza gabriele bavota software institute usi universit a della svizzera italiana switzerland abstract code completion is one of the killer features of integrated development environments ides and researchers have proposed different methods to improve its accuracy.
while these techniques are valuable to speed up code writing they are limited to recommendations related to the next few tokens a developer is likely to type given the current context.
in the best case they can recommend a few apis that a developer is likely to use next.
we present fears a novel retrieval based approach that given the current code a developer is writing in the ide can recommend the next complete method i.e.
signature and method body that the developer is likely to implement.
to do this fears exploits implementation patterns i.e.
groups of methods usually implemented within the same task learned by mining thousands of open source projects.
we instantiated our approach to the specific context of android apps.
a large scale empirical evaluation we performed across more than 20k apps shows encouraging preliminary results but also highlights future challenges to overcome.
index terms code recommender empirical software engineering mining software repositories i. i ntroduction developing high quality software while reducing time tomarket are two classical contrasting objectives in the software industry.
this translates into the need for increasing the productivity of software developers by lowering their learning curves when dealing with unfamiliar code and by maximizing the quality of the code they write.
in response to these needs researchers have proposed recommender systems for software engineering defined by robillard et al.
as applications that provide information items valuable for a software engineering task in a given context .
some recommender systems pursue a long lasting dream of software engineering research the semi automatic generation of source code.
the goal of these tools is speeding up the implementation of new code.
code completion techniques are nowadays one of the killer features of ides .
researchers have proposed different methods to improve code completion accuracy and more in general its capabilities .
while these approaches are certainly valuable to speed up code writing they are limited to recommendations related to the next few tokens a developer is likely to type given the current context.
in the best case they can recommend a sequence of apis that a developer is likely to use next .
we aim at reaching the next level in supporting developers during the writing of new code.
we present fears an approach and an ide plugin which monitors the code written by android developers in the ide and is able to recommend the complete code of the next method i.e.
signature and method body they are likely to implement based on method s they already have implemented.fears relies on a set of implementation patterns that we built by mining open source android apps available on github.
to give a concrete example the code snippet in fig.
implements an options menu in an android app.
to perform such a task tutorials recommend as first step to inflate the menu in the oncreateoptionsmenu ... method and then to handle the item selection in the onoptionsitemselected ... method.
assuming the existence of this implementation pattern in several apps fears can learn it and recommend the implementation of onoptionsitemselected ... once oncreateoptionsmenu ... has been implemented by the developer.
fig.
.
an implementation pattern in android we analyzed commits performed during the history of the subject apps to identify new methods that are implemented within the same commit.
this results for each analyzed commit ck in a setmk fm1 m2 m ngof nnew methods created in ck.
by extracting this information for thousands of commits we can identify implementation patterns repeatedly followed by android developers e.g.
the implementation of m1could imply the implementation of m2 m n. we refer to m1as the left hand side lhs of the pattern and to m2 m nas the right hand side rhs .
the identification of these implementation patterns is far from trivial.
indeed two commits ckandcjperformed in two different repositories may implement different sets of new methods e.g.
mk fm1 m2gandmj fm3 m4g that however represent the same implementation pattern i.e.
m1 m3andm2 m4 .
recognizing this situation is necessary to identify groups of methods that are repeatedly implemented together in different commits apps and not just by chance in a single few commit s .
ieee acm 43rd international conference on software engineering icse .
ieee fears identifies clusters of methods likely to implement the same feature in the overall set of mined added methods.
going back to the previous example this means that m1and m3are assigned to the same cluster c1 andm2andm4to c2.
this results in the flattening of ckandcjto the same implementation pattern i.e.
mk mj fc1 c2g .
once this processing is done for all mined commits fears applies association rule discovery on all commits thus creating the set of implementation patterns it relies on.
when monitoring the code written by a developer in the ide fears identifies newly written methods and assigns if possible each of them to one of the clusters created in the previous step.
then it checks if an implementation pattern having one or more of the newly implemented methods as lhs is available and in case a pattern is found the corresponding rhs is triggered as a recommendation to the developer.
we evaluated fears in a study in which we simulated its usage in the change history of the same apps we used to extract the implementation patterns.
we used the first of the apps histories to extract the implementation patterns the subsequent to tune the fears s parameters and the last to assess its performance i.e.
test set .
for each commitcin the test set we simulated the scenario in which a developer implemented a subset sof the new methods added incand used fears to generate recommendations using s as lhs.
then in case a recommendation is generated we check if the rhs corresponds to one of the methods actually implemented in cand not part of s. the achieved results show the feasibility of our approach but also its strong limitations.
indeed while fears is able to generate meaningful recommendations for thousands of methods several of them concern small methods that are not expected to substantially boost the developer s productivity.
ii.
f ears fig.
depicts the inner working of fears.
android apps miner clusters1history miner 4methodsclustering android studio plugin fears web service2 21k appsadded methodsb0bf3d9owner app getgps drive added methodsb0bf3d9owner app getgps drive 842k commitsassociation rule mining lhs rhs c1 c2 c3c8 c9c10c12 c1 c3 c4c7c1 c3 association rulesasia clone detectorarules r package 8javaparser fig.
.
the fears pipeline the black boxes represent components that we developed the grey boxes depict external tools we reused and or adapted.all components except the android studio ide plugin reside on a central server providing an access point via the fears web service.
steps are executed offline and only once.
step is executed every time the developer completes the implementation of a new method.
a. mining android apps the android apps miner identifies github repositories related to android apps.
their history is then analyzed to identify methods implemented within the same commit.
we use the github apis to search for repositories satisfying the following criteria they are written in java.
while android is transitioning to kotlin as the official language the majority of android apps is still written in java .
note that while we instantiated fears to the specific problem of recommending complete methods for java android apps all the steps in fig.
can be customized to any programming language.
they are android apps.
we ensure that the repository contains a build.gradle file with an explicit dependency towards the android sdks indicating the usage of the gradle build system the default choice in android studio.
they have a limited but non trivial change history.
we excluded apps with less than commits since we are interested in identifying the new methods added by developers within the same commit.
also we excluded apps having more than commits since we do not want fears to learn coding patterns peculiar only to a few apps.
the android apps miner identified and cloned github repositories the set of apps that we use in this work available in our replication package .
the set can be expanded by re running the android apps miner.
b. identifying methods added in commits the set of cloned repositories is provided as input to the history miner step in fig.
.
this component extracts the list of commits performed in all branches of each repository by using the git log topo order command.
this command allows analyzing all branches of a project without intermixing their history avoiding unwanted effects of merge commits.
history miner uses javaparser to extract from the java files added or modified in each commit the ast nodes which represent the callable declarations i.e.
methods and constructors .
in particular we are interested in the callable declarations added in each commit.
commits not implementing at least two new methods and or constructors are excluded at this stage since we want fears to learn implementation patterns in the form of fmg mi wheremrepresents a set of one or more methods and mia method that fears can recommend based on the fact that the developer implemented m. thus assuming mto be a singleton at least two new methods must be implemented in a commit i.e.
the one inm andmi to make it useful for learning.
we excluded commits adding more than new methods of the total number of commits since these are likely to be tangled commits not representative of any specific implementation pattern .
139overall we processed commits of which were useful for building fears i.e.
those adding at least two new methods and no more than ten .
these commits are provided as input to the module in charge of the methods clustering step in fig.
.
c. clustering similar methods to identify recurring implementation patterns in the considered commits fears applies clustering to group methods added in different commits possibly from different systems that implement equivalent or very similar functionalities.
two commitsckandcjperformed in two different repositories may implement different sets of new methods e.g.
mk fm1 m2gandmj fm3 m4g that represent the same implementation pattern i.e.
m1 m3andm2 m4 .
fears can identify through association rule discovery that these sets of methods represent a repetitive implementation pattern.
fears builds a weighted undirected graph.
each method added in any of the commits is considered as a node.
the weight on the edges connecting each pair of nodes represents the similarity between the two corresponding methods.
to assess similarity we use the publicly available asia clone detector since it i is designed to capture the similarity between two android methods and ii returns as output an easily interpretable value from min similarity to max .
we customized the asia similarity algorithm in two ways.
first in the original implementation all terms in the two methods to compare are lowercased before computing their textual similarity.
this is suboptimal in fears since high precision in the identification of related methods is fundamental.
experiments revealed that the similarity of methods is artificially boosted by lowercase transformation given two methodsm1andm2 it happens that a term appearing in the name ofm1 e.g.
date is matched with the type of an object appearing in m2 e.g.
date .
by not transforming date to lowercase the presence of these two terms does not influence positively the similarity between m1andm2.
second while asia uses tf idf term frequency inverse document frequency as a weighting schema for the terms during the textual similarity computation we only employ term frequency because we noticed that a single term appearing in both methods and having a very high idf i.e.
being very rare in the corpus can result in a high similarity between the two methods even if they implement completely different features.
this is especially true in small methods due to the low number of terms present in them and the strong impact a single shared term can have on their similarity.
the graph we built contains nodes.
we prune all edges with a weight below a threshold will be tuned in our evaluation .
this creates a set of disconnected subgraphs each one representing a cluster of methods implementing strongly related functionalities.
within each subgraph i.e.
cluster we identify the cluster centroid the method with the highest number of edges which serves as representative for that cluster.
the centroid is used later on by the fears web service when interacting with the ide plugin.d.
association rule mining this module takes as input the list of commits generated by thehistory miner and the clusters output of the previous step step in fig.
and creates a text file reporting in each line a set of methods added in the same commit and in the same file using the cluster they belong to.
for example assuming a commit adding three methods m1 m2 andm3to a filefi and those methods being assigned to clusters c12 c8 and c71 respectively a line c12 c8 c71will be added to the file.
we decided to split methods added in the same commit but in different files to extract more cohesive association rules and to avoid learning recommendations that span different files i.e.
the developer is working on fiand fears recommends a method to add in fj .
fears analyzes the created file using association rule mining to identify implementation patterns relying on therarules package.
we use the first of the apps commits to extract the association rules for tuning the parameters of fears and to evaluate it.
the output is a set of association rules in the form flhsg rhs where the lhs can be composed by one or more methods while the rhs always has a single method.
this means that fears can only recommend the next method to implement given the one s already implemented by the developer.
there are three parameters that we tune in our evaluation minimum support sup confidence for the mined rules con and maximum size of the lhs max lhs .
the support sup indicates how frequently a rule is observed in the dataset and in our case represents the percentage of analyzed commits that contains the specific rule.
the confidence con assesses how often a given rule is actually true in the dataset.
given a rule flhsg rhs it is computed as the number of commits implementing in the same file all methods in the lhs and rhs divided by the number of commits implementing the lhs in the same file with or without the rhs .
finally we also tune the maximum size of the lhs max lhs .
e. the fears android studio plugin fig.
shows the fears android studio ide plugin.
the plugin interacts with the server through the web service step in fig.
.
the developer can start and stop fears through simple play signand stopicons in the ide toolbar.
by clicking play sign fears starts monitoring the code written by the developer and identifies when a new method is added.
when this happens the text of the new methods added by the developer since she pressed the start button is sent to the web service.
the web service identifies for each received method the cluster it belongs to.
our customized version of the asia clone detector computes the similarity between each received method and each centroid representative of the computed clusters.
the similarity sfor the most similar centroid is compared against a threshold the fifth and last fears parameter to tune if s the method is assigned to the cluster represented by the most similar centroid otherwise no match is found and the method is discarded.
4fig.
.
the fears android studio plugin all combinations of received methods that are matched with a centroid are used to generate different lhss.
for example if three methods added by the developer are matched to clusters c1 c2 andc3 we generate possible lhss fc1g fc2g fc3g fc1 c2g fc1 c3g fc2 c3g and fc1 c2 c3g.
fears checks if any of these lhss is equal to the lhs of one of the association rules previously extracted.
in case of a match a recommendation is generated.
in the reported example if fc1 c2gis matched in a rule fc1 c2g c9 then the centroid of cluster c9is returned by the web service to the plugin as a recommendation.
for the same lhs several different rhss may be recommended.
the matching of the lhs of two rules can lead to redundant recommendations.
in the example let us assume that two rules are matched one withfc1gand one with fc1 c2gas lhs and that both of them havec9as rhs.
in this case the web service returns the centroid of c9reporting that it is recommended based on the lhs belonging to the rule having the highest confidence.
the generated recommendations are shown in the ide as depicted in the bottom part of fig.
.
shows the signatures of the methods implemented by the developer that are part of the lhs of the association rule used to recommend the method shown in i.e.
rhs of the rule .
in case several recommendations share the same lhs the plugin displays them as one recommendation allowing developers to switch between different rhss using the arrow buttons above .
the buttons at the bottom of the code snippet allow to i provide a feedback reporting if the recommendation was useful ii copy the snippet and iii delete the recommendation.
the feedback in our current implementation is stored but not used.
we plan to use it in future to adjust the confidence of the recommendations.
if the developer decides to copy the snippet a comment documenting the github repository from when the snippet has been taken is added to the code so that the developer can check its reusability from a legal perspective.the slider at the top of the plugin gui1 allows the developer to customize the chattiness of the plugin on three different levels.
low medium and high sensitivity are three different fears configurations that resulted from the calibration of its parameters presented in section iv a. by moving the slider towards low fears becomes more strict and generates fewer but higher quality recommendations while the opposite holds for high.
iii.
s tudy design the goal of this study is to assess the performance of fears when used to recommend the next method to implement given one or more already implemented methods as input.
it thus addresses the following research question rq what is the accuracy of fears in recommending complete methods in the context of android apps?
a. context selection and data collection fig.
overviews the steps in our experimental design.
we exploit the dataset of android apps as the context of our study.
then we split such a dataset into three blocks namely training validation and test.
fig.
depicts how we create and use these three sets in our study.
cicjtraining val test ck lhs rhs c1 c2 c4 c5c2 c6c3c6 c7 commit i j kadded c1 c2 c3c3 c4 c5c1 c6recomm.
10correct 00cover.
met h. fig.
.
data splitting and processing the black arrows represent the change history of the apps considered in our study.
note that the history of the apps is not aligned meaning that not all the apps exist in the same time period.
the vertical dashed lines show how we divide the change history of the apps.
we use the first to extract the association rules used by fears to generate recommendations.
we refer to this subset of the history as the training set.
the subsequent is used to tune the parameters of fears to identify the best configurations i.e.
validation set which are used to generate recommendations on the test set i.e.
the last with the goal of assessing the performance of fears.
one important clarification we do not use the first of each repository as the training set due to the misalignment of the mined change histories.
instead given dsthe date of the oldest commit present in all analyzed apps and dethe date of the most recent commit we take the first of the time interval going from dstodeas training set.
as shown in fig.
this may result in some apps exclusively contributing to the training set or to the validation test sets .
141step collecting appsstep splitting the history in three blocks training validation test best configurations high sensitivity medium sensitivity low sensitivity white boxes represent actions.
grey boxes represent outputs.step running the best configurations on the commits in the test setstep methods clustering and association rule extraction on the training set association rules step tuning of the parameters on the validation settraining set validation set test set evaluation metricsfig.
.
study design however such a design is needed to avoid using data from the future when generating recommendations for the validation and test set and thus to simulate a real usage scenario for fears.
indeed by selecting the first of the history of each app to learn the association rules it could happen that a given appxhas the last commit of training set made on date dx while for appythe latest commit of its entire history comes on date dy withdy dx i.e.
dy is older than dx .
this would mean that association rules learned ondxwill be applied to generate recommendations for commits performed on date dy that will be part of the test set thus using data from the future to learn how to trigger recommendations something that cannot happen in a real usage scenario.
table i fears parameters tuning options parameter experimented values con .
.
.
.
.
.
sup .00e .80e .80e .28e .68e .
.
.
.
max lhs once the association rules are learned we assess the performance of fears on the validation set with different parameter configurations table i for a total of configurations.
given the number of mined commits the minimum value of supwe experiment i.e.
.00e ensures that an association rule is learned from at least commits to be considered valid.
in all combinations of parameters we used meaning that the minimum similarity needed to cluster two methods together i.e.
is also the minimum similarity used when generating recommendations to assign a newly implemented methodmto a cluster c i.e.
see section ii e .
as shown in fig.
to identify the best configuration s we use of the apps change history validation set .for each commit in the validation set ci cj andckin fig.
we match all newly added methods to the clusters that have been defined during the association rules extraction from the training set using the same similarity threshold as for the clusters definition .
this means that we simulated the scenario in which each of the added methods is written by the developer in the ide and the fears plugin checks if the added method can be matched with any of the existing clusters i.e.
if its similarity with one of the centroids is higher than .
if a method is not matched no further action is taken while all matched methods are assigned to the corresponding cluster.
fig.
represents our running example in which the grey box on the left shows the association rules learned on the training set and the black box at the bottom shows how performance is computed for each commit in the evaluation set.
in the case of commit i three added methods have been matched to clusters c1 c2 andc3.
then we compute all possible combinations of the matched clusters involving all but one of them.
in the case of commit i this means all possible combinations having length lower than three fc1g fc2g fc3g fc1 c2g fc1 c3g fc2 c3g.
then we check if any of those combinations match the lhs of one of the rules learned from the training set.
in fig.
the pair fc1 c2g matches the rule fc1 c2g c3.
this means that assumingc1andc2to be written before c3 more discussion on this assumption in our threats to validity fears would be able in a real usage scenario to successfully recommend the next method to implement i.e.
thec3centroid .
thus in fig.
we count the number of recommendations generated by fears column recomm.
the number of correct recommendations and the number of methods added in commit ithat fears would have potentially been able to recommend out of column cover.
meth.
concerning commit j it would match the rule fc4 c5g c6generating one wrong recommendation see fig.
.
no recommendation would be triggered for commit k since no matched rules are found.
142there are two special cases that must be handled first when multiple association rules have the same rhs e.g.
assume fc1g c3andfc2g c3are both available in the set of learned association rules .
in this case both rules could be applied for example in the context of commitiin fig.
.
however considering both rules as successful would inflate the performance of fears since in a real usage scenario if fc1g c3is applied fc2g c3cannot be applied since c3already exists.
second in case of a circular dependency between the lhs and the rhs of two rules e.g.
r1 fc1g c3and r2 fc2 c3g c1.
the lhs of r1matches the rhs of r2 and the rhs of r1is contained in the lhs of r2.
in theory both rules could be applied to commit iin fig.
but the application of one rule would exclude the other in a real usage scenario.
if we apply r1 it means that c1has been implemented by the developer and it does not make sense to recommend it with r2.
similarly if r2is applied this means thatc3already exists making r1useless.
in both cases we select the rule with the highest confidence.
b. data analysis we assess the performance of each experimented configuration by computing the following metrics recall recall comm corcomm v wherecomm coris the number of commits for which fears generated at least one correct recommendation and comm vis the set of commits mined in the validation set.
a correct recommendation is not necessarily an exact match to the actual implemented code but the similarity has to be above a certain threshold which is consistent with the predefined clusters.
recall indicates in how many commits fears could be potentially useful for developers.
precision precision comm corcomm rec wherecomm recis the number of commits for which fears generated at least one recommendation correct or wrong .
cov commits covcommits comm rec comm v. this metric indicates the percentage of commits from the validation set that could have triggered fears to generate at least one recommendation correct or wrong for developers.
cov meth covmeth meth cor meth comm v wheremeth coris the number of methods successfully recommended by fears andmeth comm vis the total number of methods added in comm v. this coverage metric indicates the percentage of methods added in all commits from the validation set that could have been automatically generated by fears.
recom recom is the number of recommendations generated by fears in a commit for which it was triggered.
we report both the mean and the median values.
dist tokens disttokens is the distance in number of tokens that must be modified added or deleted by a developer when they receive a correct recommendation from fears which does not imply an exact match with the code actually implemented by the developer.
thus we assess the effort needed by developers to adapt the received recommendation to their codebase an example computation of such a metric is shown in fig.
.
actual implementation tokens private static void toggle if m visible hide else show recommendation tokens private void toggle if mvisible hide else show disttokens deleted updated added disttokens fig.
.
an example of disttokens calculation iv.
r esults discussion a. fears parameters tuning fig.
shows the results of the parameters tuning performed on the validation set.
each of the four graphs reports on the x axis the values experimented for a specific parameter from left to right minimum confidence con minimum support sup minimum similarity to cluster two methods and maximum size of the lhs max lhs .
the y axis reports the covcommits left and the precision right achieved with red dots indicating covcommits values and black dots precision values.
we decided to use these two metrics over the others for the parameters tuning since we wanted to contrast the talkativeness of our tool i.e.
in how many commits it generates a recommendation against the precision of the generated recommendations.
to better understand what the black and red dots represent consider the con graph when its value is set to .
.
the dots plotted in correspondence of this value represent the performance achieved when fixing con and varying all other parameters.
one first observation is related to the range of performance achieved by different configurations the covcommits varies from .
to .
while the precision from .
to .
.
while the values of covcommits may look low it is important to note that the validation set includes commits.
the trends observed for the four parameters indicate that con has the strongest influence on performance.
when the minimum confidence needed to trigger a recommendation grows as expected the precision linearly increases with a corresponding linear decrease of recall left part of fig.
.
setting conlower than .
does not ensure acceptable precision.
concerning sup increasing its minimum value does not substantially increase precision while having a strong negative effect oncovcommits .
low values of this parameter are preferable.
instead increasing the parameter results in a notable increase in precision especially when moving from .
to .
.
.
in this case .
seems to be a good compromise also considering the minor loss of covcommits as compared to lower values.
finally the max lhs does not play a big role in the performance of fears.
as the output of this tuning process we identified three configurations that we linked to the sensitivity bar in our ide plugin and that are shown in the gray boxes at the right of fig.
.
tuning of the con parameter values for minimum confidence con recall .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
precision tuning of the sup parameter values for minimum support sup recall .0e .8e .8e .3e .7e .
.
.
.
.
.
.
.
.
.
.
.
.
.
precision tuning of the lambda parameter values for minimum simiarity lambda recall .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
precision tuning of the max lhs parameter values for maximum lhs size max lhs recall .
.
.
.
.
.
.
.
.
.
.
.
.
.
precisioncov commit precisioncon .
sup .0e .
maxlhs precision .
cov commit .
correct recommendations 355high sensitivity con .
sup .0e .
maxlhs precision .
cov commit .
correct recommendations 092medium sensitivity con .
sup .0e .
maxlhs precision .
cov commit .
correct recommendations 801low sensitivityselected configurationscov commit cov commit cov commit cov commitfig.
.
tuning of fears s parameters these configurations have been picked using the following process.
we started from the assumption that a precision level below .
i.e.
one out of two generated recommendations is correct is not acceptable.
then we picked as a high sensitivity configuration the one ensuring a precision of at least .
and having the highest covcommits .
this configuration is able to generate correct recommendations in the validation set with a precision of .
then we increase the minimum acceptable precision by identifying the configuration ensuring at least a precision with the maximum covcommits .
this resulted in the medium sensitivity configuration that can successfully recommend useful methods in cases with a precision of .
finally a further increase of the precision level to at least led to the identification of the low sensitivity configuration that can recommend correct methods with a precision of .
these three configurations are the ones we experiment with.
b. quantitative results table ii reports the results achieved by the three fears s configurations on the test set.
the top part of the table reports the raw data used to compute the performance metrics in the bottom part of the table.
in the top part while commits w. corr.
recomm.
indicates the number of commits with at least one correct recommendation corr.
recomm.
represents the number of correctly recommended methods possibly more than one per commit.
the results achieved by the three configurations are in line with what we observed on the validation set precision goes from .
high sensitivity to .
low sensitivity with recall moves in an inverse direction decreasing from .
high sensitivity to .
low sensitivity .table ii performance when considering all methods high medium low sensit.
sensit.
sensit.
commits added methods commits w. recomm.
commits w. corr.
recomm.
recommendations corr.
recomm.
recall .
.
.
precision .
.
.
coverage commits .
.
.
coverage meth .
.
.
recom median recom mean .
.
.
distance tokens q1 q2 q3 distance tokens mean .
.
.
distance tokens q1 q2 q3 distance tokens mean the recall values while low still correspond to thousands of methods correctly recommended.
as we learned while performing the qualitative analysis in section iv c a correct recommendation does not imply a useful recommendation.
we noticed that many of the correct recommendations are due to small methods e.g.
a getter method triggers the implementation of the corresponding setter and decided to re compute the performance of fears only considering recommended methods with at least four lines of code including signature but excluding annotations and the closing brace .
to correctly compute recall this also required us to exclude from our analysis the commits in which a successful recommendation would not be possible at all due to the absence of newly implemented methods having at least four lines.
144table iii performance when excluding short methods high medium low sensit.
sensit.
sensit.
commits added methods commits w. recomm.
commits w. corr.
recomm.
recommendations corr.
recomm.
recall .
.
.
precision .
.
.
coverage commits .
.
.
coverage meth .
.
.
recom median recom mean .
.
.
distance tokens q1 q2 q3 distance tokens mean .
.
.
distance tokens q1 q2 q3 distance tokens mean table iii reports the results achieved in this scenario.
the precision values are in line with before min .
max .
showing that the quality of the recommendations is not influenced by the length of the recommended methods.
instead we observed a drop of recall that does not go over with a number of correct recommendations ranging between low sensitivity and high sensitivity .
the number of recommendations generated by fears recom is usually very low median and mean in both scenarios .
this shows that fears does not generate many cases to inspect when triggered.
also the results of distance tokens indicate that developers need to modify only a few tokens to adapt the received recommendations to their code.
while these results show the potential of fears they highlight as in cases discussed for table ii that the recommended methods are short with a potential small benefit for developers.
our qualitative analysis will help in better assessing the value of these recommendations.
c. qualitative examples correct recommendations fig.
shows an example of a recommendation generated for the memento app for android wear .
repository inertia besi c memento androidwear commit 590449d lhs public static boolean isexternalstoragereadable string state environment.
getexternalstoragestate if environment.media mounted.
equals state environment.
media mounted read only.
equals state return true return false rhs public static boolean isexternalstoragewritable string state environment.
getexternalstoragestate if environment.media mounted.
equals state return true return false fig.
.
correct recommendation to the usage of external storage in android.suppose that the developer implements the isexternalstoragereadable method to check whether the external storage of the device is mounted in read only mode.
fears can pop up and recommend the isexternalstoragewritable method to check also if it is writable or not.
this rule had four matching instances in our test set from four different repositories.
fig.
shows an example of providing a custom back navigation for an android drawerlayout.
repository karyakita karyakita android commit e811795 lhs override public boolean onnavigationitemselected menuitem item int id item.getitemid if id r.id.nav camera else if id r.id.nav gallery else if id r.id.nav slideshow else if id r.id.nav manage drawerlayout drawer drawerlayout findviewbyid r.id.drawer layout drawer.closedrawer gravitycompat.
start return true rhs public void onbackpressed drawerlayout drawer drawerlayout findviewbyid r.id.drawer layout if drawer.isdraweropen gravitycompat.start drawer.closedrawer gravitycompat.start else super.onbackpressed fig.
.
correct recommendation to provide a custom back navigation for an android drawerlayout.
following the implementation of an onnavigationitemselected ... method that uses a drawerlayout fears recommends a proper implementation for theonbackpressed method.
interestingly in case of a missing implementation the drawerlayout might not close properly as it is discussed in a stack overflow question .
we found matching instances for this rule in different repositories.
fig.
shows an example recommendation for the creation of a google map object from the google maps sdk.
repository p hilosophers travelguide commit f690635 lhs override protected void oncreate bundle savedinstancestate super.oncreate savedinstancestate setcontentview r.layout.activity maps supportmapfragment mapfragment supportmapfragment getsupportfragmentmanager .
findfragmentbyid r.id.map mapfragment.getmapasync this rhs override public void onmapready googlemap googlemap mmap googlemap latlng sydney new latlng mmap.addmarker new markeroptions .
position sydney .
title marker in sydney mmap.movecamera cameraupdatefactory.
newlatlng sydney fig.
.
correct recommendation for the creation of a googlemap instance from the google maps sdk for android.
we found matches for this rule in repositories.
fears matches an oncreate ... method in which an activity creates a supportmapfragment from the sdk.
next it recommends an initial implementation for theonmapready ... method that shows how to add a marker to the map.
we found various implementations having a different initial marker position e.g.
london sydney .
unmatched implementation patterns we present fears s recommendations that have been triggered during the evaluation process i.e.
their lhs has been matched in the test commits but that have never been successful i.e.
the rhs has not been matched .
fig.
shows an example of recommendation generated for the artissans android app .
lhs private boolean isvalidemail string email boolean isgoodemail email !
null patterns.email address.
matcher email .matches if !isgoodemail memailedittext.seterror please enter a valid email address return is goodemail rhs private boolean isvalidpassword string password string confirmpassword if password.length mpasswordedittext.seterror please create a password containing at least characters return false else if !password.equals confirmpassword mpasswordedittext.seterror passwords do not match return false return true fig.
.
unmatched recommendation for user credential validation in sign up activity.
suppose that the developer implements the isvalidemail method to check whether the email address provided when creating an new account is valid.
fears recommends the isvalidpassword method to check in the same scenario if the provided password confirm password fields are valid i.e.
they are composed by at least six characters and they match each other .
this rule had been triggered twice without finding a match for the rhs thus being classified as an incorrect recommendation.
however when we looked into the two commits in which this recommendation was triggered we found that both of them actually implemented an isvalidpassword method that however only validated the password based on its length do not making the recommended method and the implemented one similar enough to be counted as a correct recommendation.
this example is representative of others we found.
lhs private userfilter requestalllistadapter adapter list request originallist super this.adapter adapter this.originallist new linkedlist originallist this.filteredlist new arraylist rhs override protected void publishresults charsequence constraint filterresults results adapter.filteredlist.clear adapter.filteredlist.addall arraylist list result.values adapter.filtered true adapter.notifydatasetchanged fig.
.
unmatched recommendation for creating custom filter for filterable adapter in android.
for example fig.
relates to the creation of a custom filter applied to a recyclerview.adapter in android.
the class filter is used in android to constrain data according to a specified pattern.following the implementation of a userfilter constructor fears recommends a proper implementation of the overridden publishresults method from the filter class that as explained in the android documentation is invoked in the ui thread to publish the filtering results in the user interface.
again this recommendation was not matched and considered wrong during our study but also in this case looking into the test commit subject of the recommendation we found that a similar overridden publishresults method was implemented as well following a custom filter constructor.
unfortunately also in this case the similarity between the rhs of the rule and the implemented publishresults was not high enough to identify the recommendation as useful.
these cases show that our experimental design while useful to provide a first indication about the quality of the recommendations triggered by fears has imprecisions in assessing fears s performance.
as previously said only complementing this mining based study with experiments with developers can help in better assessing fears s usefulness.
v. t hreats to validity construct validity.
in our experimental design we assumed that if a commit added three methods belonging to clusters c1 c2 andc3and fears has an association rule fc1g c3 fears would have been useful in that commit to recommend c3to the developer.
however we cannot know whether c3 was written before c1 thus making fears s recommendation useless in practice.
such a threat can only be addressed by i performing a user study in which developers code live using fears or ii recording ide interaction data of programming sessions.
while this is part of our future work we preferred as first evaluation for fears something that can be large scale and fully automated before moving to more costly studies requiring human involvement.
in the design of our study we only consider coding activities from one single commit might perform an implementation task while ignoring those cases in which a given task can be separated into several commits.
actually we considered the idea of using close commits as a single data point but we found out that it is hard to define a proper criterion for the selection of multiple commits and it might be risky for the cohesiveness of the task.
another threat is related to the criterion we used to identify a generated recommendation as correct.
given a commit c in whichmiandmjare added we assume that a recommendationck csis correct if miis matched to an existing clusterckandmjis matched to an existing cluster cs or vice versa i.e.
mitocsandmjtock .
this implies an assumption meaning that the assignment of methods to cluster is correct or that in other words when a method is assigned to a cluster the method actually implements functionalities related to those of the cluster.
to partially address this threat two of the authors manually analyzed a set of methods assigned by fears to a specific cluster with the goal of verifying whether the assigned cluster actually implements the same feature of the method.
146after solving conflicts arisen in of cases they reported an accuracy of .
thus we acknowledge possible imprecisions.
internal validity.
we tuned the fears s parameters on a set of commits not used for the learning of the association rules nor for assessment of fears s performance.
we experimented with combinations of parameters.
however it is possible that better performance can be achieved by considering other possible values.
thus from this point of view the reported performance is an underestimation.
we adopted a careful experimental design to avoid using data from the future when tuning and testing our approach.
external validity.
overall our study involves opensource android apps.
the main issue is related to the fact that all used apps are open source and might not be representative of commercial apps.
also while fears is general enough to be adapted to other contexts e.g.
java programming in general we decided to focus on a more narrow scenario at least for this first work.
vi.
r elated work fears is one of the many recommender systems proposed in the software engineering literature.
the latter have been proposed to support many different tasks such as the recommendation of formal and informal documentation see e.g.
the automatic generation of code for different purposes e.g.
or the recommendation of relevant code examples discussions for a task at hand e.g.
.
we focus our discussion on the most related works and in particular on those dealing with code completion techniques and code search engines.
a. code completion techniques basic code completion features of ides often rely on the static type system of a programming language and do not consider the actual code context.
suggestions are usually sorted e.g.
in alphabetical order.
as a result relevant recommendations are not always easy to identify.
an alternative approach was presented by bruch et al.
.
their intelligent code completion system filters out candidates from the list of tokens recommended by the ide that are not relevant to the current working context and ranks candidates based on how relevant to the context they are.
another context sensitive approach was developed by nguyen et al.
.
their grapacc method uses graphs to model api usage patterns where nodes represent actions e.g.
method calls and control points e.g.
while and edges represent control and data flow dependencies between nodes.
context information such as the relation between api elements and other code elements is considered for ranking the most fitted api usage patterns.
statistical language models have also been used for code completion.
in their seminal work on the naturalness of software hindle et al.
developed a code completion engine for java based on an n gram language model .
their work has been extended by nguyen et al.
and tu et al.
.a language model approach was implemented by raychev et al.
too .
they extract sequences of method calls from a large codebase to train a model which they use to support the autocompletion of method calls achieving an accuracy of when considering the top three results.
method call completion was also explored by asaduzzaman et al.
.
their approach called cscc relies on a database of method call usage contexts collected from open source projects and applies a hash function to find relevant recommendations.
from another perspective robbes and lanza proposed to improve code completion by focusing on the recent changes implemented by the developer .
popular ides have recognized the importance of supporting context sensitive recommendations.
for example intellij idea has a feature called smart completion to filter and show suggestions applicable to the current context.
netbeans has a smart code completion feature to display at the top of the suggestions the most relevant ones for the context.
eclipse has plugins to extend its core code completion among these aix code completer and codota use ai techniques and can even recommend a full line of code.
while these approaches are undoubtedly valuable to speed up code writing they are limited to recommendations related to the next few tokens the developer is likely to type given the current context.
in the best case they can recommend a few apis that the developer is likely to use next.
with fears we forge another step ahead to predict the next full method a developer is likely to implement.
b. code search engines fears is also related to approaches implementing code search engines that allow retrieving code samples and reusable open source code from the web.
early online code search engines e.g.
codesearch.google.com koders.com and krugle.org offered keyword based search and file level retrieval.
these approaches could be improved by considering structural and semantic information of code.
bajracharya et al.
developed sourcerer a code search engine that extracts structural information from the code and stores it in a relational model so it can be queried for code search.
it supports queries for control structures java types and micro patterns e.g.
implementation of semaphore .
reiss developed an approach to combine code search with transformations to map the retrieved code to meet user specifications .
for the searching it allows the user to specify multiple semantic rules which also form the basis for the transformations.
thummalapenta et al.
developed an approach to support code search engines with static analysis to return fewer but more relevant code samples for search queries .
their primary goal was to support a user in reusing a given api.
later they extend their approach with spotweb to assist users by detecting hotspots that can serve as starting points for reusing apis.
147api usage was also proposed by mcmillan et al.
to return highly relevant matches for a source code search engine.
their approach combines three sources of information to locate relevant software the textual descriptions of applications the api calls used inside each application and the dataflow among those api calls.
compared to code search engines fears also relies on an extensive database of methods source code in open source applications.
these methods are organized in clusters based on a similarity algorithm implemented in the asia clone detector .
fears does not require the user to write a query to identify relevant pieces of code but extrapolates this need by monitoring the ide.
vii.
c onclusions code completion while provenly useful and extensively used by developers is just a step in the direction of an automated pair programmer adding complete methods that a developer would have to add anyway and thus removing from the developer the burden of rote work.
this was the ambitious goal that we set out to achieve with this work embodied in the creation of fears an approach and a tool to automatically recommend to developers the complete next method to write during implementation activities.
fears relies on a simple but intuitive idea programming is an eclectic activity which some even go as far as calling it natural .
what a developer is has a high chance of having been done by someone else somewhere else before.
leveraging this idea fears mines vast amounts of data to recommend complete methods given a set of methods being implemented by a developer.
we evaluated fears on the change history of android apps.
the results show the potential of fears with hundreds of correct methods recommended even in its most conservative configuration.
however our findings are not conclusive for what concerns the actual usefulness of the generated recommendations in a real usage scenario in which developers use fears during coding activities.
this is due to two observations we made.
first some of the methods recommended by fears are quite short and while they can still be useful they could also represent trivial recommendation for developers.
we believe this can in part be made up by introducing a user feedback loop which is part of our future work.
the quantitative results show that around of the tokens from the recommendations need to be modified added or deleted to fit the user s code base.
one of our future plans is to integrate code adaption techniques into fears to avoid potential conflicts or compilation errors with the user s code environment and convert the coding convention into the user s style.
second due to our experimental design the unmatched recommendations are always considered false positives while we observed that some are actually valuable recommendations.
thus a deeper evaluation of fears including a well designed user study represents another main target of our future research.acknowledgment we gratefully acknowledge the financial support of the swiss national science foundation for the projects probe snf project no.
and ccqr snf project no.
.