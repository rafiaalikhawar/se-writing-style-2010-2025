a predictive analysis for detecting deadlock in mpi programs yu huang southwestern university of finance and economics yuhuang swufe.edu.cnbenjamin ogles brigham young university benjaminogles gmail.comeric mercer brigham young university egm cs.byu.edu abstract a common problem in mpi programs is deadlock when two or moreprocessesareblockedindefinitelyduetoacircularcommunication dependency.
automatically detecting deadlock is difficult due to its schedule dependent nature.
this paper presents a predictiveanalysisforsingle pathmpiprogramsthatobservesasingle programexecutionandthendetermineswhetheranyotherfeasible scheduleoftheprogramcanleadtoadeadlock.theanalysisworks by identifying problematic communication patterns in a depen dency graph to form a set of deadlock candidates.
the deadlock candidatesarefilteredbyanabstractmachineandultimatelytested for reachability by an smt solver with an efficient encoding fordeadlock.
this approach quickly yields a set of high probability deadlock candidates useful for reasoning about complex codes and yieldshigherperformanceoverallinmanycasescomparedtoother state of the art analyses.the analysis issound and completefor single path mpi programs on a given input.
ccs concepts software and its engineering formal software verification distributed programming languages.
keywords deadlock predictive analysis abstract machine cycle detection acm reference format yuhuang benjaminogles andericmercer.
.apredictiveanalysis fordetectingdeadlockinmpiprograms.in 35thieee acminternational conferenceonautomatedsoftwareengineering ase september21 virtual event australia.
acm new york ny usa pages.
https introduction themessagepassinginterface mpi isthe defactostandardforcommunicationandsynchronizationinhighperformancedistributed programs.
mpi programs contain a finite set of processes that send and receive messages concurrently.
a common error in mpi programs referred to as deadlock occurs when one or more processes block indefinitely due to a circular communication dependency.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
paper presents an analysis for detecting deadlock in a subclassofmpiprogramscalled single pathprograms wherethe order of actions issued by each process is deterministic for a given input.single pathprogramsthereforeexhibitalimited thoughstill significant set of non deterministic behaviors due to message race.
messageraceoccurswhentwoormoremessagesaresentconcurrently to the same process that has not specified a source for its next receive.
an mpi program that terminates successfully in one executionmaydeadlockinanotherexecutiondependingonhow message race is resolved by the runtime.
theanalysispresentedinthispaperis predictive becauseitobserves a single schedule over message race and finds a different feasibleschedulethatleadstoadeadlockonthesameinput.the new schedule preserves the order of actions in each process and is thereforeguaranteedtobeafeasibleexecutionofthesingle path program.
finding such a schedule is an np complete problem and can be encoded as a propositional formula .
theseformulascangrowprohibitivelylargeformanyprograms because they must encode what it means to deadlock generally.
in contrast theapproachpresentedinthispaperonlyencodeswhatit means to deadlock at a specific point in the program.
this simpler encoding is used on a filtered set of likely deadlock candidates.
the analysis proceeds in three increasingly precise stages a conservative set of deadlock candidates is extracted from the cycles of a dependency graph defined over the observed execution.
eachcandidateistestedforreachabilityinanabstractmachine that implements an abstract semantics for the presented mpi programming model.
the feasibility of the remaining candidates is determined by encoding each as a separate smt problem.
each of these stagespresents its own research challenges.
first highly non deterministic mpi programs yield large dependency graphswithahugenumberofcycles.anaiveenumerationofall cycles would not scale to these programs.
this paper presents a strict characterization of which cycles may be deadlock candidates andamodificationofjohnson salgorithm thatonlyenumerates such cycles.
second tobe aneffectivefilteringmechanism theabstractmachine must be able to accept all feasible deadlock cycles and reject mostinfeasibledeadlockcyclesbasedononlyoneabstractexecution.inotherwords themachinemustbeprovablypreciseandthe schedulechosenbytheabstractmachineexecutionmustnotlead to spurious results.
proofs for both of these properties are given in the full paper .
finally the smt encoding is adapted from an encoding developed by huang et al that can only describe schedules over messagerace thatformcomplete executions e.g.
theendof each 35th ieee acm international conference on automated software engineering ase a n b b b nb sipsrc dst ripsrc dst bb wipi bip src p dst p figure types of actions a a. process is reached .
the witness execution which is an execution thatactuallydoesdeadlockatthepredictedprogramlocation fora feasible deadlock candidate is necessarily incomplete.
therefore the encoding is adapted to describe partial executions that deadlockataspecificpoint.thisisachievedbyaddingoneadditional boolean variable for every encoded mpi operation that represents itscompletionstateinthewitnessexecution.operationsintheprocessesnamedbythedeadlockcandidateareassertedascomplete uptothedeadlockpointwhilethecompletionstateofoperations intheotherprocessesisresolvedbythesmtsolverasneededto reach the deadlock.
the analysis supports multiple buffer settings and is sound and complete for single path programs on a given input i.e.
it reports adeadlockifandonlyifthereisareachabledeadlock .empirical results show that in many cases the staged analysis is far more efficientthanencodingthedeadlockproblemasansmtformula directly or analyzing the program with a model checker .
preliminaries we formalize an observed mpi program execution as a concurrent trace program ctp .
a ctp is a set of observed communication actionsa awhereais the set of all possible mpi actions.
thesyntaxandstructureofactionsin aisshowninfigure1.
each action has a unique identifier i nand an owning process p p a wherep a is the set of all processes in the ctp a. for a set of actions xand for each process p p x xp xis the projection of the actions in xonto the process p. non blockingactionsareusedtoasynchronouslysend s and receive r messagesbetweenprocesses.thesourceanddestination processes for a message are indicated by process identifiers in the bodyoftheseactionswherethesourceprocessforareceivecanbe toallowfor wildcardreceive.awildcardreceiveacceptsmessages from any source process.
the messages are held in buffers allocated by the user program andcopiedfromsourcetodestinationbuffersbyanmpiruntime.
data buffers are not explicitly represented in this presentation becausethevaluesofmessagesdonotaffecttheschedulesofsinglepath programs.
blocking actions are used to halt a process until some condition becomestrue possiblysynchronizingtwoormoreprocesses.the wait w actionblocksuntilthedatabufferofanon blockingaction is available i.e.
when data has been copied out of into a send receive buffer .
the barrier b action blocks until each process in a group indicated with a unique identifier has reached thesame barrier.
blocking send and receive actions are not included in abecause they are accurately modeled by placing a wait action directly after the non blocking action.
for the remaining sections we fix a ctp a. for simplicity in the presentation of the analysis and accompanying proofs we assume that the last action in each process p p a is a barrier action bipp for some group g a whereg a is the set of barrier groups in a. this assumption does not affect the programs we analyze as we can always extend the observed ctp with theseactions.
the added barrier action at the end of each process is necessarytomodelallpotentialdeadlocksinthedependencygraph including those arising from wildcard receives.
thedisjointsetsofsend receive waitandbarrieractionsin a aredenotedrespectivelyby s a r a w a b a .foranaction a a id a andpid a denote the action and process identifiers ofa.
for an action a s a r a src a anddst a denote the source and destination process of a. of course src a pid a and dst a pid a for sends and receives respectively.
for an action a w a req a is the non blocking action that a waits for.
for an action a b a grp a is the group identifier foraandb a is the set of actions in that group.
foraprocess p p a theactionsownedby parealwaysissued sequentially.thisconstraintcanbecapturedasapartialorderover aifweassumethatactionidentifierswereassignedinascending order while observing the original execution.
definition .
process order .
process order is a partial order a apo where a a prime a a a poa prime pid a pid a prime id a id a prime fordefinition2.1andsimilarlyforanyotherpartialorderdefined in this paper we use apoto mean the partial order with reflexivity removed and we omit afrom the notation when it is clear from context.
example figure2showsafeasiblecompleteexecutionforasimplectp.each column is a separate process where actions are listed in poorder.
the vertical spacing represents the total order over the actions in the observed execution.
we refer to actions by their unique identifiers.
inthisexample thewildcardreceive0canmatchwith either1 or3.inthecompleteexecution0matcheswith1 leaving3tomatch with .
if this message race is resolved in the opposite direction matching with a deadlock occurs.
our analysis detects the deadlock by identifying the program locations w906 w11 w721 as a deadlock candidate.
thedeadlockcandidateisextractedfromthecycleshowninfigure .
figure shows the witness execution for this deadlock.
here6iswaitingforitsonlymatch .thisprevents10frombeingissued and matching with which in turn prevents from being issued and matching with .
the graph for figure contains nodes and edges.
our algorithmdetects threedeadlock cyclesinthis graph.in thiscase none of the cycles are filtered away by the abstract machine even though only one predicts a feasible deadlock.
the other two cycles predict infeasible deadlocks.
r01 s1221 w210 s3001 r4101 w503 s6002 w721 r8202 w906 s1 w1 r12 w1 w1 w1 b1 b1 b1 figure example ctp with hidden deadlock.
figure cycle for deadlock in figure .
s3001 r01 w503 s6002 w210 r4101 s1221 w906 w1 w721 figure witness execution for deadlock in figure .
thesmtencodingverifiesthefeasibilityofeachdeadlockcycle by encoding a deadlock at the candidate location.
to find the execution shown in figure for example the formula encodes astate where and are issued and where and cannot find any match.
the satisfying assignment for the variables in the formula can be used to construct the witness execution including the details of which matches were made.
theinfeasiblecyclesreporttheprogramlocations b1710 and w721 in two different candidates.
in other words they each predictthattheprograminfigure2canbere orderedtoreacha state where action is waiting for process to issue a compatible matchbutprocess1iswaitingtofinish.thistypeofdeadlockdoes occur in some programs and is discussed in section .
however in thiscaseitisclearthatifprocess1reachesaction17 aspredictedin the deadlock candidates either action or must be available to match with action making these candidates infeasible.
it may beissuetransition a a i 1po i 1po w a b a m angbracketlefta i m angbracketright angbracketlefta i a m angbracketright match send recv transition a a prime i ma s a a prime r a dst a dst a prime src a prime src a 1mo 1mo m angbracketlefta i m angbracketright angbracketlefta i m a a prime angbracketright match wait transition a i ma w a 1mo m angbracketlefta i m angbracketright angbracketlefta i m a angbracketright match barrier transition g a a b a a i 1mo m angbracketlefta i m angbracketright angbracketlefta i m b a angbracketright figure transition rules for concrete semantics.
possibletoextendtheabstractmachinewithsomecountinglogic to filter these candidates but our empirical results section show that it already filters a majority of the cycles detected in our set of benchmarks.
semantics of concurrent trace programs in this section we extend the semantics presented by forejt etal.
to accomodate barrier groups and simpler proofs of correctness for our analysis.
the semantics of ais given by a finite statemachinef a angbracketleftq q0 angbracketrightwhereq 2a 2a 2aisthe set of states q0 angbracketlefta angbracketrightis the start state and q q is the transition relation.
in a state q angbracketlefta i m angbracketright ais the set of actions in the ctp i ais the setof actions that havebeen issued to the runtime and m iis the set of actions that have been matched.
sendandreceiveactionsarematchedtogetherbytheruntime whentheirsourceanddestinationprocessesarecompatible.wait actions do not match other actions but are instead matched with themselves after their associated message request is matched.
finally barrier actions match the other actions in their group when they have all been issued.
someactionsinthesameprocessmaybematchedinanorder differentfromhowtheywereissuedwhileothersmustbematched intheordertheywereissued.thisconstraintiscapturedbytwo more partial orders.
definition4.
queueorder .
queueorderisapartialorder a aqo where for all actions a a prime a a aqoa primeif and only if a apoa prime and one of the following is true a a prime s a dst a dst a prime a a prime r a src a src a prime 20definition .
defines a first in first out fifo ordering over messagescommunicatedonthesameendpoint.withoneexception this order fully supports the non overtaking property of ordered messages as defined in the mpi standard.
the exception occurs whenadeterministicreceiveisfollowedbyawildcardreceivein the same process.
in this case fifo ordering over the two receive actions is enforced only if they can both match the same send action.
this condition is schedule dependent as its value changes depending onwhetherasendactionhasbeenissuedthatcanmatchthefirst receiveactionwhenthesecondactionisissued.asin weleave such receive actions unordered.
definition4.
matchorder .
matchorderisapartialorder a amo where for all actions a a prime a a amoa primeif and only if a apoa prime and one of the following is true a aqoa prime a w a b a a s a r a a prime w a a req a prime definition .
ensures that queue order is preserved when messages are matched blocking actions are matched beforesubseqent actions in the same process and message requests arematchedbeforetheirassociatedwaitactions.withmatchorder defined we can define the transition relation shown in figure .
given a relation qover a set xand an element x x q y x yqx is the preimage of xunderq.
theissuetransition issuesanewactionwhenalloftheactionsprecedingitinthesame process have been issued and all of the blocking actions preceding it in the same process have been matched.
the match send recv transitions complete type compatible matches when their match order dependencies have been satisfied.
notethatthedefinitionofthe match wait transitionin requiresthatthe match send recv transitionhascompletedforthe messagerequestofthewaitaction.thiseffectivelyforcesexecutionstofollowa rendevousprotocol wherewaitingforacommunication causes the process to block until the full message transfer is completed.thisisincontrasttoanequallyvalidprotocolwhere wait actions are matched as soon as the data buffer used in the message request is available.
wechoosetousetherendevousprotocolbecauseitisequivalent to a zero buffer runtime.
in a buffered runtime sent messages can becopiedintosystembuffersbeforematchingreceiveactionsare issuedinordertofreeupuserbuffersmorequickly.inazero buffer runtime this buffering never occurs and the user buffer is only available after the message transfer has completed.
ouranalysiscanalsosupportanotherimportantbuffersetting formpiprograms theinfinite buffersetting.inaninfinite buffer runtime sent messages are buffered without limit.
the matchwaittransitionisincompatiblewiththisbuffersetting.ratherthan creating new transition rules however we completely support the infinite buffer setting by removing wait actions from the ctp that wait on send actions.
deadlock thissectionformalizestheproblemstatementfordetectingdeadlock ina.
the definitions are given in terms of a generic transitionrelation q q because wereuse them laterwith the abstract transistion relation.
let q qdenote the reachable states of afrom the state q with respect to a transition relation q q prime q q q prime where denotes the transitive closure of .
definition5.
deadlock .
astateq angbracketlefta i m angbracketrightisdeadlockedwith respect to a transition relation if there are no enabled transitions and there are actions left to be issued or matched dead q i nequala m nequala q prime q q q prime nelement the deadlock discovery problem given in definition .
asks whetherf a can reach a deadlocked state.
this problem is npcompleteandcanbedirectlyencodedasapropositionalformula .
definition .
deadlock discovery problem .
q q0 dead q the search for an arbitrary feasible deadlock state can be extremely expensive for many programs.
we can give the search a kindofheadstartbyfindingasimplewaytocharacterizethetypes ofstatesthatmaydeadlock.aconvenientwaytodescribeastate is by itscontrol point.
the control point of a state is simply the set of last issued actions from each process ctrl angbracketlefta i m angbracketright a i a prime ipid a a prime poa .
ifweonlyprovidethelastissuedactionforasubsetofprocess we obtain a partial control point that describes the collection of states whichincludeitasasubsetoftheircontrolpoints.definition5.
augments the problem statement in definition .
to ask for a deadlock state that matches a partial program point d also called a deadlock candidate .
definition .
constrained deadlock discovery problem .
q q0 d ctrl q dead q dependency graph this section presents a technique for generating a sound set of deadlockcandidates d a fora.thesoundnesspropertyaccording to definition .
is formally stated in the following theorem.
theorem .
deadlock candidates sound .
for all states q q0 i fdead q then d d a d ctrl q .
wegenerate d a bydetectingcyclesinagraph n e where n a p p p a is the set of nodes and e n nis the set of edges.
the node pis used to explicitly represent the end of processpinthegraph.anedge a a prime erepresentsapotential communicationdependencyof a primeonainsomeexecutionof a.a proofthatourtechniquesatisfiestheorem6.
alongwithproofs fortheothertheoremsstatedinthispaper isgivenintheappendix of the full paper .
beforepresenting thedependency graph we describehow one of its cycles can represent a deadlock.
this not only motivates the rules for adding edges to the graph but also leads to a preciseunderstanding of the type of cycle the analysis must report andthe types it can ignore.
this is important because the graphs we 21build may contain a huge number of cycles which are expensive to enumerate.themorewecanignore themoreefficientouranalysis will be.
fix a deadlock state q q0 with control point d ctrl q .
for each process p p a there is an action a dwithp pid a .
wewilldefineafewnewtermsthatallowustotalkaboutwhy ais blockingpfrom progressing in the state q. first wecall athedeadlockaction forp.next let a primebetheearliest actionin pthatisissuedin qbutnotmatchedwith a prime moa.w e calla primetheorphanedaction forp.finallylet a prime primebeanactionthatis not issued in qbut would allow pto progress if it is matched with a.wecalla prime primetheparentaction.iftheparentactiondoesnotexist it is represented in the graph by a node discussed more below .
wewillusethefollowingdefinitiontotranslatetheseconceptsto the context of a path of edges in e. definition .
deadlock path .
let a0 a1 ... an an bea path of edges in e. this path is a deadlock path for the process p p a if pid a0 nequalpand pid ai pfor alli ...n and for some i ...n ai w a b a .
inadeadlockpath a0 a1 ... an an fortheprocess p a0 anda1are interpreted as parent and orphan actions of p. the edge connecting them represents the possibility that a1may depend ona0being issued and available to match to complete in some execution.theearliestblockingactionissuedby pandcontained in the path is interpreted as the deadlock action of p. definition6.2requiresthatthedeadlockactionnotbethelast actioninthepath.thisisbecauseadeadlockcycleisconstructedby composingthedeadlockpathsoftwoormoreprocesses.inother wordsanin the deadlock path of pwill be the parent action in a different deadlock path for some process p prime nequalp.
the deadlock actioncannotalsobeaparentactionbecausethedeadlockaction is issued and ready to match by definition.
definition6.
deadlockcycle .
acycleofedgesin eisadeadlock cycleifitcanbeconstructedfromasetofdeadlockpathswhereeach process in the program contributes at most one path.
additionally theorphanedactionofeachdeadlockpathmustnotbeacompatible match for the orphaned action of any other deadlock path in the cycle.otherwise thepotentialdeadlockstatewouldquicklyunwind by matching the two issued orphaned actions.
the candidate of a deadlock cycle is the set of deadlock actions fromitspaths.weconstruct d a byextractingthecandidatefrom each deadlock cycle in the graph.
the proof of theorem .
referredto thefull paper shows thatfor everyfeasible deadlock state thereisacorrespondingcyclein ethatconformstodefinition6.3andyieldsamatchingpartialcontrolpoint.thefirststep toconstructing eistoknow which actionscanmatchtogetherin an execution of a. definition .
potential matches .
for an action a a m a denotes the set of actions that can be matched with ain some transition between reachable states of a. more precisely if m q denotes the matched set in the state q then m a a prime q q prime q0 q q prime a a prime m q prime m q a .note that fully determining mis as hard as the deadlock discovery problem itself.
fortunately mmust only be over approximated to ensurethat thewhole analysisis sound.a simple overapproximation would include every compatible match of the action ain m a .
however the analysis presented in this paper uses the more preciseapproximationgivenin whichresultsinfewerspurious cycles.
definition .
edges .
an edge a pid a is added to efor everya a. otheredges areadded between twoactions a a prime a according to the following rules ifa moa primethen a a prime e. ifa prime m a then a a prime a prime a e. ifa a prime r a such that a poa prime src a src a prime nequal then src a prime a prime e. ifa s a anda prime r a such that dst a dst a prime and src a prime then dst a a e. rule one of definition .
is an obvious preservation of the semantics presented in section .
it is necessary for connecting deadlockactionstootheractionsinthetailofadeadlockpath.it also ensures that wait actions often a deadlock action have an incoming edge from their associated message request often an orphaned action .
the rest of the rules ensure that parent actions are connected to orphan actions in any scenario.
the most obvious occurs in rule two whenthe actionscan form amatch.
theedge isbidirectional becausewedon tknowwhichactionwillbetheorphanedaction and which will be the parent action in a given deadlock.
rules three and four add edges to encode the possibility of messagestarvation.messagestarvationoccurswhenwildcardreceive actionsarematchedwithsendactionsinanunintendedwaythat leavessubsequentsendandreceiveactionswithoutanypotential future matches.
in this type of deadlock the parent action does not existintheprogram theorphanedactioniswaitingforanaction that will never be issued .
the added node at the end of every process takes the place of the parent action in these cases.
notethatwedonotneedaruleforaddinganedgefrom nodes towildcardreceiveactionsbecauseifawildcardreceiveactionis starved thentheresultingdeadlockwouldhavebeendeterministic.
there is no need for analysis in this case as the deadlock occurs no matter how you schedule the program.
these rules will inevitably generate graphs with many spurious cyclesthatobviouslydonotcorrespondtorealdeadlockstates.for example thesecondrulealoneformsatrivialcyclebetweentwo potentially matching actions.
we only want to enumerate cycles that match definition .
.
by default johnson s algorithm for enumerating the elementary cyclesofadirectedgraph willenumerateallofthespurious cycles.
algorithm presents a simple boolean function that can be added to johnson s algorithm to ensure only deadlock cycles are visited.
johnson s algorithm searches for cycles in one strongly connected component at a time according to a user defined order.
we extend potoatotalorderoverthenodesinthegraph.thecomponentcontainingtheleastnode sissearchedfirstand sisvisitedfirst.
the global variable stackmaintains a normal depth first search stack of visited nodes.
22algorithm1 determinewhethertheedge v w canpossiblyreach a deadlock cycle starting at s procedure deadlockedge v w s ifpid v pid w then returntrue ifblock count stack pid v 0then returnfalse ifblock count stack pid v v w a b a then returnfalse if a orphaned stack can match a w then returnfalse ifw nequalsthen return a stack pid a nequalpid w returnfalse theresultofthechosenorderisthat sisalwaystheorphaned action of the first deadlock path visited by the algorithm.
our specialized depth first search visits the successor wof the current nodevwhen deadlockedge v w s returnstrue.
this ensures that the stack is always extending to a valid deadlock path according to definition .
.
theblock count functionreturnsthenumberofblockingactions in a given process that have been visited by the current stack.
thecan match functiondetermineswhethertwoactionsmayform acompatiblematchbasedontheirtypesandendpoints.finally the orphaned functionreturnstheorphanedactionfromeachdeadlock path in the current stack.
lines2 3ofalgorithm1allowthetailofthecurrentdeadlock path on the stack to be extended along the same process rule one in definition .
.
if the condition on line is false then v andware the parent and orphaned actions for a new deadlock path.
lines ensure that the current deadlock path contains adeadlock action that is not also a parent action for w rules two andthreeindefinition6.
.lines8 9ensurethatorphanedactions cannot match other orphaned actions definition .
.lines ensure that each process only contributes one path to the cycle also definition .
.
the final case occurs when wis equal to sand a cycle is formed.
inourimplementation wealsoensurethatduplicatedeadlock candidates are not reported by keeping track of how actions are orphaned.ifthetailofalongdeadlockpathcanreachanorphan action in another process from two different parent actions it is simple to only enumerate one such deadlock cycle.
this is left out of algorithm for clarity.
abstract semantics of concurrent trace programs thissectiondefinesanabstractmachine hatwidef a angbracketleftq q0 abs angbracketrightthat augmentsthesemanticsofctpstoefficientlyfilterawayinfeasible deadlock candidates.
this filtering is an important stage in theanalysis because it can drastically reduce the number of calls tothe smt solver.
the abstract transition relation absis shown infigure6withthebarriertransitionomittedasitisunchangedissue send transition a s a i 1po i 1po w a b a m s s id a pid a dst a angbracketlefta i m angbracketright angbracketlefta s i s a m angbracketright issue other transition a a ia nelements a 1po i 1po w a b a m angbracketlefta i m angbracketright angbracketlefta i a m angbracketright match send recv transition a a prime i m a s a a prime r a dst a dst a prime src a prime src a 1mo 1mo m angbracketlefta i m angbracketright abs angbracketlefta i m a a prime angbracketright match wait transition a i ma w a s s id req a pid req a dst req a req a m req a s a s m angbracketlefta i m angbracketright abs angbracketlefta i m a angbracketright figure transition rules for abstract semantics.
from .inthistransitionrelationwecreateadedicated wildcard endpointfor each source process.
this eliminates the possibility of message starvation.
theissue send transition generates a fresh wildcard send for thenewendpointandissuesitalongsidetheoriginalsendaction.a wait on the original send action is allowed to match in the matchwaittransition if either the original send orthe wildcard send has beenmatched.thewildcardsendisonlyallowedtomatchwildcard receiveactionsissuedbythedestinationprocessandtheoriginal send action is only allowed to match deterministic receive actions.
we filter a deadlock candidate dby deriving a ctp adthat containstheactionsin d theactionsprocessorderedbeforeactions indand all of the actions in other processes ad uniondisplay a d po uniondisplay p nelementp d ap we then attempt to execute hatwidef ad to determine whether q q0 abs d ctrl q dead abs q notethatthisisjustdefinition5.3withtheabstracttransition relation substituted in.
if the abstract execution is able to issue everyactionin d thenthecandidatemayrepresentarealdeadlock and it is added to the set of candidates to be encoded as an smt formula.
otherwise the candidate is infeasible and is discarded.
23match order logicalanddisplay a ad logicalanddisplay a prime 1mo ca ca prime ta prime ta queue order logicalanddisplay a s ad r ad logicalanddisplay a prime 1qo ma prime ma barriers logicalanddisplay a b ad logicalanddisplay a prime bgrp a ad ta ta prime matches logicalanddisplay a s ad r ad ca logicalordisplay a prime md a omatch a a prime reach logicalanddisplay a d logicalanddisplay a prime 1mo oca prime deadlock logicalanddisplay a d o ca no matches logicalanddisplay a o logicalanddisplay a prime md a ca prime figure constraints in the formula f the abstract machine is sound if it never discards a reachable control point.
let the set of reachable control points from a state q and a transition relation becq .
cq ctrl q prime q prime q theorem7.1statesthatthereachablecontrolpointsoftheabstractmachinesubsumesthereachablecontrolpointsoftheconcrete machine.
theorem .
states that if the abstract machine cannotissueeveryactioninthedeadlockcandidateinoneexecution it will not be able to issue them all in any execution.
together these theorems prove that the candidate dcan be filtered away in a single execution of the abstract machine when it fails to issue all of the actions in d. theorem7.
abstractcandidatesimulation .
letq q0 andq prime q0 absbe a concrete and abstract state reachable from the start state q0.i fctrl q ctrl q prime then for all control points d cq it follows that d cq prime abs.
theorem .
abstract deadlock deterministic .
letq q0 absbe a reachable abstract state with dead abs q .i fd notsubseteql ctrl q then for all q prime q0 abs d notsubseteqlctrl q prime .
smt encoding if hatwidef ad isabletoissueeachactioninthecandidate d thenitis usedtoconstructansmtformula f.asatisfyingassignmentfor fcan be used to construct a witness execution for the deadlock candidate.
if fis unsatisfiable then there is no feasible deadlock statethatcontains daspartofitscontrolpoint.theencodingis anextensionoftheonedesignedbyhuangetal.
forfinding zero buffer compatible executions of mpi programs.
letmdbe an over approximated set of match pairs for ad.
for each action a ad the encoding creates an integer variabletato hold its completion timestamp in the witness execution.
if a s ad r ad then the encoding also creates an integer variablematoreferencethetimestampoftheactionthatmatches a. addtionally wais used as another name for twwherew w ad anda req w .thenewencodingaddsabooleanvariable cafor everyactionthatistrueif amustbeissuedandcompletedinthe witness execution.
the rulesfor theencoding are shownin figure .the match orderandqueueorderconstraintspreservethemeaningof mo and qointheencoding.anactioncanonlycompleteifits mo predecessors have completed and the timestamps must reflect that.
additionally matches must conform to the non overtaking guarantee of mpi executions.
in all cases constraints are omitted when theyareobviouslyredundantwithrespecttoexistingconstraints and the transitivity of and over the integers.
the barriers constraint encodes the inter process synchronizationbehaviorofbarrieractionsbyassertingthatgroupscompleteat thesametime.allothertimestamps including maforeacha ad are asserted to be distinct.
the matches constraint forces send and receive actions to find a match if they must complete in the witness execution.
some matchesarenotallowedassumingtheexecutionendsinadeadlock parked at the actions in d. specifically let odenote the set of orphaned send and receive actions for the candidate d. o a ad a prime w ad d a req a prime the matches constraint purposely excludes the actions in oas they should not be matched in the witness execution.
insection4 asendandreceiveactionwerematchedbycopying them from the issued set into the matched set together.
after that theirwaitactionswereallowedtocomplete.thissemanticmeaningispreservedintheencodingbythe match a a prime constraintwhich expands to ca prime ta ma prime ta prime ma ta wa prime ta prime wa.
first thisconstraintrecordsthat a primeiscompletedbythematch.
second the actions complete together by recording the timestamp oftheotherinthe mvariables.finally bothtimestampsarerequired to precede the timestamps of both wait actions.
note that in theinfinite buffersetting thewaitforthesendactiondoesnotexist and so one of these constraints is omitted.
thereachconstraintassertsthateverypredecessoroftheactionsindiscompletedexcepttheactionsin o.inotherwords it asserts that the deadlock dis reachable.
thedeadlock constraint simply asserts that the deadlock actions indand the orphaned actions in oare not complete.
the no matches constraint ensures that any issued actions that could untangle the deadlock are complete thus forcing them to findmatches that exclude the deadlock and orphaned actions.
givena satisfying assignment of the variables in f the witness executioncanbeconstructedfromthe ttimestampvariableswhilethe matches made can be recovered by consulting the mvariables.
experiments the runtime trace for our approach is observed through code instrumentation.thempichlibraryisusedfortheactualruntime .thetranslationofanobservedmpiexecutiontracetoactpis 24table tests on selected benchmarks name procs calls bdtmisp tm mopper tm mopper o tm aislinn tm monte4350 .037s .223s .244s .258s .665s .002s .957s .496s .488s .672s .055s to .503s .619s .190s .007s to .357s .870s .042s .206s to .406s .302s to .052s to to to to integrate836 .002s 1000s .328s .303s .832s .006s to .186s .392s .028s .01s to to .050s to diffusion2d4520 .325s to n acn ac1.245s .049s .005s .521s .486s .232s .761s to n acn ac135.273s .06s to to .792s .112s floyd8120 .071s to .472s .623s to .133s to .814s .256s to ge856 .001s .054s .172s .809s n aa .004s .426s .972s .139s n aa heat16312 .457s to .092s .205s n ab .359s to .331s .068s n ab is648280 .03s45.471s .621s .599s n ab .01s46.565s .589s .602s n ab .014s148.251s .394s .530s n ab .024s150.570s .767s .539s n ab .036s561.294s .328s .731s n ab .07s476.516s .714s .367s n ab aaislinn aborts the verification for unknown exceptions after minutes of running.
baislinn does not support some mpi calls in the program.
cmopper is not launched because the process of trace generation finds a deadlock.
largelytrivialandproceedsasexpected.anythingoutsidemessage passingasdefinedinthispaperisignored.somecaremustbetaken with collective operations but it is all mechanical.
the smt solver z3 is used by our approach for validation .
theexperimentsarerunonaninteli5quadcoreprocessorwith gb of memory running ubuntu .
lts.
a time limit of minutes is set for each test.
the test aborts the verification process ifitdoesnotcompletewithinthetimelimit.therestofthissection compares our approach to other existing tools.
.
results theexperimentscomparetheperformanceofourapproachwith three state of the art mpi verifiers mopper a sat based tool isp adynamicanalyzer andaislinn anotherdynamic analyzer .mopperisatracebasedverifierthatchecksthesame behaviors described in this paper.
therefore the comparison toour approach is direct.
the experiments compare the results of two versions of mopper the original tool and the optimized tool .
isp is a general verification tool that is not specialized to only deadlock but includes races and user defined assertions.
the comparison to our approach is intended to convey the benefit of specialization to just deadlock and suggest that similar gainsmaybefoundinspecializingtojustdataraceorassertions.aislinn is a dynamic verifier that covers two buffering choices for each send operation in a program.
in other words aislinn detects more behaviors than those in the infinite buffer semantics buffering provided for all sends and the zero buffer semantics no buffer for anysend .inordertocomparetoourapproach wesetthebufferingmodeforaislinnto eager equivalenttotheinfinitebuffersetting and rendezvous equivalent to the zero buffer setting .
the results of the comparison are in table .
the column b represents the buffering setting in the runtime.
the column d indicatestheexistenceofdeadlocks.thecolumn tm isthetimeofrunningourapproachandconstraintsolvingifnecessary.the tm column for isp is the running time of dynamic analysis.
the tm columnsformopperandoptimizedmopperareforconstraint generationandsolving.the tm columnforaislinnistherunningtimeofthetoolforeither eager modeor rendezvous mode.the notation to means timeout exceeding the time limit setfor each test .
the notation n a means not available .
.
benchmarks monte implementsthemontecarlomethodbyamaster slave model.
the program has a deadlock trace under the zero buffer setting.
integrate implementsthealgorithmthatcomputesanintegral of thesinfunction by using a large number of wildcard receives to match the sends from multiple sources.
diffusion2d hasaninterestingcomputationpatternthatuses barriers to partition the message communication into several sections.amessagefromasendcanbeonlyreceivedinacommon section.
deadlock occurs under the zero buffer setting.
floyd implements the shortest path algorithm for all the pairs of nodes.
the message communication is only built between any two successive processes.
ge is a message passing implementation for gaussian elimination.messagesarecommunicatedbyissuingseveralwildcard receives on each node.
heat implements the solution of the heat conduction equation.
the communication pattern for this benchmark contains several message starvation deadlocks.
is implementsthesolutionofintegersorting.themessage passing in this benchmark is deterministic.
.
discussion thecomparisonoftimecosttothethreeexistingstate of the art tools demonstrates that our approach is much more efficient for deadlock detection in many cases.
for the benchmark programs with a small number of processes e.g.
montewith processes all thetoolsareabletofinishthetestsveryquickly.however asthe thenumberofprocessesgrows implyingthatthebenchmarkhas a much higher degree of non determinism isp and aislinn both have unexpectedly high time costs for the tests e.g.
floydwith processes andeventimeoutforsometests.overall mopperis much quicker than the other two tools.
the optimized mopper is evenmoreefficient especiallyforlarge complicatedbenchmarks e.g.
integrate with processes .
however it still suffers from the scalabilityproblemforafewtests e.g.
montewith16processes .in contrast our approach is able to finish most tests under a second.
.
effectiveness of filtering table shows the effectiveness of the cycle detection algorithm andtheabstractmachineasafilteringmechanism.eachtestshown intable2is anexhaustive enumeration onthe detected deadlock candidatesbyourapproach.thetesthereisdifferentfromthose in table as the enumeration does not terminate even if a feasible deadlock is validated.
therefore some tests in table may takemuch more time to run.
the times are not recorded in table astheyaremeaninglessforactualdeadlockanalysis.thecolumn edges recordsthenumberofedgesinthedependencygraph.the column instances records the number of deadlock candidates.
the column filtered records the number of deadlock candidates filtered away by the abstract machine.
the column deadlock records the number of real deadlocks.
thenumbersshownintable2indicatethattheabstractmachine in our analysis has a high precision for filtering out infeasibledeadlocks.
the percentage of filtered deadlock instances amongtable enumerating all candidates on benchmarks name procsb edges instances filtered deadlock monte monte monte integrate integrate integrate diffusion2d diffusion2d diffusion2d diffusion2d floyd floyd ge ge heat heat is is is all the detected instances varies for the test.
but if an instance isnot filtered then it is often a real deadlock.
the modified cycle detectionalgorithmisalsoeffectiveatenumeratingasmallnumber of cycles for very large graphs with a huge number of spurious cycles.
related work muchoftheliteratureonpredictiveprogramanalysisfocuseson detecting as many errors as possible from a single observed execution .
as mentioned in section the analysis presented here ismaximallypredictiveforsingle pathprogramsbutcannotreason about messages that are issued in a schedule dependent manner.
instead thispaperfocusesonimprovingtheefficiencyofansmt basedanalysisforsingle pathprogramswhileleavingextensions to more general programs as future work.
the approach in this paper is inspired by several works.
joshi et al.
proposed a method for multi threaded java programs by first detecting potential lock dependency cycles with a imprecise dynamicanalyzerandthenfindingrealdeadlocksbyarandomthread schedulerwithhighprobability .therefiningstrategyofthe work inspires the staged approach taken in this paper but the tool presentedinthispaperisguaranteedtoreportadeadlockifitexists in the single path program.
sherlockisatoolthatusesconcolicexecutionfordeadlockdetection in java programs .
the key idea is similar to our approach findingpotentialdeadlocks andthensearchingforafeasibleschedule that leads to the deadlock.
the difference is that sherlock repeatedly finds alternate schedules through solving constraints that describenewpermutationsofpreviouslyobservedschedulesrather than leveraging an abstract machine to filter out false deadlocks.
26aprecisesmtencodingtechniquewasproposedbyhuanget al.
for verifying properties over mcapi programs containing messagerace .theencodingdoesnotrequireaprecisematchset and wasextended tochecking zerobuffer incompatibility formpi programs .this techniqueisadapted forvalidatingdeadlocks in this paper.
the poe approach is a dynamic partial order reduction solution for mpi program verification .
the approach was extended to poe mse which first uses a precise happens before relation to find the potential sends that may cause different behaviorsbased onthe initialtrace thenreplays theexecutionat each potentialsendwithadifferentchoice i.e.bufferingthesendinstead of matching it .
mopper is an mpi deadlock detector based on boolean satisfiability encoding .
while the solution is precise the size oftheencodingiscubicmeaningitonlyscalestoalowdegreeof message non determinism.
civl isa model checker thatuses symbolic executionto verify anumberofsafetypropertiesofvarioustypesofconcurrentprograms including message passing programs .
the tool is outperformed by mopper.
anextensiontothemodelcheckerspin ismpi spinthatis specifictoverifyingmpiprograms .sinceamassivenumber of states are explored the work is not scalable.
b hm et al.
provide an approach that aims to find deadlocks for an mpi program under both environments of synchronization and no synchronization .
the approach first uses standard partial orderreductiontofinddeadlocksassumingtheenvironmenthas no synchronization.
it then uses an algorithm to search missed deadlocks by enforcing synchronization in the basic operations such as send and collective operations.
mpi checkerisastaticanalyzerbasedonabstractsyntaxtree ofthesourcecodeofmpiprograms .thetoolisabletocheck manyerrorsinaprogram however itislimitedtocheckdeadlocks caused by complicated semantics of communication.
partypes is a type based approach for verifying mpi programs bydevelopingaprotocollanguageforatypesystem .sincethe approach is able to avoid traversing the state space the analysis is scalable for large programs.
umpire is an approach of runtime verification for checking multiplempierrorssuchasdeadlockandresourcetracking .the errorcheckingistakenby spawningonemanagerthreadandseveral outfielder threads in the execution of an mpi program.
an extensiontoumpireismarmot .theworkusesacentralized serverinsteadofmultiplethreadsforerrorchecking.anotherextension to umpire is must .
the structure of must allows the users to execute the error checking either in an applicationprocess itself or in extra processes that are used to offload these analyses.however just likeumpireand marmot theapproachis neither sound nor complete for deadlock detection.
conclusion this paper presents a new approach that automatically detects deadlocks in single path mpi programs after observing a singleexecution.
the approach leverages a simple characterization of deadlock to efficiently detect deadlock candidates in a dependencygraph.
an abstract machine is used to quickly disregard many infeasible candidates while the remaining candidates are precisely validatedbyansmtsolverwithanefficientencodingfordeadlock.
the approach is sound and complete for deadlock detection in any single path mpi program on a given input.
experiments show that thenewapproachfinishestypicalbenchmarkswithinonly1second whiletheotherstate of the artmpiverifierstimeout.futurework considers more filtering techniques and extending the approachto support multiple path mpi programs with more complicated structures.