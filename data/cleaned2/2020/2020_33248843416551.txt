api misuse detection driven by fine grained api constraint knowledge graph xiaoxue ren zhejiang university china xxren zju.edu.cnxinyuan ye australian national university australia u6296255 anu.edu.auzhenchang xing australian national university australia zhenchang.xing anu.edu.au xin xia monash university australia xin.xia monash.eduxiwei xu data61 csiro australia xiwei.xu data61.csiro.auliming zhu pilcrow data61 csiro australia liming.zhu data61.csiro.au jianling sun zhejiang university china sunjl zju.edu.cn abstract api misuses cause significant problem in software development.
existingmethodsdetectapimisusesagainstfrequentapiusage patterns mined from codebase.
they make a naive assumptionthat api usage that deviates from the most frequent api usageis a misuse.
however there is a big knowledge gap between api usagepatternsandapiusagecaveatsintermsofcomprehensiveness explainabilityandbest practices.in thiswork wepropose a novelapproachthatdetectsapimisusesdirectlyagainsttheapi caveat knowledge rather than api usage patterns.
we developopen information extraction methods to construct a novel api constraint knowledge graph from api reference documentation.
thisknowledgegraphexplicitlymodelstwotypesofapi constraint relations call orderandcondition checking andenrichesreturn and throw relations with return conditions and exception triggers.
it empowers the detection of three types of frequent api misuses missing calls missing condition checking and missing exceptionhandling while existing detectors mostly focus on only missingcalls.
as a proof of concept we apply our approach to java sdk api specification.
our evaluation confirms the high accuracy of the extracted api constraint relations.
our knowledge driven api also with ningbo research institute.
also with pengcheng laboratory.
also with data61 csiro.
corresponding author.
pilcrowalso with university of new south wales.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
recall for detecting java api misuses in the api misuse benchmark mubench.
this performance is significantly higher than that of existing pattern based api misused detectors.
a pilot user study with12developersshowsthatourknowledge drivenapimisuse detectionisverypromisinginhelpingdevelopersavoidapimisuses and debug the bugs caused by api misuses.
ccs concepts software and its engineering softwarelibrariesandrepositories.
acm reference format xiaoxueren xinyuanye zhenchangxing xinxia xiweixu limingzhu and jianling sun.
.
api misuse detection driven by fine grained apiconstraintknowledgegraph.in 35thieee acminternationalconference onautomatedsoftwareengineering ase september21 virtual event australia.
acm new york ny usa pages.
.
introduction softwarelibrariesprovidereusablefunctionalitiesthroughapplication programming interfaces apis .
apis often come with usage caveats such as constraints on call order or value state conditions.
for example when using the iteratorin java one should check that hasnext returnstrue i.e.
theiterationhasmoreelements beforecalling next toavoid nosuchelementexcpetion.applications that fail to follow these caveats i.e.
misuse apis may suffer from bugs.
.
there are many pattern based tools for detecting api misuses by static code analysis .allthesemethodsmineapiusagepatternsfroma codebase andmakeanaiveassumptionthatanydeviationswith respect to these patterns are potential misuse .
the systematic evaluation by amann et al.
reveals that all pattern based api misuse detectors no matter which form of api 35th ieee acm international conference on automated software engineering ase patterns they adopt call pairs sequences program dependencygraph statemachine sufferfromlowprecision andrecall inpractice.someapproachesattempt to improve detection results by obtaining larger codebase through code search engine adopting more informative usage representation or building more robust probabilistic models of deviation .however noneoftheseimprovementsgobeyond the naive assumption of pattern based api misuse detection.
in this paper we propose a knowledge driven approach which detectsapimisuseagainstanovelapi constraintknowledgegraph rather than against api usage patterns that may not reliably manifest api usage caveats see section for the discussion on the knowledgegapbetweenapiusagepatternsandapiusagecaveats .
existing static code linting tools like findbugs pylint cover only general programming anti patterns e.g.
null reference useless control flow that may cause program errors but not usage caveatsofhundredsorthousandsofspecificapis.compilersreport onlycompilationerrors e.g.
unhandledexception basedonapi declaration buttheyareunawareofapiusageconstraints suchas proper call order prerequisite state or value range.
api documentation is an important knowledge source of api usage caveats .
although ides provide direct access to api documentation api documentation at least in their current semistructureddocumentform areinsufficienttodirectlysolvetheapi misuse problem .
to improve the accessibility of apicaveat knowledge li et al.
used natural language processing nlp techniques to construct a api caveat knowledge graph from api documentation.
this knowledge graph supports api centric search of caveat sentences.
the extracted natural language caveat sentencesareusefulforlinkingapicaveatswitherroneouscode examples or explaining controversial api usage on stack overflow .
however caveat sentences cannot be directly used to detect api misuses in source code in their natural language form.
in this paper we propose a api constraint knowledge graph the entities represents api elements and value literals and the edges represent declaration relations and four types of constraints call order condition checking return condition exception trigger between apis see section .
.
different from existing api knowledge graphs that capture only declaration relations and simply link api caveat sentences to an api as its attributes we develop nlp techniques to transform api caveat sentences intospecific api constraint relations.
for example by analyzing thereturn description true if the iteration has more elements of iterator.hasnext and the throws description nosuchelementexcpetion if the iteration has no elements of iterator.next w e infer a state checking relation from next tohasnext with the expectedstate true andtheconsequence nosuchelementexception of violating this expected state as shown in figure b .
compared withexistingmethodsthatinferspecificationsfromtext ourapproach infersmore types ofand moreinformativeapi con straints.givenagraphrepresentation e.g.
abstractsyntaxtree ofaprogram welinktheprogramelementswiththeapientities in our api constraint knowledge graph.
by analyzing the api constraints in the knowledge graph that the linked program elements violate our approach reports api misuses and explain the detected misused by relevant api caveats see figure for an example .asaproofofconcept weapplyourapproachtojavasdkapi specification and construct a knowledge graph which contains 938call orderrelationsand74 207condition checkingrelations among methods and parameters and returnvalue conditions and exception trigger clauses.
using the statistical sampling method two developers independently annotatetheaccuracyoftheextractedapi constrainedrelations.
the annotation results confirm the high accuracy of the extractedinformationwithsubstantialtoalmostperfectagreementbetweenthetwoannotators.forthe239apimisusesinthe54java projects in the mubench our api misuse detector achieves inprecisionand28 inrecall.asacomparison existingpatternbaseddetectorsachieveabout0 .
inprecisionand0 .
in recall according to the systematic evaluation of these detectors .
weconductapilotuserstudywith12juniordeveloperswhoare askedtofindandfixthebugsinsixapimisusescenariosderived from the mubench.
the developers assisted by our api misuse warnings find and fix bugs much faster and more correctly than those using standard ide support.
the developers rate highly or in point likert scale the relevance and usefulness of our api misuse warnings not only for debugging api misuses but also for potentially avoiding them in the first place.
this paper makes the following contributions weanalyzetheknowledgegapbetweenapiusagecaveats and api usage patterns and how a knowledge graph approach may bridge the gap.
we constructthefirstapi constraint knowledgegraphwith four types of api constraint relations and build the first knowledge graph based api misuse detector.
our manual analysis confirms the high quality of the constructedknowledgegraph andourbenchmarkevaluation anduserstudydemonstratetheeffectivenessandusefulness of our knowledge graph based api misuse detection.
motivation examples to overcome the limitations of pattern based api misuse detection identifiedin weanalyzetheknowledgegapbetweenapiusage caveats and api usage patterns.
we focus on api usage caveats specifying call order and condition checking as violations of these caveats represent the most frequent api misuses .
we illustrate thegapwithtypicalexamplesandapiusagepatternsintheform of call sequences but the observed knowledge gap is not restricted totheseexamplesorspecificformsofapipatterns.wediscusshowaapi constraintknowledgegraphcanbridgethegap seesection3 for knowledge graph schema and construction method .
.
comprehensiveness apipatternsmaycoveronlysomeapiusagecaveats depending on api usage frequencies.
figure a shows a code example of java swing apis which satisfies the call order constraint the add method changes layout related information ... the component hierarchy must be validated thereafter in order to reflect the changes .
if there are enough code snippets like the one in figure a in a codebase add validate can be mined as an api pattern which helps to detect calling add without validate as a misuse.
besides add therearemanyotherlayout changingmethodslike remove a b figure example of java swing apis a !
.
?
a4 b c95 a2 da4 b c95 a2 de 2f d9f g ?
f d9 7h i a c9 ?
e b5 j a9 k1 g ?
d f i9 h i a c96 ?
?
a4 b c95 a2 d b figure example of java collections apis which have the same call order constraint.
however if the api call sequence panel.remove panel.validate isnotfrequentenough inthecodebase remove validate willnotminedasapattern and consequently cannot detect missing validate after remove .
if we model api usage caveats themselves rather than how frequenttheymanifestinacodebase wecanachievemorecomprehensive coverage of api usage caveats.
for example by analyzing the call order constraint of all layout changing methods we can constructaknowledgegraphlikefigure1 b whichcapturesthe call order relations from the method validate to all layout changing methods only add andremove is shown for the clarify .
based on this knowledge graph even there is no prior use of remove at all in the codebase we can still detect calling remove without validate as a misuse.
.
explainability apipatternsrepresenttheoutcomesoffollowingapiusagecaveats incode butoftencannotdistinguishwhysuchoutcomesemerge.
figure a shows a code example of java collection apis check that hasnext returns true then get the next element in the iteration and finally remove this element.
some patterns can be mined from such frequent use of collection apis such as hasnext next next remove or even hasnext next remove .
superficially theyalllooklikecall orderconstraints.however unlike add validate discussed in section .
there are no constraints about calling next orremove after hasnext ornext .
theactualconstraintresultsinthepattern next remove is next mustprecede remove otherwise remove throws illegalstateexception.theactualconstraintresultsinthepattern hasnext next isthatoneshouldcall hasnext tocheckthestateoftheiteration before calling next because if the iteration has no elements a l mn op qop r s tu v wop m x yz ymn op q wop m x sp qm wx sqo p p r s t sq mo a s bc d e fg hi d j k d ef g hi d j kd ef g hi d j kd e fl e m eg hi hm nfi ei h o pd h pq r s tuvw xl h pi hk yi ei h zn v rj ei rj s z skh x i j sk f wx phl i rj s sk h x i j sk f wx phl i rj snf i ei h o pd h pq r st uv wxl h pi hk yi ei h z v rj ei rj sz sk h x i j sk f wx phl i rj s m hi m svr i d h pd e m e pm hmkj hf sj ij p p m b figure example of java string apis a a a a a a a o o a o o o o b figure example of java io apis next throws nosuchelementexception.apipatternscannotdistinguishsuchfinedetailsofapicaveats.graph basedpatterns aremoreinformativethancallsequences butitisnotstraightforward to infer all fine details of api caveats from code.
in contrast we can analyze the natural language descriptions of api caveats to distinguish different types of api constraints and extract their fine details as shown in the knowledge graphin figure b .
due to the clear semantics of the state checking andcall orderrelations wewillnotreportcalling hasnext or next withoutthefollowing next orremove asamisuse.more important we can provide specific explanation of detected api misuses suchasmissingstatecheckingversusmissingpreceding call as well as the expected state and violation consequences.
.
best practices api patterns fundamentally assume frequencies reflect the rationality of api usage but this rationality may not correspond to the bestpracticesofhandlingapicaveats.
figure3 a showsacodeex ampleofjavastringapis substring indexof .thisapichaincall is frequent in code but it lacks a sanity checking of the indexof s returnvalue because indexof returns 1ifthechardoesnotoccur in the string and substring throws indexoutofboundsexception if its beginindex argument is negative.
as another example figure4 a showsacodeexampleofjavaioapis enclosefileopenand read operations in a try catch to handle ioexception which is also very common in code.
however this way of handling ioexception doesnotconsiderthespecificcausesoftheexception thefiledoes not exist or the file is a directory or an io error occurs .
by analyzing the description of return value conditions parameterconstraints exceptioncausesandapifunctionalities we can model and reason about the complex constraint relations between apis in the knowledge graphs in figure b and figure b .
for example by examining the chain call substring indexof 463464graphisthesameasthegenericapiknowledgegraphin we adopt their tested web page parser to extract api elements api namesanddescriptions anddeclarationrelationsasrequiredinour knowledgegraph seesection3.
.inthiswork weusethebrief introduction sentences of each method in the method summary section as that method s functionality description.
to detect the api misuses related to api chain calls e.g.
substring indexof weextendtheoriginalparserin toe xtract more fine grained return relations.
the return section of a methodmayhavemorethanonesentencetoexplaindifferentreturn values in different situations for example string.indexof returns the index of the first occurrence of the character in the charactersequence or 1ifthecharacterdoesnotoccur .based ontheobservationofthereturnsectionof1 000randomlysampled methods wedefineavaluegazetteerandasetofpart of speech pos tagpatternstorecognizespecificvalues e.g.
true false or ranges e.g.
negative mentioned in the return value sentences.ifareturn valuesentencecontainsaspecificvalueorrange we link the return relation to a value literal entity may need to becreatedifitisnotyetintheknowledgegraph .otherwise we create a return value entity with that sentence as its description and link the return relation to this return value entity.
.
deriving api constraint relations differentfromexistingapiknowledgegraphs thatcapture only declaration relations our api constraint knowledge graphcontainscall orderandcondition checkingrelationsbetweenrelated apis and constraint enriched return and throw relations.
we usetheapi caveatsentencepatternsdevelopedin toextract twocategoriesofapi caveatsentences temporal andconditional.
differentfrom thatsimplylinksapi caveatsentencestoapi elementsastextualattributes wedevelopsentenceparsingandapi linking techniques to derive four types of api constraint relations from api caveat sentences.
.
.
extracting api caveat clauses.
as this work focuses on apimethodusageconstraints welimittheextractiontothemaindescriptionofeachmethod excludingthefunctionalitydescription sentence of the method entity and the description in the method s return and throws section.
each extracted caveat sentence is associated with its corresponding method or return throw relation.
we processtheextractedcaveatsentencesintofine grainedapi caveat clauses by the following three steps to facilitate the subsequent api linking and constraint relation inference.
co referenceresolution.
apielementsareoftenmentionedby pronouns in api caveat sentences for example if the securerandomspi constructoris overriddenin animplementation it refer tosecurerandomspi willalwaysbecalledwheneverasecurerandom is instantiated .
we use co reference resolution technique as implementedbystanfordcorenlp toresolvethepronounsin aapi caveatsentencetotheapisthatthepronounsrepresentin the paragraph from which the sentenceis extracted.
furthermore theapimethodsbeingexplainedarecommonlyreferredtoas this method in its description for example this method is generally called...ifafatalerrorhasmadetheconnectionunusable inthe descriptionof javax.sql.pooledconnection.co referenceresolutiontools cannot resolve this type of co reference because the correspondingapidoesnotappearinthesurroundingtexts.weusethe declaration based heuristic to resolve such co reference to the api method being explained.
splitting sentencesinto clauses api caveat sentences can be rather complex.
for example filereader string filename throws filenotfoundexception if the named file does not exist is a di rectory or for some other reason cannot be opened for reading .
this sentence has a result clause and a long if clause that has three conditionclauses.toderivefine grainedapiconstraints weuse pos tagging and dependency tree analysis as implemented by standford corenlp to parse the whole sentence into several fine grained clauses.
a conditional sentence is split into a resultclauseandoneormoreconditionclauses.wealsotrytoidentify subject verb phrase and object in each clause using semantic role labeling .forexample wecanextractsubject verb objectin theresult clauseasfollows filereader stringfilename throws filenotfoundexception .
note that themissing subject e.g.
thenamed file for the2ndand 3rdconditions can be inferred by dependency tree analysis.
similar clause clustering.
one api caveat may be mentioned indifferentpartsofamethodinthesameorsimilarway.forexample the main description of string.indexof has a conditional sentence ifnosuchcharacteroccursinthisstring then 1isreturned and the return section of indexof has another conditional sentence indexof returns 1if the characterdoes notoccur .
these two sentences correspond to the same caveat.
furthermore a class may declare several overloading or similar functionality methods which often have the same or partially overlapping caveat sentence.
for example both string.indexof andstring.lastindexof have the caveat return if the character does not occur .
the overloadingmethods substring int beginindex int endindex and substring int beginindex havethesamecaveatclause thebeginindex is negative but also other different clauses.
we cluster similar caveat clauses by the word embedding based sentence similarity see section .
.
which has been shown tobe effective in matching software text .
the clustering is done progressively first within method then within class and finally within package.
clustering within method considersallcaveatclausesofamethod nomattertheirdocumentsection origin but clusteringwithin classorwithin package groupsonly the caveat clauses from the same type of document section.
we selectthecentroidsentenceinaclusterastherepresentativeofthe cluster.
if the cluster has only two sentences we select the shorter one.clusteringsimilarcaveatclauseshavetwobenefits.first we canassociateacaveatclausetoamorespecificapielement relation.
for example we can know that the conditional clause from the maindescriptionof string.indexof isactuallyrelatedtothereturn relation because a very similar clause is in the return section of indexof .second wecansignificantlyreducethenumberofcaveat clauses to be analyzed in the subsequent api linking step.
.
.
linking caveat clauses to api elements.
givenacaveatdescription a clause or its subject object phrase associated with a methodorathrowrelation weinfermethodsorparameterswhose functionality descriptions match the caveat description.
for example for the exception trigger clause the named file does not exist 465table1 rulesforcreatingcall orderorcondition checkingrelations p paramter vl value literal m method e parameter or method mc method of concern v c value checking s c state checking c o call order clause subject object value type relation example p vl the beginindex argument is negative p e theindexargumentisnotlessthanthelength of string 3m p the named file does not exis m1 m2 setsystemid string must be called before the startdocument event m temporal ifnext hasnotyetbeencalled intheremove s throws section m conditional if canundo returns false in undo s throws section 7m temporal the container must be validated thereafter in the main description of container.add 8m conditional iftheiterationhasnomoreelement inthenext s throws section ontherelation the subject the named file matches the description the name ofthefiletoreadfrom ofthe filereader string sparameter filename and the whole clause matches the functionality description offile.exists which states tests whether the file or directory denotedbythisabstractpathnameexists .basedonsuchmatches we linkthecaveatclauseoritssubject objecttomethodsorparameters that are referred to by the clause or its subject object or whose functionality can fulfill or check the clause or its subject object.
we perform the matching progressively first match parameters withinmethod thenmatchmethodswithinclass andfinallymatch methodswithinpackage.thematchingisdoneforthecaveatclause its subject phrase and object phrase respectively.
the whole clause may match a method and the subject or object phrase may match a parameter or a method.
if a subject or object phrase containsannotated code element e.g.
in code or href we directly link the subject or object to the corresponding api element byname matching.
otherwise we match a caveat description withthe functionality description of api elements by text similarity.
we select the api element whose functionality description has the highest similarity with the given caveat description within the current matching context.
if this highest similarity is above thesimilarity threshold .
in this work a matching is found.
if a matching is found within the current context the matching stops.
considering the sentence characteristics of caveat and functionalitydescriptions wecombinejaccardcoefficientandsentence embeddingsimilaritytomatchthem.wedenoteacaveatdescription ascdandafunctionalitydescriptionas fd.beforecomputingjaccardcoefficient weconverteachsentenceintoabagofwords bwcd andbw fd usingthestandardtextprocessingprocedure i.e.
tokenization stopwordremovalandlemmatization .then thejaccardcoefficientof cdandfdis sim jaccard bwcd bw fd bwcd bw fd.
tocomputesentence embedding welearndomain specificword embeddings with the corpus of api text descriptions from api reference documentation using the continuous skip gram model .
we use domain specific word embeddings because recent studies showthatdomain specificwordembeddingsoutperforms generalwordembeddingsforsoftwaretextmatching.wesettheword embedding dimension at as this setting has the best performanceonsimilarapitextcorpus .wecomputeasentence embeddingby averagingtheword embeddingsofall wordsinthe sentence.
let secdandsefdare the sentence embedding of cdand fdrespectively.thesentence embeddingsimilarityof cdandfdis the cosine similarity of secdandsefd i.e.
sim se cos secd se fd .
finally weaverage sim jaccardandsim seasthesimilarityofacaveat description and a functionality description.
.
.
creating api constraint relations.
given a caveat clause we analyze its api linking results and create a call order or conditionchecking relation according to the heuristic rules in table .
these heuristics rulesare summarizedbased onthe observation ofrandomlysampled1 000caveatclauses.forallotherapilinkingresults for example none of the clause subject phrase or object phrase is linked to an api element e.g.
an io error occurs associated withthe relation or only the subjectphraseislinkedtoaparameterofthemethod e.g.
thenamed file for some other reason cannot be opened for reading associatedwiththerelation thecaveat clause remains intact withits originally associated method or throw relation.
the first three rows in table cover the caveat clauses that describe the value or state validity of the parameters.
such caveat clauses are converted into value checking orstate checkingrelationsbetweenaparameterandavalueliteral between two parameters or between a parameter and a method.
the 4throwcoversthecaveatclausesthatexplicitlymentiontwomethodsanddescribecall orderconstraints e.g.
setsystemid string must be called before the startdocument event .
it is common that a caveat clause mentions only one method in its subject the 5th and 6th rows or the whole clause corresponds to one method the 7th and 8th rows .
in such cases the other method that is implicitly referenced is the method of concern i.e.
the method that this clause is associated with for example the caveat ifnext hasnotyetbeencalled forthe iterator.remove method or the container must be validated thereafter in order todisplaytheaddedcomponent forthe container.add method.
therefore we create a constraint relation between the explicitly mentioned method and the method of concern for the cases in rows5 .dependingonwhetherthecaveatclauseisatemporal 466or conditional clause we create either a call order relation or a state checking relation.
value literals are extracted by the value gazetteerandpostagpatternswedevelop.never seenvalueliterals will be added to the knowledge graph.
we also develop pos tag patternstoextractfrequently usedvalue checkingexpressionsand convert them into mathematical formula e.g.
as the expected expressions of the value checking relations.
if the caveat clause is associated with a throw exception we use thenegation of the formula as the expected expression.
if the clausedoes not have such frequently used value checking expressions we use the verb phrase of the clause as the expected expression.
for state checking relation if the linked method has some specific returnvaluewhosereturn conditionmatchesthecaveatclause we use this specific return value as the expected state such as true forhasnext checking before calling next .
otherwise we use the verb phrase of the clause as the expected state.
for the call order relation if the temporal clause has some guard condition clause e.g.
ifthecontainerhasalreadybeendisplayed forcalling validate we use this condition clause as the condition of the call orderrelation.ifthecaveatclauseisassociatedwithathrow relation the violation attribute of the created constraint relation