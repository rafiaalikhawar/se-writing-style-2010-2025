practical fault detection in puppet programs thodoris sotiropoulos athens university of economics and business theosotr aueb.grdimitris mitropoulos athens university of economics and business national infrastructures for research and technology grnet dimitro aueb.grdiomidis spinellis athens university of economics and business dds aueb.gr abstract puppet is a popular computer system configuration management tool.
by providing abstractions that model system resources it allows administrators to set up computer systems in a reliable predictable and documented fashion.
its use suffers from two potential pitfalls.
first if ordering constraints are not correctly specified whenever a puppet resource depends on another the nondeterministic application of resources can lead to race conditions and consequent failures.
second if a service is not tied to its resources through the notification construct the system may operate in a stale state whenever a resource gets modified.
such faults can degrade a computing infrastructure s availability and functionality.
we have developed an approach that identifies these issues through the analysis of a puppet program and its system call trace.
specifically a formal model for traces allows us to capture the interactions of puppet resources with the file system.
by analyzing these interactions we identify resources that are related to each other e.g.
operate on the same file and resources that should act as notifiers so that changes are correctly propagated.
we then check the relationships from the trace s analysis against the program s dependency graph a representation containing all the ordering constraints and notifications declared in the program.
if a mismatch is detected our system reports a potential fault.
we have evaluated our method on a large set of popular puppet modules and discovered previously unknown issues in modules.
performance benchmarking shows that our approach can analyze in seconds real world configurations with a magnitude measured in thousands of lines and millions of system calls.
ccs concepts software and its engineering software reliability software testing and debugging file systems management .
keywords puppet ordering relationships notifiers program analysis system calls permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
reference format thodoris sotiropoulos dimitris mitropoulos and diomidis spinellis.
.
practical fault detection in puppet programs.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction the prevalence of cloud computing and the advent of microservices have made the management of multiple deployment and testing environments a challenging and time consuming task .
infrastructure as code iac methods and tools automate the setup and provision of these environments promoting reliability documentation and reuse .
specifically iac boosts the reliability of an infrastructure because it minimizes the human intervention which is both laborious and error prone ensures the predictability and consistency of the final product because it eases the repetition of the steps followed to produce a specific outcome and allows the documentation and reuse of a system s configuration because it associates the system s configuration with modular code .
puppet is one of the most popular system configuration tools used to manage infrastructures .
it abstracts the state of different system entities such as files users software packages or running processes in a declarative manner using built in primitives called resources.
a puppet program consists of a collection of resources that the underlying execution engine applies one by one so that the system eventually reaches the desired state.
by default any execution sequence of resources is valid unless there are specific ordering constraints imposed by their interdependencies e.g.
an apache service should be run only after the installation of the corresponding package.
developers need to declare these ordering constraints in the program to avoid erroneous execution sequences such as trying to start a service before the installation of its package.
conceptually puppet captures all the ordering relationships defined in a program through a directed acyclic graph and applies each resource in topological ordering.
in this context all the unrelated resources are processed non deterministically.
furthermore puppet allows programmers to apply certain resources whenever specific events take place via a feature called notification.
notifications propagate changes to related resources ensuring that their state is up to date.
for instance when a configuration file changes the corresponding service has to be notified so that it will run with the new settings.
tracking all the required ordering constraints and notifications is a complicated task though mostly because developers are not ieee acm 42nd international conference on software engineering icse always aware of the actual interactions of puppet with the underlying operating system.
notably such errors can have a negative impact on the reliability of an organization s infrastructure leading to inconsistencies and outages .
for example github s services became unavailable when a missing notifier in their puppet codebase caused a chain of failures such as dnstimeouts .
approaches that automatically detect these mistakes in production code have significant room for improvement facing limitations that prevent them from being practical.
rehearsal employs static code verification to detect faults in puppet programs.
nevertheless it cannot manage realistic cases because it is unable to handle puppet resources that abstract arbitrary shell commands.
notably such resources e.g.
exec are highly pervasive as they appear in the of the top most widely used puppet modules found in the forge api .
additionally the model based testing approach adopted by citac imposes a significant overhead analyzing around modules with citac takes roughly days and restrictions on the supported puppet programs under test they must be able to run in docker containers .
it also requires extra instrumentation to be added in the execution engine of puppet.
finally none of those tools addresses missing notification faults.
we have developed a practical and effective approach to identify faults involving ordering violations and notifiers in puppet programs.
to do so we record the system call trace produced by a single puppet execution.
then we operate as follows.
first we model the system call trace of a puppet execution in a representation namely fstrace that allows us to precisely capture the interactions of higher level programming constructs puppet resources with the file system.
by examining their interplays we infer the set of the expected relationships of every puppet resource with each other.
these relationships correspond to either notifications e.g.
resource xshould notify resource y or ordering constraints e.g.
xshould run before y .
then for the given puppet program we statically build thedependency graph that reflects all the ordering relationships and notifications that have been specified by the developer.
finally we verify whether the expected relationships as specified from the analysis of traces hold with respect to the dependency graph.
unlike previous tools our approach can reason about which system resources are affected by the program s execution and how and requires only a single puppet run for discovering issues.
contributions.
our work makes the following contributions we introduce fstrace a representation for system call traces that models the intricate semantics of system calls and their effects on the file system.
building upon fstrace we propose a novel trace analysis that allows us to infer the inter relationships among puppet resources section .
we provide a framework and its open source implementation for detecting faults regarding ordering violations and notifiers in puppet programs.
to the best of our knowledge it is the first to deal with issues involving notifiers sections .
we demonstrate the effectiveness and performance of our tool on puppet modules.
specifically our tool was able to detect previously unknown faults in modules including wellestablished ones.
more than a half of the issues out of were confirmed and fixed by the developers.
this implies thatour tool is capable of discovering faults that are useful to the puppet community section .
availability.
the source code of our implementation is available as open source software under the gnu general public license v3.
at the artifact is available at overview we provide a brief overview of puppet two motivating examples that demonstrate the types of errors our approach detects and how our approach is structured.
puppet.
puppet allows developers to describe the desired state of a system through a declarative specification language.
for example service name apache2 conf file etc apache2 apache2.conf package service name ensure installed file conf file ensure file service service name ensure running the code above indicates that the apache2 package should be installed in the host the file apache2.conf should exist in the etc apache2 path and that the apache server should be running.
there are diverse types for abstracting system resources including file package service exec .
also the puppet language provides variable declarations that begin with the symbol e.g.
service name conf file conditionals loops and for reusability supports the creation of custom resources and classes.
puppet code is stored in files called manifests.
puppet compiles manifests into executables called catalogs.
catalogs are json documents that specify all the resources that puppet needs to apply in a particular system to reach the desired state .
the following json snippet shows a part of the catalog derived from the previous puppet code resources title etc apache2 apache2.conf type file parameters ensure file another resource... the field resources contains the puppet resources declared in the initial program along with their parameters.
during catalog compilation every variable defined in the manifests resolves to its value e.g.
the variable conf file resolves to etc apache apache2.conf line of the earlier puppet code .
puppet evaluates the compiled catalogs and applies potential changes if the system is not in the appropriate state.
for example if a file does not exist at a certain location puppet will create it.
motivating examples.
we present two examples of faulty programs that demonstrate the issues that our approach addresses.
missing ordering relationships mor occur when a developer fails to define a happens before relation between two puppet resources that depend on each other.
this can lead to unstable code that behaves correctly in some circumstances but breaks in others depending on the order in which puppet processes resources.
consider the real world puppet program shown in figure that sets up the mysql database in a server.
first the code declares the installation of the mysql server package line which among other things creates the etc mysql my.cnf file that contains the default database settings.
then it configures this file lines package mysql server ensure installed file etc mysql my.cnf ensure file content user db settings... require package exec initialize mysql db command mysqld initialize require package figure a program missing an ordering relationship.
package ensure latest file etc apache2 apache2.conf ensure file require package service apache2 ensure running subscribe file figure a program missing a notifier.
whose contents are specified by the content parameter at line .
note that puppet evaluates the file resource after package .
this is expressed through the require property at line .
in lines to the program declares the execution of a shell script mysqld initialize that prepares the database according to the settings specified in the etc mysql my.cnf file.
although the shell command needs to be invoked only after the file etc mysql my.cnf is configured lines the require parameter at line omits this dependency.
therefore applying the exec resource before file makes puppet set up the database with incorrect settings.
a static analyzer such as rehearsal cannot extract this dependency because it is unable to infer that the underlying shell command mysqld initialize consumes the database configuration file.
missing notifiers mn .
notifiers are necessary for services.
an update to a resource e.g.
configuration file could directly affect the state of a service.
to ensure that all services are running on a fresh environment puppet triggers the restart of a service whenever there is a change to one of the service s dependent resources via notifications declared by the programmers.
a missing notifier issue is illustrated in figure .
the code first installs the latest version of the libssl andapache2 packages line configures the file located at etc apache2 apache.conf lines and then boots the apache server lines .
the subscribe primitive line creates a notifier that restarts apache whenever there is a change to the corresponding configuration file or an update to the apache2 package e.g.
a newer version is installed in the system .
however the code lacks a notifier from the libssl package to the apache service.
a change to libssl requires the restart of apache so that the server maps the updated version of the library to its memory i.e.
apache maps the usr lib libssl.so file created during the installation of the libssl package .
failing to do so makes the server not get the latest updates or security patches of the library.
once again a static analyzer is not capable of inferring such dependencies i.e.
the fact that apache depends on usr lib libssl.so because they are hidden from the corresponding manifests.
executor faultfault detectoranalyzer parser interpretertrace catalog fstracerelationshipsmanifestfigure the architecture of our framework.
framework.
to address these issues we propose a framework illustrated in figure that consists of the following components.
the executor applies the puppet manifests given as input by invoking the actual puppet execution engine.
also the executor intercepts puppet as follows.
first it stores the compiled catalog of the program before it is applied to the system and second it monitors the system calls of the puppet process and its descendants generating the system call trace that stems from the catalog application.
the analyzer section operates on the system call trace produced by the executor and performs two steps.
in the first step parser the analyzer splits system calls into different blocks corresponding to the execution of every puppet resource defined in the initial program.
then it parses the system call trace and transforms it into an fstrace representation which is used to model the semantics of every system call and their effects on the file system.
in the next phase interpreter the analyzer evaluates the resulting fstrace program and infers the set of relationships i.e.
ordering constraints and notifications between the declared puppet resources.
to do so it inspects their interactions with the file system in terms of the files consumed produced expunged by their execution.
finally the fault detector section first builds the dependency graph by examining the parameters of every puppet resource specified in the compiled catalog given as input.
the dependency graph is a directed acyclic graph that contains all the actual ordering relationships and notifications declared in the original puppet program by the programmer.
then the fault detector compares the generated graph against the expected relationships inferred from the output of the analyzer.
if a mismatch is identified the fault detector reports a potential fault.
trace example.
in order to generate traces the executor employs a system call tracing program namely strace .
figure presents an excerpt from the trace of the program of figure .
each line denotes an invocation of a system call along with the process pid that triggered it.
for example the entry close states that the process with id invoked close with as an argument and that system call returned .
by further inspecting figure we observe that puppet initially processes theexec resource lines and then thefile resource lines .
observe the calls of write at lines that correspond to messages printed to the standard output by puppet engine for debugging purposes.
these messages indicate the points where the application of each resource starts and ends respectively.
the analyzer exploits these points to classify system calls according to the puppet resource they come from section .
.
write info stage exec starting to evaluate the resource execve usr sbin mysqld ... clone child stack null flags clone child cleartid clone child settid sigchld child tidptr 0x7f70159c39d0 open etc mysql my.cnf o rdonly read default content... ... write info stage exec evaluated in .
seconds write info stage file starting to evaluate the resource open etc mysql my.cnf20190128 15kba2r o rdwr o creat write db settings... ... close rename etc mysql my.cnf20190128 15kba2r etc mysql my.cnf write info stage file evaluated in .
seconds figure an example of trace produced by the strace utility.
analyzing system call traces to tackle the complexity and interactions of realistic system call traces section .
we design our trace analysis as an interpretation over a trace language used to abstract each system call and map it to the puppet resource it comes from section .
.
the output of the analysis is the set of the expected relationships ordering constraints and notifications among declared resources.
to produce this output the analysis examines the file system interactions stemming from puppet execution in terms of the files that are consumed produced or expunged section .
.
the analysis output is later used by our fault detector section .
.
motivation of design choices previous work on trace analysis has focused on extracting dependencies from build scripts e.g.
make for c c programs for testing and refactoring purposes or identifying license inconsistencies in software projects .
these approaches cannot apply to the domain of puppet for the following two reasons.
low fidelity.
typically the system call traces that come from the execution of puppet manifests are far more complex than those of build scripts.
indeed puppet traces involve the application of diverse entities such as execution of arbitrary scripts configuration and management of different services installation of packages and more that apart from simply reading and writing files they perform many operations on the transient os structures e.g.
file descriptor table process table etc.
.
for a precise trace analysis e.g.
correctly resolving the absolute file paths that a system call works on we need to accurately track all the operations performed on these structures.
this requires a careful design to deal with the complexities and semantics of the system calls as well as the underlying structure of the file system.
for instance many processes spawned by puppet share their file descriptor table or working directory with their child processes.
hence any update to any of those entities performed by one process also affects the other one.
by ignoring this behavior processes will hold stale information about their file descriptor table and working directory.
as another example consider the following trace open usr lib perl5 o rdonly rename usr lib perl5 usr lib perl openat .
socket6.pm o rdonly 1for example in linux this can be achieved through the clone fd andclone fs flags passed in the clone system call.to determine the absolute path that openat operates on usr lib perl .
socket6.pm we have to interpret the file .
socket6.pm relative to the directory related to the file descriptor .
to do so we need to consider that in a unix like file system every file is associated with an inode rather than a path.
thus the file related os structures e.g.
file descriptor table have to refer to inode s instead of path names.
although the correct resolution of absolute paths is an important issue existing approaches ignore the organization of the file system.
for example they either cannot resolve the absolute path of the openat system call they do not support file descriptors or they describe files through their paths .
the latter makes the corresponding file descriptor table hold the stale entry usr lib perl5 after the rename at line .
granularity.
given the system call trace of a build script such as make previous approaches assume that every build operation is performed through a separate process .
in this context the analysis estimates the dependencies among source files e.g.
the object file foo.o depends on the header file bar.h by computing the files read and written by each process and taking into consideration that each output file depends on every input file.
to verify the inferred dependencies the existing work triggers incremental builds by touching the input files and then checks whether the output files are indeed changed in response to the updates of their dependencies.
however the granularity of processes is not effective for domains such as puppet where the same system process may involve different operations puppet resources .
in such cases the existing work is not able to distinguish which file system resources are affected by which operation puppet resource and therefore it is unable to infer the precise inter relationships among execution steps puppet resources .
we design an approach on analyzing system call traces that overcomes the limitations of the previous approaches as follows.
to tackle low fidelity we introduce fstrace a representation that enables us to translate every system call into primitives that conquer the large number and complexity of posix unix linux system calls by decomposing them into simpler building blocks section .
and formally model the effects of system calls on the file system and the transient os structures section .
.
.
to address granularity we split the main process that governs the execution puppet process into different blocks that indicate the boundaries of every operation puppet resource .
this allows 29us to infer the inter relationships between all puppet resources by examining their interactions with the underlying operating system section .
.
.
in turn this enables us to combine as explained in section the trace analysis output low level analysis with the program s relationships inferred statically by analyzing compiled puppet catalogs high level analysis .
this makes our approach efficient as we are able to detect faults by monitoring only one puppet execution i.e.
we do not need to apply puppet manifests multiple times as in the case of incremental builds to verify the relationships extracted by the trace analysis.
note that our treatment of system call traces is generic and can be applied to other domains such as make or java maven.
in this case the boundaries of every execution phase correspond to the application of every build rule.
.
modeling system call traces the first step of our analyzer is to parse a given system call trace and transform it into an fstrace representation.
fstrace primitives are designed to model system calls that operate on file system resources.
some of the constructs are generic enough so that they can represent a family of system calls.
complex system calls are represented with a number of fstrace primitives something that decouples their intricacies from each other.
we group system calls into execution blocks and we assign a unique idto each of them.
the syntax of fstrace is shown in figure .
it consists of file names paths which are sequences of file names and file descriptors represented by either an integer or the at fdcwd construct.
we also include the constructs fdandcwdthat indicate what kind of entities a spawned process shares with its parent primitives consumed produced expunged that stand for the types of the effect that a system call has on a file and an infinite set of unique identifiers for execution blocks.
a trace is a sequence of blocks.
a block has the following syntax begin b z s end where bis its id and z s is a sequence of trace entries.
each pair z s is a process id pid which is a positive integer and a system call.
fstrace models every system call s sysusing eleven constructs.
we have setcwd that changes the working directory of the current process and three primitives for performing operations on file descriptors newfd creates a new file descriptor and relates it to the given path p delfd deletes the provided file descriptor from the corresponding table of the process and dupfd copies a given file descriptor and is used to model a number of system calls such asdup like system calls or fcntl fd f dupfd .
fstrace supports hard and symbolic links through the link andsymlink constructs respectively while it offers newproc for spawning new processes.
fstrace models operations on file paths explicitly through the hpath primitive.
hpath d p m captures the effect mthat a system call has on the path p. we consider prelative to the file descriptor d when pis not an absolute path.
when disat fdcwd we interpret pas relative to the current working directory.
hpath models the system calls that work on file paths.
for instance we represent the system callmkdir foo bar which creates a new directory at path foo bar ashpath at fdcwd foo bar produced .
the hpathsym primitive operates in a way similar to hpath .
inhpathsym though if the given path is a symbolic link we do not dereference it.
through hpathsym we express system calls that do not follow symbolic links such as lstat lchown lgetxattr .
the rename primitive arranges that an existing path is accessed through a new file path.
finally f f z z proc z b blocki d v file p path v e t race x x block begin b z s end s sys delfd f dupfd f1f2 hpath d p m hpathsym d p m link d1p1d2p2 newfd d p f newproc c f rename d1p1d2p2 setcwd p symlink d p1p2 nop m ef f consumed produced expunged c fla s fd cwd d dir fd f at fdcwd figure the syntax of fstrace.
1begin exec 103hpath usr sbin mysqld consumed execve 650newproc clone 660hpath at fdcwd etc mysql my.cnf consumed open 660newfd at fdcwd etc msql my.cnf open 660nop read 7end 8begin file 103hpath at fdcwd etc mysql my.cnf20190128 15kba2r produced open 103newfd at fdcwd etc mysql my.cnf20190128 15kba2r open 103nop write 103delfd close 103hpath at fdcwd etc mysql my.cnf20190128 15kba2r expunged rename 103hpath at fdcwd etc mysql my.cnf produced rename 103rename at fdcwd etc mysql my.cnf20190128 15kba2r at fdcwd etc mysql my.cnf rename end figure the fstrace representation of the trace of figure .
fstrace has a dedicated construct nop to model all system calls e.g.
write sync that we do not need to take into account.
to leverage fstrace the analyzer classifies system calls according to the applied puppet resource that triggered them.
our analyzer presumes that an execution block begins or ends when the evaluation of the corresponding resource starts or terminates because puppet processes every resource atomically.
in this context the name of the execution block corresponds to the name of the puppet resource.
it is easy to identify the points where the evaluation of a puppet resource starts finishes by decoding the puppet s debug messages.
recall from figure that those messages appear in the execution traces as writes to the standard output.
during trace parsing the analyzer detects those debug messages and marks them as the entry and exit points of execution blocks.
for example consider again the trace in figure .
we can model the trace entry at line as the entry point of an execution block whose name is exec whereas the system call at line signals the ending of that execution block.
hence all system calls that appear between lines and are included in this block.
figure shows the complete fstrace representation of the trace shown in figure .
notice that some system calls are represented through a number of fstrace primitives.
for instance we model open etc o rdonly with hpath to indicate that we consume the file etc and newfd to associate the provided path with the file descriptor returned by open.
.
interpreting fstrace programs to infer the ordering and notification relationships among puppet resources the analyzer enumerates the set of files consumed produced or expunged in every execution block.
this is done by interpreting the fstrace program produced by the parser section .
.
i n ode i i z r ident i i z i n odet i n ode filename i n ode fdt ident f i n ode proct proc ident ident cwdt ident i n ode symt i n ode path f sacc path p ef f blocki d figure semantic domains for fstrace.
.
.
domains and semantics.
we define a semantics for fstrace that we use as a base for our interpretation.
figure illustrates the semantic domains of fstrace.
the fstrace state consists of six components an inode table inodet is a map of a pair consisting of an inode and a file name to another inode .
the first element of the pair is the inode of the directory where the file name exists.
an inode is a positive integer that acts as the identifier for a certain file system resource.
note that we also keep the special inode rwhich corresponds to the inode of the root directory .
a file descriptor table fdt maps an identifier and a file descriptor to an inode .
we use this component to map the open file descriptors of a process to the resource they handle.
the cwdt element maps a unique identifier to an inode.
that inode stands for the current working directory of a process.
each process points to a pair of unique identifiers see the domain proct .
the first element of the pair is the identifier corresponding to the file descriptor table of the process.
the second element of the pair reflects the identifier that stands for the current working directory of the process.
this part of the state allows us to model the case where two different processes might share the same file descriptor table or working directory.
for example in the following entries the processes z1andz2 point to the same file descriptor table because the first elements of their pairs are identical 1 .
similarly since their second identifiers do not match 2 3 we presume that they do not share the same working directory thus any change imposed by one process does not affect the other one.
we use the table symtto store symbolic links.
each symbolic link is an inode that points to a file path.
the last component of fstrace fsacc maps path names to an element of the power set of blocks and effects.
specifically this component tracks where and how each path is accessed.
for example the entry foo produced b1 consumed b2 indicates that the path foo is produced in the block b1and consumed in b2.
we exploit this component later on to extract the ordering and notification relationships of every block with each other.
the state is a tuple consisting of the six components described above.newproc share e z newproc fd cwd f 1 2 z b e dupfd e z dupfd f1f2 z 1 f1 b e hpath e z hpath d p m m expunged p ab d p .
.
.
p i p p undef b e figure a subset of the interpretation rules of fstrace.
figure shows a small subset of the interpretation rules of fstrace.
each rule defines state transitions as follows b e the relationb e indicates that given a trace entry e a pair of apidand a system call in execution block b the initial state transitions to a new state .
the binary operator denotes the addition of an element to a set while imanifests the projection of the ithelement.
the function ab d p .
.
.
gives the absolute path of the path prelatively to the given file descriptor d. the function i p computes the inode that the path ppoints to based on the inode table .
for example the rule records the effect mthat a system call has in the current execution block bby updating the component of the state.
.
.
inferring relationships.
based on the state derived from the interpretation of an fstrace program we now formally define the ordering and notification relationships between two puppet resources.
to achieve this we exploit the computed file accesses performed in every block as defined in the resulting state fsacc .
recall that the component shows the set of files that are consumed produced and expunged inside every execution block.
ordering relationship.
for ordering relationships we consider that a block b1producing a certain file pmust precede a block b2that consumes or expunges the same file p. if this is not the case and assuming that b2does not create p there is an ordering violation.
formally given the instance found in the fstrace state we define the ordering relationship which states that the block b1comes before b2 as follows b1 b2 p path m e f f .m produced produced b1 p m b2 p produced b2 p consider again the program of figure .
after interpreting it the analyzer outputs the following relationship file exec where exec stands for the block exec lines while file corresponds to file lines .
in particular exec consumes the file etc mysql my.cnf at line while file produces the same file at line .
according to 31beforebeforee xec confpac kagefigure the dependency graph of the program of figure .
the definition the creation of the file must be processed fist so the analyzer presumes that the block file must precede exec.
notification relationship.
in order to define the notification relationship we first need to identify pairs of execution blocks where the application of the first element should trigger the application of the second one.
in the context of puppet such relationships involve service resources.
specifically we look for blocks that produce a particular resource p. these blocks must have notification relationships with service oriented blocks consuming the resource p. formally based on the component fsacc of the state we introduce the notification relationship that represents that the block b1notifies b2 b1 b2 p path m e f f .isservice b b1 produced p b2 consumed p detecting faults having introduced our approach for analyzing traces we locate faults in puppet manifests by combining the analysis output with the compiled catalog of a program.
our fault detection method performs two tasks given a catalog it builds the dependency graph a directed acyclic graph that captures all the ordering relationships and notifications declared by the developer section .
and then it verifies that the relationships inferred by the trace analysis step appear in the dependency graph section .
.
.
dependency graph construction we define the dependency graph as dg v e where vis the set of puppet resources e v v lis the set of edges and l before notify a set of labels that we assign to every edge.
an edgebefore from a source node sto a target tindicates that puppet applies sbefore t. an edgenotify denotes that apart from preceding t salso notifies the target whenever there is an update to itself.
when a node tis reachable from s we presume that the application ofshappens before that of t. on the other hand a node notifies a target when they are connected with a path where all edges are notify .
this is explained by the fact that thenotify edges transitively trigger updates to all the intermediate nodes between the source and the target resource.
to construct the graph we parse a program s catalog and we examine the parameters of every puppet resource recall section .
specifically given the parameters of a resource p we create edges as follows.
phas the parameter before v .
this indicates that the resource pis applied before every resource included in the valuealgorithm detecting faults require f sacc dg for all b1 b2 v vdo ifb1 b2and not haspath b1 b2 then report mor between b1 b2 end if ifb1 b2and not hasnotificationpath b1 b2 then report mn from b1tob2 end if end for of before .
in this case we add abefore edge from pto every element of the list v. phas the parameter require v .
this indicates that puppet processes pafter every element included in the value of require .
thus we create abefore edge from every element of vtop.
phas the parameter notify v .
the same as the before parameter but this time we createnotify edges.
phas the parameter subscribe v .
the same as the require parameter but this time we createnotify edges.
figure depicts the dependency graph of the program of figure .
we observe that the configuration file i.e.
the node conf has neither an ordering nor a notification relationship with the service because the corresponding nodes are not connected to each other.
.
fault detection algorithm summarizes our fault detection approach.
the algorithm expects as input the relationships of every puppet resource as specified by the analysis of traces and a dependency graph dg generated by the previous step.
for every ordering relationship between two resources b1 b2 the algorithm consults the dependency graph to determine whether there is path from b1tob2 i.e.
it checks whether this ordering relationship actually appears in the program.
if this is not the case the algorithm reports a missing ordering relationship that is b1must be applied before b2.
to identify missing notifiers the algorithm operates in a similar manner.
in this case though the algorithm is interested in paths that contain onlynotify edges i.e.
the function hasnotificationpath line .
as as an example recall that the analyzer yielded the file exec relationship when it examined the trace file of figure .
the algorithm verifies this relationship by viewing the dependency graph of figure .
it then reports a missing ordering relationship because there is not a path from file toexec.
remark observe that our approach does not make any assumption about the execution order imposed by puppet i.e.
it does not require the resources with missing ordering relationships to be applied in the right order so that it infers their inter dependencies.
it is clear from the example trace of figure where puppet executes resources in the erroneous order that our method is still able to observe that exec depends on file and eventually report the fault.
implementation we have developed a prototype that implements our approach in ocaml.
the tool provides a command line interface and takes as input the path where the main puppet manifest is located.
it then stores the compiled catalog of the program and executes it using 32strace to collect the system call trace.
in turn the tools employs the trace analyzer and fault detector as described in sections and .
we have implemented our method with efficiency in mind.
our tool is able to handle gb sized traces with reasonable time and space requirements see section .
.
this was made possible through a number of optimizations such as the use of streams to process and analyze traces a reversed inode table to lookup paths based on their inodes and function memoization.
currently our tool has only been tested on linux distributions.
applying our approach to other platforms i.e.
by modeling the corresponding system calls to fstrace is straightforward.
also as we discuss this in section our tool may produce false positives when two puppet resources operate on the same file but they are commutative to each other i.e.
the application order does not matter.
even though commutative pairs are not so common see section .
we plan to address this issue in future work by examining puppet catalogs to identify such pairs.
for instance we could identify resources whose execution is conditional and depends on the presence of conflicting resources.
evaluation we evaluate our framework by examining a large number of puppet modules in order to answer the following research questions.
rq1 is the proposed approach effective for finding faults in puppet manifests?
section .
rq2 what are the main patterns of the detected faults?
section .
rq3 what is the performance of our approach?
section .
.
experimental setup we collected a large number of puppet modules taken from forge apiand github.
we were particularly interested in non deprecated modules that support debian stretch because debian is one of the most popular linux distributions .
we inspected the top modules returned by the forge apithat satisfied our search criteria.
we used docker to spawn a clean debian environment efficiently.
then we automatically ran every module separately through the include module name statement.2we monitored the puppet process and collected the system call trace of every program via strace .
through this process we successfully applied puppet modules in total.
the remaining modules failed because they required extra arguments or further setup before their invocation.
for example many of the failing modules required multiple preinstalled packages or in other cases we needed to infer specific values for the modules arguments including ips of dnsservers and urls of specific upstream directories.
note that the failing modules and the successful ones were pretty similar in terms code size popularity and age in puppet forge.
also the list of the successfully analyzed modules contains well established ones including modules developed by popular organizations such as puppet inc. and vox pupuli.3finally for every puppet module that succeeded we 2include applies all the resources defined in the module using the default settings.
3vox pupuli is a big community that is currently managing and maintaining more than one hundrend puppet modules.
faults found in puppet modules.
each table entry consists of the name of the module the number of faults detected by our tool and a check mark indicating whether our fixes were accepted by the module s developers.
numb er of faults fix module total mor mn accepte d 1pupp et proxysql 2istlab ster eo 3olivierha influxdb 4hetzner fileb eats 5geoffwilliams auditd 6coreyh metricbeat 7coreyh packetbeat 8norisnetw ork packetbeat 9slashbunny phpfpm nogueirawash mysqlser ver cirrax do vecot nextrevision flowtools deric zo okeeper albatr ossflavour os patching hardening os hardening vpgrp influxdbrelay pupp et collectd sgnl05 sssd jgazele y freeradius saz ntp walkamongus co dedeploy spynappels support sysstat roshan mysqlzrm pupp etfinland nano noerdisch codeception baldurmen plymouth saz lo cales alertlogic al agents puppet telegraf pupp etlabs apache example42 apache alexharvey disable transparent hugepage campto camp ssh total ran each step of our approach trace analysis and fault detection and logged the reports generated by our tool.
to compute the performance of our approach we ran the trace analysis and fault detection steps ten times to get reliable measurements.
by examining the standard deviation we observed that the running times did not vary significantly among different executions.
all the experiments were run on a machine with an intel i7 .2ghz processor with logical cores and 16gb ofram.
.
fault detection results our framework detected previously unknown faults in puppet modules.
table presents the analysis results for each module.
to the best of our knowledge this is the first study that led to the disclosure of such a large number of faults in puppet repositories.
our tool marks out of faults as missing ordering relationships column mor .
the remaining faults are related to missing notifiers column mn .
remarkably our tool found faults in modules that are widely used by the puppet community e.g.
puppetlabs apache 9000k downloads and deric zookeeper 4500k downloads .
based on the reports of our tool we manually verified that each reported fault can lead to a problematic situation by reproducing package path tmp al agent exec download command usr bin wget o package path pkg url package al agent ensure installed provider dpkg source package path figure an ordering violation between package and exec.
each case.
specifically we repeatedly applied every manifest in a clean container until puppet applied resources in the wrong order leading to a failure or an inconsistent state.
only few trials were needed for that.
in turn we submitted fixes to the developers.
the development teams of projects confirmed and fixed issues in total.
the developers welcomed our patches.
notably in some projects e.g.
deric zookeeper slashbunny phpfpm cirrax dovecot and more the developers provided instant bugfix releases after the approval of our patches.
this indicates that our tool detects faults that are meaningful to developers.
.
fault patterns below we categorize and discuss some of the faults identified by our tool.
most represent previously unknown to us fault patterns which we learned through our tool.
notably these detected faults can lead to crashes inconsistent states and data loss.
.
.
missing ordering relationships.
we have observed three types of missing ordering relationships issues.
generate use violation.
the use of a resource must always succeed its creation.
many modules fail to preserve that ordering relationship.
consequently the execution of puppet may complete with failures when resources are applied in an erroneous order.
we observed this violation in puppet modules such as alertlogic al agents hardening os hardening and more.
figure shows a fragment from alertlogic al agents .
the code first fetches a .deb package a debian archive using the wget command lines .
the package is stored in the path specified by the package path variable whose value is tmp al agent .
then the code installs the debian archive on the system lines through the dpkg package management system.
it is easy to see that the package depends on the exec because it requires package path the .deb file to exist in the system line so that it can install the package successfully.
otherwise when puppet processes package before exec the application of the catalog fails with the following error dpkg error cannot access archive tmp al agent no such file or directory .
configure use violation.
the configuration of a file must precede its use.
for example when a service starts all the files consumed by that service have to be properly configured.
this category differs from the previous one because when a puppet resource attempts to use the file the latter exists in the system.
however this is not in the expected state e.g.
the file does not have the right contents permissions etc .
this error pattern appears in five modules including saz locales istlab stereo andvpgrp influxdbrelay.figure illustrates a program with an issue related to this category.
when the shell script is invoked the configuration file is guaranteed to be there because package creates it during installation.
however it is possible that exec does not read the desired contents of the etc mysql my.cnf file specified by content user db settings.. line because there is a missing ordering relationship between file andexec .
note that this category unlike the previous one may lead to errors that are difficult to debug as the application of the catalog does not produce any error messages.
api misuse.
many puppet modules expose an apithat other modules rely on to build their functionality.
these apis may establish some constraints that the dependent modules need to respect to achieve the intended functionality.
as with traditional software failing to do so can have a negative impact on the reliability of applications.
in particular in puppet apimisuses can lead to missing dependencies and race conditions.
eight modules such as puppet proxysql do not properly use the apiof their dependencies causing the ordering violations reported by our tool.
for example the puppetlabs apt module provides an interface for managing apt4sources and keys.
the apiof this module includes among other things the apt source resource and the apt update class.
the former is used for adding new repositories to the list of aptsources while the latter retrieves all the essential information about the newly added repositories by executing the apt update command.
the puppet proxysql module employs the apt source resource to add the repository from which it installs proxysql via the package resource .
the documentation of the puppetlabs apt sapi states if you are adding a new source and trying to install packages from the new source on the same puppet run your package resource should depend on class as well as depending on the apt source resource .
however the developers of puppet proxysql consider only the apt source dependency in their code i.e.
they omit the class dependency.
as a result the code may crash with an unable to locate package proxysql message when puppet tries to install proxysql before invoking the apt update command first.
the developers of puppet proxysql immediately confirmed and fixed this fault.
.
.
missing notifiers.
we have identified three different categories of issues related to notifiers.
configuration files.
a configuration file must always send notifications to a service so that any change to that file triggers the restart of the corresponding service.
although this is a standard pattern we observed that in six modules shown in rows of table this is not the case.
log files.
typically services log various events in dedicated files.
for instance the log file of an apache server records every incoming http request.
log files are essential for debugging and monitoring purposes .
when a service starts it opens a corresponding log file which remains open while the service is up to write any events that take place.
we discovered issues related to logging in two popular puppet modules puppetlabs apache and deric zookeeper .
these trace size mb 010203040analysis time s figure the trace analysis and fault detection time as a function of the trace size.
each spot shows the average time spent on both the trace analysis and fault detection phases for a given trace obtained by the execution of a module.
modules declare the log files for the apache andzookeeper services in their manifests.
however the log files do not have a notifier for their associated services.
this may lead to data loss.
consider the case where the log file of a service is removed or renamed.
when we remove or rename an open file the underlying system call unlink orrename only changes the file entry not the inode .
this means that although the filename disappears from the file system and puppet creates a new one the service still uses a file descriptor that points to the inode of the original file.
the issue is that after removal the inode typically becomes an orphan i.e.
it is not linked with any file which means that it is no longer accessible through a file path.
therefore in the case of a missing notifier the log history of the upcoming events is lost because the service writes to an orphan inode .
to fix that issue the log file should notify the service so that the service opens the newly created log file.
the developers of both projects confirmed this kind of fault.
packages.
when puppet applies a package resource the service that depends on that package should restart.
this ensures that a service gets all the necessary updates including security patches new features and more.
our tool identified this kind of issue in twelve modules including example42 apache and puppet telegraf .
specifically the package resources that are responsible for installing apache and telegraf do not notify the running instances whenever there is a new version of those packages.
.
performance figure shows the running times in seconds of the trace analyzer and fault detector relatively to the size of the provided traces in mb .
we observe that the correlation between the trace size and analysis time is almost linear.
notably our framework is able to handle a large volume of traces more than .2gb in a reasonable amount of time seconds .
the average trace size and analysis time of the inspected modules is 72mb and seconds respectively.
there are cases out of where the execution times were relatively high compared to the remaining modules.
however they all remain in acceptable limits.
by examining the characteristics of the traces coming from these modules we observed that they contain more unlink system calls than the rest of the modules.
such calls involve more expensive operations on the analysis state.
for collecting traces using strace our tool imposes a .
times slowdown on puppet on average.
unlike existing work though our approach requires only a single puppet execution to locate faults.
overall we argue that the overhead of our tool is relativelysmall and our approach can be used as part of the testing process for puppet manifests.
.
false positives beyond the actual faults listed in table we have identified false positives in out of puppet modules.
fourteen false alarms are related to commutative resources reported as missing ordering relationships.
for example in the claranet varnish module the developers use two different resources to partially configure a certain file.
on the one hand they use file to set the permissions and ownership of the file and on the other they use exec to initialize its contents.
in this case the execution order in which puppet processes resources does not matter.
specifically puppet can first useexec to create the file with the desired contents and then apply file to set the appropriate file s attributes or vice versa.
however as observed in the inspected modules configuring a file through the combination of resources is not particularly common.
only three false positives are associated with missing notifiers.
the developers of bodgit dbus use a custom command expressed via exec to reload the configuration of the service.
consequently the configuration files notify the exec resource instead ofservice .
we did not observe this case elsewhere because puppet programmers typically employ the restart parameter of the service type to define a custom restart command in the following manner service restart custom cmd .
.
.
.
related work our work is related to three research areas namely quality in iac trace analysis and modeling of file systems operations.
quality in iac.
with the proliferation of the iac process there have been numerous attempts to identify defects and quality concerns in configuration code.
a number of studies focus on maintainability issues.
sharma et al.
design and implement a code smell detection scheme for puppet which searches for issues related to naming conventions code design indentation etc.
their findings suggest that such anti patterns as in the traditional programs exist in many iac repositories.
van der bent et al.
introduce a quality model for puppet programs which is empirically evaluated by interviewing practitioners from industry.
schwarz et al.
do similar work focusing on chef recipes.
endeavors have recently moved to the identification of security issues.
rahman et al.
define and classify security smells into seven categories such as hard coded passwords use of weak cryptographic algorithms and then build a tool for statically detecting these smells in puppet repositories.
other studies attempt to extract error patterns and source code properties from the analysis of defective iac programs.
rahman et al.
employ machine learning and text processing techniques to identify properties that faulty puppet programs hold.
then they build a prediction model for asserting whether iac scripts manifest faults or not.
chen et al.
identify error patterns in puppet manifests by following a different approach.
first they inspect the code changes from repositories commits.
second they construct an unsupervised learning model to detect error patterns based on the clustering of the proposed fixes.
their approach is based on the assumption that similar faults are fixed with similar patches .
35there are few automated techniques proposed for improving the reliability of configuration management programs.
rehearsal statically verifies that a given puppet configuration is deterministic and idempotent.
rehearsal models a given puppet manifest in a small language called fsand then it constructs logical formulas based on the semantics of each language s primitive.
then an smt solver decides whether the initial program is non deterministic or not.
compared to our approach rehearsal is less effective and practical.
specifically rehearsal employs a form of static analysis that can only handle a subset of puppet programs.
for example the analysis does not support exec resources because it is unable to reason about the file system resources that shell commands process.
unlike rehearsal our approach works by reasoning actual system calls rather than puppet manifests thus it can effectively determine which files are affected by a puppet run and how.
other advances adopt a model based testing approach for checking whether configuration scripts meet certain properties.
hummer et al.
focus on testing the idempotence of chef scripts.
their proposed framework generates multiple test cases that explore different task schedules.
by tracking the changes in the system trigged by a chef script they determine if idempotence holds for the given program.
hanappi et al.
extend the work of hummer et al.
and introduce citac a framework that can be applied to puppet manifests to examine the convergence of programs.
convergence states that the system reaches a desired state even at the presence of failed puppet resources.
they formally express the properties of idempotence and convergence and through test case generation they verify if the provided manifests violate those properties.
contrary to citac we adopt a more lightweight approach applying manifests only once.
finally neither rehearsal nor citac detect issues involving missing notifiers.
unfortunately a side comparison between our tool and the stateof the art was neither feasible nor fair.
citac works on an instrumented version of puppet .
.
however puppet .x is not used any longer and the vast majority of modules no longer support puppet .x.
furthermore as already discussed rehearsal is unable to analyze modules that use the exec resource.
more than a half of the inspected modules contain exec let alone their dependencies.
also rehearsal cannot statically analyze modules whose source code consists of multiple files.
finally in most cases rehearsal s analysis aborts prematurely due to some bugs e.g.
its custom parser fails to parse complex puppet constructs.
for these reasons rehearsal cannot analyze any of the modules listed in table .
tortoise employs a semi automated approach for repairing faulty puppet scripts.
in particular it monitors the fixes made by administrators via command line and follows a program synthesisbased technique to generate a patch for the corresponding puppet manifests.
this patch reflects all the file system changes made by administrators through the execution of shell commands.
extending our approach to automatically generate fixes for the reported bugs is an interesting direction and we leave it as future work.
based on the detected issues we could identify where to apply the fix by inspecting the abstract syntax tree ast of manifests to add missing dependencies and notifiers.
trace analysis.
analysis of system call traces has been widely used in the past especially in the context of dependency inferencefor builds scripts.
many existing approaches are used for refactoring and testing boosting performance of builds or detecting license inconsistencies in open source projects .
as discussed in section .
most of them do not deal with the intricacies of system calls.
this degrades the precision and effectiveness of the analysis.
also unlike existing work our trace analysis enables us to compute relationships in higher level of abstraction i.e.
puppet resources.
modeling file system operations.
several researchers have designed specifications for the posix file system .
the specifications mainly focus on program reasoning and verification.
shambaugh et al.
have introduced fs a small language used to model the effects of puppet resources on the file system.
in this work we model system calls rather than puppet resources.
conclusion we have introduced an effective and practical approach for identifying missing dependencies and notifiers in puppet manifests.
our method collects the system calls invoked by a puppet program and models them in fstrace.
through fstrace we design a trace analysis that captures how higher level programming constructs such as puppet resources interact with the operating system.
this enables us to infer their inter relationships and check these relationships against the program s dependency graph for potential mismatches.
the effectiveness of our approach is exemplified by the uncovering of previously unknown issues in projects including well established ones such as puppetlabs apache .
notably of them were confirmed and fixed by the developers.
we have further showed that our tool can handle realistic traces in a couple of seconds.
our results indicate that our tool can be used as part of the testing process for puppet programs.
fstrace is a generic model that can be applied to other domains with partially ordered constructs.
consequently future studies can build on our work to detect concurrency faults in many other areas.