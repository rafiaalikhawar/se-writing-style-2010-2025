mining input grammars fromdynamic controlflow rahul gopinath rahul.gopinath cispa.saarland cisp a helmholtz center for informationsecurity saarbr cken saarland germanybj rnmathis bjoern.mathis cispa.saarland cispa helmholtz center for informationsecurity saarbr cken saarland germanyandreas zeller zeller cispa.saarland cispa helmholtz center for informationsecurity saarbr cken saarland germany abstract one of the key properties of a program is its input specification.
having a formal input specification can be critical in fields such as vulnerability analysis reverse engineering software testing clone detection orrefactoring.unfortunately accurateinputspecificationsfor typical programs are often unavailableor outof date.
inthispaper wepresentageneralalgorithmthattakesaprogram andasmallsetofsampleinputsandautomaticallyinfersareadable context freegrammarcapturingtheinputlanguageoftheprogram.
we infer the syntactic input structure only by observing access ofinputcharactersatdifferentlocationsoftheinputparser.this works on all stack based recursive descent input parsers including parsercombinators andworksentirelywithoutprogramspecific heuristics.our mimidprototypeproducedaccurateandreadable grammarsforavarietyofevaluationsubjects includingcomplex languagessuch as json tinyc andjavascript.
ccs concepts softwareanditsengineering softwarereverseengineering dynamicanalysis theoryofcomputation grammars andcontext free languages.
keywords context free grammar dynamic analysis fuzzing dataflow controlflow acm reference format rahul gopinath bj rn mathis and andreas zeller.
.
mining input grammars from dynamic control flow.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november 8 13 virtual event usa.
acm new york ny usa pages.
.
introduction one of the key properties of a program is its input specification.
having a formal input specification is important in diverse fields such as reverse engineering program refactoring and program comprehension .
to generate complex system inputs for testing a specification for the input language is practically mandatory esec fse november 8 13 virtual event usa copyright held by the owner author s .
acm isbn .
json raw json raw json string json list json dict json number true false null json number json number json number e json number json number .
e e json string json string json list json raw json raw json raw json raw json dict json string json raw json string json raw json string !
.
?
decode escape decode escape b f n r t figure jsongrammarextracted from microjson.p y. however formalinput specifications are seldom available and whentheyare theymaybeincomplete obsolete orinaccurate withrespecttotheprogram .unfortunately determiningthe input language of a program is a non trivial problem even when the source code is available .
therefore obtaining input models automatically bears greatpromise for software engineering.
while researchers have tried to tackle the problem of grammar recoveryusingblack boxapproaches theseminalpaperby angluinandkharitonov showsthatapureblack boxapproach isdoomedtofailureas therecannotbeapolynomialtimealgorithm in termsofthenumberofqueriesneededforrecoveringacontext free grammarfrommembershipqueriesalone.hence only white box approachesthattakeprogramsemanticsintoaccountcanobtain an accurateinputspecification.
the first white box approach to extract input structures from programs is the work by lin et al.
which recovers parse treesfrominputsusingacombinationofstaticanddynamicanalysis.
however lin et al.
stop at recovering the parse trees with limited labeling and the recovery of a grammar from the parse trees is non trivial as the authors recognize in the paper and as indicated by the limited number publications in this topic even thoughrecoveringsuchagrammarisimportantinmanyareasof software engineering .
172this work is licensed under a creative commons attribution international .
license.
esec fse november8 virtualevent usa rahulgopinath bj rn mathis andreas zeller the one approach so far that extracts human readable input grammarsfromprogramsis autogram byh scheleetal.given aprogramandasetofinputs autogram extractsanapproximate context freegrammaroftheprogram sinputlanguage.itdoessoby tracking the dynamic data flow betweenvariables at different locations ifapartoftheinputisassignedtoavariablecalled protocol this substringforms a protocol nonterminal inthe grammar.
while dynamic data flows produce well structured grammars on a number of subjects the approach depends on a number of assumptions the most important being that some data flow to a uniquevariable hastobethereinthefirstplace.ifaprogramaccepts astructuredinputwhereonlypartoftheinputissavedandused there isnodata flowto learn from inthe unsavedparts.
second learningfromdynamicdataflowsrequiresspecialheuristicstoworkaroundcommonparsingpatternsidentified thedata flow induced by a parser lookahead for instance has to be ignored asitwouldotherwisebreakthemodel .finally commonpatterns such as passing the complete input as an array with an index indicatingcurrentparsestatuscanbreakthesubsumptionmodel.
these shortcomings limit learning from data flows to a small class ofinputprocessors.
inthispaper wedescribea generalalgorithm torecoverthe input grammar from a program without any of these limitations.
rather thanbeing based on data flows to unique variables it recovers the inputgrammarfrom dynamiccontrolflow andhowinputcharacters areaccessedfromdifferentlocationsintheparser.ouralgorithm works regardless of whether and how the parsed data is stored and requires no heuristics to identify parsing patterns.
it works on allprogram stack basedrecursive descent parsers including modern techniquessuch as parser combinators.the recursive descent family ofparsers makesup ofthe top programming language parsers ongithub .
theresultinggrammarsarewell structuredandveryreadable.
as an example consider the json grammar shown in figure which our mimidprototype extracted from microjson.py .1each jsonelementhasitsownproductionrule json number forinstance lists a number as astring of digits.
rules capture the recursivenatureoftheinput a json list contains json raw elements whichinturnareotherjsonvalues.allidentifiersofnonterminals are derived from the names of the input functions that consume them.
all this makes for very readable grammars that can be easily understood adapted andextended.
whydoweemphasizethe readability ofextractedgrammars?
recoveringreadablegrammarsisimportantinanumberofareas insoftware engineering .
therecoveredgrammarrepresentstheinputspecificationof thegivenprogramandprovidesanoverviewofhowtheprogramprocessesitsinputs.thiscanbeusedforunderstanding theprogramandidentifyingwherepossiblevulnerabilities lie.
the grammar recovered can be useful for identifying the difference between differing implementations and even foridentifyinghowtheinputspecificationchangedacross revisions andidentifying compatibilityissues.
alargenumberofrecentbugshavebeencausedbyincorrectlyimplementedparsersforcommonspecifications .
1weremoved rulespertainingto whitespace processing for clarity.recoveringtheactualgrammaroftheinputsacceptedbythe program can helpusidentifythe problematic parts easily.
another important use of grammar is for debugging where techniques such as hierarchical delta debugging can onlybeappliedifonehastheprograminputgrammar.an inputgrammar for a givenprogram can also be of use ifone wantstorepairdamagedinputs .inallthesecases the inputsneedto be decomposedintosmallerfragments.
when using a grammar as an input producer for testing readable grammars allow testersto refine the grammar with specific inputs such as logins passwords or exploits.
given such a grammar one can contract the grammar such that only specific subparts are generated if one is first able to understand what partsofthe grammarcorrespondto thepart that one is interested in.
if even a partial human readable grammarisavailable itcanbeexpandedwithhumanknowledge on features where the miner may not have sufficient inputs or identify vulnerabilities through human inspection of the grammar e.g.
allowing special characters in usernames .fuzzerscanonlyallowforsuchcontrolifthemodel ishuman readable.
intheremainderofthispaper wefirstillustrateourapproach on a simple self contained example in section .
we then detail our contributions weprovideageneralalgorithmforderivingthecontext free approximationofaninputlanguagefromarecursivedescent parser.
our approach relies on tracking character accesses in theinputbuffer section3 whichiseasytoimplementfor avarietyoflanguagesthatsupportstringwrappers orthe source can be transformed to support such wrappers or dynamic taint information is available.
from the tracked accesses we then infer parse trees section which we generalizebymeansof activelearning2 beforepassingthem to our grammar inference section .
our approach distills the developer supplied method names and input processing structure to produce human readableinputgrammars.
we evaluate our approach using subjects in both python andcand recover complex grammars such as javascript andtinyc.
for the evaluation we assess both precision and recall section of our grammars.
when compared against learning from dynamic data flows so far the only approach forinferenceofhuman readablegrammars wefoundour approach to be superior inboth precision andrecall.
in our evaluation we also show that our approach is applicable in contexts in which no usable data flow of input fragmentstovariablesexistssuchasmodernparsingtechniqueslike parsercombinators whichmakethestateofthe art for writing secure parsers .
after discussing limitations section and related work section section closes with conclusion and future work.
the complete sourcecode ofour approach andevaluation isavailable.
2the term active learning was first used by dana angluin for grammar learning.
173mining input grammarsfrom dynamic control flow esec fse november8 virtualevent usa defdigit i return iin defparse num s i n whilei !
len s anddigit s n s i i return i n defparse paren s i assert s i v parse expr s i ifi len s raiseex s i assert s return i v defparse expr s i expr is op true whilei len s c s ifdigit c if not is op raiseex s i i num parse num s i expr.append num is op false elifcin ifis op raiseex s i expr.append c is op i true i elifc if not is op raiseex s i i cexpr parse paren s i expr.append cexpr is op false elifc break else raiseex s i ifis op raiseex s i return i expr defmain arg return parse expr arg figure apython parser formath expressions ourapproachina nutshell howdoesourapproachwork?weuselightweightinstrumentation totrackdynamiccontrolflow andlightweightstringwrappers or dynamic taint information if available to identify in which control flow nodes specific input characters are accessed.
the character accessesaswellasthecorrespondingcontrol flownodesarethen logged.
a parse tree of the input string is extracted from that trace using the following rules whichmostly followlin etal.
arecursivedescentparsertriesalternativesrulesuntilthe first successful parse and a character is not accessed after it was successfully parsed.
hence the method call that accessesaparticularinputcharacterlast directlyconsumes that character.
e.g.
if a call to digit is the last to access the digit3 then3isconsumedbythat callto digit .
amethodcall indirectlyconsumes acharacterifoneofthe nestedmethodcalls consumes that character.
a control flow node such as a conditional e.g.
if or loop e.g.while is regarded as a pseudo method.
the name for the pseudo method is derived from the parent method name andaunique identifier.
parse expr while if parse num digit while if while if parse num digit while if while if parse num digit figure derivationtree for namesofmethodsthat consumesomepartoftheinputare used as the nonterminal symbol for the corresponding node inthe parse tree for that part.
as an example consider figure 2showing a complete python programthatacceptsmathematicalexpressionsusingarecursive descentparser.runningitwithanargument 4yieldsthetentativeparsetreeshowninfigure .themethod parse num which parsesnumeric elements becomesthe nonterminal parse num in the parse tree figure representing inputnumeric elements.
the parse tree is then processed further to correctly identify compatible nonterminal nodes withthe following steps collectandgroupnodesbythenamesoftheir nonterminal symbols.
identify subdivisions within each nonterminal group by substitutingnodeswitheachotherinthecorrespondingparse trees andverifying the validity of resultingparse trees.
generate unique nonterminal symbols for identified subgroupsand updatethem inthe correspondingnodes inthe parse trees.
this gives usaccurately labelledparse trees.
we thenuse thisaccurately labelledparsetrees toinfer agrammar eachnodeinaparsetreeiscollected andthe nonterminal symbolbecomes a nonterminal inthe generatedgrammar.
each sequence of terminalandnonterminal symbols from childnodesofthe nonterminal becomesapossibleexpansion rulefor that nonterminal .
apply the prefix tree acceptor algorithm to identify regularright handsides dueto loopsandconditionals.
applygeneralizationoftokenssuchasconvertingaseenlist ofintegersto an expressionthat can generateany integer.
compactandcleanup the grammar.
weextractsuchparsetreesfor anumberofgiveninputs.next we traverse each tree and identify loopnodes that are similar as we detail in section .
.
this results in parse trees where similar nodes have similar names.
finally we construct the grammar by recursively traversing each parse tree and collecting the name and children typesandnames for eachnode.the nodenames become nonterminal symbols in the grammar and each set of children becomesonepossibleexpansioninthegrammarbeingconstructed.
thechildnodesthatrepresentcharactersbecometerminalsymbols inthe constructedgrammar.
for our example the final result is the grammar in figure whichexactlyreflectsthecapabilitiesoftheprogramin figure2.
174esec fse november8 virtualevent usa rahulgopinath bj rn mathis andreas zeller start parse expr parse expr parse expr parse num parse paren parse paren parse expr parse num parse digit digit figure agrammarderived fromtheparser in figure again thegrammarisreadablewithnear textbookqualityandwell reflectsthe inputstructure.
trackingcontrolflowand comparisons let us now start with describing the details of how we infer the parse tree from dynamiccontrolflow.
fortrackingthecontrol flow we programmaticallymodify the parser source.
we insert a tracker for both a method entry and an exitaswell astrackers forcontrolflow entry and exitforany conditionsandloops.forthepurposesofourapproach weconsider these control structures as pseudo methods .
every such method call both true and pseudo method calls gets a unique identifier from a countersuchthatachildofthecurrentmethodoralatermethod callgetsalarger newmethodidentifier thanthe currentone.
inpython fortrackingthecharacteraccessesbeingmade we simply wrap the input string in a proxy object that log access to characters.weannotateeachcharacteraccessedwiththecurrent method name.
for c the above information is recovered using a lightweightdynamictaint framework.
what if one can not distinguish parsing functions?
in such case one can simply conservatively instrument allfunctions.
given that weonlylogaccesstotheinitialbuffer thenon parsingfunctions will have no effect except on performance on the parse trees generated.anotherapproachwouldbetomakeuseofstaticanalysis to identify parsingfunctions that mightaccess the initial buffer andinsert trackers only onthosefunctions.
inbothlanguages westoptrackingassoonastheinputistransformedorcopiedintoadifferentdatastructure ifthereisalexer we continue the trackingintothe parser stage .
wenotethat accessto thesourcecodeisnotarequirement.so long as one can track access to the initial input string and identify methodcalls bytheiraddressifweareanalysingabinary onecan recover the requiredinformation.
from traces to parsetrees theprevioussectionshowedhowtoannotatetheexecutiontree withindexesoftheinputstringaccessedbyeachmethodcall.at this point however there can be multiple accesses by different methods at the same input index.
to assign specific indexes to specificmethodcalls wefollowasimplestrategyinformedfrom the characteristics of recursive descent parsers the last method callthat accessed a character directly consumes that character and its parentmethodcalls indirectlyconsumethat character4.
3this is one of the main differences of our technique from both lin et al.
and h schele et al.
whotrack dynamictaintsthroughout the program.
4wenote thatthis isone of the majordifference of our technique fromlin et al.
who define parsing points as thelastpointthecharacterwas used beforetheparsingwe now resolve the ownership of input index ranges between nodes.
given any node we obtain the starting and ending indexes that were consumed by the node.
if no other node has consumed anycharacterwithinthatrange thecurrentnode directlyowns that range and all its parent nodes indirectly own that range.
if a range overlap is found between a parent node and a child node the tie is decided in favor of the child with the child node directly owning theoverlap andtheparentnode indirectlyowning theoverlap.if anoverlapisfoundbetweentwosiblingnodes thetieisdecided in favor of the sibling that accessed the part last as the last access to the character defines the consumer method .
the sibling that is intheoverlapisrecursivelyscanned andanydescendentofthat node that are containedinthe overlap are removed.
once the indexes are associated with method call identifiers wegeneratea calltreewitheachmethodidentifierarrangedsuch that methods called from a given method are its children.
the directly ownedinput indexes are addedas the leafnodes from the correspondingmethodcallnode.asthereisnooverlap suchatree can be consideredas a parse tree for the given inputstring.
the parse tree at this point is given in figure 5a which we call thenon generalized parsetreeoftheinputstring.infigure 5a each pseudo method has a list of values in parenthesis in the following format.
the last value in the parenthesis is the identifier for the controlflownodetaken.thatis givenanodenameas if theidentifieris .itindicatesthatthecorresponding ifstatement wasthethirdconditionalintheprogram andtheexecutiontook the first if branch of the conditional.
if the identifier was itwouldindicatethattheexecutiontookthe elsebranch andfor larger values it indicates the corresponding branch of a cascading ifstatementoracasestatement.in thecaseofloops thereisonly a single branch that has child nodes and hence this is indicated by .thevaluesbeforetheidentifiercorrespondtotheidentifiersof the pseudo method parents of this node until the first method call.
thatis the if hasa parentnode thatis a loop and it is the secondloopinthe program.
while we have produced a parse tree it is not yet in a format fromwhichwecanrecoverthecontext freegrammar.tobeable todoso weneedaccuratelylabeledparsetreeswhereanygiven nodecan be replacedby anodeofsimilarkind withoutaffecting the parse validity of the string.
the problem here is that not all iterationsofloopsarereplaceablewitheachother.thatis loopscan be influenced by the previous iterations.
for example consider the derivationtreeinfigure 5a.ifoneconsiderseachiterationofthe looptobeone alternateexpansion tothecorresponding nonterminal the rulerecoveredis expr num however thisisincorrectasasinglefree standingoperatorsuch as is not a validvalue.the problem is that is opencodesa link betweendifferentiterations.hence weannotateeachindividual iterationandleaverecoveringtheactualrepeatingstructureforthe nextstep.asimilarproblemoccurswithmethodcallstoo.inthe producedparsetreeweassumethatanygiven nonterminal say parse num canbereplacedbyanotherinstanceof parse num pointofitssuccessor.theproblemwithsuchanapproachisthatreal worldparsers mayaccess characters out of order.
see section8.
for details.
175mining input grammarsfrom dynamic control flow esec fse november8 virtualevent usa parse expr while if parse num digit while if while if parse num digit while if while if parse num digit a non generalized parse tree.
the number before colon indicates theparticularpseudo method andnumberafterthecolonidentifies thealternativeifany.thatis if ... isthefifth ifwhoseelse branch was taken.
the pseudo methodstack isinside .
parse expr while if parse num digit while if .
while if parse num digit while if .
while if parse num digit b generalizedparsetree.thenumberinsuffixaftercolonindicates the generalized identifier after validating replacements.
as before the pseudo method stack is contained in the parenthesis which is also updatedwhen theparentis updatedduring generalization.
figure parse trees for .
the prefix before colon indicates the static identifier of the control structure in the method.
thatis thefirst ifgets theprefix .the suffix isexplained above.
withoutaffecting thevalidityof thestring.however thisassumption may not hold true in every case.
the behavior of a method may be influenced by a number of factors including its parameters andthe globalenvironment.
we fixthis inthe nextstep.
.
activelearning oflabeling to determine the precise labeling of each node we first collect eachnodefromeachparsetreeandgroupthembythenameofthe nonterminal .thatis all parse num nodesgotogether sodoall if .
next the challenge is to identify the buckets under the grouped nodesthatarecompatiblewitheachother.weconsideranodeas replaceable with anotherif the string producedfrom a parse tree where the first node is replaced by the second is parsed correctly thatis thegeneratedstringisparsedwithoutanyerrors andthe parsetreegenerated from thenewparsehasthe samestructure as thetreegeneratedbyreplacingthenode.anodeis compatible with anotherif both nodes are replaceable witheachother.
unfortunately compatibilityisnot transitive ifonelooksatparse validity.for example say there are three wordsin a language a b andac.eachwordiscomposedofindividual letters.inthecase ofa andb thecorrespondingletter andfor ac theletters a andc.
start word1 word2 word3 word1 letter a word2 letter b word3 letter a letter c letter a a letter b b letter c c now considerthe parse trees of a b andac.
start word1 letter a a start word2 letter b b start word3 letter a a letter c c here thenodes letter a acrossparsetreesarecompatiblebecause thegeneratedstringsareexactlythesame.next the letter a under word1 is compatible with letter b under word2 .
the generated strings are aandb.
so is the node letter b under word2 compatible with letter a under word3 ?
unfortunately not as the stringgeneratedfrom start word3 letter b b letter c c isbcwhichisnot inthe language.
thismeansthatfortheaccurateidentificationofuniquenode labels each node has to be compared with all other nodes with the same name which gives us a complexity of o n2 in the worst case in terms of the number of nodes.
however we found that the assumption of transitivity rarely breaks and even then the inaccuracyinducedaffectslessthan10 ofinputsgeneratedfromthe grammar seetheevaluationof mathexpr.py .sincetheassumption oftransitivity allows us to reduce the computational effort our evaluation is implemented assuming transitivity of compatibility.
oncewehaveidentifiedthecompatibilitybuckets wecanupdate the nodes in them with unique suffixes corresponding to each bucket and update the node name of each one with the suffix.
in the case of loop nodes we also update the stack name of this node in all the descendent elements of this node all descendent nodes up to the next non pseudo method call.
the idea here is that if there are two unique loop iterations that are incompatible with each other then any other control flow nodes inside that loops such asconditionals shouldalsobe considered incompatible even ifthesamealternativepathistakenintheconditionalduringthe executionofboth iterations.
once the process is complete all the nodes in all the parse trees will be labeled with consistent and correct identifiers.
these can then be extracted to produce the correct grammar.
the generalized counterpartto figure 3isgiven infigure 5b.
.
activelearning ofnullability some of the loops may be skipped completely e.g.
an empty objectinjson.thesecanbeidentifiedusing activelearning .the idea is to replace all consecutive loopnodes that are the children of a given node in a given parse tree.
then check the validity of thestringproducedfromthattree.iftheparsestructureofthenew 5wenotethatauserofourtechniquedoesnotneedtorelyonthisassumption.one can choose to do the complete o n2 verification or can choose anything in between that and the fasterbutapproximate version.
176esec fse november8 virtualevent usa rahulgopinath bj rn mathis andreas zeller stringiscorrect andthiscanbedoneonallparsetreesandatall pointswhere this ispossible the loopismarkedas nullable.
forconditionalnodes whetheran ifnodecanbeskippedcanbe determinedstaticallywithoutactivelearning bysimplychecking for the presence of an elsebranch.
however ifconditionals may be labeled incorrectly.
for example consider this set of statements ifg validate validate header header while the ifdoes not have an elsebranch we do not know whether the body of the conditional can be skipped or not.
in particular the g validate may be a global configuration option whichmaymeanthatitisalwaysenabledoralwaysdisabledfor specific kindsof parse trees.
while we have not found such conditionalsinoursubjects ifadditionalaccuracyisdesired theoptional parts ofconditionals mayalsobe verifiedusing active learning.
withthis ourtreesareaccuratelylabeledandreadyforinferring grammars from them.
grammarinference for constructing a grammar out of parse trees we traverse each parse tree starting from the top.
each node we see if it is not a character node is marked as a nonterminal in the grammar.
the children are placed as the rule for expansion of the nonterminal in the grammar.
if the child is a non character node the token in the expansion will be a reference to the corresponding nonterminal in the grammar.
there may be multiple alternate expansions to the samenonterminal evenfromthesametreeasthesamemethodcall maybe maderecursively.this isdetailedinalgorithm .
algorithm1 extracting the basic grammar function extract grammar node grammar name uid children stack node a name name uid stack rule ifa name nelement rammar then grammar rule else grammar .add rule ifchildren then returnterminal a name else forchild childrendo kind cname extract grammar child ifkind terminalthen rule to terminal cname else rule to nonterminal cname returnnonterminal a name anadditionalchallengecomesfromidentifyingrepeatingpatterns.
from the various solutions of this problem we chose amodificationofthe prefixtreeacceptor algorithm6.oncewerunthe modified ptaalgorithm the previous grammaristransformedto expr while expr while while while while if if num while thewhile n can be replaced by the regular expression summariesofthecorrespondingrulesrecursively.here thisgivesus the regularexpression expr num num num whilegeneralizing wecanreplaceany with providedallthe itemsinsidethegrouparenullable.similarly whenmergingregular expressionscorrespondingtoconditionals onecanadd ... i.e.an alternative provided the corresponding ifcondition was nullable.
these steps generate the right hand side regular expressions in figure for a simple program given in figure .
for details on learningregularexpressionsfromsamples seehiguera .the grammar derived from microjson.py after removing differences due towhite spaces isgiven in figure .
.
generalizing tokens thegrammarwehavegeneratedsofarisafaithfulreproductionof theparsingprocess.thisgrammarishowevernotcompletewith respect tothe generalization.the reason is that typicallanguages relyonexternal libccallssuchas strtod strtof andstrstr.theinternal structure oftheportionsthusparsedarelosttooursimpletracer.
hence weneedtorecoverthestructureoftheseitemsseparately.
asimilarproblemalsooccursinparsersthatusesaninitial scanner thatfeedstokens into parser.theseresultin nonterminal symbols whichsimply contain alonglistof tokens such as int which need to be generalized.the solution here is a simple generalization withthe following steps.
collectall terminalsymbolsinthe grammar.
spliteach terminalsymbolintoindividualcharacters.
widenthe character into itsparent group.
e.g.
givena character widen it first to digit then to alphanum and lastlyto anychar checkingtomakesurethateachwidening is accepted by the program and is parsed in the same manner.
deduplicatethe resultinggrammar apply regular expression learning using the pta algorithm to obtain the fully generalizedgrammar.
.
producinga compactgrammar at this point the mined grammar is readable but verbose.
there are a number of transformations that one can take to reduce its verbosity withoutchanging thelanguagedefined bythegrammar.
theseare as follows 6unliketheoriginal pta whichconsidersonlyrepeatingpatternsofsinglecharacters wefirstscanforandidentifyrepeatingpatternsofanyblocksize.wenextscanthe inputs for any instances of the identified repeating patterns.
these inputs are then chunked and considered as the alphabets as in the original ptaalgorithm.
177mining input grammarsfrom dynamic control flow esec fse november8 virtualevent usa if there is any nonterminal that is defined by a single rule with a single token delete the key from the grammar and replace allreferences to that key withthe token instead.
iftherearemultiplekeyswiththesameruleset chooseone delete the rest and update the