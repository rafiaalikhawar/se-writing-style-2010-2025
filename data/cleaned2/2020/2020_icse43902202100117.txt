automatic solution summarization for crash bugs haoye wang xin xiaykdavid loz john grundyyxinyu wang k college of computer science and technology zhejiang university yfaculty of information technology monash university zschool of information systems singapore management university fwhy wangxinyug zju.edu.cn fxin.xia john.grundy g monash.edu davidlo smu.edu.sg abstract the causes of software crashes can be hidden anywhere in the source code and development environment.
when encountering software crashes recurring bugs that are discussed on q a sites could provide developers with solutions to their crashing problems.
however it is difficult for developers to accurately search for relevant content on search engines and developers have to spend a lot of manual effort to find the right solution from the returned results.
in this paper we present crasolver an approach that takes into account both thestructural information of crash traces and the knowledge of crash causing bugs to automatically summarize solutions from crash traces.
given a crash trace crasolver retrieves relevant questions from q a sites by combining a proposed position dependent similarity based on the structural information of the crash trace with an extra knowledge similarity based on the knowledge from official documentation sites.
after obtaining the answers to these questions from the q a site crasolver summarizes the final solution based on a multi factor scoring mechanism.
to evaluate our approach we built two repositories of java and android exception related questions from stack overflow with size of and questions respectively.
our user study results using selected java crash traces and selected android crash traces show that our approach significantly outperforms four baselines in terms of relevance usefulness and diversity.
the evaluation also confirms the effectiveness of the relevant question retrieval component in our approach for crash traces.
i. i ntroduction software crashes are a serious software defect problem and often requires developers to solve them with a high priority.
however as the complexity of a software system increases the reasons for software crashes become ever more complicated.
fortunately many bugs are recurring and occur in different projects but are similar .
previous research reported that there are about of total bugs that can be considered as recurring.
therefore the recurring bugs which have already been discussed on q a sites such as stack overflow so could potentially help developers solve their own software crashes.
most mainstream programming languages have their own exception handling mechanism that produces crash traces which can then be used for further investigation.
figure shows an example of such a crash trace.
we refer to red parts ascrash reasons and blue parts as stack frames .
typically developers will organize their questions about a crash into a query to the search engines.
however for a large crash trace thrown by a program it is often difficult for a kcorresponding authors.
java.lang.runtimeexception unexpected exceptionat com.google.appengine.tools.enhancer.enhancer.execute enhancer.java at com.google.appengine.tools.enhancer.enhance.
init enhance.java at com.google.appengine.tools.enhancer.enhance.main enhance.java caused by java.lang.reflect.invocationtargetexceptionat sun.reflect.nativemethodaccessorimpl.invoke0 native method at sun.reflect.nativemethodaccessorimpl.invoke unknown source at sun.reflect.delegatingmethodaccessorimpl.invoke unknown source at java.lang.reflect.method.invoke unknown source at com.google.appengine.tools.enhancer.enhancer.execute enhancer.java ... morecaused by java.lang.illegalargumentexceptionat org.objectweb.asm.classreader.
init unknown source at org.objectweb.asm.classreader.
init unknown source at org.objectweb.asm.classreader.
init unknown source at org.datanucleus.enhancer.asm.asmclassenhancer.getclassnameforfilename asmclassenhancer.java at org.datanucleus.enhancer.datanucleusenhancer.getfilemetadataforinput datanucleusenhancer.java at org.datanucleus.enhancer.datanucleusenhancer.enhance datanucleusenhancer.java at org.datanucleus.enhancer.datanucleusenhancer.main datanucleusenhancer.java ... morecrash reasons stack framesfig.
.
an example of a crash trace.
developer to summarize this crash trace into a query.
due to limitations of input length search engines like google and stack overflow can not deal with the entire crash trace.
in general developers will try to directly use the crash reasons as shown in figure as search engine input then read the returned posts to find solutions to their software crash.
however this method will miss a lot of important information instack frames and the result may not be accurate enough.
to make matters worse there is much noisy and redundant information in the returned posts and developers need to spend a lot of time to digest and find the right solution.
an automated approach considering both crash reasons andstack frames to provide solutions to a crash trace will help developers solve crash bugs more effectively.
recently two approaches have been proposed to automatically generate solutions for programming questions answerbot and crokage .
answerbot generates a query focused multi answer posts summary for a given technical question.
it aims to help developers quickly capture the key points of several answer posts relevant to a technical question before they read the details of the posts.
crokage takes the natural language description of a programming task and provides a comprehensive solution for the task.
crokage suggests programming solutions containing both code and explanations.
however both the approaches are not designed for crash trace analysis and require a natural language description of the programming problem as input which is hard for developers.
several techniques use crash trace for bug localization ieee acm 43rd international conference on software engineering icse .
ieee automated program repair and duplicate bug report detection see section vi for more detail .
however to the best of our knowledge automatic generation ofexplanations that can guide a developer to fix the problem causing a given crash trace has not yet been investigated.
unlike the question answering task a crash trace may share no lexical units with an answer and the information they convey may be totally different.
to address this we utilize the fact that some q a posts discussing a crash bug usually have a crash trace attached which contains certain information about the crash.
we can retrieve related questions by measuring the similarities between crash traces.
however many modern programs depend on common packages and thus different crash traces may contain lots of similar tokens.
two different crash bugs may share many identical tokens in different positions of their crash traces if the programs rely on some common packages.
thus traditional information retrieval methods i.e.
bm25 tf idf based information retrieval word embedding based information retrieval and document to vector based information retrieval will bring bias and not work very well.
the crash reasons and the structural information of stack frames may be the key points to improve our retrieval ability.
additionally some crash traces on q a sites may be incomplete as the questioner only pastes the crash reason and describes the crash in short.
only using crash traces will not be able to retrieve all related q a posts.
if we can introduce some additional knowledge about the crash bugs to retrieve it will greatly improve our approach.
unfortunately it is easy for developers to have a concept what a crash trace is about but it is difficult for a program.
to address these we propose c rasolver crashsolver that takes a crash trace as input and then returns a solution summary for the bug.
our approach takes into account both the structural information of the crash traces and the knowledge of crash bugs.
first we extract all crash traces from question bodies on stack overflow and use bm25 to retrieve a set of relevant questions based on the crash reasons part of every crash trace.
then we propose two metrics to evaluate the similarities between given crash trace and all posts in the question set i a proposed position dependent similarity based on stack frames between a given crash trace and question s crash trace ii an extra knowledge similarity measure being the similarity between the knowledge from official documentation of a crash reason and the question s title.
the sorted top k question list and the answers belonging to these questions are returned.
we then score these answer paragraphs according to several kinds of features and we borrow ideas from the maximal marginal relevance algorithm to generate solution summaries.
finally we filter some low quality sentences out and output the solution.
we built two repositories for java questions and android questions from stack overflow where there is crash trace in the question body of size of and respectively.
we randomly selected another java questions and android questions and extracted all crash traces in these question posts.
we chose four approaches as our baselines google search engine so search engine answerbot and crokage .
our experiments demonstrate that c rasolver significantly outperforms all baselines in terms of relevance usefulness and diversity.
the evaluation of the retrieval component in our approach shows strong ability to search related questions on q a sites for a given crash trace.
the main contributions of this paper include we propose a novel approach that automatically summarizes solutions for crash traces we introduce two similarity metrics for retrieving relevant questions related to crash traces position dependent similarity and extra knowledge similarity we conduct extensive experiments to evaluate c rasolver demonstrating its effectiveness compared to state of the art approaches.
the rest of this paper is organized as follows.
section ii describes the details of proposed approach.
section iii describes data preprocessing and the experiments.
section iv discusses the advantages and disadvantages of c rasolver .
section v elaborates the threats to validity and section vi reviews the related work.
finally section vii concludes the paper and mentions future work.
ii.
p roposed approach we propose a new approach c rasolver to generate potential solution summaries for a given crash trace thrown by a program.
its framework is illustrated in figure .
c rasolver takes a crash trace as input and produces a solution summary for the crash trace.
the details of its preprocessing and preparation phase relevant question retrieval phase and solution generation phase are described below.
a. preprocessing and preparation to find questions with a crash trace on stack overflow we first manually checked a large number of exceptionrelated questions on stack overflow.
we observe that most crash traces are highlighted with the html tag hcodeior hblockquoteiand contain the string caused by or exception in .
we thus use beautiful soup and regular expressions to extract all questions with crash traces based on these heuristics offline.
in order to support the relevant question retrieval phase and the solution generation phase we prepare the following materials crash trace index we use the nltk package to tokenize all the crash traces extracted from so questions.
all the pairs of question id and crash trace are collected to build the document corpus.
the preprocessed document corpus is then utilized to build an index using whoosh similar to lucene but implemented in python.
c rasolver utilizes this index to initially filter out the relevant question set.
exception dictionary to determine the concept of what a crash trace is about we introduce knowledge from official documentation into our approach.
we build a dictionary that stores the names of all exceptions and corresponding descriptions crawled from official documentation sites.
1287fig.
.
the overall framework of our approach.
language models to measure the similarity between a so post and an exception description from official documentation we build domain specific language models.
we collect all titles and body text of stack overflow posts and tokenize the extracted contents with white spaces and punctuation.
we remove stop words and stem each word to its root form in the corpus using the nltk package .
we then train a word embedding model fasttext to represent each word in the corpus as a fixed length vector.
we also compute the idf metric inverse document frequency of each word in the vocabulary.
the idf metric represents the possibility that a word may carry important semantic information.
we use the idf weighted word embedding vector as the representation of each word in the corpus.
in this way the semantic similarity is able to be computed in the question retrieval phase and the solution generation phase.
b. relevant question retrieval given a crash trace ct c rasolver first uses regular expressions to extract the crash reasons andstack frames respectively.
c rasolver also checks every token contained in the trace crash reasons .
if the token fully matches any names of exceptions in the exception dictionary see section ii a the corresponding description and the exception name are added as extra knowledge for the crash trace.
in order to greatly narrow down the search space c rasolver uses the crash trace index to retrieve a relevant question set.
c rasolver tokenizes the extracted crash reasons by nltk and loads the crash trace index.
c rasolver uses bm25 to measure the lexical similarity of each crash trace in the index.
the crash reason and the crash trace from the pre loaded index are denoted as cr and p respectively.
the similarity score is computed as follows sim p cr nx i 1score i score i idf wi f wi p k f wi p k b b jpj avgdl wheref wi p is the word wi s term frequency in crash trace p jpjis the length of the crash trace idf wi is the inverse document frequency of word wi kandbare two free parameters.
kis used to normalize the range of term frequencies and bcontrols the influence of document length.
we setkandbto be .
and .
by default.
prior works have demonstrated that this setting performs well for various corpora .
in this paper c rasolver only retrieves the top similar questions to avoid introducing too much noise in later stages.
c rasolver further filters out questions where the crash trace in question body shares no exception name with the query crash trace.
after getting the relevant question set based on the crash reasons crasolver further utilizes structural information contained in stack frames and extra knowledge from official documentation for a more precise result position dependent similarity we introduce our proposed position dependent similarity in this section based on insights from dang et al.
the frame that causes the bug most likely occur near the top of the a call stack and the alignment offset between two matched functions in two similar call stacks is likely to be small.
for the given a crash trace c rasolver extracts all of its call stacks and corresponding stack frames .
we denote the call stacks position in the entire crash trace as s and the distance of every function token to the top of its belonging call stack asd.
crasolver thus records the position information of each tokenwiin the crash trace as a set position wi f si di si k di k g where k is the total number that wiappears in the crash trace.
for example the position information of the token marked in blue in figure can be represented as position wblue f g. 1288crash tracecall stack !
0call stack !
1stack framesstack framesthe distance to the top of call stack 2the distance to the top of call stack 4fig.
.
illustration of the position information.
letwbe the set of all the matched functions between the given crash trace ct 1and a crash trace from the relevant question set ct .
the position dependent weight of each word inwis computed as pdweight wi emin dis1 dis jdis1 dis2j wheredisis the average of din theposition wifrom their respective crash trace.
based on bm25 c rasolver calculates the position dependent similarity between ct 1and ct 2as follows pdsim ct ct nx i 1score i pdweight wi where thescore iis calculated by equation .
even if two crash traces have many identical tokens if the position distributions of these tokens are very different meaning the two bugs are not similar our algorithm can distinguish them and give a low score.
in this way the position dependent similarities between the given crash trace and each crash trace in the relevant question set can be calculated.
extra knowledge similarity to understand what the crash trace about we introduce extra knowledge sourced from official documentation.
given a crash trace and the relevant question set c rasolver transforms the corresponding description from official documentation of the crash trace and the title of a relevant question into two bag of words denoted as d and t respectively.
unlike yang et al.
who average word embedding vectors of words in a document c rasolver uses a idf weighted word embedding vector to represent a document.
crasolver loads the prepared language model mentioned in section ii a and computes the extra knowledge similarity as follows eksim d t !vd !vt k !vdkk !vtk !v pn i 1idf wi fasttext wi pn i 1idf wi wherewiis the word in the document fasttext wi is the word embedding vector of the wirepresented by pre trained fasttext model see section ii a .now we obtain extra knowledge similarities and position dependent similarities between the given crash trace and all questions in the relevant question set.
we normalize both similarity scores to make them comparable.
the final relevant score between the given crash trace ct and each question q in the relevant question set is calculated as rel q ct pdsim eksim where is a hyper parameter set to .
by default.
we give more weight to position dependent similarities because we need knowledge of official documentation to help retrieve rather than lead the search for relevant questions.
based on the calculated final relevant scores c rasolver returns the top relevant questions along with their answers for the given crash trace.
c. solution generation in order to avoid some redundant information and generate a comprehensive solution we borrow an idea from maximal marginal relevance algorithm to generate the solution.
given the answers of the top relevant questions c rasolver uses the granularity of answer paragraphs to generate the final solution.
we first score each answer paragraph denoted as a based on four features the relevant score of the question to which the paragraph belongs which is described in section ii b semantic similarity score with crash trace s description calculated by equation vote on answer we set the vote on the answer post where the paragraph comes from as the vote score and whether the answer is accepted.
if the answer to which the paragraph belongs is accepted we set the score to otherwise .
the final score for a answer paragraph score a ct is computed by multiplying the above four scores and normalizing the result.
we then apply the mmr algorithm to select a set of paragraphs as mmrdef arg max ai2rns score ai ct max aj2ssim ai aj wherectis the given crash trace sis the set of paragraphs which have been selected rnsis the paragraphs which have not been selected sim is the cosine similarity between the vector representations !vof two answer paragraphs and is a parameter to adjust the relevance and diversity of the results which is set at .
by default.
in this work c rasolver selects relevant paragraphs to prevent too long output.
the short code fragments which are enclosed in html tag hcodeiin natural language paragraphs are preserved in the paragraphs.
the long code snippets with no more than lines are extracted along with the answer paragraph.
c rasolver will append the corresponding long code snippets if any to the end of the solution.
1289finally we follow the method from wang et al.
that uses grammatical dependency analysis by stanford corenlp to identify the higher quality sentences from these answer paragraphs.
vp np nn ?
vb ?
np!
prp we keep only sentences that have a verb phrase followed by a noun and have a noun phrase followed by a verb phrase .
the other sentences are filtered out and then c rasolver outputs the final solution to the users.
iii.
e valuation in this section we describe the experimental setup that we follow to evaluate the performance of our c rasolver .
our experiments aim to answer the following research questions rq1 how does c rasolver perform compared to other approaches?
rq2 what impact does each of the proposed metrics have in the c rasolver approach?
rq3 how effective is the c rasolver relevant question retrieval component for crash traces?
a. data collection and tool implementation we downloaded the official data dump of stack overflow published on march .
considering that our approach is designed for crash traces based on the java language we extracted the questions on so that are tagged with java or android .
to create our knowledge base of exception related questions we selected questions satisfying the following criteria i there is at least one answer to the question ii there is a crash trace in the question body.
note that questions where there is a crash trace in the body were automatically identified by the heuristics described in section ii a. we collected java questions and android questions respectively.
we downloaded the java se api documentation to introduce additional crash solving knowledge.
we parsed the html files using beautiful soup and extracted all the class names along with their descriptions.
we collected all classes and did not distinguish whether they are exceptions for the sake of simplicity.
in total we built a dictionary containing class name description pairs.
based on these repositories we built a text corpus using the title and body of each post.
we used gensim to train the fasttext model.
in order to evaluate c rasolver we randomly selected java questions and android questions where there are crash traces attached and made sure there are no duplicate questions.
we extracted all crash traces in these questions to build the experimental queries.
note that these questions and their duplicate questions are removed from our exception related question base.
we refer the crash traces extracted from java questions as java test crashes and the crash traces from android questions as android test crashes .table i task allocation rqs java java android android rq1 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 rq2 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 rq3 p13 p14 p15 p13 p14 p15 p16 p17 p18 p16 p17 p18 b. baselines since there is no previous work to generate solutions for crash traces that we could find we choose two approaches for automatic solution generation for programming questions and two solution search methods commonly used by developers.
answerbot answerbot is a three stage framework to achieve the goal of generating an answer summary for a nonfactoid technical question.
answerbot evaluation has shown that its generated answer summaries are relevant useful and diverse.
in our experiment we use the crash trace as the input.
crokage crokage is a tool that takes the description of a programming task as a query and provides a comprehensive solution for the task.
we conduct our experiment by using their online website and take the crash reasons part of crash trace as input due to the limitation of input length.
google search engine google search engine is the most common way for developers to search for solutions.
however the length of input to google search engine is limited to words.
we take the crash reasons part of test crash trace as input in our experiment which is also the general practice of most developers.
for the sake of fairness we add site stackoverflow.com to the input of google search engine so that it searches only posts on stack overflow.
stack overflow search engine stack overflow is an important body of knowledge for solving developers technical questions.
developers formulate their question as a query to stack overflow and the search engine will return a list of relevant questions.
we also use the crash reasons as query due to its limitation of query input.
for the baselines based on a search engine we use the answer that is accepted or has the highest votes if there is no accepted answer from the first ranked stack overflow question returned by a search engine.
due to the different implementation of their search engines even if we input the same thing into google and stack overflow the order of so pages returned by both search engines is often different.
c. participant selection and task allocation we invited students who major in computer science to participate in our study including ph.d. students and graduate students.
as shown in table i they will be assigned to the user studies for rq1 rq2 and rq3 respectively.
all of them are not co authors and are indexed from p1 to p18.
all study participants have industrial experience in java programming ranging from to years and participants evaluating the android crash traces have at least years android development experience.
we have a tutorial for participants and they are allowed to conduct the study in their own lab.
1290table ii comparison results with baselines on different languages languages approaches relevance usefulness diversity javacrasolver .
.
.
google .
.
.
stack overflow .
.
.
answerbot .
.
.
crokage .
.
.
androidcrasolver .
.
.
google .
.
.
stack overflow .
.
.
answerbot .
.
.
crokage .
.
.
p value .
table i presents the task allocation.
the crash traces from java questions and from android questions are divided into four groups e.g.
java java android and android to reduce overall task size for participants.
rq1 and rq2 both evaluate the overall performance of c rasolver and rq3 evaluates the effectiveness of the retrieval component.
to avoid biasing results we have participants analyzing the same crash traces in rq1 and rq2 and arranged another group of participants to conduct rq3 e.g.
p1 p2 and p3 evaluate java in rq1 and rq2 but java are evaluated by p13 p14 and p15 in rq3 .
d. experimental results rq1 how does c rasolver perform compared to other approaches?
motivation.
crasolver aims to automatically provide a solution summarization for a given crash trace.
we choose two approaches for automatic solution generation for programming questions and two solution search methods commonly used by developers as baselines.
compared to these baselines we wanted to evaluate the overall performance of our c rasolver approach in terms of the relevance usefulness and diversity.
approach.
we compare c rasolver against four baselines described in section iii b. in this user study participants will first read the given crash trace followed by five solutions from c rasolver and the four baseline approaches.
note that participants do not know which approach each solution comes from and the order is randomized.
similar with xu et al.
participants are asked to score the five solutions from three aspects i.e.
relevance usefulness and diversity.
relevance refers to how relevant the solution is to the crash trace.
usefulness refers to how useful the solution is for solving the crash bug.
if a solution contains a variety of methods to solve the crash bug as long as one of them can solve the problem well we give it a high usefulness score.
diversity refers to whether the generated solution contains multiple relevant methods for the crash trace.
note that if some contents are not related to the crash the fig.
.
box plots of the relevance usefulness and diversity of different approaches e.g.
a crasolver b google c stack overflow d answerbot and e crokage.
diversity score cannot be improved because of this irrelevant content in the generated solution.
the score ranges from to .
score means irrelevant useless identical and means highly relevant useful diverse .
results.
table ii presents the mean of relevance usefulness and diversity scores and figure presents in box plots these scores of each solution from different approaches.
the baseline built on google is the best in all three aspects besides our crasolver method.
although xu et al.
have reported that answerbot diversity is much higher than that of google it has not performed well because their approach is not aimed at crash traces.
however ourcrasolver approach performs far better than the best baseline built on google .
this phenomenon demonstrates that directly using the crash reason of a crash trace as input to google has a limited effectiveness on identifying solutions to the crash bug.
for the java test crashes the relative improvements of c rasolver are .
.
and .
w.r.t.
relevance usefulness and diversity respectively.
for the android test crashes crasolver outperforms google solution search by .
.
and .
in terms of relevance usefulness and diversity respectively.
on average c rasolver outperforms the baseline built on google by .
.
and .
in terms of relevance usefulness and diversity respectively.
we conducted a wilcoxon signed rank test with a bonferroni correction to evaluate whether the differences between c rasolver and these baselines are statistically significant.
the improvements of our c rasolver approach over these baselines are statistically significant on three aspects at the confidence level of .
.
this suggests that the solution for crash trace solution generation by our c rasolver approach is better than other baselines in terms of relevance usefulness and especially diversity.
in summary c rasolver significantly outperforms other approaches for both java and android crash traces.
rq2 what impact does each of the proposed metrics have in our c rasolver approach?
1291table iii results of the ablation study languages approaches relevance usefulness diversity javacrasolver eksim3.
.
.
crasolver pdsim2.
.
.
crasolver .
.
.
androidcrasolver eksim3.
.
.
crasolver pdsim2.
.
.
crasolver .
.
.
p value .
p value .
motivation.
in order to improve the quality of the final generated solutions we introduce position dependent similarity and extra knowledge similarity to the relevant question retrieval component described in section ii b. however c rasolver can still work with only relying on one similarity metric.
thus we need to conduct an ablation study to investigate the influence of these two similarity metrics.
approach.
to answer this research question we analyze the performance gain achieved due to various components of our approach by performing an ablation study.
we first remove the extra knowledge from official documentation and set all the extra knowledge similarity scores to i.e.
eksim in c rasolver .
we refer to this reduced approach as crasolver eksim.
the second variant crasolver pdsim disables the position dependent similarity setting all the pdweight to be .
finally we compare the performance of solutions generated by the above two methods with c rasolver using both similarity metrics.
participants are asked to score each solution from these approaches as in rq1.
the tasks are assigned according to table i. results.
table iii presents the results of our ablation study.
we observe that c rasolver performs significantly better than using each similarity metric individually on both java test crashes andandroid test crashes .
on average c rasolver outperforms crasolver pdsimby .
.
and .
in terms of relevance usefulness and diversity c rasolver outperforms crasolver eksimby .
.
and .
respectively.
comparing the improvement ratio over crasolver pdsimand crasolver eksim we can see that the proposed position dependent similarity greatly improves the performance of our approach.
the introduction of extra knowledge further improves the effectiveness of c rasolver .
as for rq1 we conduct a wilcoxon signed rank test with a bonferroni correction which has been marked in the table.
the improvement of our approach over the variant crasolver pdsimon all three aspects is statistically significant at the confidence level of .
.
compared with crasolver eksim the improvement of c rasolver on diversity is statistically significant at the confidence level of the improvement on relevance and usefulness is statistically significant at the confidence level of .
.
in summary the combination of the two similarity metrics makes our crasolver approach achieve its best performance.rq3 how effective is c rasolver s relevant question retrieval component for crash traces?
motivation.
in order to generate high quality solutions c rasolver must first narrow down the search scope to find the stack overflow questions related to the given crash trace.
whether the retrieval questions are relevant to the given crash trace will greatly affect the quality of the final solution.
here we investigate the effectiveness of our relevant question retrieval component see section ii b in c rasolver compared with several traditional information retrieval methods.
approach.
we choose four most commonly used information retrieval methods as our baselines bm25 tf idf based information retrieval word embedding based information retrieval and document to vector based information retrieval .
bm25 is a ranking function used by search engines to estimate the relevance of documents to a given search query.
tf idf is also a traditional ir metric which has been widely used in software engineering .
yang et al.
use the mean of word embedding vectors to represent the document and calculate the similarity.
an unsupervised framework that learns continuous distributed vector representations for pieces of texts document to vector is an unsupervised framework that learns continuous distributed vector representations for pieces of texts.
for each test crash trace we collect the top relevant questions returned by our relevant question retrieval component or one of the baselines.
we put all the top results together from approaches and there are many overlapping questions.
then according to the task allocation table i we ask participants p13 p14 and p15 for java test crashes p16 p17 and p18 for android test crashes to identify the relevant questions within the results.
it is easy for participants because they only need to give yes no response.
each participant had days to complete the task and they spent an average of .
hours on it.
we further use fleiss kappa to measure the agreement between the three participants.
the kappa values are .
and .
for java test crashes and android test crashes respectively which indicate that participants have a high degree of consistency.
if there are inconsistent labels among the participants we take the label by majority rule as the final result.
the evaluation metrics we used to evaluate our retrieval component and other baselines are top k accuracy top k mean reciprocal rank mrr and mean average precision map which are widely used in previous software engineering studies .
top k accuracy is the percentage of test crash traces where there is at least one relevant question within the top k returned questions.
in this paper we set the k to be and .
mean reciprocal rank is the multiplicative inverse of the rank of the first relevant questions.
mean average precision is the average of precision for each test crash trace where the precision is the percentage of relevant questions within the top returned results.
results.
table iv presents the performance of different approaches in terms of top k accuracy mrr and map.
the 1292table iv perfomance of crasolver and other baselines in terms of top k a ccuracy mean reciprocal rank mrr and mean average precision map languages approaches top top top mrr map javatf idf .
.
.
.
.
bm25 .
.
.
.
.
word embedding .
.
.
.
.
doc2vec .
.
.
.
.
crasolver .
.
.
.
.
androidtf idf .
.
.
.
.
bm25 .
.
.
.
.
word embedding .
.
.
.
.
doc2vec .
.
.
.
.
crasolver .
.
.
.
.
table v some examples of generated solutions crash trace generated solutions process social.com.networking.social.media.app pid java.lang.noclassdeffounderror failed resolution of lcom squareup okhttp okhttpclient at com.squareup.picasso.okhttpdownloader.defaultokhttpclient okhttpdownloader.java at com.squareup.picasso.okhttpdownloader.
init okhttpdownloader.java at com.squareup.picasso.okhttpdownloader.
init okhttpdownloader.java at social.com.networkingsocialmediaapp.global.oncreate global.java ... caused by java.lang.classnotfoundexception didn t find class com.squareup.okhttp.okhttpclient on path dexpathlist zip file data app social.com.networking.social.media.app base.apk nativelibrarydirectories data app social.com.networking.social.
media.app lib arm64 vendor lib64 system lib64 at dalvik.system.basedexclassloader.findclass basedexclassloader.java at java.lang.classloader.loadclass classloader.java at java.lang.classloader.loadclass classloader.java at com.squareup.picasso.okhttpdownloader.defaultokhttpclient okhttpdownloader.java at com.squareup.picasso.okhttpdownloader.
init okhttpdownloader.java ...crasolver well this is not an appropriate solution but it seems that there is some bug in okhttp library.. to solve this error i just replaced my gradle with the older version of okhttp.
compile com.squareup.okhttp okhttp .
.
.
compile com.squareup.okhttp3 okhttp .
.
.
and it works like a charm.. thankyou.
those are the steps i followed to do the signup login linking of users with parseusers according to parse documentation and some tips i found on the web .
first i went to this website and created a new application.. i downloaded the facebook sdk i did the steps and and i added my package name and the default class name.
i added the key hashes ... baseline google got the solution it is happening because of instant run just disable it goto android studio file setting build execution deploy instant run.
exception in thread main java.io.ioexception not in gzip format at java.util.zip.gzipinputstream.readheader gzipinputstream.java at java.util.zip.gzipinputstream.
init gzipinputstream.java at java.util.zip.gzipinputstream.
init gzipinputstream.java at postgresjdbc.postgresjdbc.gunzip postgresjdbc.java at postgresjdbc.postgresjdbc.readbytes postgresjdbc.java at postgresjdbc.postgresjdbc.main postgresjdbc.java java result 1crasolver since fcontents contains your gzipped data it should be a byte and not a string?.
i recommend using ioutils for reading the file into a byte array as reading it into a string will most likely corrupt your data... baseline google string outstr out.tostring utf this out is ziped byte stream encode it to string then decode it from string will be lose some bytes.this maybe a bug of java.
to resolve it you can encode bytes to string in compress to return such as string infobase64encode new string base64.encodebase64 out.tobytearray ... exception in thread main java.lang.outofmemoryerror java heap space at java.util.hashmap.createentry hashmap.java at java.util.hashmap.addentry hashmap.java at java.util.hashmap.put hashmap.java at com.kaggle.baseline.baselinenew.createsimmap baselinenew.java at com.kaggle.baseline.baselinenew.
init baselinenew.java at com.kaggle.baseline.baselinenew.main baselinenew.java crasolver the problem is that eclipse memory analyser does not have enough heap space to open the heap dump file.you can solve the problem as follows open the memoryanalyzer.ini file.
change the default xmx1024m to a larger size note that on os x to increase the memory allocated to mat you need to right click memory analyzer.app and show the package contents.
the memoryanalyzer.ini file is under contents macos .
i was facing the same issue but with the eclipse plugin and i did not have any memory analyzer app in applications folder.
the solution which worked for me was .
right click on eclipse icon and select show package content.
go to contents eclipse.
open eclipse.ini.
restart eclipse.
baseline google well it s fairly self explanatory you ve run out of memory.
you may want to try starting it with more memory using the xmx flag e.g.
java xmx2048m whatever you d have written before this will use up to gigs of memory.
see the non standard options list for more details.
results show that the relevant question retrieval component ofcrasolver significantly outperforms other baselines in terms of top mrr and map for both test datasets.
compared to the best baseline approach bm25 our approach outperforms bm25 by and in terms of top mrr and map on java test crashes .
as for the android test crashes the relative improvements of c rasolver are and in terms of top mrr and map respectively.
another phenomenon is that almost all the metrics of our method are close to .
indicating its powerful performance in finding relevant so questions for crash traces.
our approach decomposes a crash trace into crash reasons andstack frames and introduces the position dependent similarity and extra knowledge similarity for retrieval component.
these enable c rasolver to achieve the best performance.
this also ensures that the resulting solution is mostly composed of answer paragraphs to the relevant questions.
the results indicate the effectiveness of the relevant question retrieval component and the superior performance of this component further improves the quality of our final generated solutions.
iv.
d iscussion in order to help developers resolve software crash bugs more efficiently we propose c rasolver to automatically generate solutions for thrown crash traces.
c rasolver decomposes 1293every crash trace into crash reasons andstack frames and utilizes the information of these two parts for better retrieval of similar crash traces.
in particular we designed two similarity scoring metrics for crash trace e.g.
position dependent similarity and extra knowledge similarity.
the experiments described in section iii have shown the effectiveness of our c rasolver approach.
in this section we qualitatively analyze the advantages and disadvantages of c rasolver .
until now there have been no approaches designed for automatic crash solution generation.
according to the experimental results from section iii the baseline built on google search engine performs the best among these other four baselines.
we manually compare solutions from the baseline built on google search engine and the solutions generated by c rasolver .
table v presents three examples.
in the first example we can see from the crash trace that the cause of this crash bug may be a problem related to the okhttp package or project configuration.
the solution generated by c rasolver first points out that there may be some bugs in the okhttp library and then gives a feasible solution replace my gradle with the older version of okhttp .
however the second paragraph of the solution describes the facebook sdk settings which is not very relevant to this crash trace.
we check the answer post corresponding to this paragraph and find that it comes from a question that throws the same crash reason as this crash trace report but involves different packages.
we introduce the mmr algorithm see section ii c to generate diversified and comprehensive solution suggestions which may also introduce some noise into the final output.
this leads to c rasolver suggested solutions occasionally containing some irrelevant content.
the solution from the baseline built on google provides a common method to solve the problem of project package configuration.
from this case we can find that the solutions given by c rasolver are more targeted while those from baseline built on google are more general.
in some cases like the second crash trace in table v the proportion of keywords gzip in the crash reason part is relatively low.
if we use crash reason to search for relevant answers in search engines as most developers do the answers returned by search engines may contain a lot about ioexception .
this will cost developers a lot of time to find the right solution.
in contrast c rasolver first utilizes thecrash reason to narrow down the search space.
among the relevant found questions c rasolver then introduces a position dependent similarity and an extra knowledge similarity to retrieve more relevant questions.
the tokens e.g.
zip and gzipinputstream in the stack frames of the crash trace help c rasolver to better locate relevant questions.
the experimental results of rq3 in section iii d also show the effectiveness of the relevant question retrieval component in our approach.
we can see from the solution generated by c rasolver it first explains the cause of the crash bug and then gives the targeted solution.
this also shows the disadvantage of using only the crash reason part of crash trace to search.
our approach utilizes both the crash reasonandstack frames contained in the crash trace which ensures better quality of the final generated solutions.
the third case is an outofmemoryerror which is a crash bug that we often encounter in our daily development.
the solution from baseline built on google suggests using the xmx flag to start the program with more memory.
in contrast crasolver provides not only the reason for the crash bug but also several alternative methods to solve it.
in this example c rasolver provides solutions for different situations with or without mat memory analyzer tool .
even better crasolver specially suggests a way to solve this crash bug on the os x system.
the solutions returned by the baseline built on google usually focus on a specific aspect of the solution to the crash bug.
our generated solutions are derived from answers posted in several relevant questions.
therefore the solutions generated by c rasolver can provide solutions with more alternative methods to solve crash bugs and more useful information for developers.
in addition to the advantages and disadvantages of our approach discussed above c rasolver is also limited to situations that developers can find relevant solutions for the thrown crash traces by referring to the relevant content on q a sites.
if there is no relevant content on q a sites crasolver is not able to generate useful and comprehensive solutions to the given crash traces.
in contrast the google search engine can search for relevant solutions from a much wider range of website resources and its results returned may be more useful.
however many programs depend on a certain framework thus many crash bugs are recurring.
the scale of questions on q a sites is also growing with the development of community.
our c rasolver approach has the potential to generate solutions for more crash traces in the future.
another limitation is that our implementation of c rasolver can only deal with crash traces based on java language at present.
at present we collect stack overflow questions tagged with java or android to build our repositories and the official documentation we use is java se api documentation .
however the crash logs in other languages e.g.
python and c also have a structure similar to the java call stack which makes it not difficult for our approach to support other language crash traces.
based on the idea proposed in this paper we plan to design algorithms that can analyze crash traces based on other programing languages to further enhance the generality of c rasolver .
in addition we will collect more official documentations from various languages and frameworks to extend the extra knowledge of our approach in the future.
v. t hreats to validity threats to internal validity are related to the implementation of different approaches and the design of our user study.
we have double checked our code to make sure that the questions used in test datasets are excluded from the question base when conducting experiments.
we directly use the published tool of answerbot and the online tool website of crokage .
as for the input to the search engines 1294we choose the crash reasons as long as possible in crash traces as the input which is also one of the most commonly ways for developers to search for solutions.
for the user study each participant s development experience and understanding of the given crash trace may affect the results.
we mitigate this threat by asking three participants with at least years of programming experience to score for each solution.
in addition we recruited participants who show interest in our research and give them enough time to do the user study to reduce any threats caused by a participant s impatience.
threats to external validity relate to the generalizability of the our experimental results.
there are crash traces from various programming languages on stack overflow and each program language has its own crash trace structure.
at present crasolver only supports crash traces based on java language.
but it is not difficult to support other languages based on the approach we propose.
for this reason we only use the java and android questions in this work.
as the experimental part needs a lot of human participation we only collected example java and example android crash traces for evaluation.
in future we will collect crash traces containing more types of crash bugs to mitigate these threats.
threats to construct validity relate to suitability of our evaluation metrics.
we use relevance usefulness and diversity to evaluate the quality of generated solutions.
these metrics are widely used to evaluate summarization tasks in software engineering .
to investigate the effectiveness of retrieval component in our approach we use top k accuracy mrr and map which are classical evaluation metrics for information retrieval .
vi.
r elated work text summarization.
although there is to our knowledge no previous work that automatically generates solutions for given crash traces this task is similar to other summarization tasks in software engineering e.g.
bug reports summarization and comment summarization .
rastkar et al.
used a bug report corpus to train a classifier and is based on conversational data for automatic bug report summarization.
mani et al.
proposed an unsupervised approach based on noise reducer to improve the precision of bug report summarization.
lotufo et al.
pose three hypotheses on what makes a sentence relevant and used heuristic rules to perform bug report summarization.
for comment summarization wong et al.
use natural language processing to filter relevant sentences to compose the descriptions for a code.
our approach borrows two patterns they used to identify important sentences.
surf classifies each user review sentence to one of the user intention categories and generates user review summary based on a scoring mechanism.
gias et al.
proposed two algorithms statistical and aspect based to summarize opinions about apis.
different from the above studies our work aims at providing useful solution generation for a given crash trace.
mining developer forums.
there are abundant resources for researchers to explore in developer q a forums.
treude etal.
analyzed how programmers ask and answer questions on the web.
they find that q a websites are effective for code reviews and conceptual questions.
ace is a novel traceability recovery approach to extract the code elements contained in informal documentation like stack overflow.
seahawk and prompter retrieve api names and keywords from stack overflow by the formulated queries based on the code context.
however their approach is not applicable to the crash trace solution recommendation problem.
huang et al.
proposed an approach named biker to recommend apis for the programming task via analyzing the posts on stack overflow.
answerbot bridges the lexical gap and provides relevant useful and diverse answer to the natural language queries.
crokage provides comprehensive solution containing not only relevant code examples but also their succinct explanations.
different from our approach the inputs to both answerbot and crokage are natural language queries which are difficult for developers to use to describe a complex crash bug in natural language.
in addition a lot of information contained in the crash trace will be lost.
analysing crash traces.
the crash trace has been used in many software engineering studies such as bug localization automated program repair and duplicate bug report detection .
crashlocator locates faulty functions by expanding function call sequences in a static call graph and then ranking suspicious functions according to the suspiciousness of each function.
wang et al.
proposed three rules to identify correlated crash types and an algorithm to locate and rank buggy files using crash correlation groups.
moreno et al.
and wong et al.
proposed to use code segments and stack traces to retrieve code elements relevant to bug reports.
mohammad et al.
transform stack traces into a trace graph and reformulate queries to improve ir based bug localization.
stmlocator automatically locates the relevant buggy source files for a given bug report.
for automated program repair gao et al.
proposed an approach to fix recurring crash bugs by generating edit scripts for source code via analyzing q a sites.
however their approach only uses the crash reason of crash traces to retrieve relevant questions by a search engine.
droix uses user event sequences e.g.
clicks and touches as input to repair buggy apps and utilizes the crash traces to locate the bug.
some other existing techniques in automated program repair typically rely on unit tests or test scripts to guide repair process.
different from these techniques that aim at generating patches our approach provides explanations for crash traces.
thus they are complementary and can work hand in hand to help developers resolve crashes.
kim et al.
proposed crash graphs which provide an aggregated view of multiple crashes in the same bucket to detect duplicate bug report.
dang et al.
proposed a method for clustering crash reports based on call stack matching.
similar to our position dependent similarity they also considered the distance to the top frame and alignment offset.
however they 1295used frame as the matching granularity and their similarity metric is formulated in a different way.
johannes et al.
only used stack traces and their structure as input for detecting bug report duplicates.
durfex is a feature extraction technique that extracts features from bug reports with a focus on crash traces for detection of duplicate bug reports.
however our approach not only analyses the structure of crash traces but also introduces extra knowledge for retrieving potential solution posts.
our experimental results in section iii d have shown its effectiveness.
vii.
c onclusion in this paper we propose c rasolver to automatically generate possible solution summaries from a given crash trace.
crasolver parses a crash trace into crash reasons and stack frames and introduces position dependent similarity and extra knowledge similarity measures to retrieve relevant questions on stack overflow.
after obtaining the answers to these questions c rasolver summarizes a solution based on several features.
we leverage both information contained in crash traces and also the knowledge in official documentation to improve the effectiveness of c rasolver .
our evaluation using java and android crash traces demonstrates the relevance usefulness and diversity of our generated solutions.
we believe the c rasolver approach will help developers solve crash bugs more efficiently and accurately in practice.
the code for our approach and the data of experiments are available at in the future we plan to integrate c rasolver into an ide and provide timely solutions when developers encounter crash bugs during development.
furthermore we will extend c rasolver to support crash traces based on more programming languages and introduce more official documentation into its knowledge base.
acknowledgment this research was partially supported by the national key r d program of china no.
2019yfb1600700 australian research council s discovery early career researcher award decra funding scheme de200100021 arc laureate fellowship funding scheme fl190100035 arc discovery grant dp200100020 key research and development program of zhejiang province no.2021c01014 and the national research foundation singapore under its industry alignment fund prepositioning iaf pp funding initiative.
any opinions findings and conclusions or recommendations expressed in this material are those of the author s and do not reflect the views of national research foundation singapore.