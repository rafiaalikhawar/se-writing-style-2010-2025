detecting optimization bugs in database engines via non optimizing reference engine construction manuel rigger manuel.rigger inf.ethz.ch department of computer science eth zurich zurich switzerlandzhendong su zhendong.su inf.ethz.ch department of computer science eth zurich zurich switzerland abstract database management systems dbms are used ubiquitously.
to efficiently access data they apply sophisticated optimizations.
incorrect optimizations can result in logic bugs which cause a query to compute an incorrect result set.
we propose non optimizing reference engine construction norec a fully automatic approach to detect optimization bugs in dbms.
conceptually this approach aims to evaluate a query by an optimizing and a non optimizing version of a dbms to then detect differences in their returned result set which would indicate a bug in the dbms.
obtaining a nonoptimizing version of a dbms is challenging because dbms typically provide limited control over optimizations.
our core insight is that a given potentially randomly generated optimized query can be rewritten to one that the dbms cannot optimize.
evaluating this unoptimized query effectively corresponds to a non optimizing reference engine executing the original query.
we evaluated norec in an extensive testing campaign on four widely used dbms namely postgresql mariadb sqlite and cockroachdb.
we found previously unknown bugs in the latest versions of these systems of which have been fixed by the developers.
of these were optimization bugs while the remaining were error and crash bugs.
our results suggest that norec is effective general and requires little implementation effort which makes the technique widely applicable in practice.
ccs concepts information systems database query processing software and its engineering software testing and debugging .
keywords database testing dbms testing query optimizer bugs test oracle acm reference format manuel rigger and zhendong su.
.
detecting optimization bugs in database engines via non optimizing reference engine construction.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
introduction database management systems dbms are an important component in many systems.
to meet the growing performance demands increasingly sophisticated optimizations for query evaluation are applied .
unsurprisingly the query optimizer is typically considered to be a dbms most complex component posing a major correctness challenge .
implementation errors in the optimizer can result in logic bugs which are bugs that cause a dbms to return an incorrect result set for a given query.
specifically we refer to logic bugs in the query optimizer as optimization bugs .
pivoted query synthesis pqs was recently proposed as a way of tackling logic bugs in dbms .
its core idea is to verify the dbms based on a single pivot row for which a query is generated that is expected to fetch this row.
while pqs has been effective in detecting many bugs in widely used dbms a significant drawback is the high implementation effort that is required to realize this technique specifically the technique requires the re implementation of the dbms provided operators and functions to determine whether a randomly generated expression evaluates to true .
since pqs considers only a single row it also fails to detect bugs such as when a duplicate row is mistakenly fetched or omitted.
another successful technique for detecting logic bugs in dbms was realized in a system called rags .
it is based on differential testing .
a query is generated that is sent to multiple dbms if the dbms disagree on the output at least one of the dbms is expected to be affected by a bug.
as noted by the authors a significant drawback of this technique is that it applies only to the common core of sql which is small because dbms differ in what operators and types they support and because even common operators have subtly different semantics between different dbms .
in this paper we propose non optimizing reference engine construction norec a novel general and cost effective technique for finding optimization bugs in dbms.
the high level idea of our approach is to compare the results of an optimizing version of a dbms against a version of the same dbms that does not perform any optimizations.
obtaining such a non optimizing version of a dbms is challenging.
while many dbms provide some options to control optimizations these are limited and specific to a dbms.
although adding such options would be a possibility so retrospectively would be error prone and impractical because of the high implementation effort and domain knowledge required.
rather we propose the idea that a given query can be rewritten so that the dbms is not expected to optimize it.
finding a translation mechanism that guarantees the same result as the original query while making optimizations inapplicable is not obvious.
our key insight is that this can be achieved by transforming a query with a where clause which is subject to extensive optimization by the dbmsarxiv .08292v1 jul 2020esec fse november virtual event usa manuel rigger and zhendong su listing illustrative example where a bug in sqlite s like optimization caused a record to mistakenly be omitted.
create table t0 c0 unique insert into t0values 1select from t0where t0.c0 glob 2select t0.c0 glob from t0 true and the basis for creating an efficient query plan to a query that evaluates the where clause s predicate on every record of the table which cannot be meaningfully optimized the number of records fetched by the first query must be equal to the number of times the where predicate evaluates to true for the second query.
a different result indicates a bug in the dbms.
listing illustrates the idea of our approach based on a bug that we found in sqlite where an optimization caused a row to be erroneously omitted from the result set.
starting from an initial database that contains a single record we generate query 1with a random where condition t0.c0 glob .glob is a regular expression operator and a regular expression that should match a followed by any number of characters.
since where and join clauses are performance critical they are subject to optimization by the dbms.
in this example sqlite applies the like optimization by using an index which is an auxiliary data structure used for efficient lookups and implicitly created based on theunique constraint to do a range search allowing the execution engine to skip irrelevant records.
unexpectedly the optimization causes the dbms to omit fetching the single record even though it matches the specified regular expression.
next we translate the first query to query 2so that the dbms is unlikely to optimize it namely by moving the where clause s predicate directly next to the select keyword which causes the query to evaluate the predicate on each record of the table.
we expect that the number of times the expression evaluates to true corresponds to the actual number of records fetched by the first query.
however in this example the expression evaluates to true for the single record in the database.
the dbms could only meaningfully apply the incorrect optimization to the first query but not to the second.
we reported this bug to the sqlite developers who quickly fixed it.
we implemented norec in a tool called sqlancer which is available at demonstrate the generality of our approach we evaluated norec on four widely used production level dbms sqlite mariadb postgresql and cockroachdb.
as part of an extensive month testing campaign in which we sought to demonstrate the effectiveness of the approach and maximize its real world impact we found previouslyunknown bugs many of which were serious of which were subsequently fixed and confirmed.
these comprised optimization bugs crash bugs assertion failures and error bugs.
although sqlite has been extensively tested by pqs norec found more than additional bugs in it demonstrating norec s effectiveness.
the dbms developers greatly appreciated our efforts.
for example the sqlite website describes our successful testing campaign and mentions the following rigger s work is currently unpublished.
when it is released it could be as influential as 1an artifact prepared for long term archival is also available .zalewski s invention of afl and profile guided fuzzing.
we believe that the simplicity effectiveness and low implementation effort of norec will result in its broad adoption.
in summary this paper contributes the following a new effective testing technique for dbms based on a novel test oracle for detecting optimization bugs called norec an implementation of norec in a tool called sqlancer an extensive evaluation of norec which uncovered more than new bugs in widely used dbms.
background database management systems and sql.
dbms are based on a data model which abstractly describes how data is organized.
most widely used dbms are based on the relational data model proposed by codd according to the db engines ranking seven of the ten most popular dbms are based on it.
in our work we primarily aim to test such relational dbms.
structured query language sql which is based on relational algebra is the most commonly used language in relational dbms to create databases tables insert rows as well as manipulate and retrieve data.
our approach is not directly applicable to nosql dbms as they often provide their own query languages or support only a sql subset however it is applicable to the newer generation of newsql dbms which attempt to achieve the same scalability of nosql dbms but provide sql as a query language .
automatic testing.
in this work we focus on automatic testing which is is an effective and practical way of finding bugs although it cannot guarantee their absence .
two components are crucial for an automatic testing approach.
first an effective test case must stress significant portions of the system under test to find bugs in them.
second a test oracle is required that detects whether a certain test case executes as expected.
while various database generators and query generators have been proposed to generate effective test cases test oracles have received less attention.
as part of this work we propose an effective cost effective test oracle that allows detecting logic bugs in dbms.
optimizations in dbms.
decades of work have been devoted to query optimization .
each dbms typically provides a query optimizer that inspects a query potentially simplifies it and maps it efficiently to physical accesses i.e.
by selecting one of potentially multiple available access paths .
consider the two queries in listing .
it is well understood that the primary performance gains of query optimizations stem from determining how the database records can be efficiently fetched.
consequently the query optimizer would focus its optimization effort on simplifying and creating an efficient query plan based on the where clause in query .
in query the predicate is evaluated once for every row in the result set and thus provides limited space for meaningful optimization.
as detailed below we utilize this observation to translate an optimized query to one that is less optimized.
differential testing.
differential testing refers to a testing technique where a single input is passed to multiple systems that are expected to produce the same output if the systems disagree on the output a bug in at least one of the systems has been detected.
slutz applied this technique for testing dbms in a system calleddetecting optimization bugs in database engines via norec esec fse november virtual event usa r1 r32 records r1 r2 r33 records true false true2 records where is true select from t0 where select is true from t0 rs1 rs2 rs3 dbmsquery optimizer dbmsquery optimizer r1 r2 r3 t0 dbmsquery optimizer dbmsquery optimizer 23correct optimization incorrect optimizationhigh optimization potential low optimization potential figure the core of the approach is the translation of an optimized query step to an unoptimized one step which allows the automatic detection of optimization bugs step .t0is a table contained in the database and rs1 rs2 as well as rs3are result sets returned by the dbms.
predicate is random but fixed.
rags by generating sql queries that are sent to multiple dbms and then observing differences in the output sets .
while the approach was effective the author stated that the small common core and the differences between different dbms were a challenge.
indeed dbms typically differ in the sql dialect that they support by deviating from the standard and providing dbms specific extensions .
for example the cockroachdb developers argued that they cannot use differential testing using postgresql which is the dbms that is closest to it correctness is difficult because we don t have any oracle of truth which would require a known working sql engine which is exactly the thing we re trying to break.
we are unable to use postgres as an oracle because cockroachdb has slightly different semantics and sql support and generating queries that execute identically on both is tricky and doesn t allow us to use the full cockroachdb grammar.
in this paper we propose an approach that allows building such a known working sql engine namely one that is expected to be free of optimization bugs.
as argued next it is unclear how differential testing could be used to achieve this.
controlling optimizations in dbms.
one obvious but infeasible approach to finding optimization bugs is to realize differential testing by executing a sql query once by disabling and once by enabling optimizations in a dbms to detect bug induced deviations in the result set.
this technique has been applied on compilers where programs were compiled without and with optimization flags.
for dbms the majority of optimizations cannot be disabled.
dbms typically provide some run time and compile time options to control the behavior of operators and optimizations but these are typically very limited.
for example the like optimization applied to the query in listing cannot be disabled sqlite provides only an option to control whether the operator should ignore the casing of the string.
similarly some dbms allow the specification of hints to the query optimizer for a given query which also does not apply to many optimizations.
although modifying the dbms to provide configuration options for all optimizations would be a possibility so would require dbms specific knowledge and would involve a high implementation effort.
approach to find optimization bugs in dbms we propose norec.
our core insight is that a given query that is optimized by the dbms can be transformed to another query that cannot be effectively optimized.
for brevity we refer to the query that is potentially optimized by the dbms as the optimized query and the query that is not or less optimized as the unoptimized query .
while our translation step cannot guarantee the absence of optimizations we found that this technique is widely applicable to disable them in practice.
.
approach overview figure illustrates our approach.
in step we randomly generate an optimized query of the form select from t0 where .
since most optimizations apply to data filtering such as expressed in the query s where clause we expect that the randomly generated query might be optimized by the dbms.
in the figure the database contains a single table t0holding the records r1 r2 and r3.
assuming that the dbms functions correctly the result set should correspond to rs1 which comprises two records r1andr3.
due to an incorrect optimization however it might occur that a record is omitted or a record is mistakenly fetched.
in the example rs2 mistakenly additionally contains r2.
in step we translate the optimized query to an unoptimized query of the form select is true from t0 .
this query lacks awhere condition.
thus the dbms must fetch every record in the selected table which effectively disables most of the optimizations that the dbms could apply.
furthermore this query evaluates as a boolean predicate on every record in the table.
this predicate should evaluate to true for every record that is contained in the result set of the optimized query i.e.
for which the where clause evaluates to true because the predicate must consistently yield the same value regardless of where it is used.
the result set thus must contain two records with true and one record with false .
in step we pass both queries to the dbms and compare the two result sets i.e.
rs1 rs2with rs3 .
for the optimized query we count the number of records that is rs1 2for the correctesec fse november virtual event usa manuel rigger and zhendong su listing join clauses can be copied during translation.
1select from t0left join t1ont0.c0 t1.c0 join t2 ont2.c0 t0.c1 where t2.c0 2select t2.c0 is true from t0left join t1on t0.c0 t1.c0 join t2ont2.c0 t0.c1 execution and rs2 3for the incorrect execution.
for the unoptimized query we count the number of true values in the result set that is column true r2 which should correspond to the number of records that are fetched for the optimized query.
since for the incorrect execution norec detects a bug in the query optimizer.
note that we consider only the cardinalities of the result set for the optimized query and for how many rows the expression evaluates to true for the unoptimized query to validate the dbms.
our empirical evidence demonstrates that this suffices to find all optimization bugs.
for completeness section .
describes how norec can be extended to also validate the records contents.
.
translating the query translating an optimized query to an unoptimized one is a straightforward automatic procedure.
as illustrated in figure step it requires moving the condition in a where clause to after the select statement so that it is executed on every row in the table.
as detailed next the basic approach can be extended to cover additional features of the dbms.
multiple tables.
in afrom clause multiple tables can be specified from which records are fetched which are typically joined by a predicate in the where clause.
although the previous examples only referred to a single table our approach directly applies to multiple tables without any modifications.
join clauses.
besides where clauses also join clauses can be used to join two tables.
for example consider query 1in listing which shows an example with one inner join and one left join .
the onclause for inner join s specifies that only those records should be fetched for which the condition evaluates to true for records in both tables i.e.
as if the predicate would have been specified in a where clause .
a left join fetches all records that an inner join fetches in addition it fetches all records from the left table that do not have a matching record in the right table by assuming selected columns from the right table to be null .
these and the other types of joins e.g.
natural join s right join s and full join s can be left unmodified during translation.
query 2shows that only the where condition t2.c0 was moved after the select clause and that the join s were copied.
an alternative strategy that could find additional bugs in joins would be to move their onclauses as well which would require translating them to multiple unoptimized queries see section .
order by.
order by clauses do not influence the cardinality of the result set.
thus the unoptimized query can either omit or replace it during translation to test for bugs related to this feature.
group by.
group by clauses group records with same values and are often used in combination with aggregate and window functions.
these clauses if present in the optimized query can be copied to the unoptimized query.
if so an additional query is required to sum up the intermediate counts of the individual groups assuming thatlisting we alternate between two strategies for determining the count for the optimized query.
1select from t0where while rs.
next count 2select count from t0where count rs.
getint listing we use an aggregate function to determine the count for the unoptimized query.
select sum count from select istrue as count from t0 count rs.
getint an aggregate function is used to sum up the records for which the expression evaluates to true cf.section .
.
.
determining the row count figure step 3does not illustrate how to compute the counts for the optimized and unoptimized queries.
we apply different strategies for this.
the naive approach is to iterate through the result set to determine the count which is applicable for both queries.
the second more efficient strategy the performance gain varies on various parameters such as the number of rows in the database relies on aggregate functions provided by the dbms to retrieve the count but might result in bugs being overlooked since the increased complexity of the query might make optimizations inapplicable.
to balance performance and bug finding capabilities we alternate between both strategies.
optimized query.
listing demonstrates the two ways how we compute the count for the optimized query from figure .
query 1represents the naive approach.
for this query the dbms returns a result set rs through which sqlancer iterates to determine the count.
query 2uses count to count the number of records by relying on the dbms for this.
this is more efficient because the dbms might optimize the query and also because the overhead for crossing the boundaries between the dbms and sqlancer is avoided .
sqlancer only needs to retrieve the count from the single record in the result set rsreturned by the dbms.
unoptimized query.
for the unoptimized query we assume that since the dbms is unable to optimize the query it is unable to optimize an aggregate function applied to it as well.
since using an aggregate function is more efficient we use only this strategy see listing .
the sum function adds up the predicate values by interpreting true as one and false as well as null as zero.
dbms such as postgresql and cockroachdb do not provide implicit conversions from booleans to integers and require an additional cast.
records content.
our basic idea can be extended to check the records contents.
to this end the query generated by step 2must list each column in addition to the predicate.
the records for which the predicate evaluates to true for the unoptimized query can then be compared with those fetched for the optimized query in step .
however retrieving and comparing the result sets makes it necessary to use the slower naive strategy presented above.
checking the records contents allowed us to find an additional bug in an sqlite extension albeit not in its optimizer.
we speculate that so was not more effective because we are unaware of any optimizations that transform the fetched content.
furthermore while it isdetecting optimization bugs in database engines via norec esec fse november virtual event usa possible that a dbms returns an incorrect result set with the correct cardinality our empirical evidence suggests that such bugs are unlikely to occur.
.
corner cases and limitations we tested a large subset of each dbms functionality and in the process identified general limitations as well as three sqlite corner cases that need to be specially treated by our approach.
we do not consider these limitations to be essential as they did not hinder the approach in finding bugs.
ambiguous queries.
sql queries can be ambiguous and thus it might be possible that a dbms returns a different result for the optimized query than the unoptimized one which was also a challenge for previous work .
in practice we found subqueries to be problematic especially when comparing the result of a subquery that might return more than one record with a value.
thus we decided to disable the generation of subqueries and will consider generating unambiguous subqueries as part of future work.
nondeterministic functions.
a query might be unambiguous but yield a different result between the optimized and unoptimized queries due to nondeterministic functions.
such functions include random number generators and those that return the current time.
to prevent false positives we disabled their generation.
short circuit evaluation.
our approach is not applicable to detect bugs where an optimization results in an exception or error being optimized way .
this is due to sql not specifying whether the andandoroperators must short circuit.
we found that dbms can handle this inconsistently between the optimized and unoptimized query.
consider a predicate okand er r where er rresults in an error when executed.
if okis executed first and yields false the dbms might avoid also evaluating er r causing the statement to execute without errors.
otherwise the execution of er rresults in an error.
consequently our approach cannot detect incorrect optimizations that prevent expected errors to occur.
other features.
our approach does neither directly apply to distinct clauses nor to queries that compute results over multiple records such as aggregate as well as window functions which is also a limitation that affects pqs.
also these features are optimized meaning that their implementation might be affected by optimization bugs as well.
we believe that our high level idea of translating an optimized to an unoptimized query could also be extended to be applicable in this context.
number comparisons in sqlite.
one of the three sqlite corner cases that caused problems was that sqlite3 considered floating point numbers and integers that represent the same value to be equal also when using the distinct keyword which caused inconsistent results.
in listing the distinct keyword in the view v0resulted in only one of the records being fetched which one is unspecified and differed between the optimized and unoptimized query.
for query 0was fetched thus the string concatenation yielded the value .
which evaluated to true .
for query .0was fetched from the view which resulted in the concatenated string .
.
which evaluated to false .
since such false positives wereuncommon in sqlite3 and not present in the other dbms we initially manually filtered out such false positives but then introduced an option to avoid generating distinct keywords in views.
listing the distinct keyword in views can cause inconsistent results in sqlite.
create table t0 c0 insert into t0 c0 values .
create view v0 c0 as select distinct c0from t0 1select count from v0where v0.c0 .
2select v0.c0 .
is true from v0 input columns in sqlite.
the second sqlite corner case concerned thedbstat extension in sqlite see listing .
the where clause stat.aggregate set an configuration option to true which changed the behavior of the query and causes a record to be fetched.
when we used this predicate directly after the select clause however the column was not used as an input and no record was fetched.
we addressed this by avoiding the generation of clauses that set the configuration option for this specific column and extension.
listing input columns in sqlite can change the behavior of queries create virtual table stat using dbstat select from stat where stat .
aggregate fetches one record select stat .
aggregate from stat false ambiguous group by s in sqlite.
the third sqlite corner case was given by ambiguous group by s in a view which caused problems in combination with other features such as optimizer hints see listing .
all other dbms that we tested prohibited such ambiguousgroup by s and returned an error for the view creation.
in our complete testing period we encountered such cases seldom which is why we did not address this in sqlancer.
listing ambiguous group by s in sqlite can cause inconsistent results create table t0 c0 c1 c2 primary key c2 without rowid create index i0ont0 cast c1 as int create view v0as select c0 from t0group by 1having c2 insert into t0 c2 values insert into t0 c1 c2 values select from v0where unlikely select unlikely from v0 true .
query and database generation the random and targeted generation of databases and queries for different workloads and purposes has been widely explored and is not a contribution of this paper.
our approach can be applied based on any randomlygenerated or existing database.
it can also be applied to any random query generator that prevents the generation or ignores errors in the corner cases described in section .
.
thus we explain our database and query generator only for completeness.
in our work we base the generation of databases and queries on sqlancer which we extended to cover additional dbms i.e.
cockroachdb and mariadb as well as sql features e.g.additionalesec fse november virtual event usa manuel rigger and zhendong su data types operators and functions .
sqlancer generates a database by randomly creating tables indexes inserting data as well as by updating and deleting data to stress the dbms in an attempt to increase the chances of finding bugs.
the core part of sqlancer s random query generation is the generation of random expressions which we use in where andjoin clauses.
sqlancer generates these expressions heuristically by selecting one of the applicable options.
the applicable options are specific to a given dbms since dbms vary in which operators they support and which implicit conversions they perform.
the generation of the expressions is based on the grammar of the respective dbms and the schema of the current database to generate valid