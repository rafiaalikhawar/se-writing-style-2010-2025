detecting memory related bugs by tracking heap memory management of c smart pointers xutong ma1 jiwei y an2 wei wang1 jun y an1 jian zhang1 and zongyan qiu4 1state key laboratory of computer science institute of software chinese academy of sciences 2technology center of software engineering institute of software chinese academy of sciences 3university of chinese academy of sciences 4school of mathematical sciences peking university emails maxt yanjw wangwei19 yanjun zj ios.ac.cn qzy math.pku.edu.cn abstract the smart pointer mechanism which is improved in the continuous versions of the c standards over the last decade is designed to prevent memory leak bugs by automat ically deallocating the managed memory blocks.
however notall kinds of memory errors can be immunized by adopting thismechanism.
for example dereferencing a null smart pointer willlead to a software failure.
due to the lack of specialized supportfor smart pointers the off the shelf c static analyzers cannoteffectively reveal these bugs.
in this paper we propose a static approach to detecting memory related bugs by tracking the heap memory managementof smart pointers.
the behaviors of smart pointers are modeledduring their lifetime to trace the state transitions of managedmemory blocks.
and the specially designed checkers are used tocheck the state changes according to five collected bug patterns.to evaluate the effectiveness of our approach we implement iton the top of the clang static analyzer.
a set of handmade codesnippets as well as nine popular open source c projects areused to compare our tool against four other analyzers.
the resultsshow that our approach can successfully discover nearly all thebuilt in bugs.
and out of reports generated from theopen source projects are true positives after manual reviewing where the bugs of dereferencing null smart pointers are mostfrequently reported.
to further confirm our reports we designpatches for aria2 restbed mysql and llvm in which sevenpull requests covering bug reports have been merged by thedevelopers up to now.
the results indicate that pointers shouldalways be carefully used even after migrated to smart pointersand static analysis upon specialized models can effectively detectsuch bugs.
index t erms c smart pointer memory errors i. i ntroduction due to the bug prone and inconvenient approaches of managing heap memory manually in the c c languages developers and maintainers have fought for decades againstmemory errors such as memory leak null pointer dereference and so on.
fortunately the new c standards the continuousversions since c provide the smart pointer mechanism to save them from the morass which have been widely usedin recent years.
figure presents the trend of smart pointer usages crossing the last decade.
the lines represent the statistics on githubwhen searching with keywords of unique ptr shared ptr weak ptr and smart pointer.
the entries in the figure indicate corresponding authors2011 .
.
.
.
.
a commits2011 b issues c repositories2011 d wiki unique ptr shared ptr weak ptr smart pointer fig.
trend of smart pointer usages on github the number of the entities which explicitly mention these keywords.
according to the results more and more projects beginto use smart pointers to manage heap memory approximatelysince and .
smart pointers are designed to prevent memory leak bugs.
the memory blocks assigned to smart pointers can be au tomatically deallocated when the smart pointers go out ofscope.
besides as the calls to destructors are scheduled by thecompiler smart pointers can also prevent use after free bugscaused by improperly scheduled manual deallocations .
however using smart pointers cannot immunize all kinds of memory errors.
the undefined behaviors of smart pointermethods presented in the cpp reference can lead to memory errors such as dereferencing null smart pointers andso on.
in addition improper usages of smart pointers whichare prohibited by the c core guidelines and widely used coding regulations can also lead to memory leaksand efficiency issues .
in this paper we call all thesememory related bugs caused by smart pointers the misuses of smart pointers missp .
static analysis is an effective way to check program defects.
36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee however according to our experiments on a handmade benchmark presented in section v b1 the off the shelf tools cannotprovide satisfactory results.
on one hand some coding stylecheckers like cppcheck and sprinter can only detect coding style problems and a few intra procedural missps insome simple functions.
on the other hand static analyzers likeclang static analyzer and facebook infer will miss a lot of real bugs according to our experiments.
the shortcomings of the off the shelf analyzers can be summarized into two aspects model and checker.
on onehand it is a straightforward approach to model smart point ers by directly analyzing their implementations in the c standard library.
however as those most commonly usedimplementations gcc libstdc clang libc and msvcstandard library are all very complex it is difficult andinefficient to model the behaviors in this way.
on the otherhand new checkers should also be specially designed to revealthe missps that cannot be reported by memory error checkers.
facing the shortcomings we propose our models of smart pointers and checkers on missps which can be seen asa smart pointer extension of the typestate analysis on heapmemory blocks .
we extend a general heap memorymodel to handle c memory management operationsand cooperate with the model of smart pointers.
and a set ofmeta operations are defined to model the method calls andrecord the states of smart pointer objects.
besides we alsodefine new checkers based on five error patterns extracted fromthe c standard and famous coding regulations.
and misspsare checked with these checkers according to the states of heapmemory and smart pointers.
we implement an analyzer spelton on the top of the clang static analyzer and evaluate it with a handmade benchmark and nine open source c projects.
the experimental resultsindicate that our approach can effectively detect missps.
ourmain contributions are listed as follows we model the behavior of smart pointers via a set ofmeta operations.
and the states of heap memory blocksare also extended to be managed by smart pointers an analyzer with checkers specially designed for fiveextracted bug patterns is implemented to systematicallyscan for missps on c projects our discoveries and suggestions on using smart pointersare also presented based on our statistics and bug reports.
ii.
b ackground in this section we will introduce the usages of smart pointers the basic concepts that smart pointers are based on as well as the different kinds of smart pointers defined in thec standard.
a. usage of c smart pointers to roughly understand how smart pointers work we present the comparison of managing memory manually and using smart pointers.
the following two functions implement thesame functionality line by line.
they first allocate a dog object then call its method bark and deallocate it at last.the left snippet manages the object manually whereas theone on the right hand side uses smart pointers.
void manualbark dog dog new dog dog bark delete dog void autobark unique ptr dog dog new dog dog bark no manual deallocations.
the comparison shows their two main differences.
first a smart pointer object instead of a raw pointer is used to point to the allocated memory.
and second manual deallocation forthe managed memory is not needed when using smart pointers.
b. raii and memory ownership raii based resource management c smart pointers are designed based on a common programming idiom in object oriented programming called resource acquisition is initialization raii or scope bound resource management sbrm .
the names explain this idiom from its twomain characteristics.
first the resource is allocated during theinitialization of a manager object.
and second their lifetimesare bound to the corresponding scope via the variable ofthe manager object.
therefore the resource can be properlydeallocated when it is no longer accessible.
the smart pointers take this idiom to manage the memory blocks assigned to them.
more specifically the manuallyallocated objects and arrays will be automatically deallocatedduring the destruction of the smart pointer objects that theyare assigned to.
and a smart pointer object will be destructedwhen it goes out of scope as expected e.g.
the function normally returns or accidentally e.g.
an exception is thrown from this scope .
as the destruction is scheduled by compilers the idiom can significantly help to prevent memory errorscaused by improperly scheduled manual deallocations suchas double free and use after free bugs .
ownership of heap memory blocks different from other raii based manager classes such as the file io stream whose resources can only be used through the manager object the allocated memory can also be used via a raw pointer.to take advantage of both smart pointers and raw pointers it is suggested by some coding guidelines to usethe memory block through a raw pointer and leave the smartpointers managing the deallocation of memory blocks only.these suggestions indicate that smart pointers are the owners of their managed memory blocks.
the ownership of a heap memory block represents the responsibility of deallocation .
if an object has a fieldpointing to a heap memory block and deallocates the blockin its destructor such as smart pointers we call these kindsof objects owners.
while for other blocks that are manually deallocated via a raw pointer their ownership is held bythe programmer.
ownership can be either transferred betweenowners or shared by a group of owners.
when ownership isuniquely held by one owner it can be transferred to other owners.
and this unique owner is responsible to deallocatethe memory.
while if the ownership is shared it cannot be 881t able i smart pointers in c standard and their features name standard ownership dereference array auto ptr c unique ye s n o unique ptr c unique ye s ye s shared ptr c shared ye s ye s weak ptr c n a no y es transferred but can only be released by one of these owners and the last owner reserved will deallocate the memory.
c. smart pointer implementations in c standard we summarize all kinds of smart pointer classes of the c standard in table i. the entries presented in the table include the class name the standard in which the class is introduced the kind of ownership management whether users can dereference the smart pointer and whether managing dynamic array allocated with operator new is supported.
in c standard the auto pointer auto ptr the first smart pointer class is introduced.
however as a consequenceof its ill formed copy semantics it is not widely used.
andit is replaced by the unique pointer unique ptr i nt h ec standard and fully removed in the c standard.
then in c standard the concept of smart pointers is further perfected with three new smart pointers.
the uniquepointer is designed as a unique owner in contrast with the shared pointer shared ptr which is used as a shared owner.
besides to prevent possible memory leaks causedby circular referencing of shared pointers the weakpointer weak ptr is also introduced in the c standard.different from the two kinds of owners the weak pointers arenot owners and they only reference the ownership managedby a group of shared pointers.
therefore they cannot bedereferenced.
to access the memory a weak pointer needsto be cast to a shared pointer.
since the auto pointers are deprecated and become seldom used we mainly focus on the weak pointers and two owner pointers the unique and shared pointer in this paper.
iii.
m isuses of smart pointers in this section we will introduce the misuses of smart pointers missp .
a motivating example will first show the real world missps then each pattern that we extracted isexplained with a simple example.
a. motivating example the code presented in figure is composed of three realworld missps found in three different projects .
among them bug and are found and reported by us and bug is found from the commit history and can alsobe reported by our tool.
there is one class and two functionsin the code.
class request on line has three methods and the other two functions handlerequest line and entry line work with a request object managed by a unique pointer.
when using an instance of class request users can add a buffer to the instance via method addbuffer and handle1struct request bool addbuffer char b static void handlewithbuf request r static void handlewithoutbuf request r 6void handlerequest unique ptr request r bool hasbuffer if r hasbuffer request handlewithbuf r else request handlewithoutbuf r bug 11void entry unique ptr request r unique ptr char b new char bug handlerequest move r r addbuffer b.get bug fig.
the motivating example the request with method handlewithbuf or users can call function handlewithoutbuf directly without adding a buffer.
the buffer added with method addbuffer will not be deallocated in the class and the function returns true if the buffer is successfully added.
function handlerequest andentry implement an example of handling requests.
the execution of the examplestarts from function entry.
a buffer is allocated and assigned to a unique pointer.
then the buffer is lent to the argumentinstance of class request.
then the request is moved to function handlerequest to be handled.
the three bugs are commented in the example.
on line the nullity of unique pointer ris checked.
and it can be inferred that if pointer ris null the operator call on the else branch line will dereference a null smart pointer bug .on line a buffer is allocated with operator new and is then assigned to a unique pointer of type char.
this indicates that operator delete will be used during deallocation which cannot be matched with the allocator operator bug .
andon line the unique pointer ris moved to the parameter rof function handlerequest.
then the operator will dereference a null smart pointer on line bug .
although the three bugs can all trigger program crashes the off the shelf memory error checkers cannot provide uswith desired reports.
we tried to scan the example codewith the latest version of two static analyzers clang staticanalyzer csa and infer and two coding style checkers cppcheck and sprinter .
among these four tools csa can only report a use after moved bug on line which seems less important than dereferencing a null smartpointer whereas sprinter can correctly report bug on line but the report will be suppressed if there is an intermediateraw pointer forwarding the address.
and the other two toolsfail to report any of the bugs.
b. patterns of missps the bug patterns of misuses of smart pointers missp are extracted from the undefined behaviors in the c standard according to the introductions on the cpp reference as well as the rules in the c core guidelines and the smart pointer guidelines of the chromium project .
five patterns are finally selected as they are likely to cause a crash or have 882void dereferencenull unique ptr int p p a dereference null dn void badassignment int a unique ptr int p a b bad assignment ba void typemismatch unique ptr int op op.reset new int unique ptr int ap ap.reset new int c type mismatch tm struct t shared ptr t t void circularreference shared ptr t t new t t t t d circular reference cr int use shared ptr int p2 return p2 ?
p int uniqueshared shared ptr int p1 new int return use p1 e unique shared us fig.
examples of misuses of smart pointers efficiency issues that have not been paid enough attention to.
we will further introduce the reason why these patternsare selected and what the other patterns are in section vi.these five kinds of missps can be illustrated with the simpleexamples presented in figure .
dereference null dn .
the term dereference null is short for dereferencing a null smart pointer.
similar to raw pointers dereferencing a null smart pointer will also lead to a crash.
forthe two kinds of owner smart pointers i.e.
the unique and the shared pointers they can be dereferenced via the overriddenoperator arrow star and subscription .
therefore we report a dereference null bug if these operators are called with a null smart pointer.
bad assignment ba .
the memory managed by owner smart pointers will always be deallocated.
therefore when asmart pointer points to a memory block that should not bedeallocated such as stack memory and so on we will reportthe assignment as a bad assignment bug.
type mismatch tm .
the type argument of the smart pointer will determine whether operator delete or delete will be used to deallocate the memory.
if it does not match with the allocator of the managed memory we willreport a type mismatch bug on the assignment.
circular reference cr .
all reference counting based memory management mechanisms suffer the circular referenc ing problem so are the shared pointers.
however a garbagecollector is not available for shared pointers to reclaim thememory in the cyclic structures.
when a ring of memoryblocks is connected with smart pointers we will report acircular reference bug.
unique shared us .
shared pointers consume more memory and time than unique pointers during execution.besides shared pointers are infectious.
when a shared pointeris used all related pointers should also be replaced with sharedpointers.
since there would be many shared pointers used it isusually hard to infer which shared pointer actually deallocatesthe managed memory .
therefore as a consideration ofprogram efficiency and maintainability unique pointers shouldbe used if the ownership is not semantically shared .
in the example the parameter p2 is only dereferenced without sharing the ownership to other objects or containers.and pointer p1 is used to automatically deallocate the memory and satisfy the interface of calling function use.
in this case we will report a unique shared bug for pointers p1 andp2.
the solution is to change pointer p1 to a unique pointer to manage the memory block and replace p2 with a raw pointer to dereference the memory.
iv .
a pproach of checking missp s in this section starting with the workflow we will introduce our extension of memory block states models of smartpointers as well as checkers for the bug patterns.
and a casestudy on the motivating example will be presented at the endof this section to concretely illustrate our approach.
a. overview of workflow to explain how missps are checked we present the workflow of our approach in figure .
the components surrounded with dashed lines represent the ones that are newly added tomodel and check smart pointers.
6rxufh rgh xj 5hsruwv khfnhuv iru 0lv63v 6pduw 3rlqwhu 0rghohu 3urjudp 6wdwh 6wdwh ri 0hpru orfnv 6wdwh ri 6pduw 3rlqwhuv0hpru 0rghohu 6wdwhphqw ydoxdwru 0hpru 2shudwlrqv 6pduw 3rlqwhu 2shudwlrqv0hpru 2shudwlrqv fig.
workflow of checking missps the statement evaluator will parse the input file and analyze each function according to the topological order ofthe call graph.
it is used to explore program paths andevaluate the encountered statements that are not related toheap memory and smart pointers.
for the operations on rawpointers and memory blocks they are modeled by the memory modeler section iv c which is a typestate analysis on the heap memory blocks.
and the smart pointer modeler section iv d extends the typestate analysis with new states andoperations of heap memory and smart pointers.
the modelers will modify the program state section iv b according to the operations executed.
and if a smart pointeroperation needs to modify the state of its managed memoryblock the memory modeler will be invoked by the smart pointer modeler to handle the corresponding memory operations.
when applying the model the states of memoryblocks and smart pointers will be checked by the checkers for missps section iv e and bug reports will be generated if any missps are found.
b. program state the program states record the states of memory blocks and smart pointers.
we use mem to represent the set of all valid heap memory blocks which is composed of the 883allocated memory set am the set of captured memory from external contexts em and the set of null pointer values .f o r simplicity we use to refer to the global null pointer constant.
and set ptr is used to denote all of the smart pointer objects among the entire program together with set var to represent all variable names in the code.
in the c language three pairs of allocators and deallocators are used to manage heap memory managing raw blocks with function malloc free and so on managing dynamic objects with the operator new anddelete and managing dynamic arrays with the operator new anddelete .
we use enumerate value raw object andarray to represent the type of the allocators and deallocators that are used in these three kinds of memory management approachesrespectively.
and for simplicity the set raw object array is represented as adt .
besides value any is used as the type of the allocator of a memory block captured from theexternal context which indicates that we do not know howit is allocated and it can be reclaimed with all kinds ofdeallocators.
and there are no deallocators of type any .
with the definitions of the above sets we define the program state as a triplet s angbracketleftm p q angbracketrightwhere m mem is the set of monitored memory blocks that are being analyzed in the current context p ptr indicates the set of all traced smart pointers q m p p represents the map from a monitored memory block to the set of all its owner smart pointers.
for a monitored memory block m m it is defined as a tripletm angbracketleftid at st angbracketrightwhere id nis a natural number used as the identifier of the memory block at adt any represents its allocator type st memst denotes the state of the memory block where the set of all states is memst allocated captured escaped usable null freed bad .
and we define a traced smart pointer p pas a triplet p angbracketleftvn dt tm angbracketrightwhere vn var is its variable name used as a unique identifier dt adt represents the type of its pending deallocator tm mem indicates the memory block it points to.
when a monitored non null memory block m m is assigned to a traced owner pointer p p w eh a v e p.tm m. and it is required that pointer pshould be added to block m s owner set q and removed after unassigned.
in the following subsections we will introduce the operations on memory blocks and smart pointers as well as thetransitions of the program state.
c. modeling state transitions of memory blocks the state transitions of memory blocks are modeled with the memory modeler.
for a memory block m its identifier m.id and allocator type m.atare determined when it is created and will not be changed then.
however the operations performed on memory blocks will change its state m.st.
to support checking c code with smart pointers we extend the state5 v oorfdwhg vfdshg 1xoo dggg p dw p dw p dw 8vdeoh p dw dswxuhg uhhg fig.
state transitions of memory blocks transitions of heap memory which are widely used to checkmemory errors .
the operations on a memory block are composed of three kinds of d ealloca te operations of the adt types as well as the c heck l oad and r elinquish operations.
to distinguish different kinds of d ealloca te operations for a deallocator of type t function d el t is used to represent the corresponding d ealloca te operation.
and for a monitored memory block m we define another function b addel m.at to represent the set of d ealloca te operations with mismatched deallocators where baddel m.at braceleftbig m.at any del t t adt m.at m.at adt figure presents the state transitions of a memory block m where a lldelrepresents all three kinds of d ealloca te operations.
the operations that will not change the states areomitted for simplicity.
for an allocated memory block m a am its initial state isallocated.
and the type of the corresponding allocator will be stored as its allocator type ma.at.i fm ais then managed by a group of shared pointers and one of the pointers is sentto an uninterpreted function or inserted into an stl container operation r elinquish will change its state to escaped.
for a memory block mecaptured via an external pointer me em its initial state is captured and its allocator type is set to any.
on one hand if meis directly dereferenced via operation l oad we will modify its state to usable.
on the other hand if its nullity is checked with operation check the state will be changed to usable on the then branch whereas null on the else branch.
the usable state indicates that memory block meis confirmed to be non null on the then branch.
while the null state on the else branch represents me is a null constant and block mewill also be moved from the set of external memory em to the null constant set .
all the allocated escaped and usable memory blocks can be deallocated.
the only exception is the escaped memory blocks whose deallocation via shared pointer destructors willbe omitted as we cannot know whether there are any otherowners left.
when a memory block mis reclaimed with the d ealloca te operations that are not in the invalid deallocator set b addel m.at its state can be changed to freed.
apart from the transitions mentioned above there are also edges representing memory errors which will change the statetobad.
these errors are mismatched memory management routines allocated and escaped tobad use after free freed tobad and null pointer dereference null tobad .
884d.
modeling operations on smart pointers the smart pointer modeler manages the state transitions of smart pointer objects.
the states mainly focus on assignments and ownership management.
when a new smart pointer p is defined or an external one is referred to for the firsttime we will create an object for it.
its variable name p.vn and deallocator type p.dt are directly set according to its declaration and will not be changed during its lifetime.
itsvaluep.tm will be assigned to the null pointer constant before it is further used via other operations.
as the owner pointers and weak pointers have differences in ownership management we will separately introduce theiroperations in the next two subsections.
owner smart pointer operations to model the assignment of owner pointers we define two meta operations s et and u nset to assign or unassign a smart pointer.
their operational semantics are presented below.
p p m m p. tm p q set p m p. tm m q q p p p m m p. tm m p q unset p p.tm q q p the s et operation assigns a memory block mto an empty smart pointer pwhereas the u nset operation clears a previous assignment.
when assigning with operation s et p m the value of the assigned pointer p.tm will be modified to the assigned memory block m andpwill be added to m s owner setq vice versa for operation u nset p .
after operation unset the pointer will be reassigned to null.
with the definition of two meta operations and operations on memory blocks we can now define the operations onowner pointers.
the operational semantics of these operationsare presented below.
among these operations apart from the s hare operation which can only be used on a shared pointer the others can be applied to both kinds of owner pointers.for simplicity we will omit the preconditions of requiring thementioned pointers to be traced p p .
q p.tm clear p del p.dt p.tm unset p q p.tm negationslash clear p unset p m m m. st freed bad q m.at any m.at negationslash any m.at p.dt assign p m clear p set p m share p1 p2 clear p2 set p2 p1.tm move p1 p2 clear p2 set p2 p1.tm unset p1 p.tm access p load p.tm inspect p check p.tm operation c lear is used to break the original assignment which is used when destructing or reassigning a smart pointer.for a unique pointer and the last live shared pointer defini tion is used to deallocate the managed memory block andset the pointer to null.
whereas when clearing an empty smartpointer or one of a group of shared pointers definition canunassign the pointer and leave the memory unchanged.
in contrast with operation c lear three operations are used to assign an owner pointer.
operation a ssign is used to reassign a pointer.
the s hare operation is used to share the ownership with another shared pointer.
and operation m ove can transfer the ownership from one smart pointer to another.when assigning an owner pointer the previous assignmentwill be canceled with operation c lear and then the new value will be assigned with operation s et.
and for the m ove operation the source pointer will also be cleared.
the other two operations a ccess and i nspect are just wrapped memory block operations.
they are used to l oad or c heck a memory block respectively.
the preconditions of a ssign and a ccess operation are used to check the missps.
we will further introduce them insection iv e. weak pointer operations for the weak pointers as they do not manage the ownership and cannot be dereferenced theyonly have two operations c at c h and l ock .
the corresponding operational semantics are presented below.
cat c h pw ps p w.tm ps.tm pw.tm m m.st captured lock ps pw check m lock pw ps pw.tm m m.st allocated escaped usable lock pw ps share pw ps pw.tm m m.st null freed bad lock pw ps clear ps the c at c h operation is used to reference the ownership of a group of shared pointers.
as the weak pointers are notowners of the managed memory block m we will only reset the value without adding the pointer to the owner set of thepointee memory block q .
and the l ock operation is used to create a new shared pointer from the referenced ownership.
if a weak pointerpointing to a memory block mwith a captured state operation c heck will be first used to determine its nullity and a shared pointerpswill be created with a recursive call on both the usable and null branches.
when the state of misallocated escaped orusable the created shared pointer pswill share the ownership of m. and if mcannot be dereferenced i.e.
freed null orbad a null shared pointer will be created.
a weak pointer is expired when its memory block is deallocated.
e. checkers for missps the checkers are specially designed for the five patterns.
the states of related memory blocks and smart pointers aswell as the owner sets qwill be checked by the checkers.
the precondition of operation a ccess p.tm requires the dereferenced smart pointer should not point to a nullconstant which is used to check the dereference null bugs.
besides to detect such bugs caused by expired weak pointers we suppose the first shared pointer created by operation l ock on an external weak pointer is always the last remaining owner.and when the managed memory is therefore deallocated the 885t able ii state transitions of the motivating example line statement operation monitored memory block set m traced smart pointer set p map of owner sets q begin new char allocate array angbracketleftm array allocated angbracketright m1 b m assign b m angbracketleftm array allocated angbracketright angbracketleftb object m1 angbracketright m1 b r n move r r angbracketleftm array allocated angbracketright angbracketleftm2 any captured angbracketright angbracketleftb object m1 angbracketright angbracketleftr object m2 angbracketright m b m r move r move r r angbracketleftm array allocated angbracketright angbracketleftm2 any captured angbracketright angbracketleftb object m1 angbracketright angbracketleftr object angbracketright m1 b m r angbracketleftr object m2 angbracketright begin r n inspect r angbracketleftm any captured angbracketright angbracketleftr object m1 angbracketright m1 r if r inspect r t angbracketleftm any usable angbracketright angbracketleftr object m1 angbracketright m1 r if r inspect r f angbracketleftm any null angbracketright angbracketleftr object m1 angbracketright weak pointer will get expired and the future calls to operation lock will generate null pointers only.
for operation a ssign two kinds of bugs will be checked on the assigned memory block m. the first three clauses of its preconditions require that block mshould have been monitored and can be deallocated m m and not in deallocated or error state m. st freed bad or managed by other owners q .
if block mviolates any of the conditions it will trigger a bad assignment bug.
and the last clause requires that the memory block mis either a captured external one m. at any or is allocated in the current context m. at negationslash any and the deallocator type of the assigned smart pointer pcan match its allocator type m.at p.dt .
a type mismatch bug will be reported if the condition is unsatisfiable.
acircular reference bug is defined as a ring of memory blocks linked with smart pointers.
we use the owner set qof each monitored memory block to create the point to graph.
if a cyclic structure can be found in the graph starting from thenewly assigned memory block it means the assignment trig gers a circular reference bug.
the circular reference checker is invoked every time after operation a ssign .
to check the unique shared bugs the owner set of a memory block should be tracked when it is assigned to a shared pointer.when calling operation a ssign with a shared pointer p i t will be recorded as the first owner of the assigned memoryblock.
and when operation c lear on pointer pdeallocates its managed memory definition it means that the ownership isuniquely held by the first owner pand should be replaced with a unique pointer.
besides when the first owner p 1is the only remaining owner of its managed memory block and operation move transfers its ownership to another shared pointer p2 pointerp2will become the new first owner.
f .
case study on motivating example in this subsection we use the motivating example in figure to concretely illustrate how our checkers work.
theprogram state transitions are presented in table ii.
the suffixestand fof operation i nspect represent the state on the true orfalse branch respectively and prefix n denotes the changed state before an operation.
the analysis starts from the top level function among the call graph i.e.
function entry.
at the beginning of the function line the state is empty.
the first statement inthe function is the new operator call on line .
it willcreate a memory block object of angbracketleftm array allocated angbracketright.a s the block is not assigned to a smart pointer its owner setq m is left empty.
next the memory block m1will be assigned to smart pointer bvia operation a ssign b m on line .
before that pointer bwill be created as angbracketleftb object angbracketright.
then in the operation the checkers found that the last clause of theprecondition m .at any m1.at negationslash any m1.at b.dt is violated where b.dt object andm1.at array .
therefore a type mismatch bug will be reported here.
as the error will not make the program crash the analysis willcontinue.
after the assignment the pointer bwill be changed to angbracketleftb object m angbracketright and it is added to the owner set of memory blockm1.
after that we will evaluate the arguments for the call to function handlerequest on line .
as the evaluation order of the arguments is undefined in the c standard wewill first evaluate the call to function std move and then the arrow operator call of smart pointer r. the function call to std move on line will trigger operation m ove r r which moves the ownership from the parameter rof function entry to the parameter rof function handlerequest.
after that pointer rwill be cleared and pointer rwill take the ownership of memory block m2.
finally on the next line operation a ccess r in the arrow operator call of pointer rwill trigger a dereference null bug as it breaks the precondition of the a ccess operation.
and the analysis on this path is therefore terminated here.
as there are no remaining paths for function entry the analysis will restart from function handlerequest line .
when checking the nullity of smart pointer r a memory blockmwith state captured will be recovered to pointer r. then operation i nspect r will fork the path and change the state of m tousable ornull on the true orfalse branch respectively.
and a dereference null problem will be then reported on the false branch with operation a ccess r when calling operator of pointer r. v. e v alua tion to evaluate the effectiveness of our model and the ability to reveal missps we carried out three groups of experimentsto answer the following three research questions.
rq effectiveness.
how many handmade and real world missps can be detected by our tool?
rq usability.
how much time and memory will be consumed?
what are the reasons for false alarms?
rq discoveries.
what can we know about missps from our statistics?
the first research question evaluates the effectiveness of our tool.
we use a handmade benchmark and nine open source c projects to present the effectiveness of our tool andcompare the ability to detect missps with the off the shelfopen source static analysis tools.
the comparison is presentedin section v b1 and v b2.
to evaluate the usability we alsomeasure the time and memory cost of our tool on the open source projects.
and the composition of false positives andtheir reasons are also discussed in section v c. the thirdresearch question is used to present the discoveries duringchecking missps.
the corresponding empirical conclusionsand hints on using smart pointers are presented in section v d. a. setup of experiments implementation we implement our tool spelton on top of the symbolic execution engine of the clang static analyzer csa .
.
with all its original checkers disabled.
the original csa has very limited support of cross translation unit ctu analysis i.e.
inlining inter file function calls.
to help spelton to find the desired inter file function definitions and import them to the current analysis context we also im proved the features and fixed the bugs in csa .
.
.
besides to speed up the analysis process and take full advantage ofthe system resources gnu make is used to concurrently generate ctu function indexes as well as analyze the codefor each source file.
therefore our spelton can be considered as a standalone missp finding tool.
when analyzing an input file the analysis engine of the csa will handle the static symbolic execution process anditschecker mechanism is used to model the smart pointer method calls and check for missps.
when a smart pointermethod is called instead of inlining the callee we will applythe corresponding operations of smart pointers and memoryblocks and check missps based on our error patterns.
environment and tools we set up all of our experiments on a linux server with two intel xeon e5 v4 cpus of threads and gb of memory in total.
weevaluate our tool against four off the shelf tools of the latestversion including clang static analyzer csa .
.
infer static analyzer infer v1.
cppcheck v2.
and sprinter v1.
.
benchmark composition our benchmark is composed of two parts handmade snippets and open source projects.
the first part is the handmade code snippets which are used to test the ability to model the behaviors of smartpointers and check the inserted missps.
table iii presents thedetailed statistics of the handmade benchmark.
the number offiles inserted bugs pos.
and corresponding fixes neg.
are presented for each category.
the first group of snippets is automatically generated by imitating the juliet test suite v1.
jts .
we manually created bug templates by replacing the invoked methods int able iii statistics of handmade snippets.
the imitatedones are grouped with bug types and the mutated ones arecategorized with their original cwe ids.
typesimitated snippets mutated snippetstotal dn ba tm cr us c415 c476 c590 c762 files pos.
neg.
t able iv information of the open source project instances.statistics of smart pointer utilization are presented as follows the numbers of smart pointers of class members f localvariables l and reference variables r as well as methodcalls with a ccess operations a among all calls all .
project commit kloc f l r a all aquila d5e3bd .
aria2 9d0a48 .
celero 0d7b24 .
evpp .
osrm 15f0ca .
restbed 03f1f2 .
spdlog 3dedb5 .
mysql ee4455 .
llvm bbd4eb .
figure with the ones of the same functionality and addingtests on our model of smart pointers.
a part of them isdesigned for both unique and shared pointers while others arefor shared pointers only.
the test code snippets are generatedby applying the bug templates on control flow templatesextracted from the jts.
the remaining snippets are semi automatically mutated from four types of memory errors in the jts.
for each typeof memory errors selected we first manually design how tomutate the bug to one of the patterns we check.
then wecarry out the mutation on the original snippets and merge thesimilar ones where only their data types of the pointers aredifferent.
and finally the snippets are manually reviewed toremove the invalid ones that cannot be analyzed by csa.
the second part of our benchmark is composed of nine c open source projects from github as shown in table iv.
the selected projects are all written in c or newer versions ofc standards whose usability is important in their applicationfields backend services performance benchmarks networklibraries and compilers.
for each project we use their latestversions when carrying out the experiments.
the correspond ing commit hashes and kilo lines of code are presented in thesecond and third columns.
besides to present their utilizationof smart pointers we also provide the corresponding statisticsin the last four columns.
b. evaluation on effectiveness we evaluate the effectiveness of spelton against four other off the shelf tools on the handmade benchmark as well as the open source c projects.
effectiveness on handmade benchmark in this experiment the precision and recall of all five tools are evaluated.
887t able v effectiveness on handmade benchmark tool spelton csa infer cppcheck sprinter tp tn fp fn precision .
.
n a .
.
recall .
.
n a .
.
f1 .
.
n a .
.
the purpose of this experiment is to use these straightforward bugs to check their ability to reveal the missps.
table v presents the statistics of these measures.
among the reports of these tools the unrelated true reports are removedbefore counting while the false ones are recorded as falsepositives.
the first four rows present the number of true orfalse positives or negatives.
and the last three rows showthe precision recall and f1 measure values.
according to the table spelton can find almost all bugs with no false alarms.
the only two false negatives are caused byimproperly handled switch case statements.
while other tools can only detect a part of bugs with false positives.
effectiveness on open source projects to evaluate the effectiveness on real world c code we run these tools onnine popular open source c projects.
compared with thehandmade benchmark these real world projects have massivecode kloc each project and complex features.
theresults are presented in the left two groups of table vi wherethe empty cells indicate no bugs are reported.
the first group of columns provides how many bugs are reported by the four other off the shelf tools.
as there aretoo many reports to review we use the information of smartpointer variables presented in table iv to automatically findthe reports related to smart pointers.
the filter selects 151reports shown with the numbers in parentheses and onlyone report of csa and two reports of sprinter are true bugs with manual review.
the bugs missed by spelton are those memory errors triggered with raw pointers cooperating withsmart pointers.
we will have a discussion on such memoryerrors in section vi.
for the results of spelton in the second group the number of reports is categorized with their types of bug patterns andthe results are presented with the ratio of true positives toall reports.
according to the table out of reportsgenerated by our tool are recognized as real bugs after amanual review.
and the most frequently reported bugs are thedereference null bugs.
to further confirm the true positives generated by spelton patches are designed and submitted to the developers where related bugs are fixed together within one patch.
bynow seven patches have been merged and five patches havenot been reviewed yet.
besides one has been fixed before wesubmitted it and one has been confirmed by the developers asa true bug but they do not intend to fix such kinds of bugs.among the merged patches bugs in reports are fixed.c.
evaluation on usability the usability of spelton is evaluated with the cost of time and memory.
besides the reasons for our false positives in theopen source projects are also discussed in this section.
evaluation on time and memory cost the total time and memory costs of spelton are presented in the last two groups of table vi.
the time cost is measured in seconds while for the memory cost we measure the peak memory costcollected from the process status.
for best performance weoptimize spelton with o3 option.
the max cost is measured for each input file and the average value is computed for every kilo line of source code.
according to the measurements a project with the average size of all evaluated projects .
kloc can be ana lyzed with .
seconds and .
mb of memorysequentially or with approximately .
hours and .
gbof memory under an eight thread concurrency.
discussion on false positives more than a half out of of the false positives are triggered by the codethat is not analyzed.
they can be separated into three groups.
the first group is the uninterpreted functions which indicates spelton cannot find the definition of a callee function.
the reasons include the function is a third party libraryfunction whose definition is not provided it is a virtualfunction call on an object with an unknown type and afailed ctu indexing or importing of the invoked externalfunctions.
there are reports clustered to this group.
the second group is the implicit constraints.
these constraints hold among the entire program but fail to be collectedin the current analysis context.
for example an iterator classin ll vm the nullity of its unique pointer field representswhether it is the end iterator or not.
when analyzing the code as we cannot collect this constraint in the current context spelton will assume that an iterator with such a null pointer is not the end iterator.
it will therefore generate a dereference null report at the dereference site of the iterator.
and false reports can be categorized into this group.
the last group is the disabled assertions where the assert macros in the code are replaced with a void expression whenthe code under analysis is compiled with assertions disabled.as the conditions in the assertions are removed during pars ing spelton cannot add the corresponding constraints in the assertions and therefore lead to false positives.
there are 5false reports in this group.
besides unique shared reports considered false ones may still be true bugs or helpful to developers.
in spelton we check the unique shared bugs for every unique path.
therefore we will report the paths that do not share the ownership whenthere are other paths in this function sharing the ownership.since we cannot make sure whether all the involved sharedpointers can be replaced with unique and raw pointers.
forthe sake of conservation we mark them as false positives.
there are false positives of type bad assignment triggered via the feature of user customized deleters.
this feature allows users to determine what is to be done in the d el operation.
therefore it will still be correct when a non heap memory 888t able vi evaluation on open source c projects projectsreports of compared tools reports of spelton time cost sec memory cost kb csa infer cppcheck sprinter dn ba tm cr us max average max average aquila .
.
.
.
aria2 .
.
.
.
celero .
.
.
.
evpp .
.
.
.
osrm .
.
.
.
restbed .
.
.
.
spdlog .
.
.
.
mysql crash .
.
.
.
llvm .
.
.
.
total .
.
block is assigned to a smart pointer with a deleter that does not deallocate the memory.
as this feature is seldom used wedo not model this feature in spelton.
the remaining false reports include reports for we consider the reported site may be written on purpose by thedevelopers and reports that are too complex to be checkedand marked as false positives directly.
although these reports may be difficult to be filtered automatically it is easy for developers to filter or suppress themvia automatic code transformation with the knowledge of theproject .
d. discoveries about smart pointers according to the bug reports on the open source projects we have three discoveries.
first all of the real bad assignment and type mismatch bugs are caused by not using function std make unique andstd make shared to create a new smart pointer.
another three commits found in the history of project osrm and llvm also agree with this conclusion.
therefore it is strongly suggested to use thesetwo makers to allocate memory and create smart pointers.
second developers should pay more attention to shared pointers.
although the unique shared bugs will not lead to crashes or resource depletion such bugs will strongly affectthe efficiency of the program .
besides shared pointers mayalso trigger circular reference bugs.
therefore developers had better have a double check on whether the ownership needsto be shared before using shared pointers.
third smart pointers cannot immunize all kinds of memory errors especially the null pointer dereference bugs.
the c standard smart pointers are designed to prevent danglingpointers with null pointer values.
and null pointer values arealways used as the return values of abnormal circumstances.therefore we believe these are the reasons why the dereference null bugs are reported most.
vi.
t hrea t to validity the main threats to the validity of our results lie in the following three aspects.
error pattern selection.
in this paper we only address the bugs that can be directly triggered by the method callsof three kinds of smart pointers.
however there are anothertwo kinds of smart pointer related memory errors that canbe triggered with raw pointers the memory leak bugs dueto not deallocating a memory block after its ownership hasbeen dropped with the release method of unique pointers and the dangling raw pointer bugs after a smart pointerdeallocates its managed memory block.
although smart pointers add new deallocation sites to the program these two kinds of bugs are still pure raw pointerbugs since smart pointers are designed to avoid being dan gling.
as they have been well studied we prefer checkingthese bugs that cannot be directly triggered by smart pointerswith the corresponding state of the art approaches.
and ourmodel of smart pointers can be integrated into them to perfectthe results.
benchmark selection.
the validity of our benchmark may be subject to the threat that our handmade code snippetsmay not be complete enough to test all the circumstances.therefore the performance of spelton on real world projects cannot be as good as the handmade benchmark.
besides theprojects selected may not cover all language features either there could be false negatives or positives when analyzingother complex projects.
csa analysis engine.
when developing spelton the latest release version of csa was .
.
.
there will be manyimprovements and bug fixes in the latest version at present.some of our solutions and strategies during developing the toolcan be replaced with newer and better optimizations.
and thebugs from old version may also affect outcome accuracy andexactness.
vii.
r ela ted work our work is mainly related to modeling and checking smart pointers and memory related bugs.
in this section we willmainly present the existing researches in these aspects.
analysis on smart pointers.
currently there is only a little research about the c smart pointers on differentkinds of aspects.
babati et al.
researched the performance of smart pointers under different compiler configurations and concluded that using shared pointers is very resource consuming.
and henriques et al.
compared the performance of different memory deallocation methods in c c and java with smart pointers of c and garbage collectorof c and java.
their conclusion is the garbage collector ofc outperforms the one of java and the smart pointers ofc .
donchev et al.
and raj et al.
explored teaching smart pointer usages to newbies and experienced programmers 889respectively.
their researches introduced their experience from their courses.
smartor is a tool that helps developers to replace raw pointer based memory management with smartpointers.
apart from c smart pointers the smart pointersof the boost libraries are also involved in this tool.
and sprinter is a linter like tool that mainly focuses on checking coding style problems of smart pointer usages.
someof the bug types of sprinter are also supported by our tool in this paper.
ownership of memory blocks.
the concept of ownership of memory blocks has been widely used to analyze memoryerrors.
svoboda et al.
introduced the pointer ownership model to represent a similar concept of smart pointers.
heine et al.
utilized the ownership model to check for memory leak and double free problems.
they introduced a uniquepointer like strategy to use raw pointers in c programs bylimiting the ownership of a memory block only managedby one owner raw pointer.
and they developed a tool tocheck the violations of this model.
and aldrich et al.
developed a tool to annotate variables in a java program to helpprogrammers understanding the data flow.
they introduceda static ownership model to annotate the variables whichrequires the type of ownership of a variable cannot be changed.
pointer analysis.
pointer analysis is also an important part of our work and pointer analysis of smart pointershas many similarities with raw pointer analysis.
trabishet al.
introduced a symbolic execution aided pointer analysis method.
the method uses the program state duringsymbolic execution to help a query on a static pointer analysis.and the results of the query are used to improve the precisionof the symbolic execution.
by reusing the information avail able krainz et al.
employed a diff graph based method to quickly analyze points to relations incrementally.
the methoduses the diff graph to represent each function and re computesthe graph for a function if it is changed.
in this way theprevious analysis results of an unchanged function can bereused.
and grech et al.
utilized a dynamic snapshotbased static analysis method to analyze java programs.
theyuse dynamic analysis to make heap snapshots and the staticanalysis uses the information from the snapshots to analyzethe pointers.
a scalability focused algorithm is presented by liet al.
.
they estimate the amount of information of pointsto relations that will be used when analyzing a function andselect a proper sensitivity degree for each function to archivehigh scalability together with enough precision.
and thiessenet al.
presented a method of combining demand driven local reasoning analysis and object sensitivity for analyzingpointers.
the results indicate the method is more efficient forcontext sensitive pointer analysis.
typestate analysis on heap memory.
checking heap memory usages for memory errors is a typical utilization ofthe typestate analysis approach.
melton and smoke are both tools for checking memory leaks.
they model thestate of memory blocks to detect the ones that go out of scope without being deallocated.
y an et al.
checked use after free problems by using spatio temporal context to inferthe potential usages after deallocation.
they summarize theprogram with a k level context sensitive pointer analysis and diagnose use after free bugs by checking the intersection of thepointee set of deallocation with the set of dereferences.
andtsmartgp is a tool for checking memory errors according to pointer analysis.
it uses a flow context field and quasipath sensitive pointer analysis to record the value of pointersand check errors with them.
besides fixing memory errors related to heap memory management will also use a typestate like analysis approachto model the state of heap memory blocks.
memfix tries to fix trivial memory leaks by rescheduling the calls to functionfree.
they model the state transitions of heap memoryblocks and use the state to find a better place to deallocatethe memory for all paths after they have removed all frees in a function.
sa ver attempts to fix heap memory errors according to given bug reports.
they use a value flow graph tomodel the operations on a memory block and fix the given bugby inserting and replacing the memory operations.
finally atypestate like analysis is used to verify the patches generated.
viii.
c onclusion and future work in this paper we proposed an approach to modeling the state of c smart pointers together with the managed heapmemory and we defined a group of operations on themmodifying the states.
to diagnose misuses of smart pointers missp we extracted five error patterns for the operations onsmart pointers and implemented checkers for the patterns.
weevaluated our model and checkers on a handmade benchmarkand nine open source c projects.
the experimental resultsindicate our approach can precisely detect the missps.
in the future this work can be extended in three aspects.
first as the first tool focusing on precisely checking missps we check five error patterns.
more error patterns of missps canbe added with the evolution of the c standard.
second themodel can be applied to other analysis algorithms other thanstatic symbolic execution to make the check more precise andefficient.
and last this paper only focuses on smart pointers ofthe c standard.
other kinds of smart pointer like managerclasses or pointer like classes also need to be checked if theirimplementations cannot be precisely analyzed.
a cknowledgment the authors would like to thank the anonymous reviewers for their suggestions.
this work is supported in part by the keyresearch program of frontier sciences chinese academy ofsciences under grant no.
qyzdj ssw jsc036 and the 973program of china 2014cb340701 .
r eferences j. lee s. hong and h. oh memfix static analysis based repair of memory deallocation errors for c in proceedings of the 26th acm joint meeting on european software engineering conference and symposium on the f oundations of software engineering pp.
.
cppreference.
.
available b. stroustrup and h. sutter c core guidelines web.
last accessed february .
e. geisseler and p .
meier gslatorptr c core guidelines pointer checker and support library refactorings ph.d. dissertation hsr hochschule f ur technik rapperswil .
the chromium projects smart pointer guidelines.
.
available x. ma j. y an y .
li j. y an and j. zhang sprinter a static checker for finding smart pointer errors in c programs in 34th ieee acm international conference on automated software engineering ase .ieee pp.
.
b. babati and n. pataki comprehensive performance analysis of c smart pointers pollack periodica vol.
no.
pp.
.
cppcheck.
.
available clang static analyzer csa .
.
available https clang analyzer.llvm.org infer static analyzer.
.
available r. e. strom and s. y emini typestate a programming language concept for enhancing software reliability ieee transactions on software engineering no.
pp.
.
r. deline and m. f ahndrich typestates for objects in european conference on object oriented programming.
springer pp.
.
z. xu j. zhang and z. xu melton a practical and precise memory leak detection tool for c programs frontiers of computer science vol.
no.
pp.
.
g. fan r. wu q. shi x. xiao j. zhou and c. zhang smoke scalable path sensitive memory leak detection for millions of lines of code in2019 ieee acm 41st international conference on software engineering icse .
ieee pp.
.
raii cppreference.
.
available com w cpp language raii d. svoboda and l. wrage pointer ownership model in 47th hawaii international conference on system sciences.
ieee pp.
.
s. beyer efficient cycle collection in a hybrid garbage collector with reference counting and mark and sweep ph.d. dissertation wien .
restbed pull request .
.
available corvusoft restbed pull mysql bug .
.
available bug.php?id aria2 pull request .
.
available aria2 pull gnu make.
.
available p .
e. black and p .
e. black juliet .
test suite changes from .
.
us department of commerce national institute of standards andtechnology .
r. van tonder and c. l. goues tailoring programs for static analysis via program transformation in proceedings of the acm ieee 42nd international conference on software engineering pp.
.
l. henriques and j. bernardino performance of memory deallocation in c c and java .
i. donchev et al.
experience in teaching c within the undergraduate informatics curriculum inf.
in education vol.
no.
pp.
.
a. g. s. raj v .
naik j. m. patel and r. halverson how to teach modern c to someone who already knows programming?
inproceedings of the 20th australasian computing education conference pp.
.
a. fr ohlich and c. mollekopf smartor dress naked c pointers to smart pointers ph.d. dissertation hsr hochschule f ur technik rapperswil .
boost c libraries.
.
available d. l. heine and m. s. lam a practical flow sensitive and contextsensitive c and c memory leak detector in proceedings of the acm sigplan conference on programming language design andimplementation pp.
.
j. aldrich v .
kostadinov and c. chambers alias annotations for program understanding acm sigplan notices vol.
no.
pp.
.
d. trabish t. kapus n. rinetzky and c. cadar past sensitive pointer analysis for symbolic execution in proceedings of the 28th acm joint meeting on european software engineering conference and symposiumon the f oundations of software engineering pp.
.
j. krainz and m. philippsen diff graphs for a fast incremental pointeranalysis in proceedings of the 12th workshop on implementation compilation optimization of object oriented languages programsand systems pp.
.
n. grech g. fourtounis a. francalanza and y .
smaragdakis shooting from the heap ultra scalable static analysis with heap snapshots inproceedings of the 27th acm sigsoft international symposium onsoftware testing and analysis pp.
.
y .
li t. tan a. m ller and y .
smaragdakis scalability first pointer analysis with self tuning context sensitivity in proceedings of the 26th acm joint meeting on european software engineering conferenceand symposium on the f oundations of software engineering pp.
.
r. thiessen and o. lhot ak context transformations for pointer analysis acm sigplan notices vol.
no.
pp.
.
h. y an y .
sui s. chen and j. xue spatio temporal context reduction a pointer analysis based static approach for detecting use after freevulnerabilities in ieee acm 40th international conference on software engineering icse .
ieee pp.
.
y .
wang g. chen m. zhou m. gu and j. sun tsmartgp a tool for finding memory defects with pointer analysis in 34th ieee acm international conference on automated software engineering ase .ieee pp.
.
s. hong j. lee j. lee and h. oh saver scalable precise and safe memory error repair in proceedings of the acm ieee 42nd international conference on software engineering pp.
.