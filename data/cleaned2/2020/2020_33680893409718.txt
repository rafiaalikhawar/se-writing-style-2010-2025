domain independent interprocedural programanalysis using block abstractionmemoization dirk beyer lmu munich germanykarlheinz friedberger lmu munich germany abstract wheneveranewsoftware verificationtechnique isdeveloped additionaleffortisnecessarytoextendthenewprogramanalysisto an interprocedural one such that it supports recursive procedures.
we would like to reduce that additional effort.
our contribution is an approach to extend an existing analysis in a modular and domain independentwaytoaninterproceduralanalysiswithout large changes we present interprocedural block abstraction memoization bam whichisatechniqueforproceduresummarizationto analyze recursive procedures.
for recursive programs a fix point algorithmterminatestherecursionifeveryprocedureissufficiently unrolled and summarized to cover the abstract state space.
baminterproceduralworksfordata flowanalysisandformodel checking and is independent from the underlying abstract domain.
to witness that our interprocedural analysis is generic and configurable wedefinedandevaluatedtheapproachforthreecompletely different abstract domains predicate abstraction explicit values and intervals.
the interprocedural bam based analysis is implementedintheopen sourceverificationframework cpachecker.the evaluation shows that the overhead for modularity and domainindependence is not prohibitively large and the analysis is still competitive with other state of the art software verification tools.
ccs concepts software and its engineering formal methods formal software verification theory of computation program verification verification by model checking .
keywords softwareverification interproceduralprogramanalysis recursive c program block abstraction procedure summary acm reference format dirk beyer and karlheinz friedberger.
.
domain independent interproceduralprogramanalysisusingblock abstractionmemoization.in proceedingsofthe28thacmjointeuropeansoftwareengineeringconferenceand symposiumonthefoundationsofsoftwareengineering esec fse november 8 13 virtual event usa.
acm new york ny usa 13pages.
funded in part by deutsche forschungsgemeinschaft dfg convey .
a reproduction packageis available onzenodo .
esec fse november 8 13 virtual event usa copyright held by the owner author s .
acm isbn .
introduction software verification has been successfully applied to improve the qualityandreliabilityofcomputerprograms .
in the last decades several algorithms and approaches were developedtoperformsoftwaremodelcheckingforvariouskindsof c programs.
however only a few verifiers for c support full interproceduralanalysis thatis verificationofrecursiveprograms only 13outof22toolsubmissions 17differenttools inthe2020competition on software verification participated successfully in the benchmark category of recursive tasks.
a program analysis is called interprocedural if procedures are analyzed separately and verification results are merged together from the separate results.
the idea is that a program analysis does not depend on long traces through the program but analyzes procedures independently from each other such that the result of a procedure s analysis can be used at all call sites with the same context e.g.
with the same abstract arguments .
many verifiers inline called procedures into the calling procedure and verify long traces througha program without any benefit from a modular approach.
thisnotonlyhindersthereuseofsub resultsoftheanalysis but alsomakesitimpossibletoverifyunboundedrecursiveprograms.
we present bam interprocedural a generalization of summarybased interprocedural analysis.
the abstract framework is an extension of block abstraction memoization bam and is currentlyusedtoverifyreachabilitypropertiesaboutprograms.
example.
weoutlinehowtoprovethecorrectnessoftheexample programin fig.
illustratedin fig.
whichusestwounsignedinteger variablesaandb andnondeterministicallyinitializesthemas inputfortherecursiveprocedure sum whichreturnsthesumofits arguments.
the program is deemed correct if error is not called.
this program can not be verified by a default bounded model checker that iteratively unrolls the recursion because the number ofunrollingsisunknown.however usingaproceduresummary likeret m n wheremandnare the parameters of procedure sumandretis the return value of the procedure call would help withtheverification.thissummaryisavalidabstractionforthe control flowforeverycalloftheprocedure sumandcanbeapplied as a substitution for the initial call in procedure mainas well as for the recursive call in procedure sumitself.
for a fully automated analysis theverificationalgorithmmustcomeupwiththis orsome similar summary and apply it as part of the proof strategy.
thisexampleprogramrequiresanabstractdomainthattracksrelationsbetweenvariables.thus astandardpredicateanalysis such asinsect.
isabletoinfersuch predicates e.g.
viacegar andinterpolation andcansoundlyapplyproceduresummaries for all call sites of a procedure.
in general our approach works on a domain independent level and does not depend on smt based summaries.
the combination of procedure summaries with a fixedpoint algorithm computes an over approximation of the reachable 50this work is licensed under a creative commons attribution international .
license.
esec fse november8 virtualevent usa dirkbeyerandkarlheinzfriedberger 1void main void 2uint a nondet 3uint b nondet 4uint s sum a b 5if s !
a b error 10uint sum uint n uint m 11if n return m else uint tmp sum n m return tmp figure example program with arecursive procedure sum 6error 7a nondet b nondet s sum a b !
tmp sum n m returnm returntmpbsumbmain callsum return from sumcallsum return fromsum figure cfas for the example program in fig.
with procedure blocks bmainandbsum state space of the recursive procedure.
the algorithm first determinesaproceduresummaryforasingleunrollingoftheprocedure i.e.
for all paths through the procedure that are not traversing the recursive call.
using the above mentioned abstract domain the analysisobtainsasummarylike ret m ninthisfirststep.then the algorithm applies the computed procedure summary to the recursive call and explores longer paths through the program and refines the procedure summary until the algorithm cannot explore any new path.
for the given example applying this summary once for the recursive procedure call within the procedure sumdoes not change the summary of the whole procedure sum thus it is sufficient to reach afixed point and theanalysis can terminate.
contribution.
our contribution consists of three parts we present a domain independent approach of bam for a fully interprocedural analysis every procedure is analyzed separatelyandtheresultofaprocedure sanalysis anabstractionof the procedure also known as procedure summary is integrated in the analysis of the calling context.
aprogrammightcontain unboundedrecursion e.g.
therecursion depth is depending on unknown input .
instead of just cuttingoffprogramtracesatapredefineddepth ouranalysisterminatestheunrollingofarecursiveprocedureinasoundwayonceafixedpointisreached anddoesnotomitfeasibleerrorpaths.the fixed point algorithm iteratively increments the unrolling of the recursionuntilnonewabstractstateisreachable.thealgorithm is domain independent because only coverage checks for abstract statesareused whicharealreadyprovidedbyeachabstractdomain.
the overhead is negligible for non recursive programs.
we formally define an additional domain specific operator rebuildin the framework such that recursive procedures can be handledineverydomain.thisoperatorrestoreseliminatedinformation of the calling context after leaving a recursive call.
related work.
as programs with recursive procedures have beenanalyzedandalsoverifiedsincedecades manyideasarealready available and implemented in some tools.
we give a short overview of the tools and the domains they are based on.
inlining based analysis.
a common approach to analyze procedures in bounded model checking is to unroll them up to a certain limit and ignore any deeper recursive calls.
tools like cbmc esbmc andsmack implement this approach which leads toanunsoundanalysisincombinationwithrecursiveprocedure calls because there is no guarantee that the bug is unreachable throughfurtherunrolling.withouttheuserspecifyingabound the modelcheckermightrunintoanendlessunrollingoftherecursion.
constant propagation like in cbmc or additional checks can avoid toofarunrollingofrecursiveprocedures.alsounboundedframeworkslike cpachecker haveseveralanalysesbasedondifferent domains that inline procedure calls.
our approach is built on top of them and reuses existing components such that the amount of changes to a single analysis is minimal.
interpolation based summaries.
someapproachestoverifyrecursive programs start with a the analysis of single procedures and compute procedure summaries when applying nested functioncalls.theboundedmodelchecker funfrog generates interpolation based proceduresummariestoavoidtherepeated analysisofprocedures.
whale isanextensionof impact and analyzes recursive procedures using two types of formulas in its intra proceduralanalysis namelystate andtransition interpolants togetsummaries.thoseapproachesseparatelyanalyzeeachprocedure until a fixed point is reached and the procedures or the representing formulas are sufficiently refined.
uautomizer uses nested interpolants to compute formulas for procedures depending on the caller s context.
those approaches are bound to an smt based domain and the algorithms do not support combinations with other domains.
further domain specific interprocedural analyses.
bebop computesproceduresummariesforbooleanprograms.theapplication ofbebophowever islimited to boolean programs and abstract statesaredescribedwithbinarydecisiondiagrams.
abductor is aninterproceduralprogramverifierthatappliesthedomainofseparationlogictoprovememory relatedsafetyproperties.additionally arecursiveprogramcanbetransformedintoanon recursiveone such that any verification tool without direct support for recursioncanbeusedindirectlytoanalyzetherecursiveprogram.for example cparec is a light weight approach using an external black box verifier and a fixed point algorithm that increments the unrolling depth to compute procedure summaries until coverage is reached.
this approach is limited to predicate based verifiers.
51domain independentinterproceduralprogram analysis usingblock abstractionmemoization esec fse november8 virtualevent usa interprocedural data flow analysis.
the above examples are basedonsymbolicanalysis i.e.
dependingonbdd sat orsmtbaseddomains whileourproposedapproachworksforclassicdataflowdomainsaswell.sincemanyyears programswereanalyzed in interprocedural manner using several lattice based domains and with procedure summaries .
the classic approach to interproceduraldata flowanalysis isrestrictedtofiniteheight lattices of domain elements and an operator yielding the join of two domain elements.
bam interprocedural works for arbitrary unlimited abstract domainsanddifferentoperatorsforcombiningelements depending on the represented data not only join or coverage checks for elements domain specific comparison .
background we describe the program representation as a control flow automaton and domain independent reachability analysis based on the concept of configurable program analysis.
afterwards their application as components in an interprocedural analysis is shown.
.
programs aprogramis represented by a control flow automata cfa a l l0 g that consists of a set lof program locations an initial programlocation l0 l andasetg l ops lofcontrol flow edges.anedgemodelsthecontrol flowoperation from ops between program locations for example assignments or assumptions.
figure2representstheexampleprogramascfas.ourpresentation usesasimpleimperativeprogramminglanguage whichallowsonly assignments assumeoperations procedurecallsandreturns and all variables are integers.
the implementation of our tool provides basicsupportforheap relateddata structuresincludingpointers and arrays but thisarticle avoidsthem forsimplicity.in general cpachecker supports the verification of c programs including pointers and arrays.
however the analysis of recursive procedures forsuchprogramsisstillunderdevelopmentandatopicofresearch.
.
blocksin aprogram blocksare formally defined as parts of a program a block b l g of a cfa a l l0 g consists of a set l lof program locations and a set g l1 op l2 g l1 l2 l of control flow edges.
we assume that two blocks band b are either disjoint b.l b .l or one block is completely nested in the other block b.l b .l .
each block has inputandoutput locations which are defined as in b l l l l l g l nelementl l l l g and out b l l l l l g l nelementl l l l g respectively.
in general the block size can be freely chosen in our approach.
for an interprocedural analysis we use procedures as blocks suchthatablockabstractionrepresentsaproceduresummary.
infig.
the blocks bmainandbsumrepresent the two proceduresoftheprogram.theinputandoutputlocationsaremarked in color for each block.
.
cpa andcpaalgorithm thereachabilityanalysisisbasedontheconceptofconfigurable programanalysis cpa whichspecifiestheabstractdomain for a program analysis and additional operations.
a cpad d leadsto merge stop consists of an abstract domaind atransferrelation leadsto andtheoperators mergeandstop.
the abstract domain d c e consists of a set cof concrete states a semi lattice e e over a set eof abstract domain elements i.e.
abstractstates andapartialorder thejoin of two elements and the join of all elements are unique and a concretization function e 2cthat maps each abstract domain element to the represented set of concrete states.
the transfer relation leadsto e ecomputes abstract successor states a transfer relation leadstomatchesthetransferalonganedge gofthecfa.the mergeoperator merge e e especifiesifandhowtomerge two abstract states when control flow meets.
the stop operator stop e 2e bdetermineswhetheranabstractstateiscovered by a givensetof abstract states.
theoperators mergeandstopcan be chosen appropriately to influence the abstraction level of the analysis.commonchoicesinclude mergesep e e e whichdoes not merge abstract states and stopsep e r e r e e which determines coverage by checking whether the given abstract state is less than or equal to any other reachable abstract state according to the semi lattice .
given a cpa we can apply a reachability algorithm denoted as cpa algorithm in that explores the abstract state space ofa programand computesall reachable abstractstates.
the stop operatordeterminesthefixed pointcriteria i.e.
whetherastate hasalready beendiscoveredbefore.
for thefollowing description weconsiderareachabilityanalysis cpa d reached waitlist using acpadandtwosets reachedandwaitlistofabstractstatesasinput andreturningtwosets reached andwaitlist ofabstractstates.the idea is that starting with the given sets of already reached abstract states andafrontier waitlist thereachability algorithmcomputes more reachable successors and a new frontier waitlist.
thecpaalgorithmcanbeusedascomponentinacegar based fixed pointloop torefinethegranularityofthecurrentanalysis.
for simplicity we ignore the precision in this article.
inthefollowing sect.
wedescribeourinterproceduralextension of block abstraction memoization and then in sect.
4provideanapplicationoftheconcepttothreeseparatedomains the callstack cpafortrackingacallstackoftheprogram thevaluecpafortrackingvariableassignmentsexplicitly andthepredicatecpa for handling variable assignments with predicates.
bamforinterproceduralanalysis block abstraction memoization bam isa modular andscalable approach for model checking abstract state spaces by leveraging the idea of divide and conquer .
bam divides a large program into smaller parts named blocks and analyzes them separately.
the result of a block s analysis is denoted as a block abstraction .
blockabstractionsarestoredinacache.wheneveralargerblock depends on a nested block a block abstraction of the nested block is created during the larger block s analysis.
block abstractions are independentofaconcretedomainandworkonanabstractlevel.
52esec fse november8 virtualevent usa dirkbeyerandkarlheinzfriedberger there can be several block abstractions for the same block e.g.
depending on different input values of the block.
in the following we use procedures as blocks.
more precisely aprocedureblock bfconsistsoftheprocedure fitselfandallprocedures that are transitively called from f such that the whole control flow of nested blocks including call and return edges is included in the block bf seefig.
.
bamensuresefficiencybyusingacache cache blocks e 2e 2e forblockabstractions whichmapstheinitialabstractstate forablocktotheblockabstraction.theblockabstractionisdefined as the set of reached abstract states and the set of frontier abstract states which both are computed during the block s analysis.
bamisdefinedrecursively independentofanyrecursioninthe analyzed program and repeatedly nestedly applies the reachabilityanalysis.ourimplementationofbamusesa stackofpairs p blocks ethat consists of all currently open analyses referenced by their block of the cfa to be analyzed and an initial abstract state starting point of the block abstraction .
this section defines bam interprocedural.
we show that procedure blocks correspond to procedure summaries describe the problems of analyzing recursive procedures the necessity of the fixed point algorithm and a new operator rebuild.
.
operatorsofbam bamusestwocomplementingoperators reduce blocks e e andexpand blocks e e e and an additional operator rebuild e e e e to drop or restore context based information for each analyzed block.
a cpa with these three additional operatorsiscalled cpawithbamoperators .onanabstractlevel the reduce operator performs an abstraction of the given abstract state andtheexpandoperatorconcretizesanabstractstateforagiven context.theseoperatorsaimtowards aninterproceduralanalysis where each block can be analyzed without knowing its concrete context.howmuchofthiscontext independencecanbeachieved depends on the concrete domain see sect.
4for more details .
the implicit benefit of the first two operators is an improvement of the cache hit rate.
the operator reducedrops unimportant information from an abstract state when entering a block.
the resulting abstractstateismoreabstractandisusedascachekeyandasinitial abstract statefor the block s analysis.
the importanceof some information depends on the wrapped analysis and the available block.
for example variables predicates or levels of the call stack thatare not accessed inside the enteredblock but onlydepend on the surrounding context might be good candidates to be removed fromtheabstractstate.theoperator expandrestoresremovedinformationforabstractstateswhenapplyingtheblockabstractionin thesurrounding context.
the operator rebuildavoidscollisions of programidentifiers likevariables whenreturningfroma possibly recursive procedurescopeintoitscallingcontext.thisoperator doesnotcomputeanabstraction butperformssimpleoperations dependingonthegivenabstractdomainsuchasrenamingvariables substituting predicates or updating indices.
withtheseoperators wenowformallydefinethecpaforbam.algorithm1 fixedpoint bmain l0 e0 input blockbmainwithinitial programlocation l0 abstract state e0 output setofreachablestates whichallrepresentoutput states ofthe block bmain global variables booleanflag fixedpointreached variables setblockresult ofabstract states repeat fixedpointreached true blockresult applyblockabstraction bmain e0 untilfixedpointreached return blockresult .
bamas cpa for usage with the cpa concept see sect.
.
bam itself is formalized as a cpa bam dbam leadstobam mergebam stopbam .
as bam works on an abstract domain independent level it requires a separate abstract domain dependent analysis like the valueanalysis orpredicateanalysis totrackvariables values and assignments.
this separate component analysis is also defined via the cpa concept see sect.
.
for the following definition we denote it as a general wrapped cpa with bam operators w dw leadstow mergew stopw reducew expandw rebuildw .
the domain dbamis the wrapped domain dw i.e.
bam simply uses the abstract states of the underlying domain.
the transfer relation includes the transfer e leadstobame for twoabstract states eande andablock bif e fixedpoint bmain l e ifl l0andstack applyblockabstraction b e ifl in b e e leadstowe ifl nelementout b wherelistheprogramlocationfor eandstackistheinternal stack ofnestedblocksduringthe analysis.
the transfer relation applies one of three possible steps thefixed pointalgorithm alg.1isexecutedifthecurrent programlocationistheinitialprogramlocation l0andthe stackisempty.
ataninputlocationofablock b i.e.
if a new nested block would be entered from a surrounding context we apply the block abstraction returned from the operation applyblockabstraction cf.alg.
for the nested block.
for outputlocations of blocks there is nosucceeding abstract state in the sub analysis .
for other program locations the wrappedtransfer relation leadstowisapplied.
the merge operator mergebam mergewdelegates to the wrappedanalysis i.e.
bam merges whenever the underlyingdomainmerges abstract states.
the termination check stopbam stopwdelegates to the wrappedanalysis i.e.
thecoveragerelationbetweenabstract states depends onthe underlying domain.
the transfer relation leadstobamuses the fixed point algorithm and the computation of block abstractions as explained in the next subsections.
53domain independentinterproceduralprogram analysis usingblock abstractionmemoization esec fse november8 virtualevent usa algorithm2 applyblockabstraction b ei input abstract state eiat ablockinput location ofablock b output abstract statesforthe outputlocationsofthe analyzed block b global variables booleanflag fixedpointreached setcachemappingablockandan abstract state to a blockabstraction sequence stackconsisting ofpairsofaprocedureblock andan abstract state variables setsreachedandwaitlistofabstract states forthe analysis ofthe currentblock ei reducew b ei if b ec stack ei ecthen ifcachecontains b ec then reached cache b ec else reached fixedpointreached false else ifcachecontains b ei then reached waitlist cache b ei else reached ei waitlistr ei stack.push b ei reached waitlist cpa w reached waitlist stack.pop ifcachecontains b ei then reachedold cache b ei fore reacheddo ifloc e out b e reachedold e e then fixedpointreached false cache b ei reached waitlist ecall getpredecessor ei tmp expandw b ei eo eo reached loc eo out b return rebuildw ecall ei eo eo tmp .
fixed pointalgorithmforunbounded recursion an analysis of recursive procedures must handle a possibly unbounded unrolling of the call stack if the information of an abstract state is insufficient to avoid deeper exploration and can not cut off the state space.
in our approach the fixed point algorithm fixedpoint alg.
repeatedly analyzes the program using applyblockabstraction alg.
fromtheinitialprogramlocationonwards.ititerativelyincrementsthenumberofunrollingsandterminates only if coverage was reached for all analyzed procedure calls.
in each iteration of the fixed point algorithm we generate an overapproximation of some more paths through the recursive procedure becauseofthelimitedunrollingoftherecursion and determine a summary for the currently analyzed procedure block.
the termination is decided by a coverage check for the abstract states of the analyzed block summary.
the first iteration of the fixed point algorithm assumes no valid path through the recursive call.
we only explore the non recursive parts of the program s control flow and skip the recursive call of the procedure.
depending on the abstract domain the initial summary for the recursive procedure is an empty set of abstract states alg.
line6 .theblockabstractionofaprocedureisstored inthecacheafterreturningfromtheprocedurecall alg.
line21 .
p b f a q p p a bf q p a b r p b f a q figure hoare s rule for recursion for a given procedure definition f p bf returnr b f a bf b f a figure hoare srule forrecursion with abstract states in further iterations we increment the limit of unrollings of the recursiveprocedureandrefinetheblockabstraction analyzethe programagain startingfromtheinitialprogramlocation andusing several intermediate results from the cache until the procedure summary becomes stable.
.
soundness ofbamforrecursion the fixed point criteria are based on hoare s rule for recursion if the body of a procedure fsatisfies the pre and postconditions pandq includingparameterpassingandreturnvalues under the condition that all recursive calls to the procedure f satisfypandq then the whole procedure fsatisfiespandq.
translated into our model we use concretizations of abstract states as pre and post conditions of statements the procedure and its body corresponds to the procedure s block fig.
4shows the resulting rule.
the renaming or an equivalent operation of equal identifiers from the recursive call of f which appear in the calling andcalledprocedure f isshiftedintoadifferentpartoftheanalysis seesect.
.5onoperator rebuild andishandledinasoundway.
to determine the fixed point criteria for termination alg.
checks the following two properties during the analysis.
firstly wetrytostoptheunrollingofanunboundedrecursive procedure by an over approximating analysis.
thus before analyzing a new recursive procedure call we check whether the abstract state ataprocedure entryis alreadycovered by anyabstractstate fromthecurrent stack alg.
line2 .ifsuchacoveringabstract stateexists weskiptherecursivecallanduseaproceduresummary insteadoffurtherexploringtherecursivecall alg.
line3to7 .
the procedure summary consists of either previously computed abstractsuccessorstatesfromthebamcacheor incaseofacache miss no successor states at all.
secondly because a procedure summary represents only a bounded execution of the called procedure this approach alone represents only a subset of possible traces in the procedure and might be unsound in cases that require deeper unrolling.
to determineiftheinsertedproceduresummariesaresufficientforhoare s rule offig.
wecheck for coverage oftheexit state oftheprocedureexecutedwiththeinsertedproceduresummary againstthe previouslycomputedabstractstates oftheproceduresummary .
thischeckis performedinlines18to20of alg.
.ifthecoverage relation is satisfied for all procedures in the program then the fixed point algorithm terminates because fixedpointreached was neversetto falseduringtheiteration.inthiscasewehavefounda soundover approximationoftherecursiveprocedure.otherwise the fixed point algorithm continues.
54esec fse november8 virtualevent usa dirkbeyerandkarlheinzfriedberger .
block abstractioncomputation with operators theoperation applyblockabstraction cf.alg.
startswiththereduction reducew b ei ofinitial abstractstate eiand determines the block abstraction for a block b. the block abstractionis either taken from the cache or computed via a separate application of the reachability algorithm i.e.
cpa algorithm .
to integrate the block abstractionintoasurroundingcontext theoperators expandwand rebuildwareappliedtoeachabstractstateattheblock soutputlocation lines23and24 .theoperators reduceandexpandabstractor concretizethegivenabstractstateandaimtoincreasethecache hit rate of bam.
for an interprocedural approach they remove and restore most of the context based information of a procedure block.
whilethefixed pointalgorithmhandlesover approximations andrefinementsofblockabstractions aninterestingdetailofthe implementation remains open how can we identify and work with symbols i.e.
variable identifiers across procedure scopes?
identicalidentifiersforprogramvariablesofthesameprocedure scopeareproblematicfortheanalysisofrecursiveprocedures.due tothemodularityoftheframework cpachecker onlyaseparatecallstackanalysisknowsaboutprocedurescopesandallotheranalyses assume unique identifiers across all operations.
bam also tracks informationaboutproceduresinits stack butitdoesnotusethis information for detailed analysis of variables and identifiers.
each recursive procedure entry starts a new procedure scope where the identifiers override existing valid identifiers from previous callstacklevels.enteringaprocedureandoverridingexistingidentifiers fromthecallingscopeisnoproblem becauseonlythemostlocal version ofan identifier is available and visible in the procedure scope.
leaving the procedure afterwards is more complex because identifiersareoverriddenduringtheprocedure straversalandhave to be restored to match the calling context.
asolutionlikeasimplerenamingofidentifiersisnotpossible because each domain has its own way of representing variables.
additionally eachdomainmusthaveastrategyforhandlingscoped variables that allows a consistent use of the cache in bam.
wesolvethisproblembyusinganewoperator rebuild e e e e and we show how to implement it for different domains.
the operator rebuildis applied after analyzing the procedure exit location alg.
line24 i.e.
afterleavingtheblockofa mayberecursive procedureandaftertheapplicationoftheoperator expand.
the operator rebuildmaps three abstract states information about the calling context from the procedure call state ecall information about the arguments and parameters of the called procedure from theprocedureentrystate ei andinformationaboutthereturnvalue and the block abstraction from the procedure exit state eo to a new abstract state that is a successor of the procedure call and a validstartingpointforthefurtheranalysis.theoperator rebuild is defined depending on the underlying analysis.
application of baminterproceduralto abstractdomains in this section we describe some component program analyses that can be used by bam interprocedural to compute contextindependentblockabstractions.usingtheframework cpachecker program analyses are composed of several component cpas.
componentcpasaredefinedandimplementedfortrackingtheprogram counter the predecessor successor relationship of the reachability graph or for combining other cpas in a composite analysis.
thus wedonotneedtospecifytheseaspectswhendefiningacomponent analysis but directly specify the component analyses.
in the following weexplainananalysisfortrackingthecallstackandtwo analyses for analyzing variables and assignments namely value analysisandpredicate analysis .
callstack cpa.
thecpawithbamoperators forcall stackanalysis c dc leadstoc mergec stopc reducec expandc rebuildc explicitly tracks the call stack s of the program where f1 tofndenote procedure scopes for an abstract state s. the domain dc c ec is based on the flat semilatticeec s for the setsof possible call stacks.
theexpression s s isfulfilledif s s ors c. for allsins we have c c callstackof c s .
thetransferrelation leadstochasthetransfer s leadstocs forcfa edge andabstract states s ands if s if isaprocedure callto fn if isaprocedure return from fn s otherwise the merge operator mergec mergesepdoes not combine abstract states.
the termination check stopc stopsepreturns whether the same abstract state wasalready reachedbefore.
the reduce operator reducecabstracts from a concrete call stack and keeps only the context relevant suffix.
therefore it determines the maximal range of procedure scopes of the currentblock i.e.
procedurescopesthatcanbepoppedfrom the current call stack during an analysis of thecurrentblock.lettheprocedurescope fibethelowest procedure scope on the stack that is reachable during the block s analysis.
then the operator keeps only the reachable most local procedure scopes from the abstract state reducec b .
the expand operator expandcrestores the removed part of the callstack expandc b .
thecall stackanalysis doesnottrackvariables buttheprocedurescopesthemselves.thustherebuildoperatorisdefined as rebuildc ecall ei eo eo.
value cpa.
thecpa with bam operators forvalue analysis e de leadstoe mergee stope reducee expande rebuilde explicitly tracks the assignments of variables.
the cpa is used as described in previous work and extended by bam operators.
the domain de c ee is based on the semi lattice ec v e for the set v x z of partial functions that model abstract variable assignments for a set x of variables and the set zof integer values.
we use v x to denote the value of a variable x xfor an abstract variable assignment v v and we use dom v to denote the set of variables for which vassigns a value that is dom v x x v .
the partial order e v vis definedas v v ifdom v dom v andv x v x is 55domain independentinterproceduralprogram analysis usingblock abstractionmemoization esec fse november8 virtualevent usa satisfied for all x dom v .
the top element e v least upper bound denotes the abstract variable assignment with nospecificvalueforanyvariable e .thejoinoperator e e e eis based on the partial order and returns the least upper bound of its operands.
the concretization function v 2creturnsthemeaningforanabstract variable assignment.
thetransferrelation leadstoehasthetransfer v leadstoev foracfa edge op and two abstract variable assignments v andv ifoneofthefollowingconditionsissatisfied givena predicatepandanabstractvariableassignment v wedefine p v p logicalandtext.
x dom v x v x a op assume p and predicate p v is satisfiable and v is defined as follows x c v ifcis the only satisfying assignment for variable xofthe predicate p v or b op w exp and x c v if either x nequalwand x c v or x wandcistheonlysatisfyingassignment for variable x ofthe predicate x exp v .
the mergeoperator mergee mergesepdoes not combine abstract states.
theterminationcheck stope stopsepreturnswhethera coveringabstract state wasalready reachedbefore.
the reduce operator reduceeonly keeps abstract assignmentsofvariablesthatareaccessedintheblock scontext reducee b ei x c ei xusedinb .
theexpandoperator expanderestorestheassignmentsthat were removed by reduceefrom the initial abstract state expande ei b eo x c ei xnot usedin b eo.
fortherebuildoperator rebuilde wedefine globalvariables asvariablesdeclaredintheglobalscopeandtherestas localvariables i.e.
variables declared in a local procedure scope.afterleaving a recursive procedurecall theoperatorrebuildeconsiders local variables from the calling scope andglobalvariablesandthereturnvariable1fromtheexited procedure scope rebuilde ecall ei eo x c ecall isglobal x isreturn x x c eo isglobal x isreturn x .
becauseglobalvariablescanbeassignedduringtheprocedure sexecution theyarenotresettotheirassignedvalue frombeforetheprocedure sexecution theirvaluesaretaken from the abstract state eoat the procedure sexit location.
note that with these definitions of reduceeandexpande the valueanalysis ofaprocedureblockisnotcompletelydetachedfrom the calling context because a block abstraction for this domain depends on the input values of variables accessed in the block.
for procedure blocks a block abstraction for a function call can be takenfromthebamcachewheneverthefunctionargumentsand global variables have identical values.
predicate cpa.
thecpawithbamoperators forpredicateanalysisp dp leadstop mergep stopp reducep expandp rebuildp uses predicates to track variablesand their values .
forthis analysisasetpofpredicatesisused whichcanbeincrementallycomputed in a cegar loop that is applied on top of the cpa 1our implementation introduces an additional variable to capture the return value such that weareable to referenceit hereas well.algorithm.inthisdescription wedonotgointodetailonhowto determine useful predicates but assume that the predicates are already available e.g.
by applying an existing refinement strategy .
the refinement procedure of the predicate analysis computes interpolants that match the structure of the procedure blocks and allow an interprocedural analysis.
foreachblock b wepartitiontheset pofpredicatesintotwo disjoint sets pb p p prelevantfor b andp b p pb.
a predicate p pisrelevant for bif it contain variables that are accessedintheblock.thepartition p bcontainstherestof p. the domain dp c ep is based on the set cof concrete states the lattice ep e p and a concretization function e c.thelatticeconsistsofabstractstates e ethat are tuples l p l l p .
theabstraction formula is a boolean combination of predicates from pand has been computed at the program locationl .
thepath formula represents the disjunction of all paths from l to the abstract state e. the partial order e eis defined for any two abstract states e1 1 l 1 1 ande2 2 l 2 2 as e1 e2if e2 p l 1 l 2 1 1 2 2 .
the top element is p true l true .
the join operator e e eisbasedonthepartialorderandreturnstheleast upper bound ofits operands.
the transfer relation leadstophas the transfer e leadstope for an edge op l andtwoabstractstates e l and e l if l braceleftbigg true l spop ifblk e l spop otherwise wherespop denotes the strongest post condition of a given path formula for an operation op.
the choice of computingabooleanpredicateabstractiondependsonthe configurable operator blk.
for our work it returns trueat leastforprocedurecalls procedureentries andprocedure exits.thebooleanpredicateabstraction computesthe strongestboolean combination of predicates from p. the merge operator mergep e e ecombines the two abstract states e1 1 l 1 1 ande2 2 l 2 2 accordingtotheirlastabstractioncomputation merge e1 e2 braceleftbigg 2 l 2 1 2 if 1 2 l 1 l 2 e2 otherwise theterminationcheck stopp stopsepreturnswhethera coveringabstract state wasalready reachedbefore.
for an abstract state ei i l i true at a block entry the operator reducepcomputes the set p b p1 ... pi of predicatesthatareirrelevantfortheblockabstractionand removes themfrom the abstractionformula reducep b ei p1 ... pi i l i true .
theoperator expandprevertstheoperation reducep itcomputestheset pb pi ... pn ofpredicates andrestores thefullset ofpredicates p p b pbfor anoutput state eo o l o true as follows the abstraction formula o 2we represent the abstraction formula in a way that makes it easy to remove elements from pin an atomic way from an abstraction formula.
we represent as a binarydecisiondiagram bdd whosebooleanvariablesrepresentpredicatesfrom p. 56esec fse november8 virtualevent usa dirkbeyerandkarlheinzfriedberger isextendedbytheremainingpartoftheinitialabstraction formula i expandp ei b eo pi ... pn i o l o true .
the operator rebuildpis based on the procedure call state ecall call l call true the not reduced procedureentry state ei i l i true and the expanded procedureexitstateeo o l o true .thepathformula callrepresentsthecfaedgethatistheprocedureentryedgebetween the program locations of the abstract states ecallandeiand representstheencodingofallassignmentsoftheactualarguments to the formal parameter variables.
the operator rebuildpcomputesthepredicateabstractionfortheconjunctionoftheabstractionsbeforeandaftertheprocedurecall andthe parameterassignment rebuildp b ecall ei eo call call o .
interval cpa.
thecpa withbam operators forintervalanalysis i di leadstoi mergei stopi reducei expandi rebuildi tracks variables and the range interval of their possible assigned values.
theinterval analysis is similartothe value analysis whichcanbe seen as a special case using intervals containing only one value.
thecoveragerelationbetweenintervalsisbasedontheinclusion of intervals instead of equality of values .
we omit the detailed definition here to keep the reader focused on our approach.
.
soundness ofreduce andexpandoperator forthegivendomains foreachofthedescribeddomains thesoundnesscriterionofthe whole interprocedural analysis is based on the soundness of the cpaalgorithmitself whichweassumeasbasis aswellasonthe propertiesofthespecificoperators reduceandexpand.forasound analysis the abstract states that would have been reached withoutapplyingablockabstraction i.e.
onlyapplyingthewrapped cpaw needtobeasubsetofthestatesreachedwithanapplication of the corresponding block abstraction i.e.
using block abstractionscanonlybelessprecisethanawrappedanalysis butnever cut off a reachable part of the abstract state space.
the transfer relation leadstobamfor an abstract state e esatisfies the relation e e e leadstowe e e e leadstobame .
based on the definition of leadstobam sect.
.
the interesting case appears when applying a block abstraction.
thus the concrete implementationoftheoperators reduceandexpandmustsatisfy the following condition for all blocks b e e e leadstowe expand e b eo e reduce b e leadstoweo .
for the call stack analysis each abstract call stack state after an application of a block abstraction exactly matches the call stack statewithoutsuchablockabstraction.toprovethis justextend each call stack during the block analysis with the removed part fromthereduceoperation.forthevalueanalysis and basedonaprogramminglanguagewithoutpointerhandling the same proof can be applied removing assignments from abstract states and restoring them later results in an abstract state that matches the state when not applying a block abstraction computation.
a detailedsoundness proof for the predicate domain is given in the literature .
removing irrelevant predicates p band conjunctingthosepredicateswhenapplyingtheblockabstractiondoesonly make the analysis more imprecise but does not reduce the reachable abstract state space.
.
embeddingbaminterproceduralincegar the framework cpachecker defines bam as a cpa and allows to combinethecpaalgorithmwithotheralgorithms likecegar whichallowstorefinethegranularityoftheabstractanalysisbased oninformationextractedfrominfeasibleprogrampaths.additional operators for the refinement step in cegar are also defined in a domain independent manner and available in the framework.
in our case the cegar algorithm can wrap the cpa algorithm and the analysis of bam can benefit from this.
whenever bam findsapropertyviolation thereachabilityanalysisandthefixedpoint algorithm terminates and the surrounding cegar algorithm checks the error path for feasibility.
if necessary cegar refines theprecision andbamwiththefixed pointalgorithmisre started with the updated precision.
in case of the predicate analysis the refinement procedure computes tree interpolants according to procedure scopes i.e.
foreachentered andexited procedurescopealonganinfeasible error path a new subtree for the tree interpolation problem is constructed.forotheranalyses like valueanalysis therefinementof recursive procedures does not need special handling.
in this case a refinementstrategyforsequentialerrorpaths issufficient.
.
detailed description oftheexample inthefollowing weprovidedeeperinsightsforthepreviouslygiven example program see sect.
infig.
to show the control flow ofbamwiththefixed pointalgorithmwhenusingthe predicate analysis.
we combine the previously defined callstack cpa cand the predicate cpa p i.e.
the transfer relation coverage check reduce expand and rebuild operators are applied in both domains.
figure 5shows the abstract states that are reached in the first two iterations of the fixed point algorithm which terminates after the second iteration.
the labeling of each abstract state consists of the program location circled number in first line the call stack second line and the abstraction formula of the predicate analysis third line .
to keep the figure readable we dismiss the call stackandabstractionformula wheneverthereisnochangein the abstract state.
outside the upper left corner of each node we annotateei where index irefers to the exploration strategy and control flow of the analysis.
theoperators reduce expand andrebuildshowtheireffectat theprogramlocations 11and16 whicharetheinputandoutput locationsoftheprocedureblock bsum.forexample theoperator reducecofthecall stackanalysis removesofallprocedurescopes exceptthemostlocalonefromthecallstack.theoperator expandc restoresthewholecallstackwhentheanalysisleavestheblock.the effectofthe rebuildpatprogramlocation 16willbedescribedbelow.
initialization.
we assumethat the initialcache and the stack of bam are empty and the following set of predicates is defined as precision p ret mp np ret a b m mp n np .
thepredicateanalysis uses the symbols mp np andrettoencode parameterassignmentsatfunctionentryandthereturnvalue.such predicates can be generated via an interpolation procedure from previouslyfoundinfeasibleerrorpathsinthecontextofcegar.
57domain independentinterproceduralprogram analysis usingblock abstractionmemoization esec fse november8 virtualevent usa bmain bsum bsum2 true true11 true true11 truecachemiss16 ret mp np ret a b truereduce reduce expand rebuild apply block abstractione1 e2 e3 e4e5 e6 e7 e8 e9 e10 e11 e12 e13coverage a afterfirst iteration cache missleads to seconditerationbmain bsum bsum2 true true11 true true11 true ret mp np16 ret m ncachehit for statee516 ret mp np ret a b ret mp np5 truereduce reduce expand rebuildexpand rebuild apply block abstractionapply block abstractione21 e22 e23 e24e25 e26 e27 e28 e29 e30 e8 e32 e33 e34e35 e36 e37coverage coverage b afterseconditeration fixed point isreached figure graph ofreached abstract statesafter thefirsttwofixed point iterations forsimpleprograms likethisexample theymatchtheexpected proceduresummary.ingeneral theanalysismightneedseveraliterationsofcegartoobtainasufficientprecision.inthisexample we concentrate on the rebuild operator.
all predicates are relevant for theblockbsum i.e.
pb p i.e.
thereduceandexpandoperators forpredicate analysis will keep the abstraction formula unchanged.
first iteration.
the result of the first iteration of the fixed point loopisshownin fig.5a.theanalysisstartswiththeinitialabstract statee1at program location entering the main block bmain and pushing e1 aseiinalg.
onto the bam stack.
the recursive procedureblock bsumisanalyzedforthefirsttimeattheprocedure callfromprogramlocation 4toprogram location where bam starts a new sub analysis with state e4 aseiinalg.
for the blockbsum.thereductionremovesthesuffix mainofthecallstack and keeps the abstraction formula true.
the abstract state e5 asei inalg.
is pushed onto the bam stack.
when the procedure blockbsumisentered thesecondtime procedurecallat program location14forstatee9 thereducedabstractstate e10iscompared with elements in the bam stack.
the coverage relation alg.
line2 issatisfied.bamhasnocomputedproceduresummaryin the cache and returns an empty set of reachable abstract states line of alg.
.
the flag fixedpointreached is set to falsein line of alg.
.
the analysis continues with the exploration of the non recursive branch of the procedure.
when leaving block bsum theblock ssummaryisinsertedintothecache i.e.
theblock abstraction from the abstract state e5towards the abstract state e8 aseoinalg.
is stored for later usage in the bam cache.
for the predicate analysis the summary of the block is the abstraction formularet mp np which describes the equality of the sum of the two formal function parameters with the return value.therebuildoperator rebuild b e3 e4 e8 restoresinformation from the calling context.
using the abstraction formula 3 true the parameter assignment from the procedure call call a np b mp and the block summary 8 ret mp np the rebuild operator rebuildpcomputes 3 call 8 ret a b .thatis basedonthegivenpredicatesfor e11 e11 ret a b theprocedureissummarizedby ret a b which describestheequalityofthesumofthetwoactualfunctionarguments with the return value.
we do not describe internals of predicateabstraction here but referto the literature .noproperty violation is found along the path until state e13 i.e.
the branching towardsprogramlocation 6isnotsatisfiable andthefixed point computation continues.
second iteration.
the initial steps of the second iteration are similar to the first iteration.
after a few steps the stack consists of the abstractstates e21ande25.a different controlflowappears whentheanalysisreachestherecursiveprocedurecallagainatstate e30 with a coverage relation for the abstract state e25because it is partofthebamstack.nowwegetacachehitforthepreviously computedblockabstractionbetweenstate e5andstatee8andapply the procedure summary to skip the recursive procedure call line ofalg.
.usingtheabstractionformula 27 true theparameter assignment from the procedure call call n np m mp andtheblocksummary 8 ret mp np therebuildoperator rebuildpcomputes 27 call 8 ret m n .
when leaving the procedure block our approach alg.
line19 checks for new not yet covered abstract states.
in this example state e34isalready coveredby state e28 thus the fixed point algorithm terminatesafterthisiteration.asthepropertyviolationatprogram location6is not reachable the program is verified.
58esec fse november8 virtualevent usa dirkbeyerandkarlheinzfriedberger experimentalevaluation weevaluatebaminterproceduralforseveraldomainsandshow thatitiscompetitivewithexistingapproaches.wedividetheevaluationaccordingtothreeclaims.forbothclaims weuseabenchmark set of non recursive and recursive programs and provide the effectivity numberofsolvedproblems andperformance runtime of our implementation using several analyses of cpachecker and other verification tools.
claimi domain independenceandmodularity.
weclaimthat ourinterproceduralapproachisdomain independentandcanbe implemented in a modular way as described in sect.
such that the development and integration overhead for an existing analysis in the framework cpachecker is quite small.
to evaluate the claim weapplytheapproachtoseveralabstractdomains showthat theanalysisworks andcomparedifferentanalysesof cpachecker against each other.
claimii effectivenessandefficiency part1 .
weclaimthatour approach despitethemodulardesign doesnotcauselargeperformanceoverheadsinananalysis.toevaluatetheclaim wecompare benchmarkresultsagainstseveralstate of the artverificationtools that are able to verify programs with recursive procedures.
claim iii effectiveness and efficiency part .
we claim that our approach is comparable to intraprocedural analyses within the sameframework.toevaluatetheclaim weapplydifferentanalyses to a larger set of recursive and non recursive benchmark tasks and compare benchmark results from our interprocedural approach against intraprocedural analyses with and without bam.
.
benchmark programsandsetup weuseverificationtasksfromthesv comp benchmarkset3 includingtaskswithandwithoutrecursivefunctioncallsfromcategoriesreachsafety bitvectors reachsafety controlflow reachsafetyloops reachsafety productlines andreachsafety recursive .most recursive programs are generic and allow to easily scale the programs to deeper recursion they include recursive algorithms e.g.
fibonacci ackermann towers of hanoi andmccarthy91 .
the non recursive programs use integer arithmetics and avoid heaprelated data structures.
all experiments were performed on machines with a .4ghz quad core cpu and 33gb of ram.
the operating system was ubuntu .
bit with linux .
.
.
a cpu time limit of15min andamemorylimitof15gbwereused whichistheestablished standard from sv comp.
measurements and resource limits were managed by benchexec .
.
results anddiscussion claim i. we implemented our domain independent approach in cpachecker for several domains including value analysis predicate analysis andinterval analysis .
in addition we evaluated a reduced product ofvalueandpredicateanalysis.weused cpachecker inversion1.
whichalsoparticipatedinsv comp .
cpachecker combinedwithdifferentabstractdomainsin cpacheckeron category reachsafety recursive ofsv comp domain cputime s proofs bugs value predicate interval value predicate table resultsforthe comparison ofdifferentverifierson category reachsafety recursive ofsv comp verifier cputime s proofs bugs cbmc cpachecker sv comp divine esbmc map2check pesco pinaka symbiotic uautomizer ukojak utaipan veriabs verifuzz waschosenastheimplementationplatformbecauseithasaconfigurable and modular design that is easy to extend by new concepts has a considerable user base and is well maintained.
table1comparesbaminterproceduralforfourdomains one ofthembeingaproduct byprovidingthecputime inseconds withthreesignificantdigits neededbytheverifiersforallcorrectly solved verification tasks and the number of correctly solved tasks divided into proofs and bugs found in the category reachsafetyrecursive of sv comp.
claim ii.
we provide the results ofstate of the artsoftware verifiers which participated in sv comp .
we compare verifiers that participated successfully in the category reachsafetyrecursive of sv comp.
this includes the predicate based verifiers cpachecker pesco andultimateautomizer the bounded model checkers cbmc andesbmc the symbolic execution tool symbiotic as well as the smtbasedtool map2check .thebinaryarchivesofallverifiers arepubliclyavailable.6thedataareextractedfromthepublished sv comp results .
table2providesthesumofcputimeneededbytheverifiersfor allcorrectly solvedverification tasks and thenumberofcorrectly solvedtasks dividedintoproofsandbugsfound.theconfiguration usedbyverifier cpachecker sv comp combines valueanalysis andpredicateanalysis withinour interproceduralapproach same configurationasinthelastentryof table1 whichisautomatically selectedasthestrategytoverifyrecursiveprograms .theperformance of the tool with our approach cpachecker also shows that 59domain independentinterproceduralprogram analysis usingblock abstractionmemoization esec fse november8 virtualevent usa predicate value interval value predicate020406080 reachsafety recursive correctresults predicate value interval value predicate02040 reachsafety bitvectors correctresults predicate value interval value predicate0204060 reachsafety controlflow correctresults predicate value interval value predicate050100 reachsafety loops correctresults predicate value interval value predicate0200400 reachsafety productlines correctresults proofsand bugsfoundwithoutbam proofsand bugsfoundwithbam intraprocedural proofsand bugsfoundwithbam interprocedural figure results for different benchmark categories for thecomparisonofdifferentabstractdomainswithoutbam with bam intraprocedural and with bam interprocedural incpachecker although modularand domain independent it is competitive with completely different tools and approaches in terms of effectiveness andefficiency bam interprocedural solves about as many tasks astheothertoolswithinreasonablecputime.noneofthetools managedtoverifyalltasks andthereareseveraltasksinthegiven benchmark set that could not be solved by any verifier.
claim iii.
ascpachecker istheconfigurable program analysis framework different domain independent intraprocedural analyses based on the cpa concept are available such as the default analysis without bam and its combination with bam.
figure 6comparesthosealgorithmswithournewapproachofbaminterprocedural.
each analysis is combined with four different domains one of them being a product .
we provide the number of correctly solved tasks divided into proofs and bugs found.
each category of sv comp 20isgiven separately such that the strengthsof the algorithmsarevisible.incontrasttotheexistingintraprocedural approaches without and with bam the new approach supports theinterproceduralanalysisofrecursiveproceduresforallthree domains separately as well as for a combination of domains and leads togood results in the category reachsafety recursive .
for all other categories the results are comparable over all approaches.
onlyfor the predicate domain the resultfor the tasks in category reachsafety productlines is worse.
the reason for the result in this singlecategoryiscausedbyavalid butunfittingrefinementstep i.e.
asuboptimalheuristicinthesmtsolver thatcausesexpensiveunrollingoftheprogram.asmanytasksinthiscategoryare similar most results are affected.
for value analysis interval analysis andalsofortheanalysis basedonvalueandpredicatedomain together the new approach performs approximately as good as the existing approaches without or with bam.
conclusion wehavepresentedbaminterprocedural anovelapproachtointerproceduralprogramanalysis.thenewapproachis modular and domain independent because it is not integrated in a specific program analysis but wraps an existing analysis.
in other words given anarbitraryabstractdomainfor intra proceduraldata flow analysis wecanturnitintoan inter proceduralanalysiswithout much a development work and b performance overhead.
we have illustrated in detail how to make predicate analysis andvalue analysisinterprocedural.
our implementation and experiments show thatbaminterproceduralworkswellfor four differentprogram analyses.
the new approach supports recursive procedures becauseitisnotboundedtoafixednumberofprocedurescopes.
we showed the effectiveness on the benchmark set of recursive programs fromsv comp the approach is able to successfully verifyrecursiveprocedures.thenewapproachis efficient because itisintegratedintobam anddoesnot addmuchoverheadontop of the wrapped abstract domain.
compared to other software verifiers thenewimplementationiscompetitive.duetothemodular approach theeffectivenessandefficiencyheavilydependsonthe wrapped program analysis.
our results are promising and there is potential for optimization in our implementation.
we plan to specify the operator rebuildfor further domains like binary decision diagrams symbolicmemorygraphs oroctagons e.g.
toanalyze more difficult memory accesses in recursive programs.
we hope that other researchers and developers of verification toolscanbenefitfromourapproachbecauseitseparatestheconcern of making an analysis interprocedural from the actual work on implementing and improving abstract domains.
dataavailabilitystatement.
allbenchmarktasksforevaluation configurationfiles aready to runversionofourimplementation andtableswithdetailedresultsareavailableinourreproduction package .thesourcecodeofourextensionstotheopen source verificationframework cpachecker isavailableintheproject repository see .
60esec fse november8 virtualevent usa dirkbeyerandkarlheinzfriedberger