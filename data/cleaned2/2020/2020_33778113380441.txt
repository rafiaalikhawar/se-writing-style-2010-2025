on the recall of static call graph construction in practice li sui l.sui massey.ac.nz massey university palmerston north new zealandjens dietrich jens.dietrich vuw.ac.nz victoria university of wellington wellington new zealand amjed tahir a.tahir massey.ac.nz massey university palmerston north new zealandgeorge fourtounis gfour di.uoa.gr university of athens athens greece abstract static analyses have problems modelling dynamic language features soundly while retaining acceptable precision.
the problem is wellunderstood in theory but there is little evidence on how this impacts the analysis of real world programs.
we have studied this issue for call graph construction on a set of real world java programs using an oracle of actual program behaviour recorded from executions of built in and synthesised test cases with high coverage have measured the recall that is being achieved by various static analysis algorithms and configurations and investigated which language features lead to static analysis false negatives.
we report that the median recall is .
suggesting that standard static analyses have significant gaps with respect to the proportion of the program modelled built in tests are significantly better to expose dynamic program behaviour than synthesised tests adding precision to the static analysis has little impact on recall indicating that those are separate concerns state of the art support for dynamic language features can significantly improve recall the median observed is .
but it comes with a hefty performance penalty and the main sources of unsoundness are not reflective method invocations but objects allocated or accessed via native methods and invocations initiated by the jvm without matching call sites in the program under analysis.
these results provide some novel insights into the interaction between static and dynamic program analyses that can be used to assess the utility of static analysis results and to guide the development of future static and hybrid analyses.
ccs concepts software and its engineering automated static analysis software defect analysis dynamic analysis .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .. .
.
static program analysis testing soundness java call graph construction test case generation acm reference format li sui jens dietrich amjed tahir and george fourtounis.
.
on the recall of static call graph construction in practice.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
.
introduction static program analysis is widely used to detect faults such as bugs and vulnerabilities in software early in its life cycle when corrective action is still relatively inexpensive.
static analysis constructs and reasons about a model of program behaviour.
it is highly desirable that this process does not miss faults i.e.
it produces no false negatives and is therefore sound and that it does not produce false alerts i.e.
it produces no false positives and is therefore precise.
unfortunately rice s theorem states that such a perfect analysis is generally not possible so in practice analyses aim for reasonable trade offs between soundness and precision and in addition to this performance.
unsoundness is usually attributed to the ubiquitous presence of dynamic programming language features in modern programming languages used to implement generic components that can adapt to and be reused in different contexts.
for instance in call graph construction the static analysis computes a directed graph with functions methods procedures being represented by vertices and invocations being represented by edges.
with such a model questions relevant for program security such as can a function performing some i o operation be reached from a program entry point?
or questions related to maintenance such as what is the impact of renaming or otherwise refactoring a method?
can be answered.
however if reflection is used where a reference to a target method is computed at runtime and the language contains a feature to invoke function