fuzzing symbolic expressions luca borzacchiello diag department sapienza university of rome rome italy borzacchiello diag.uniroma1.itemilio coppa diag department sapienza university of rome rome italy coppa diag.uniroma1.itcamil demetrescu diag department sapienza university of rome rome italy demetres diag.uniroma1.it abstract recent years have witnessed a wide array of results in software testing exploring different approaches and methodologies ranging from fuzzers to symbolic engines with a full spectrum of instances in between such as concolic execution and hybrid fuzzing.
a key ingredient of many of these tools is satisfiability modulo theories smt solvers which are used to reason over symbolic expressions collected during the analysis.
in this paper we investigate whether techniques borrowed from the fuzzing domain can be applied to check whether symbolic formulas are satisfiable in the context of concolic and hybrid fuzzing engines providing a viable alternative to classic smt solving techniques.
we devise a new approximate solver fuzzy sat and show that it is both competitive with and complementary to state of the art solvers such as z3 with respect to handling queries generated by hybrid fuzzers.
index terms concolic execution fuzzing testing smt solver i. i ntroduction the automatic analysis of modern software seeking for high coverage and bug detection is a complex endeavor.
two popular approaches have been widely explored in the literature on one end of the spectrum coverage guided fuzzing starts from an input seed and applies simple transformations mutations to the input re executing the program to be analyzed to increase the portion of explored code.
the approach works particularly well when the process is guided and informed by code coverage with a nearly native execution time per explored path .
on the other end of the spectrum symbolic execution se assigns symbolic values to input bytes and builds expressions that describe how the program manipulates them resorting to satisfiability modulo theories smt solver queries to reason over the program e.g.
looking for bug conditions.
a popular variant of se is concolic execution ce which concretely runs one path at a time akin to a fuzzer collecting branch conditions along the way .
by systematically negating these conditions it steers the analysis to take different paths aiming to increase code coverage.
the time per executed path is higher than fuzzing but the aid of a solver allows for a smaller number of runs.
different ideas have been proposed to improve the effectiveness of analysis tools by combining ideas from both fuzzing and se somewhere in the middle of the spectrum.
as a prominent example hybrid fuzzing couples a fuzzer with a symbolic executor to enable the exploration of complex this paper is supported in part by european union s horizon research and innovation programme grant agreement no.
project sparta .branches .
compared to base fuzzing this idea adds a heavy burden due to the lack of scalability of symbolic execution.
it is therefore of paramount importance to speed up the symbolic part of the exploration.
while there is no clear winner in the software testing spectrum tools that hinge upon an smt solver get a high price to pay in terms of running time limiting their throughput.
contributions.
as a main contribution this paper addresses the following research question can we avoid using accurate but costly smt solvers replacing them with an approximate solver to test satisfiability in the context of software testing?
we attempt to positively answer this question devising fuzzy sat an approximate solver that borrows ideas from the fuzzing domain.
our solver is tailored to the symbolic expressions generated by concolic engines and can replace classic smt solvers in this context.
by analyzing the expressions contained in symbolic queries f uzzy satperforms informed mutations to possibly generate new valuable inputs.
to demonstrate the potential behind f uzzy sat we present fuzzolic a new hybrid fuzzer based on qemu.
to show that f uzzy satcan be used in other frameworks we integrate it also in qsym .
in our experimental evaluation we compare f uzzy satto the smt solver z3 and the approximate solver jfs on queries issued by qsym which we use as a mature baseline.
our results suggest that f uzzy satcan provide a nice tradeoff between speed and solving effectiveness i.e.
the number of queries found satisfiable by a solver.
we show that f uzzy satallows q sym to find more bugs on the la v a m dataset compared to z3.
we evaluate f uzzolic on real world programs against state of the art fuzzers including afl eclipser and q sym showing that it can reach higher code coverage than the competitors.
to facilitate extensions of our approach we make our contributions available at ii.
b ackground fuzzy sattakes inspiration from two popular software testing techniques symbolic execution and coverage7112021 ieee acm 43rd international conference on software engineering icse .
ieee based grey box fuzzing .
we now review the innerworkings of these two approaches focusing on recent works that are tightly related to the ideas explored in this paper.
symbolic execution.
the key idea behind this technique is to execute a program over symbolic rather than concrete inputs.
each symbolic input can for instance represent a byte read by the program under test from an input file and initially evaluate to any value admissible for its data type e.g.
for an unsigned byte .
se builds expressions to describe how the program manipulates the symbolic inputs resorting to smt solver queries to reason over the program state.
in particular when a branch condition bis met during the exploration se checks using the solver whether both directions can be taken by the program for some values of the inputs forking the execution state in case of a positive answer.
when forking se updates the list of path constraints that must hold true in each state bis added in the state for the true branch while bis added to the state for the false branch.
at any time the symbolic executor can generate concrete inputs able to reproduce the program execution related to one state by asking the solver an assignment for the inputs given .
se can be performed on binary code e.g.
a ngr s2e or on more high level representations of a program e.g.
llvm ir in k lee java bytecode in spf .
besides software testing se has been extensively used during the last decade in the context of cybersecurity .
concolic execution.
a twist of se designed with scalability in mind is concolic execution which given a concrete inputi analyzes symbolically only the execution path taken by the program when running over i. to generate new inputs the concolic executor can query an smt solver using b wherebis a branch condition taken by the program in the current path while is the set of constraints from the branches previously met along the path.
a benefit from this approach is that the concolic executor only needs to query the solver for one of the two branch directions as the other one is taken by the path under analysis.
additionally if the program is actually executed concretely in parallel during the analysis the concolic engine can at any time trade accuracy for scalability by concretizing some of the input bytes and make progress in the execution using the concrete state.
for instance when analyzing a complex library function the concolic engine may concretize the arguments for the function and execute it concretely without issuing any query or making more complex due to the library code but possibly giving up on some alternative inputs due to the performed concretizations.
a downside of most concolic executors is that they restart from scratch for each input driving the exploration thus repeating analysis work across different runs.
to mitigate this problem q sym has proposed a concolic executor built through dynamic binary instrumentation dbi that cuts down the time spent for running the program by maintaining only the symbolic state and offloads completely the concrete state to the native cpu.
additionally it simplifies the symbolic state by concretizing symbolic addresses but also generates inputs that can lead the program to access alternative mem ory locations.
more recently s ymcc has improved the design of q sym by proposing a source based instrumentation approach that further reduces the emulation time.
approximate constraint solving.
many queries generated by concolic executors are either unsatisfiable or cannot be solved within a limited amount of time .
this often is due to the complex constraints contained in which can impact the reasoning time even when the negated branch condition is quite simple.
for this reason q sym has introduced optimistic solving that in case of failure over b due to unsatness or solving timeout submits to the solver an additional query containing only b by patching the input i used to drive the exploration in a way that makes bsatisfied the executor is often able to generate valuable inputs for a program.
a different direction is instead taken by jfs which builds on the experimental observation that smt solvers can struggle on queries that involve floating point values.
jfs thus proposes to turn the query into a program which is then analyzed using coverage based grey box fuzzing.
more precisely the constructed program has a point that is reachable if and only if the program s input satisfies the original query.
the authors show that jfs is quite effective on symbolic expressions involving floating point values but it struggles on integer values when compared to traditional smt solvers.
two very recent works p angolin and t rident devise techniques to reduce the solving time in ce.
p angolin transforms constraints into a polyhedral path abstraction modeling the solution space as a polyhedron and using e.g.
sampling to find assignments.
t rident instead exploits interval analysis to reduce the solution space in the smt solver.
their implementations have not been released yet.
coverage based grey box fuzzing.
an orthogonal approach to se is coverage based grey box fuzzing cgf .
given an input queue q initialized with some input seeds and a programp cgf picks an input ifromq randomly mutates some of its bytes to generate i0and then runs poveri0 if new code is executed covered by pcompared to previous runs on other inputs then cgf deems the input interesting and adds it toq.
this process is then repeated endlessly looking for crashes and other errors during the program executions.
american fuzzy lop afl is the most prominent example of cgf.
to track the coverage it can dynamically instrument at runtime a binary or add source based instrumentation at compilation time.
the fuzzing process for each input is split into two main stages.
in the first one afl scans the input and deterministically applies for each position a set of mutations testing the effect of each mutation on the program execution in isolation.
in the second stage afl instead performs several mutations in sequence i.e.
stacking them over the input non deterministically choosing which mutations to apply and at which positions.
the mutations in the two stages involve simple and fast to apply transformations such as flipping bits adding or subtracting constants removing bytes combining different inputs and several others .
hybrid fuzzing.
although cgf fuzzers have found thou712sands of bugs in the last years there are still scenarios where their mutation strategy is not effective.
for instance they may struggle on checks against magic numbers whose value is unlikely to be generated with random mutations.
as these checks may appear early in the execution fuzzers may soon get stuck and stop producing interesting inputs.
for this reason a few works have explored combinations of fuzzing with symbolic execution proposing hybrid fuzzing .
driller alternates afl and a ngr temporarily switching to the latter when the former is unable to generate new interesting inputs for a specific budget of time.
q sym proposes instead to run a concolic executor in parallel with afl allowing the two components to share their input queues and continuously benefit from the work done by each other.
recent improvements in coverage guided fuzzing.
during the last years a large body of works has extended cgf trying to make it more effective without resorting to heavyweight analyses such as symbolic execution.
l af intel splits multi byte checks into single byte comparisons helping the fuzzer track the intermediate progress when reasoning on a branch condition.
v uzzer integrates dynamic taint analysis dta into the fuzzer to identify which bytes influence the operands in a branch condition allowing it to bypass e.g.
checks on magic numbers.
a ngora further improves this idea by performing multi byte dta and using gradient descent to effectively mutate the tainted input bytes.
as dta can still put a high burden on the fuzzing strategy some works have recently explored lightweight approximate analyses that can replace it.
r edqueen introduces the concept of input to state correspondence which captures the idea that input bytes often flow directly or after a few simple encodings e.g.
byte swapping into comparison operands during the program execution.
to detect this kind of input dependency r edqueen uses colorization that inserts random bytes into the input and then checks whether some of these bytes appear as is or after few simple transformations in the comparison operands when running the program.
input to state relations can be exploited to devise effective mutations and bypass several kinds of validation checks.
weizz explores instead a different approach that flips one bit at a time on the entire input checking after each bit flip which comparison operands have changed during the program execution possibly suggesting a dependency between the altered bit and the affected branch conditions.
while more accurate than colorization this approach may incur a large overhead especially in presence of large inputs.
nonetheless weizz is willing to pay this price as the technique allows it to also heuristically locate fields and chunks within an input supporting smart mutations to effectively fuzz applications processing structured input formats.
slf exploits a bit flipping strategy similar to w eizz to generate valid inputs for an application even when no meaningful seeds are initially available for it.
thanks to the input dependency analysis slf can identify fields into the input and then resort to a gradient based multi goal searchheuristic to deal with interdependent checks in the program.
eclipser identifies a dependency between an input byteikand a branch condition bwhenever the program decision on bis affected when running the program on inputs containing different values for ik.
eclipser builds approximate path constraints by modeling each branch condition met along the program execution as an interval.
in particular given a branch b it generates a new input using a strategy similar to concolic execution by looking for input values that satisfy the interval from bas well as any other interval from previous branches met along a path.
to find input assignments e clipser does not use an smt solver but resorts to lightweight techniques that work well in presence of intervals generated by linear or monotonic functions.
iii.
a pproach recent coverage guided fuzzers perform input mutations based of a knowledge on the program behavior that goes beyond the simple code coverage.
concolic executors by design build an accurate description of the program behavior i.e.
symbolic expressions but outsource completely the reasoning to a powerful but expensive smt solver which is typically treated as a black box.
in this paper we explore the idea that a concolic executor can learn from the symbolic expressions that it has built and use the acquired knowledge to apply simple but fast input transformations possibly solving queries without resorting to an smt solver.
the key insight is that given a query b the inputithat has driven the concolic exploration satisfies by design .
hence we propose to build using input mutations a new test case i0that satisfies band is similar enough to iso that remains satisfied by i0.
in the remainder of this section we present the design of f uzzy sat an approximate solver that explores this direction by borrowing ideas from the fuzzing domain to efficiently solve queries generated by concolic execution.
a. reasoning primitives for concolic execution while smt solvers typically offer a rich set of solving primitives enabling reasoning on formulas generated from quite different application contexts concolic executors such as qsym are instead built on top of a few but essential primitives.
in this paper we focus on these primitives without claiming that f uzzy satcan replace a full fledged smt solver in a general context.
f uzzy satexposes the following primitives solve e i opt returns an assignment for the symbolic inputs in e such that the expression e is satisfiable.
the flag optindicates whether optimistic solving should be performed in case of failure.
this primitive is used by concolic engines when negating a branch condition b hencee b. solve max e i resp.
s olve min e i returns an assignment that maximizes resp.
minimizes ewhile making satisfiable.
concolic executors use these primitives before concretizing a symbolic memory address e to keep the exploration scalable.
these functions are thus 713analysis input groups input to state range intervals constants conflicting exprs reasoning expression metadata fetch update input to state mutation engine range brute force gradient descent afl deterministic multi goal engine find conflicting expr e if not sat fuzz e fetch constants afl non determ.
inputs fig.
.
internal architecture of f uzzy sat.
used to generate alternative inputs that steer the program to read write at boundary addresses.
solve all e i combines s olve minand s olve max yielding intermediate assignments identified during the reasoning process as well.
this primitive is valuable in the presence of symbolic memory addresses accessing a jump table or when the instruction pointer becomes symbolic during the exploration.
two main aspects differentiate these primitives in f uzzy satwith respect to their counterpart from an smt solver.
first f uzzy satis an approximate solver and thus it cannot guarantee that no valid assignment exists in case of failure of s olve i.e.
f uzzy satcannot prove that an expressione is unsatisfiable.
similarly given an expression e fuzzy satmay fail to find its global minimum maximum value or to enumerate assignments for all its possible values.
another crucial difference is that f uzzy satrequires that the concolic engine provides the input test case ithat was used to steer the symbolic exploration of the program under test.
this is essential as f uzzy satbuilds assignments by mutating the test case ibased on facts that are learned when analyzingeand .
given an assignment areturned by f uzzy sat a new input test case i0can be built by patching the bytes inithat are assigned by a. b. overview architecture.
to support the primitives presented in section iii a the architecture of f uzzy sat figure has been structured around three main building blocks the analysis stage the expression metadata and the reasoning stage .
the analysis stage iii c is designed to analyze symbolic expressions extracting valuable knowledge to use during the reasoning stage.
it starts by identifying which input bytes ikfrom the input iare involved in an expression and how they are grouped.
it detects input to state relations ii and collects constants appearing in the expression for later use in the mutation phase.
expressions that constrain the interval of admissible values for a set of inputs dubbed range constraints such asi0 are identified to keep track of the range intervals over the symbolic inputs.
finally this stage detects whether the current expression shares input bytes with other expressions previously processed by the analysis component possibly pinpointing conflicts that may result when mutating these bytes during the reasoning stage.
the expression metadata maintains the knowledge of fuzzy saton the expressions processed by the analysisfunction solve e i opt 1m analyze m 2m analyze e m 3a sa mutate e i m 4ifa is not null then return a 5a pickbestassignment sa 6ifa is not null then m0 fixinput bytes a m cc getconflicting expressions e m0 fore02ccdo a0 sa mutate e0 i m0 ifa0is not null then return a0 a0 pickbestassignment sa ifa0is null then break a a0 m0 fixinput bytes a m0 ifoptthen ifa is null then a mutate opt e i m return a return null algorithm solve implementation of f uzzy sat analysis stage in light gray reasoning stage in dark gray initial mutations due to eat lines multi goal strategy at lines and optimistic solving at lines .
stage over time.
internally it is implemented as a set of data structures optimized for fast lookup of different kinds of properties related to an expression and its subexpressions .
it is updated by the analysis stage and queried by both stages.
finally the reasoning stage is where f uzzy satexploits the knowledge over the expressions to effectively fuzz the input test case and possibly generate valid assignments.
to reach this goal a mutation engine iii d is used to perform a set of transformations over the input bytes involved in an expressionelooking for an assignment that satisfies eand solve or maximizes minimizes ewhile satisfying other primitives .
when this step finds assignments for e but none of them satisfies then f uzzy satperforms a multi goal strategy which is not limited to changing the input bytes involved in e but attempts to alter other input bytes that are involved in conflicting expressions present in .
implementing the reasoning primitives.
algorithm shows the interplay of these three components in f uzzy sat when considering the primitive s olve .
lines and execute the analysis stage by invoking the a nalyze function on ande respectively.
a nalyze updates the expression metadata m adding any information that could be valuable during the reasoning stage.
since concolic engines would typically call s olve several times during the symbolic exploration providing each time a that is the conjunction of branch conditions met along the path and which have been already analyzed by f uzzy satin previous runs of s olve the call at line does not lead f uzzy satto perform any work in most scenarios as the expression metadata m already has a cache containing knowledge about expressions in .
lines instead comprise the reasoning stage and can be divided into three main phases.
first the m utate function is called at line to run the mutation engine restricting the transformations on input bytes that are involved in the expressione.
when m utate finds an assignment athat 714satisfies both eand solve returns it at line without any further work.
on the other hand when ais invalid but some assignments sa found by m utate make at least esatisfiable then s olve starts the multi goal phase lines .
to this end f uzzy satuses function p ickbestassignment to select the best candidate assignment afrom sa1and then fixes the input bytes assigned by ausing function f ixinput bytes to prevent further calls of m utate from altering these bytes.
it then reruns the mutation engine considering an expression e0 which has been marked as in conflict with eduring the analysis stage.
this process is repeated as long as three conditions hold a e is not satisfied line b m utate returns at least one assignment in sa for e0 line and c there is still a conflicting expression left to consider condition at line .
the multi goal strategy in f uzzy satemploys a greedy approach without ever performing backtrack e.g.
reverting the effects of f ixinput bytes in case of failure as it trades accuracy for scalability.
indeed f uzzy satbuilds on the intuition that by altering a fewbytes from the input test case i it is possible in several cases to generate valid assignments.
additionally since many queries generated by a concolic engine are unsatisfiable increasing the complexity of this strategy would impose a large burden on f uzzy sat.
the last phase of s olve lines has been devised to support optimistic solving in f uzzy sat.
when the boolean optis true f uzzy satreturns the last candidate assignment found by the mutation engine which by design satisfies the expressione.
however since the previous calls to the mutation engine in s olve may have failed to find an assignment a foredue to the constraints resulting from the analysis of expressions from fuzzy satas last resort uses a variant of the function m utate called m utate opt that ignores these constraints and exploits only knowledge resulting from ewhen performing transformations over the input bytes.
the other reasoning primitives s olve min solve max and s olve all respectively follow a workflow similar to solve and we do not present their pseudocode due to lack of space.
in the remainder of this section we focus on the internal details of functions a nalyze iii c and m utate iii d which are crucial core elements of f uzzy sat.
c. analyzing symbolic expressions we now present the details of the main analyses integrated into the a nalyze function which incrementally build the knowledge of f uzzy satover an expression e. detecting inputs and input groups.
the first analysis identifies which input bytes ikare involved in an expression and evaluates how these bytes are grouped.
in particular f uzzy satchecks whether the expression can be regarded as an input group i.e.
the expression is equivalent to a concatenation of input bytes or constants that never mixtheir bits.
single byte expressions are also detected as input groups.
1we pick anathat maximizes the number of expressions satisfied in .examples expressioni1 i0contains inputs i0andi1 and it is an input group since the bits from these bytes do not mix with each other but are just appended expression i0contains input i0and it is a byte input group as it is a zero extend operation on i0 expressioni1 i0contains inputs i0andi1 but it is not an input group as bits from i0are mixed i.e.
added with bits from i1 expression i0 i1 contains inputs i0 andi1 and it is an input group as the expression is equivalent to i1 i0 which is an input group.
given an expression e fuzzy satstores in the expression metadata m the list of inputs involved in e whethereis an input group and the list of input groups contained inewhen recursively considering subexpressions of e. detecting uniquely defined inputs.
a crucial information about an input byte is knowing whether its value is fixed to a single value dubbed uniquely defined in our terminology due to one equality constraint that involves it.
indeed it is not productive to fuzz input bytes whose value is fixed to a single constant.
given an expression e then ifeis an equality constraint and one of its operands is an input group or contains exactly only one input group while the other operand is a constant then m is updated to reflect that the bytes in the group will be uniquely defined due to eifeis later added to an input in eis marked as uniquely defined whenever a constraint from marks it as uniquely defined the input group in e if any is marked as uniquely defined whenever the inputs forming it are all uniquely defined due to constraints in example.
the expression i1 i0 0xabcd makes fuzzy satmark inputs i0andi1as uniquely defined.
if this expression is later added to theni0andi1 will be considered uniquely defined in other expressions disabling fuzzing on their values.
detecting input to state branch conditions.
this analysis checks whether econtains at least one operand that has inputto state correspondence ii .
in f uzzy satwe use the following conditions to detect this kind of branch conditions a ematches the pattern e0opcmpe00 whereopcmp is a comparison operator e.g.
etc.
and b one operand e0ore00 is an input group.
when eis a boolean negation fuzzy satrecursively analyzes the subexpression.
example.
the expression i1 i0is an input tostate branch condition as is a comparison operator and i1 i0is an input group.
detecting interesting constants.
fuzzy satchecks the expressione looking for constants that could be valuable during the reasoning stage dynamically building a dictionary to 715use during the transformations.
when specific patterns are detected f uzzy satgenerates variants of the constants based on the semantics of the computation performed by e. example.
when analyzing i1 0xf0 0x0f fuzzy satcollects the constants 0xf0 0x0f and 0xff i.e.
0xf0 0x0f since the computation is an exclusive or.
the patterns used to generate interesting constants can be seen as a relaxation of the concept of input to state relations.
detecting range constraints.
fuzzy satchecks whether eis a range constraint i.e.
a constraint that sets a lower bound or an upper bound on the values that are admissible for the input group in e if any .
for instance f uzzy sat looks for constraints matching the pattern e0opcmpe00where e0is an input group opcmp is a comparison operator and e00is a constant value.
other equivalent patterns such as e0 e00 opcmpe000wheree0is an input group while e00and e000are constants are detected as range constraints as well.
by considering bounds resulting from expressions in and not only from e fuzzy satcan compute refined range intervals for the input groups contained in an expression.
to compactly and efficiently maintain these intervals f uzzy sat uses wrapped intervals which can transparently deal with both signed and unsigned comparison operators.
examples.
given the expressions i1 i0 10andi1 i0 fuzzy satcomputes the range interval for the input group composed by i0andi1 given the expression i1 i0 0xaaaa unsigned 0xbbbb f uzzy sat computes the intervals fori0andi1 correctly modeling the wrap around that may result in the two s complement representation.
detecting conflicting expressions.
the last analysis is devised to identify which expressions from may conflict withewhen assigning some of its input bytes.
in particular f uzzy sat marks an expression e0as in conflict with ewhenever the set of input bytes in e0is not disjoint with the set from e. example.
the expression i1 i0 10is in conflict with the expression i1 i2 20as they both contain the input bytei1.
hence fuzzing the first expression may negatively affect the second expression.
computing the set of conflicting expressions is essential for performing the multi goal strategy during the reasoning stage.
d. fuzzing symbolic expressions the core step during the reasoning stage of f uzzy satis the execution of the function m utate which attempts to find a valid assignment a. to reach this goal m utate performs a sequence of mutations over the input test case i returning as soon as a valid assignment is found by one of these transformations.
when a mutation generates an assignment that satisfied ebut not then m utate saves it into a setof candidate assignment sa which could be valuable later on during the multi goal strategy iii b .
in some cases a transformation can determine that there exists a contradiction betweeneand the conditions in leading m utate to an early termination.
additionally when m utate builds a candidate assignment a it checks that ais consistent with the range intervals known for the modified bytes discarding ain case of failure and avoiding the possibly expensive check over .
we now review in detail the input transformations performed by the function m utate .
fuzzing input to state relations.
when an expression eis an input to state branch condition iii c f uzzy sattries to replace the value from one operand e0into the bytes composing the input group from the other input to state operand e00.
if e0is not constant then f uzzy satgets its concrete value by evaluatinge0on the test case i. whene0is constant and the relation is an equality if the assignment does not satisfy then f uzzy satdeems the query unsatisfiable.
conversely when the comparison operator is not an equality f uzzy sattests variants of the value from e0 e.g.
by adding or subtracting one to it in the same spirit as done by r edqueen .
example.
giveni1 i0 0xabcd fuzzy sat builds the assignment fi0 0xcd i1 0xabg.
if the range interval over i0is due to constraints from then the assignment can be discarded without testing deeming the query unsatisfiable but keeping the assignment in sa in case of optimistic solving .
range interval brute force.
when a range interval is known for an input group contained an expression e fuzzy sat can use this information to perform brute force on its value and possibly find a valid assignment.
in particular when an expression contains a single input group and its range interval is less than f uzzy satbuilds assignments that brute force all the possible values assignable to the group.
if no valid assignment is found then the query can be deemed unsatisfiable.
if the interval is larger than then f uzzy satonly tests the minimum and maximum value of the interval.
to make this input transformation less conservative fuzzy satruns it even when econtains at least one input group whose interval is less than2512.
example.
given the expression i1 i0 0xabcd 0xcafe and the range interval built due to constraints from on the group gwithi0andi1 then fuzzy satbuilds assignments for g2 deeming the query unsatisfiable if none of them satisfies e .
trying interesting constants.
for each constant ccollected by a nalyze when considering the expression eand for each input group gcontained in e fuzzy sattries to set the bytes fromgto the value c. since constants are collected through relaxed patterns f uzzy sattests different encodings e.g.
little endian big endian zero extension etc.
for each constant to maximize the chances of finding a valid assignment.
2we pick the input group with the minimum range interval.
716example.
given the expression i1 i0 and assuming that a nalyze has collected the constants f2 201gwhere 2was obtained as while other constants are obtained from 100and then f uzzy satwould find a valid assignment when testingfi0 i1 0g c little endian encoding .
gradient descent.
given an expression e fuzzy sattries to reduce the problem of finding a valid assignment for it to a minimization or maximization problem.
this is valuable not only in the context of s olve min solve max or solve allwhere this idea seems natural but also when reasoning over the branch condition ein s olve .
indeed any expression of the form e0opcmpe00 whereopcmp is a comparison operator can be transformed into an expression famenable to minimization to find a valid assignment e.g.
e0 e00can be transformed3intof 0withf e0 e00.
the search algorithm implemented in f uzzy satis inspired by a ngora and it is based on gradient descent.
although this iterative approach may fail to find a global minimum for f a local minimum can be often good enough in the context of concolic execution as we do not always really need the global minimum but just an assignment that satisfies the condition e.g.
given i0 the assignmentfi0 0x0g satisfies the condition even if the global minimum for i0 1is given byfi0 0x81g.
for this reason f uzzy satin s olve can stop the gradient descent as soon an assignment satisfies botheand .
when the input groups from ehave disjoint bytes f uzzy satcomputes the gradient considering groups of bytes instead of computing it for each distinct byte as this makes the descent more effective.
in fact reasoning on i0and i1as a single value is more appropriate when these bytes are used in a two byte operation since gradient descent may fail when these bytes are considered independently.
example.
given the expression i0 i1 i2 i3 5and a zero filled input test case then f uzzy sat transforms the expression into i2 i3 i1 i0 computes the gradients over the input groups i1 i0 and i2 i3 finding the assignment fi0 0x80 i1 0x06 i2 0x84 i3 0x01gwhich makes the condition satisfied as 0x80 0x06 0x84 0x01 .
deterministic and non deterministic mutations.
these two sets of input transformations are inspired by the two mutation stages from afl ii .
deterministic mutations include bit or byte flips replacing bytes with interesting well known constants e.g.
max int adding or subtracting small constants from some input bytes.
non deterministic mutations instead involve also transformations such as flipping of random bits inside randomly chosen input bytes setting randomly chosen input bytes to randomly chosen interesting constants subtracting or adding random values to randomly chosen bytes and several others .
the main differences with respect to 3for the sake of simplicity we ignore in our examples the wrap around.afl are a mutations are applied only on the input bytes involved in the expression e b multi byte mutations are considered only in the presence of multi byte input groups c for non deterministic mutations f uzzy satgenerates kdistinct assignments with kequal to maxf100 ni 20g whereniis the number of inputs involved in e and for each assignment it applies a sequence or stack of nmutations n rand as in afl .
e. discussion similarly to fuzzers using dynamic taint analysis f uzzy satrestricts mutations over the bytes that affect branch conditions during the program execution.
however it does not only understand which bytes influence the branch conditions but also reasons on how they affect them possibly devising more effective mutations.
fuzzy sat shares traits with a ngora slf and eclipser by integrating mutations based on gradient descent a multi goal strategy and range intervals respectively.
nevertheless these techniques have been revisited and refined to work over symbolic constraints which accurately describe the program state and are not available to these fuzzers.
fuzzy satexposes primitives that are needed by concolic executors and that are typically offered by smt solvers but it implements them in a fundamentally different way inspired by fuzzing techniques trading accuracy for scalability.
finally f uzzy satshares the same spirit of jfs but takes a rather different approach.
while jfs builds a bridge between symbolic execution and fuzzers by turning expressions into a program to fuzz f uzzy satis designed to merge these two worlds possibly devising informed mutations that are driven by the knowledge acquired by analyzing the expressions.
iv.
i mplementation fuzzy satis written in c 10k loc and evaluates queries in the language used by the z3 theorem prover .
to efficiently evaluate an expression given a concrete assignment fuzzy satuses a fork of z3 where the z3 model eval function has been optimized to deal with full concrete models.
fuzzolic is a new concolic executor based on qemu .
user mode written in c 20k loc that currently supports linux x86 binaries.
its design overcomes one of the major problems affecting q sym fuzzolic decouples the tracer component which builds the symbolic expressions from the solving component which reasons over them.
this is required as recent releases of most dbi frameworks such as pin on which q sym is based on do not allow an analysis tool to use external libraries as the z3 solver in case of q sym when they may produce side effects on the program under analysis .
this implementation constraint has made it very complex to port qsym to newer releases of pin limiting its compatibility with recent software and hardware configurations4.
to overcome this issue the two components are executed into distinct processes in f uzzolic .
4qsym has been recently removed from the google project fuzzbench due to its instability on recent linux releases .
717in particular the tracer runs under qemu and generates symbolic expressions in a compact language storing them into a shared memory that is also attached to the memory space of the solving component which in turn submits queries to fuzzy satto generate alternative inputs.
similarly to q sym fuzzolic runs in parallel with two coverage guided fuzzers.
v. e valuation in this section we address the following research questions rq1 how effective and efficient is f uzzy satat solving queries generated by concolic executors?
rq2 how do different kinds of mutations help f uzzy satin solving queries?
rq3 how does f uzzolic with f uzzy satcompare to state of the art fuzzers on real world programs?
benchmarks.
throughout our evaluation we consider the following programs advmng .
bloaty rev 7c6fc bsdtar rev.
f3b1f djpeg v9d jhead .
libpng .
.
lodepng decode rev.
5a0dba objdump .
optipng .
.
readelf .
tcpdump .
.
libpcap .
.
and tiff2pdf .
.
.
these targets have been heavily fuzzed by the community and used in previous evaluations of state of the art fuzzers .
as seeds we use the afl test cases or when missing minimal syntactically valid files .
experimental setup.
we ran our tests in a docker container based on the ubuntu .
image using a server with two intel xeon e5 4610v2 .
ghz cpus and gb of ram.
a. rq1 solving effectiveness of fuzzy sat to evaluate how effective and efficient is f uzzy satat solving queries generated by concolic execution we discuss an experimental comparison of f uzzy satagainst the smt solver z3 and the approximate solver jfs.
we first focus on s olve queries collected by running the programs under qsym on their initial seed with optimistic solving disabled comparing the solving time and the number of queries successfully proved as satisfiable when using these three solvers.
then we analyze the performance of q sym at finding bugs on the la v a m dataset when using f uzzy satwith respect to when using z3 implicitly considering the impact also of other reasoning primitives e.g.
s olve max and from enabling optimistic solving in s olve .
in these experiments we consider q sym instead of f uzzolic to avoid any bias resulting from its expression generation phase that could benefit f uzzy satand impair the other solvers.
fuzzy satvs z3.
table i provides an overview of the comparison between f uzzy satand z3 on the queries generated when running the benchmarks.
the first interesting insight is that only a small subset of the queries i.e.
less than has been proved satisfiable even when considering together both solvers .
the remaining queries are either proved unsatisfiable or make the solvers run out of the time budget seconds for z3 as in q sym .
the second insight is that when focusing on the queries that are satisfiable f uzzy satis able to solve the majoritytable i number of queries proved satisfiable by fuzzy sat w .r.t.
z3 timeout 10secs .
n umbers show the average of 5runs .
the speedup considers the solving time on the full set of queries .
program queries proved sat by sat f uzzy sat solv.
time queries both z3 fuzzy sat div.by sat z3 speedup advmng .
.
.
.
.
bloaty .
.
.
.
.
bsdtar .
.
.
.
djpeg .
.
.
.
.
jhead .
.
.
libpng .
.
.
lodepng .
.
.
.
.
objdump .
.
.
.
optipng .
.
.
readelf .
.
.
.
tcpdump .
.
.
.
.
tiff2pdf .
.
.
.
g. mean .
.
.
.
.
.
of them and can even perform better than z3 on a few benchmarks for instance f uzzy satsolves queries on average on advmng while z3 stops at .
although this may seem unexpected this result is consistent with past evaluations from state of the art fuzzers that have shown that a large number of branch conditions can be solved even without smt solvers.
nonetheless there are still a few queries were f uzzy satis unable to find a valid assignment while z3 is successful e.g.
fuzzy satmisses queries on bloaty but solves one query that makes z3 run out of time .
assessing the impact of solving ornot solving a query in concolic execution is a hard problem especially when bringing into the picture hybrid fuzzing and its non deterministic behavior.
hence we only try to indirectly speculate on this impact by later discussing the results on the la v a m dataset and the experiments in section v c. lastly we can see in table i that on average f uzzy sat requires less time than z3 to reason over the queries from the benchmarks.
when putting together this result with the previous experimental insights we could speculate why f uzzy satcould be beneficial in the context of concolic execution it can significantly reduce the solving time during the concolic exploration while still be able to generate a large number of possibly valuable inputs.
one natural question is whether one could get the same benefits of f uzzy satby drastically reducing the time budget given to z3.
to tackle this observation figure 2a reports the number of queries solved by z3 when using a timeout of second and figure 2b shows how the speedup from f uzzy satis reduced in this setup.
f uzzy satis still faster than z3 and the gap between the two in terms of solved queries increases significantly in f uzzy sat suggesting that this setup of z3 is not as effective as one may expect.
fuzzy satvs jsf.
one solver that shares the same spirit of f uzzy satis jfs ii which however is based on a different design.
when considering the queries collected on the benchmarks it can be seen in figure 2a that jfs is able to solve only queries significantly less than the from f uzzy sat.
on out of the queries from bsdtar jfs has failed to generate the program to fuzz due a all benchmarks0500100015002000 queries proved sat1367.
.
11061534z3 secs z3 secs jfs fuzzy sat b all benchmarks051015speedup on solving time9.
.
.8fuzzy sat vs z3 sec fuzzy sat w o cache vs jfs fuzzy sat vs jfs fig.
.
f uzzy satvs other solvers on the benchmarks a number of queries proved satisfiable and b speedup on the solving time.
table ii bugs found on lava m in5h avg max number over 5runs .
base64 md5sum uniq who qsym with z3 qsym with fuzzy sat .
.
to the large number of nested expressions contained in the queries yielding a gap of 95solved queries between two solvers.
the remaining missed queries can be likely explained by considering that a it is not currently possible to provide the input test case iused for generating the queries to the fuzzer executed by jfs as jfs generates a program that takes an input that is different in terms of size and structure fromiand builds its own set of seeds b jfs does not provide specific insights to the fuzzer on how to mutate the input and c jfs uses l ibfuzzer which does not integrate several fuzzing techniques that have inspired f uzzy sat.
when considering the solving time f uzzy satis1 faster than jfs figure 2b .
however when enabling analysis cache in f uzzy sat the speedup increases up to .
jfs does not currently provide a c interface requiring concolic executors to dump the queries on disk as this operation can take a long time in presence of large queries we do not consider jfs further in the other experiments.
fuzzy saton la v a m. to test whether f uzzy satcan solve queries that are valuable for a concolic executor we repeated the experiment on the la v a m dataset from the qsym paper looking for bugs within the four benchmarks base64 md5sum uniq and who.
table ii reports the average and max number of bugs found during hour experiments across runs.
q sym with f uzzy satfinds on average more bugs than q sym with z3 on out of programs.
in particular the improvement is rather significant on who where fuzzy satallows q sym to find more bugs compared to z3 suggesting that trading performance for accuracy can be valuable in the context of hybrid fuzzing.
interestingly f uzzy satwas able to reveal bugs that the original authors from la v a m were unable to detect e.g.
fuzzy sathas revealed new bugs on who.
since other works reported a similar experimental observation the additional bugs are likely not false positives.
b. rq2 impact of different kinds of mutations in fuzzy sat an interesting question is which mutations contribute at making f uzzy sateffective.
table iii reports which transformations have been crucial to solve the queries from the benchmarks assigning a query to the multi goal strategy when fuzzy sathad to reason over conflicting expressions fromtable iii effectiveness of the different mutations from fuzzy sat i2s input to state bf r.i. b rute force ic i nteresting constants gd g radient descent d nd d eterministic and non deterministic mutations mgs m ulti goal strategy .
program i2s bf ic gd d nd mgs advmng bloaty bsdtar djpeg jhead libpng lodepng objdump optipng readelf tcpdump tiff2pdf perc.on total .
.
.
.
.
.
to solve the query.
f uzzy satwas able to solve more than of the queries by applying input to state transformations and an additional was solved by exploiting the interesting constants collected during the analysis stage.
range interval brute force was helpful on around of the queries while mutations inspired by afl were beneficial in of them.
gradient descent solved just of the queries.
however two considerations must be taken into account a the order of the mutations affect these numbers as gradient descent is not used when previous cheaper mutations are successful and b gradient descent is crucial for solving queries in s olve min solve max and s olve all which are not considered in this experiment.
finally the multi goal strategy of f uzzy satwas essential for solving around of the queries.
c. rq3 fuzzy satinfuzzolic to further assess the effectiveness of f uzzy sat we compare f uzzolic which is built around this solver against state of the art binary open source fuzzers on the benchmarks tracking the code coverage reached during hour experiments runs .
besides f uzzolic we consider a afl rev.
3f128 in qemu mode which integrates the colorization technique from r edqueen as well as other improvements to afl proposed by the fuzzing community during the last years b e clipser rev.b072f which devises one of the most effective approximations of concolic execution in literature and c q sym rev.89a76 with z3.
as both f uzzolic and q sym are hybrid fuzzers that are designed to run in parallel with two instances fm fs of a coverage guided fuzzer we consider for a fair comparison afl and e clipser in a similar setup running them in parallel to fm fs and allowing the tools to sync their input queues .
hence each run takes cpu hours.
forfmwe use afl in master mode which performs deterministic mutations while for fswe use afl in slave mode that only executes non deterministic mutations.
since eclipser does not support a parallel mode we extended it to allow afl to correctly pick inputs from its queue.
figure shows the code coverage reached by the different fuzzers on out of programs.
on the remaining four time secs 357911131517coverage map density bsdtar afl eclipser fuzzolic fuzzy sat qsym z3 time secs 234567coverage map density djpeg afl eclipser fuzzolic fuzzy sat qsym z3 time secs 1234coverage map density libpng afl eclipser fuzzolic fuzzy sat qsym z3 time secs 4710131619coverage map density objdump afl eclipser fuzzolic fuzzy sat qsym z3 time secs 345678coverage map density optipng afl eclipser fuzzolic fuzzy sat qsym z3 time secs 371115192327coverage map density readelf afl eclipser fuzzolic fuzzy sat qsym z3 time secs 2112029384756coverage map density tcpdump afl eclipser fuzzolic fuzzy sat qsym z3 time secs 4681012141618coverage map density tiff2pdf afl eclipser fuzzolic fuzzy sat qsym z3 fig.
.
coverage map density reached by f uzzolic with f uzzy satvs other state of the art fuzzers.
the shaded areas are the confidence intervals.
time secs 31221303948coverage map density tcpdump fuzzolic fuzzy sat qsym z3 qsym fuzzy sat time secs 4710131619coverage map density objdump fuzzolic fuzzy sat qsym z3 qsym fuzzy sat fig.
.
coverage map density impact of f uzzy satin q sym.
benchmarks the fuzzers reached soon a very similar coverage making it hard to detect any significant trend and thus we omit their charts due to lack of space.
similar to other works we plot the density of the coverage map from fsand depict the confidence interval using a shaded area.
as bitmap collisions may occur we validated the trends by also computing the number of basic blocks .
fuzzolic reaches a higher code coverage than other solutions on programs i.e.
bsdtar djpeg objdump readelf tcpdump and tiff2pdf.
in particular tcpdump is the program where f uzzolic shines better consistently showing over time an increase in the map density of with respect to the second best fuzzer afl .
on optipng although f uzzolic appears to have an edge at the beginning of the experiment it then reaches a coverage that is comparable to other fuzzers which are all very close in performance.
finally f uzzolic falls behind other approaches on libpng pinpointing one case where f uzzy satseems to underperform compared to z3 as q sym dominates on this benchmark.
when comparing closely f uzzolic to q sym the improvement in the coverage is likely due to the better scalability of the former with respect to the latter.
for instance on tcpdump fuzzolic performs concolic execution on inputs secs input generating alternative inputs while q sym only analyzes 376inputs 4secs input and generates alternative inputs.
when considering libpng f uzzolic is still faster than q sym 8secs input vs 6secs input but the number of inputs available in the queue from fs from which f uzzolic and q sym pick inputs over time is very low.
hence the difference between f uzzolic and q sym on libpng is due to a few but essential queries that z3 is able to solve while f uzzy satfails to reason on.
the better scalability of f uzzolic with respect to q sym isgiven by the combination of an efficient solver f uzzy sat and an efficient tracer f uzzolic .
indeed when replacing z3 with f uzzy satin q sym this concolic executor improves its performance but still falls behind f uzzolic .
figure compares the coverage of q sym with the two solvers and fuzzolic on two benchmarks.
on tcpdump q sym with fuzzy satis able to analyze inputs 1secs input and generate alternative inputs improving the coverage by on average with respect to z3 but still performing worse than f uzzolic .
similarly on objdump the improvement in qsym due to f uzzy satis even more noticeable but still qsym cannot match the coverage reached by f uzzolic .
when comparing f uzzolic to e clipser and afl the results suggest that the integration of fuzzing techniques into a solver provides a positive impact.
indeed while these fuzzers scales better than f uzzolic processing hundreds of inputs per second they lack the knowledge that f uzzy sat extracts from the symbolic expressions which is used to perform effective mutations.
overall colorization from afl and approximate concolic execution from e clipser seem to generate similar inputs on several benchmarks yielding often a similar coverage in our parallel fuzzing setup.
moreover despite f uzzolic may spend several seconds over a single input it collects information that allows it to fuzz a large number of branch conditions paying on average only a few microseconds when testing an input assignment.
hence the time spent building the symbolic expressions can be amortized over thousands of cheap query evaluations reducing the gap between the efficiency of a fuzzer and a concolic executor.
nonetheless f uzzolic is still a hybrid fuzzer and it needs to run in parallel to a traditional fuzzer to provide good results since some non deterministic mutations such as randomly combining inputs are not performed by f uzzolic .
vi.
t hreats to validity and limitations floating point arithmetic.
our current implementation of fuzzolic and f uzzy satdoes not handle symbolic expressions involving floating point operations.
in case of floatingpoint instructions during program execution f uzzolic concretizes the symbolic expressions.
although this is the same strategy adopted by q sym we acknowledge that it may harm 720the effectiveness of the concolic executor on programs heavily based on floating point computations.
order of the mutations in f uzzy sat.the current implementation of f uzzy satapplies mutations using a specific order and stops as soon as one of the mutations is successful in finding a valid assignment for a query.
in particular f uzzy satruns first the cheapest rules that are more likely able to succeed e.g.
given an input to state relation trying the inputto state rule first makes sense as it requires a few attempts and has high chances to succeed .
hence results reported in section v are based on the order currently adopted by fuzzolic .
an interesting experiment would be to evaluate how f uzzy satwould perform when changing the order of the mutations.
impact of f uzzy satin hybrid fuzzing .
in section v we have investigated the impact of f uzzy satinside two concolic executors f uzzolic and q sym.
our results are promising and suggest that f uzzy satcan be beneficial in the context of hybrid fuzzing.
however we believe it would be interesting to integrate f uzzy satin other frameworks to have additional insights on its effect.
for instance the benefit from using f uzzy satinside a concolic executor that is slow at building symbolic expression would be marginal as most of the analysis time would be spent in the emulation phase and not in the solving one.
on the other hand an efficient concolic executor should benefit from f uzzy satas long as the number of queries submitted to the solver during an experiment is very high if the number of queries is low then a slower but more accurate traditional smt solver would likely perform better than f uzzy sat.
vii.
c onclusions fuzzy satis an approximate solver that uses fuzzing techniques to efficiently solve queries generated by concolic execution helping hybrid fuzzers scale better on several realworld programs.
we have currently identified two interesting future directions.
first we plan to integrate f uzzy satin the concolic execution framework s ymcc which has been shown to be very efficient at building symbolic expressions and thus should benefit from using an efficient approximate solver.
second we would like to devise an effective heuristic for dynamically switching during the exploration between f uzzy satand a traditional smt solver depending on the workload generated by the concolic executor on the solver backend.