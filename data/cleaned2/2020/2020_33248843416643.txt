good things come in threes improving search based crash reproduction with helper objectives pouria derakhshanfar p.derakhshanfar tudelft.nl delft university of technology delft the netherlandsxavier devroey x.d.m.devroey tudelft.nl delft university of technology delft the netherlandsandy zaidman a.e.zaidman tudelft.nl delft university of technology delft the netherlands arie van deursen arie.vandeursen tudelft.nl delft university of technology delft the netherlandsannibale panichella a.panichella tudelft.nl delft university of technology delft the netherlands abstract writing a test case reproducing a reported software crash is a commonpracticetoidentifytherootcauseofananomalyinthesoftwareundertest.however thistaskisusuallylabor intensiveand time taking.hence evolutionaryintelligenceapproacheshavebeen successfully applied to assist developers during debugging by generating a test case reproducing reported crashes.
these approaches use a single fitness function called crash distance to guide the searchprocesstowardreproducingatargetcrash.despitethereported achievements these approaches do not always successfully reproducesomecrashesduetoalackoftestdiversity premature convergence .inthisstudy weintroduceanewapproach called mo ho thataddressesthisissueviamulti objectivization.inparticular weintroducetwonewhelper objectivesforcrashreproduction namely testlength tominimize and methodsequencediversity to maximize in addition to crash distance .
we assessed mohousingfivemulti objectiveevolutionaryalgorithms nsga ii spea2 pesa ii moea d femo on non trivial crashes stemmingfromopen sourceprojects.ourresultsindicatethatspea2 isthebest performingmulti objectivealgorithmfor mo ho.w e evaluatedthisbest performingalgorithmfor mo hoagainstthe state of the art single objectiveapproach single objectivesearch and decomposition based multi objectivization approach de mo .
our results show that mo horeproduces five crashes that cannot be reproduced by the current state of the art.
besides mo hoimproves the effectiveness and in reproduction ratio and theefficiencyin34.
and36 ofcrashes i.e.
significantlylower running time compared to single objective search and de mo respectively.
for some crashes the improvements are very large beingupto .
forreproductionratioand fortherequired running time.
ase september virtual event australia copyright held by the owner author s .
acm isbn .
concepts softwareanditsengineering softwaretestinganddebugging search based software engineering.
keywords crash reproduction search based software testing multi objective evolutionary algorithms acm reference format pouria derakhshanfar xavier devroey andy zaidman arie van deursen and annibalepanichella.
.
goodthings come inthrees improving search basedcrashreproductionwithhelperobjectives.in 35thieee acm international conference on automated software engineering ase september virtual event australia.
acm new york ny usa pages.
introduction when a software application crashes a report or issue including informationgatheredduringthecrash isassignedtodevelopersfor debugging .
one common practice to identify the root cause of acrashistoprovideatestcasethatreproducesit .thistestcase can later be adapted and integrated into the test suite to prevent futureregressions.however thistestcaseisnotalwaysavailable inthecrashreports.also dependingontheamountofinformation available in the report writing this crash reproducing test case can be time consuming and labor intensive .
consequently various approaches have been proposed in the literaturetoautomate crashreproduction .
these approaches use the information about a crash e.g.
stack tracesfromcrashreports togenerateacrashreproducingtestcasebyutilizingdifferenttechniquessuchassymbolicexecution model checking etc.among these approaches two evolutionary based techniqueshavebeenintroduced recore andevocrash .
these two approaches generate test cases able when executed toreproducethetargetcrashusingsingle objectiveevolutionary algorithms.theempiricalevaluationof evocrash showsthat it outperforms other evolutionary based and non evolutionarybasedapproachesintermsof crashreproductionratio percentage ofcrashesthatcouldbereproduced and efficiency timetakento reproduceagivencrashsuccessfully .thisevaluationalsoconfirms that evocrash significantly helps developers during debugging.
evocrashreliesonasingle objectiveevolutionaryalgorithm single objective search hereafter that evolves test cases according 35th ieee acm international conference on automated software engineering ase this work is licensed under a creative commons attribution international .
license.
toanobjective crashdistance hereafter measuringhowfaragenerated test is from reproducing the crash.
crash distance combines threeheuristics linecoverage howfaristhetestfromexecuting theline causingthe crash?
exceptioncoverage doesthe testthrow thesameexceptionasinthecrash?
and stacktracesimilarity how similar is the exception stack trace from the one reported in the crash?
.althoughsingle objectivesearchperformswellcompared totheothercrashreproductionapproaches amoreextensiveempirical study evidenced that it is not successful in reproducing complex crashes i.e.
large stack traces .
hence further studies to enhance the guidance of the search process are required.
justlikeanyotherevolutionary basedalgorithm single objectivesearch requirestomaintain abalancebetween exploration and exploitation .
the former refers to the generation of completely new solutions i.e.
test cases executing new paths in the code the latter refers to the generation of solutions in the neighborhood of the existing ones i.e.
test cases with similar execution paths .
single objectivesearchensuresexploitationthroughguidedmutation which guarantees that each solution contains the method call causingthecrash andreportedinthestacktrace .however thelowexplorationof single objectivesearchmayleadtoalack of diversity trapping the search in local optima .
to tackle this problem a prior study investigated the usage ofdecomposition based multi objectivization de mo to decomposethecrashdistance inthree distinct sub objectives.atarget crashisreproducedwhenthesearchprocessfullfilsallthreesubobjectivesatthesametime.theempiricalevaluationshowsthat de moslightly improves the efficiency for some crashes.
however sincethesub objectivesarenotconflicting theircombinedusage can be detrimental for crash reproduction .
a recent study alsoconjecturedthatincreasingdiversityviaadditionalobjectiveis a feasible yet unexplored research direction to follow.
however no systematicempiricalstudyhas been conductedtodrawstatistical conclusions.
in this study we investigate a new strategy to multi objectivize crashreproductionbasedonhelper objectives mo ho rather thandecomposition.morespecifically weaddtwoadditionalhelperobjectives to crash distance first objective method sequence diversity secondobjective and testcaselengthminimization third objective .thesecondobjectiveaimstoincreasethediversityin themethodsequences morediversesequencesaremorelikelyto coverdiversepathsand consequently improveexploration.thethird objective aims to address the bloating effect i.e.
the generated test cases can become longer and longer after each generation until the all of the system memory is used as diversity can lead to an unnecessary and counter productive increase of the test case length .sincethesethreeobjectivesare conflicting weexpect animprovementinthesolutions diversityand hence improving the effectiveness crash reproduction ratio and efficiency.
to assess the performance of mo hoon crash reproduction we use five multi objective evolutionary algorithms moeas nsgaii spea2 moea d pesa ii and femo .
we apply them to non trivial crashes from jcrashpack a crash benchmark used by previous crash reproduction studies .
those crashes can only be reproduced by a test case that brings the software under test to a specific state and invokes the target method with one or more specific input parameters.
we performed0 java.lang.ar rayindexoutofboundsexception at .fastdateparser.toarray fastdateparser.java at .fastdateparser.getdisplaynames at .fastdateparser textstrategy.addregex at .fastdateparser.init at .fastdateparser.
init figure lang 9b crash stack trace an internal assessment among mo hoalgorithms to find the best multi objective evolutionaryalgorithm forthis optimizationproblem.accordingtotheresultsobservedinthisassessment spea2 outperforms other moeas in crash reproduction using mo ho helper objectives.
furthermore wecomparedthebest performing mo ho mo ho spea2 againsttwostate of the artapproaches single objective search andde mo from the perspectives of crash reproduction ratio andefficiency.
our results show that mo ho outperforms the state of the art in terms of crash reproduction ratioandefficiency.thisalgorithmimprovesthecrashreproduction ratio by up to and .
and on average compared tosingle objectivesearchand de mo respectively.also afterfive minutes of search mo horeproduces five and six crashes and more crashes that cannot be reproduced by single objectivesearchand de mo respectively.inaddition mo horeproduces crashessignificantlyfasterthansingle objectivesearchand de mo in .
and .
of the crashes respectively.
a replication package enabling the full replication of our evaluation and data analysis of our results is available on zenodo .
background and related work several approaches have been introduced in the literature that aim to reproduce a given crash.
some of these techniques e.g.
recore useruntimedata i.e.
coredumps .howev er collectingthe runtime data may induce a significant overhead and raises privacy concerns.incontrast otherapproaches onlyrequirethe stacktraces oftheunhandledexceptioncausingthecrash collected from executions logs or reported issues.
for java programs a stack traceincludesthelistofclasses methods andcodelinenumbers involved in the crash.
as an example figure shows a stack trace producedbyacrash duetoabug inapachecommonslang.this stack trace contains the type of the exception arrayindexoutofboundsexception andframes lines indicating the stack of active method calls during the crash.
amongthevariousapproachessolelyusingastacktraceasinput star and bugredux use backward and forward symbolic execution respectively mucrash mutates the existing test cases of the classes involved in the stack trace jcharming applies model checking and program slicing for crash reproduc tion and concrash is designed to use pruning strategies to reproduce the crash reproducing test case.
evocrash is an evolutionary based approach that applies a single objective genetic algorithm single objective search to generateacrash reproducingtestcaseforagivenstacktraceand atarget frame i.e.
the class under test for which the test case is generated .
the generated test will trigger a crash with a stack 212trace that is identical to the original one up to the target frame.
forinstance forthestacktraceinfigure1withatargetframeat line evocrash generates a test case that reproduces the first threeframesofthisstacktrace i.e.
identicalfromlines0to3 .a previous empirical evaluation shows that evocrash performs bettercomparedtoothercrashreproductionapproachesrelyingon modelcheckingandprogramslicing backwardsymbolic execution or exploiting existing test cases .
the study also confirmsthatautomaticallygeneratedcrash reproducingtestcases help developers to reduce their debugging effort.
.
single objective search heuristics to evaluate the candidate tests and consequently guide the search process single objectivesearchappliesafitnessfunctioncalledthe crashdistance .thisfitnessfunctioncontainsthreecomponents i theline coverage distance indicating the distance between the execution trace and the target line the line number pointed to by the target frame ii the exceptiontype coverage indicating whether the target exception is thrown and iii the stack trace similarity indicating whetherall frames fromthe beginningup to the target frame are included in the triggered stack trace.
definition .
crashdistance .foragiventestcaseexecutiont thecrash distance f is defined as follows f t ds t max de max dtr if line not reached min ds de t max dtr if line reached min ds min de dtr t if exception thrown whereds t indicateshowfarthetest tisfromreaching thetargetline usingtwoheuristics approachlevel andbranchdistance .theformermeasurestheminimumnumberofcontrol dependenciesbetweentheexecutionpathof tandthetargetline thelatterindicateshowfar tisfromsatisfyingthebranchcondition on which the target line is control dependent.
and de t indicateswhetheranexceptionwiththesametypeasthetargetexceptionisthrown ornot .finally dtr t calculatesthe similarity between the stack trace produced by tand the expected one basedonclasses methods andlinenumbersappearinginboth stack traces.
functions max .
andmin .
denote the maximum and minimum possible values for a function respectively.
concretely de t anddtr t areonlycalculateduponthesatisfaction oftwoconstraints exceptiontypecoverage andstacktracesimilarity are relevant only when we reach the target line first constraint and when we have the same type of exception second constraint respectively.
.
single objective search the search process starts with a guided initialization during which an initial population of randomly generated test cases is created.
the algorithm ensures that each test case calls the targetmethod pointedtobythetargetframe atleastonce.ineach generation the fittest test cases are evolved by applying guided mutation andguided crossover .
guided mutation applies a classicalmutationtothetestcaseswhileensuringthatthemutatedtest containsoneormorecallstothetargetmethod.similarly guided crossoverisavariantofthesingle pointcrossoverthatpreservescalls to the target methods in the offsprings.
accordingly each generatedtestcasecontainsatleastonecalltothetargetmethod i.e.
the method triggering the crash .
with thoseoperators single objectivesearch improvesthe exploitation but it penalizes exploration of new areas of the search spacebynotgeneratingdiverseenoughtestcases.asaconsequence the search process may get stuck in local optima.
.
decomposition based multi objectivization toincreasediversityduringthesearch apriorstudy investigatedtheusageof decomposition basedmulti objectivization called de mohereafter to decompose the crash distance in three distinct sub objectives.
de moonthecrashdistance temporarily decomposes the function in three distinct sub objectives ds t de t anddtr t .
then de mouses a multi objective evolutionary algorithm optimizing three objectives to generate one crash reproducing solution.
in the end the global optimal solution is a testcaseintheparetofrontproducedbymoeasthatsatisfiesallof the sub objectives simultaneously.
the empirical evaluation shows thatde moincreases the efficiency of the crash reproduction processforsomespecificcasescomparedtosingle objectivesearch.
however it loses efficiency in some other cases.
inparticular in multi objectivization searchobjectivesshould be conflicting to increase the diversity of generated solutions .
however thethreesub objectivesin de mo aretightlycoupled and not conflicting the stack trace similarity dtr t cannot be computedfortestcase twithoutexecutingthetargetline ds t and throwing the correct type of exception de t .
also the typeofexception de t isnotrelevant whiletest tdoesnotcover the statement in the target line ds t .
.
multi objectivization with helper objectives mo ho decomposingthe crashdistance leadstoasetofdependentsubobjectives whichreducestheeffectofimprovingdiversitythrough multi objectivization .
in this study we focus on using new helper objectives in addition to the crash distance rather than decomposing it.
we define two helper objectives called method sequence diversity andtest length minimization that aim to i increase diversity in the population i.e.
generated tests and ii address the bloatingeffect .
then we use five different evolutionaryalgorithmsbelongingtodifferentcategoriesofmoeas e.g.
decomposition based and rank based to solve this optimizationproblem.intheremainderofthissection wefirstdiscussthe twohelper objectives.next wepresentthemoeasused tosolve this problem.
.
helper objectives assuggestedbyjensen etal.
addinghelper objectivestoan existing single objective can help search algorithms escape from local optima.
however this requires that the helper objectives are in conflict with the primary one .
therefore defining proper helper objectives is crucial.
methodsequencediversity.
thefirsthelper objectiveseeks tomaximizethediversityofthemethod callsequencesthatcompose the generated tests because more diverse tests might execute 213differentpathsorbehaviorsofthe targetclass.noticethateachtest case is a sequence of statements where each statement belongs to oneofthefollowingfivedifferentcategories primitive statements constructors fieldstatements methodcalls orassignments.
furthermore the length of a test case is variable i.e.
it is not fixed a priori and can vary during the search.
inrecent years severalfunctions havebeenintroduced tomeasure test case diversity .
these functions measure the diversity between two test cases by using a binary encoding function to calculate the distance between the corresponding encoded vectors using the levenshtein distance hamming distance etc.
for three or more test cases the overall diversity corresponds to the average pairwise diversity of the existing test cases .
these metricshavebeenusedinothertestingtasks e.g.
automatedtest selection but not in crash reproduction.
to measure the value of this helper objective for the generated solutions we follow a similar procedure.
let us assume that f f1 f2 ..fn isasetofpublicandprotectedmethodsinthetarget class i.e.
method calls that can be called directly by the generated tests and t t1 t2 ..tm is a set of generated test cases.
to calculate the diversity of t we first need to encode each tk t into a binary vector.
we use the same encoding function proposed by mondal et al.
each test case tk tcorresponds to a binary vectorvkof length n i.e.
the number of public and protected methodsinthetargetclass .eachelement vk ofthebinaryvector denotes whether the corresponding method fi fis invoked by the test case tk.
more formally for each method fi f the corresponding entry vk 1i ftkcallsfi vk otherwise.
then we calculate the diversity for each pair of test cases tk andtias the hamming distance between the corresponding binary vectorsvkandvi .thehammingdistance hamming between twovectorscorrespondstothenumberofmismatches1overthetotallengthofthebinaryvectors.forinstance thehammingdistance betweena angbracketleft1 angbracketrightandb angbracketleft0 angbracketrightequals to .
.
definition .
methodsequencediversity .givenanencoding functionv .
the method sequence diversity msd of a test t t corresponds to the average hamming distance of that test from the other test cases in t msd t summationtext ti t t hammin v t v ti t in our approach msdshould be maximized to increase the chanceofthegeneratedtesttoexecutenewpathsorbehaviorsin thetargetclass.sinceourtool seesection4.
isdesignedforminimizationproblems weminimizethemethodsequencesimilarity using the formula fmsd t msd t testlengthminimization whileincreasingmethodsequence diversity can help to execute diverse paths of the target class a previousstudy alsoshowedthat testdiversitymetrics suchas call sequence diversity can reduce coverage.
this is due to the bloating effect i.e.
diversity will also promote larger test cases over short ones.
let us assume that we have a set of short test cases withfewmethodcallsinourpopulation mostoftheelementsin theirbinaryvectorsare0 .alengthytestcase tlthatcallsallthe 1the number of positions at which the corresponding bits are different.methods of the target class will have a binary vector containing only values.
as a consequence tlwill have a large hamming distance from the existing test cases.
larger tests introduce two potential issues i they are likely more expensive to run extra overhead and ii they may contain spurious statements that do not help code coverage which is apart ofcrash distance .
in the latter case mutation can become less effective as it may mutate spurious statements rather than therelevantpartofthechromosomes.therefore testdiversityis in conflict with crash distance .
to avoid the bloatingeffect our secondhelper objectiveis testlengthminimization whichcounts the number of statements in a given test definition3.
testlengthminimization .foratestcase twitha length t the fitness function is flen t t .
multi objective evolutionary algorithms inthisstudy ourgoalistosolveamulti objectivizedproblemby minimizing the three objective functions crash distance fmsd andflen .
in theory we could consider various moeas each coming with different advantages and disadvantages over different optimization problems e.g.
multimodal convex etc.
.
however wecannotestablishupfrontwhattypeofmoeaworksbetterfor crash reproduction as the shape of the pareto front i.e.
type of problem for crash reproduction is unknown.
hence we chose five moeasfromdifferentcategoriestodeterminethebestalgorithm formo ho nsga iiusesthenon dominatedsortingprocedure spea2is an archive based algorithm that selects the best solutions according to the fitness value pesa iidivides the objective space tohyper boxesandselectsthesolutionsfromthehyper boxeswith thelowerdensity moea d decomposestheproblemtomultiple sub problems and femo is a evolutionary algorithm that evolves tests solely with mutation and without crossover.
weusethesamestoppingconditionsforallsearchalgorithms which is a maximum search budget or when the target crash is successfully reproduced i.e.
a solution with a crash distance of .
is found.
also to increase exploitation during the search all algorithms use the guided crossover andguided mutation operators.
in the following subsections we briefly describe the selected search algorithms and their core characteristics.
.
.
non dominated sorting genetic algorithm ii nsga ii .
in nsga ii offspring tests are generated from given a population of sizen usinggenetic operators crossover andmutation .
next nsga iiunionstheoffspringpopulationwiththeparentpopulation intoasetofsize2 nandappliesa non dominatedsorting toselect thenindividualsforthenextgeneration.thissortingisperformed basedonthe dominance relationand crowdingdistance thesolutions aresortedintosubsequentdominancefronts.thenon dominated solutions are in the first front front0 .
these solutions have a higher chance of being selected.
furthermore crowding distance is used to raise the chance of the most diverse solutions within the samefronttobeselectedforthenextgeneration.ineachgeneration parent test cases are selected for reproduction using the binary tournament selection.
.
.
strength pareto evolutionary algorithm spea2 .besidesthecurrentpopulation spea2containsanexternalarchive thatcollectsthenon dominatedsolutionsamongallofthesolutions consideredduringthesearchprocess.spea2assignsa fitnessvalue to each solution test in the archive.
the fitness value of solution i is calculated by summing up two values raw fitness r i n0 which represents the dominance relation of i andstrength value s i which estimates the density of solutions in the same pareto front solutions that are not dominating each other .
a solution with lower fitness value is better and has a higher chance of beingselected.forinstance thenon dominatedsolutionshavea r i and their fitness values are lower than .
the external archive has a fixed size which is given at the beginningofthesearchprocess.afterupdatingthearchiveineach iteration thealgorithmchecksifthesizeofthearchiveexceedsthis givensize.ifthesizeofthearchiveissmallerthanthegivensize spea2fillsthe archivewiththeexisting dominated solutions.in contrast if the size of the archive is bigger than the given size this algorithm uses a truncation operator to remove the solutions with a highfitness value from the archive.
after updating the archive spea2 applies binary tournament selection based on the calculated fitnessvalues selectsparentsolutions andgeneratesoffspringsolutions via crossover andmutation.
.
.
pareto envelop based selection algorithm pesa ii .similar to spea2 pesa ii benefits from an external archive.
in each generation thearchiveisupdatedbystoringthenon dominated solutionsinthearchiveandthecurrentpopulation.however the difference is in the selection strategy and archive truncation.
inthis algorithm instead of assigning a fitness value to each of thesolutions in the archive the objective space is divided based onthe existing solutions into hyper boxes or grids.
non dominated solutionsinahyper boxwithlowerdensityhaveahigherchance of being selected and a lower chance of being removed.
.
.
multi objective evolutionary algorithm based on decomposition moea d .this algorithm decomposes the m objectives problem into ksingle objective sub problems and optimizes them simultaneously.
each sub problem has different weights for the optimizationobjectives.the ksub problems x w1 ... x wk are obtained using a scalarization function x w and a set of uniformly distributed weight vectors w w1 ... wk .
the decomposition can be done with several techniques such as weighted sum tchebycheff orboundaryintersection .ineach generation moea dmaintainsthebestindividualsforeachsub problem x wi whilethereproduction basedoncrossoverand mutation is allowed only among solutions tests within the same neighbourhood mating restriction .
.
.
fair evolutionary multi objective optimizer femo .
this algorithm is a local evolutionary algorithm.
it means that in each iteration only one solution is evolved by the mutation operatortohaveonlyoneoffspringsolutionforthenextgeneration.
femo contains an archive.
in the first iteration it generates a randomsolutionandplacesitinthearchive.inthenextgenerations itselectsoneindividualfromthearchiveandevolvesitbymutation operator to generate a new solution.
finally if the new solutiondominates at least one of the solutions in the archive it adds the new solution to the archive and removes the dominated solutions.
each solution inthe archive has a weight w that indicatesthe number of times that a solution was selected from the archive.
so the initial weight of a newly generated test case is .
during the selection femo selects a solution randomly from the solutions in the archive that have the lowest w. empirical evaluation to assess the impact of mo hoon crash reproduction we performed an empirical evaluation and answered the following research questions.
rq1 which multi objective algorithm performs better with moho s search objectives in terms of crash reproduction?
rq2 what is the impact of the mo ho algortihm on crash reproduction compared to single objective search and de mo?
rq3 howdoesmo ho sefficiencycomparetosingle objective search and de mo?
.
implementation sinceothercrashreproductionapproachesarenotopenlyavailable weimplementedanewopen sourceevolutionary basedcrashreproductionframework calledbotsing.2botsingiswell testedand designedtobeeasilyextensiblefornewtechniques newevolutionary algorithms newgenetic operators etc.
.
it relieson evosuite anevolutionary basedunittestgenerationtool forcodeinstrumentationand forthe internalrepresentation ofan individual i.e.
a test case by using evosuite client as a dependency.
for this study we implemented the techniques used in previous studies for crash reproduction single objective search and demo in botsing.
moreover we implemented all of the mo ho approaches which include the two fitness functions for our newhelper objectives method sequence diversity andtest length and the five moeas mentioned above.
.
setup crash selection.
weselected ourcrashesfrom jcrashpack a collection of crashes from open source projects and created forcrashreproductionbenchmarking.basedonthereportedresults of the prior studies about search based crash reproduction we know that single objective search and de moface various challengestoreproducemanyofthecrashesinthisbenchmark.for thisstudy weapplyourapproachandstate of the artalgorithms to crashes from jcrashpack which are used in the recentsearch based crash reproduction study .
these crashes stem fromsixopen sourceprojects jfreechart aframeworkforbuildinginteractivecharts commons lang alibraryprovidingextrautilities to the java.lang api commons math a library for mathematical andstatisticalusages mockito atestingframeworkformocking objects joda time alibraryfordateandtimemanipulation xwiki a large scale enterprise wiki management system.
algorithmselection.
weattemptedtoreproducetheselected crashesusingsevenevolutionaryalgorithms single objectivesear ch de mo andmo howithfivemoeas nsga ii spea2 pesa ii moea d and femo .
for each crash we ran each algorithm on 2available at 215each frame of crash stack traces.
we repeated each execution timestotakerandomnessintoaccount foratotalnumberof199 independent executions.
we ran the evaluation on servers with cpu cores gb memory and tb hard drive.
evaluationprocedure.
inrq1 weperformaninternalassessment ofmo hoby comparing all moeas to determine the bestperforming one when optimizing the search objectives in mo ho.
then toanswerrq 2andrq3 weusethebest performing mo ho configuration moea toevaluateitseffectivenessandefficiency against the state of the art crash reproduction approaches.
parameter settings.
we set the search budget to five minutes assuggestedbypreviousstudiesonevolutionary basedcrashreproduction .also wefixedthepopulationsizeandarchivesize ifneeded to50individuals asrecommendedinpriorstudieson test case generation .
formo howith pesa ii the number of bisectionsforgriddingissettothedefaultvalueoffivegrids.in mohowith moea d the weight vectors are obtained using a variant simplex lattice design and using the tchebycheff approach as the aggregation function.
finally we set the neighborhood selection probability to0.
settothedefaultvalue andthemaximum numberof solutionsthatcanbereplaced ineachgenerationto50.
forallmoeas weusethe guidedmutation withmutationprobabilitypm n nis the length of the test case and guided crossover with crossover probability pc .
the same parameters used for the suggested baselines .
.
data analysis to evaluate the crash reproduction ratio i.e.
the percentage of successful crash reproduction attempts in rounds of runs of different algorithms we follow the same procedure as the previous studies foreachcrash c wefindthehighestframethatcan bereproducedbyatleastoneofthealgorithms rmax .weanalyze the crash reproduction ratio of each algorithm for a target crash c targeting frame rmax.
tocheckwhethertheperformance reproductionratio ofmoeas significantly differs from one another we use the friedmantest .
the friedman test is a non parametric version of the anovatest i.e.
itdoesnotmakeanyassumptionaboutthe data distribution.
it is a multiple problem statistical test and hasbeen widely used in the literature to compare randomized algo rithms .
friedman s test allows to rank and statistically comparedifferentmoeasovermultipleindependentproblems i.e.
crashes in our case.
for friedman s test we use a level of signifi cance .
.ifthe p valuesobtainedfromfriedman stestare significant p values .
we apply pairwise multiple comparison using conover s post hoc procedure .
to correct for multiplecomparisonerrors weadjustthe p valuesfromconover s procedure using holm bonferroni .
to answer rq2 we need to determine whether an algorithm reproduces a crash.
since we repeat each execution times weuse the majority of outcomes for a crash reproduction result.
in other words if an algorithm could reproduce a crash in runs i.e.
reproductionratioof wecountthatframeas reproduced.
tocomparethenumberofreproducedcrashesbyeachalgorithm we used the same procedure used by almasi et al.
and campos etal.
wecheckcrashreproductionstatusandreproductionratiotable1 moeasranking in mo ho intermsofcrashreproduction ratio friedman s test and results of the pairwisecomparison p value .
rank moea rank value significantly better than spea2 .
pesa ii .
nsga ii .
moead .
femo .
of the best performing mo hoalgorithm according to the results ofrq1 single objective search and de moat five time intervals and minute.
to evaluatethe efficiencyof thealgorithms rq3 weanalyze thetimespentbythebest mo hoalgorithm single objectivesearch andde mofor generating a crash reproducing test cases.
since efficiencyisonlyapplicabletothereproducedcrashes wecompare the efficiency of algorithms on the crashes that are reproducedat least once by one of the algorithms.
if for one execution analgorithm was not able to reproduce the crash it means that it consumedthemaximumallowedtimebudget 5minutes .toassesstheeffectsizeofdifferencesbetweenalgorithms weusethevargha delaney 12statistic .avalueof .5forapairoffactors a b showsthat areproducedthetargetcrashinashortertime whileavalueof .5indicatestheopposite.besides .
means thatthere isno differencebetween thefactors.
toevaluate the significance of effect sizes we use the non parametric wilcoxon rank sum test with .
for the type i error.
areplicationpackageofourevaluationisavailableonzenodo .itcontainstheselectedcrashes theresultsanddataanalysis presentedinthispaper aswellastheimplementationofmoeas in botsing and a docker based infrastructure to enable the fullreplication of our evaluation.
results this section presents the results of our empirical evaluation and answers one by one our research questions.
.
best moea for mo ho rq1 figure2presentsthecrashreproductionratioofthemoeasappliedtoourmo hoframework.forthisanalysis weconsiderthenumber of times in percentage each moeas could reproduce a given crash across runs and using a search budget of five minutes.
on average the squares in figure the best algorithm for mo hois spea2 with an average and median of and of successful reproductions respectively.
spea2isfollowedby pesa ii nsga ii andmoead.
also this figure shows that the first quartile of the crashreproductionratioof spea2is atleast about25 higherthan other moeas.
according to friedman s test the differences in reproduction ratios are statistically significant p value .
.
this means that somemoeasaresignificantlybetterthanotherswithinour mohoframework.
for completeness table reports the ranking producedbythefriedmantest.tobetterunderstandforwhichpairs .
.
.
.
.
femo moea d nsga ii pesa ii spea2 algorithmsreproduction ratio percent figure crash reproduction ratio out of executions of mo hoalgorithms.
the upper and lower edge of each box present the upper and lower quartile respectively.
square de notes the arithmetic mean and is the median.
of moeas the statistical significance holds we applied the posthoc conover s procedure for the pairwise comparison.
the results ofthecomparisonarealsoreportedintable1.accordingtothistable the best performing algorithm is mo ho spea2 which has a significantly higher crash reproduction ratio compared to othermo hoalgorithms.the nextalgorithmsare mo ho pesaiiandmo ho nsga ii.thesetwoalgorithmsaresignificantly better than mo ho moeadandmo ho femo.
finally the worst algorithmin termsof crashreproduction is femo whichis significantly worse than other moeas.
summary rq .mo ho spea2 achieved the highest performance in terms of crash reproduction ratio compared to mo ho other moeas.
the next best performing moeas in terms of crash reproduction are pesa ii and nsga ii.
.
crash reproduction rq2 figure3depictsthecrashreproductionratioofthebest performing mo hoconfiguration i.e.
with spea2 single objectivesearch andde moat five time intervals search budgets .
as indicated in this figure the average crash reproduction ratio of mo hois higherthanotheralgorithmsatallofthetimeintervals.also the median crash reproduction ratio for this algorithm is always .
furthermore themaximumimprovementachievedby mo howith thefive minutessearchbudgetisin xwiki with100 improvement and math 3b with .
improvement compared to single objective search and de mo respectively.
in contrast the largest reduction in reproduction ratio by mo ho with the five minutesbudget isin xcommons with30 drop and xwiki with40 reduction comparedtosingle objective searchand de mo respectively.we willexplainthe negativefactors inmo ho which lead to negative results for this algorithm in some corner cases in section .
.
moreover wecan seethat de mois thesecond bestalgorithm in all of the time intervals.
in the first seconds of the crash reproductionprocess onaverage itscrashreproductionratiois4 better than single objective search.
however in contrast to the othertwoalgorithms thecrashreproductionratioofthisalgorithmchangesonlyslightlyafterthefirst120seconds.hence attheendof the search process the average crash reproduction ratio of de mois only better than single objective search.
in contrast since the crash reproduction ratio of mo hokeeps growing on average it remains more effective than single objective search about even after seconds.
the other interesting point in figure isthe first quantile of mo ho.
in the first seconds this value is lower than but it grows up to after seconds.
this improvement is not observable in state of the art algorithms.
furthermore mo hois more stable in crash reproduction after seconds budget compared to the other algorithms.
figure 3demonstrates that the interquartile range i.e.
the difference betweenfirstandthirdquartile ofcrashreproductionratioin mo ho withthe300secondsbudgetis46 smallerthantheinterquartile rangeofotheralgorithms being38.
for mo ho .
.forsingleobjective search and .
for de mo .
also figure shows the number of crashes which are reproduced by mo ho but not by the state of the art algorithms and vice versa in different time intervals.
as indicated in this figure in all of the time intervals the number of crashes that are reproduced bymo hoishigherthanthecrashesthatitcannotreproduce.in thebestcase after1minuteofsearch mo horeproduceseight and seven new crashes that cannot be reproduced by single ob jectivesearchand de mo respectively.incontrast thereisonly one crash that can be reproduced by de moand not by mo ho.
also afterfiveminutes mo hostillreproducesmorecrashesthan thebaselines itreproducesfiveandsixnewcrashes thatcannotbe reproduced by single objective search and de mo respectively.
thecrashesthatarereproducedby mo hoafterfiveminutesbut not by single objective search are time 10b frame xcommons928frame xwiki frame xwiki frame and xwiki frame1.andthecrashesthatarereproducedby mohoafterfiveminutesbutnotby de moare mockito 16b frame time 5bframe xwiki frame xwiki frame math 3b frame and mockito 10b frame .
figure shows the crash s stack trace reported in the issue xwiki .mo hois the only approach that can reproduce the first two frames of this stack trace.
here the target methodis usemainstore figure6 whichdoesnothaveanyinputargument.
hence to reproduce this crash the crash reproducing test generated by mo ho depicted in figure should invoke specific methods e.g.
setwiki setwikiid to set different local variables inthe xwikicontext0 object andthen passthisobjecttotheclass undertest here activitystreamconfiguration .sincethecrash reproducingtestcasegeneratedby mo hodoesnotaddanyplugin to the xwiki0object the execution of this test indeed leads to anullpointerexception thrown at line of the getplugin method in figure .
generating such a specific test case requires a searchprocesswithhighexplorationability whichcangenerate diverse test cases.
we do note that single objective search cannot even generate a test case covering the target line line of the usemainstore method .
however de mocan cover the target line thanks to moretestgenerationdiversitydeliveredbytheapplicationofmultiobjectivization.
moreover single objectivesearchand de moreproducestwo crashes that cannot be reproduced by mo hoafter five minutes.
we will analyze these corner cases later in section .
.
seconds budget seconds budget seconds budget seconds budget seconds budget de mo mo ho single de mo mo ho single de mo mo ho single de mo mo ho single de mo mo ho single0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
algorithmsreproduction ratio percent figure3 crashreproductionratio outof30executions of mo hoagainststate of the artinfivedifferenttimeintervals.
square denotes the arithmetic mean and is the median.
time budget seconds of crashesmoho.reproduces less more than de mo single objective figure number of reproduced crashes only by mo hoor only by one of the state of the art algorithms.
java.lang.nu llpointerexception null at .xwiki .getplugin xwiki.java at .activitystreamconf iguration.usemainstore figure xwiki crash s stack trace .
82public boolean usemainstore xwikicontext context contextprovider.get if context.ismainwiki return false activitystreamplugin plugin activitystreamplugin context.getwiki .
getplugin context target line figure6 method usemainstore appearsinthesecondframe of the xwiki crash s stack trace.
in addition after five minutes of crash reproduction de mo reproduced six crashes which are not reproduced by single objective search.
still there are more crashes seven that can bereproduced by single objective search but not by de mo.
this5617public xwikiplugininterface getplugin xwikipluginmanager pl ugins getpluginmanager vector st ring p luginlist plu gins.getplugins figure7 method getplugin appearsinthefirstframeofthe xwiki crash s stack trace.
1public void test0 throws throwable activitystreamconfiguration ac0 new activitystreamconfiguration xwikicontext x wikicontext0 newxwikicontext xwiki xwiki0 newxwiki xwikicontext0.se twiki xwiki0 xwikicontext0.se twikiid yrlfi .u ib provider xwikicontext prov ider0 provider xwikicontext mock doreturn xwikicontext0 .when prov ider0 .get injector.
inject ac0 contextprovider object provider0 undeclared excep tion!
ac0.usemainstore figure crash reproducing test case generated by mo ho for the xwiki crash.
resultshowsthatdespitethenewcrashesreproducedby de mo this algorithm was counter productive with respect to the total number of reproduced crashes.
summary rq .on average mo ho has the highest crash reproduction ratio independently from the search budgets.
.
efficiency rq3 figure9showsthetime inseconds neededbythe mo hoandthe state of the art algorithms to successfully reproduce the crashes in our benchmark.
on average the fastest algorithm is mo ho with de mo mo ho single algorithmscomsumed time seconds figure9 overallbudgetconsumptioninseconds log.scale .
square denotes the arithmetic mean and is the median.
table pairwise comparison of the budget consumption with a small s medium m and large l effect size 12 .5and a statistical significance .
.
12 .
single de mo mo ho lms lms lms single de mo 32mo ho an average search time of seconds per crash replication.
the medianofitsrunningtimeislowerthan10seconds.thesecondfastest algorithm is de mothat on average uses seconds to reproducethecrashes.theslowestalgorithmissingle objective search which demands on average about seconds.
moreover the biggest improvements achieved by mo hoin terms of efficiency are for xwiki in which mo horequires only of the time required by single objective search to achieve crash reproduction and math 3b in which mo horequires only of the time required by de moto finish the crash reproduction task.howeve r thebiggestefficiencylossesby mo hoareinmath81bwith seconds drop of time budget and xrendering481with145secondsdrop oftimebudget comparedtosingleobjective search and de mo respectively.
table2comparesthebudgetconsumptionofthealgorithmsfrom astatisticalpointofview i.e.
accordingtotheeffectsizes 12 .
and statistical significance p value .
.
according to this table mo hoisthefastestalgorithm itsignificantlyreproduced .
ofcrashes and47 .
ofcrashes crashesfasterthan single objective search and de mo respectively.
most of these significant improvements have large effect sizes against singleobjective search and against de mo .
in cases that mo ho improves efficiency on average this algorithmdecreases the time requiredforcrashreproductionby47 and58 comparedto de mo and single objective search respectively.
furthermore table shows a few cases in which mo hoincreases the consumed time compared to the state of the art 3againstsingle objectivesearchand5against de mo.inmostof these cases out of the crash reproduction process needs to reproduce acrash with onlyone frame.even the exceptionalcase is a stack trace with three frames.
in contrast in cases that mo ho wins we have many crashes with more frames six frames for0 java.lang.ar rayindexoutofboundsexception at org.apache.commons.math.linear.bigmatriximpl.operate bigmatriximpl.
java figure math 98b crash s stack trace .
991public bigdecimal operate bigdecimal v final int nrows this.getrowdimension final int ncols this.getcolumndimension finalbigdecimal out newbigdecimal for introw row nrows row .
.
.
out sum target line .
.
.
figure method operate appears in the first frame of the math 98b crash s stack trace .
instance .
also this table shows that de mois significantly slower than single objective search in crashes.
meanwhile mo hois only slow in reproducing three crashes.
hence our proposed algorithm reducesthe cases in whichthe multi objectivization search process is slower than the single objective search by .
summary rq .the fastest crash reproduction algorithm is mo ho with an average improvement in running time in .
of the crashes compared to the state of the art.
.
corner cases analysis despitethenotableimprovementsachievedby mo ho thereare few specific cases in which single objective search or de mo outperform mo ho.
for instance in section .
single objective search and de moreproduce two crashes that are not reproduced bymo ho.
also we observedin section5.
thatthe efficiencyof these two algorithms is higher than mo hoin crashes.
tounderstandwhy mo hoiscounter productiveinafewcases we performed a manual analysis to analyze the factors in mohothat negatively impact the crash reproduction process.
results of our analysis point to two adverse factors extra overhead in calculating the objectives fitness evaluation andhelperobjectives misguidance.
extracalculationinfitnessevaluation.
insomecases crash reproduction is trivial and the search process reproduces it in a few seconds.
for instance in time 8b single objective searchand de moreproducethecrashinaboutasecond.thetime required by mo hoto reproduce this crash is three seconds timesmore .thisstemsfromthefactthatfitnessfunctionevaluationinmo hoismoretime consumingthanthestate of the art single objectivesearchand de moneedtocalculateonlythecrash distanceforeachtestcaseevaluation while mo honeedstocalculate the call diversity as well.
this extra calculation lengthens the search process by a couple of seconds.
in these cases the increasedcrashreproductiontimeislowerthan5seconds anditisnegligible in practice.
helper objectivesmisguidance.
insomeothercases thescenario which leads to crash reproduction needs a simple sequence 219of methods calls to the target class.
still the complexity of this scenariostemsfromtheinputargumentsusedforthemethodcalls.
inthesecases sincecrashreproductiondoesnotneedthecalldiversity methodsequencediversity objectivemisguidesthesearch process.
alternatively we need another objective for method input argumentdiversity i.e.
improvesthediversityoftheinputarguments for method calls .
adding new helper objectives to consider other aspects of diversity is part of our future agenda.
as an example let us analyze math 98b figure in which mo ho doubled the time consumed by the crash reproduction search process against state of the art.
this crash concerns an arrayindexoutofboundsexception .also thiscrashhasonlyone frame.
for reproducing this crash the generated test case needsto instantiate a class called bigmatriximpl and call a method named operate figure with precise input values.
method getcolumndimension usedin operatereturnsthenumberofrows inthedatavariable whichhasbeensetintheconstructor.tore produce this crash the generated test case should pass an array withasizesmallerthanthepassedsizetotheconstructor.inthis case methodargumentdiversitycouldhelpthesearchprocess and the method call diversity is not helpful.
discussion .
effectiveness and applicability generally de moreproducessomecrashesthatcannotbereproducedbysingle objectivesearchduetoitsimprovedexploration ability resulting from the multi objectivization of the crash distance.
however since the decomposed objectives in this approach dependononeanother e.g.
thestacktracesimilarityisnothelpful ifthegeneratedtestdoesnotthrowthegiventypeofexception theymaymisguidethesearchprocessinvariouscases.forinstance as we saw in section .
single objective search reproduces six crashes that are not reproducible by de mo.
incontrast mo hohasthree conflicting searchobjectives.from the theory the objective function must be conflicting to increasetheoverallexplorationability.ourresultsconfirmthetheory thechanceofthesearchprocessgettingtrappedinalocaloptimum is lower by using mo hoobjectives compared to the ones used inde mo.
as we observed in section .
after minute of search mo horeproduces and crashes more than single objective search and de mo respectively.
also it continues outperforming with larger search budgets and minutes until the end of the search process.
it reproduces and crashes more than single objectivesearchand de mo respectively whileitcannot reproduce only two crashes reproduced by the other algorithms.
note that reproducing each crash needs a particular test case whichdrivesthesoftwareundertesttoaparticularstate andthen it callsamethodwithproperinputvariables.toachievethisgoal eachcrashreproducingtestcaseneedstocreatemultiplecomplexobjects.hence reproducingfivenewcrashes ofcrashesavailableinour benchmark is a significant improvement for mo ho.
.
factors in the benchmark crashes that impact the success of mo ho there are multiple factors characteristics of the crashes in our benchmark that might impact the performance of our approachpositively.weidentifythefollowingrelevantfactors thetype of the exception e.g.
null pointer exception the size the stack frames the number of classes involved in the crashes thenumber of methods of the deepest class in the crash stack.
to verify whether these factors influence the performance of our algorithm weusedthetwo waypermutationtest .thepermutation test is a well established non parametric to assess the significance offactorinteractionsinmulti factorialanalysisofvariance nonparametric anova .
we usea significancelevel alpha .
anda verylargenumberofiterations toensurethestability of the results over multiple executions of the procedure .
for the sake of our analysis we considered the difference in crashreproductionratebetween mo hoandthebaselinesasthe dependent variable while the co factors are our independent variables.
according to the permutation test the type of exception pvalue .
and the number of crash stack frames p value .
significantlyimpacttheperformanceof mo hocomparedtosingle objectivesearch.wecanalsoobservesimilarresultswhenconsider ingtheimprovementsof mo hoagainstde mo p values for both exception type and the number of frames .
in other words therearecertaintypesofexceptionsandstacktracesizesforwhich mo hois statistically better than the state of the art approaches.
fromadeeperanalysis weobservethatfor nullpointerexcep tionandorg.joda.time.illegalfieldvalueexception mo ho achieves a higher reproduction ratio than single objective search when the stack traces contain up to three frames for npe in reproductionrate anduptofiveframesfor illegalfieldvalueex ception in reproduction rate .
instead for stack traces with more frames the differences in reproduction ratio are negligible on average or negative in reproduction ratio .
besides mo hoachieves better reproduction ratios for the following exceptions independently of the stack size xwikiexceptions on average unsupportedoperationexception on average mathruntimeexception on average .
finally mo hooutperforms de mowhenreproducing nullpoin terexception with1 3frames onaverage classcastexcep tion onaverage stringoutofboundsexception with more than frames on average illegalfieldexception on average unsupportedoperationexception on average mockitoexception forshorttraces onaverage and missingmethodinvocation on average .
.
crash reproduction cost inthisstudy weobservedthatsince mo hoincreasesthediversity ofthegeneratedtestcases itcandramaticallyimprovetheefficiency ofcrashreproduction.thisalgorithmsignificantlyimprovedthe speed of the sear ch process in more than of crashes compared tosingle objectivesearchand de mo.incasesinwhich mo ho had a significant impact it improves the crash repr oduction speed by more than .
the prior studies on search based crash reproduction suggested5minutesasthesearchbudgetbecausethesearchprocesscannotreproducemoreafter5minutes.however weobservedthatdespitethehighefficiencyof mo ho thisalgorithmcontinues to reproduce more crashes in the second half of the time budget.
220section .
shows that mo hokeeps increasing the crash reproduction ratio even in the last minutes of the search process while the previous multi objectivization approach de mo changes only slightlyafterthefirst2minutesofcrashreproduction.hence increasingthesearchbudgetfor mo hocanleadtoahighercrash reproduction ratio.
.
extendability theimprovementachievedbytheproposedhelper objectivesshows the impact of suitable objectives on increasing the diversity of the generated test cases and result in improving the effectiveness and efficiency of the crash reproduction search process.
hence wehypothesize that this approach can be extended by adding new relevant helper objectives.
threats to validity internalvalidity.
wecannotensurethatourimplementationof botsingiswithoutbugs.however wemitigatedthisthreatbytest ingourtoolandmanuallyanalyzingsomesamplesoftheresults.weusedapreviouslydefinedbenchmarkforcrashreproduction which contains non trivial crashes from six open source projects and applications.
moreover we explained how we parametrized the evolutionary algorithms in section .
.
we used the default values of these algorithms in the other open source implementations like evosuite and jmetal.
the effect of these values for crash reproduction is part of our future work.
finally to take the randomness ofthesearchprocessintoaccount wefollowedtheguidelinesof the related literature and executed each evolutionary crash reproduction algorithm for times.
external validity.
we report our results for only crashes introduced by jcrashpack which is an open source crash reproductionbenchmarkcollectedfromsixopen sourceprojects.
however we recall here that we cannot guarantee that our results are generalizable to all crashes.
evaluation mo hoon a larger benchmark from more projects is part of our future work.
reproducibility.
weprovidebotsingasanopen sourcepubliclyavailabletool.also thedataandtheprocessingscriptsused to present the results of this paper including the subjects of our evaluation inputs the evolution of the best fitness function value ineach generationof eachexecution and theproducedtest cases outputs are openly available as a docker image .
conclusion and future work crash reproduction can ease the process of debugging for devel opers.
evolutionary approaches have been successfully used to automate this process.
existing evolutionary based approaches use one single objective i.e.
crash distance to guide the search and rely on guided genetic operators.
later strategies applied multiobjectivizationviadecomposition de mo inanattempttoimprove diversity and therefore e xploration .
ho wever the latter strategy may misguide the search process because the sub objectives are not strongly conflicting.
inthisstudy weapplyanewapproachcalledmulti objectivization using helper objectives mo ho to tackle the problems of the formertechniques.in mo ho multi objectivizationisperformedby adding two helper objectives that are in conflict with crash distance.we evaluated mo howithfive moeas which areselected from different categories of multi objective algorithms.
our results indicatethat mo hoisthemostefficientalgorithm significantly outperforming single objective search and de mo.
also this algorithm is able to reproduce and more crashes in and minutes respectively comparedtothestate of the art.moreover incontrasttothepreviousmulti objectivizedcrashreproductionapproach de mo the crash reproduction ability of mo hoincreases with large search budgets i.e.
above two minutes .
weperformedanadditionalanalysistofindthecorrelationbetweenthedifferentaspectsofthecrashesandtheabilityof mo ho in reproducing them.
the result of this analysis shows that two factors in crashes significantly impact the performance of mo ho i type of exception and ii the number of crash stack frames.
furthermore we observed that single objective search and democouldoutperform mo hobutonlyinafewcases.weperformed amanualanalysistocharacterizethenegativefactorsleadingtotheadverseresultsinthesecases.ouranalysisrevealsthattwonegative factors are at play in these cases i extra calculations in fitness evaluation and ii helper objectives misguidance.
we also showed insection5.4thatwhilethedifferencesin extracalculationsinfitness evaluation are significant they are often negligible in practice.
the contributions of the paper are as follows anopen sourceimplementationofsevencrashreproduction techniques section .
.
an empirical comparison of seven search based crash reproduction approaches section .
an analysis of the benefits of multi objectivization withhelper objectives in terms of reproduction ratio and efficiency section .
the identification of the special situations in which mo ho can be counter productive section .
.
theidentificationofastrongcorrelationbetweentheability ofmo hoinimprovingtheefficiencyandeffectivenessof crash reproduction for combinations of exception types and thenumberofframesinthestacktraceofthetargetcrash section .
.
in our future work we will investigate additional helper objectivesforcrashreproduction.forinstance thecurrenthelper objectivesinmo hoconcernthetestlengthandmethodsequencediversity.
however furtherobjectivescanbeadded suchastestinput data diversity.
increasing the number of objectives will require to evaluate their performance using different many objective evolutionary algorithms.
we will also analyze the evolution of the fitness values of existing and new objective to further investigate the root causes of goodand badperformances of mo hoand otherobjectives for different crashes and different moeas.
moreover thesearchobjectivesintroducedby de moisonlyoptimizedby nsga iimoea.asfuturework wewillinvestigatethe impactofutilizingothermoeasforoptimizing de moobjectives.