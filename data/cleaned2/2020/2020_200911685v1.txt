on the relationship between refactoring actions and bugs a differentiated replication massimiliano di penta dipenta unisannio.it university of sannio benevento italygabriele bavota gabriele.bavota usi.ch universit della svizzera italiana lugano switzerlandfiorella zampetti fiorella.zampetti unisannio.it university of sannio benevento italy abstract software refactoring aims at improving code quality while preserving the system s external behavior.
although in principle refactoring is a behavior preserving activity a study presented by bavota et al.in reported the proneness of some refactoring actions e.g.
pull up method to induce faults.
the study was performed by mining refactoring activities and bugs from three systems.
taking profit of the advances made in the mining software repositories field e.g.
better tools to detect refactoring actions at commit level granularity we present a differentiated replication of the work by bavota et al.
in which we i overcome some of the weaknesses that affect their experimental design ii answer the same research questions of the original study on a much larger dataset vs103 systems and iii complement the quantitative analysis of the relationship between refactoring and bugs with a qualitative manual inspection of commits aimed at verifying the extent to which refactoring actions trigger bug fixing activities.
the results of our quantitative analysis confirm the findings of the replicated study while the qualitative analysis partially demystifies the role played by refactoring actions in the bug introduction.
ccs concepts software and its engineering software reliability designing software .
keywords refactoring bug introduction mining software repositories1 introduction software refactoring has been extensively studied by the research community through empirical studies investigating how and why developers perform refactoring how refactoring relates with other development tasks e.g.
merge conflicts with software quality indicators e.g.
quality metrics and with developers productivity .
some studies e.g.
kim et al.
indicated that often developers are concerned about performing refactoring activities as it may cause the introduction of bugs.
the relationship between refactoring and bugs has been the subject of several studies that analyzed software repositories to understand the extent to which refactoring activities introduce bugs .
wei gerber and diehl studied the correlation between refactoring activities and bug reports opened in the subsequent days finding no strong correlation.
however their study did not link refactoring activities in a specific file with bug fixes performed on that same file.
in a previous work some of the authors1 presented a study overcoming this limitation showing that refactoring actions involving hierarchies e.g.
push down method induce bug fixing commits more frequently than other refactoring types.
they used the reffinder tool to create a dataset of manually validated refactoring actions detected comparing subsequent releases in total of three java systems.
by comparing releases bavota et al.
assumed that a specific refactoring was performed on a file fj between releases riandri 1of a given system while the exact refactoring related commit was unknown.
then by mining the change history of the three systems the authors identified bugfixing commits by linking commit messages and issue tracker data using a keyword based approach e.g.
fixed issue id where id was the id of an issue on the issue tracker of the mined system .
finally for each bug fixing commit they identified its fix inducing commits using the szz algorithm .
using such data bavota et al.assumed that a refactoring action performed on file fjbetween riandri 1induced a fix if a bug inducing commit cidentified by the szz was performed on fjbetween riandri .
thus there is a strong assumption made in the experimental design since the refactoring actions were captured between releases it is not possible to know whether the refactoring was actually implemented in the bug inducing commit c. also some refactoring actions may not be detected because of the large differences that may occur between two releases.
this together with the small size three projects are the main limitations of this study.
1in the following we refer previous work as bavota et al.
because the set of authors only partially overlaps.arxiv .11685v1 sep 2020di penta et al.
more recently ferreira et al.
reported preliminary results of a mining based study performed on five systems and overcoming the main design issue of the work by bavota et al.
.
ferreira et al.
mined both refactoring actions and bug inducing changes at commit level looking for how close the refactoring actions were to bug inducing changes.
they confirmed the relationship between refactoring actions and bugs showing however that many bugs are not the direct consequence of the refactoring action but of changes implemented later on the refactored code.
by using a tool chain similar to the one adopted by ferreira et al.
we present a differentiated replication of the study by bavota et al.
.
we overcome several limitations of that study by taking profit of the recent advances made in the mining software repositories field .
this reflects in i better refactoring miner tools able to precisely identify refactoring actions at commit level granularity thus avoiding the assumption made in the original study done at release level ii enhanced implementations of the szz algorithm overcoming some of the limitations of the original algorithm iii a line level linking between refactoring actions and bug fixing activities as compared to the file level linking done in previous studies .
considering the possible impact of the size confounding factor on the achieved results .
while the original study indicated a relationship between specific refactoring actions and the introduction of bugs the authors ignored the possible impact of the size confounding factor on this finding e.g.
refactoring is usually performed in larger commits and larger commits are more likely to introduce bugs .
complementing the quantitative analysis with a systematic qualitative evaluation .
we manually analyze a statistically significant sample of commits identified as fix inducing refactoring actions i.e.
those that induced a bug fixing activity to study whether the performed refactoring actions actually induced the bug fix.
this analysis provides more confidence in the reported quantitative findings.
answering the same research questions presented in but on a larger scale .
we answer the research questions presented in both on the same three systems used in the original study as well as on a set of open source java projects.
this increases the generalizability of the findings.
despite the different experimental design adopted our quantitative analysis confirms most of the findings of the original study.
however we also unveil the significant role played by the size confounding factor in inducing bug fixing activities.
also our qualitative analysis shows that while the szz can identify the commit implementing the refactoring s as the last one modifying the code then subject to bug fixing activities in many cases the bug was already in the system before the refactoring even happened.
the obtained results trigger further research in the area of automated refactoring but also warns developers about possible risks associated with refactoring activities if the latter are not accompanied by suitable verification validation.
paper structure.
section describes the study design.
results are discussed in section while their threats to validity in section .
after a discussion of related work section section concludes the paper.
study design thegoal of the study is to perform a differentiated replication of the work by bavota et al.
in which the authors investigated the extent to which refactoring actions trigger bug fixing activities.
thecontext is represented by the history of java projects and in particular by the refactoring operations and bug fixes performed by their developers.
we address the following research questions rqs rq 1are refactoring related commits more likely to induce fixes than other commits?
this rq mirrors the rq 1from the original work of bavota et al.
.
they answered this rq by mining refactoring actions and fix inducing changes performed between subsequent releases of three systems.
using this data bavota et al.
investigated whether refactoring operations are likely to induce bug fixes.
however as also acknowledged the strong unverified assumption behind the study is that there is an overlap between the fix inducing commits and the commits that implemented the refactoring actions.
instead of performing our replication at release level we use a commit level granularity.
this means that we know the exact commits in which refactoring operations have been performed in a specific file fjand as a consequence we can check whether those commits induced a fix or not.
we also improved other aspects on top of the original experimental design.
finally while we answer rq 1by using the same three systems adopted in the original study we also answer rq 1in a large scale study involving open source projects.
rq 2to what extent is the relationship between refactoring actions and fix induced changes influenced by the effect of size?
bavota et al.
did not consider the size of the code change as a possible confounding factor in their analysis.
however it is wellknown that large commits i.e.
commits impacting a large number of files lines code churns have a higher probability of inducing a bug .
it is possible that commits implementing refactoring operations are more likely to induce bug fixes simply because they are larger than commits implementing other types of changes e.g.
bug fixes enhancements .
rq 2aims at investigating the role played by the commit size co factor in the relationship between refactoring actions and fix inducing changes.
rq 3what kinds of refactoring types are more likely to induce fixes?
rq3mirrors the rq 2of the original study and analyzes the likelihood that different types of refactoring e.g.
extract class pull up method trigger bug fixing activities.
rq 4to what extent does refactoring actually trigger bugfixing activities?
rq 4is a qualitative analysis we perform on a sample of the fix inducing commits we identified in our quantitative study as responsible for both i implementing a refactoring and ii inducing a bug fixing activity.
in other words these should be the commits where there is a cause effect relationship between refactoring and bug introduction.
.
context selection we answer our research questions by mining the change history of projects.
three of them namely apache ant argouml and apache xerces j are the java projects used in the replicated study while the remaining were selected from github through the following procedure.on the relationship between refactoring actions and bugs a differentiated replication our initial idea was to mine popular and large projects from github excluding forked projects coding tutorials and personal projects as well as projects having less than issues and commits to ensure the availability of a long change history to study.
also we decided to ignore projects having less than of their code written in java since the refactoring detector used in our study only works with java.
finally since in our study it is of crucial importance to identify bug fixing commits we also wanted to exclude repositories not using a clear label for bugs and those not consistently referencing in commit notes the id s of the issue s closed by the commit.
concerning the first point i.e.
label for bugs in github every project can define its own set of labels to tag the opened issues thus indicating bugs feature requests etc.as for the second point having an explicit link between commits and bugs allows to precisely identify the bug fixing commits needed for our study.
to this aim we used the github api to extract the list of projects having at least issues and java as their first language .
the latter criterion means that java is the most used language in the project but does not guarantee that the vast majority of the code is written in java.
since the github api returns at most results per search we generated several requests each having a specific size range.
we used the size min..max argument to retrieve only projects within a specific size range.
in this way we increased the number of returned results to up n where nis the number of considered size ranges.
note that while such a search heuristic does not allow to identify all possible github projects having at least issues and java as their primary language this is not important for the sake of our study.
here the goal was to just collect a set of candidate projects that then we can manually validate to decide which ones to include in our study.
we collected projects and two of the authors inspected them to check the selection criteria previously mentioned.
after analyzing the first projects by sorting them in descending order of stars it became clear that most of these projects were not suitable for our study.
in particular out of these we found only projects to match all our selection criteria.
then upon further inspection other problems were found also for most of these projects.
some of them while having defined an explicit label for bugs had very few labeled issues in the issue tracker.
for others while in the manual inspection of the change log we observed commits linked to closed issues the number of these links turned out to be very low even in projects having a very high number of commits and issues.
this likely indicated the non consistent adoption of a linking methodology between issues and commits.
for these reasons we decided to adopt a different process for project selection.
however before describing it we want to stress the challenges and perils of automatically selecting projects from github.
indeed while we applied some strong selection criteria on the number of issues at least and sorted projects based on their popularity as indicated by the number of stars the most popular projects in our dataset had 67k stars we obtained as result many tutorial like projects e.g.
snailclimb javaguide repositories collecting quiz for job interviews e.g.
kdn251 interviews or as previously said repositories making a very limited use of methodologies to link commits and issues and or to consistently label issues.
we believe this is an important warning for our researchcommunity when dealing with large scale studies in which project selection is not manually curated.
we decided to focus on projects managed by the apache software foundation asf because these are well used projects managed by a known open source foundation.
also a large chunk of these projects consistently used through their entire change history a single bug tracking system namely jira .
the issues are always classified based on their types e.g.
bug and as a best practice the apache projects reference the issue id s in the note of commits closing issues.
we used the github api to extract the list of github projects managed by the asf.
then we filtered out projects not having at least of their code written in java obtaining a list of candidate projects.
finally we sorted them by the number of forks as a proxy for popularity and two of the authors manually inspected this list from the top with the goal of selecting projects to use for the study.
the selection was done based on two criteria the project used the jira issue tracker for its entire change history the project was not a subproject representing a component of a bigger project e.g.
we excluded fineract cn portfolio .
if these two criteria were met the authors annotated the name of the projects from the apache jira installation that were referenced in the change log of the repositories i.e.
in the commit notes .
indeed the apache jira installation hosts several projects each one identified by a specific name.
for example the apache hadoop project