memlock memory usage guided fuzzing cheng wen csse shenzhen university shenzhen chinahaijun wang ant financial services group china csse shenzhen university chinayuekang li nanyang technological university singapore shengchao qin scedt teesside university uk csse shenzhen university chinayang liu nanyang technological university singaporezhiwu xu csse shenzhen university shenzhen china hongxu chen xiaofei xie nanyang technological university singaporegeguang pu east china normal university shanghai chinating liu xi an jiaotong university xi an china abstract uncontrolled memory consumption is a kind of critical software security weaknesses.
it can also become a security critical vulnerability when attackers can take control of the input to consume a large amount of memory and launch a denial of service attack.
however detecting such vulnerability is challenging as the stateof the art fuzzing techniques focus on the code coverage but not memory consumption.
to this end we propose a memory usage guided fuzzing technique named memlock to generate the excessive memory consumption inputs and trigger uncontrolled memory consumption bugs.
the fuzzing process is guided with memory consumption information so that our approach is general and does not require any domain knowledge.
we perform a thorough evaluation for memlock on widely used real world programs.
our experiment results show that memlock substantially outperforms the state of the art fuzzing techniques including afl aflfast perffuzz fairfuzz angora and qsym in discovering memory consumption bugs.
during the experiments we discovered many previously unknown memory consumption bugs and received new cves.
ccs concepts security and privacy software security engineering.
keywords fuzz testing software vulnerability memory consumption acm reference format cheng wen haijun wang yuekang li shengchao qin yang liu zhiwu xu hongxu chen xiaofei xie geguang pu and ting liu.
.
memlock memory usage guided fuzzing.
in 42nd international conference on software corresponding authors shengchao qin and haijun wang permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .. .
.
icse may seoul republic of korea.
acm new york ny usa pages.
introduction time and space complexities are two main concerns in software design and development.
if they are not implemented well unexpected behaviors and even troublesome security issues can happen.
in real world programs lots of such security vulnerabilities have been found e.g.
.
for example if the termination conditions of recursive functions are not implemented correctly an infinite number of recursive function calls can occur and thus render the stack memory exhausted.
the adversaries can exploit this vulnerability to launch a denial of service dos attack with some well crafted inputs .
recently researchers have started to pay attention to these issues.
for example slowfuzz perffuzz and rescue are developed to generate pathological inputs to stress the time complexity issues i.e.
algorithmic complexity vulnerabilities .
however it still leaves untouched for automatically generating pathological inputs to stress space complexity issues namely memory consumption bugs thus far.
although a number of works e.g.
the popular fuzzing techniques have devoted to detecting memory issues they mostly focus on memory corruption vulnerabilities such as buffer overflow and use after free.
memory corruption occurs in a program when the contents of the memory are modified due to some unexpected program behavior that exceeds the original intention of the program .
when the corrupted memory contents are used later by the program it may lead to unexpected behaviors e.g.
program crash .
however memory consumption bugs are essentially different from memory corruption vulnerabilities.
as defined by cwe the software does not properly control the allocation and maintenance of a limited resource thereby enabling an actor to influence the amount of resources consumed eventually leading to the exhaustion of available resources.
to make it explicit this paper focuses on three types of memory consumption bugs uncontrolled recursion uncontrolled memory allocation andmemory leak .
uncontrolled recursion may exhaust stack memory when the program does not properly control the amount of recursion that takes place.
uncontrolled memory allocation refers to the situation whereby the program allocates memory based on an untrusted size value but it does not validate or incorrectly validates ieee acm 42nd international conference on software engineering icse 1struct demangle component 2cplus demangle type struct d info di peek is a single character extracted from the input directly 5char peek d peek char di 7switch peek ... 9case p ret d make comp di demangle component pointer cplus demangle type di null break 14case c ... ... figure code snippet from cp demangle.c inbinutils v2.
1class exiv2api databuf 2public constructor with an initial buffer size explicit databuf long size pdata new byte size size ... byte pdata pointer to the buffer size t size the current size of the buffer 10void jp2image readmetadata while io read byte subbox sizeof subbox sizeof subbox subbox.length arrowhookleft subbox.length getlong byte subbox.length bigendian databuf data subbox.length allocation without checking ... io seek position sizeof box box.length basicio beg figure code snippet from jp2image.cpp inexiv2 v0.
the size allowing arbitrary amounts of memory to be consumed.
moreover if the software does not track and release allocated memory after it has been used it causes a memory leak.
existing detection techniques for memory consumption bugs usually use domain or implementation specific heuristics or rules .
for example radmin learns and executes multiple probabilistic finite automata and then confines the resource usage of target programs to the learned automata and detects resource usage anomalies at their early stages.
thus their effectiveness heavily depends on the completeness of heuristics and rules.
to create and maintain such rules requires substantial manual efforts and expertise.
in this paper we employ the greybox fuzzing technique to develop an automated and general technique to detect memory consumption bugs.
grey box fuzzing is one of the most effective techniques to find vulnerabilities which typically adopts the coverage information as guidance to explore different program paths.
however existing grey box fuzzing techniques are not designed for detecting memory consumption bugs because such bugs often depend not only on the program path but also on some interesting program states in that path i.e.
amount of memory consumption .
for example the real world program in figure allocates the memory at line however this memory allocation may fail if no additional memory can be allocated for use.
to detect this bug the grey box fuzzer needs to execute a program path that touches line as well as a large value for variable size to exceed the available heap memory.
existing coverage based fuzzing techniques can easily cover line but it may be difficult to produce test cases that have a large value for variable size.
to address the aforementioned challenges we present memlock to enhance grey box fuzzing to find memory consumption bugs.
memlock works in two steps.
firstly memlock performs the static analysis which identifies the statements and operations relevant to memory consumption.
we would qualitatively analyze the call graph which determines the stack memory usage and quantitatively analyze memory usage operations which determines the heap memory usage.
besides we also analyze the control flow graph of the program which provides branch coverage for guiding to explore different program paths.
with the memory consumption analyzed memlock then employs branch coverage as well as memory consumption information to guide the fuzzing process.
the branch coverage information guides to explore different program paths and the memory consumption information guides the program path to consume more and more memory.
if an input covers new branch compared to previous inputs it is considered as interesting and added into the seed queue.
besides although an input has no new branch coverage if it leads to more memory consumption we also retain it as an interesting input through a novel seed updating scheme.
this input can be further mutated so that the newly generated input leads to more memory consumption.
after some mutations memlock is expected to generate an input whereby the memory consumption exceeds the available memory.
we have evaluated memlock s effectiveness using a set of realworld open source programs.
the experiment results show that memlock substantially outperforms six state of the art tools i.e.
afl aflfast perffuzz fairfuzz angora and qsym in discovering the memory consumption vulnerabilities.
memlock finds .
more unique crashes and .
more vulnerabilities than the second best counterpart.
in particular memlock can discover a certain memory consumption vulnerability at least .
times faster than the other baseline fuzzers.
besides the generated test cases in memlock usually lead to times memory consumption compared to the other state of the art tools.
in addition we have responsibly disclosed several previously unknown memory consumption bugs and received new cve1for them demonstrating memlock s effectiveness in practice.
in summary this paper makes the following contributions we present memlock the first to the best of our knowledge dedicated fuzzing technique to automatically discover memory consumption bugs without requiring any domain knowledge.
we design a new dimension of guidance engine to deeply exploit the memory consumption in a program path which is complementary to the coverage guidance.
we have implemented and evaluated memlock on various widelyused real world programs.
the experimental results have shown that memlock substantially outperforms five state of the art fuzzing techniques in discovering memory consumption bugs.
1the common vulnerabilities and exposures cve system provides a reference for tracking publicly known information security vulnerabilities and exposures.
we have discovered security critical memory consumption vulnerabilities in widely used real world programs and most of these vulnerabilities have been patched by the developers.
overview .
motivating examples we first illustrate the limitations of existing coverage based greybox fuzzing techniques for detecting memory consumption bugs with two examples summarized from real world vulnerabilities.
we use the vulnerability cve in figure to demonstrate an uncontrolled recursion bug and cve in figure to demonstrate an uncontrolled memory allocation bug.
in figure the function cplus demangle type recursively calls itself in line when the input contains the character p .
the depth of recursion depends on the number of character p s in the input.
with a sufficiently large recursive depth the execution would run out of stack memory causing stack overflow.
to trigger a stack overflow the fuzzer would need to generate inputs containing a large number of character p s. however existing coverage based grey box fuzzers do not have enough awareness about the change in recursive depth and solely use coverage information to retain interesting inputs.
take afl as an example it is aware of repeatedly executed cfg edges but only in a coarse manner.
to be specific afl adopts the concept of loop bucket to retain interesting inputs see section .
.
the loop bucket cannot tell the fine grained change in recursive depth.
specially it does not differentiate the change when the recursive depth is greater than .
nevertheless this number is still very far from causing stack exhaustion which normally requires tens of thousands of recursive depth.
therefore to expose uncontrolled recursion effectively grey box fuzzers need to have precise awareness about the stack memory consumption of the target program when executing an input.
figure demonstrates an uncontrolled memory allocation problem in exiv2.
at line when the program parses a subbox in readmetadata a length is extracted from the user inputs.
then the length is fed directly into databuf at line .
finally this value is used as the size of a memory allocation request at line .
note that the program does not check the size before allocating memory.
by carefully handcrafting the input an adversary can provide arbitrarily large values for subbox.length leading to program crash i.e.
std bad alloc or running out of memory.
to trigger this problem the fuzzer would need to generate inputs with a large subbox.length .
for this purpose the fuzzer needs to collect information about the value of subbox.length to retain the interesting inputs that can incur a large memory consumption.
however existing coverage based grey box fuzzers lack awareness about the value of subbox.length .
therefore they cannot effectively generate inputs causing subbox.length to become larger.
take afl as an example let us assume afl now holds a seed input awhich incurs the subbox.length of and causes the function to enter the while at line and eventually return at line .
after some mutations afl may generate another input bwhich incurs the subbox.length of and also causes the function to enter the while at line and return at line .
we can source codestatic analysiscontrol flow graph call graph memory usage operationsinstrumentationinstrumented program initial seedsseed poolseed selector selected seed seed mutator test inputs executor feedback collectorbranch coverage memory consumptionseed updaterproof of crashesstatic analysis fuzzing loopfigure the overview of the proposed approach grey rectangles denote the new features of memlock.
clearly see that comparing with a bconsumes much more memory and is closer to running out of memory.
however afl will discard input band will not retain it as a seed because bdoes not bring new branch coverage.
consequently afl cannot detect this uncontrolled memory allocation problem effectively.
therefore to expose uncontrolled memory allocation effectively grey box fuzzers also need to have precise awareness about the amount of consumed heap memory of the target program when executing an input.
.
approach overview figure shows the workflow of memlock which contains two main components static analysis andfuzzing loop.
in particular the static analysis takes the program source code as the input and generates three kinds of information see section .
control flow graph call graph and memory usage operations.
the static analysis inmemlock helps to decide where to instrument andwhat to instrument.
the control flow graph information is used to collect the branch coverage the call graph information aids to instrument the function call entries and returns.
based on the memory usage operation statements memlock instruments the locations of memory allocation and free operations.
once the program is instrumented memlock enters the continuous fuzzing loop to detect memory consumption bugs see section .
.
given the initial seeds memlock selects a seed sfrom the seed pool.
as for the seed s memlock generates the new inputs test cases using different mutation strategies.
memlock then runs the generated inputs against the instrumented program and collects their memory consumption information see section .
.
and branch coverage information.
if the generated seeds consume more memory or have new branch coverage they are retained as interesting seeds.
memlock adds them into the seed pool through a seed updating scheme see section .
.
.
memlock repeats this process until reaching time or resource budget limits.
example in figure .
we illustrate memlock using the example in figure .
suppose the initial value of peek obtained from function parameter diby function d peek char at line is a .
this value is general unbiased for any special case.
through the coverage guidance memlock generates a new input i1that may produce the 767value p for peek as it covers the different branch.
when i1is further mutated it generates i2 which may produce four consecutive p s forpeek i.e.
pppp in its recursion.
since i2has different branch hits in the sense of loop bucket from i1 it is added into the seed pool.
when i2is selected for mutation it generates i3that may produce five consecutive p s for peek i.e.
ppppp in its recursion.
the coverage guidance uses the concept of loop bucket and considers that i3does not offer new branch coverage compared toi1andi2.
in this case existing coverage based grey box fuzzers would discard i3 and thus miss the chance to generate an input that can produce more consecutive p s. on the other hand memlock introduces memory consumption as the guidance under which i3is considered to cause more memory consumption than i1ori2 .
thus it retains i3as an interesting test case and adds it into the seed pool.
it can further mutate i3 and generate inputs that may produce more consecutive p s. after some mutations memlock may generate an input that would produce a sufficiently large number of consecutive p s i.e.
ppp.
.. to run out the stack memory.
example in figure .
for illustration let us assume that the available heap memory is bytes.
suppose the initial value of subbox.length is100 which is produced from user input at lines .
at line in figure the memory is allocated successfully and the program executes the true branch of the while statement at line .
based on the coverage guidance memlock performs the mutation and can generate a new input i1that produces a larger value for subbox.length .
in this case we assume the value is .
the input i1still executes the true branch of the while statement and thus there is no new branch coverage.
at this time the coverage based grey box fuzzers would discard i1 therefore missing the chance to generate an input consuming more memory.
on the other hand memlock s memory consumption guidance considers that i1consumes more memory i.e.
and keeps it as an interesting input.
when i1is further mutated memlock can generate an input e.g.
len that consumes more memory.
after some mutations memlock can generate an input e.g.
len that runs out of memory.
note that we have not elaborated memory leaks separately asmemlock deals with them in the same way as uncontrolledmemory allocation using the same memory usage guidance during fuzzing.
methodology .
static analysis the static analysis in memlock decides how to instrument the target program.
based on the instrumentation memlock collects the guidance information and then uses it to drive the fuzzing process.
after analyzing the control flow graph memlock instruments the target program to capture branch edge coverage guiding program path explorations.
additionally based on the qualitative and quantitative analysis of call graph andmemory usage operations it also instruments the target program to collect the memory consumption information guiding the fuzzing process towards consuming more memory for each program path.
to facilitate the description of our methodology we define the following concepts.
.
.
control flow graph.
memlock collects branch coverage information in the control flow graph cfg of the program to guide program path explorations as afl .
it inserts instrumentation into every branch of the program cfg assigning a pseudo unique idto every branch.
during program execution the instrumentation uses an bit counter to keep track of the number of times that a branch has been executed.
memlock groups the hit counts of each branch execution into several buckets to denote different magnitudes2.
consequently the branch coverage information in an executed program path can be defined as follows.
definition .
trace bits .for an executed program path its trace bits are represented by an bit array with size 2k and the value of the idthelement is stored in an bit counter in afl k .
the trace bits record the accumulated branches executed in a program path and they can represent a program path roughly.
definition .
path id .
for an executed program path its path id is the hash value of its trace bits see definition .
.
.
.
call graph.
in addition to branch coverage memlock also collects the memory consumption information.
one important construct that may cause a large bulk of stack memory consumption is the recursive function call.
when a function call occurs the program automatically allocates the stack memory for use e.g.
local variables .
on the other hand when a function call is finished returned the program automatically reclaims the allocated stack memory for reuse.
to monitor the stack memory consumption of function calls memlock injects the instrumentation into both the entry and the exit of the function call.
we use ftto denote the length i.e.
consumption of call stack during the program execution.
this value changes with the execution of the program.
when the program execution enters a function the value ftis increased by one likewise when a function call is returned the value ftis decreased by one.
in the following we use fmto denote the peak value of ftduring the program execution.
the value fmthus qualitatively reflect the maximum stack memory consumption by recursive function calls during the program execution.
we do not differentiate the memory consumption caused by different functions because usually the stack memory can be exhausted only under infinite recursive function calls.
thus we only need the peak length of call stack to guide memlock to approach infinite recursive function calls.
.
.
memory usage operations.
memory usage operation statements e.g.
malloc andfree may also contribute to the consumption of a large bulk of memory.
in a program path the memory operation statements may be affected by the program inputs.
when this happens it is possible to guide this program path to consume more memory by controlling the program inputs.
to this end memlock uses instrumentation to quantitatively obtain the size of the memory operation.
due to the lack of freed memory size in deallocation statements memlock maps them to their corresponding allocation statements to obtain the size of the freed memory.
in particular we insert instrumentation into the memory allocation deallocation functions in the standard libraries and obtain 2in afl the hit counts of each branch execution are divided into buckets time times times times times times times and times .
768algorithm memory usage guided fuzzing input an instrumented program p and set of initial seeds t output test cases striggering memory consumption bugs 1s 2queue t 3while time and resource budget do not expire do foreach input tinqueue do ifwith probability fuzzprob tto select tthen numchildren assi nener y t for0 i numchildren do child i mutate t tracebits i fmi omi run child i p k hash tracebits i ifit triggers memory consumption bugs then s s child i else ifnewco v tracebits i then queue queue child i ifnewmax fmi omi then queue update child i fmmap ommap 18return s its parameters and return value.
the reason is that the memory is allocated by some standard library functions e.g.
malloc calloc realloc and new.
on the other hand the program may also free the memory using the standard library function such as free anddelete.
even when the program uses a user customized memory usage operation function it still relies on standard library functions to operate a larger bulk of memory.
thus we do not need to consider the user customized memory usage operations in practice.
we use otto denote the amount of memory consumed by memory operations in a program path.
when the program allocates ot bytes memory the value otis increased by ot likewise if it frees ot bytes memory the value otis decreased by ot .
in the following we use the omto represent the peak value of otduring the program execution.
the value omevaluates the memory consumption in a program path by memory usage operation statements.
by using omas the guidance memlock can mutate the program inputs and gradually increase the peak value of memory consumption in a program path.
.
fuzzing loop algorithm shows the high level procedures of memlock.
the intuition of the algorithm is that for each input tin the seed pool memlock decides whether to mutate it based on a selection probability.
if so memlock mutates tand generates a set of child inputs.
then memlock runs each child input and monitors their executions.
if a child input has new coverage or consumes more memory see definitions .
and .
it is retained as an interesting input.
while this process is similar to the process of traditional coverage based grey box fuzzers e.g.
afl the main difference isthatmemlock additionally adopts memory consumption guidance to retain interesting inputs.
the algorithm takes the instrumented program p see section .
and a set of initial seeds tas the inputs and outputs a set of test cases sthat trigger the memory consumption bugs.
the variable queue represents the seed pool and is initialized as the initial seeds tat line .
memlock first selects an input tfrom the seed pool queue line and computes its probability on whether or not to be mutated at line see section .
.
.
upon deciding to mutate the input t memlock assigns the energy i.e.
numchildren to it at line which determines the number of children to produce from t.memlock uses the same heuristics to determine numchildren as afl .
it produces more children for inputs that have wider code coverage or that are discovered later in the fuzzing process.
at lines memlock mutates the input tto generate numchildren children monitors their executions and determines their affiliations.
memlock first performs mutation to generate the new input child i line .
at line memlock then runs the input child ion the instrumented program p and collects its branch coverage i.e.
tracebits i function memory consumption i.e.
fm and operation memory consumption i.e.
om respectively.
if the input child itriggers memory consumption bugs how to determine memory consumption bugs see section .
it is added into the output s line .
otherwise memlock analyzes its branch coverage and memory consumption line and .
if it has new branch coverage it is added into the queue for the further mutation line .
in addition we further analyze its memory consumption.
memlock checks whether child ileads to more memory consumption based on fmmap andommap at line .
see section .
.
.
if so memlock updates the value of fmmap and ommap using the function update at line see section .
.
.
this process is repeated until the given time or resource budget expires lines .
.
.
guidance mechanisms.
one of the most important components in the grey box fuzzing is its guidance mechanism lines and in algorithm which often dominates the capability of the fuzzing technique in finding bugs .
for example slowfuzz uses the number of executed instructions as guidance to stress algorithmic complexity vulnerabilities.
to find the memory consumption bugs effectively memlock uses branch coverage as well as memory consumption as the guidance.
the branch coverage information guides memlock to explore different program paths while the memory consumption information can drive memlock to focus on program paths with more memory consumption.
to facilitate the description of our memory consumption guidance we define the following concepts.
definition .
maximum function memory .
given a path kand a set iof inputs that all execute k the maximum function memory consumption fmmap inkis the maximum peak value of call stack among all the inputs i fmmap max i ifmi where fmirepresents the peak value of call stack during the execution of input i see section .
.
.
769seed seed seed seed seed seed seed seed seed seed seed seed 5path path path path original seed queue new path larger memory consumptionfigure dynamic seed updating definition .
maximum operation memory .
given a path kand a set iof inputs that all execute k the maximum operation memory consumption ommap inkis the maximum peak value of memory consumption by memory usage operations among all the inputs i ommap max i iomi where omidenotes the peak value of memory consumed by memory usage operations during the execution of input i see section .
.
.
definition .
newcov .
given a set iof inputs and an input t we say thits a new coverage if it either executes a branch that has not been touched by i or hits a branch touched by ibut with a different bucket number.
the function newco v line will check whether a newly generated input child ihits a new coverage with respect the current queue or not.
that is the function newco vconsiders the branch coverage and guides memlock to explore different program paths.
definition .
newmax .
given a set iof inputs and an input t that all execute k we say thits a new maximum memory consumption if either fmt fmmap or om t ommap .
the function newmax line determines whether the input child ileads to the maximum memory consumption among the current seed set.
it actually checks two kinds of memory consumption.
it first determines whether child ileads to the maximum function memory consumption see definition .
.
it also considers whether child ileads to the maximum operation memory consumption see definition .
.
if the input child isatisfies either of the above two cases memlock update the seed queue with child iat line see section .
.
.
.
.
dynamic seed updating.
in order to efficiently support retaining the most interesting input for each path we propose a novel seed updating scheme.
in memlock the seed queue is kept in a linked list where each node represents a seed that explores a program path as shown in fig.
.
memlock updates the seed queue in the following two cases.
new path.
if the test input results in new branch coverage then it will be added to the seed queue as a new node as shown in the second row of fig.
.
larger memory consumption.
if the input e.g.
seed2 in the third row of fig.
generates an input seed5 which does not result in new branch coverage but it leads to larger memory consumption than the corresponding input.
when seed2 andseed5 execute the same path seed2 is replaced with seed5.
with replacing the originalseed with the generated input child i we well exploit the advantage ofchild ias it is better in terms of finding memory consumption bugs.
this seed updating policy ensures memlock to gradually improve increase the overall memory consumption and it could avoid getting stuck in local maxima like slowfuzz and brings long term stable improvements.
to tailor for our guidance mechanism memlock also optimizes the seed selection probability line in algorithm for the mutation as follows.
definition .
favored input .
an input tis favored for mutation if thas new branch coverage i.e.
newcov or tleads to maximum memory consumption i.e.
newmax .
definition .
selection probability .
an input tis selected for mutation with the following probability fuzzprob t 1iftis favored a otherwise that is the favored inputs are always selected and ais the probability of selecting a non favored input.
in our experiments we usea .01like perffuzz .
evaluation we have built a prototype of memlock.
our implementation adds around .6k lines of c c code to the file containing afl s core implementation.
in particular the static analysis and instrumentation components are implemented based on the llvm framework and the fuzzer engine is implemented based on the afl .52b framework .
we have conducted thorough experiments to evaluate memlock with a set of real world programs.
more detailed experimental results can be found on our website .
with these experiments we aim to answer the following research questions rq1.
how capable is memlock in memory consumption crash detection?
rq2.
how capable is memlock in memory consumption realworld vulnerability detection?
rq3.
do the strategies of memlock help to trigger memory leaks with more leakage?
rq4.
do the strategies of memlock help to generate inputs with more memory consumption?
.
experiment setup following the suggestions in we conducted the experiments carefully to draw conclusions as objective as possible.
baseline fuzzers to compare against.
we compare memlock against six state of the art fuzzers namely afl aflfast perffuzz fairfuzz angora and qsym .
the baseline fuzzers are selected based on the following considerations.
afl is the widely used coverage based greybox fuzzer and selected as baseline fuzzer in the most work.
aflfast is an advanced variant of afl specially equipped with a better power schedule .
perffuzz is to stress the time complexity issues in the program while memlock seeks to detect space complexity issues.
fairfuzz leverages a targeted mutation strategy to execute towards rare branches.
further angora utilizes taint analysis to track information flow and then uses gradient descent to 770break through the hard branches.
lastly qsym is a popular symbolic execution assisted fuzzer.
note that we haven t selected memfuzz as baseline fuzzer because memfuzz is not open source and it resorts to memory accesses instead of memory consumption .
in a word we selected various kinds of representative state of the art fuzzers as baseline fuzzers and they are widely used to discover vulnerabilities in practice.
evaluation benchmarks.
we select evaluation benchmarks considering several factors e.g.
popularity frequency of being tested development activeness and functional diversity.
finally we use widely used real world programs which all contain memory consumption bugs to evaluate memlock including well known development tools e.g.
nm cxxfilt readelf code processing tools e.g.
nasm flex yaml cpp mjs graphics processing libraries e.g.
openjpeg jasper exiv2 video processing tools e.g.
bento4 and libming and data processing libraries e.g.
libsass andyara etc.
these programs have also been widely tested by existing state ofthe art greybox fuzzers .
performance metrics.
to compare against state of the art fuzzers the most direct measurement is the capability to find the vulnerabilities.
with this regard we consider both unique bugs and unique crashes each fuzzer finds in the fuzzing process.
since memlock is to stress the space complexity issues of programs we also distill the memory consumption of each seed in the pool.
configuration parameters.
since the fuzzers heavily rely on the random mutation there could be performance jitter during fuzzing process.
we took two actions to mitigate the randomness caused by the nature of fuzzing techniques.
first we test each program for a longer time until the fuzzer reaches a relatively stable state.
we run each fuzzer for hours.
second we perform each experiment for times and evaluate their statistical performance.
besides we run all the fuzzers with the doption to skip the deterministic mutation stage following the configuration of perffuzz .
memory consumption bugs.
the uncontrolled recursion bug usually causes stack overflow thus we can directly use addresssanitizer to detect it.
the uncontrolled memory allocation bug consumes a large amount of memory so that the program runs out of the memory.
thus we can detect it by setting the allocator may return null flag of addresssanitizer.
in addition we use leaksanitizer to detect memory leakage.
experiment infrastructure.
all our experiments have been performed on machines with an intel r xeon r e5 v3 processor .40ghz and 16gb of ram under bit ubuntu lts .
.
.
unique crashes evaluation rq1 to evaluate the effectiveness of fuzzers a direct measurement is the number of unique crashes found by different fuzzers.
it is believed that more unique crashes usually indicate higher chances of covering more unique vulnerabilities.
table shows the number of unique crashes which is caused by memory consumption vulnerabilities found by different fuzzers within hours in the benchmark programs.
it is worth noting we identify unique crashes related to memory consumption bugs by reproducing the crashes and analyzing their crash stacks.
and we discuss other types of crashes in section .
.
out of the groups ofexperiments memlock performs best in .
groups of experiments among different fuzzers as shown in column memlock.
in total memlock finds unique memory consumption crashes in the benchmark programs improving by .
.
.
.
.
and .
respectively compared to state of the art fuzzers afl aflfast perffuzz fairfuzz angora and qsym.
especially memlock is able to find unique crashes in all benchmark programs while other state of the art fuzzers may find no crashes in some benchmark programs.
for example none of the other state ofthe art fuzzers could find any unique crashes in the program flex butmemlock was able to find unique crashes within hours.
to better compare different fuzzers we also use the plots to depict the performance over time in some benchmark programs as shown in figure .
it shows that memlock has a steady and strong growth trend in finding unique crashes and memlock is also the first fuzzer that reported crashes.
following klees recommendation we also conduct the statistic test for the results.
the a12 statistic measures the probability that one fuzzer in this case memlock outperforms another fuzzer.
the value of a12means by what chance the result of memlock is better than the competitor as shown in columns with the heading a12.
further we apply the mann whitney u test with a significance level of .
to check the statistical significance differences of experimental results.
a smaller statistical significance difference a.k.a p value indicates a more significant difference between memlock and the competitor.
in table we mark the corresponding a12values in bold for those with a p value smaller than the significance level .
for simplicity we do not include p values here but they are available at the companion website .
out of a12values in the table .
a12values exceed the conventionally large effect size .
and are marked in bold.
thus we can conclude that memlock significantly outperforms other state of the art fuzzers in most benchmark programs.
from the analysis of table and figure we can positively answer rq1 thatmemlock significantly outperforms the startof the art fuzzers in terms of memory consumption crashes detection.
.
real world vulnerability evaluation rq2 in this section we compare the capability of memlock to find realworld known vulnerabilities against baseline fuzzers as suggested by klees .
table shows the statistic results in memlock as well as other different state of the art fuzzers.
the benchmark programs totally contain unique vulnerabilities out of which memlock performs best in the vulnerabilities among other state of the art fuzzers as shown in column memlock.
memlock averagely takes about .
hours to find each unique vulnerability which is .
.
.
.
.
.
times faster than the state of the art fuzzers afl aflfast perffuzz fairfuzz angora and qsym respectively.
in particular memlock finds out of unique vulnerabilities within hours while other fuzzers afl aflfast perffuzz fairfuzz angora and qsym only find and respectively.
the three unique vulnerabilities i.e.
issue cve and cve in mjs nmand flexcan be found only by 771table unique crashes evaluation memlock afl aflfast perffuzz fairfuzz angora qsymprogram version sloc type crashes crashes a12 crashes a12 crashes a12 crashes a12 crashes a12 crashes a12 mjs .
.
40k ur .
.
.
.
.
.
cxxfilt .
757k ur .
.
.
.
.
.
nm .
757k ur .
.
.
.
.
.
nasm .
.
105k ur .
.
.
.
.
.
flex .
.
27k ur .
.
.
.
.
.
yaml cpp .
.
58k ur .
.
.
.
.
.
libsass .
.
27k ur .
.
.
.
.
.
yara .
.
45k ur .
.
.
.
.
.
readelf .
844k ua .
.
.
.
.
.
exiv2 .
84k ua .
.
.
.
.
.
openjpeg .
.
243k ua .
.
.
.
.
.
ua .
.
.
.
.
.00bento4 .
.
78kml .
.
.
.
.
.
ua .
.
.
.
.
.80libming .
.
92kml .
.
.
.
.
.
ua .
.
.
.
.
.92jasper .
.
44kml .
.
.
.
.
.
total unique crashes improvement .
.
.
.
.
.
ur means the uncontrolled recursion bug ua means the uncontrolled memory allocation bug and ml means the memory leak.
we highlight the a12values in the bold if its corresponding mann whitney u test is significant.
time hour 020406080100120140160180number of unique crashesnasm qsym perffuzz memlock fairfuzzangora aflfast afl time hour 020406080100120140number of unique crashesnm qsym perffuzz memlock fairfuzzangora aflfast afl time hour 050100150200250300number of unique crashesreadelf qsym perffuzz memlock fairfuzzangora aflfast afl time hour 024681012141618number of unique crashesopenjpeg qsym perffuzz memlock fairfuzzangora aflfast afl figure the growth trend of unique crashes found in different fuzzers higher is better memlock within hours.
therefore it is proved that our memoryconsumption guided strategy is very effective in finding memory consumption bugs.
in addition we also conduct the statistic test for unique vulnerability evaluation.
out of a12values in the table .
a12values are bold and exceeding the conventionally large effect size .
.
thus memlock significantly outperforms other stateof the art fuzzers in finding unique vulnerabilities.
case study.
to demonstrate the reason behind memlock s superiority we present the case of cve .
it is an uncontrolledrecursion vulnerability in flex which is a lexical analyzer generator.
the lexical analyzer generated by flexhas to provide beginning state and ending states.
the mark beginning as normal function mark each beginning state in a machine as being a normal state and the beginning states are the epsilon closure of the first state.
the mark beginning as normal function would call to itself if there is a state reachable from the first state through epsilon.
we investigate memlock s mutation history and identify a key mutation step.
the test case triggers the mark beginning as normal function calling itself for multiple times through havoc mutation operation.
then the recursive depth of this function is multiplied bysplice operation and finally leading to stack overflow.more interestingly memlock takes only .
hours on average to discover this vulnerability while other fuzzers all fail.
we can also see the peak length of call stack of flexin figure .
afl does not retain any seed over lengths as those inputs do not increase coverage.
comparing to afl memlock intentionally keeps seeds that increase the peak length of call stack and finally triggering stack overflow.
this explains the reason why memlock can find the vulnerability while afl can not detect it in all runs.
new vulnerabilities memlock found.
with memlock we have discovered many previously unknown security critical vulnerabilities.
these vulnerabilities were not previously reported.
we informed the maintainers and mitre assigned cves.
among these cves cves are uncontrolled recursion vulnerabilities are vulnerabilities due to uncontrolled memory allocation issues and are about memory leak vulnerabilities.
an attacker might leverage these vulnerabilities to launch an attack by providing wellconceived inputs that trigger excessive memory consumption.
the developers actively patched the vulnerabilities with our reports.
at the time of writing of these vulnerabilities have been patched.
detailed information on our newly discovered vulnerabilities is available on our website .
we are confident that memlock is effective and viable in practice.
772table time to expose real world vulnerability memlock afl aflfast perffuzz fairfuzz angora qsymprogram vulnerability typetime h time h a12 time h a12 time h a12 time h a12 time h a12 time h a12 issue ur .
.
.
.
.
.
.
.
.
t o .
.
.22mjsissue ur .
t o .
t o .
t o .
t o .
t o .
t o .
cve ur .
.
.
.
.
.
.
t o .
t o .
.
.
cve ur t o .
.
t o .
t o .
t o .
t o .
t o .
cve ur .
.
.
.
.
.
.
.
.
t o .
.
.
cve ur .
.
.
.
.
.
.
t o .
.
.00cxxfilt cve ur .
.
.
.
.
.
.
.
.
t o .
.
.
cve ur .
.
.
.
.
.
.
t o .
t o .
.
.
cve ur .
.
.
.
.
t o .
t o .
t o .
.
.
cve ur .
.
.
.
.
t o .
t o .
t o .
.
cve ur .
.
.
.
.
t o .
t o .
t o .
t o .
cve ur .
t o .
t o .
t o .
t o .
t o .
t o .
cve ur .
.
.
.
.
t o .
t o .
t o .
.
.56nm cve ur .
t o .
.
t o .
t o .
t o .
t o .
cve ur .
t o .
.
.
t o .
t o .
.
.00nasmcve ur .
.
.
.
.
t o .
t o .
.
.
flex cve ur .
t o .
t o .
t o .
t o .
t o .
t o .
cve ur .
t o .
.
.
.
.
t o .
t o .
t o .00yaml cppcve ur .
t o .
t o .
.
.
t o .
t o .
t o .
cve ur .
.
.
.
.
.
.
.
.
t o .
.
cve ur .
.
.
.
.
.
.
.
.
t o .
.
.
libsass cve ur .
.
.
.
.
.
.
.
.
.
.
.
.
yara cve ur .
.
.
.
.
.
.
.
.
t o .
.
.
readelf cve ua .
.
.
.
.
.
.
.
.
t o .
.
.
exiv2 cve ua .
.
.
.
.
.
.
.
.
.
.
.
.
cve ua .
.
.
.
.
.
.
.
.
.
.
.
.50bento4cve ua .
t o .
t o .
t o .
t o .
.
.
t o .
cve ua .
.
.
.
.
.
.
.
t o .
.
.
cve ua .
.
.
.
.
.
.
.
.
.
.
.
.
libming issue ua .
.
.
.
.
.
.
.
t o .
.
.
cve ua .
.
.
.
.
t o .
t o .
t o .
.
.81openjpegcve ua .
.
.
.
t o .
.
.
t o .
.
cve ua .
.
.
.
t o .
.
.
t o .
.
.88jasperissue ua .
.
.
.
.
t o .
.
.
.
.
.
average time usage improvement .
.
.
.
.
.
.
.
.
.
.
.
.
unique vulnerabilities improvement .
.
.
.
.
.
ur means the uncontrolled recursion bug ua means the uncontrolled memory allocation bug.
t o means the fuzzer can t find this vulnerability throughout hours across repetitions.
when we calculate the average time usage we replace t o with hours.
we highlight the a12in the bold if its corresponding mann whitney u test is significant.
from the analysis of table the case study and new vulnerabilities memlock found we can positively answer rq2 thatmemlock significantly outperforms the state of the art fuzzers in terms of real world memory consumption vulnerability detection.
.
memory leakage evaluation rq3 memory leak bugs are a little different from uncontrolled recursion and uncontrolled memory allocation bugs because they may not lead to program crashes immediately.
only enough memory is leaked it would produce denial of service dos attack for example in a long time running programs e.g.
banking service .
to evaluate the effectiveness of fuzzers in finding memory leaks we look into the number of total bytes leaked during different fuzzers within hours table shows the amount of memory leak in bytes identified by each fuzzer that may occur in different programs.
we can see that memlock shows an obvious advantage over other baseline fuzzers.
the number of bytes leaked is improved increased byfrom to compared to other baseline fuzzers.
this is because memlock tries to maximize each allocation and generates inputs with high memory consumption.
when the memory leak happens those memory consuming inputs will often cause morebytes memory leakage.
from the results in table we can answer rq3 thatmemlock significantly magnifies the memory leakage comparing to the state of the art fuzzing techniques due to its memory consumption guidance.
.
memory consumption evaluation rq4 since memlock seeks to generate test inputs that consume more and more memory.
in this experiment we evaluate the test input distribution according to memory consumption for memlock afl aflfast perffuzz fairfuzz angora and qsym.
a fuzzer that maintains a seed pool with a larger proportion of high memory consumption inputs is considered to have a better chance of detecting memory consumption bugs.
the peak length of call stack of seeds in seed poolnm afl aflfast fairfuzzmemlock perffuzz qsym the peak length of call stack of seeds in seed poolnasm afl aflfast fairfuzzmemlock perffuzz qsym the peak length of call stack of seeds in seed poolflex afl aflfast fairfuzzmemlock perffuzz qsym the peak length of call stack of seeds in seed poolyara afl aflfast fairfuzzmemlock perffuzz qsym .
.
.
.
.
.
.
.
.
amount of consumed heap memory bytes 1e9100101102103104 of seeds in seed poolreadelf afl aflfast fairfuzzmemlock perffuzz qsym .
.
.
.
.
.
.
.
.
amount of consumed heap memory bytes 1e9100101102103 of seeds in seed poolopenjepg afl aflfast fairfuzzmemlock perffuzz qsym .
.
.
.
.
.
.
.
.
amount of consumed heap memory bytes 1e9100101102103104 of seeds in seed pooljasper afl aflfast fairfuzzmemlock perffuzz qsym .
.
.
.
.
.
.
.
.
amount of consumed heap memory bytes 1e9100101102103104 of seeds in seed poollibming afl aflfast fairfuzzmemlock perffuzz qsymfigure seed distribution based on memory consumption.
the larger the value on the right side is better.
table total leak bytes program type tool leakge bytes improve.
p value a12 bento4 memory leakmemlock afl .
.
aflfast .
.
perffuzz .
.
fairfuzz .
.
angora .
.
qsym .
.
libming memory leakmemlock afl .
.
aflfast .
.
perffuzz .
.
fairfuzz .
.
angora .
.
qsym .
.
jsaper memory leakmemlock afl .
.
aflfast .
.
perffuzz .
.
fairfuzz .
.
angora .
.
qsym .
.
figure shows the input distribution based on memory consumption.
in general we can clearly see that memlock can generate more seeds with higher memory consumption.
this is because the guidance mechanisms in memlock help to gradually add more and more memory consuming inputs into the seed pool.
in particular for the uncontrolled recursion bugs nm nasm flexand yara memlock generates a large number of inputs that hold more than function calls in the call stack while perffuzz generates only a few and afl aflfast can hardly generate inputs that hold more than function calls.
the pattern is similar for uncontrolled memory allocation bugs readelf openjpeg jasper andlibming .memlock can generate a considerable amount of inputs with high memory consumption while the inputs of the other fuzzers concentrate on the low memory consumption region.the results clearly demonstrate the effectiveness of the strategies ofmemlock in generating inputs with high memory consumption.
after analyzing figure we can answer rq4 that the strategies of memlock indeed help to generate inputs with high memory consumption.
.
discussion additional experiments.
the above four groups of experiments show that memlock is effective and efficient in finding memory consumption vulnerabilities.
since memlock focuses on the space complexity issues it may fall behind other baseline fuzzers in other performance metrics.
for example memlock intentionally keeps seeds that increase memory consumption which may degrade its capability of identifying other types of vulnerabilities.
we have therefore evaluated the capability of finding other types of crashes.
in the benchmark programs memlock afl aflfast perffuzz fairfuzz angora and qsym find and other types of unique crashes respectively.
moreover our approach may also incur some runtime overhead.
therefore we compare the code coverage and execution speed for each baseline fuzzer.
in total the number of executed test inputs in memlock ranges from to of those in afl aflfast fairfuzzer and qsym.
among all the fuzzers perffuzz performs the worst likely due to the fact that it prefers the test inputs that execute long instructions.
considering the code coverage memlock achieves the comparable code coverage compared to the fuzzers afl aflfast fairfuzzer and qsym.
perffuzz still performs the worst among those fuzzers and in most cases it only achieves the code coverage from about to of those in other fuzzers.
all extra experimental results and data are available on our website for interested readers.
threats to validity.
we selected a variant of real world programs to show the capabilities of memlock and compared it against other state of the art fuzzers.
however our benchmarks may still include 774a certain sample bias.
further studies on more real world programs can help better evaluate memlock.
besides memlock also suffers from the difficulty in breaking through hard comparisons e.g.
magic bytes as most work .
adopting some program analysis techniques e.g.
symbolic execution might help mitigate this threat.
related work coverage based grey box fuzzing.
coverage based grey box fuzzing is one of the most effective techniques to find vulnerabilities and bugs and has attracted a great deal of attention from both academic and industry.
coverage based grey box fuzzers typically adopt the coverage information to guide different program path explorations.
for example google has built an oss fuzz platform by incorporating several state of theart coverage based grey box fuzzers libfuzzer honggfuzz afl and clusterfuzz .
since a coverage guidance engine is a key component for the grey box fuzzers much effort has been devoted to improve their coverage.
steelix vuzzer and redqueen use programstate analysis or taint analysis to penetrate some paths protected by magic bytes comparisons.
qsym driller and safl equips grey box fuzzing with a symbolic execution engine to reach deeper program code.
angora adopts a gradient descent technique to solve path constraints so as to break some hard comparisons.
memfuzz augmenting evolutionary fuzzing by additionally leveraging information about memory accesses instead of memory consumption performed by the target program.
profuzzer grimoire superion and zest leverage the knowledge in highly structured files to generate syntactically and semantically valid test inputs and thus be able to touch deeper program code.
collafl proposes a coverage sensitive fuzzing solution to mitigate the path collisions.
fairfuzz leverages a targeted mutation strategy to execute towards rare branches.
uafl incorporates typestate properties and information flow to their fuzzing engine to guide the detection of use after free vulnerabilities.
besides aflgo and hawkeye use the distance metrics to execute towards user specified target sites in the program.
the main difference between memlock and these stateof the art fuzzers is that memlock aims at memory consumption bugs while the others are to find memory corruption vulnerabilities.
thus memlock is orthogonal to these state of the art fuzzers.
recently researchers have paid attention to the algorithmic complexity vulnerabilities i.e.
time complexity issues such as slowfuzz singularity and perffuzz .
they use the number of executed instructions as the guidance to explore the program path with a longer path length.
in contrast with memlock they stress the time complexity issues while memlock considers space complexity issues.
the space complexity issues have its own unique characteristics as the amount of memory consumption can increase e.g.
function entry memory allocation and decrease e.g.
function exit memory free memlock takes both of them into consideration.
static analysis.
static analysis is also used to analyze memory consumption .
wang et al.
presents a type guided worst case input generation by using automatic amortized resource analysis to derive symbolic bounds on the resourceusage of functions.
duc hiep et al.
presents a worst case memory consumption analysis which uses symbolic execution to exhaustively unroll loops and compute memory consumption of each iteration.
he et al.
and chin et al.
employ static verification to check a program s memory usage is within the memory bounds while chin et al.
uses static analysis to compute the memory usage bounds for assembly level programs.
these approaches rely on type theory or symbolic execution thus they often suffer from the scalability issue.
smoke is a path sensitive memory leak detector for millions of lines of code.
it first uses a scalable but imprecise analysis to compute a set of candidate memory leak paths and then verifies the feasibility of the candidates using a more precise analysis.
while smoke can demonstrate the existence of memory leak memlock can generate an input that produces the memory leak.
dynamic analysis.
yuku et al.
proposes an improved realtime scheduling algorithm to reduce maximal heap memory consumption by controlling multitask scheduling.
different from memlock this technique aims at reducing memory consumption by dynamic online scheduling while memlock is to find memory consumption bugs.
bleak is a system to debug memory leaks in web applications.
it leverages the observation that users often repeatedly return to the same visual state.
sustained growth between round trips is a strong indicator of a memory leak.
bleak is only applicable to memory leak of web applications while memlock can find several kinds of memory consumption bugs.
radmin is a system for early detection of application level resource exhaustion and starvation attacks.
it first learns and executes multiple probabilistic finite automata from its benign executions.
it then restricts the resource usage to the learned automata and detects resource usage anomalies.
radmin uses some heuristics to detect resource usage anomalies while memlock employs the fuzzing technique to automatically generate the inputs for memory consumption bugs.
conclusion in this paper we propose memlock an enhanced grey box fuzzing technique to find memory consumption bugs.
memlock employs both coverage and memory consumption information to guide the fuzzing process.
the coverage information guides the exploration of different program paths while the memory consumption information guides the search for those program paths that exhibit more and more memory consumption.
our experimental results have shown that memlock outperforms state of the art fuzzing techniques i.e.
afl aflfast perffuzz fairfuzz angora and qsym in detecting memory consumption bugs.
we also found securitycritical vulnerabilities in some real world programs.
at the time of writing of these vulnerabilities have been patched.