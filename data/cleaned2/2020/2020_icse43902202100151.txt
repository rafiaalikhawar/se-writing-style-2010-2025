justgen effective test generation for unspecified jni behaviors on jvms sungjae hwang school of computing kaist daejeon south korea sjhwang87 kaist.ac.krsungho lee department of computer science and engineering chungnam national university daejeon south korea eshaj cnu.ac.krjihoon kim school of computing kaist daejeon south korea kjh618 kaist.ac.krsukyoung ryu school of computing kaist daejeon south korea sryu.cs kaist.ac.kr abstract java native interface jni provides a way for java applications to access native libraries but it is difficult to develop correct jni programs.
by leveraging native code the jni enables java developers to implement efficient applications and to reuse code written in other programming languages such as c and c .
besides the core java libraries already use the jni to provide system features like a graphical user interface.
as a result many mainstream java virtual machines jvms support the jni.
however due to the complex interoperation semantics between different programming languages implementing correct jni programs is not trivial.
moreover because of the performance overhead jvms do not validate erroneous jni interoperations by default but they validate them only when the debug feature the xcheck jni option is enabled.
therefore the correctness of jni programs highly relies on the checks by the xcheck jni option of jvms.
questions remain however on the quality of the checks provided by the feature.
are there any properties that the xcheck jni option fails to validate?
if so what potential issues can arise due to the lack of such validation?
to the best of our knowledge no research has explored these questions in depth.
in this paper we empirically study the validation quality and impacts of the xcheck jni option on mainstream jvms using unspecified corner cases in the jni specification.
such unspecified cases may lead to unexpected run time behaviors because their semantics is not defined in the specification.
for a systematic study we propose justg en a semi automated approach to identify unspecified cases from a specification and generate test programs.
justg enreceives the jni specification written in our domain specific language dsl and automatically discovers unspecified cases using an smt solver.
it then generates test programs that trigger the behaviors of unspecified cases.
using the generated tests we empirically study the validation ability of the xcheck jni option.
our experimental result shows that the jni debug feature does not validate thousands of unspecified cases on jvms and they can cause critical run time errors such as violation of the java type system and memory corruption.
we reported unspecified cases that are not validated by jvms to their corresponding jvm vendors.
among them cases have been fixed and the remaining cases will be fixed in near future.
based on our empirical study we believe that the jni specification should specify the semantics of the missing cases clearly and the debug feature should be supported completely.
index terms java native interface java virtual machine testing empirical study debugging i. i ntroduction java developers use the java native interface jni in various application domains including games and multimedia and mainstream java virtual machines jvms supportthe jni.
the jni is an interface that defines interoperation between java code and native code written in c or c .
using the jni developers can improve the performance of programs by implementing performance critical modules in native code and composing them with java modules into a single program via the jni.
in addition the jni reduces software development cost by allowing java modules to reuse existing native libraries.
however building correct jni programs is a difficult task due to the complex interoperation semantics between different languages.
in addition because the jni specification does not describe the interoperation semantics completely the semantics of numerous cases are unspecified which may lead to unexpected behaviors.
note that the jni does not check for programming errors for the following reasons forcing jni functions to check for all possible error conditions degrades the performance of normal correct native methods.
in many cases there is not enough run time type information to perform such checking.
while compilers can detect compile time errors and provide useful debug features for programs written in a single programming language they cannot find bugs in interoperation between java and native code.
furthermore no publicly available tools can detect such interoperation errors.
the jni supports the xcheck jni option to help developers to diagnose problems in jni programs but the specification does not define its semantics clearly.
the xcheck jni option is a command line option that causes the vm to do additional validation on the arguments passed to jni functions .
however the additional validation is not well defined note the option is not guaranteed to find all invalid arguments or diagnose logic bugs in the application code but it can help diagnose a large number of such problems.
because the specification does not specify which problems the option diagnoses jni programs may behave differently on different jvms depending on their implementation of the option which makes reasoning of jni programs challenging.
in this paper we study the semantics of the xcheck jni option and its impacts on mainstream jvms.
our approach ieee acm 43rd international conference on software engineering icse .
ieee is to generate test programs for unspecified cases which are interoperation semantics that are not defined in the jni specification to execute the test programs on jvms with the xcheck jni option enabled and to inspect the execution results.
our study has two technical challenges how to identify unspecified cases in the jni specification and how to generate test programs that trigger the behaviors of unspecified cases.
for a systematic study we propose justg en a semi automated approach to identify unspecified cases and generate test programs.
we first define a domain specific language dsl that can express the jni interoperation semantics such as the return types and parameters of jni functions.
then we manually transform the interoperation semantics written in a natural language in chapter of the jni specification to a mechanized specification expressed in our dsl.
because the english phrases used to specify the interoperation semantics are well structured and use specific patterns manually converting them to the dsl is considerably straightforward.
then justg enreceives the mechanized specification automatically extracts unspecified cases from the specification and generates test programs that provoke them.
justg enleverages an smt solver to find unspecified cases by verifying whether the specification describes all the conditions of jni function calls.
if justg enidentifies a condition of a jni function call that the specification does not describe it considers the condition as an unspecified case.
for test code generation justg entakes an unspecified case and synthesizes c code consisting of jni function calls with arguments that satisfy the conditions of the unspecified case.
it then compiles and links the synthesized c code with prepared java modules to generate an executable jni program.
using test programs generated by justg en we empirically evaluated the xcheck jni option on five mainstream jvms.
our study shows that thousands of unspecified cases are not validated by jvms and they can cause critical run time errors such as run time type errors and memory corruption.
in addition we found a bug of the xcheck jni option which leads to deadlock between multiple threads.
we also observed that the xcheck jni option of hotspot zulu corretto and graalvm validate similar properties but openj9 validates properties significantly different from them.
we reported the problems of the xcheck jni option to their jvm vendors and among reported unspecified cases cases have been fixed.
the tool used for the empirical study and the identified unspecified cases are publicly available1.
the contributions of this paper include the following we present an approach to identify unspecified cases from a specification and implement justg enthat automatically identifies them from a mechanized specification and generates test code provoking them.
we believe that justg enis applicable to other specifications with only changes in test code generation.
we identify unspecified cases from the jni specification.
describing the semantics of the identified unspeci1 class hellojni static system.loadlibrary hello private native string foo public static void main string args string n new hellojni .foo ... private string name return this .getclass .getname a java code 1jmethodid get name id jnienv env jobject obj jclass cls env getobjectclass env obj return env getmethodid env cls name ljava lang string 5jstring java hellojni foo jnienv env jobject thisobj jmethodid mid get name id env thisobj return env callobjectmethod env thisobj mid b normal jni interoperation in c code 1jstring java hellojni foo jnienv env jobject thisobj jmethodid mid get name id env thisobj jchararray arr env newchararray env return env callobjectmethod env arr mid c unspecified jni interoperation case in c code fig.
jni code example for normal and unspecified behaviors fied cases in the jni specification would make consistent behaviors of jni programs on different jvms.
it is the first work that analyzes the quality of the xcheck jni option on five mainstream jvms.
our empirical study reports limitations of the xcheck jni option and jvm vendors fixed among reported cases.
we believe that our work would be helpful in enhancing the quality of the jni debug feature on jvms which in turn improves the quality of jni programs.
ii.
b ackground and motivating example a. jni interoperation the jni is a foreign function interface that enables bidirectional interoperation between java and native applications.
figure a shows java code that has an entrypoint of a jni program and figure b shows c code compiled to a native library hello.so .
in java a class hellojni has two java methods main andname and a native method foo declared with the native keyword.
the native method is linked with a c function java hellojni foo when executing the system.loadlibrary method at line .
when the program runs the main method calls the native method foo at line .
then the jvm transfers the program control to the entry of the linked c function java hellojni foo .
in c code the function java hellojni foo calls the java 1709method name via a sequence of three jni function calls.
at line in figure b the c code obtains a java method id by calling get name id defined at line .
the function calls the getobjectclass jni function that takes a jnienv pointer and a java object and returns class information of the java object.
then it calls getmethodid to obtain a java method id using the class information a method name and a method signature.
using the method id and the java object it calls the java method name via the callobjectmethod jni function.
b. unspecified cases and the jni debug feature because jvms do not validate argument values at run time due to its performance overhead the unspecified cases may lead to unexpected behaviors or even security vulnerabilities like memory corruption.
figure c shows one unspecified case for the jni function callobjectmethod .
the function java hellojni foo gets an id of the java method name via the get name id function as the same as b .
however at line it tries to call the java method name using a java character array object created at line instead of the java object propagated from java.
the jni specification describes the behavior of callobjectmethod as follow nativetype call type method jnienv env jobject obj jmethodid methodid ... methods from these three families of operations are used to call a java instance method from a native method.
themethodid must be derived from the real class of obj not from one of its superclasses.
however in the example because the method id is derived from hellojni while a class of this is a character array its behavior is not specified which can cause problems on mainstream jvms.
for example calling callobjectmethod at line triggers a segmentation fault on the hotspot jvm but executes normally on the openj9 jvm producing a wrong result.
after normal execution the variable nhas a string value cat line in a instead of hellojni which is wrong in the java semantics because a this object in a java method must be an instance of a class having the method.
to prevent segmentation faults or abnormal executions from jvms due to the unspecified jni interoperation semantics the jni provides a debug feature the xcheck jni option but it does not guarantee to find all problems and its semantics depends on the implementation on jvms.
the xcheck jni option enables jvms to validate arguments passed to jni functions .
if argument values are not valid jvms stop execution and report errors or warnings.
for example when executing the example in figure c on the openj9 jvm with the xcheck jni option enabled the jvm detects the invalid argument and throws an exception with the error message jni error in callobjectmethod callobjectmethodv ineligible receiver .
however because the debuggability highly relies on jvms invalid interoperation in jni programs may still remain undiscovered after the debugging process which degrades the quality of jni programs.
in this paper we leverage unspecified cases to evaluate the quality of the xcheck jni option on mainstream jvms.
we be lieve that unspecified cases are useful resources to evaluate the xcheck jni option since developers might have missed them because they are not described in the specification.
iii.
m ethodology a. overview to evaluate the quality of the xcheck jni option we test jvms with unspecified cases that are semi automatically extracted from the jni specification.
figure presents an overview of our testing approach consisting of two phases.
in the jni unspec.
code generation phase justg enextracts unspecified cases from the jni specification and generates test programs that provoke the behaviors of the unspecified cases.
since the specification is written in a natural language that is not suitable for automated processing our first step is to define a domain specific language dsl and to manually transform the semantics in the specification to a mechanized specification in the dsl.
then unspec.
extractor discovers unspecified cases from the mechanized specification by utilizing an smt solver.
it encodes the mechanized specification as logical formula in a way that the smt solver can recognize and leverages the smt solver to determine whether a formula is unsatisfiable.
if the formula is satisfiable the smt solver generates a counterexample of such a case.
the counterexample denotes an unspecified case with a possible argument combination.
similar to counterexample guided abstraction refinement cegar unspec.
extractor updates the specification by adding the identified unspecified case and repeats the above process until the formula becomes unsatisfiable.
among various smt solvers we used z3 .
for each unspecified case test code generator automatically generates a sequence of valid jni function calls that triggers the behavior of the unspecified case.
then it composes the jni function calls with a java and c template code that we defined.
in the jvm testing phase we execute the generated test programs on mainstream jvms with the xcheck jni option enabled.
because different jvms may produce different results we manually inspect the test results and analyze the capability of the debug feature of each jvm and identify potential hazards due to the lack of validation from jvms.
b. jni specification in a domain specific language for automatic processing of the jni specification we define a simple dsl to describe the behaviors of jni functions.
because the expected behaviors of jni functions are defined in chapter of the jni specification we manually transformed them to a mechanized specification expressed in the dsl.
since the jni function behaviors are written in a wellstructured phrases using specific patterns manually converting them to the dsl is considerably straightforward.
figure presents the dsl syntax.
a specification sis a sequence of type declarations typedeft a sequence of refinement predicate declarations refinedef t p and a sequence of jni function specification d. typestdenote types in the 1710fig.
overall structure of jvm testing with unspecified cases rule type void setintarrayregion jnienv jintarray jsize jsize jint spec void setintarrayregion jnienv jintarray notnull jsize validindex jsize validindex jint notnull unspec void setintarrayregion jnienv jintarray isnull jsize validindex jsize validindex jint notnull ... fig.
example jni function specification in dsl s typedeftrefinedef t pd d rule ftypet f t t ?f t ?
g spec junspec r pjr r fig.
domain specific language to define the jni semantics c programming language including primitive types and predefined types for the jni in jni.h .
a refinement predicate pdenotes a predicate name which returns whether an input satisfies its condition.
a refinement type t pdenotes a set of values that have the type tand satisfy the refinement predicatep.
for example a set of all negative integer values is denoted as int isnegative where isnegative is a predicate returning whether an input is a negative integer.
a jni function specification dconsists of a jni function descriptor and a sequence of refined function descriptors.
a jni function descriptor typet f t denotes a return type t a jni function name f and a sequence of parameter types t. a refined function descriptor t ?f t ?
denotes an optionally refined return type t ?
a jni function name f and a sequence of optionally refined parameter types t ?
where is either spec orunspec .
a refinement ris a refinement predicate por its conjunctions.
for our research we defined types and refinement types .
to distinguish function descriptors jvms do not verify return values of jni functions but because we use return types in test code generation as described in section iii d we include return types in refinement types.
specified in the specification and those constructed while finding unspecified cases using the smt solver we use spec for the former and unspec forthe latter.
figure shows an example jni function specification in dsl.
the jni function setintarrayregion takes a jni environment pointer jnienv a java array of integers jintarray an integer value representing the start index of an array jsize an integer value indicating the number of elements to be copied jsize and the source buffer jint .
the function copies a specified number of elements from the source buffer to the java array.
according to the jni specification the java array must not be null the start index and the number of elements must be greater than or equal to zero and the source buffer must not be null as well.
we transform the above specification in the dsl as thespec statement with refinement predicates representing the conditions for valid argument values.
in this example notnull denotes that input values should not be null and valideindex denotes that input values must be greater than or equal to zero.
in addition to the spec statement various unspec statements are automatically generated in the process of finding unspecified cases of the jni function as we discuss in the next subsection.
c. finding unspecified behaviors with an smt solver we leverage the z3 smt solver version .
.
to find unspecified cases automatically from the mechanized jni specification.
to use the smt solver we convert the unspecified case finding problem to an sat problem.
for example for a jni function specification spect1 r1f t2 r2 we extract a boolean formula as follows is there a refined type xthat is matched with the type t2but is not covered by the specification t2 r2?
when the formula is satisfiable the smt solver produces an example satisfiable cases the 1711produced example is an unspecified case.
then we update the boolean formula including the unspecified case to find another unspecified case.
we repeat the process to find unspecified cases until the boolean formula is not satisfiable which means that no more unspecified cases exist.
bit vector representation for jni function specification we use bit vectors to represent each jni function specification in a boolean formula so that the smt solver can manipulate it.
a jni function specification consists of a possibly refined return type a function name and a list of possibly refined parameter types.
since only the parameters determine the behavior of the jni function we can encode a jni function specification into a list of bit vectors where each bit vector represents each possibly refined parameter type.
definition bit vector representation type each typetis mapped to a unique bit vector representation bt.
refinement predicate for each refined type t r each refinement predicate pinris mapped to a unique bit vectorbpwhose on bits do not overlap with other bit vectors representing refinement predicates of t. refinement for a refinement r p1 pn its bit vector representation is br bp1jbpnwherejis the bitwise or operator.
jni function specification for a jni function specificationt1 r1f t2 r2 t n rn its bit vector representation is bt2 br2 ... btn brn wherebtiandbri are bit vector representations of tiandri respectively.
one challenge for the bit vector representation is to define subtype relations among types.
while c does not have any subtype relations between types jni reference types have a type hierarchy that corresponds to the java type hierarchy .
for example because jstring is a subtype of jobject a jni function that takes a jobject argument can take a jstring value as well.
we define a subtype relation t between two bit vectors using the bitwise and operator .
for the previous example we encode jobject andjstring into two different bit vectors btoandbts which satisfy bto bts bto.
definition subtype relation assume that t1is a subtype oft2andbt1andbt2are bit vector representations of t1and t2 respectively.
then a subtype relation bt1 tbt2is valid.
the subtype relation is equivalent to a boolean expression bt1 bt2 bt2.
similarly we also define a subrefinement relation r between two bit vectors representing refinements.
a refinement r1is a subrefinement of another refinement r2 when all the refinement predicates in r1are included in r2.
definition subrefinement relation assume that r1is a subrefinement of r2andbr1andbr2are bit vector representations of r1andr2 respectively.
then a subrefinement relationbr1 rbr2is valid.
the subrefinement relation is equivalent to a boolean expression br1 br2 br2.
satisfiability for unspecified case finding using encoded jni function specifications we convert each jni function specification to a boolean formula to find unspecified cases.
onecomplexity is that because most jni functions take multiple parameters we should consider many parameter combinations.
for example if a jni function takes five parameters and each parameter has ten refined types the number of possible parameter combinations is which is a huge search space.
for practicality we handle each parameter independently to reduce the search space.
for a jni function fwithnparameters we make nfunctionsf1 fnwherefitakes only thei th parameter of f. then each function figets converted to a boolean formula and the smt solver finds unspecified cases for each boolean formula independently.
this approach may miss some unspecified cases that are caused only by a combination of multiple parameters.
however our experiments showed that because most unspecified cases are due to a single parameter few such cases are missing.
after defining four auxiliary definitions we define a boolean formula to check the satisfiability of a jni function parameter using the auxiliary definitions.
note that we now consider only such jni functions that take one parameter.
definition complete refinement for each type t its complete refinement bit vector is bt cthat is a conjunction of all the refinement predicates of t. definition validity of refined type a bit vector representation of a refined type btx brx is valid for a type t ifbtx tbtandbrx rbt c. a logical predicate valid btx brx t istrue only when btx brx isvalid for the typet.
definition equivalent type satisifiability a bit vector representation of a refined type btx brx is equivalent type satisfiable to another bit vector representation bty bry iffbtx btyandbrx rbry.
a logical predicate sateq btx brx bty bry istrue only when btx brx isequivalent type satisfiable to bty bry .
definition subtype satisifiability a bit vector representation of a refined type btx brx is subtype satisfiable to another bit vector representation bty bry iffbtx tbtyandbtx6 bty.
a logical predicate satsub btx brx bty bry istrue only when btx brx issubtype satisfiable to bty bry .
using the auxiliary definitions we define a boolean formula for the parameter satisifiability solved by the smt solver.
assume that a jni function declaration is t1f t2 and the bit vector representation of its specification is bty bry .
then we can define its satisfiability problem as follows btx brx valid btx brx t2 !
sateq btx brx bty bry satsub btx brx bty bry the formula represents that there is a valid parameter btx brx that is matched with the jni function parameter type t2but not covered by the specification bty bry .
when the smt solver concludes that this formula is satisfiable it produces an example such as btz brz as a result representing an unspecified case that is not covered by the current 1712specification.
then we record the unspecified case and update the formula by adding it as follows btx brx valid btx brx t2 !
sateq btx brx bty bry satsub btx brx bty bry sateq btx brx btz brz satsub btx brx btz brz thus in the next iteration the smt solver tries to find another unspecified case except for ones discovered previously.
when the smt solver fails to find more unspecified cases it concludes that the formula is not satisfiable implying that the updated specification covers all the valid parameters.
d. test case generation and testing on jvms one difficulty in the test code generation phase is to generate valid test code.
as described in section ii in jni programs c code leverages a sequence of jni function calls to interact with java modules.
to investigate behaviors caused by unspecified cases generated test code should contain jni function call chains that do not introduce run time errors caused by other factors such as invalid arguments unintended unspecified cases and so on.
random test generation is widely used but it is not suitable for our purpose it produces too many wrong jni function call chains that cause run time errors unrelated to unspecified cases.
the test code generator utilizes both a jni function mapping table and template code to generate valid test code.
firstly it constructs a mapping table by matching each refined parameter type of jni functions with a refined return type of other jni functions.
for example if a first refined parameter type of a jni function foo is matched with a refined return type of another jni function bar the mapping bar !foo is added to the table it denotes that the return value of bar can be used for the first argument of foo.
jni functions often take values of primitive types such as integers and character arrays as arguments and some primitive types may not have matching jni functions that have them as return types.
therefore for primitive types we manually write template code that consists of functions that return values of primitive types according to refined parameter types.
with the mapping table and the template code test code generator generates valid c test code for unspecified cases by building valid jni function call chains and propagating valid arguments for refined parameter types.
we compile the generated c test code and link it with java modules we developed to build executable jni test programs.
note that we focus on only c test code while jni supports both c and c because all the mainstream jvms handle the jni interoperation for c and c in the same way.
for testing on multiple jvms we install each jvm on an individual docker container and execute the generated test code on each container.
because different jvms print execution results in different formats we develop a result parser for each jvm to translate its execution result to a unifiedtable i evaluation results of the xcheck jni option on five jvms for unspecified cases category hotspot openj9 zulu corretto graalvm misbehave segfault exception validation format.
then test result assembler classifies the execution results into four categories misbehave segfault exception and validation .
the misbehave category represents that test code terminates normally without any warnings or errors.
since behaviors of unspecified cases are not defined each jvm may produce different execution result from one another for an unspecified case.
the segfault and exception categories represent that test code causes a segmentation fault and an exception thrown respectively and the validation category represents that test code terminates with an error or a warning produced by the debug feature as its validation result.
in addition test result assembler compares the execution results of the jvms to identify different debugging capabilities of the jvms.
iv.
e valuation of the jni d ebug feature on jvm s a. evaluation results for unspecified cases to evaluate the debug capability of mainstream jvms we chose five jvms based on their popularity oracle s hotspot ibm s openj9 azul s zulu amazon s corretto and oracle s graalvm.
among various java versions we chose java since its popularity is ranked the second following java and all five jvms have implementations for java .
table i shows the categorized evaluation results on the five jvms for the test programs.
justg engenerated test programs for unspecified cases from the jni specification within seconds.
as table i indicates the evaluation results are very similar between jvms except for openj9 because they are variants of openjdk.
even though they have similar evaluation results we believe that analyzing them is significant because different vendors support them.
openj9 validated much more unspecified cases than the others but it validated only .
of the unspecified cases.
the other jvms validated only .
.
in most cases when jvms do not validate unspecified cases they let test programs terminate with exceptions.
throwing exceptions may be helpful for developers diagnose the problems but segmentation faults may not be useful to point out where the problems occur.
moreover misbehaviors may make the problems undiscovered which can lead to unexpected behaviors.
in the following subsections we report our empirical study results for unspecified cases in the categories of misbehaviors and segmentation faults.
in addition we discuss the differences in the debug capability of the jvms the unspecified cases that were not validated by all of the jvms and threats to validity.
1713b.
category misbehave we manually investigated the unspecified cases in the misbehave category.
since there are many unspecified cases as shown in table i it is impractical to investigate them all.
instead we chose one unspecified case for each parameter of jni functions.
in addition for jni function families that provide the same functionality for different types such ascallvoidmethod callintmethod and so on we randomly selected one of them.
finally we manually investigated unspecified cases for hotspot zulu correctto and graalvm but only cases for openj9 because it has a small number of misbehave cases.
in all the jvms we found two cases where all five jvms failed to identify unspecified cases.
finding error handling using return values of jni functions is not reliable.
some jni functions return v alues that indicate the success or failure of their e xecution butthey may not return correct results.
one example isregisternative that re gisters nativ e functions.
according to thespecification the function should tak e apositiv e number of nati vefunctions and return on success and a negativevalue on failure.
ho wever all five jvms failed to validate the case when the functi on tak es no nati vefunctions.
moreo ver in such cases while openj9 returns the other jvms return 0indicating the execution success.
thus relying on return v alues of jni functions to handle e xecution failures is not reliable.
finding deleted