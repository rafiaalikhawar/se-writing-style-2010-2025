chemtest an automated software testing framework for an emerging paradigm michael c. gerten iowa state university department of computer science ames iowa usa mcgerten iastate.edujames i. lathrop iowa state university department of computer science ames iowa usa jil iastate.edu myra b. cohen iowa state university department of computer science ames iowa usa mcohen iastate.edutitus h. klinge drake university department of mathematics and computer science des moines iowa usa titus.klinge drake.edu abstract inrecentyearstheuseofnon traditionalcomputingmechanisms has grown rapidly.
one paradigm uses chemical reaction networks crns to compute via chemical interactions.
crns are used to prototype molecular devices at the nanoscale such as intelligent drug therapeutics.
in practice these programs are first written and simulated in environments such as matlab and later compiled into physical molecules such as dna strands.
however techniques for testing the correctness of crns are lacking.
current methods of validating crns include model checking and theorem proving but these are limited in scalability.
in this paper we present the first to thebestofourknowledge testingframeworkforcrns chemtest.chemtestevaluatestestoraclesonindividualsimulationtracesand supports functional metamorphic internal and hyper test cases.
it also allows for flakiness and programs that are probabilistic.
weperformed a large case study demonstrating that chemtest can find seeded faults and scales beyondmodel checking.
of our tests areinherentlyflaky suggestingthatsystematicsupportforthis paradigm is needed.
on average functional tests find .
of thefaults while metamorphic tests find .
showing the benefit of usingmetamorphicrelationshipsinourtestframework.inaddition we show how the time at evaluation impacts fault detection.
ccs concepts software and its engineering software testing and debugging.
keywords chemicalreactionnetworks softwaretesting metamorphictesting flakiness ase september virtual event australia copyright held by the owner author s .
acm isbn .
reference format michaelc.gerten jamesi.lathrop myrab.cohen andtitush.klinge.
.
chemtest an automated software testing frameworkfor an emergingparadigm.in 35thieee acminternationalconferenceonautomatedsoftware engineering ase september virtual event australia.
acm newyork ny usa 13pages.
introduction in recent years utilization of non traditional computing mechanisms i.e.
programs not written in declarative imperative functional languages have proliferated in research and applications .
many of these paradigmscanbespecifiedwithhigh levelprogramminglanguages .
one such paradigm is the chemical reaction network crn .
crns are an abstraction of the traditional model of physicalchemistryandareofspecial interestbecausetheycanbe compiledintodeoxyribonucleicacid dna strandsthatsimulate theirbehaviorviastranddisplacement .asaresult crns are used as a programming language to deploy molecular programs at the nanoscale.
crns can naturally compute computational primitives such as addition multiplication and square roots a s well as more complex algorithms such as watchdog timers state logging and finite automata .
with new technologies forsynthesizingdnaandothermolecules itisnowcommonto implementcrnsasphysicalnanodevicesinthelab.thispowerful emerging computing paradigm is being promoted as a method to provide intelligent drug delivery and to achieve other compu tational functions at the nanoscale.
recently new programming methodsandtoolshavebeendevelopedtoeasethedevelopmentof molecularprograms.
thereis evena newprogramminglanguage crn designedto specifycrnsusingtraditionalprogramming primitives and control structures .
given the explosive growth in molecular systems it is important to be able to validate and verify the behavior of crns.
thepotentially safety critical nature of expected applications of thistechnology has led the research community to employ formal methods to prove correctness of stochastic crns via model checking automated theorem proving and even proving correctness by hand .however asnotedin modelchecking doesnotscaleforlargemoleculepopulations.wedemonstratein 35th ieee acm international conference on automated software engineering ase this work is licensed under a creative commons attribution international .
license.
ourcasestudy thattheprismmodelcheckerfailstobuildamodel at a concentration of molecules on at least one of our subjects.
theoremprovingtechniquesarescalable butthedollarcostand timerequiredtodoso maybeprohibitive andthetechniquesare stillrudimentary.whiletheorem provingtechniques arejustified forextremesafety criticalapplications thereareincreasingnumbersofmolecularapplicationsthatarelesssafety critical suchas buildingdnaorigami .thereforetoleratingasmallprobability of failure is acceptable.
an alternative and common approach is to use software testing to improve scalability for validation however several issues make utilizingstandardtestingframeworksfortestingcrnschallenging.
first to test crns we must rely on a simulation environment testingthephysicalsysteminvolvesextensivechemistryandcan only occur for a limited set of instances as in other cyberphysical environments .forinstance qianetal.documentedthata single experimenttook10hourstorun .second asinmanyscientific systems oraclesand orcompletespecificationsmaynotexist.third thestochasticandasynchronousnatureofthesesimulationsmeans that they may result in flaky behavior obtaining different values forthesamesetsofinputs .fourth evenwhenatestisnotflaky itcan betime dependent and thatmay makeitappear flakyeven whenitisnot.last manyoftheseprogramscanbeprobabilistic and sets of testing trials will be needed.
in this paper we present the first to the best of our knowledge testing framework for crns chemtest.
chemtest supports different types of test cases functional metamorphic internal and hyper .itformalizesrequirementsintoanltl likelanguageand thenbuildsabstract parameterized testcaseswhichcanbeinstantiatedforarangeofinputvalues.oracleprocessingisperformed at specific times on simulation traces of a crn simulator.
all tests are run multiple times to account for flakiness and multiple test trials are used for probabilistic programs.
in a large case study we evaluate crns of varying sizes and show that we can specify constraints and oracles for test re quirements all types of tests are effective in varying degrees and none outperform others on all mutants tests are dependenton time and test and mutant flakiness are inherent to the crns and must be accounted for.
the contributions of this work are an end to end approach for a new type of programming paradigm called chemtest a case study on different crns evaluating the need for different types of tests and theimportanceofinherenttestflakinessandprobabilistic outcomes inthenextsection wepresentmotivatingexamplesandbackgroundoncrns.insection3 wepresentchemtest.weconductacasestudyinsections4and5alongwithadiscussionandroadmap for interesting research directions in crn testing.
we end with related work section followed by conclusions and future work.
motivation and background chemicalreactionnetworks crns werefirstusedtomodelandan alyzechemicalreactionsover50yearsago .acrniscomposed ofasetofspecies sandasetofreactions roverthosespecies.a reactioniscomposedofasetofreactants leftsideofreaction asetofproducts rightsideofreaction andarateconstantthatdetermineshowfastthereactionproceeds.thelawofmass actionyields onecommonsemanticforcrnsandisdividedintotwovariants stochastic mass action and deterministic mass action semantics.
in thispaperweusestochasticmass actionsemanticswheremolecule counts are natural numbers and a markov process determines the state of the network.
theprobabilitiesaredeterminedbytherateconstantandproduct of the reactants.
a simple example illustrates these concepts most crnsaremuchmorecomplexthanthis.thecrnbelowconsists of two reactions.
x11 y x2 y1 null reaction converts species x1t oyat a rate proportional to theproductofthenumberof x1 sandtherateconstant1 andin reaction 1species yisremovedforevery x2inthesystem.this isasubtractionprogram x2issubtractedfrom x1andplacedin y thatweuseasoneofourstudysubjects.thisprogramcannot return negative values.
if x2 is larger than x1 it outputs zero y s. weshowatypicalsimulationenvironmentforthiscrnusing matlab s simbiology package in figure .
on the left part a we see the species at the top initialized with molecular concentrations we often just say molecules of and for x1 andx2 respectively.
ystartswithaconcentrationof0.thereactions r1 and r2 are on the bottom and the model is shown on the right.
on the right of this figure part b is a stochastic simulation of this crn.atthestart x1is10 while x2is5and yis0.at2simulation seconds both x1 andx2 have reduced to while yis now .
y is the output variable for this crn.
we note that x1 andx2a r e inputvariables butwecan alsoconsidertheminternal variables since their value is not needed to evaluate the functional outcome.
they are still important since in some cases a wrong internal state attheendcouldindicateafault weseethisinourcasestudy .this crn is a specific type of a crn which is called stable since all ofthereactionswillstoponce x1andx2havebeenfullyutilized andthecrnwillconvergetoasinglespecifiedstatewithprobability1.thustheprogramisdeterministiceventhoughthecrn proceedsinaprobabilisticfashion.othercrnsmaynotstabilize to a single terminating state and the program is expected to have aprobabilisticresult.weconsiderbothtypesofprogramsinthis work.
verifying crns the state of the art for verifying crns uses model checking to analyzespecificpropertiesinthestatespacegivena small fixed number of initial molecules for each species .
however asseenin onmanyrealprograms thiswillnotscale beyond to molecules.
the subtraction crn is relatively small thereforewecanmodelcheckitfor1000sofmolecules.thegoal of verification however is to evaluate potentially buggy programs.
if we add a single fault to this program it is possible it will change our ability to scale model checking on this crn.
in our case study severalofourmutantscausedamodelcheckertorunoutofmemory before it could build the initial model at concentrations of molecules.
on another crn the original correct crn was unable figure the subtraction crn encoded in matlab s simbiology package.
a shows the species x1 x2 andy.
this program willperformthesubtraction10 .
b showsastochasticsimulationwhereovertime.atthestart x1is10and x2is5 while yis zero.
at simulation seconds y the output stabilizes at the final result of .
to scale beyond molecules.
both instances allowed for 20g of memory.instead wecantestthecrn whichshouldscaletolarger concentrations buttothebestofourknowledgethereisnoexisting systematic method to do this.
.
challenges of testing crns to test a crn we first represent the crn in a simulation environment such as matlab s simbiology package visual gec or nuskell .
we also need to determine the input and output species a set of test requirements and test cases.
once the simulationisrun allofthespeciesstillholdsomevalue allspeciesare global sowewillneedtochecktheirendingvaluesifintegrated with other programs.
if we know the functional output which we do in this case we can perform traditional functional testing.
sincecrnsoftenmodelphysicalprocesses manyprogramshave no known oracles.
for instance the absence detector part of the molecularwatchdogtimer isacrnthatchecksforthelackof a signal heartbeat over a given time period.
for this crn we may need other types of tests such as metamorphic tests .
these are often used to reason about relationships between two different runs of a program when the exact oracle is unknown.
an example metamorphic test for subtraction is if the first test input x1 isgreaterthanthesecondtestinput x1 prime andx2remainsthe sameforboth thentheoutputin y primewillbesmallerthantheoutput iny.
although we do not specify what yis we know that the second output is smaller.
another need for metamorphic testing wouldbeintheabsenceofformalspecificationsorifwehavepartial requirements.
this may helpus bypass the need of acomplete set of functional tests.
in this work we support both functional and metamorphic tests.
inherent flakiness sincecrnsaredistributedsystemsbasedonthelawsofphysics we cannot control the order in which reactions fire hence there is no direct analogy to a threadin traditional concurrent programs .
thiscanimpacttheabilityofourteststodetectafaultandleadsto flaky tests.
we believe these are common in crns therefore we choose to accept that we can t fix them and mitigate the issue withmultipletestruns.anexamplefaultthatisdetectedflakilychanges subtraction reaction above to x1 y null.
this has the impact of reducing x1t oyand then using x1 to remove y. this is incorrectbehavior buttheoutputin yisdependentontheorderreactionsfire.inasmallpre studywefoundthisfaultlessthan50 of the time over ten test runs.
anotherincorrectcrnforsubtraction arandomfaultseeded in our study mutant has an additional third reaction null x2 x1 y that creates new molecules.
adding an additional reaction is a common mistake a crn programmer may make.
one of our tests which checks if subtraction works correctly when x2 x1 yshould be will be correct intermittently.
suppose westartwith x2 x1 .yalsoequals0atthestartofthe program.
the first two reactions original reactions will not fire sincethesearealreadycomplete.ho wever the thirdreactionisfree tofireatanypointintime.whenthisfiresthenewprogramstateis x2 x1 y .
reaction now can fire removing an x2 and ay x2 x1 y .
at this point yhas the correct value for the output and it would return a correct functional result.
but as other reactions continue to fire this will return to an incorrect state cycling between the correct and incorrect value.
thismutantwasfoundtobeflakyfor25 oftheinputvalueson this test case.
these are mostly large input values for x2 small valuesstabilizedquickly somethingthatwecannotknowaheadof time.wealsomustbecognizantofsimulationtime sinceevaluation before the crn stabilizes can also cause flakiness.
we address all of the issues raised in chemtest.
we allow for different types of tests functional metamorphic internal and use abstract tests instantiated with a broad range of concrete values.
we consider evaluations at different simulation times and run simulations tests multiple times.
we also support setsof tests or hyper tests that are needed to evaluate probabilistic outcomes.
chemtest we now present chemtest as shown in figure .
we begin with an existing crn program and a set of requirements or partial requirements .
we then formulate the test requirements using ltllikeproperties .thesepropertiesarethenusedtocreatedifferent types ofabstract test cases which define the input species and the oracle.
we use category partition in the current framework weimplement this with the test specification language tsl to generateconcretetestcases.theseareinformedbyconstraintsthat come from the properties and the input species.
we then perform testingusingastochasticsimulationengineand oracleprocessing andthefinaloutputistheresultoftesting.wedescribeeachpart of the process in more detail next.
partial system requirements test requirementtslcrn input species oracle output species concrete input simulation oracle processingconstraints abstract teststestingsimulation environment functional f metamorphic m internal i hyper metamorphic h iteration figure overview of chemtest.
chemtest starts with an existingcrnprogramand partial setofrequirements.weformalizetheseandusethepropertiestocreateabstracttestcases.wethengenerateconcretetestcases performsimula tions and process the oracle.
.
formalizing test requirements inordertogeneratetestcasesandtheiroracles weneedasetof requirementstotest.sincestochasticchemicalreactionnetworks aremodeledusingmarkovchains temporallogicisanaturalchoice.lineartemporallogic ltl isarichlogicthatclassifiesthepathsof a markov chain and is especially useful for our purposes.
the structure of an ltl formula can be defined recursively in the following backus naur form true a 1 2 x 1u 2. lineartemporallogicformulas specifyconstraintsoninfinite paths s1 s2 ... through a markov chain where each siis a state.
in equation ais anatomic proposition which evaluates to true if the first state s1of the path satisfies the proposition a x says that is true in the nextstate of i.e.
that s2 s3 ... satisfies and 1u 2says that 2eventually holds starting at some future state siand that 1holds for every state s1 ... si .
two commonly used operators are futuredefined by f trueu andgloballydefined by g f .
intuitively f is trueifthereexistsafuturestate sithatsatisfies andg istrueif every state siin the path satisfies .
in this work we use an ltl like notation adding some new operatorsspecifictocrns.weleavetheformalizationanddescription of this notation for elsewhere and instead describe important aspects of the notation as we go.
considerthesubtractioncrndefinedearlierbythereactionsin equations and whichtakesinputs x1andx2andproduces a number of ys equal to x1 x2.
many of our test oracles for subtractionrequirethatifthenumberof x1inputmoleculeschange thenthenumberof youtputmoleculeschangeaccordingly.one such test is as follows bracketleftbig x1 prime x1 bracketrightbig bracketleftbig x1 is even bracketrightbig fg bracketleftbig y prime y bracketrightbig .
thisisametamorphictestwhichcomparesthebehaviorofthecrn on two differentinputs.
wedenote one input with species x1 x2 and the other input with x1 prime x2 prime.
this requirement specifies that when the number of initial x1 molecules denoted by x1 i s increased by a specified amount then the output y primeof the crnwith more x1 molecules will eventually be always greater than y the one with fewer x1 molecules.
wemanuallycreatedthesespecificationforthiswork.weprovide additional information on this notation and all of our formalized specifications on our supplementary web page.
.
abstract test generation after we formalize test requirements we generate abstract test cases.
the input output species are determined by the crn.
a test requirementspecifies constraints leftsideofimplication and the oracle rightsideofimplication .wedefinefourtypesofabstract tests.
the first are functional tests f which use a single set ofinputs and have a known output.
an example functional test for subtraction is fg which has a constraint that x1 is greater than x2 at the start of the program.
the oracle states that ywill eventually always equal x1 x2.thesecondtypeofabstracttestsaremetamorphictests m which include two different input sets and are evaluated based ontherelationshipoftheoutputs.therequirementshowninequation is an example of a metamorphic test.
the third type of tests are internal tests i which check internal state of the crn is correct at the end of computation.
fg this test in equation tests the subtraction property when theinitialnumberofmoleculesin x2aregreaterthanin x1.we expect the value of molecules in x1 an internal variable to be zero when the computation is complete.
this is internal since itdoes not involve our output species y .
it is a stronger program oracle and is important as we move towards integration testing since other modules may depend on the state of this variable the hailstone subject from our study demonstrates an example of an internal parity species which is a likely candidate for use by other modules.
thelasttypeoftestsarehyper metamorphictestswhichwerefer to as simply hypertests h .
a hyper test consists of multiple runs of the same metamorphic test used for probabilistic programs such as approximate majority which is one ofthe crns we investigate inourcasestudy.hypertestsevaluatetheresultofmetamorphic tests over some number of runs.
an example of a hyper test is .
this test requirement states that if the number of x2 molecules is increased then x1 wins less frequently.
since approximate majority is an algorithm that determines which of two species has greater initial population by converting all molecules to a single species we use x1 wins as shorthand to describe that species x1 has completely annihilated the population of x2 and therefore has the majority.
the operator counts the number of times the oracle is satisfied over many simulations of the crn on that input.
.
concrete test generation weuseconstraintsfromthetestrequirementsandtheinputspecies togenerateconcreteinputsusingtsl.eachabstracttesthasone 551or more concrete test cases that partition its valid test space.
as an example in subtraction and can be concrete values for x1 and x2.
we use partitions that include large small even odd etc.
our tsl is provided on the supplementary website.
.
simulation wesimulateall ofthe crnsusinga stochasticsimulatorsuch as matlab s simbiology environment .
we run each test ntimes a parameter of our testing process .
in our study we use for n. wealsoselectasimulationtime relativetimeusedbythesimulator .
this may vary based on the crn see rq2 and is important to allowthecrntostabilize.wecollecttracesfromthesimulationto useintheoracle.forthehypertestsweruneachofour niterations ttimes.
in our study we use for t. .
oracle processing last we evaluate the results of checking each test requirement against the system traces.we implemented a library to check properties against the simulation traces.
we first read the full trace and examinetheprogramstatefor eachtimeinterval.thisiscomputationallyexpensive butcomplete.forthemetamorphictestswe evaluate two traces the two differentinput simulations together andforhypertestsweruntheanalysisonpairsofsimulations t times and count the number of times the requirement holds.
we notethatour futureglobally operatormayfailpastthetimethatwe areevaluating butweassumethecorrectnesswithintheevaluation time.
case study we evaluate several facets of chemtest.
supplemental data for our experiments are found on our supplementary website.1we ask the following three research questions in this study.
the first question focuses on chemtest s core effectiveness rq1.
how effective is chemtest at fault detection?
as part of this question we ask how well chemtest scales by comparing it against the state of the art model checking.
the next two questions focus on unique aspects of crnsrq2.
what is the impact of time on simulations?rq3.howdothestochasticandprobabilisticaspectsofcrnsimpact test results?
.
objects of study wehaveselectedthreecommonlyusedcrnstostudyinthispaper.
thefirsttwoareoftenusedtoillustratecrnbehavior.thethird subjecthasbeenusedinmanyresearchpapers .thefirst subtraction is a simple crn only two reactions and species that has an obvious functional output.
the second hailstone is morecomplicatedwith11reactionsand11species.thethirdisa commoncrn approximatemajority describedearlier thathasa probabilistic output.
it returns the correct result a large percentage of time but is not guaranteed to always converge on the same answer.
this has only reactions and species.
table shows the reactions for each of these programs.
we describe each in more detail below.
thiscrncomputes f n1 n2 n1 n2usinginput speciesx1 x2and outputspecies y. however since crnscannot havenegativemolecule counts the crn outputs if n1 n2.
hailstone.
this crn computes the hailstone function f n braceleftbigg n ifnis even 3n ifnis odd using input species x1 and output species y. approximate majority.
this crn models a probabilistic algorithm that is used in nature to make binary decisions such asthe cell cycle switch.
it will quickly decide which of two species has more molecules.
given an initial population of x1 andx2 the algorithmoutputsitsdecisionbyconvertingthetotalpopulation ofmoleculestothespecieswiththeinitialmajority.both x1and x2 are outputs.
table reactions defining subject programs subtraction s hailstone h approximate majority am x1 y x1 po h m x1 x2 u x1 x2 y nullpo po pe x1 u x1 x1 pe po po x2 u x2 x2 pe pe pe x1 x2 u x2 h h d m 3b 6a 2b 2a null pe d pe ce y po a po co y ce po y po d co pe y pe a .
fault seeding since we don t have an existing bug repository of faulty crns we generaterandomprogrammutants i.e.weusemutationtesting .
program mutants have been shown to be similar to common types offaultsintraditionalprograms .whilewecannotguarantee thesearerealisticand orsufficient wegeneratemutantsthatare first ordermutants i.e.
singlechanges and haverestricted them to similar types of faults we have seen in the crn programs we have studied.
the mutants are generated as follows.
for each mutant we randomly select a reaction and randomly select from a set of high level operations add a new reaction remove a reaction change a reaction.
to add a new reaction we select from one of templates up to three reactants and three products andthen for each of the species we assign a valid species from theprogram at random .
to change a reaction we choose to eitheradd a product reactant remove a product reactant or change an existing product reactant to a different species from that crn.
we generated random mutants for each subject.
for approximatemajority oneofthemutantsimulationstimedoutafter4days of runtime therefore it was removed.we also restricted thetypes of reaction modifications for approximate majority to preserve the existence of two reactants in all cases because this changes the rate aparameterofsimulation andwediscoveredthatsimbiology does not correctly handle different rates its default is .
this was 552not an issue for other subjects since they are stable crns.
table showsthemutantsforeachsubjectbynumber.thechanged added reaction is shown followed by a reaction number.
if the number is larger than the number of reactions in the original crn e.g.subtraction m1 this means a new reaction is added.
all others represent changes and or removals.
.
chemtest implementation we manually created program requirements which formed our abstracttestcases.thesecanbefoundonourwebsite.wegenerate concrete test cases for all abstract test cases using tsl to definepartitions for each crn such as even odd large small guidedby test requirement constraints.
since some of our abstract testshave constraints such as x1 x2 each set of abstract tests has a different number of concrete tests.
for all crns we used 200as the maximum input value for a single species.
in some of our metamorphictests thesecondtracerequiredaspeciesthatislarger by a factor e.g.
test number for hailstone hence our largest input population can be as high as molecules.
werunallconcretetests100times.ifaconcretetesthasasingle trace i.e.functional internal wehave100tracesforthetestcase.inthecaseofmetamorphicteststherearetwotracesforeachconcretetest hencewehave200traces.forthehyper metamorphictestswerepeatourtests10times thereforewehave1000testrunsand2000traces 2tracesforeachtest .werunalltests noninteractively ona heterogeneous computation cluster with an allocation of 20gb ofram intelcpuwithfrequenciesfrom2.
.5ghzandutilizinga single processor core running red hat linux and mabtlab2019a version r2019a io4754x.
all rate constants are kept at for all reactions in the subjects of this study.
after simulation we run the evaluation script on the generated simulation traces.
the oracle processing is done using a python script.itevaluatesthepropertiesonthecrnsimulation returning for each trace iteration whether or not the property holds.
.
flakiness metrics we define the metrics used to differentiate deterministic and flaky tests and mutants in rq3.
deterministic flaky concrete test a concrete test is deterministic if itfailsonall nsimulationtracesduringoracleprocessingandis flakyif it fails on at least one but not all ntraces.
deterministic flaky mixed abstract test an abstract test is deterministicif all of its concrete tests are deterministic is flakyif all ofitscorrespondingconcretetestsareflaky andis mixedithasa combination of deterministic and flaky concrete tests.
deterministic flaky mixedmutant amutantis deterministic ifevery test that finds it is deterministic is flakyif every test that it finds it isflaky and mixediftherearebothdeterministicandflakyfailures.
.
threats to validity we outline the most important threats to validity here.
with respecttoexternalvalidity generalization weonlyusedthreecrns.
however weusedcrnsthathavedifferentcharacteristics used fordifferentpurposes.wealsoranallofoursimulationsusingmat lab ssimbiologypackage.wedid however keeporacleprocessingas a separate program so that this can be used on alternative types ofsimulationtraces.whilewebelievethatchemtestwillworkfor otherstochasticsimulationengines weleavethisasfuturework.
with respect to internal validity the authors of this paper wrote therequirementsdefinitions.wetriedtousecommonproperties of the systems we were testing but we cannot be sure that they are complete and orrepresentative of what other smight develop.
we leave automated test generation from the crn model itself as futurework.allofouranalysisusedautomatedprogramswhich could have faults themselves.
we selected subsets of our data to validate by hand and examined multiple individual faults in depth.
we have also provide artifacts for this work on an external website for others to re validate.
with respect to construct validity the use of correct metrics we acknowledge there may be better metrics touse butwe chosestandard metrics such asfault detectionand runtime used in testing.
results in thissection wepresent the resultsof eachof our researchquestions.wefollowwithadiscussionofsomeinterestingobservations and end with a roadmap for the future of crn testing.
.
rq1 how effective is chemtest at fault detection?
table shows testing results for the subtraction top and hailstone subjects bottom .
table shows data for the approximate majoritysubject.thefirstcolumnistheabstracttestid thesecond is the number of concrete tests generated for that test.
the next columnstatesthetesttypewhere f meansfunctional m means metamorphic i meansinternal and h meanshypertest.thecolumns represent individual mutations for subtraction andhailstone and for approximate majority .
each test id has two rows.
the first unshaded is the percent of failing tests that fail on all runs i.e.
deterministic .
the second shaded row indicates the percent of failed tests that fail in at least one but not all ofthe runs i.e.
flaky .
the sum of the two rows indicates thepercent of tests failing for that abstract test.
for example in the firstrowofsubtraction weseethatthisisafunctionalabstracttest with concrete tests.
for mutation of the abstract tests fail deterministically and none are flaky.
on the other hand for mutation3 .
areflaky aredeterministic thetotaldetection rate is .
.
both of these mutants are easily detectable with this functional test however for mutation the concrete test plays a biggerrole.itispossibletomissthefaultdependingontheinput and number of runs.
overall we can see that all mutants except subtraction mutation are detected.
we examined mutation and determined it isanequivalentmutation henceweremovethisfromtherestof the analyses i.e.
rq2 and rq3 .
however mutation did cause performanceproblemsduringoursimulationssinceitiscreating additional unneeded reactions accounting for of the simu lationtimeattime100.forsubtraction allmutantsarefoundbya mixture of functional metamorphic and internal tests and are found both deterministically and flakily.
forhailstone mutation1isonlyfoundbyasinglefunctionaltest however allthreeconcretetestsdetectthefaultdeterministically.
553table mutants by subject.
for each subject the changed reaction r and reaction number is given.
s change r h change r am change r s1x1 x1 x23 h12b 3a null 7a1x1 x2 u x2 u4 s2y y 3h2m h 12a2removed s3x1 y null 2h3ce 3b 6a 6a3x1 x2 u u s4x1 x2 y null3h4ce po y null 12a4removed s5removed 1h5n a 4a5x2 x1 x2 x23 s6x2 y x1 null2h6x1 po h 1a6x1 x2 u u x24 s7y null 2h7co pe y a 11a7x1 x2 u x1 u1 s8null x2 x1 y3h8po a y po co y9a8x1 u null s9y x2 x23 h92b 2a po null 7a9u u x1 x12 s10x2 null 2h10co pe y ce pe a11 mutation is only found by an internal test.
mutation is only foundbyoneofthefunctionaltests butmultiplemetamorphictests this pattern is reversed in other mutants .
one of the functional testsdoesnotfindanyofthemutants andnotestfindsallmutants.
nextweturntotheapproximatemajority .sincethisis probabilistic weexpect somefailuresinthe originalprogram.we include an additional column column labeled o which is the original non mutatedcrn.inalltests weonlyseeflakyfailures.
for most of the mutations the mutants fail at a higher rate than the original in at least some tests.
wenowlookattheruntimesfortheexperiments.wecapture the runtime for all simulations of each concrete test and the time taken to evaluate the oracle.
this data is presented in table .
weincludethedataforsubtractionmutation2inthiscalculation.
for subtraction the simulation time took .
hours andthe oracle analysis took .
hours.
for hailstone this is .
hours and .
hoursrespectively.forapproximatemajority thetimesroseto15.
daysand42.2days.overall thematlabsimulationtimeaccounts for of the total testing time thus the majority of the testing timewasduetooracleprocessingonthesimulationdata.partofthe reason for the long oracle processing was due to the i o needed to processthelarge uncompressed simulationfiles.anotherreasonisthatouroracleprocessinglibrarywaswritteninpythonandoneoftheltl likeoperatorsusedaninefficientpythonloop.performance profiling revealed that the bottleneck was this loop and can be optimizedbyrewritingthelibraryinalanguagelikec.asfuture workwe planto optimizetheanalysis partof thisstudy andbuild theoracleprocessingdirectlyinmatlab.allthedatacollectedin thisstudy whichinvolvesadditionalprocessingoftheoraclesfor different time slots in rq2 and rq3 have used from .
days to .4days.overall theexperimentsrunrepresentapproximatelya year of machine time .
days of which is simulation time.scalability.
we compare against the current state of the art in validating crns model checking.
we selected the probabilistic symbolic pr modelchecker version4.
.prhaspreviously beenusedtoevaluatecrns .sincethefirststepofmodelchecking buildingthemodel isrequiredtoevaluateindividualproperties we focus on this step.
likewise we focus on the simulation and trace collection phase of chemtest for all concrete tests.
it should benotedthatbothmodelcheckingandchemtestcanevaluatemultiplepropertiesonthesamemodelortracerespectively.weused the default configuration of pr except for the cudd memory.
we setthisparameter cuddmaxmem to20gtogiveitafairchance.thistable percent of failing test cases by mutant.
id is the abstract test number nt is the number of concrete tests ttis the type of test f functional m metamorphic i internal.columns represent mutations.
idnttt12345678910 subtraction 146f87.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
240f0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
340m0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
440m75.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
540m85.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
640m55.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
746m0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
840i0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
940i55.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
hailstone 17f0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23f100.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
31f0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
46m0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
57m0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
63m0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
73m0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
89i0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
554table percent of mutants found by test case for approx.
majority.idistheabstracttestnumber ntistheno.ofconcretetests ttistesttype f functional i internal h hyper.columns are mutations.
idnttto123456789 1190f0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
2190f0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3183f0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4183i0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
5183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
6183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
7183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
8183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
10183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
11183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
12183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
13183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
14183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
15183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
16183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
18183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
19183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
20183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
21183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
22183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
24183h0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
iscomparablewiththe 20gofmemoryweusedtorunchemtest experiments.wegavepr21gboframtoaccountforoverhead andusethesamecomputingclusteraschemtest.weusetwoof our crns subtraction and hailstone.
for subtraction we startedtable runtime data.
total runtime for simulations sim forallconcretetests timetocalculatetheoracle oracle .
times in hours h or days h subjects simoracle total simtot.
exp.
times s .2h24.6h29.8h .
.4d h .3h16.8h22.1h .
.5d am .0d .2d57.2d .
.4d withaninputsize40andscaledupto10k.forhailstoneweconstructthemodelstartingat10molecules increasingby10to100 where model checking regularly fails.
we run for all mutants for each programsand record thetime taken tobuild the models or run the chemtest simulations .
we used a hour timeout for both pr and chemtest.
table shows a subset of the results the rest is on our website .
the rows represent input sizes and the columns are the mutant programs.
the first column o is the original crn.
for each we showtheresultsinseconds minutes m orhours h foreachpr pr and chemtest ct .
as we see in subtraction pr is faster at small input sizes but is not able to scale to 10k molecules in8 of the mutants.
in hailstone pr fails to build a model for 10of11modelswithaninputof100molecules demonstratinga lossofscalabilityonmorecomplexcrns.weexploredhailstone mutation further.
the largest input it handled has molecules and consists of .
billion states and billion transitions.summary of rq1.
all four test types metamorphic internal and hyper tests are effective at finding faults.
every mutation wasidentified by at least one test type and the majority were found bymultipletesttypes.wealsoseeamixtureofdeterministicand flaky detection across the various types of tests.
with respect to scalability wesee that wecan collect test tracesin minutes while pr fails to build models for larger molecule counts.
.
rq2.
what is the impact of simulation time on test results in chemtest?
forthisrqwelookatfailuresatsimulationintervalsforsubtraction and hailstone.
approximate majority is on our website and shows similarresults.weevaluatetheoracleattime2 and100 thetimeusedinrq1 .thesetimesareinternalmatlab simulation times and not relative simulation runtimes i.e.
the time chosen may have little impact on the practical runtimes however itcanimpactthelengthofthetracesforanalysisifwedonotallow the simulation to run long enough.
figure3showsthetimedataasboxplotsfortwoofoursubjects.
foreachtimeinterval x axis weplotthenumberoffailingconcretetestcasespermutation.afailuremeansthetestfailedatleastonceforamutation thisconsidersbothflakyanddeterministicfailures .
the red line is the original correct crn.
in all cases at time the original crn is appearing faulty since it has not yet converged on an answer.
over time this converges to zero failures.
the box plots show that the number of failing tests drop over time and stabilize.
we break out the deterministic and faulty failures in rq3.
summaryof rq2.
weconcludethatsimulationtimeisveryimportant.
all three subjects are unstable early on but converge at some point in time.
555table left is prism model checker pr right is time to run all tests in chemtest ct .
timeout of hrs with gb of memory.
times in seconds unless noted minutes m hours h .
m is a memory error and t is a time out.
inputsubtraction s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 prctprctprctprctprctprctprctprctprctprctprct .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
m16.
.
.
.
.
.
.
.
.
.
.
.
.
.
m14.
.
.
.
m13.
.
.
.
m23.
.
.
.
.
.
.
.
.
.
.
.
.
.
m15.
.
.
.
m15.
.
.
.
m23.
.
.
.
.
1k14.
.
.
.
.
.
.
.
.9m16.
.
.
.9m15.
.
.
.7m26.
.
.
.
.
2k1.3m24.
.6m19.
.3m17.
.
.5m23.
.
.2m22.
.
.
.6h38.
.6m36.
.
.
3k3.
m25.
.
m15.
.
m28.
.
.8m31.
.
.4m29.
.
.5t48.
.
m48.
.
m45.
4k5.9m33.
.0m19.
.3m2.6m1.8m50.4m36.
.
.4m36.
.
.1t58.
.9m57.
.5m1.0m 5k11.
m41.
.
m22.
.
m41.
.
m56.5m42.
.
.3m41.
.
m1.
mt1.
m24.
m1.
m9.
m1.
m 6k16.3m50.
.5m29.
.0m49.
.6m1.1mm51.
.
.5m48.
.0m1.4mt1.3m22.4m1.4m10.2m1.4m 7k25.
m58.
.
m2.
m28.
m57.
.
m1.
mm55.
.
.5m57.
.
m1.
mt1.
mm1.
m13.
m1.
m 8k29.3m1.2m1.8h42.
.3m5.2m11.1m1.3mm1.2m1.5m7.9m1.1m3.7m1.8mt1.9mm1.8m17.5m1.7m 9km1.
mm47.8m1.
m25.
m1.
mm60.
.
m9.3m58.
.
m1.
mt1.
mm1.
m23.
m1.
m 10km1.4mm2.7mm2.5mm1.6mm1.2m2.2m13.2m1.2m6.4m2.1mt2.0mm2.0m31.2m2.0m inputhailstone h0 h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 prctprctprctprctprctprctprctprctprctprctprct .6m27.
.
.
.6m22.
.
.
.
.
.
.
.
.
.
.
.
.
.4m9.
.8m2.2m .3m50.
.0m40.
.1m41.
.
.2m8.4m19.
.4m4.5m12.
.
.4m12.
.7m16.
.1m9.
.8m13.
.
m1.
m24.
m59.4m1.
m4.
m19.
.
m30.
.
m1.
m15.
.
.
m27.
.
m23.
.
h12.
.
m2.
m .5h3.9m2.2h3.1mm1.6m7.9m26.6m48.
.9h1.5m30.
.
.2h2.4m3.9h33.6m15.
.3h24.
50m2.
mm1.
mm2.
m55.
m34.
.
m2.
mm4.
m42.
.
.
h2.
mm38.1m19.0t30.
60m3.3mm2.2mt2.6mm42.5m5.2mm4.8m38.
.5mt32.8t45.7m29.2t38.
70m4mm2.
mt5.
mm51.2m1.
mm9.
m1.
m36.7t40.2t3.
mm26.3t41.
80m6.8mm5.2mm3.8mm3.0mm1.6mm4.4m1.6m47.1m42.7m3.1mm2.5t53.
90t7.
mt5.
mt6.
mm1.
mm5.
mm8.
m2.
m57.5m53.2t3.
mm33.6t52.
100m6.2mt4.4mt5.1mm3.3mm2.2mm7.7m3.5m59.2m52.8t1.2mm45.7t3.1m .
rq3.
how do the stochastic and probabilistic aspects of crns impact test results?
if we return to table and we see a mix of tests failing either deterministically or flakily.
in this question we look at this data from another angle.
table breaks out the data by each subject as follows.
it shows those abstract tests followed by concrete testsin parentheses that are deterministic only flaky only or mixed.
all data is taken at simulation seconds.
these are mutually exclusive categories.
for instance in subtraction zero abstract tests are always deterministic but concrete test case are.
again zero abstract tests are flaky while concrete tests are always flaky.last all of the abstract tests are always mixed some flaky some deterministic with224concretetestcasesfallingintothiscategory.
we also can determine from this data that concrete tests failed atleastonceinthisstudy.forthemajorityoftestcases flakiness is dependent on the mutant that is being tested.
the second line of thistableshowsthatforsubtraction 3mutantsarealwaysfound deterministically nonearealwaysflaky andthat6haveamixed behavior.
there is only one mutant in hailstone that is alwaysflaky.
in approximate majority none of the mutants are always deterministic and or always flaky.table7 no.ofdeterministic flakyandmixedtestcasesand mutants by subject subtraction s hailstone h and ap proximate majority am .
tests are listed as both abstract abs and concrete conc.
in parentheses.
subject type determ.
flaky mixed abs conc abs conc abs conc s test mutant h test mutant am test mutant we now return to the time data to see how determinism and flakiness impacts fault detection over time.
we use the subtraction andhailstone data.figure4 showssubtraction top andhailstone by time for deterministic only faults and flaky only faults.
these graphsarethesameasthosefromrq2 butsplitoutbycategory.in subtractionthenumberoftestsfailing deterministicallyincreases over time while the number failing flakily decreases.
in hailstone we see an initially higher deterministic set of failing tests followed byadecreaseandfinallyweseeanincreaseasthecrnstabilizes.
simulation timeno.
o f failing tests of original crn simulation timeno.
o f failing tests of original crn figure subtraction hailstone faults over time.
the flaky tests also reduce over time.
this suggests that some of the flakiness we see is due to simulation time.
while we believe that we ran our crns long enough simulation seconds for alltostabilize wecan t ofcoursebesure.wedobelievethatthe reasonsforflakinessgobeyondtime.wedescribesomeexamples of flaky tests mutants in our discussion section.summary of rq3.
we conclude that stochasticness plays a big role in testing crns.
we have built in iterations repetitions for this study .
.
discussion inthissectionweinvestigatecrnmutationbehaviorinmoredetail using two of the crns from this study.hailstone h5mutation removes the reaction pe pe pereactionfromthecrn.thisisaninterestingmutationsinceithasnoeffectonthefunctionalbehavior butviolatesthespecification.this is directly tested by the crn oracle property fg which says that eventually there is always only one of poorpe molecule in the system however the mutation allows multiple pe moleculesto accumulatewhenthecrn terminates.thisaccumulation ofpemolecules only occurs on even inputs.
evenwhentheinputisevenandtheaccumulationof pemolecules couldhappen theorderofreactionsthatfiremaymasktheerror in the mutation.
for example if all the firings of the reactions po pe poandpo po pealternate thenumbersof pe molecules whenthe crn stabilizes willbe eventhough there is nope pe pereactionpossible.however adifferentsequence of reactions can result in multiple pemolecules when the crn terminates.
the hailstone h5 mutation is never detected by odd inputs and only detected less than of the time on even inputs andonlyonasingletestthatutilizedinternalspecies internaltest .inaddition thiscrnisdesignedandconstructedusingcrnsubcomponents e.g.
thethreereactionsthatcomputeparitycontrol a multiplexer to decide if the output is n 1o rn .
while the parity crn was flawed but had no effect on the functional output this is not always the case.
if the parity crn is utilized in other systemswhereitiscriticalthatonlyasingle peorpomoleculebe present at the end of the computation this other system would fail.
approximatemajoritya3mutation highlightstheprobabilistic nature of this crn how this manifests as flakiness and how it canfooloracles.thefirstreactionismutatedsothespecies x1is replacedbythespecies u.theeffectofthisontheoverallsystem gives a slight unfair advantage to species x2.
depending on the input this can fool hyper tests.
abstract test on with concrete inputx1 11andx2 12onlyfailstwiceoutof100runs.abstract test states that if x2 has an advantage x2 x1 thenx2 should win.comparethisresultwiththatofthecorrectamcrnwhereit fails times on the same input.
the reason is that the am crn on equal inputs should yield x1 wins percent of the time and as the difference between x1 andx2 increases with x2 x1 this frequency decreases.
with this mutation x2 is helped and thus returns the correct majority species with better frequency.
.
a roadmap for the future of crn testing in this paper we have presented an initial framework for crn testing.wehaveobservedmanyinterestingfuturedirectionsthat we summarize briefly here.automatedspecificationsandtestcases.
wemanuallycreated the specifications and test cases for our crns.
we see many oppor tunities for automated generation both partial and complete from the crn models.crn flakiness.
as demonstrated test flakiness is an inherent part of chemtest.
we ran all tests times in our experiments to ensureourresultswerevalid.however webelievethatitispossibletodetermineasufficientnumberofiterationsfortesting.thetopicofflakinessanditsrelationtoflakinessintraditionalenvironments is an open and interesting question.mutation operators.
in this work we used mutation testing to evaluatethequalityofourtestcases.recentresearchonconcurrent andflakymutationtesting suggeststhatmutationtesting should be customized for this new environment.
while we haveseen some interesting faults that are similar to those which wehave observed in our own programs a set of sufficient mutation operators and a theory of mutation testing for crns is needed.performance optimization.
inthisworkourfocuswasoncorrectness however someoftheoracleevaluationwasresourceintensive.
better algorithms to improve this aspect of chemtest including the evaluation of partial traces and states of the ltl operators areneeded.simulation parameters.
several of our simulation parameters were chosen based on simple heuristics.
the best threshold for considering parameters such as simulation time with respect to the input size or other characteristics of the crn warrants further investigation.thesemaybedeterminedbyboththeoreticalanalysis and experimental tuning.
simulation timeno.
o f failing tests of original crn simulation timeno.
o f failing tests of original crn simulation time simulation timeno.
o f failing tests of original crn simulation time simulation timeno.
o f failing tests of original crn figure faults found over time deterministic versus flaky related work there has been considerable research on defining and programming crns for various tasks including the development of languages that can be compiled down to crns .
we focusprimarilyonvalidatingthecorrectnessofcrns.thestateof the art is to use model checking or automated theorem proving .crnscanbemodeledasdeterministic using systems of differential equations concurrent and probabilistic usingcontinuoustimemarkovmodel systems .wefocus on stochastic crns which are both concurrent and probabilistic.
thereisabodyofworkinconcurrenttesting .we don t attempt to reference it all here since it is geared towards traditionalcodingconstructs.someworkanalyzingconcurrencyat thenanoscaleusingcrnshasalsobeeninvestigated see for example .inourwork thephysicalpropertiesofthemodeldrive thetestinganddonotexplicitlychangetheorderoffiringreactions.
whilelockingmechanisms canbeachievedby programdesignin crns it is important to note that these systems are themselvescrns the underlying physics in these systems are not changed.
thecrnmodelisalsorelatedtothestandardpetrinetmodelwhich iswidelystudied .however thecrnmodelwhichdefinesacontinuoustimemarkovmodelrequiresembellishmentstothepetri netmodel.petrinetscanbeusedtoautomatetestgeneration but wedo notexplorethat here.instead weutilizeour ownltl like temporal logic which is natural for the expression of test oracles.
therehasbeenresearchontestflakiness see as asample however muchofthatworkfocusesonprogramming constructs in traditional programming languages.
we use the same notionofflakiness butweexplicitlyexpectandsupportthisphenomenon.last therehasbeenresearchonprobabilisticprogramming .
some crns are probabilistic and chemtestsupports that construct but is not specifically about solving probabilistic programming problems.
conclusions and future work wepresentedchemtestanendtoendtestingframeworkforchemicalreactionnetworks.chemtestformalizestestrequirementsinanltl likelanguageandusesthistospecifyconstraintsontheinputsandabstracttests.itsupportsfunctional metamorphic internaland hyper tests.
simulations are run multiple times to handle flakiness.
inacasestudyweseeonaveragethatfunctionaltestsfind66.
of the mutants while metamorphic test find .
.
the internal and hyper tests find .
and .
respectively.
in addition time of evaluation impacts fault detection.
none of our abstract testsare fully deterministic and are flaky across all concrete test inputs.infutureworkweplantoapplychemtesttomorecomplex crnssuchasthosewhichrequireallmetamorphictests integration across multiple crn units and other probabilistic programs.
wealsowilloptimizetheoracleprocessingwhichwasabottleneck in this study and build chemtest directly into matlab.