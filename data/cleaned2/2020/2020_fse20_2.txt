understanding build issue resolution in practice symptoms and fix patterns yiling lou hcst cs peking university beijing china yiling.lou pku.edu.cnzhenpeng chen hcst cs peking university beijing china czp pku.edu.cnyanbin cao hcst cs peking university beijing china caoyanbin pku.edu.cn dan hao hcst cs peking university beijing china haodan pku.edu.cnlu zhang hcst cs peking university beijing china zhanglucs pku.edu.cn abstract build systems are essential for modern software maintenance and development while build failures occur frequently across software systems inducing non negligible costs in development activities.
build failure resolution is a challenging problem and multiple studies have demonstrated that developers spend non trivial time in resolving encountered build failures to relieve manual efforts automated resolution techniques are emerging recently which are promising but still limitedly effective.
understanding how build failures are resolved in practice can provide guidelines for both developers and researchers on build issue resolution.
therefore this work presents a comprehensive study of fix patterns in practical build failures.
specifically we study build issues of three popular build systems maven ant and gradle from stack overflow construct a fine granularity taxonomy of categories regarding to the failure symptoms and summarize the fix patterns for different failure types.
our key findings reveal that build issues stretch over a wide spectrum of symptoms .
of the build issues are fixed by modifying the build script code related to plugins and dependencies and there are symptom categories more than half of whose build issues can be fixed by specific patterns.
furthermore we also address the challenges in applying non intuitive or simplistic fix patterns for developers.
ccs concepts software and its engineering software testing and debugging .
keywords build systems build failure resolution empirical study corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa association for computing machinery.
acm isbn .
.
.
.
reference format yiling lou zhenpeng chen yanbin cao dan hao and lu zhang.
.
understanding build issue resolution in practice symptoms and fix patterns.
inproceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
introduction build systems play an essential role in modern software development facilitating developers build activities by automatically transforming source code to executable software.
meanwhile build failures occur frequently both in commercial and open source software systems and postpone software development activities with non negligible costs .
multiple previous studies show that developers spend non trivial efforts in resolving their encountered build failures.
to facilitate manual resolution studies on automated build failure fixing are emerging in recent years.
for example al kofahi et al.
proposed a fault localization approach for makefiles based on dynamic execution trace analysis lou et al.
utilized program analysis and search based strategies to fix general type build failures.
although promising existing automated techniques have been shown to have limited effectiveness in practice especially for general type build failures and the stateof the art technique can fix only a small ratio of build failures i.e.
.
to provide developers and researchers with practical guidelines on this challenging problem understanding how build failures are resolved by developers in practice is helpful.
fortunately two recent studies have shed some light on this problem.
zhang et al.
studied fix patterns in compiler errors in build process macho et al.
investigated frequent resolution patterns in dependency related build failures.
however both studies target at only a specific failure type leaving many other categories of build failures unexplored.
so far there is no comprehensive understanding of fix patterns across different types of build failures.
therefore in this paper we conduct a comprehensive study on general build failures considering both symptoms and fix patterns.
we collect a dataset of stack overflow so posts related to build issues in three mainstream java build systems maven gradle andant .
based on the dataset we manually summarize build failure symptoms and fix patterns from so questionesec fse november virtual event usa yiling lou zhenpeng chen yanbin cao dan hao and lu zhang descriptions and accepted answers we also distill frequent topics from how to questions to show the build knowledge that developers lack.
we focus our study on the following questions that we believe could provide insights for developers and researchers.
rq1 topics in how to questions.
how to questions present the build knowledge that developers are inexpert at which tend to induce future build failures.
by studying frequent topics in how to questions we uncover the difficulties that developers face in configuring their builds and the vulnerabilities that should be addressed by automated tools and techniques.
rq2 symptoms of build failures.
by constructing a comprehensive taxonomy of build failure symptoms we suggest frequent failure types and the symptoms neglected by previous work which should be addressed by the future study.
rq3 fix patterns of build failures.
by studying fix patterns in each symptom category we summarize their characteristics and commonalities and provide insights for both developers and researchers about principled ways in build failure resolution.
our main findings reveal a high diversity in build issue symptoms i.e.
categories and most .
build issues are related todependency resolution parse output execution compilation and assemble widely covering different symptom categories moreover output execution covers .
of the build issues which are often neglected by previous studies.
we also find that .
build issues are fixed by patterns applied in build script code related to plugins and dependencies among which the most two frequent patterns are correcting plugin setting and adding missing dependency besides for symptom categories more than half of their build issues can be fixed by specific patterns.
in addition we discuss the challenges in applying non intuitive and simplistic fix patterns.
the summary of all findings and implications is listed in table .
as the first comprehensive study on build issue resolution this paper makes the following contributions revealing the difficult build topics for developers which may become vulnerabilities for inducing future build failures.
constructing a fine granularity and comprehensive taxonomy of build failure symptoms via manual classification which facilitates the fixing pattern analysis for build failures.
summarizing fixing patterns for different build failure symptoms with practical guidelines for developers and researchers in build failure resolution domain.
background build systems are responsible for transforming project source code into a collection of deliverables e.g.
executable software or distributable library .
with the increasing demand on the building process build systems become more complex by including various functionalities besides the basic ones e.g.
compile or assemble .
for example static code analysis code coverage collection and mutation testing can be integrated into the build process via thirdparty plugins.
to facilitate the understanding of such complex build systems we draw figure to present the build workflow by summarizing the commonalities of mainstream java build systems maven ant and gradle .
components.
build system leads the entire build process following developers instructions.
the inputs of build process usually buildscript source code resourcerepository buildsysteminput outputcode analysis4.
prepare2.resolve dependency3.resolve plugin5.compiletask1.
parsedependency plugin environmentide os runtime environment software executable distributablesoftwarecompileassembledocumentresourceprocesstestfigure build workflow consist of build script source code and resource while the output is assembled software in a distributable or executable format such as jar ear war or apk.
more specifically a build script is a collection of developers instructions written in a script language which varies among different build systems.
for example gradle requires a build script written in groovy dsl while a maven script is written in xml format.
the resource refers to the artifacts necessary for the build process e.g.
images .
as for the other required non local artifacts e.g.
dependencies or plugins the build system downloads them from external repositories.
besides a successful build process also relies on the build environment referring to the operation system run time environment e.g.
memory network setting or other installed software.
we include ide in the build process since besides command lines build tasks can also be invoked in ide.
build process is associated with these components and thus build failures may come from any of them or their interaction.
workflow.
once the build system is launched it first parses and validates the input build script e.g.
checks syntax and resolves properties defined in the script code .
then build system prepares the required dependencies and plugins by downloading them from specified location e.g.
central remote local repository .
the subsequent build process is a sequence of build tasks and each of them is actually an invocation of certain plugin.
for example maven utilizes the plugin maven compiler plugin to perform compilation task and the maven deploy plugin to deploy distributable outputs gradle is capable of building android applications with various extended functions in the plugin android.
various build tasks are shown in figure such as test code analysis and document generation tasks of compilation and resource preparation are also based on plugin invocations but they are put outside the box since they are common build tasks and often invoked by default.
after all the build tasks finish besides the by product e.g.
reports generated by specific plugins the main output e.g.
an executable project is available for execution or distribution.
we regard a build as successful only when the workflow finishes without interruption and all the tasks and outputs behave as developers expectation otherwise we consider it as a build failure.
methodology to understand how developers resolve build issues we analyze the build related posts on stack overflow so .
figure illustrates the overview of the methodology used in our study.understanding build issue resolution in practice symptoms and fix patterns esec fse november virtual event usa table summary of findings and implications findings about how to build issues implications f.1developers ask a wide range high level categories of how to topics on build systems and grammar .
common tasks .
i o .
dependencies .
and command line .
are asked most frequently.i.1the frequently asked how to topics imply the vulnerable components in a build script which may be given priority attention for build failure detection and fix techniques.
f.2most .
questions are about build script programming and some developers complain about limited help from documents and tutorials.i.2the documentation of plugins libraries and build tools should be improved in terms of the completeness usability and readability code generation techniques may be adopted to facilitate build script generation and completion.
findings about build issue symptoms implications f.3we construct a taxonomy of symptom categories for build issues and error categories in dependency resolution .
parse .
output execution .
compilation .
and assemble .
are frequently asked by developers .
in total .i.3build issue resolution is challenging due to the diversity in symptom categories techniques for detecting and fixing general build issues should cover as broad spectrum of the categories as possible researchers should pay attention to these categories that developers find difficult to fix.
f.4output execution .
covers build issues with delayed exposure and .
of them encounter class loading error .i.4to uncover these issues earlier introduce early examination mechanism for build outputs check the configuration consistence between run time and build time environments.
findings about fix patterns implications f.5more than half .
of the build issues are fixed by patterns related to plugins and dependencies covering out of symptom categories.
the top two frequent fixing patterns are correcting plugin setting .
and adding missing dependency .
.i.5our suggestion to developers is checking plugin settings and absence of dependency declaration first.
our suggestion to researchers is assigning high suspiciousness values to the script code related to plugin and dependency in designing fault localization techniques and adding more fix operations and ingredients on these components in designing automated repair techniques.
f. out of symptom categories have frequent fixing patterns such as adding missing dependency to resolve class loading error and changing build tool version to solve plugin apply error.i.6the frequent pairs obtained from our study may serve as common fix strategies for both manual and automated build issue resolution.
f.7there is no common fix pattern for most symptom categories .
and each category has more than three fix patterns in average range from to indicating that a non negligible part of build issues are fixed case by case.i.7there is no silver bullet for fixing arbitrary types of build issues.
therefore researchers may facilitate automated resolution via embedding more priorexperience rules including the corner cases in our studies or mining more cases from big data to expand fix strategies.
f.8most .
fix patterns are simple and contain only a few lines of modification but require comprehensive and up to date knowledge on third party resources to apply.i.8automated resolution techniques are suggested to include autonomous updating mechanism to update their embedded fix strategies that are related to external resources so as to keep stable effectiveness.
f.9some symptom categories are fixed by non intuitive patterns e.g.
illegal symbol fixed by changing plugin version and in these cases developers often find it challenging to localize the causes.i.9we suggest tool vendors to provide deeper hints for build issues to assist developers resolution.
moreover the existence of non intuitive patterns indicates build errors with fault localization challenges.
how to questionsbuild failuresrefine datasetidentify related issuedownload so datasetmanuallabelled issuesrq1 how to topic rq2 symptom rq3 fixpattern figure overview of the methodology .
data collection it has been a common practice for se researchers to get insight into developers concerns on different se issues by mining related posts from so .
in our study we use so as the data source because i as one of the most popular community driven q a websites the users in so range from novices to experts increasing the diversity of the analyzed issues ii developers often seek for help in so after they cannot find solutions in documents or internet search leading to more unsolvable and non trivial build problems in our analyzed data iii so inherently contains build issues with implicit symptoms which are often hard to be capturedin reproduced or historical build data increasing comprehensiveness of the dataset.
we construct our dataset of build issues from so in the following steps.
step download stack overflow dataset.
we download so datasetsallfrom the official data dump in december which covers so posts from july to december .
we keep the post identifier question body answers and tags in the metadata of each post for our study.
step identify build related posts.
an so post usually has to tags which indicate the belonging domains of the post.
therefore we utilize a set of build related tags to identify and extract build related posts from sall.
similar to previous work we construct a set of build related tags as follows.
we start with a tag set tinithat includes our initial buildrelated tags.
as this study focuses on three mainstream java build systems maven gradle and antthat are widely studied in previous work we define an initial tag set tini ant mvn gradle .
we extract a subset of posts spart whose tags match at least one tag intiniand identify more build related tags based on spart.
specifically we construct a set of candidate tags tcand by extracting all the tags of the posts in spart.esec fse november virtual event usa yiling lou zhenpeng chen yanbin cao dan hao and lu zhang to remove noisy tags from spart we only keep the tags that are significantly relevant to build systems.
we use two metrics significance andrelevance from previous work and calculate for each tagtintcand with equations and .
a tag tis significantly relevant to build systems if its two metrics are higher than specific thresholds.
to avoid omitting relevant tags we adopt the lowest thresholds used in previous work and only the tags whose significance is higher than .005and whose relevance is higher than .05are kept intcand.
at last the first two authors manually inspect each remaining tag in tcand and remove the ones irrelevant to build systems and besides three initial tags the final tag set tf inal consists of extra tags such as build.gradle gradle plugin gradlew pom.xml and m2eclipse .
significance t p p s part pwitht spart relevance t p p s part pwitht p p s all pwitht all the posts with at least one tag in tf inal are regarded as build related posts.
step refine dataset.
to ensure the quality of selected posts and to reduce the ambiguity in following analysis we further filter the selected posts by only keeping the ones with an accepted answer which is the answer marked as accepted by the questioner.
out of the remaining posts we randomly select a statistically significant sample ensuring a confidence level .
the final dataset for our study consists of posts i.e.
for ant formaven and for gradle .
.
manual labelling each post in the dataset is manually classified as false positive i.e.
it is unrelated to build issues or its accepted answer is useless according to the questioner s additional comments or assigned a set of labels describing i the how to topic which is the summarization of the how to question description ii the failure symptom which shows what the failure looks like according to the question description and iii the fix pattern which tells how a build issue is fixed distilled from the accepted answer.
each of these labels is optional.
in particular if the post is raising a how to question e.g.
asking help to implement a specific build task or discussing conceptual build knowledge rather than an encountered build failure only the how to topic label is necessary for such a how to question otherwise for the post with a concrete build failure encountered by the questioner it is labelled with both the failure symptom and thefix pattern .
the manually labelling is conducted following an open coding procedure by the fist two authors with year experience of software development.
moreover we synchronize the label set among participants.
in particular the two authors independently tag each issue assigned to her with an existing label from the current label set or create a new label when the issue cannot be categorized to any existing label.
the newly created label is instantly updated into the label set and can be used by other participants then.
although in principle this is against the notion of open coding little is known about general type build fixing and the granularity of previous error category is too coarse in our study.
hence to avoidthe number of labels from growing excessively following previous studies we adopt the compromise without introducing substantial bias.
in this process the conflict ratio between two authors is .
.
in the cases where there is a conflict between the two authors a third arbitrator who is practised in build knowledge with years of build system experience would be introduced to label the issue.
in case of further disagreement among the three participants the conflicts are discussed and solved among all participants.
we follow this rigorous procedure until all issues reach agreement and the final label results are checked by all participants.
through the preceding process except the false positive posts how to posts are labelled with how to topics and build failures are labelled with symptoms and fix patterns.
to answer rq1 we analyze how to posts and distill the frequent topics in section .
for rq2 we construct a taxonomy of build failure symptoms based on the labels.
all the authors proceed to group similar codes into categories and create a hierarchical taxonomy of challenges.
the grouping process is iterative in which they continuously go back and forth between categories and questions to refine the taxonomy.
the frequent and non trivial symptom categories in our taxonomy are discussed in section .
for rq3 we study the characteristics of fix patterns for each symptom category in section .
for convenience we list the main findings and implications drawn from this paper including rq1 rq2 and rq3 in table .
others2.
build tool .
multi modules2.
ide .
grammar .
common task .
i o .
dependency12.
plugin6.
environment .
command line .
keyword13.
variableaccess .
condition4.
assemble5.
compile2.
deploy4.
resource3.
test2.
authorization0.
directory file11.
include7.
setting2.
exclude2.
log2.
conflict .
ds .
figure topics in how to build issues how to topics in build issues rq1 figure shows the hierarchical how to topics in build issues with corresponding percentages.
according to the figure we observe a high diversity in how to topics that developers ask which can be grouped into high level categories.
grammar is the topic asked most frequently .
by developers specifically .
of the questions are about the usage of the default keywords in the build script language .
are about howunderstanding build issue resolution in practice symptoms and fix patterns esec fse november virtual event usa to access i.e.
write read variables in a build script .
of the questions ask for code examples of conditions e.g.
loop if else and the rest are questions on the data structure e.g.
array iteration .
besides .
how to questions are about the difficulties that developers encounter when they attempt to write build code to implement common build tasks e.g.
compile test deploy or assemble a non negligible number .
of questions are related to file system operations since resource arrangements occur frequently during the build process .
are concerned about customizing dependencies to the project .
questions are on the usage of specific third party plugins and .
of the questions are about the interoperability between the build system and the command line e.g.
how to pass parameters in command line to the build process?
.
the questions vary from naive puzzles e.g.
grammar to very particular problems e.g.
usage of some specific plugin .
it may attribute to the co existence of novices and experts posts on stack overflow both of which are important and noteworthy.
overall most .
questions are about build script programming indicating that a non trivial number of developers have difficulties in writing a complete version of build scripts for their projects.
hence build script generation or completion tools are helpful for developers in programming build scripts where modern code generation techniques may be adopted since build scripts are often semi structured and most build tasks can be specified concisely.
furthermore we observe that developers complain about documents and tutorials in their so posts e.g.
neither the documentation had any sort of straightforward example... indicating that the completeness usability and readability of documents in third party plugins dependencies and build tools should be improved .
in addition to a certain extent the how to topics with high frequency imply the build components that developers are unfamiliar with which are vulnerable and subject to introducing defects in the further build script evolution.
for rq1 see findings f. and f. as well as implications i. and i. in table .
symptoms of build issues rq2 .
taxonomy and distribution figure shows the hierarchical taxonomy of symptoms manually constructed in our study.
nodes are in descending gray level along with their depth in hierarchy e.g.
leaf nodes are in white .
each leaf node represents a category and its non white parent node that consists of multiple categories is an inner category .
for example download error c. is an inner category that can be further divided into two categories connection error c. .
andlicense error c. .
.
the number in the top right corner refers to the number of issues in that category.
in total our taxonomy consists of inner categories and categories.
the broad scope of build error types indicates the prevalence and the diversity of build failures.
we next discuss categories by groups according to their belonging inner categories.
due to space limit we only address the frequent and non trivial categories and the complete explanations for each category are on our website .
parse b .
it is a build stage where the build system validates the build script prior to executing build tasks and .
of the build issues occur in the parsing phase.
all the previous studies lump parsing issues together as one group while our taxonomy further classifies them into categories regarding to their error symptoms.
illegal symbol b. errors cover .
parsing issues and they are triggered when the build system fails to resolve characters in the build script e.g.
undefined keywords properties or tasks .
besides such grammar check the build system also validates the presence of necessary artifacts such as embedded properties and project modules and interrupts when the property is not initialized i.e.
missing property b. modules are not correctly recognized i.e.
module resolution error b. or the value of the property is invalid i.e.
property value resolution error b. .
dependency resolution c .
it is an essential step in the build process and responsible for preparing necessary dependencies directly or transitively specified by developers which covers .
build issues.
all the previous studies classify dependencyrelated issues into one large group and regard them as a big concern in build activities on this basis our taxonomy further derives finer categories within dependency related failures.
dependency findability error c. the most frequent category in the dependency resolution phase occurs when the required dependencies cannot be found in the specified location e.g.
remote central or local repository .
conflict error c. is triggered when a project relies on different versions of the same library.
usually developers would not simultaneously use multiple versions of one dependency but it is difficult for them to be aware of the hidden transitively dependent relationship among dependencies which actually causes the conflict issue.
these two common error types cover .
dependency resolution issues while the rest are caused by connection error c. .
andlicense error c. .
triggered in the unsuccessful dependency downloading process.
resource processing e .
it covers the build failures triggered in processing resources.
half of the resource processing issues are acccessibility error e. which is triggered when the build system is unable to find the specified resources.
besides some resources are not originally embedded within the project and need to be generated or merged.
therefore we classify these issues into categories generation error e. andmerge error e. respectively.
furthermore when the build system parses resource files and finds any violation format error e. is triggered.
compilation f .
it covers a non negligible part .
in build issues.
a small ratio .
of compilation issues are reported by the build system.
for example when the build system is unable to load compilers i.e.
compiler loading error f. or unable to load specified files for compilation i.e.
source file loading error f. .
the rest issues .
in the compilation phase are errors thrown by the compiler i.e.
compiler error f. .
for example unsupported operator f. .
i.e.
the current java version is not compatible with the used operators and source code encoding error f. .
are the errors detected by a compiler when it is parsing the source code.
we observe that most errors .
reported by a compiler are symbol resolution error f. .
which refers to the cases that symbols e.g.
variable class method or package in source code cannot be resolved by the compiler usually with error messages as cant.resolve ordoesnt.exist .
this observation is consistent with the finding in the previous work .
assemble g .
it is a collection of tasks that process the compiled files and package them into distributable or executable formatsesec fse november virtual event usa yiling lou zhenpeng chen yanbin cao dan hao and lu zhang build issues parse illegal symbol obsoleteapi build script encoding error missing property module resolution error project attribute resolution error variable value resolution error plugin resolution plugin apply error plugin cover error pluginfindability error initialization memory error tool loadingerror execution permissionerror852143726644 dependency resolution download error conflict error licenseerror connection error dependencyfindability error accessibility error generation error merge error format error resource processing assemble broken file missingfile process aborting duplicated file test run time error test test loading error document generation error i ocompression error other plugins code analysis error extra plugin execution project import error compatibility error character resolution error ide interoperability external executable error8 sourcefileloadingerror unsupported operator symbolresolution error compiler loading error source code encoding error non error issue unexpected output performance issue deploy server install error server connection error output execution other run time error class loading error java version compatibility error missing referredfile others compiler error compilation memory issue72465 figure taxonomy of symptoms in build issues e.g.
jar war ear or apk .
the assemble stage breaks down when there are duplicated missing or broken files g. g. and g. respectively .
besides .
assemble issues result in an unexpected exit i.e.
process aborting g. which means that the packaging process interrupts abnormally.
for example the assemble process of android applications often breaks down when there are excess .dex files.
non error issue j .
it is concerned about the build issues with implicit symptoms rather than explicit error message i.e.
build failure .
for example performance issue j. andmemory issue j. contain the builds that abnormally occupy too much time or too large memory space.
unexpected output j. refers to the cases where the output of certain build task is not as expected although no error is triggered during that build task.
for example the developer assigns jacoco plugin to collect and report dynamic test coverage during the build process although the build finishes successfully the generated report is incomplete with missing coverage results for some tests.
extra plugin execution k .
considering the large number of third party plugins except the plugins for common build tasks e.g.
resource processing e compilation f test h deploy i and assemble g as listed in our taxonomy we group the build failures triggered during the execution of the other plugins into this inner category.
these build failures are further classified into finer categories regarding to their functions.
for example code analysis k. covers the build failures triggered by plugins for conducting code analysis e.g.
static code analysis or dynamiccoverage collection document generation error k. covers the errors thrown by plugins for generating documents e.g.
javadoc .
given the diversity of plugins in the wild instead of enumeration an extendable category other plugins k. is used to contain the rest issues.
output execution l .
some build related issues do not trigger build failures explicitly during the build process but generate problematic outputs e.g.
compiled class file assembled jar or executable application that fail to work properly.
we group such issues as output execution l .
in other words these issues are actually build failures with delayed exposure.
note that such build failures are often neglected by the previous studies on build failures since their analysis only keeps the build issues with explicit error symptoms during the build process.
after inspecting the various run time exceptions and errors thrown during the output execution we find that .
of them are related to class loading error l. which consists of two symptoms classnotfoundexception andnoclassdeffounderror .
they occur when the java virtual machine is unable to find a particular class at run time and we group these two symptoms together because in many cases they are nested with each other and essentially they are both caused by missing classes during run time.
class loading error l. often stems from the missing or incorrect dependencies in the assemble or compilation phases and more details and examples of their root causes will be discussed in section .
furthermore when the java versions in run time and compilation phases are inconsistent javaunderstanding build issue resolution in practice symptoms and fix patterns esec fse november virtual event usa version compatibility error l. is triggered and inaccessible referred files during run time induce missing referred file l. .
due to their delayed exposure output execution issues increase developers efforts in solving build problems.
ide interoperability m .
the interoperability between ide and build frameworks may also induce build issues.
in this study we observe such symptoms on most mainstream ides such as android studio eclipse and intellij.
most interoperability issues .
are character resolution errors m. when the build script cannot be resolved properly in ide e.g.
an unresolved character is often addressed by a red underline .
compatibility error m. is triggered when ide is incompatible with the current version of the build system.
when ide fails to import an existing project that is already built with a build framework ide reports a project import error m. .
interoperability build issues are often occurring and resolved in developers local work space and therefore they are seldom included in previous studies that are based on historical or reproduced build data.
for rq2 see findings f. f. and implications i. i. in table .
.
discussion .
.
comparison to previous studies.
several studies have investigated error types of build failures driven by different research goals.
for example kerzazi et al.
interviewed developers in a company to investigate circumstances under which the build process was broken in the lense of human factors.
given the prevalence of continuous integration ci there are emerging studies investigating build breakages in the ci scenario vassallo et al.
compared different error types of ci in open source and closedsource projects zolfagharinia et al.
investigated environmental impacts on ci error types of cpan projects.
besides ci there are studies investigating build issues under the traditional build scenario.
for example hassan et al.
inspected build issues to explore the feasibility of automatic build.
table lists all the studies related to general build issue classification.
the column dataset attributes shows project types closed source or open source build scenarios and build systems involved in their datasets the column label process shows how these studies label each build failure in their datasets to derive the categorization.
specifically automated label means that the study utilizes text processing techniques to automatically extract labels from build failure logs to label each build failure manual label means that each build failure is labelled via manual inspection.
the column size counts the number of categories in the taxonomy and the last column presents the frequent error types in their findings.
overall we observe that our taxonomy differs from previous studies in terms of granularity diversity and distribution .
i our taxonomy is derived at a finer granularity so that the corresponding fix patterns within each symptom category would be more uniform.
it helps understand developers resolution behaviours on different build failures.
note that a fine granularity taxonomy is not always necessarily practicable in all studies which is dependent on the 1the company adopts one central build server acting as build controller and four build agents in the build process.research goal and the categorization methodology automated or manual label .
ii we observe that our taxonomy covers extra categories that are absent in previous studies.
the reason might be that our dataset is mined from build issues posted by developers on so while previous studies are based on build history data in ci or reproduced data in traditional build scenario.
the latter inherently filters out the build issues without explicit failure symptoms during the build process.
iii another difference lies in the frequency distribution of the categories in our taxonomy which is not identical with previous ones.
actually as shown in the column frequent categories almost every study derives different frequent categories.
the biggest reason for the inconsistence may stem from the underlying datasets.
different sources build scenarios and build tools all attribute to the different distribution of frequent failure types.
as shown in the table analyzing build issues from so our taxonomy inherently is not limited to open or closed source projects ci or traditional build scenario.
furthermore the frequent error types identified by previous studies may be those that occur most frequently in build activities while the frequent error types identified by our study tend to be the issues hard to solve since so posts are often composed by the problems developers cannot resolve at first glance.
.
.
evaluation of the taxonomy.
in the previous section we illustrate the difference of our taxonomy compared to the previous work.
note that we are not to judge which taxonomy is better since as aforementioned all the taxonomies are driven by different research goals.
in this work our goal is to understand build issue resolution in practice.
therefore we evaluate our taxonomy against the latest taxonomy proposed by hassan et al.
in terms of this goal.
we further construct another sample of so posts from the remaining dataset categorize them according to our taxonomy and hassan s respectively and then calculate the following measurements as suggested in previous work .
the numbers before and after refer to the results on our taxonomy and hassan s respectively.
we find that i of issues cannot fit in any category ii categories have no issues iii there are .
.
fixing patterns on average in each category.
the results demonstrate that our taxonomy has less categorization errors and the smaller number of fix patterns in each category indicates the better performance in facilitating failure resolution.
.
.
different views of the taxonomy.
our taxonomy is primarily derived based on the issue triggering phases and the manifested symptoms.
actually there can be various aspects to analyze build issues e.g.
incremental full local remote and system user and thus we further discuss our taxonomy with different views.
for example build issues can be generally categorized into system errors or user errors.
the former refers to the issues associated with incorrect functioning of the build tool itself e.g.
ant and the latter refers to the issues caused by artifacts outside the build tool e.g.
dependencies or user configuration .
within our taxonomy we can observe that some categories are purely related to system errors e.g.
all issues in tool loading error can be resolved by the build tool itself while some categories are the mixture of both errors e.g.
issues in illegal symbol are probably caused by changing the build tool or syntax errors from users .
overall most build issues are resulting from developers.
moreover we also find that differentesec fse november virtual event usa yiling lou zhenpeng chen yanbin cao dan hao and lu zhang table summary of previous studies related to build issue categories studydataset attributes category attributesfrequent categoriessource build scenario build system label process size kerzazi et al.
closed continuous integration industrial system1interview missing files mistaken check in tufano et al.
open traditional scenario maven automated label dependency sul r et al.
open traditional scenario maven ant gradle automated label dependency compilation vassallo et al.
open closed continuous integration maven automated label test release preparation rausch et al.
open continuous integration maven gradle automated label test code quality compilation zolfagharinia et al.
open continuous integration cpan manual label dependency undefined variable hassan et al.
open traditional scenario maven ant gradle manual label jdk incompatibility build tool this workopen closedtraditional scenario continuous integrationmaven ant gradle manual label 50dependency parse compilation output execution assemble operating platforms may cause different fix patterns.
although we observe only a small number of such cases i.e.
less than five it is interesting to further investigate the impact from different platforms e.g.
operating systems on build issue resolution.
fix patterns of build issues rq3 to capture how developers fix different types of build issues in this section for each symptom category we summarize their fix patterns in table .
the columns inner category and category are consistent with our taxonomy in figure and the number in parentheses is the number of build issues in that category.
the column category description briefly describes the symptom category the column fix pattern description presents the fix pattern and the last column issues is the number of issues fixed by that pattern.
take the first row in the table as an example out of the issues in inner category initialization a issues belong to tool loading error a. and all of them are fixed by changing the version of the build tool.
due to space limit we do not list the patterns with low frequency i.e.
issues and the complete list of all patterns can be found in our website .
overall we observe complicated crossovers between different fix patterns and symptom categories confirming that build failure resolution is a challenging problem.
meanwhile the average number of fix patterns in each category i.e.
.
is much less than in each inner category i.e.
.
indicating that our taxonomy potentially divides build failures with different causes into different small groups which supports the necessity and validity of our finegranularity taxonomy derived in rq2.
we next discuss the main findings and implications as following.
.
prevalent fix patterns across symptoms although the number of symptom categories and fix patterns is large there are prevalent patterns that can fix multiple symptom categories.
we find that .
of the build issues are fixed by repairing the build script code related to the components plugin anddependency and these build issues cover out of .
symptom categories in our taxonomy.
in addition we use figure to show the frequency of each fix pattern on each inner category.
x axis represents each inner category and the letter identifier is consistent with our taxonomy in figure y axis shows fix patterns1following with their total frequency.
1due to space limit patterns with total frequency 5are not shown in the figure.
figure distribution of fix patterns on inner categories the figure shows the overall trend more intuitively but at a price of detailed information loss compared to table .
in figure we can also observe that the patterns related to plugins and dependencies cover a broad scope of inner categories.
in particular fix patterns related to plugins e.g.
correcting plugin option oradding missing plugin cover build issues in categories.
for example correcting plugin option fixes categories and .
build issues which is the most frequently used fix pattern.
patterns on script code related to dependencies cover symptom categories adding missing dependency covers categories and fixes .
build issues correcting dependency version adding searching repository and excluding conflict dependency fix .
.
and .
of build issues respectively.
it implies that defective script code in plugin setting and dependency declaration is a major cause for build issues.
the analysis of prevalent fix patterns across symptoms is summarized by finding f. and implication i. in table .
.
frequent pairs of fix patterns and symptoms from table we observe that there exist frequent pairs of patterns and symptom categories which indicates that given a symptom category most issues in that category can be fixed by a specific pattern.
in table we find that for symptom categories more than half of its build issues can be fixed by a specific pattern and we regard such combination of symptom category and fix pattern as a frequent pair.
for example out of illegal symbol b. issues are resolved by fixing syntax error out of conflict errors c. understanding build issue resolution in practice symptoms and fix patterns esec fse november virtual event usa table frequent fix patterns of each category inner category category category description fix pattern description issues initialization tool loading error unable to launch build tool change build tool version parse illegal symbol keywords or variables e.g.
property task or method cannot be resolvedfix syntax error change build tool version obsolete api deprecated api is in build script change plugin version missing property property without default value is not initialized correct relative location of modules module resolution error resolution error during configuring modules correct relative location of modules project attribute resolution error project attribute e.g.
build type is invalid correct project build type dependency resolution connection error connection timeout due in dependency download fix build tool proxy setting conflict error multiple versions of the same dependency are required simultaneouslyexclude conflict dependency change dependency version dependency findability error unable to find the required dependency in the specified remote central local repository or local locationadd searching repository change dependency version change dependency identifier correct dependency local location correct dependency usage setting plugin resolution plugin findability error unable to find the required plugin in remote local central repositoryadd plugin declaration change plugin version add searching repository plugin cover error plugin execution is not specified in build lifecycle specify plugin execution phase plugin apply error unable to apply plugin change build tool version resource processing accessibility error unable to find the required resourcecorrect plugin assemble optionversion add missing resource in project compilation symbol resolution error cannot resolve symbol e.g.
variable class method or package that does not existadd missing dependency fix source code change dependency version correct dependency usage setting source code encoding error encoding format error in parsing source code set plugincompile optionencoding unsupported operator compilation compatibility error set plugincompile optionsource target assemble duplicated file multiple or conflict files are foundexclude redundant files exclude conflict dependency missing file cannot find required files set pluginassemble optionpath process aborting package process is interrupted abnormally set pluginassemble optionenable test test loading error unable to load tests set plugintest optionclasspath output execution class loading error run time exceptions e.g.
classnotfound ornoclassdef are triggered during class loadingadd missing dependency change dependency version exclude conflict dependency correct dependency usage setting are fixed by excluding conflict dependency and out of class loading errors l. are fixed by adding missing dependency .
besides as shown in figure the darker cells also confirm that specific fix patterns are clustering in different inner categories.
therefore heuristic strategies for build failure resolution can be derived from these frequent pairs.
the analysis of frequent pairs of fix patterns and symptoms is summarized by finding f. and implication i. in table .
.
case by case fix patterns for symptoms in spite of the existence of prevalent fix patterns and frequent pairs many symptom categories out of do not have common fixing strategies and are fixed by case by case patterns.
specifically the number of fix patterns in each category varies from to and the average number is .
.
for example there are fix patterns for the symptom symbol resolution error f. .
patterns for dependency findability error c. and patterns for class loading error l. .
furthermore build issues are fixed by a pattern different from the other issues that are in its same category.
to a certain extent this observation explains why manually build issue resolution is 2recall that we do not list less frequent patterns due to space limit and the complete pattern list is on our website .challenging which requires developers comprehensive knowledge and experience in various cases of failure resolution.
additionally it may also explain why the state of the art automated build resolution techniques are not that effective.
compared to the overall cases their fixing strategies only cover a tip of the iceberg and more fixing strategies may be included according to the massive corner fixing cases derived from our results.
the analysis of case by case fix patterns is summarized by finding f. and implication i. in table .
.
challenges in simplistic fix patterns according to our statistics .
build issues are fixed by a few lines of modification on build script code i.e.
within lines .
particularly the pattern changing dependency version correcting plugin option orcorrecting plugin version often involve only one line modification.
notwithstanding that there is a knowledge gap for developers to transform fix patterns template into concrete fix patches3.
for example in process aborting g. category build issues can be fixed by enabling a specific option in the plugin for assemble i.e.
3a pattern is an abstract template while a patch is concrete and ready for use modification.esec fse november virtual event usa yiling lou zhenpeng chen yanbin cao dan hao and lu zhang correcting plugin assemble option enable .
as shown in the example a i.e.
the post on so the assemble phase is interrupted due to the abnormal process abortion.
according to the developers discussion in this post the root cause is the large number of .dex files and setting multidexenabled totrue can prevent the build process from abortion.
multidexenabled is an option in android plugin while most questioners of this failure symptom are unaware of the function of this option.
to sum up a third party plugin usually has many options e.g.
android plugin has options which require massive open knowledge for developers to solve plugin related build issues.
question description com.android.build.api.transform.transformexceptionprocess command finished with non zero exit value .fix pattern correctplugin optionpatch multidexenabledtrue symptom process aborting g. example a therefore although most patterns are simplistic they are associated with different third party libraries and the libraries always keep evolving and updating their features which is challenging for a manual follow up.
although build fixing techniques may relieve such manual efforts by embedding as much domain knowledge as possible in advance considering the timeliness the fixing strategies have to be dynamically updated to keep stable effectiveness since the external resources dependencies plugins are evolving all the time.
for example the history based failure fixing technique hirebuild is less half effective when it is evaluated one year later with the original training set and the timeliness may partly attribute to it.
the challenge in simplistic fix patterns is summarized by finding f. and implication i. in table .
.
challenges in non intuitive fix patterns we observe that many fix patterns are non intuitive for the given symptom category and developers often face difficulties in realizing the root causes behind these build issues.
for example for build issues in obsolete api b. surprisingly they are not caused by the direct usage of the deprecated api instead some plugin transitively uses that obsolete api which is often neglected by developers.
in other words developers apply a third party plugin which uses an obsolete api indirectly.
in example b a developer encounters an obsolete api warning and confidently claims that the obsolete api is never used by herself in the build script.
actually the older version of the plugin com.google.gms google services uses this deprecated api and upgrading the plugin to a new version can resolve this issue.
besides half of the issues in missing property b. are not caused by the absence of property declaration but caused by the incorrect relative path among modules.
in example c although the error message is reporting missing property and the developer is pretty sure that the property is already written in the script code the root cause is the incorrect relative location of modules.
because there are inherited properties between the parent module and the child question description configuration compile is obsolete i tried to look for compile in the whole project but no match was found fix pattern change plugin versionsymptom obsolete api b. patch classpath com.google.gms google services .
.
classpath com.google.gms google services .
.
example b 48709870module an incorrect relative location declaration can prevent the build system from resolving the value of the inherited property.
question description dependencies.dependency.versionis missing i check pom but there are the version written patch parent ... relativepath ... relativepath ... parent fix pattern correct relative location of modulessymptom obsolete api b. example c furthermore most issues in class loading error l. are also fixed by non intuitive patterns.
in the example d the developer complains that the build process is successful but the generated application does not run successfully by reporting the class loading error l. .
it is difficult for the developer to learn that this error comes from the building process because class loading error l. is a type of build errors with fake successful build status but exposed after build discussed in section .
in this example the root cause is that the dependency library json is not included in the compilation phase and thus adding it can resolves theclassnotfoundexception issue.
question description java.lang.classnotfoundexception mvn cleanpackage andeverything builds successfully butwhen i try to run it i get error... patch dependency groupid org.json groupid artifactid json artifactid version version dependency fix pattern add missing dependencyexample d 15951032symptom class loading error l. the challenge in non intuitive fix patterns is summarized by finding f. and implication i. in table .
threats to validity a major threat to validity is that we only use stack overflow as the data source to study how developers resolve build issues.
although the study is based on a representative sample of so posts and so posts have been widely used in previous work there could be build issues that are never discussed on so.
in other words we cannot guarantee the generalizability of our observations due to the bias induced by single data source.
in the further we plan to extend our study in more data sources e.g.
github and build systems to further validate our findings.
another threat lies in the construction of the tag set which we utilize to extract build related so posts.
we cannot guarantee the tag set is complete since the thresholds chosen for the metrics significance andrelevance may overlook some tags related to buildunderstanding build issue resolution in practice symptoms and fix patterns esec fse november virtual event usa issues.
to mitigate this threat we adopt the smallest threshold values used in previous work to firstly include as many related tags as possible and then we refine the tag set by further manual inspection to ensure the precision.
in addition to eliminate the false positive resulting from automatically extracting posts with selected so tags the first two authors of this paper manually label these posts.
in addition the possible subjectiveness introduced during the manual analysis might induce bias in the results.
to mitigate this threat we ensure each data item is labelled by at least two authors with a third arbitrator resolving the conflicts and inspecting all final results.
related work as this paper targets at the understanding of build issue resolution it is very related to both the work on build failures and build fixing.
.
build failures build failures have been extensively studied in recent years.
kerzazi et al.
interviewed developers to study why build breakages are introduced in an industrial case.
tufano et al.
investigated build errors in maven projects and sul r et al.
studied error categories in open source java projects built with maven antandgradle .
hassanet al.
inspected build issues to explore the feasibility of automatic build.
with the prevalence of continuous integration ci there are emerging studies investigating build breakages in ci scenario.
rausch et al.
studied the factors affecting ci build errors in open source java projects.
vassallo et al.
compared the build errors in open source ci and closed source ci.
zolfagharinia et al.
investigated the environmental impacts res and oses on ci build failures in cpan projects.
besides general build failures several studies focused on specific type of build failures.
seo et al.
performed a large scale study on compiler errors in build process at google zhang et al.
further investigated compiler errors on open source java projects in continuous integration beller et al.
investigated build breakages related to testing on travis ci ghaleb et al.
studied the build issues with long duration.
different from existing studies we conduct the first comprehensive study on build failures by mainly focusing on fix patterns meanwhile to characterize patterns precisely a fine granularity taxonomy of build failure symptom is derived in our study and the difference with previous studies is discussed detailedly in section .
.
.
furthermore in this work we also summarize frequent topics developers ask frequently about build issues indicating the challenges developers encounter in build activities.
.
build fixing the prevalence of build failures has inspired emerging studies on automated build fixing techniques.
macho et al.
designed three fixing strategies for only dependency related maven build failures.
zhang et al.
studied compiler failures in ci and summarized fix patterns particularly for frequent compiler errors.
different from these studies on the specific type of build failures our work investigates fix patterns across general types of build failures.
al kofahi et al.
proposed a fault localization approach for makefile by calculating statement suspiciousness based on theirdynamic execution trace.
vassallo et al.
proposed a supporting tool summarizing maven build logs and providing relevant online links to reduce developers resolution efforts.
hassan and wang fixed general build failures via analysis on build history data.
recently lou et al.
proposed a history oblivious fixing technique for general build failures via code analysis and search based patch generation.
although promising the effectiveness of the state ofthe art fixing techniques is still far from satisfactory i.e.
the latest technique successfully fixed only build failures indicating a gap between automated techniques and practical build failure resolution.
to bridge such a gap in this work we manually inspect a large number of practical human fixing cases and summarize fix patterns for general type build failures.
conclusion in this work we present a comprehensive study of build issue resolution by manually inspecting build issues from stack overflow.
we distill frequent topics in developers how to questions and find that most .
of them are about script code programming.
through the study we also construct a fine granularity taxonomy of failure symptom categories and summarize fix patterns for different failure types.
we find that build issues stretch over a wide spectrum of symptoms and prevalent fix patterns and frequent combinations of failure symptoms and fix patterns can be adopted to facilitate build failure resolution.
furthermore we discuss the challenges in both simplistic and non intuitive fix patterns.