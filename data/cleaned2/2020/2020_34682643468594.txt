understanding and detecting server siderequestraces in web applications zhengyi qiu departmentof computerscience north carolina stateuniversity raleigh north carolina usa zqiu2 ncsu .edushudishao departmentof computerscience north carolina stateuniversity raleigh north carolina usa sshao ncsu .edu qizhao departmentof computerscience north carolina stateuniversity raleigh north carolina usa qzhao6 ncsu .eduguoliang jin departmentof computerscience north carolina stateuniversity raleigh north carolina usa guoliang jin ncsu .edu abstract modernwebsitesoftenrunwebapplicationsontheservertohandle httprequestsfromusersandgeneratedynamicresponses.dueto their concurrent nature web applications are vulnerable to serverside request races.
the problem becomes more severe with the ever increasing popularity ofwebapplications.
wefirstconductacomprehensivecharacteristicstudyof157realworld server side request races collected from different popular typesofwebapplications.thefindingsofthisstudycanprovide guidance for future development support in combating server side request races.
guided by our study results we develop a dynamic framework reqracer for detecting and exposing server side request races in web applications.
we propose novel approaches to model happensbeforerelationshipsbetweenhttprequests whichareessential to web applications.
our evaluation shows that reqracer can effectivelyandefficientlydetectknownandunknownrequestraces.
ccs concepts software and its engineering software defect analysis softwarereliability softwaretestinganddebugging concurrency control organizing principles for web applications consistency.
keywords web applicationrequestraces characteristicstudy racedetection happens before relationships permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse august 23 28 athens greece copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
.org .
.3468594acmreference format zhengyi qiu shudi shao qi zhao and guoliang jin.
.
understandinganddetectingserver siderequestracesinwebapplications.in proceedingsofthe29thacmjointeuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec fse august 23 28 athens greece.
acm new york ny usa 13pages.
.org .
.
introduction upon receiving http requests modern web sites dynamically generateresponsesbyrunningsomeprogramsontheserver.we refer to these programs as server side web applications and we refer to the code that handles each http request as a request handler.duetovarioustypesofconcurrentactivitiesinserver side webapplications requesthandlersservinghttprequestscould encounter race conditions while accessing shared resources and leadtoerroneousbehaviorsdependingontheorderofthesesharedresource accesses.
since these races happen on the server side of webapplicationswhilehandlinghttp requests werefertosuch racesasserver siderequestraces orshortlyas requestraces .
several high profile software failures were caused by request races e.g.
instacart coupon double redemption starbucks gift card duplicate balance transfer and flexcoin bankruptcy causedbywallet overdraw .
in the instacart incident a user reported that he was able to redeem the same coupon more than once with savings stacked by sending the coupon redemption request multiple times .
figure1shows a high level explanation based on the incident description.
while serving onecoupon redemption request the corresponding request handler will issue multipledatabase queries i.e.
one query will first check whether a given coupon has been redeemed and if it has not more queries will markthe couponas beingredeemedandupdatetheuseraccountwiththeredeemedsavings.
figure 1ashows the case when these two coupon redemption requests are sentsynchronously i.e.
sending one request after receiving the response of the previous request.
in this case these two requests are handled one by one where only the first request will add savings to the user account but the second request will inform the user that the coupon has already been redeemed.
however ifauser sendsthe tworequests asynchronously asshown in esec fse august athens greece zhengyiqiu shudi shao qi zhao andguoliang jin query response noserver db query dallas20 used?
query response donequery use dallas20 response ok query response yesquery dallas20 used?request use dallas20 response cannot userequest use dallas20 a tworequests handled one by one request use dallas20 server db query dallas20 used?
request use dallas20 query dallas20 used?
query response no query response no query use dallas20 query use dallas20 query response done query response doneresponse ok response ok b tworequests handled concurrently figure ahigh levelillustrationoftheinstacartincident figure1b i.e.
sendingonerequestbeforereceivingtheresponse of the previous request in a different concurrent client session the two requests are handled concurrently and two concurrent instancesofthesamerequesthandlerareracing.undertheinterleaving shown in figure 1b both requests first see that the coupon hasnotbeenusedandthenbothusethecoupon resultinginthe reportedcoupondouble redemptionscenario.
as exemplified by these incidents request races can lead to seriousservicecorruption severesecurityvulnerabilities andhuge financiallosses.tworecenttrendsmakerequestracesanemerging threattothereliabilityandsecurityofwebapplications.first the development of cloud platforms greatly eases the deployment of web applications and the number of web applications increases.
secondly getting access to web sites is eased by the increasing population of handheld devices and the chance of encountering requestracesincreaseswithmoreconcurrentrequests.wearein great need of a comprehensive understanding of request races and effective techniques for detecting them.
.
limitationsofexistingwork inthismulti coreera alotofresearcheffortshavebeenspenton thread races in multi threaded programs.
researchers have conducted characteristic studies and proposed various techniques for different purposes e.g.
bug detection program testing failure diagnosis and fixing .
since web applications are commonly hosted on top of some multi threaded programs e.g.
apachehttpdandmysql onemayhavethemisconceptionthat request racesare asolved problemgiven the researchprogresson thread races.
however thread racedetectiontechniques cannotdetectrequest races.
the request race shown in figure 1happens between two instancesofthesamerequesthandlerracingondatabaserecords andthe problematicinterleavingondatabase queriesmanifests as an atomicity violation where the violated atomicity assumption isamongmultiplequeriesissuedbyasinglerequesthandler.therequestracecannotbedetectedasathreadraceinthehttpserver program astheshareddataisstoredinadatabasebutnotinthe shared memory of the http server program.
it also cannot be detectedasathreadraceinthedatabaseprogram aseachdatabase query is atomically processed when the request race happens in figure1.therefore thereisnothreadracefromtheviewpointof the http serveror the database.essentially threadraces happen in the system layer which is below the application layer where request races happen.
through the discussion above we can see thatrequestracescanhappeneveniftherearenothreadraces and thus thread race techniques are not effective for request races.
recent techniques for process races on the operating system level anddistributed concurrency bugs in distributed and cloud systems are also not effective for request races.
the reasonsaregenerallytwo folded.first thesetechniquesalsotarget racesinthesystemlayerbutnotintheapplicationlayer andthe racesdetectedbythesetechniquesarenotnecessarilyrequestraces.
secondly evenifthesetechniquescandetectsomerequestraces they could report many false positives as they do not consider applicationsemanticswhilemodelinghappens beforerelationships.
we willexpand the discussiononthe secondpointlater.
not only one cannot directly use these existing techniques to detect request races but server side web applications also bring uniquechallengestoadaptexistingapproachestodetectrequest races.
dynamic race detection now commonly follows the tracinginference validation architecture i.e.
a tool first traces dynamic executionswhereracesdonotmanifest theninfersracesfollowing common race manifestation characteristics and finally validates the inferred races during replay runs.
however we face two major challengestoadaptthistracing inference validationarchitecture for request race detection inwebapplications.
first we currently lack a comprehensive understanding of realworldrequest racecharacteristicstoguidethethreestagesinthe tracing inference validationarchitectureandmaketheapproach effectiveandefficient.onlyrecentlyresearchershaveconducted characteristic studies on request races in applications developed with javascript on top of the node.js framework .
however these two studies do not specifically focus on web applications but includemanymiddlewareanddesktopapplications andtheirstudy results cannot provide sufficient coverage for real world request racesinrepresentative server side webapplications.
secondly server sidewebapplicationsrequirenewtechniques to model happens before relationships and determine which request handlers can run concurrently.
for example one common way to establish a happens before relationship between two requests is to send the second request by clicking a button on the web page returned for the first request.
such happens before relationshipscannotbemodeledbyexistingtechniquesthatmostly focusonmodelinghappens beforerelationshipsestablishedwith synchronizationoperations.
recently client side races in web applications have drawn much attentionfromtheresearchcommunity.researchershaveproposed several techniques for client side race detection.sincetheyfocusontheinteractionbetweenthehtml document object model dom and asynchronous event driven javascript executions on the client side the happens before relationships modeled by existing techniques do not readily capture 843understandinganddetectingserver siderequest racesin webapplications esec fse august athens greece dependenciesbetweendifferenthttprequests.althoughboththe clientsideandtheserversideareintegralpartsofwebapplications requestracesontheserversidearearguablymorecriticalastheyoften affect persistent system resources e.g.
the coupon redemption information inthe instacart incident storedinthe database.
lastly specific to server side request races only a few groups ofresearchershave explored techniquestodetectthem so far and proposed dynamic static and model checking approaches.
the dynamic and static approaches only detect request races between two instances of the samerequest handler andoneofthem furtherlimitsitselftoonesub type of request races.
since it is almost always possible to send the samerequestmultipletimesasynchronouslywithcommand line toolsandinvokemultipleconcurrentinstancesofthesamerequest handler there is no need to model happens before relationships inthelimitedscopeofrequest racestargetedby thesetechniques.
althoughtheycandetectrequestracesliketheoneinfigure their designchoicesleadtomajorcoverageissues andtheycannotdetect request races between distinctrequest handlers leading to false negatives.ifoneappliesthesepriortechniquesalsofordetecting races between different request handlers every pair of request handlers will be considered as potentially concurrent leading to a large number of false positives to be pruned with the costly replaystage.ontheotherhand themodel checkingapproach alleviates the need to model happens before relationships between distinct request handlers by constructing concurrent test cases manually limitingthe applicabilityofthe approach.
.
contributions to better understand request races and guide the design of requestracedetectors wefirstconductacharacteristicstudyon157serverside request races collected from the bug tracking systems of web applicationsdevelopedwithdifferentlanguagesandframeworks coveringphp perl python c java ruby on rails andnode.js.
ourstudyisthelargestandmostcomprehensivetodateforserverside request races.
it reveals many general findings on racingresourcetypes manifestationconditions root cause patterns the effects of races and fix strategies which are useful to guide the developmentofcomprehensivetoolsupportforrequestraces.we also investigate how external factors such as language framework differences affectthe characteristics ofrequest races.
our study confirms several observations we made earlier requestracesarenumerousandarealthreattothereliabilityand securityofserver sidewebapplications requestracesareindeed different from system layer racesthat the root causes and fixes of allthestudiedrequestracesareintheapplicationlayer and it is necessary to design new detection techniques that can handle requestracesbeyondthosebetweenmultipleinstancesofthesame requesthandler asasignificantportionofthestudiedrequestraces are between distinct request handlers.
we then present reqracer a dynamic framework for detecting request races beyond those between two instances of the same requesthandler.
tomake iteasytodeployand broadlyapplicable reqracer traces only on the server side and thus requires no changetobrowsersorotherformsofclients.
reqracer currentlyfocuses on detecting request races manifest as atomicity violations as they account for 137outof the 157request raceswe studied.
reqracer follows the tracing inference validation architecture mentionedearlier anditsdesignisguidedbysomekeyresultsfrom ourcharacteristicstudy.specifically ourstudyshowsthatallthe studied races manifestingas atomicity violations can be triggered bytwoconcurrentrequests i.e.
thebuggyinterleavingsthatcan lead to erroneous behaviors only involve shared resource accesses issuedbytwoconcurrentrequesthandlerswithonerequesthandler on each racing side.
with this result reqracer detects request racesbycheckingwhethertherearecommonlyseenunserializable interleaving patterns eitherbetweentwo instances of the samerequest handler or between two distinct request handlers that can be concurrent.
to this end reqracer reports two request handlers as having a true harmful race if their corresponding requests are concurrentandtheinferredunserializableinterleavingscauseerrors orundesiredbehaviors inreplayruns.
ourmajorcontributionliesin reqracer snovelapproachfor constructingadependencygraphtomodelhappens beforerelationships between requests with which reqracer recognizes requests that are potentially concurrent.
reqracer models two types of dependenciesthatarecommoninwebapplications.thefirstisa request response request rrr dependency and it exists when one request can only be sent after the response of the previous request has been received by the client.
the second is a select by primarykey spk data dependency and it exists when a latter select query specifies a primary key and retrieves one row inserted by an earlier query.
the rrr dependency is natural for web applications and the purpose of the spk data dependency is to quickly prune requestracesthatwouldotherwiseresultinreplaydivergencesduring thevalidation stage where a replay divergencehappens when the request handlers involved in the request race to validate executesignificantly differentbusiness logic comparingtherecorded run and replay run.
similar to the previous work on detecting and validating process races reqracer prunes a request race as a false positive when a replay divergence happens and the spk data dependencycangreatlyreducethenumberoffalsepositivesthat needto be prunedthroughreplay.
weimplementedaprototypeof reqracer forthelamp linux apache mysql and php stack.
we evaluated reqracer with requestraces thatwereproduced from ourstudied bugs.
these 12bugscoverallthefourwebapplicationsusedinourstudythat are developedwithphp i.e.
mediawiki wordpress moodle and drupal.
our evaluation results show that reqracer can effectively andefficientlydetectandexposetheseknownbugsbasedontraces fromrecordedrunswhererequestracesdonotmanifest.
reqracer alsofoundatleastfournewrequestracesthatwereunknownto us withthe testing workloadsfor the real worldbugs and two ofthemhave already been confirmedbydevelopers.
server side request racestudy in our characteristic study we follow the same methodology as takenbyexistingstudiesonconcurrencybugsinmulti threaded applications races in node.js applications and performancebugsinwebapplications .below wefirstdescribe the methodology andthen detailthe results.
844esec fse august athens greece zhengyiqiu shudi shao qi zhao andguoliang jin table1 webapplicationsandnumbersofbugsbeingstudied application abbreviation server side languagenumberon serversidenumberon clientside wordpress wp php mediawiki mw php drupal dpl php moodle mdl php bugzilla bz perl odoo od python dnn dnn c openmrs mrs java gitlab gl ruby discourse dc ruby redmine rm ruby spree spr ruby node.js based node.js javascript total .
methodology table1summarizesthenumberofstudiedrace inducedbugsand web applications from the bug tracking systems of which these bugs are collected.
we study bugs from two major types of web applications classical ones that access database by constructing sqlqueriesdirectly and thoseimplementedontopofruby onrails whichprovidesobject relational mapping orm support.
westartedwithpopularopen sourcewebapplicationsthathave beenpreviouslystudiedbyexistingperformance bugstudies which have non orm applications and orm applications respectively.
we also included extra non orm web applications that we have experience with.
to collect races we searched across the bug tracking systems of these applications for closed bugs using keywords related to races such as race s concurrency atomic and synchronization.
then we manually filtered out results obviously not related to races e.g.
braces or traces can be returned while searching for race.
afterkeywordsearchandfiltering weobtainedaround1400 bug reports.
we then manually examined each bug with sufficient informationforustounderstandtherootcause andwecollected bugs with clear root causes that are related to races.
our final selection includes a total of bugs from popular open source webapplicationscoveringsixdifferentserver sideprogramming languages.we omit applicationswithoutany race inducedbugs.
we also included race induced bugs in node.js based web applications from the two previous studies on node.js projects the total of which is as other bugs are either in node.js based middlewareordesktopapplicationsbutnotwebapplications.since these bugs are in different node.js web applications we omit theirnames dueto spacelimit.
after collecting race induced bugs from the bug tracking systems of these web applications two inspectors first independently checked all available resources e.g.
source code developer discussions and patches compared their characterization results and resolveddisagreement if any.
among the bugs we collected are induced by serverside races and are induced by client side races.
note that we includedallrace inducedbugsthatwecouldunderstandregardless ofwhethertheyareontheserversideorontheclientsidewhile collecting the bugs and the separation of server side races from client side races was done after we collected all race induced bugs.such a distribution shows that server side races are indeed understudiedcomparedwithclient sideracesandwarrantmoreresearch attention.ourinvestigationfocusedontheserver sideraces and future work can further study the client sideraces.
.
characteristic studyresults table2summarizes our findings.
before describing the details we note that two general observations we made during our characteristicstudyarealignedwithourargumentmadeearlier i.e.
existing system layerracedetectiontechniquesarenoteffectiveforrequest races.
first all the server side races in web applications we studied areintheapplicationlayerbutnotinthesystemlayer.secondly we do not see a case where developers used existing race detection toolstohelpdebugging whicharguablyimpliesthat practical thread race detection tools commonly mentioned in thread race bug reports are not useful for request races and tool support fordebuggingrequestracesisingreatneed.below wedetailthe resultsonthefollowingcharacteristics racing resourcetypes rootcause patterns and manifestation conditions the effects of races and fix strategies.
we end this section with a discussion on how theseresults depend onexternal factors.
racing resource types.
databases files cache using modules like redis or memcached and shared memory data structures are the racing resources we found in our studied request races.
four bugsinvolveconsistencyissuesbetweendatabaseandcache and their racing resources include both databases and cache.
while thread race techniques cover shared memory data structure and process race techniques cover files asa racing resource tools targeting request races need to further model and analyze accesses to databases and cache.
further some races involve inconsistency between databaseandcache whichneedsto be accountedfor.
root cause patterns and manifestation conditions.
in our studiedbugs atomicityviolationandorderviolationarethetwo root cause patternsof howthe shared resourceaccessesin racing request handlers can lead to failures or undesirable effects.
all studiedracesinvolvingonlyonerequest i.e.
intra requestraces manifest as order violations and all studied races involving two requests i.e.
inter request races manifestas atomicity violations.
for atomicity violations all studied races can manifest with two racingrequesthandlers andtheviolatedatomicityassumptionis on accesses within a single request handler but not across multiple request handlers.
as a result we only need to check pairs of concurrent request handlers to detect request races manifestingasatomicityviolationsonshared resourceaccesses.however not all atomicity violations can manifest with two instances of the samerequest whichwillbehandledbythesamerequesthandler.
one third of them require two requests that will be handled by differentrequesthandlers.existingdynamicrequest racedetection techniquesinliterature onlycheckracesbetweenarequest handlerwithitself andtheywillmissallracesrequiringtwodifferentrequesthandlers.weareingreatneedoftechniquesthatcan detectrequest racesbetween distinct request handlers.
fororderviolations allthestudiedcasesareduetoasynchronous execution.
since modern orm and node.js frameworks have builtinsupportforasynchronousexecution webapplicationsbuiltwith suchframeworksaremorepronetoorderviolations whichispartly 845understandinganddetectingserver siderequest racesin webapplications esec fse august athens greece table overallcharacteristic study results wpmwdplmdlbzoddnnmrsgldcrmnode.js total number of bugs studied racing resourcetypes database file cachewith modules like redis ormemcached shared memorydata structure root causepatterns and manifestation conditions atomicityviolation with twoinstances of the same request handler atomicityviolation with twodifferentrequest handlers orderviolation withinone request handler effects of database races databaseerroronduplicatedata insertion applicationerrorcaused by duplicatedata inconsistentorstale view misleadingerrormessage programcrash orfailure fixstrategies for database races atomicityviolation change applicationlogic atomicityviolation handle the race properlywhen it happens atomicityviolation guaranteecolumnvalueuniqueness atomicityviolation use duplication tolerantsql query atomicityviolation refactorquerystatement atomicityviolation addtransactionorleverageexistingtransaction atomicityviolation lock the table atomicityviolation use atomicapi atomicityviolation fix in frontend orderviolation enforce orderby callbackfunction orderviolation use synchronous execution orderviolation removetransaction effects of file races duplicate file directorycreation filedata corruption non existingfile directoryerror misleadingerrormessage fixstrategies for file races atomicityviolation change applicationlogic atomicityviolation handle the race properlywhen it happens atomicityviolation guaranteefilenameuniqueness atomicityviolation addfilelock effects of cache races inconsistentorstale view fixstrategies for cache races atomicityviolation change applicationlogic atomicityviolation handle the race properlywhen it happens atomicityviolation guaranteecachekeyuniqueness orderviolation use proper cacheapi effects of shared memorydata structureraces applicationerrororexception request never beresponded to programcrash orfailure fixstrategies for shared memorydata structureraces atomicityviolation use databaseinstead atomicityviolation addlanguage provided lock orderviolation change applicationlogic orderviolation addcondition to enforce order orderviolation read again aftera delay reflectedbythefactthatonlyoneoutofthe20orderviolationsare inthe firsteightnon orm non node.js webapplications.
unserializableinterleavingpatternsinatomicityviolations.
to summarize unserializable interleaving patterns in atomicity violations wefollowtheargumentsraisedbyzhengandzhang in theirworkofstaticdetectionofrequestracesmanifestingasatomicity violations.
specifically operations like file append and database delete cannot be modeled as write operations.
for example a local selectqueryandalocaldeletequeryinterleavedwitharemotedeletequeryonthesamedatabaserecordisunserializableifthey aremodeledas rw w.however thisiswrongasithasthesame consequence as first performing the local select and delete queries and then the remote delete query.
therefore they introduced two new operation categories i.e.
afor append and d for delete and wis now specifically for overwrite or update.
with thesefourtypesofoperations adrw defined alotofinterleaving patterns are possible.
they further argued that a lot of them are unlikely in practice and suggested four unserializable interleaving 846esec fse august athens greece zhengyiqiu shudi shao qi zhao andguoliang jin table the patterns of unserializable interleavings and their numbers inour studied request races pattern number r r a w d a w d r a a r w a w a r w a dd aa a w a d w r patternsthatcouldhappeninpractice rr a w d a w a a r w a w a r w a and dd aa .
with these four unserializable interleaving patterns we first matchedourstudiedatomicityviolationsinvolvingasingleresource against them.
for those without an exact match we modified a close match or proposed a new pattern.
table 3summarizes the results.thefirstfourpatternsaremostlythesameastheonesby zhengandzhang withthefirstpatternmodified.thesefour patterns cannot be further merged as the first operations of the fourpatternsaredifferent.amongthesefourpatterns thefirstone isthemostcommoninourstudiedbugs.wealsofoundonenew pattern with bugs matching it where most of these bugs are racesoncacheandshareddatastructures.wedidnotmergepattern with pattern as that results in a w a r w d a r butar ris serializable.
all the four races involving both database and cache are categorized as pattern .
specifically the buggy interleavingisthatonerequestfirst queriesdatabaseandcaches the queried results.
before the cached results are accessed another requestupdatesthedatabasewithoutinvalidatingthecache and the first request will later access stale data that is not consistent withthe database.
although the first four patterns are initially proposed by zheng and zhang based on intuition the value of our results lies in that we confirm that they are indeed the most common ones with our collected real world bugs and we further refine them.
we further summarize one new pattern i.e.
pattern which zheng and zhang suggested as being unlikely but we observed such a pattern in real world request races partly due to our inclusion of request racesoncache andshareddata structures.
theeffectsofraces.
outofthe104studied request raceson databases can lead to duplicate data insertion.
among them result in database errors and result in application errors.
the majority of the remaining database races lead to inconsistent or stale views.
file races can lead to various errors such as duplicate file directory creation or non existing file directory errors.
file races can also lead to data corruptions.
all cache races lead to inconsistentorstaleviews.racesonshared memorydatastructures canleadtovariousfailuresanderrors.theycanalsoleadtorequests neverberespondedto andsucheffectsarenotobservedonraceson otherresources.forsomeoftheseraces thefailureeffectsareeasy to detect such asthoseresultingin explicit errors.for othersthat 1eachpatternhasfourorthreeoperations.thefirstandthirdoperationsarefromone request.the secondand fourth whichare marked are from the second request.if one operation has multiple possibilities they will be put inside and separated by .astands for append operations which include database insert file append file dir create andcacheadd dstandsfordeleteoperations whichincludedatabasedelete file dir delete and cachedelete rstands for read operations which include database select file dirread cacheread wstandsforwriteoperations whichincludedatabase update fileoverwrite and cacheset orreplace and stands for null operations.lead to inconsistent views or data corruptions on shared resources sometypesofcheckerstakingapplicationsemanticsintoaccount are neededto catch the effects.
amongthe91racesontwoinstancesofthesamerequesthandler of them are racing on databases.
further the aforementioned races leading to duplicate data insertion with either database or application errors are all among these and can manifest with two instances of the same request handler.
these numbers suggest that we can use an effect oriented approach to find a large portion of database races between two instances of the same request handler by focusing on detecting request races with the duplicatedata insertion effect.
fix strategies.
out of the studied atomicity violations are fixed using database locks transactions file locks or languageprovidedlockstoprovideatomicity.thepatchesforthemajorityof remainingatomicityviolationsinvolve designorapplication logic changes.theseresultsareconsistentwiththeconventionalwisdom that there are few synchronization operations to use on the server side and thus some design or logic changes are often needed to fix request races.
for order violations using callback functions and changing applicationlogic are the twomajorfixstrategies.
oneinteresting finding on fix strategies isthatfourserver side requestracesare fixedbychangesinclient side code suchasdisablingabuttonontheclientsideifthebrowserhasnotyetreceived the response for an earlier request which was sent by clicking the samebutton toavoidtwoconcurrentinstancesofthesamerequest.
dependencyonexternalfactorsanddiscussion.
inourstudy we paid attention to several external factors including web server configuration database configuration and development languages andframeworks andstudiedthe impact of theseexternal factors.
some web servers e.g.
apache httpd commonly provide differentmulti processingmodules i.e.
prefork worker andevent whilewebapplicationsbuiltontopofthenode.jsframeworkuse theevent basedmodel.inourstudy wedidnotfindtheunderlying multi processingmodelaffectthewayhowwedefineserver side requestraces i.e.
thestudiedracesareonrequesthandlersupon receivinghttprequests.suchadefinitionabstractsawaywhether a request is served by a process or thread and whether a request is served with an event based model.
on the other hand we found requestraceswhose manifestationconditiondependsondatabase configuration.
for example the myisam storage engine in mysql doesnotsupporttransactions andwehaveseenmediawiki racesthatarecausedbytheuseoftransactions whichonlymanifest if myisam but not innodbisusedinmysql.
intermsofthedependencyondevelopmentlanguagesandframeworks built insupportforasynchronousexecutioncouldmakeweb applications more prone to order violations as we discussed earlier.
we alsonotethat non orm non node.js webapplicationhasthe leastnumber ofracesracingonshared memory datastructure as theirdevelopmentlanguagesprovidelittlesupportforsharedmemory natively.
on the other hand some other number differences maynotbedependingonlanguage framework.nonode.jsrequest racesareonfileorcache whichisprobablyduetothesmallertotal number of request races being studied.
also the differences on the total numbers of request races we studied in different types of web applications i.e.
westudythelargestnumberofrequestracesin non orm non node.js web applications and the smallest number 847understandinganddetectingserver siderequest racesin webapplications esec fse august athens greece backup and restoretrace for replayclient db cache file web serverserver sidereq offline analyzertracing deployed system validation replay system inference true and harmful racesclient db cache file web serverserver sidereq figure the architecture of reqracer innode.jswebapplications aremorerelatedtothedevelopment history length ofwebapplicationsbeing studied.
although we included some bugs from node.js based web applications which were studied inearlier studies our focus is different aswespecificallyfocusonwebapplicationsbuttheirstudies include othertypes of applicationsbuilt on top ofnode.js e.g.
middlewareanddesktopapplications.duetothisdifference our characteristicstudyisessentiallytargetingadifferentsubject.moreover our study includes 146more request races from non node.js web applications which allows us to both find characteristics that are common to all types of web applications and to understand the impact ofdevelopmentlanguage framework differences.
server side request racedetection based on our characteristic study results we design a dynamic framework reqracer to detect and expose server side request racesthat manifestasatomicity violations.figure 2illustratesthe architectureof reqracer andithasthreemajorstages.thefirst stage records four types of runtime information and they are used fordeterminingshared resourceaccesses reasoningaboutdependencies between requests and enabling execution replay.
the secondstageconsumesthetracesrecordedduringthefirststageandinfers potential unserializable interleavings to detect racing requests.
the last stage replays the recorded traces tries to enforce the unserializable interleavings inferred by the second stage and observes their effects.
racing requests with triggered harmful unserializable interleavings willbe reported.
.
illustratingexample the key contribution of reqracer is to model happens before relationshipsessential tohttp requestsin webapplications with a novel form of dependency graphs so that the well established tracing inference validationarchitecturecanbeappliedtodetect request races.
wewillusewordpress11073toillustratethedependency graph constructionprocessshowninfigure .therequestraceisbetween adding a comment for a post and trashing the post.
while trashing a post in one request the ids and current statuses of its comments are first backed up for possible future restoration and then the statuses of all existing comments will be marked as trashed.
in between these two steps another concurrent request can add a newcommenttothepostbeingtrashed.underthissituation the comment is first successfully added to the post and displayed to req14 get trash page req15 post to trash req16 get the redirected pagereq2 get add post page req3 ajax post autosave req4 ajax get permeant link req5 ajax get token update req6 ajax post autosave req7 post to publish req8 get the redirected page req17 get untrash page req18 post to untrash req19 get the redirected pagereq10 get comment page req11 post to submit req12 get the redirected pagereq1 get admin page grp1 3req9 get site home page req13 get admin pagegrp2.
add a new post grp3.
go to site home grp4.
add a comment grp5.
go to admin page grp6.
trash the post grp7.
untrash the post grp3grp2 grp5grp4 grp6 grp7grp1.
go to admin pagefigure anexample ofdependency graph construction the user and it is then marked as trashed since the post is being trashed.
however the new comment is not backed up and this commentcannotberestoredifthepostisuntrashedlater.theuser whoaddedthenewcommentwillobserveinconsistentviews as thecommentwasfirstaddedsuccessfully butlaterthecomment willbegoneiftheuserrefreshesthepostthatjustwentthrough the trashanduntrash process.
now assuming a developer is some testing for wordpress.
inabrowser thedeveloperfirstgoestotheadminpageandadds a new post then goes to site home and adds a comment for the newly added post and finally goes back to the admin page to trash and thenuntrashthe post.inthis sequence the harmfulraceis not triggered.duringthisprocess reqracer recordsasequentialtrace as shown in and it then constructs the dependency graph as shownin .notethattheboxessurroundingtherecordedrequests in1 are addedfor illustration purposes but not part of the trace.
with these recorded requests one extreme is to consider all recorded requests as totally ordered under which case we will not be able to infer any potential races.
the other extreme is to consider that allrequestscan potentially be sentconcurrentlyvia different browsers or tabs under which we will be inferring too manyfalsepositives.therefore weonlyrelaxordersbetweentruly independentrequestsbutpreserveordersthat oncerelaxed can disable subsequent requests and lead to replay divergences.
in figure3 reqracer will go through to find potentially concurrentrequests from the sequenceof recordedrequests.
from1 to2 reqracer groupsrequeststhat have arequestresponse request rrr dependency i.e.
one request can only be sentaftertheresponseofthepreviousrequesthasbeenreceived by the client.
such an rrr dependency can be established in three waysin figure .first apostrequest could depend onthe previous get request and this applies to req2 req7 req10 req11 req14 req15 andreq17 req18.
second a get request to a redirectedpagedependsonthepreviousrequest andthisapplies toreq7 req8 req11 req12 req15 req16 andreq18 req19.
third ajax requests depend on the previous get request and this 848esec fse august athens greece zhengyiqiu shudi shao qi zhao andguoliang jin applies to req2 req3 req4 req5 req6 .
grouping requests with dependencies together we get a total of seven groups shown in figure3.
.reqracer recognizestheserrrdependenciesthrough programmodificationstoembedtokensintorequestsandresponses.
notethatthetextdescriptioninfigure .
isjustaddedtoease understanding but not inferredby reqracer .
from2 to3 reqracer adds an edge between two request groupsifthereisaspecialtypeofdatadependenciesbetweenthem i.e.
whenarequestissuesaselectquerywithaprimarykey and thedatabasereturnsasinglerowthatwasinsertedbyaqueryfrom anearlierrequest.wenameitasselect by primary key spk data dependency.
the rationale is that if one considers two requests withanspk datadependencyasconcurrentandforcefullysendthe latterrequest before receivingtheresponse oftheformer request theselectqueryinthelatterrequestwillreturnzerorows which couldsignificantlyaffecttheexecutionofthecorrespondingrequest handlercomparedwiththerecordedrunwhereitgetsonerow and itwillresult inareplaydivergence.
for example the spk data dependency edge from grp2togrp4 infigure .
isaddedbecauseonequerysenttodatabasewhile handling req10queriesasingletonofresultspecifiedwithaprimary key that was inserted by req7.
as it is a singleton inserted by req7 req10willgetanullresultifwerelaxtheorderbetween req7and req10 which can significantly affect the request handlers handling req10andotherrequestsfollowingitinthesamegroup.asaresult we will not be able to add comments to the post in grp4if the post hasnotbeenaddedin grp2yet.theotherspk data dependency edge is added for a similar reason.
reqracer recognizes such data dependenciesbyrecordingdatabasequeriesandselectedresponses.
note that our spk data dependency is different from general datadependencywherealatterqueryreadsdatainsertedorupdated byanearlierquery.thisisbecausetheeffectofchangingtheorder oftwoquerieswiththegeneraldatadependencyhighlydepends on the business logic of the corresponding request handlers and canonlybeobservedduringreplayrunsingeneral.however ifthe select queryspecifies aprimary key the corresponding request handler will have significantly different business logic for cases wherethequerygetsoneroworgetsnorow andwecaninferthat there willbe replaydivergencesif the order isnot enforced.
withthedependencygraphinfigure .
andrecordedtraces onaccessestosharedsystemresources tworequestsarepotentially concurrentiftheyareindifferentrequestgroupsthatarenotreachableonthedependencygraph.infigure reqracer determines thatgrp4andgrp6are potentially concurrent and they contain req11andreq15 whicharetheracingrequestsinwordpress11073.
afterinferring concurrentrequests reqracer further checks unserializable interleavings and validates them and the race between req11andreq15willbe reportedas atrue harmfulrequest race.
.
tracing andrequest raceinference reqracer employsserver onlytracingbutrequiresnomodifications on the client side making it easy to deploy and broadly applicable.
in particular reqracer records http requests received by the http server accesses to shared resources including database queries and calls to cache apis the return value of functionsthat are usedto getthe primary key ofthe rowinsertedbyapreviousinsertquery and uniquetokensgeneratedwhile formulatinghttpresponses.
shared resourceaccesses andtokens are attributedto the request that initiates them.
with dynamic execution traces reqracer first identifies conflictingrequests i.e.
apairofrequestswhoserequesthandlersboth accesssomesharedresourceincommonandatleastonerequest handler performs logical append delete or write operations to the resource.
reqracer thenbuilds adependency graph asillustrated infigure andtworequesthandlersthatareindifferentgroups and not reachable from each other are considered as concurrent.
finally reqracer reportstwoconflictingandconcurrentrequest handlers as racing if the two request handlers can exhibit unserializableinterleavingsofshared resourceaccesses.below wedescribe each of these three steps including what information is traced and howthe tracedinformation isanalyzed.
whileourframeworkcanbeusedforalltypesofracingresources thatwehaveseeninourstudy ourprototypeimplementationof reqracerhandlesdatabasesandcache.toextend reqracer forfiles oneneedstoincorporatetechniquesoftracingandanalyzingfile accessespreviouslyusedforprocessraces intoourframework.toextend reqracer forshared memorydatastructures one needs to further trace and analyze shared memory accesses.
in bothcases happens beforerelationshipsmodeledby reqracer s dependency graphs could be reused.
.
.
identifyingconflictingrequests.
reqracer considerstworequestsasconflictingiftheircorrespondingrequesthandlerscontain conflicting accessesto eitherdatabasesorcache.
on database queries reqracer currently logs select insert update anddelete.forselect update anddeletequeries wedeterminetherowsofdataelementsbeingaccessedbasedonthe whereclause.aninsertqueryaddsanewrowtoatablewith thevalueofeachcolumnspecified.weextractthecolumn value pairs from an insert query string.
these four types of queries are sufficient inour evaluation andmore can be addedif necessary.
for two insert queries if they operate on the same unique key andthevaluesinsertedtotheuniquekeyarethesame these two insert queries are conflicting.
otherwise if no unique key appears in an insert query string reqracer currently considers twoinsertqueriesconflicting if they insert the same data.
to find conflicts between a query with a where clause and an insertquery wecomparethewhere clauseconditionswiththe column value pairs from the insert query.
if the column value pairssatisfy the conditions the twoqueriesare conflicting.
tofindtwoconflictingqueriesbothwithawhereclause we compare their conditions.
if there issome intersection we conservativelyconsiderthesetwoqueriesas conflicting.
one special case is a select query without a where clause.
for this type of select query we consider it as accessing the whole table and conflicting with any query that modifies the table.
on cache accesses reqracer currently logs add delete get set andreplaceoperations.twocacheaccessesareconflictingif they have the same key and at least one of them is an add delete set orreplace operation.
.
.
dependency graphconstruction.
asillustratedinsection .
reqracer constructsthe dependency graph intwosteps.
849understandinganddetectingserver siderequest racesin webapplications esec fse august athens greece to model the rrr dependency between two requests where thesecondrequestcanonlybesentaftertheresponseofthefirst request has been received by the client we modify the web applicationtoincludearandomtokenuniquetoeachrequestwhen formulating responses to the client and it leverages the requestresponse requestchainestablishedbytherandomtokenembedded inresponses to capture rrrdependencies.
therearefourscenarioswherethistokenisembedded.forforms inhtmlresponses weaddanewhiddenfieldtotheformswith thetoken value.for embeddedurls inhtmlresponses weadd the token as a url parameter.
for http redirection responses we alsoaddaurlparametertotheresponseurl.inthesethreecases laterrequestssentthroughthetoken embeddedhtmlelementsor urlswillautomaticallycarrytherandomtoken.forallhtmlpage responses that could enable ajax requests we add the token value asametapropertyundertheheadtagoftheresponsehtmland registersanewfunctionwithjquery sajaxprefilterinterface where thefunctionwillreadandattachthetokenvaluetoallajaxrequests sent from this page.
to avoid potential client side races on these token values the random token valueis always parsed and loaded aspartoftheresponsebeforesubsequentrequeststhatneedtocarry thetokenvaluecanbesent.notethatsimilarmechanismsareused to implement cross site request forgery csrf tokens .
while csrf token is unique for every web session our new token will be unique for every response.
our implementation leverages existing csrf token code to embedour newtoken for rrrdependency.
with these modifications reqracer can establish a requestresponse request chain and add an rrr dependency edge between two requests when the second request contains a token value that matches the token value embedded into the response of the first request.
after identifying pair wise dependencies based on tokens these requests are further grouped until no two requests from differentgroupshave an rrrdependency.
after grouping requests based on rrr dependencies reqracer next adds edges between request groups with spk data dependencies whichhappenswhenone selectquerywithaprimarykey specifiedinthesecondgroupgetsonerowinsertedbyaqueryin thefirst group.specifically if arequest rqaiinrequest group grpacontainsaninsertqueryandthenewlyinsertedrowhas valuevon a primary key column colp a request rqbjin a different request group grpbwhich contains a select query with a whereclause colp v and grpaappearsbefore grpbinthe trace reqracer adds an spk data dependency edge from grpato grpb.
note that requests after rqaiingrpawill still be considered aspotentiallyconcurrentwithrequestsin grpbandwillbechecked byreqracer .
we do not add data related dependency edges on cache as a requesthandlerwillusuallybringthedataintocachebyitselfin cases of cache misses without relying on other request handlers to bringthe data in.
.
.
request race inference.
reqracer currently focuses on detecting request races with atomicity violations as their root causes.
with the dependency graph constructed reqracer then checks whether two conflicting concurrent request handlers have sharedresource accesses that can exhibit unserializable interleavings withthepatternsshownintable .reqracer identifiespotentialrequest racesfor validation if unserializablepatterns are found.
to detect races between two requests that will be served by two instances of the same request handler reqracer duplicates the selectedrequesthandler considerstheoriginalrequesthandlerand the duplicated request handler as concurrent and applies the same checking of unserializable interleavings.
the duplicated request handlerwillonlybecheckedagainstitsoriginbutnototherrequest handlers.wefurtherfollowtheeffect orientedapproach to handle the majority of races between two instances of the same requesthandlerasdiscussedinsection .
i.e.
wefocusonfinding duplicatedata insertionracesbyduplicatingarequestonlyifthe corresponding requesthandler issuesoneselect queryandone insertquery that are conflicting.
.
replay basedvalidation whiletherrrandspk dataedgeshelptoreducethenumberof falsepositivestobeprunedbythevalidationstage replayisstill necessary to validate the remaining request races by observing the effect of enforcing specific interleavings to determine whether they lead to errors or replay divergences.
reqracer reports a true harmfulrequest raceonly if itdetectsfailures.
in the replay stage reqracer replays recorded requests and interceptstheirresponses.inonereplaysession reqracer replays requestsuntilreachingonerequestintherequestracetovalidate.
whilethisreplaysessionispausedbeforethefirstracingrequest reqracer replays the other racing request in a different replay session and all requests that the second racing request has general data dependence as defined in section .
on but have not been replayed will be replayed in the order they appear in the trace.
to validate duplicated instances of the same request handler we simply replaythe same request twice.
with both replay sessions pausing before racing requests reqracercontrols the execution of the racing request handlers to makeshared resourceaccessesfollowtheorderofunserializable interleavings.
to achieve this we insert delays in the database execution engine and cache access apis to control the order of accessestodatabasesandcache.asnotallinterleavingsarefeasible to enforce reqracer gives up an interleaving if one access has beenwaitingforapre definedtimeoutvaluebutitisnottheaccess to proceed according to the interleaving to enforce.
reqracer currentlysetsthetimeoutvalueto10seconds.
reqracer alsogives up an interleaving if a response indicates an error and reports the request race as a true positive.
if an interleaving is successfully enforced reqracer will detect failures by checking whether thereareapplicationerrors databaseerrors orerrorsemittedby programmer suppliedapplication specificcheckers.ifafailure is detected reqracer reportstherequestraceasatruepositive.inall othercases the inferredrequest raceisprunedas afalse positive.
toenablereplay basedvalidation weneedtocreatebackupsfor persistentsystemresourcessothattheycanberestoredontothe replaysystems.fordatabasestates reqracer usesthebackupand restore functionality provided by databases.
as cache is less persistent cache state is not backed up for restore and it is populated duringreplaybasedondatabasestates.
850esec fse august athens greece zhengyiqiu shudi shao qi zhao andguoliang jin table overall evaluation results.
reqs shows the number of requests in the workload.
acc.
represents the number of database or cache accesses in the trace.
confl.
reqs shows the number of conflicting request pairs.
rrr spk s and r showthenumbersofconflictingrequestpairsprunedbycheckingrrrdependency spk datadependency serializability andreplay respectively.
tp and fp showthenumbersoftruepositivesandfalsepositives.
likelytp isforcasesthatcan be detected if application specificcheckersare added.numbers with an are unknownto uswhile devising the workload.
buginformation between distinctrequest handlersbetween twoinstances of the same request handler bugidracing resourcereqs acc.confl.
reqsrrrspk srtplikely tpfpconfl.
reqssrtplikely tpfp wp database wp database wp database mw database mw database mdl28949 database mdl43421 database mdl51707 database mdl59854 database dpl database wp cache wp cache database implementation and evaluation we implemented a reqracer prototype for the popular lamp stack i.e.
linux apache mysql and php.
the prototype consists of components for server side tracing and replay based validation which is implemented by modifying php mysql and application specific cache apis.
the inference step is implemented using python.
we use an open source tool gor to capture and replayhttprequests.toenabletoken baseddependencytracking wecurrentlymanuallymodifytheapplicationstoembedthetokens leveraging existing csrf token sites.
to embed tokens we first determine the names of csrf tokens used by an application.
in our experiments we can get the names effectively by checking the hidden fieldnamesinhtmlresponsesthroughabrowser.once wegetthenamesofcsrftokens wesearchtheapplicationcode to find the sites where such csrf tokens are embedded.
we finally embed andlog ourtokens at thesesites following the ruleof how csrftokens are embeddedinthe application.
wedonotautomatecache apichangesandtokenembedding as they areapplication specific.fortunately our experience suggests that places where we made changes are well modularized and weexpecttheworkloadofporting reqracer tonewapplications underthe lamp stack to be small.
to evaluate the effectiveness and efficiency of reqracer in detecting request races we mimic the way how developers may testtheirwebapplications i.e.
byclickingbuttonsonthebrowserto visitvariouspagesandusevariousfunctionalities andweleverage knownreal worldbugstodevisebug triggeringworkloads.among all the bugs we have investigated in the characteristic study we are currently able to reproduce a total number of bugs from wordpress mediawiki moodle and drupal and we used all these 12real worldbugstoevaluate reqracer coveringallthefourphp webapplicationswestudied.basedonthese12bugs wedevisea workloadthatvisitsallthepagesinvolvedineachbug.notethat the workloads we come up with just visit all the pages one by one butnotconcurrently andtheracesarenottriggeredintherecorded runswithlimitedconcurrency.wealsovisitsomepagesthatare not essentialto the buginour devisedtestingworkloads.all our experiments were conducted on a machine with an intel core i7 cpu and 16gb memory.
the software versions are apache httpd .
.
mysql .
.
and php .
.
.
cache is set up according to the requirement of each individual case and we install the cache component only while evaluating with workloads for wp andwp .
.
effectiveness results table4summarizestherace detectionresults.notethat arequest racecouldmanifestunderdifferentworkloads andwearereporting the numbers of unique request races.
in total reqracer detects and exposes unique request races that are true and harmful including13uniquerequestracesthatcanexplainthe12known bugsandfouruniquerequestracesthatarepreviouslyunknown to us while devising the workloads.
reqracer also detects eight uniquerequestracesthatarelikelytruewithapplication specific checkersadded.asdiscussedinsection .
theeffectsofrequest racesthatleadtoinconsistentviewsordatacorruptionscanonly becaughtwithsometypesofcheckerstakingapplicationsemantics into account.
to catch these request races we came up with applicable specificcheckersbasedonourunderstandingofapplicationswhilemanually checking false positives.
for request races between distinct request handlers table shows the numbers of conflicting request pairs and false positives prunedbydifferentstrategies.thenumbersshowthatafterpruning false positives by rrr dependency spk data dependency and serializabilityinference themajorityoffalsepositivesarepruned.this shows that these three strategies combined are very effective.
the remainingfalsepositivesareduetoeitherourconservativeanalysisonwhereclausesorfailure freeexecutionsafterenforcing alternative interleavings andthey are prunedbyreplay.
for request races between two duplicated instances of a request handlerwithconflictingselectandinsertqueries two thirds of the false positives are pruned by serializability checking and the remainings are pruned by replay.
for false positives pruned by replay thereisnoapplicationerrorordatabaseerroruponduplicate data insertion.
our evaluation results show that the effect oriented 851understandinganddetectingserver siderequest racesin webapplications esec fse august athens greece approach caneffectively find request racesbetween two instances ofthe same request handler.
weidentifiedlikelynewbugs whichrequireapplication specific checkers bycheckingalltherequestracesprunedbyreplayand adding application specific checkers designed based on studied requestracesresultingininconsistentandstaleviews.forexample weaddedcheckerstodisallowduplicatecommentsinwordpress anddisallowduplicateclass namealiasesinmoodle.
fornewbugsandlikelynewbugs wehaveverifiedthattheystill existinthelatestversion andweareintheprocessofreportingand confirming with developers.
so far two bugs have been confirmed including one that requires an application specific checker and othersare waiting for responses from developers.
manual checking of all the request races reported by reqracer revealedonefalsepositive i.e.
althoughweareabletotriggeran error under the workload for mdl by duplicating a request itisnotfeasibleinpracticeastheclientsidewilldisablethebutton while waiting for the response.
we leave it for future work to addressthis limitationbyincorporatingmore client sideanalysis.
.
efficiencyresults we evaluated theoverheadof reqracer srecording step by measuring the time between sending a request to and receiving the response from the server and the overhead is between to6 .
note that our numbers were measured with both the server and client on the same machine and we expect the overhead to be smaller in a real world deployment setting after including network latencies.
in our evaluation the inference step can finish within seconds and the validation time varies from seconds to several minutes depending on the number of unserializable interleaving to prune.
on the other hand if a developer were to manually conduct stresstestingbyrepeatingthesequentialworkloadmanytimes the bugs are unlikelyto be triggered.
even ifa bug is triggeredonce it is difficult for the developer to know exactly how to trigger it whilereqracer can reliably trigger abugonceitisdetected.
threats to validity characteristics studies are subject to validity problems and our characteristic study results need to be taken with the methodology and our selection of web applications in mind.
one threat is the likely lack of representativeness of the studied applications and request races.
to minimize this threat we choose popular opensource web applications with a significant user base.
our choice of applications also covers several popular development languages and framework for the server side.
the other threat is related to themanual inspectionof bugreports.
toalleviate thisthreat two authors first independently study the collected bugs by thoroughly investigatingtheresourcesthatareavailabletous.oncetheyfinish they cross checktheirresults anddraw aconclusion.
the evaluation of reqracer is also subject to validity problems.
one threat is the correctness of the implementation and the representativeness of bugs used for evaluation.
to minimize this threat weuseallknownbugsthatwecanreproducefromallfourphpweb applications included in our study.
another threat is the validity ofthenewlydetectedbugsby reqracer .wemitigatethisthreatbyreportingnewlydiscoveredbugstodevelopers andtwopreviouslyunknown bugs oneof whichrequiresanapplication specific checker have been confirmed.
regarding the general applicability ofourproposedtechnique ourcurrentimplementationonlyhandles web applications built on top of lamp.
during our evaluation reqracer wasimplementedbeforewereproducedanymoodleand drupalbugs andourexperiencesuggeststhatporting reqracer tonewlampapplicationswillbesmall.wealsobelievethatour key contributions on modeling happens before relationships could also apply to other types of web applications e.g.
orm based and node.js based andwe willleave itfor future work.
related work section1discussed some related work on several different types ofraces.wenextdiscussotherrelatedwork.server sidewebapplicationshavebeenthesubjectofalotofexistingresearch and many different techniques have been proposed for improving their reliability but none of them handles theconcurrency aspect.
some ofthese existingtechniqueshandle theinputgenerationproblem and reqracer complementsthese techniques bysolving the buggy interleavingexposing problem.
techniques focusing on the security aspect of web applications have been proposed e.g.
auditing intrusion detection and recovery andidentifyinginformationdisclosure .races are considered severe security vulnerabilities and they can enableconcurrency attacks .
ourproposedtechniquescan also help improve thesecurity aspectof web applications by detecting andexposing races.
similar to detecting client side races and node.js races techniques developed for android applications also focus on the eventdriven nature of the mobile platform .
some androidapplicationsalsohaveaclient serverstructure andtechniques developedinthispaper could alsobe leveragedto handle racesintheirserver side applications.
conclusion we present the first to the best of our knowledge comprehensive characteristic study of real world server side request races in web applications.
our results show that request races are indeed understudied and need more research attention.
we expect that future research can follow our study results to provide comprehensive support in combating request races.
guided by these results we developreqracer a framework for detecting and exposing request races.
our evaluation shows the effectiveness and efficiency ofreqracer .
future work can adapt reqracer for other types of webapplications repurposeitforproduction rundeployment or pursueclient server combinedapproachesfor in house testing.