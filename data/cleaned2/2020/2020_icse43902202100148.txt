fine with ?
an analysis of sms one time password randomness in android apps siqi ma1 juanru li2 hyoungshick kim3 elisa bertino4 surya nepal5 diethelm ostry5 and cong sun6 1the university of queensland slivia.ma uq.edu.au 2shanghai jiao tong university jarod sjtu.edu.cn 3sungkyunwan university hyoung skku.edu 4purdue university bertino purdue.edu 5data61 csiro fsurya.nepal diet.ostry g data61.csiro.au 6xidian university suncong xidian.edu.cn abstract a fundamental premise of sms one time password otp is that the used pseudo random numbers prns are uniquely unpredictable for each login session.
hence the process of generating prns is the most critical step in the otp authentication.
an improper implementation of the pseudorandom number generator prng will result in predictable or even static otp values making them vulnerable to potential attacks.
in this paper we present a vulnerability study against prngs implemented for android apps.
a key challenge is that prngs are typically implemented on the server side and thus the source code is not accessible.
to resolve this issue we build an analysis tool otp lint to assess implementations of the prngs in an automated manner without the source code requirement.
through reverse engineering otp lint identifies the apps using sms otp and triggers each app s login functionality to retrieve otp values.
it further assesses the randomness of the otp values to identify vulnerable prngs.
by analyzing commercially used android apps downloaded from google play andtencent myapp otp lint identified vulnerable apps that generate predictable otp values.
even worse vulnerable apps use the otp authentication alone without any additional security mechanisms leading to insecure authentication against guessing attacks and replay attacks.
index terms otp authentication protocol mobile application security pseudo random number generator vulnerability detection randomness evaluation i. i ntroduction sms one time password otp is widely used for authentication and authorization in android apps which employs a uniquely generated pseudo random number prn for each login session to verify each user s identity.
a pseudo random number generator prng is commonly used to generate unpredictable otp values.
some cryptographically insecure randomness algorithms such as mersenne twister mt and linear congruential generator lcg have been used in practice.
a prng using any of these insecure randomness algorithms would generate highly predictable otp values.
even though the utilized randomness algorithm is secure the generated prns may still be problematic if the algorithm is not implemented correctly e.g.
seeding the randomness algorithm by using a constant .
many studies have been proposed to analyze the security of pseudo random number generating algorithms however these studies seldom analyze prng implementations in apps.
the techniques proposed for assessing the prng implementations mainly focus on open source systems e.g.
linux openssl .
however these techniques rely on code analysis and thus cannot be applied to analyze prngs of android apps.
this paper focuses on the following two goals exploring security vulnerabilities in sms otp values generated by android apps gaining insights into potential implementation issues of prngs used by these vulnerable apps without accessing the source code of the prngs.
towards fulfilling our goals we first study the algorithms and functions for generating prns to understand what types of vulnerabilities may occur in prngs.
next based on the official rfc documents and research work we introduce three critical randomness rules rule do not use a static otp value rule do not generate otp values according to specific patterns rule do not use a constant or predictable seed to initialize a randomness function section iii .
if the otp values generated for user authentication violate any of the randomness rules those otp values can be predicted and thus the authentication scheme can eventually be cracked.
we develop a novel analysis tool otp lint to assess the randomness of otp values and analyze the potential implementation vulnerabilities of the corresponding prngs without having access to the prng source code.
otp lint first identifies the login activity declared in each app using a fuzzing inspired approach.
it then recognizes those apps which use sms otp authentication through keyword matching.
by locating the otp login widgets otp lint triggers the relevant app functionalities and sends otp requests to the app server to retrieve otp values.
finally otp lint evaluates whether the gathered otp values violate any of the three introduced randomness rules.
a major challenge in the vulnerability analysis of otp values is to determine which algorithm and function are used to generate prns and which parameters they are given as input.
to address this challenge we collected prng sample codes written in diverse programming languages shared by app developers on github and stack overflow to learn the popular ieee acm 43rd international conference on software engineering icse .
ieee approaches for implementing prngs.
we used otp lint to analyze real world android apps downloaded from both google play andtencent myapp markets from google play and from tencent myapp .
out of these apps otp lint successfully detected that apps implemented sms otp login and .
of these violated the defined randomness rules.
our results demonstrate that a significant number of android apps would be at real risk of cyber attacks exploiting such otp login functions.
we believe that otp lint would help service providers and users test whether the otp authentication in android apps is securely implemented and highlight potential security issues without accessing prng source code.
our main contributions are as follows through an examination of the official rfc documents and research works we provide insights into potential implementation issues in vulnerable prngs and propose three types of randomness rules that must be followed for implementing secure prngs.
to the best of our knowledge this is the first randomness study of otp values generated by prngs used in android apps.
without knowing the detailed implementations of prngs we infer the potential vulnerabilities that might exist in the prngs through otp value analysis.
we build a novel analysis tool otp lint .
by triggering otp authentication in apps otp lint simulates the most common vulnerable prng implementations for otp randomness analysis and checks whether the generated otp values are vulnerable.
we used otp lint to analyze android apps and detected apps that produce predictable otp values.
interestingly vulnerable apps use the otp authentication alone without any additional security mechanisms leading to insecure authentication against guessing attacks and replay attacks.
ii.
a nalysis of randomness weaknesses we discuss the widely used randomness algorithms and present the randomness functions in programming languages that can be used for android apps.
a. randomness algorithms linear congruential generator lcg .
lcg is one of the most popularly used algorithms that generate a sequence of pseudo random numbers prns using a discontinuous linear equation.
lcg is defined by the recurrence relation sn a sn cmodm.
starting with a seed lcg repeatedly applies the recurrence relation to generate the subsequent prns.
such an algorithm is not cryptographically secure .
if a sufficient number of prns are gathered an attacker can predict subsequent values.
lagged fibonacci generator lfib .
lfib is an improvement of the standard lcg where prns are derived as a generalization of the fibonacci sequence.
such a sequence is generated according to the recurrence relation sk sn j sn pmodm j p where is any binary function such as addition subtraction multiplication or even the bitwise xor.
lfib thus requires an initial sequence and two seeds to begin.
however such algorithms using two seeds can be vulnerable to birthday attacks .
alternatively therefore three seeds are recommended to be used according to the expression sk sn q sn j sn pmodm q j p .
in addition the initial sequence of lfib should contain at least one odd number otherwise the generated prns would be all even.
however even if these issues are addressed lfib is still not cryptographically secure because it is represented as a linear recursion.
mersenne twister mt .
mt is another popular algorithm.
mt does not use any arithmetic operations i.e.
but is based on a group of permutation and tempering operations with shifts and and or jj and xor .
since mt is based on a linear recursion it is not cryptographically secure .
one can determine the internal state of the algorithm once a sufficiently long sub sequence of outputs is observed.
the most common implementation of mt is mt19937 in which only distinct outputs can be used to derive all the internal state variables of the prng .
well equidistributed long period linear well .
similar to the mt algorithm well is also a form of linear feedback shift register using simple bitwise operations.
a seed value is required to start the generation process.
with only a slightly higher time cost well obtains better equidistribution than mt .
well512 with a state size of bits is a widely used version.
its generated outputs are only selected within the restricted state instead of unbounded dynamic memory allocation.
the period length of the generated prns is approximately .
at first glance the use of well512 is sufficiently secure for otp generation.
however when the same seed is used well512 also becomes vulnerable .
b. randomness functions most programming languages provide the functions for generating prns by default.
instead of analyzing all of them we only consider the most common ones c c python php java and javascript .
we introduce the randomness functions that are frequently used to generate prns and discuss each function s security issues.
c c many prng functions are provided in the c library.
two primary functions are listed below.
rand this function is a c standard built in generator.
to ensure that the sequence of prns is unpredictable srand is called to initialize the prng with a seed value beforehand.
the algorithm of rand is adapted from the basic prng algorithm and simple operations such as arithmetic e.g.
and bitwise operations e.g.
are involved.
if a static seed is used the rand generates the same stream of prns.
hence in order to produce an unpredictable sequence of prns the initialization should not be a constant value but a pseudorandom value instead.
nonetheless rand uses the lcg algorithm without adding any entropy to the generator which is not cryptographically secure.
although the lcg parameters 1672are unknown the attacker can easily identify the parameters when consecutive outputs are collected.
rand s this is a secure alternative for rand .
it generates cryptographically secure prns depending on the operating system.
it is not affected by the seed produced by srand it also does not affect the pseudo random number sequence used by rand .
it is essential to mention that this function only works on windows xp and its later versions.
python python uses the mt algorithm as the core generator and leverages the standard mt implementation i.e.
mt19937 .
hence the randomness functions in python are unsuitable for cryptographic purposes.
random.randrange start stop this function generates a pseudo random integer within a range of .
by default start is defined as zero.
numpy.random.rand d0 d1 d n this function takes as input the dimensions of the array to be created.
it then creates the array and fills it with prns from a uniform distribution over .
php php is the most popular programming language for server side scripting.
three main functions are discussed.
lcgvalue this function is used in numerous places within the zend engine code as an internal function.
this function leverages two lcgs to get better quality prns.
a default seeding algorithm uses time and process id inputs to calculate a value to seed both lcgs.
the function implementation is proved to be cryptographically insecure as one can determine the generated values by only using consecutive outputs .
rand min max this function generates a pseudo random integer.
by default it falls back to rand supported by c with the range is .
the implementation of this prng generates a default seed by taking the current timestamp and the value generated by lcg value as input.
alternatively users can call srand to set the seed externally.
when a constant or predictable seed is chosen this prng becomes insecure.
mtrand this function is implemented using the mt algorithm.
by implementing mt19937 namely the standard implementation of mt this function is not cryptographically secure because the algorithm s internal states can be observed when successive outputs are gathered.
java there are three primary functions for prng implementations in the java development kit jdk .
random this function is included in the class java.util.random for generating a stream of prns with positive signs and restricted within .
this function is created based on knuth s subtractive algorithm that is an internal prns repeated cycle length is fixed.
in addition this class utilizes lcg with a bit static seed.
without any entropy added to the generator this function is not cryptographically secure because two pseudo random sequences created by the same seed are the same.
when the prng is unknown the prng parameters can be calculated when 232consecutive outputs are known.
math.random this function is included in the java.util package.
without giving any seed a java.util.randomobject is created when math.random is called hence the prns generated by math.random depend on random .
it is also cryptographically insecure.
securerandom this function is included in the java classjava.security.securerandom to produce secure prns.
by using sha as part of the random algorithm the generated prns are hashed hence securerandom provides a strong prng implementation to ensure a nondeterministic output.
in java it is thus critical to use the randomness function securerandom injava.security.securerandom class instead of using random ormath.random to generate prns for security reasons.
javascript.
javascript also provides math.random which is insecurely implemented in the same manner as java.
however several cryptographically secure randomness functions are also supported.
a web cryptographic function window.crypto.getrandomvalues with a high entropy seed is recommended.
furthermore a secure crypto library sjcl 1is also provided.
iii.
r andomness rules for one timepassword while weaknesses and recommended implementations of the randomness algorithms and functions are precisely described we are curious whether the prngs implemented by developers achieve the expected security level.
therefore we introduce three generic types of randomness rules for otp.
the sequence of the gathered otp values that violate any of these rules indicates that the opt values can be predicted with a significant probability.
note that we assume the network channel is secure when otp values are transmitted.
rule .
do not use a static otp value it forbids using a static value for all login sessions of different accounts which violates the requirement of otp randomness.
consequently the security of the otp authentication scheme is not guaranteed once the otp value is exposed to attackers.
threat.
when a static otp value is used the otp authentication is vulnerable to replay attacks.
if the length of the otp value is insufficient the otp is guessable through brute force attacks.
rule .
do not generate otp values according to specific patterns otp values should be unpredictable.
however some real world randomness functions generate otp values in specific patterns which can be statistically observed.
we discuss the three sub rules below.
rule .
do not generate a repeated sequence of otp values it states that the prng should not generate prns with a fixed period length.
unsurprisingly if otp values are periodically repeated attackers can easily predict the otp values when the number of generated otp values is larger than the period size.
rule .
do not repeat each distinct otp value ntimes it demonstrates that each otp value should not be used repeatedly for the nconsecutive login sessions.
1sjcl 1673rule .
do not generate otp values with predictable binary representations it states that the prns should be pseudorandom in any format.
even though the generated otp values in the decimal format seem unpredictable they may have some specific patterns in the binary format.
for example the parity of otp values has a specific pattern such as all evens or odd even odd even parity.
in such cases the possible space of the possible otp values can be reduced significantly.
threat.
otp authentication is vulnerable to replay attacks when the generation pattern of otp values is exploited.
the attacker first collects a certain number of the login communication packets.
without retrieving the plaintext of the otp values the attacker can send the corresponding packet to the server consistent with the generation pattern.
rule .
do not use a constant or predictable seed to initialize a randomness function it states that the randomness functions should not be seeded with a constant or predictable seed.
when the seed is a constant value the attacker can duplicate the sequence of prns when the seed is guessed.
for example when using srand to seed rand rand always outputs the same sequence because the initialization status is determined.
note when a dynamically changed seed is used for the randomness function the otp authentication can still be insecure if the seed is predictable e.g.
use of a timestamp .
threat.
when a randomness function e.g.
rand is seeded by a constant or a predictable value the attacker can test the possible seeds through brute force attacks and infer the following otp values.
iv.
c hallenges three challenges need to be addressed while analyzing the real world apps to identify the implementations violating the randomness rules introduced in section iii .
challenge how can we determine the selected randomness algorithm and the prng implementation resided on the server side?
app developers typically select a particular randomness algorithm to generate otp values.
however general program analysis techniques such as program slicing cannot be used here.
we cannot access the otp generation implementation because it resides on the server side.
diverse prng implementation options written in many different programming languages make it harder to decide which prng is specifically used for the otp functionality.
challenge how many otp values should be gathered to infer potential patterns in an otp sequence?
a large number of otp values are needed to determine whether any pattern exists in the otp sequence.
therefore multiple login attempts should be made.
however it is time consuming or often not allowed to gather a massive number of otp values through login attempts.
therefore we need to minimize the number of login attempts as much as possible.
challenge how can we collect otp values for our experiments without affecting the otp server?
we can perform the login process repeatedly to collect a sufficient number of otp values.
however sending a large numberof login requests can interfere with the otp server s normal operations.
more worryingly it can raise ethical issues.
to address these challenges we propose three approaches we analyze the existing prng implementations written in diverse programming languages and then abstract the common implementations in android apps.
based on the analysis of existing prng implementations we obtain vulnerable codes in each code snippet.
if a predictable pattern is found we then determine how many otp values are sufficient to infer the following prns.
we set a maximum number of login attempts for collecting otp values because we need to stop the otp data collection process when we fail to identify a specific pattern from a sequence of otp values.
moreover since some apps limit the number of login attempts per day e.g.
per day it would be time consuming to collect the number of otp values larger than such a maximum number of login attempts.
therefore we empirically set the maximum login attempts as by considering both practicality and efficiency.
v. o verview of otp l i n t to investigate the randomness of otp values we build otp lint to collect a sufficient number of otp values from a given android app using the sms otp authentication.
otp lint then checks whether randomness rules listed in section iii are violated.
figure shows the workflow of otp lint which includes three components authentication locator request processor and vulnerability detector .
authentication locator request processorrequest processorfuzzing inspired iterations app code analyzerapp code analyzer login locatorlogin locator input generator feedback handlerfeedback handlercandidate creator test activity test activity fuzzing inspired iterations app code analyzer login locator input generator feedback handlercandidate creator test activity vulnerability detectorvulnerability detector fig.
.
workflow of otp lint .
a. authentication locator in order to trigger login requests for otp collection otp lint first identifies whether there are any login activities implemented in apps.
the variety of login activities which are named differently makes it challenging to identify login activities by simply using keywords matching .
the customized functions are generally declared by using abbreviations and informal terms e.g.
accountact authaccount which are difficult to recognize.
for two functions using similar keywords these functions semantics might be different if the order of these keywords 1674in the two names is different.
as an example consider the functions smsloginact andloginsms .
they have different semantics although both of them utilize the keywords sms andlogin .
the smsloginact function represents a sms login activity whereas function loginsms requires the otp value for identity verification.
therefore only matching the keywords makes the activities identification inaccurate.
in order to achieve an accurate login activity identification otp lint applies a fuzzing inspired approach.
fuzzing is an automatic test generation and execution to find security vulnerabilities.
we aim to combine fuzzing with program analysis to address the issues of inconsistent function naming and ambiguous function semantics.
instead of matching keywords otp lint relies on code dependencies to understand the purpose of each function.
in particular it creates a test activity consisting of dependencies to locate login activities .
according to the previous test executions feedback otp lint dynamically optimizes the dependencies in the test activity for the next round of activity identification.
the authentication locator executes five steps a candidate creator generates candidate samples an app code analyzer analyzes the code of the target app and extracts dependencies an input generator creates a test activity a login locator identifies login activities from the realworld android apps and a feedback handler optimizes the test activity when the login activity is not identified in an app.
otp lint executes steps iteratively until the number of iterations exceeds a threshold which indicates that there would likely be no login activity implemented in the apps.
referring to the previous fuzzing approaches we set the iteration threshold as by considering both effectiveness and efficiency.
candidate creator candidate samples are a group of sample codes used as