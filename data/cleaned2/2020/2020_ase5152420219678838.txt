nekara generalized concurrency testing udit agarwal pantazis deligiannis cheng huang kumseok jung akash lal immad naseer matthew parkinson arun thangamani jyothi vedurada yunpeng xiao iiit delhi microsoft research microsoft university of british columbia iit hyderabad abstract testing concurrent systems remains an uncomfortable problem for developers.
the common industrial practice is to stress test a system against large workloads with the hopeof triggering enough corner case interleavings that reveal bugs.however stress testing is often inefficient and its ability to getcoverage of interleavings is unclear.
in reaction the researchcommunity has proposed the idea of systematic testing where a tool takes over the scheduling of concurrent actions so that it canperform an algorithmic search over the space of interleavings.
we present an experience paper on the application of systematic testing to several case studies.
we separate the algorithmicadvancements in prior work on searching the large space ofinterleavings from the engineering of their tools.
the latter wasunsatisfactory often the tools were limited to a small domain hard to maintain and hard to extend to other domains.
wedesigned nekara an open source cross platform library for easilybuilding custom systematic testing solutions.
we show that nekara can effectively encapsulate stateof the art exploration algorithms by evaluating on prior bench marks and nekara can be applied to a wide variety ofscenarios including existing open source systems as well asproduction distributed services of microsoft azure.
nekara waseasy to use improved testing and found multiple new bugs.
i. i ntroduction exploiting concurrency is fundamental to building scalable systems.
it can range from desktop applications with multiple threads that exploit a multi core cpu or giant distributedsystems with multiple processes spanning many vms.
in eithercase getting the concurrency right is challenging.
the combi natorial explosion of possible interleavings between concurrentactions makes it hard to find bugs or even reproduce knownones .
prior work argues for systematic testing which hooks on to the concurrency in a program to reliably controlthe interleaving of concurrent actions and then orchestratesa search exhaustive or randomized within the space of allinterleavings.
this idea manifests in several tools such aschess and cuzz for multi threaded applications dbug modist and samc for distributed message passing systems and many others .
this paper summarizes our experience in applying systematic testing in practice.
concurrency comes in many forms itchanges with the programming language c go rust etc.
programming model e.g.
threads tasks actors async await etc.
framework e.g.
service fabric libevent trio etc.
and so on.
our immediate learning in this space wasthat each of the tools mentioned above only address a specificclass of programs and are difficult or impossible to apply toother classes of programs.
to understand this shortcoming we can examine the design of a typical solution.
it consists of three parts.
the first isalgorithmic search a collection of heuristics that guide thesearch to interesting parts where bugs can be found forinstance fewer context switches first or priority basedscheduling etc.
second is the modeling of supported concurrency primitives that specify their semantics for instance the behavior of spawning a thread or acquiring a semaphore etc.
last is the injection of these models into a program so that calls to the original primitives can be replaced by callsto their corresponding models helping take over schedulingdecisions at runtime.
prior work attempts to offer integrated solutions that address all three aspects for a particular domain.
for instance thechess tool supports a subset of c threading apis from thesystem.threading namespace .
their models are build into the tool itself and they are injected automatically into theprogram binary via binary instrumentation.
this offers a seam less experience for supported programs.
however there is noeasy way to extend the tool to programs outside this supportedclass.
even c task based or async await programs which are very commonplace are not supported.
furthermore use ofcomplex technology like binary instrumentation makes the toolhard to maintain.
other tools do not fare any better.
samc forinstance only supports sockets based communication that too only for zookeeper like distributed systems.
supporting other systems was arguably never a goal of that work.
this paper aims to democratize systematic testing by allowing users i.e.
developers to build their own systematictesting solutions.
we propose nekara a cross platform open source library that provides a simple yet expressive api thata developer can use to model the set of concurrency primitivesthat they have used in their program.
nekara encapsulates var ious search heuristics from prior work freeing the developerfrom having to design these themselves.
nekara can recordscheduling decisions and provide full repro for bugs.
unlike an integrated solution nekara delegates modeling as well as injection of these models to the developer.
we argue through experience presented in this paper that the burden ondevelopers is small and is out weighted by many engineeringbenefits.
in most cases applications depend on a well definedframework or library to provide concurrency support e.g.
pthreads .
the user can then only design models for theseframework apis only ones they used with nekara hooks and the rest of the system remains unchanged.
importantly these nekara enabled models are just code they live and evolve alongside the rest of the system andbenefit from standard engineering practices.
the models canbe easily injected for testing say through macros for c code or 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee mocking utilities for higher level languages like c .
binary instrumentation is an overkill.
they can be shared betweenmultiple teams that use the same form of concurrency or acommunity can contribute to support models for a popularframework like pthreads.
developers can even choose to limit their code to only those apis for which they have thesemodels given the clarity that nekara provides.
nekara also helps with other forms of non determinism as well such as failure injection and provides the same benefitsof reproducibility.
in all with nekara systematic testingof non determinism is just another programming exercise completely in the hands of the developer.
we show the effectiveness of nekara by documenting several case studies each time showcasing that modelingconcurrency requires minimal effort less than a few weeks easy to share and provides significant value for testing morebugs found .
nekara is just 3k lines of c code.
1we believe that a solution like nekara unlocks the potential of systematictesting that has so far been siloed in individual tools.
the main contributions of this paper are as follows.
the design of the nekara library that allows buildingcustom systematic testing solutions sections ii and iii .
experience from several case studies that cover a rangeof different forms of concurrency and non determinism sections iv to vi .
nekara has been adopted by mi crosoft azure to test distributed services sections vi aand vi b .
the search algorithms in nekara are inspired from pre vious work we show that the generality of nekara doesnot limit its bug hunting abilities section vii .
section ix discusses related work and section x concludes.
ii.
n ekara library this section illustrates how nekara can be used to build a systematic testing solution.
nekara is only meant for testing.production code need not take a dependency on nekara.
the core nekara apis are shown in figure .
nekara operations generalize over threads and resources generalize over synchronization.
operations and resources are uninterpreted each is just an integer.
nekara understands that each operation once started and before it ends executes concurrently withrespect to other operations unless it blocks on a resource.
operations while executing can additionally signal a resource which unblocks alloperations that may be blocked on it.
nekara implements a co operative scheduler iii .
it ensures that at most one operation executes at any pointin time.
the current operation continues running until itcallsschedule next orwait resource.
at that point nekara can switch to execute some other enabled operation.
it is up to the programmer to map the concurrency in their program to nekara operations and resources.
we explainthis exercise using the simple concurrent program shown infigure .
the program contains a test case which executesthe method foo using multiple threads and does an assertion 1available open source at starting stopping the schedulervoid attach void detach operationsvoid create operation void start operation int op void end operation int op resourcesvoid wait resource int rid void signal resource int rid co operative context switchvoid schedule next nondeterministic choicesint next integer int min int max fig.
core apis of the nekara library.
at the end.
clearly the assertion can fail but only in a specificinterleaving where thread t1updates the shared variable x last.
for this program it makes sense to map threads tooperations and locks to resources.
our goal will be to simplymock the concurrency related apis and leave the rest of theprogram unchanged as much as possible.
figure shows the mocks.
the create thread wrapper function calls create operation from the parent thread and then start operation in the child thread.
the former informs nekara that a new operation is about to be created whereasthe latter allows nekara to take control of the child thread.the actual thread is still spawned via create thread nekara does not provide any runtime of its own.
next step is to implement the synchronization via resources.
we map each lock to a unique resource and then acquire andrelease methods can be mocked as shown in figure .
for ease of explanation we have assumed that the resourceid corresponding to a lock object xis stored in the field x id and a boolean variable representing the status of thelock locked unlocked is stored in the field x acquired.
because nekara performs co operative scheduling imple menting synchronization is typically easy.
the procedureacquire wrapper first does a context switch to give other operations the chance to acquire the lock and then goesahead to grab the lock if it is available.
when the lock isnot available then the operation blocks on the correspondingresource.
in release wrapper we signal the resource so that blocked operations can try to grab the lock again.
notethat signalling a resource unblocks all waiting operations butnekara ensures that only one unblocked operation executes atany point in time.
any other way of implementing a lockis acceptable as long as it ensures that the only blockingoperation is wait resource.
the final step is to run the test in a loop for a desired number of iterations under the control of nekara s scheduler as shownin figure .
nekara uses search heuristics to explore thespace of interleavings of the underlying test.
nekara recordsthe set of scheduling decisions that it makes.
when a testiteration fails the sequence of scheduling decisions can besupplied back to the nekara scheduler to directly reproduce thebuggy iteration.
the default set of search heuristics in nekaraare randomized so we measure the effectiveness of nekaraas the percentage of buggy iterations i.e.
what fraction of 680modeling project loc operations resources loc pw memcached iv 21k pthread t pthread mutex t pthread cond t libevent event loop 1k verona v 8k std thread std condition variable std atomic n a cscs vi a 56k task taskcompletionsource t 3k ecss vi b 44k task taskcompletionsource t lock 3k coyote vii 27k actor eventqueue table i systems integrated with nekara.
int x shared variable lck lock mutex void test initialization x lock new lck run workload t1 create thread foo t2 create thread foo t3 create thread foo continues in right column.
thread join t1 thread join t2 thread join t3 assert x !
void foo int arg acquire lock x arg release lock fig.
a simple concurrent program.
invocations of the underlying test fail.
completeness limitations a natural question is if nekara s exploration is complete i.e.
if it is possible to explore all behaviors of a given test in the limit.
with nekara we leave this decision to the developer.
completeness can beachieved by inserting a context switch just before each noncommuting action .
for message passing programs noncommuting actions are typically just message transfers thusinstrumenting them is enough to get completeness.
in shared memory programs an access to shared memory is potentially non commuting.
one option is for a developerto implement their own methodology for inserting contextswitches at memory accesses in their code.
a second simpler and common solution is to only insert at synchronizationapis.
then the instrumentation remains limited to mocks ofthe synchronization apis and does not pollute the code.
onecase study v uses the former strategy whereas rest usethe latter strategy.
with nekara the aim is not necessarilyto find all bugs it s a testing solution after all but rather tosignificantly improve existing practice.
behaviors induced byweak memory models are also outside the scope of thispaper although interesting future work .
nondeterminism the call to next integer returns a randomly generated integer within the supplied range.
thereturned value is recorded to allow for replay.
this is handy formodeling non determinism such as failure injection vi a orabstracting branches v .
case studies we demonstrate nekara on various systems table i .
memcached is a popular open sourcein memory key value store with cache management.
verona is a language runtime written in c .
cscs and ecssare production cloud services of microsoft azure writtenin c .
coyote provides a c actor based programmingframework for building distributed systems.
the third andint create thread wrapper func ptr foo args ptr args int op create new op scheduler.
create operation op create thread starter op foo args void starter int op func ptr foo args ptr args scheduler.
start operation op foo args scheduler.
end operation op void acquire wrapper lck lock scheduler.
schedule next while true if lock.acquired true scheduler.
wait resource lock id else lock.acquired true break void release wrapper lck lock assert lock.acquired lock.acquired false scheduler.
signal resource lock id fig.
mocks for thread creation and lock acquire release.
void nekara test scheduler scheduler options for int i i i scheduler.
attach start the scheduler test run the test for iteration i scheduler.
detach stop the scheduler fig.
a typical nekara test running for 100iterations.
fourth columns of table i list what is mapped to nekaraoperations and resources respectively.
the last two columnsshow the modeling effort lines of code loc as well as thenumber of person weeks pw spent for modeling.
veronaused custom nekara modeling from the outset so we cannotquantify the effort.
each of cscs and ecss use the samemocks which were developed once in 4person weeks.
it is worth noting that nekara testing is an integral part of theengineering process for verona cscs and ecss.
iii.
n ekara implementation the nekara scheduler must be attached before it takes any action once detached all nekara apis are no ops.
a simplified implementation of the core nekara apis is shownin algorithm .
nekara also includes apis for joining onan operation blocking on a conjunction or a disjunction ofresources as well as signalling a particular operation.
theseadditional apis are not discussed here.
nekara must ensure that only one operation executes at any point in time and it must block the rest to give itprecise control of the program s execution.
nekara maintains the current operation o cur a map m o rthat maps 681algorithm nekara scheduling apis state int cnt pending ocur m o r 1procedure create operation o o o o m atomic cnt pending 3procedure start operation o atomic cnt pending o.cv.wait cv is a condition variable 6procedure schedule next while cnt pending 0dowait 8e o m collect enabled operations ife then raise deadlock onxt s .next e choose next operation ifocur onxt then return oprev ocur ocur onxt onxt.cv.notify resume next operation ifoprev e then oprev.cv.wait pause previous operation 16procedure wait resource r m r schedule next 18procedure signal resource r foreach o odo m m r an operation to a set of resources that it s currently blocked on and a counter cnt pending that is initialized to zero.
an operation oisenabled ifm is empty and is disabled otherwise.
nekara creates a condition variable o.cvfor each operation othat it uses to block the operation.
calling create operation atomically increments cnt pending to keep track of operations that nekara should expect to be spawned.
no other action is taken whichmeans that the current operation o curwill continue executing.
start operation decrements cnt pending and immediately blocks the caller.
having these two calls decorating the spawnof a new operation was important to keep nekara independentof the underlying runtime.
a call to start operation can happen concurrently with respect to other nekara api.
the executing operation o curcontinues until it calls either schedule next orwait resource.
the latter just calls the former so we just describe schedule next.
it first waits until cnt pending goes to zero.
once this happens it implies that all operations must be inside nekara.
nekarathen uses a search heuristic sto decide the next operation to schedule from the set of all enabled operations or raise deadlock is none is enabled .
if the next operation isthe same as the current no action is necessary.
otherwise the current operation is blocked and the next operation isscheduled.
search heuristics several search heuristics have been proposed in prior work thomson et al.
provides a survey.these heuristics are based around empirical observations ofwhere most bugs lie in practice for instance prioritize fewcontext switches few delays few priority exchangepoints etc.
even selecting the next operation uniformlyat random works well in practice .
nekara by default hasseveral heuristics implemented and uses all of them in a round robin fashion across test iterations .network slabs...application programming interface api slab rebalancerlru crawler slab classes lru... ... ...lru maintainerworker threadsworker threadsmemcached lab asses threads crawler s maintainer wler m cra threads s kv hash tableassoc maintainerworker threads maintainer r er main thread m ds fig.
architecture of memcached.
nekara captures the crux of systematic testing in a small simple c library.
it separates search heuristics from themodeling and specialization of testing to a particular system.
iv .
c ase study m emcached memcached mc is an open source in memory keyvalue store commonly used as a cache between an applicationand a database.
it is mostly written in c with approximately21 kloc.
being a popular multi threaded application it hasbeen used for benchmarking bug detection tools in prior work .
figure illustrates the high level architecture of mc showing the key data structures at the bottom and the various kindsof threads that access them.
mc maintains an in memory chained hash table for indexing key value kv pairs.
worker threads update the hash table and the assoc maintainer thread is responsible for expanding or shrinking the hash table whenits load crosses above or below certain threshold.
to reduce internal fragmentation mc uses a slab based allocator for storing kv pairs.
kv pairs of different sizesare mapped to different slab classes and the slab rebalancer thread redistributes memory among slab classes as needed.
for every slab class mc maintains three linked lists namedhot warm and cold lrus to keep track of the least recently used lru kv pairs.
when a slab class runs out of memory some memory is reclaimed by evicting the least recently usedkv pair.
two background threads called lru maintainer and lru crawler update these linked lists and performs evictionswhenever required.
the dispatcher thread is the main thread that starts and stops all other threads.
its primary function is to look for incom ing network connections and dispatch them to the availableworker threads which then serve the network client s requests.mc relies on an event driven asynchronous model based onlibevent worker threads do not block on network i o but instead switch to processing another request.
integrating nekara we first needed to make mc more modular and unit testable.
we mocked system callslike socket sendmsg recvmsg getpeername poll read write etc.
so that we could imi682knownid bug type description reference misuse of pthread api double initialization of mutex and conditional variables pr data race dispatcher and worker thread race on a shared field named stats pr misuse of pthread api deadlock due to recursive locking of a non recursive mutex pr misuse of pthread api deadlock due to an attempt to pthread join a non existing thread issue atomicity violation two worker threads simultaneously increment the value of the same kv pair issue 127new6 atomicity violationnull pointer dereference when one worker thread deletes a global variable while another worker thread was updating itissue misuse of pthread api attempt to join a non existant thread issue deadlockslab rebalancer and the dispatcher thread deadlock due to simultaneous invocation ofpthread cond signal by a worker and the dispatcher thread.issue misuse of pthread apithis bug can lead to either unlocking an unlocked mutex or unlocking a mutex that is held by some other thread resulting in data races .issue table ii list of previously known bugs as well as new bugs that nekara found in memcached.
bug bug bug bug uncontrolled .
nekara .
.
table iii percentage of buggy iterations for memcached tests.
each test was executed for 10k iterations.
tate network traffic coming from one or multiple mc clients.
nekara specific work was limited to the mocking oflibevent andpthread apis.
these totalled around kloc and took a nominal effort of around two weeks.
existing mc tests did not exercise concurrency so we wrote a test ourselves.
it concurrently invoked several mc oper ations the workload itself was a combination of workloadsfrom existing tests.
we then compared the response returnedby mc with the expected response.
because nekara tests runin a loop we needed to ensure that every iteration of the testwas independent of the previous one.
this required resettingof all the global static variables and clearing the cache afterevery iteration.
bugs we picked five previously known concurrencyrelated bugs listed in table ii and injected them back in thelatest version.
we picked mc s latest stable version .
.
forexperimentation.
some of these bugs bugs were eitherused or found by previous work and others wereobtained from github.
in the course of testing we also foundfour previously unknown bugs bugs to which have beenconfirmed by mc developers.
bugs related to misuse of pthread apis bug were easy they were caught in the first test iteration.
the onlyreason they escaped mc s existing tests is that pthreads doesnot fail on invalid invocations we found them simply becauseour pthread api mocks checked for them.
table iii shows results for the remaining bugs where using nekara was crucial.
most of these bugs could not be caughtwithout nekara despite running the test several 10k times.all of previously unknown bugs were present in mc from atleast the past four years and even prior tools didnot find them.
state coverage in addition to finding bugs we wanted to check if nekara indeed provides more coverage of concurrent1000 iterations0100200300400500600700800 unique statesuncontrolled nekara fig.
state coverage for memcached.
behaviors.
we took a hash of all key data structures of mc lru linked lists slab classes and the kv table at the endof a test iteration and counted the number of unique hashesseen over all test iterations.
we ran the nekara test for 15kiterations and the results are shown in figure .
the results show a roughly four fold increase in the total number of hashes with nekara clearly indicating that itwas able to exercise many more behaviors of mc.
deeperinspection revealed that nekara was able to trigger corner case behaviors more often for instance a slab class runningout of memory or a getoperation observing a cache miss.
overall our evaluation demonstrates that a system like mccan benefit greatly from systematic testing and using nekararequires little effort.
v. c ase study verona project verona is a prototype implementation of a new programming language that explores the interaction betweenconcurrency and ownership to guarantee race freedom.
theruntime of the language has several complex concurrent pro tocols that use shared memory.
the runtime has schedulingincluding work stealing back pressure to slow message queuegrowth fairness memory management using atomic referencecounting and global leak detection.
these concepts interact insubtle ways that are difficult to debug.
the designers of verona decided to use systematic testing from the start motivated by prior struggle with concurrencybugs that took hours to days to resolve and that had been asignificant barrier to making quick progress.
683uncontrolled nekara commit hash bug .
25bb324 bug .
c087803 table iv percentage of buggy iterations for verona tests.
each test was executed repeatedly for mins.
during development of the verona runtime the scheduler concurrent queues and memory management protocols werecarefully reviewed for uses of shared memory concurrency.threads were mapped to operations like in section ii .synchronization happened in two forms.
the first was the useofstd atomic these remain unchanged except that before every store and after every load a call to schedule next is inserted because they mark a potentially racy access toshared memory.
the second was the use of condition variables these directly map to nekara resources.
verona uses nekara s next integer to control other sources of non determinism.
for instance object identity insystematic testing builds was made deterministic so featuresthat sort based on identity can be tested reproducibly.
theruntime has numerous heuristics to postpone expensive op erations until there is sufficient work to justify their cost.this implies that certain bugs which require the expensiveoperation to execute can take a long time to manifest.
thepostponement heuristic was replaced with systematic choice i.e.
if next integer .
this had two benefits it shortened the trace length to find a bug and itremoved any dependency on a specific heuristic s behaviour.
verona uses systematic testing as part of its code review and ci process.
any change to the verona runtime has anadditional twenty minutes of ci time for running systematictesting.
there is a small amount of stress testing but mostruntime bugs are found using systematic testing.
the project sethos is such that any failure found which did not exhibitduring systematic testing is treated as two bugs the underlyingbug and a bug in the use of systematic testing.
the latteris fixed first by writing a systematic test that reveals thebug.
moreover users of verona get systematic testing for freebecause the runtime is already instrumented with nekara.
anecdotal evidence from the verona team has said that the use of systematic testing has given greater confidence for newmembers of the team to modify the runtime primarily dueto the debugging experience of replayable crashes.
detailedlogging and replayable crashes provide a way to understandthe subtle interactions in concurrent systems that would nor mally be a significant barrier to entry for new programmers.most runtime bugs do not make it off the developer s machineas the local systematic testing catches them before ci.
tworecent bugs that we investigated are listed in table iv.
bothbugs would not have been found without systematic testing.bug was a failure to correctly protect memory frombeing deallocated by another thread.
the window for this tooccur was a few hundred cycles hence almost impossible toreproduce reliably without systematic testing.
the second bugwas due to not considering a corner case of a new feature.class task static task run func task func static task delay timespan delay static task whenall params task tasks static task task whenany params task tasks ... taskawaiter getawaiter class taskcompletionsource t task t task get ... void setresult t result void setexception exception ex void setcanceled cancellationtoken ct fig.
task andtaskcompletionsource t apis.
vi.
c ase study task parallel library the task parallel library tpl is a popular opensource cross platform library provided by .net for buildingconcurrent applications.
tpl exposes several key types suchastask andtaskcompletionsource t that interoperate with the async andawait keywords in the c language enabling writing asynchronous code without the complexity ofmanaging callbacks.
a developer writes code using these high level apis and tpl takes care of the hard job of partitioningthe work scheduling tasks to execute on the thread pool canceling and timing out tasks managing state and invokingasynchronous callbacks.
tpl is pervasive in the .net ecosystem.
we designed tpl nas a drop in replacement library for tpl.
tplnprovides stubs that replace the original tpl apis as well assubclasses that override original tpl types.
these stubs andsubclasses call into nekara via a c to c foreign functioninterface.
any c application that uses tpl for its concurrencysimply needs to replace it with tpl nto get systematic testing.
we now explain core tplndesign.
thetask type figure provides several public facing apis including task.run for queueing a function to execute on the thread pool and returning a task that can be usedas a handle to asynchronously await for the function tocomplete task.whenall andtask.whenany for waiting one or more tasks to complete task.delay for creating an awaitable task that completes after some time passes andcompiler only apis such as task.getawaiter which the c compiler uses in conjunction with the async and await keywords to generate state machines that manage asynchronous callbacks .
figure shows the nekara instrumented version of task.run.
for simplicity we have omitted low level de tails such as task cancellation and exception handling.task.run of tpl ncreates a new nekara operation viacreate operation and then invokes the originaltask.run to spawn a task.
this new task first calls start operation then invokes the user function followed by end operation.
the parent task calls schedule next to give the child task a chance to execute.
taskcompletionsource t tcs shown in figure allows developers to asynchronously produce and con sume results.
this type exposes a task get only property 684using systemtask system.threading.tasks.task static task run func task func create a new nekara operation id for the new task.
int op getuniqueoperationid nekara.
create operation op var task systemtask.run async nekara.
start operation op execute the user specified asynchronous function.
the await logic is instrumented with nekara.
await func nekara.
end operation op nekara.
schedule next return task fig.
instrumentation of task.run with nekara.
tcs context used for nekara testing.
class tcscontext t nekara resource id for the tcs.
int id getuniqueresourceid the result set by the tcs.
t result default bool iscompleted false void setresult t result var context getcurrentcontext if !context.iscompleted set the tcs result.
context.result result context.iscompleted true signal the tcs consumer.
nekara.
signal resource context.id task t task get the current tcs context.
var context getcurrentcontext if context.iscompleted if tcs is completed return the result.
return task.fromresult context.result return a nekara controlled task that will be completed by the producer.
return task.run wait the producer to set the result.
nekara.
wait resource context.id exception cancellation logic.
... return context.result fig.
instrumentation of tcs apis with nekara.
that a consumer can await to receive a result of type tasynchronously.
this task remains uncompleted until the producer completes it with a result by invoking setresult.
instrumentation of tcs task andsetresult is shown in figure .
we designed tcscontext t a simple test only data structure in tplnthat contains information needed to model a tcs.
tcscontext t contains a nekara resource id associated with the tcs the result of the tcs and aboolean value that is set to true once the tcs completes.tcscontext t is set to the tcs state upon initialization by tpl n so that it can be accessed when invoking one of the stub tcs apis.
the producer setresult is modeled asfollows it first accesses the context then checks if the tcs hascompleted and if not it sets the result and iscompleted totrue and signals the resource associated with the tcs to unblock any task that might be waiting on the tcs task getter property.
the consumer task getter is modeled as follows it first accesses the context then checks if the tcshas completed and if it has it simply returns a completed taskwith the result.
if the tcs has not completed yet it will createa new task by invoking the task.run tpl napi which we described above .
this asynchronous task immediately waitson the resource and once the producer signals it returns the mock client control plane asp.net microservicedata plane asp.net microserviceworker asp.net microservicecscs kubernetes cluster mock cosmos db mock storage queue fig.
the high level architecture of cscs.
completed result.
we also modeled two other tpl types.
first is the monitor type that implements a reentrant lock in c along similar lines to figure .
second is the typeasynctaskmethodbuilder that the c compiler uses to generate state machines to manage asynchronous callbacks inmethods that use async andawait.
creating tpl ntook roughly one person month with most time spent in ensuring that we support each tpl api andmaintain details such as exception propagation cancellation etc.
this is largely a one time effort unless tpl itself changessignificantly .
several engineering teams in microsoft wereable to use tpl nto test their services without needing any changes to their production code.
two such systemsare summarized next in sections vi a and vi b. they useconditional compilation to automatically replace the originaltpl library with tpl nduring testing.
a. testing cscs with tpln cloud supply chain service cscs exposes a set of http rest apis that clients can invoke to create supply chain entities and orchestrate supply chain processes.
cscsis designed with a typical microservice based architecture figure where multiple stateless microservices coordinatewith each other through shared state maintained in backendstorage systems.
cscs consists of roughly 56k lines of c code.
it is built using asp.net and achieves horizontalscalability through kubernetes .
the cscs microservices although stateless concurrently access the backend storage including cosmos db aglobally distributed database service and azure queue stor age a durable distributed queue .
some requests incscs follow a simple request response pattern while otherstrigger background jobs making the client periodically pollto check on the completion of the job.
this requires complexsynchronization logic between the microservices.
cscs is written against storage interfaces so they can be easily mocked during testing using techniques such asdependency injection.
multiple concurrent client calls are sim ulated by spawning concurrent tasks that invoke the relevantasp.net controller actions.
instantiates a cosmos db mock an instance of a cscs asp.net microservice and a cscs client.var cosmosdbmock new cosmosdb mock ... var factory new servicefactory cosmosdbmock ... var client factory.createclient ... invokes a concurrent create and update client request.
task req1 task.run client.create id content payload1 timestamp task req2 task.run client.update id content payload2 timestamp await task.whenall req1 req2 gets the resource stored in cosmos db and asserts it contains the expected payload and timestamp.var resource await client.get id assert.istrue resource.content payload2 resource.timestamp fig.
a simple nekara concurrent test in cscs.
bug bug bug bug uncontrolled nekara table v percentage of buggy iterations on cscs tests.
cscs concurrency unit tests range from simple concurrency patterns where the test calls an api with different inputs but the same key to exercise interference in cosmos db to morecomplex tests that randomly fail certain mock invocations using the next integer api to simulate intermittent network failures.
figure shows a simple cscs test.
thesetests when exercised by nekara were able to uncover subtlebugs.
table v lists some of the bugs comparing testing withand without nekara.
each test was run multiple times for atotal of minutes and the table shows percentage of buggyruns.
without nekara none of these bugs would have beenfound.
following is a description of these bugs.
a data loss due to concurrent requests bug cscs requires that upon two concurrent create orupdate requests only the request with the latest modified timestampsucceeds.
to achieve this cscs uses cosmos db etagsfunctionality for optimistic concurrency control but a bugin the handling of etags led to a stale create overwriting fresher data.
this bug was missed by both stress testing andmanual code review but found quickly with nekara with thetest shown in figure .
this bug could have lead to customerdata loss.
b inconsistent entity state bug cscs manages two sets of related entities which are stored in different tables andpartitions of cosmos db.
rejecting an update on one of theentities must lead to rejection of updating the other entity too.however cosmos db does not support transactions betweenentities stored in different partitions and the developers hadto implement custom synchronization logic to get around thislimitation.
when the team wrote a concurrent test that tries tocancel and reject an entity at the same time nekara uncoveredan issue where the system got into an inconsistent state.
thisbug had escaped stress testing and manual code review.
c resource creation liveness issue bug certain requests trigger a background task requiring the client to peri odically poll its completion.
this functionality is implementedby storing a record indicating the request status in cosmos dband then submitting the job to a worker queue to trigger theasynchronous work.
there was a bug where the submission tothe worker queue could fail due to network connectivity issues.however as the record was created in the database the userwould find the status to be pending creation upon a get request and would erroneously assume the resource will be eventually created.
this liveness bug was caught with a test that simulated potential network failures.
d race condition in test logic bug interestingly nekara found a bug in the cscs test code itself.
the buggytest performed two concurrent put requests to provision a resource then waited for the provisioning to complete andthen deleted the resource.
the test was failing because twoconcurrent create requests led to two asynchronous workers for the same resource.
the test then deleted the resource assoon as one of the workers transitioned the resource state tocreated.
however there was a race between the secondasynchronous worker and the delete request which caused the test to fail.
the developers were initially not sure if thisbug was in their production logic or test logic but due tonekara s reproducible traces they were able to understand theissue and fix it.
b. testing ecss with tpl n cloud storage uses geo redundancy to protect against catastrophic data center failures.
the erasure coding storage service ecss offers an economical solution to this problem byapplying erasure coding to blob objects across geographicallydistributed regions.
figure shows a partial view of thehigh level architecture of ecss.
the system consists of a dataservice and a metadata service.
the data service is responsiblefor striping data and generating parities across regions as wellas reconstructing data in the event of failures.
the metadataservice manages erasure coding stripes and handles dynamicupdates to the stripes due to object creation update anddeletion .
ecss consists of roughly 44k lines of c code.
to achieve high throughput ecss was designed to be highly concurrent.
the data service implements a componentcalled syncer that periodically synchronizes metadata betweenindividual regions and the metadata service using azurequeue storage.
syncer is sharded and the ecss developersimplemented a lease based mechanism to assign differentsyncer partitions to different metadata service nodes.
themetadata service executes two long running tpl tasks atable updater and a table scanner.
the updater asynchronouslydequeues syncer messages from azure queue storage anduses their contents to update azure table storage.
the scannerperiodically scans azure table storage to check different typesof metadata.
based on the metadata state the scanner will data servicemetadata service syncer ... mock storage tabletable scanner table updaterin memory action queue in memory action queue... action engine mock storage queuedata block fig.
parts of the high level architecture of ecss.
syncer 1 syncer 2 mock storage tableupdate metadata to v2init and read metadata from v1 update metadata to v3enqueue msg benqueue msg a mock storage queue .
msg a metadata v2 .
msg b metadata v3 init and read metadata from v2data block read data at time 1read data at time fig.
race condition in the ecss data service.
enqueue actions on a set of in memory queues.
long running tasks execute action engines that drain these queues performactions on the state and update the metadata in azure tablestorage as well as sending action messages to the data servicethrough azure queue storage to do erasure coding amongother operations.
eventually the state of the data service and azure table storage must be consistent.
ecss manages exabytes ofcustomer data and correctness is absolutely vital which iswhy the team used tpl nfor thorough testing.
no changes were required to the production code.
the main investmentwas in writing the tests the tests instantiate the syncer andthe metadata service in memory use dependency injection forinserting their mocks of azure table storage and azure queuestorage write input data and finally assert that the azure tablestorage state is consistent.
nekara helped find several critical bugs that could have resulted in data loss.
figure illustrates one of these bugs a race condition between two syncer instances from the samepartition.
the first syncer instance syncer 1 starts andreads metadata with version 1from azure table storage updates it and writes it back to the table with version .
on the same partition a new syncer instance syncer 2 starts reads the same metadata which now has version and updates it to version .
immediately after syncer 2 reads from the data block but just before it continues itsexecution syncer 1 reads the latest data from the same block and generates msg a containing version 2of thetplncoyotencoyote benchmarks bi time bi time bi time ch.
replication .
.
fail.
detector .
.
paxos .
.
.
raft .
.
.
table vi comparing systematic testing with nekara againstthe original coyote.
tests run for 10k iterations.
bi denotespercentage of buggy iterations.
time is in seconds.
metadata and enqueues this message to azure queue storage.
next syncer 2 continues executing and generates msg b containing version 3of the metadata and also enqueues this message.
finally the metadata service dequeues conflictingmessages from the same partition which could result in alater version of the metadata being overwritten by an outdatedversion.
to fix the bug the developers had to write logic justbefore enqueueing the messages to check if the metadata andthe version are consistent and if not then discard the message.
this bug had escaped continuous unit and stress tests.
nekara was able to find it in under seconds and just test runs on average .
the ecss team as well as the cscsteam routinely run nekara tests as part of their ci.
vii.
r eproducing known bugs we evaluate nekara against three prior tools on their own set of benchmarks.
the purpose of this evaluation is to showthat one can get state of the art systematic testing with nekara.
a coyote the first comparison is against coyote that provides an open source .net actor library used by teamsin azure .
coyote provides a runtime for executing actors.all actors execute concurrently and communicate by sendingmessages to each other.
coyote also provides a systematictesting solution for testing these actor based programs .
we directly instrumented the coyote runtime using nekara to build our own systematic testing solution.
we had twooptions.
in the first approach we took advantage of the coyoteruntime being implemented entirely on top of tpl whichwe simply replaced with tpl n. in the second approach we instead instrumented at the level of actor semantics an actoris mapped to an operation and the actor s inbox is mappedto a resource.
we skip the details of this instrumentation forlack of space the high level summary is that it only required16lines of changes to the coyote runtime.
we refer to the second approach as coyote n. note that in both approaches all changes were limited to the coyote runtime the user programremains unchanged.
table vi shows results on prior coyote benchmarks which consist of buggy protocol implementations.
the two nekaraapproaches have different advantages.
tpl nhas the benefit of being able to test the coyote runtime itself that it correctlyimplements actor semantics .
moreover the instrumentationwas mechanical and required no knowledge of coyote itself.
687class mockdictionary k v dictionary k v int sharedvar bool iswrite false ... bool override containskey k key var tid task.currentid sharedvar tid nekara.
schedule next check for race.
assert !
sharedvar !
tid iswrite return base .containskey key void override add k key v value var tid task.currentid sharedvar tid iswrite true nekara.
schedule next check for race.
assert sharedvar tid iswrite false base.add key value fig.
mock dictionary instrumented to detect races.
however bugs in the coyote runtime was not in question here and we found this approach to have worse performancethan the other systematic testing solutions.
instrumenting atthe tpl level significantly increased the number of operationsand scheduling points in the program which decreased bug finding ability and increased test time.
coyote n however was comparable to coyote because both directly leverage actorsemantics.
we also compared against uncontrolled testing which unsurprisingly could not find any of the bugs.
we make a note on the relationship of coyote to nekara because both projects have influenced each other.
coyote hadearlier only supported an actor based programming model.nekara inherited many of the search techniques used incoyote but applied them to a generalized setting.
giventhe success of nekara s tpl nmodel in testing task based programs the coyote team has since incorporated that worknatively to support task based programs as well.
coyoteuses bytecode level instrumentation to automatically injecthooks into an unmodified c program making the end userexperience more seamless than with using tpl n. b tsvd in the second experiment we reproduce bugs found by tsvd a tool that looks for thread safety violations tsvs which are concurrent invocations of operations on a non thread safe data structure e.g.
a dictionary .
tsvd s open source evaluation covered nine .net appli cations here we consider six of those one was removed fromgithub and in two others we were unable to locate a tsv bugfrom the cited github issue .
in each application we replacedtpl with tpl nand made one additional change.
to capture tsv as an assertion we implemented a mockdictionary type as a subclass of dictionary and modified the application to use this type.
figure shows this mock an assertionfailure in the mock corresponds to a tsv .
table vii showsthe results we were able to find all tsvs taking at most iterations on average.
in the datatimeextension benchmark we found four additional tsvs not reported by tsvd byrunning the test for iterations.
c maple the third comparison is against maple a systematic testing tool that uses dynamic instrumentation andprovides coverage driven testing through online profiling anddynamic analyses.
we picked a set of real world benchmarksfrom sctbench .
these include an older version of mem cached spidermonkey a javascript runtime engine stream nekara applications loc bf br?
bi tsvddatatimeextention .2k .
fluentassertion .3k .
k8s client .3k .
radical .9k .
system.linq.dynamic .2k .
thunderstruck .1k .
maplespidermonkey 200k .
memcached .
.
10k .
streamcluster .5k .
pbzip2 .5k .
table vii comparison with tsvd and maple.
bf isnumber of bugs found by these tools.
the under br?
denotes that nekara reproduced all these previously foundbugs.
bi denotes percentage of buggy iterations.
cluster online clustering of input streams and pbzip2 a parallel implementation of bzip2 .
bugs in these applicationsinclude atomicity violations order violation deadlocks andlivelocks.
all these benchmarks use pthreads so we reused the models from section iv.
table vii shows the results.nekara found all the reported bugs most in a small numberof iterations.
these numbers are either comparable or smallerthan those reported by maple although a direct comparisonis not possible because of the different set of techniques andinstrumentation used.
for some benchmarks marked in thetable with a we also inserted schedule next just before global variables accesses without which we were unableto find some of the bugs due to the incompleteness issuementioned in section ii .
viii.
e xperience summary this section summarizes our experience in integration nekara with the various case studies presented in this paper.
integration we were able to integrate nekara testing with several systems with no changes to the production code inmost cases.
only in the case of memcached we had to modifythe code in order to mock system calls to sockets so that wecould write unit tests with multiple concurrent clients.
the factthat production code need not take a dependency on nekarawas important was acceptance with development teams.
modeling effort table i shows that the modeling effort was small to moderate.
for systems like verona systematictesting was always an integral part of its development process.systems like ecss and cscs fully shared their models tpl n demonstrating amortization of effort across teams.
development of the models does require some expertise in reasoning about concurrency especially for understanding thesemantics of synchronization apis and encoding it correctlyusing nekara resources.
correctness of these models is aconcern because mistakes can lead to deadlocks when runningnekara tests.
we leave the problem of validating models asfuture work.
in general it would be interesting to explore acommunity driven effort that maintains models of commonconcurrency frameworks or apis.
688bugs nekara helped catch several bugs including liveness bugs deadlocks memory leaks as well as functionality bugs like data corruption.
many of these would not have beencaught with existing practices like stress testing or code review.
writing test cases developing good tests that exercise concurrency in the system and assert something meaningful are crucial to get benefits from systematic testing.
for mem cached we wrote a generic test by simply combining existingtest cases.
for other systems the developers of those systemswere able to write tests themselves without our help.
debugging repro capabilities of nekara was well appreciated by developers.
furthermore instrumentation of aruntime like verona or coyote provides systematic testingto users of the runtime for free.
ix.
r elated work the systematic testing approach has its roots in stateless model checking popularized first by verisoft .
stateful approaches require capturing the entire state of a program inorder to avoid visiting the same state again because of whichthese techniques are typically applied on an abstract modelof an implementation .
stateless approaches on theother hand only control program actions.
they do not inspectprogram state at all consequently are directly applicable totesting the implementation itself.
all these techniques wereinitially focussed on verification.
chess shifted thefocus to bug finding it prioritized exploration of a subsetof behaviors one with a few number of context switches and found many bugs.
several randomized search techniques have followed since showcasing veryeffective bug finding abilities.
our focus has been on makingsystematic testing easy to use to that end we capture allthese search techniques inside nekara.
one class of techniquesthat we are unable to capture in nekara s interface currentlyis partial order reduction por based techniques .por requires knowing if the next steps of two different operations are independent of each other or not.
supporting por require more information to be supplied to nekara whichis interesting future work.
instantiation of systematic testing exists for multi threaded as well as message passing programs however their combined reach is stillsmall.
for instance most c applications that we consideredare built on tpl tasks.
these tasks eventually execute onthe .net threadpool so one can consider them to be multi threaded applications but instrumenting the .net runtime ischallenging and we did not find any readily applicable tool.moreover even if this was possible instrumenting at a higher level is typically much easier vi and more efficient vii .our goal is to unlock systematic testing modeling is nothidden inside a tool but available as code that can be readilyadopted by others.
complementary to systematic testing is the work on finding low level concurrency bugs such as data races and atomic ity violations .
these techniquesexamine a given concurrent execution and evaluate if therewere potentially racy accesses.
data race detection typicallyrequires monitoring memory accesses at runtime.
nekara canhelp generate a diverse set of concurrent executions for thesetools or be used directly for specific races vii .
another related problem is deterministic replay of processes even virtual machines .
thesetechniques seek generality to support arbitrary systems andrequire very detailed tracing.
the problem is simpler in oursetting as we are focussed on a single test written by adeveloper aware of the concurrency used in their application.
x. c onclusions systematic testing holds promise in changing the way we test concurrent systems.
in this paper we present nekara a simple library that allows developers to build their ownsystematic testing solutions.
integration of nekara is a simpleprogramming exercise that only requires modeling of keyconcurrency apis.
the model code is easy to share to furtheramortize the cost across multiple projects.
we report severalcase studies where the use of nekara made considerableimpact both in existing systems as well as systems designedfrom scratch with systematic testing.
r eferences j. gray why do computers stop and what can be done about it?
in proceedings of the 5th symposium on reliability in distributed software and database systems.
ieee pp.
.
m. musuvathi s. qadeer t. ball g. basler p. a. nainar and i. neamtiu finding and reproducing heisenbugs in concurrent pro grams in proceedings of the 8th usenix symposium on operating systems design and implementation pp.
.
m. musuvathi and s. qadeer fair stateless model checking in proceedings of the acm sigplan conference on programminglanguage design and implementation tucson az usa june r. gupta and s. p. amarasinghe eds.
acm pp.
.
.
available s. burckhardt p. kothari m. musuvathi and s. nagarakatte a randomized scheduler with probabilistic guarantees of finding bugs inproceedings of the 15th international conference on architectural support for programming languages and operating systems asplos2010 pittsburgh pennsylvania usa march pp.
.
.
available j. simsa r. bryant and g. a. gibson dbug systematic testing of unmodified distributed and multi threaded systems inmodel checking software 18th international spin workshop snowbird ut usa july .
proceedings ser.
lecturenotes in computer science a. groce and m. musuvathi eds.
vol.
.
springer pp.
.
.
available j. yang t. chen m. wu z. xu x. liu h. lin m. yang f. long l. zhang and l. zhou modist transparent model checking ofunmodified distributed systems in proceedings of the 6th usenix symposium on networked systems design and implementation pp.
.
t. leesatapornwongsa m. hao p. joshi j. f. lukman and h. s. gunawi samc semantic aware model checking for fast discoveryof deep bugs in cloud systems in proceedings of the 11th usenix symposium on operating systems design and implementation pp.
.
j. f. lukman h. ke c. a. stuardo r. o. suminto d. h. kurniawan d. simon s. priambada c. tian f. ye t. leesatapornwongsa a. gupta s. lu and h. s. gunawi flymc highly scalable testingof complex interleavings in distributed systems in proceedings of the f ourteenth eurosys conference dresden germany march pp.
.
b. k. ozkan r. majumdar f. niksic m. t. befrouei and g. weissenbacher randomized testing of distributed systems with probabilistic guarantees pacmpl vol.
no.
oopsla pp.
.
p. godefroid software model checking the verisoft approach f ormal methods in system design vol.
no.
pp.
.
.
available p. deligiannis m. mccutchen p. thomson s. chen a. f. donaldson j. erickson c. huang a. lal r. mudduluru s. qadeer and w. schulte uncovering bugs in distributed storage systems during testing notin production!
in 14th usenix conference on file and storage technologies f ast santa clara ca usa february .
pp.
.
p. thomson a. f. donaldson and a. betts concurrency testing using controlled schedulers an empirical study acm transactions on parallel computing vol.
no.
pp.
.
microsoft azure service fabric service fabric .
libevent an event notification library trio a friendly python library for async concurrency and i o https trio.readthedocs.io en stable .
r. j. lipton reduction a method of proving properties of parallel programs commun.
acm vol.
no.
pp.
dec. .
b. norris and b. demsky cdschecker checking concurrent data structures written with c c atomics in proceedings of the acm sigplan international conference on object oriented programming systems languages applications oopsla part of splash2013 indianapolis in usa october pp.
.
memcached an in memory key value store org .
microsoft research verona research programming language for concurrent ownership .
microsoft coyote fearless coding for reliable asynchronous software .
m. emmi s. qadeer and z. rakamaric delay bounded scheduling inproceedings of the 38th acm sigplan sigact symposium on principles of programming languages popl austin tx usa january pp.
.
t. elmas j. burnim g. necula and k. sen concurrit a domain specific language for reproducing concurrency bugs in proceedings of the 34th acm sigplan conference on programming language designand implementation pp.
.
d. schemmel j. b uning c. rodr guez d. laprell and k. wehrle symbolic partial order execution for testing multi threaded programs arxiv preprint arxiv .
.
s. nagarakatte s. burckhardt m. m. martin and m. musuvathi multicore acceleration of priority based schedulers for concurrency bugdetection in proceedings of the 33rd acm sigplan conference on programming language design and implementation pp.
.
n. jalbert c. pereira g. pokam and k. sen radbench a concurrency bug benchmark suite.
hotpar vol.
pp.
.
k. serebryany and t. iskhodzhanov threadsanitizer data race detection in practice in proceedings of the workshop on binary instrumentation and applications pp.
.
d. leijen w. schulte and s. burckhardt the design of a task parallel library in proceedings of the 24th acm sigplan conference on object oriented programming systems languages and applications.acm pp.
.
microsoft asynchronous programming with async and await https docs.microsoft.com dotnet csharp programming guide concepts async .
asp.net a framework for building web apps and services with .net and c .
the kubernetes authors kubernetes .
microsoft cosmos db fast nosql database with open apis for any scale .
queue storage durable queues for large volume cloud services .
p. deligiannis n. ganapathy a. lal and s. qadeer building reliable cloud services using p experience report corr vol.
abs .
.
.
available p. deligiannis a. f. donaldson j. ketema a. lal and p. thomson asynchronous programming analysis and testing with state machines inproceedings of the 36th acm sigplan conference on programming language design and implementation pp.
.
g. li s. lu m. musuvathi s. nath and r. padhye efficient scal able thread safety violation detection finding thousands of concurrencybugs during testing in proceedings of the 27th acm symposium on operating systems principles ser.
sosp .
new york ny usa association for computing machinery p. j. yu s. narayanasamy c. pereira and g. pokam maple a coveragedriven testing tool for multithreaded programs in proceedings of the acm international conference on object oriented programmingsystems languages and applications ser.
oopsla .
new york ny usa association for computing machinery p. .
.
available g. holzmann the spin model checker primer and reference manual 1st ed.
addison wesley professional .
t. andrews s. qadeer s. k. rajamani j. rehof and y .
xie zing a model checker for concurrent software in computer aided v erification 16th international conference ca v boston ma usa july proceedings pp.
.
m. musuvathi and s. qadeer iterative context bounding for systematic testing of multithreaded programs in proceedings of the acm sigplan conference on programming language design andimplementation san diego california usa june pp.
.
a. desai s. qadeer and s. a. seshia systematic testing of asynchronous reactive systems in proceedings of the 10th joint meeting on f oundations of software engineering esec fse bergamo italy august september pp.
.
j. huang stateless model checking concurrent programs with maximal causality reduction in proceedings of the 36th acm sigplan conference on programming language design and implementation portland or usa june pp.
.
m. musuvathi d. y .
w. park a. chou d. r. engler and d. l. dill cmc a pragmatic approach to model checking real code in 5th symposium on operating system design and implementation osdi2002 boston massachusetts usa december .
c. flanagan and s. n. freund atomizer a dynamic atomicity checker for multithreaded programs in proceedings of the 31st acm sigplansigact symposium on principles of programming languages popl2004 v enice italy january pp.
.
s. park s. lu and y .
zhou ctrigger exposing atomicity violation bugs from their hiding places in proceedings of the 14th international conference on architectural support for programming languages andoperating systems asplos washington dc usa march pp.
.
c. flanagan and s. n. freund fasttrack efficient and precise dynamic race detection in proceedings of the acm sigplan conference on programming language design and implementation pldi dublin ireland june pp.
.
k. sen race directed random testing of concurrent programs in proceedings of the acm sigplan conference on programminglanguage design and implementation tucson az usa june pp.
.
s. savage m. burrows g. nelson p. sobalvarro and t. e. anderson eraser a dynamic data race detector for multi threaded programs inproceedings of the sixteenth acm symposium on operating system principles sosp st. malo france october pp.
.
s. bhansali w. k. chen s. de jong a. edwards r. murray m. drini c d. miho cka and j. chau framework for instruction level tracing and analysis of program executions in proceedings of the 2nd international conference on virtual execution environments ser.
vee .
newyork ny usa association for computing machinery pp.
.
.
available g. w. dunlap s. t. king s. cinar m. a. basrai and p. m. chen revirt enabling intrusion analysis through virtual machine loggingand replay sigops oper .
syst.
rev.
vol.
no.
si pp.
dec. .
.
available g. w. dunlap d. g. lucchetti m. a. fetterman and p. m. chen execution replay of multiprocessor virtual machines in proceedings of the f ourth acm sigplan sigops international conference onvirtual execution environments ser.
vee .
new york ny usa 690association for computing machinery pp.
.
.
available j. d. choi and h. srinivasan deterministic replay of java multithreaded applications in proceedings of the sigmetrics symposium on parallel and distributed tools ser.
spdt .
new york ny usa association for computing machinery pp.
.
.available m. xu r. bodik and m. d. hill a flight data recorder for enabling full system multiprocessor deterministic replay inproceedings of the 30th annual international symposium on computerarchitecture ser.
isca .
new york ny usa associationfor computing machinery pp.
.
.
available