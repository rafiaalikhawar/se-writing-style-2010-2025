repfinder finding replacements for missing apis in library update kaifeng huang bihuan chen linghao pan shuai wu xin peng school of computer science and shanghai key laboratory of data science fudan university china abstract libraries are widely adopted in developing software projects.
library apis are often missing during library evolution as library developers may deprecate remove or refactor apis.
asa result client developers have to manually find replacement apisfor missing apis when updating library versions in their projects which is a difficult and expensive software maintenance task.
one of the key limitations of the existing automated approaches is thatthey usually consider the library itself as the single source to findreplacement apis which heavily limits their accuracy.
in this paper we first present an empirical study to understand characteristics about missing apis and their replacements.
specif ically we quantify the prevalence of missing apis and summarizethe knowledge sources where the replacements are found and thecode change and mapping cardinality between missing apis andtheir replacements.
then inspired by the insights from our study we propose a heuristic based approach r epfinder to automatically find replacements for missing apis in library update.
we de sign and combine a set of heuristics to hierarchically search threesources deprecation message own library and external library for finding replacements.
our evaluation has demonstrated that r epfinder can find replacement apis effectively and efficiently and significantly outperform the state of the art approaches.
i. i ntroduction libraries are widely adopted in developing software projects .
developers need to update library versions in their projects under various circumstances e.g.
using new functionalities and b u gfi x e s solving dependency conflicts mitigating vulnerability risks and harmonizing inconsistent library versions .
as libraries evolve i.e.
new library versions are released library developers might introducemissing apis i.e.
apis that are missing in the new library ver sions by deprecating removing or refactoring apis.
as a conse quence client projects fail to compile after library update whileclient developers have to manually investigate how to replace us ages of missing apis.
due to this difficult and expensive manualanalysis client developers may choose not to update library ver sions and thus cause technical lags .
to achieve automated library update various api adaptation approaches have been introduced .
in general api adaptation can be decomposed into two tasks i.e.
the first is to find what is the replacement of a missing api e.g.
and the second is to identify how usages of a missing api are ac tually replaced by usages of its replacement api e.g.
.
the first task which is the focus of this paper has been achieved by four groups of approaches.
manual approaches require library developers to specify the mapping between missing apis and their replacements or to record api refactoring actions in ide.
however the involvement of library developersis often not available.
similarity based approaches utilize textual metric and structural similarities to build the map ping.
usage based approaches identify the mapping from api usage changes in library s instantiation code or owncode.
however they become infeasible when missing apis arenot used in library s instantiation code or own code.
hybrid approaches combine and extend similarity based and usage based approaches and hence also share their limitation.
all approaches share the same limitation that they consider the library itself as the single source to find replacement apis andonly wu et al.
further consider libraries of the same vendor.
therefore the accuracy of these approaches are limited.
to address the limitations we first conduct an empirical study to characterize missing apis and their replacement apis.
here we regard public methods in public classes as apis.
specifically we quantify the prevalence of missing apis in major version updates minor version updates and patch version up dates from widely used libraries.
on average and244 apis are missing in major minor and patch version updates.moreover we manually find the replacement apis for miss ing apis in version updates and summarize the knowledgesources where the replacements are found and the code change and mapping cardinality between missing apis and their replacements.
deprecation message own library and external library are the three sources to find replacements respectively accounting for .
.
and .
of the missing apis.code change from missing apis to their replacements can be categorized into refactoring .
substitution .
and deletion .
.
one to one mapping .
is the commonest cardinality between missing apis and their replacements.
then inspired by our study we propose a heuristic based approach named r epfinder to automatically find replacement apis for missing apis in library update.
r epfinder takes as inputs the old library version before update the new library version after update and an api that resides in the old libraryversion but is missing in the new library version and returns the replacement apis.
r epfinder searches the three sources i.e.
deprecation message own library and external library to find replacement apis.
specifically we design a set of heuristics for each source based on our empirical study and hierarchically combine them to find replacement apis.
to evaluate the effectiveness of r epfinder we compared repfinder with two state of the art approaches i.e.
r efdiff and a ura on missing apis.
r epfinder significantly outperformed r efdiffand a ura in recall by up to .
while having a slight decrease in precision by 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee .
.
further we evaluated the efficiency of r epfinder .
repfinder took one seconds on average to find replacements for a missing api.
moreover we applied r epfinder to library update on projects.
r epfinder successfully found replacements for all missing apis for .
projects.
in summary this work makes the following contributions.
we conduct an empirical study to characterize missing apis and their replacement apis in library update.
we propose a heuristic based approach named r epfinder to find replacements for missing apis in library update.
we conduct extensive experiments to demonstrate the effectiveness and efficiency of r epfinder .
ii.
a nempirical study in this section we present an empirical study to characterize missing apis and their replacements to inspire approach design.
a. study design we designed our study to answer the following four research questions about missing apis and their replacements.
rq1 prevalence analysis how prevalent are missing apis in library evolution?
sec.
ii c rq2 source analysis what are the knowledge sources for finding replacements for missing apis?
sec.
ii d rq3 change analysis what is the code change between missing apis and their replacements?
sec.
ii e rq4 cardinality analysis what is the mapping cardinality between missing apis and their replacements?
sec.
ii f before elaborating our rq design we define some library terms to avoid confusion.
library update refers to updating an old li brary version to a new library version.
hereafter old library ver sion refers to the library version before library update and newlibrary version refers to the library version after library update.
we designed rq1 to quantify the prevalence of missing apis in library evolution.
to this end for each of the collected library version updates sec.
ii b we analyzed the number of public classes and the number of public methods in public classes that are defined in the old library version but are missing in thenew library version through code differencing .
defined by semantic versioning version numbers must take the form ofx.y.z where x yand zdenotes the major minor and patch version.
bug fixes not affecting apis increment z backwards compatible api changes or additions increment y and backwards incompatible api changes increment x. generally client developers need no integration effort if updating to a patch or minor version but need some integration effort if updating to a major version.
therefore we conducted our prevalence analysis via distinguishing major version updates the old and new library version have different major version minor version updates the old and new library version have the same major version but different minor version and patch version updates the old and new library version have the same major and minor version but different patch version .
our results from rq1 aim to motivate the need of an automated approach to find replacements for missing apis.fig.
.
prevalence of missing apis in library evolution we designed rq2 rq3 and rq4 to characterize the knowledge sources for finding replacements for missing apis and thecode change and mapping cardinality between missing apis andtheir replacements.
to this end for each of the collected missing apis in the collected library version updates sec.
ii b two of the authors separately found its replacements by analyzing apiusages in client projects looking at library documentations andsearching internet resources and recorded its knowledge source code change and mapping cardinality.
then they discussed andinvestigated inconsistent cases together to reach consensus andcategorized knowledge sources code change and mapping car dinality.
our results from rq2 rq3 and rq4 aim to capture the characteristics of missing apis and their replacements to inspire the design of an automated approach.
b. data collection to prepare library version updates for our rqs we decided to choose libraries that were truly used by client projects so that i the characteristics about missing apis and their replacements would be more realistic and more representative and ii our manual analysis would become more accurate as we could use clientprojects to help to confirm whether the replacements we found were correct.
hence we selected the github java projects thatwere created after used maven as the build tool and had more than stars.
these criteria were adopted to ensure projectquality and ease the extraction of libraries which restricted ourselection to projects.
from these projects we extracted atotal of used libraries and used library versions and collected library api calls using javaparser .
for rq1 we chose libraries that were most widely used according to our collected library api calls.
library versions from these libraries were used from which we generated a version update for any two adjacent major minor and patchversions.
if multiple library versions shared the same major minor or patch version we randomly selected one of them.
fi nally we prepared major version updates minor version updates and patch version updates.
for rq2 rq3 and rq4 we selected libraries whose library apis were called by more than ten times across projects to increase the possibility of finding missing apis called by projects which resulted in libraries.
of these libraries libraries had at least two library versions used in projects.
library 267table i. examples of missing apis and their replacements in library update no.
libraryversion updatemissing api replacement api source 1org.mapdb mapdb0.
.
.
.
org.mapdb.dbmaker.writeaheadlogdisable org.mapdb.dbmaker.transactiondisable deprecation message 2org.apache.lucene lucene core5.
.
.
.
org.apache.lucene.search.phrasequery.add term org.apache.lucene.search.phrasequery.builder.add term own library 3org.apache.lucene lucene core3.
.
.
.0org.apache.lucene.analysis.standard.standardanalyzer.standardanalyzer version org.apache.lucene.analysis.standard.
standardanalyzer.standardanalyzer version vendorlibrary 4org.elasticsearchelasticsearch .
.
.
.
org.elasticsearch.common.joda.time.format.datetimeformatter.print long org.joda.time.format.datetimeformatter.print long dependency library 5org.elasticsearchelasticsearch .
.
.
.1org.elasticsearch.common.trove.list.array.
tintarraylist.toarray gnu.trove.list.array.
tintarraylist.toarray similarlibrary 6org.jsoupjsoup .
.
.
.1org.jsoup.select.elements.contains object java.util.
arraylist.contains object jdk library 7org.apache.solrsolr solrj .
.
.
.
org.apache.solr.client.solrj.util.
clientutils.tosolrinputdocument solrdocument nadeprecation message versions from these libraries were used in projects from which we generated version updates in three ways.
first we selected the smallest and the largest version as a version update to simulate the largest version gap in library update.
second we se lected any two adjacent versions as a version update to simulatetimely library update.
third we selected any two adjacent major versions as a version update to simulate major library version update where missing apis are very common.
if multiple library versions had the same major version we selected the version with the highest api usage.
we generated major version updates minor version updates and patch version updates.
of these version updates major version updates 19minor version updates and patch version updates had missing apis called across projects resulting in missing apis that were from libraries and truly called across projects.
c. prevalence analysis rq1 fig.1presents the average number of missing public classes and missing public methods in major minor and patch version updates.
we can observe that major version updates introduce the most missing public classes and missing public methods which is consistent to semantic versioning and minor version updates and patch version updates also introduce some missingpublic classes and missing public methods which actually vio lates semantic versioning.
averagely public classes and 215public methods are missing in a major version update.
if we include the public methods in missing public classes a total of public methods are missing.
in a minor and patch version update and public classes and and public methods aremissing.
these results indicate that missing apis are prevalent and severe in major version updates and also occur in minor and patch version updates.
d. source analysis rq2 we summarize three sources i.e.
deprecation message own library and external library where the replacement apis can be found.
first for .
of the missing apis the depre cation message in javadoc gives the hint about the replacement apis.
specifically .
of the deprecation messages include a link tag for developer to navigate to the replacement api whileothers .
do not include a link but list the replacement in text.
however the deprecation message is not always in thejavadoc of the old library version but can be in the javadoc of a library version that is released before the new library version.
this result indicates that api changes might not be always documented in javadoc.
example .
the second row of table ireports an example that the api org.mapdb.dbmaker .writeaheadlogdisable in the old version .
.
of the library mapdb is missing in the new version .
.
.
there is no deprecation message in the javadoc of the old version .
.
.
it turns out that the deprecation message is in the javadoc of the version .
.
and says that use transactiondisable instead with a link to the replacement.
second for .
of the missing apis their replacement apis can be found in their own library i.e.
the newlibrary version.
as refactoring is a common practice in library evolution some apis are refactored to become missing in the new library version see sec.
ii e for a detailed discussion .
notice that for the missing apis whose replacements are foundby deprecation message their replacements are actually also in the new library version but here we do not include them.
example .
for the second example in table i no deprecation message can be found in the versions of the library lucenecore for the missing api org.apache.lucene.search.phrasequery.add term in the version .
.
.
after investigating the source code of the version .
.
we find that the missing apiis moved from the class phrasequery to its inner class builder.
third for .
of the missing apis their replacements can be found in related external libraries.
specifically thereplacements are found in the library with the same vendor i.e.
vendor library for missing apis the library that is declared as a direct dependency i.e.
dependency library for missing apis the library that provides a similar api to the missing api i.e.
similar library for missing apis and the jdk library for missing apis.
example .
in the third example in table i the api locates in the version .
.
of the library lucene core but is missing in the version .
.
.
it turns out that the lucene project evolves intoa multiple module project and it reorganizes its modules afterthe version .
.
.
as a result the api originally a part of themodule corresponding to the library lucene core is moved into another module corresponding to the library lucene analyzercommon that shares the same vendor.
example .
in the fourth example in table i the library 268table ii.
code change between missing apis and their replacements code change change level change action deprecation message own library external library none refactoringclassmove class rename class methodpull up method push down method change method signature move method substitutionclasssubstitute by method with different name from another class18 substitute by method with same name from another class8 methodsubstitute by method with different name from own class deletionclass delete class method delete method composition na na joda time is used by the library elasticsearch by copy andpaste in the version .
.
i.e.
the source code of joda time is directly included in the packages of elasticsearch.h o w e v e r i n the version .
.
the source code of joda time has already been removed from elasticsearch which introduces the missing api.
elasticsearch declares joda time as a direct dependency as it itself also uses the apis in joda time.
example .
the fifth example in table iis similar to example2.
.
the library trove is used by the library elasticsearch by copy and paste in the version .
.
.
however in the version .
.
the source code of trove has already been removed from elasticsearch which introduces the missing api.
the difference from example .4is that elasticsearch does not declare trove as a direct dependency after removing the source code of trove.
example .
the sixth example in table ishows that the api jsoup.select.elements.contains object in the old version .
.
of library jsoup is missing in the new version .
.
.
it turns out that the class elements in the old version .
.
inherits the class arraylist in the jdk library and overrides the method contains object .
however in the new version .
.
the method contains object is removed but the inheritance still exists and thus the replacement api is the method contains object in the class arraylist in the jdk library.
finally of the remaining missing apis .
missing apis have no replacement i.e.
these missing apis aresimply removed.
here we take a conservative approach to conclude that a missing api has no replacement.
we first use the previous three sources to check whether we can find a replace ment.
if not we then look for clear evidences of no replacement e.g.
deprecation message and release note that clearly say the removal of a functionality and the functionality of the missing api is inlined in other methods.
still we fail to find replacement for missing apis but cannot conclude no replacement.
example .
the last example in table ishows that the api org.apache.solr .client.solrj.util.clientutils.tosolrinputdocu ment solrdocument in the old version .
.
of the library solr solrj is missing in the new version .
.
.
the deprecation message clearly says that this method will be removed in solr .
and we make the conclusion of no replacement.
e. change analysis rq3 we categorize three basic code changes from missing apis to their replacements i.e.
refactoring substitution and deletion and a composition of these basic code changes.
table iireports a detailed categorization and its correlation to the sources discussed in sec.
ii d. here we denote the old library version aslo the missing api as mo the residing class of moinlo asco the replacement api as mn the residing class of mn ascn and the residing library of mnasln.
the first category is refactoring covering .
of the missing apis.
if mndoes not reside in lo we consider the change from motomnas refactoring.
specifically as shown in the second column refactoring can be conducted at two different levels.
at the class level cocan be moved into a different package in ln while mnis the same to moexcept for the residing package name.
cocan be renamed in ln while mn is the same to moexcept for the residing class name.
at the method level mocan be pushed up or pushed down along the inheritance tree.
the signature of mocan be changed in ln including its return type method name and parameter type.
mocan also be move into a different class in ln.
the second category is substitution covering .
of the missing apis.
substitution means that there exists another api that can do the similar job to the missing api.
both apis can co exist and later the missing api is deprecated and finally removed.
thus if mnalso resides in lo we consider the change from motomnas substitution.
in particular as shown in the second column substitution can be conducted at two different levels.
at the class level mocan be substituted by a method from another class either with the same method name or a different method name.
at the method level mo can be substituted by a different method from its own class.
the third category is deletion covering .
of the missing apis which means there is no need in the functionalities the api provides and the library developer simply removesit in the new library version.
thus only the missing apis we conclude no replacement i.e.
the last column in table ii belong to this category.
as shown in the second column deletion can be conducted at two different levels.
at the class level cocan be deleted and thus moincois also deleted.
at the method level mocan be deleted while costill exists.
apart from these basic code changes there are more complex code changes which are a composition of the three basic code changes.
for example the signature of mocan be changed in ln and then the method is pushed up into its super class or 269table iii.
examples of missing apis and their replacements with various cardinality no.
libraryversion updatemissing api replacement apis 1redis.clients jedis2.
.
.
.
redis.clients.jedis.
jedispoolconfig.setmaxactive int org.apache.commons.pool2.impl.genericobjectpoolconfig.setmaxtotal int org.apache.commons.pool2.impl.genericobjectpoolconfig.setmaxidle int 2org.apache.lucene lucene core3.
.
.
.0org.apache.lucene.document.numericfield.setintvalue int org.apache.lucene.document.intfield.setintvalue int org.apache.lucene.document.longfield.setintvalue int org.apache.lucene.document.floatfield.setintvalue int org.apache.lucene.document.doublefield.setintvalue int 3org.apache.lucene lucene core2.
.
.
.
org.apache.lucene.search.hits.iterator org.apache.lucene.search.indexsearcher.search query int org.apache.lucene.search.scoredoc.docorg.apache.lucene.search.indexsearcher.doc int cois moved into a different package in ln while the signature ofmois changed.
this category accounts for a total of .
missing apis.
f .
cardinality analysis rq4 from the missing apis that we find replacements we categorize five types of mapping cardinality i.e.
one to one one to many one to some many to one and many to many.
we observe that most of the missing apis .
have a one to one mapping to their replacements.
the first six examples in table ibelong to this category.
besides and missing apis have a one to many one to some many to one and manyto many mapping to their replacements.
here one to some mapping means the missing api has more than one replacement and which one to use depends on the api usage context.
example .
the first example in table ishows an example of one to many mapping.
the missing api sets the field maxactive.
its two replacements respectively set the field maxtotal and maxidle.a s maxtotal maxidle equals maxactive the missing api can be replaced by the two replacements together.
example .
the second example in table ishows an example of one to some mapping.
the missing api belongs to the class numericfield which is later replaced by specific classes intfield longfield floatfield and doublefield.
depending on the type of numeric field used the missing api can be replaced by the api from one of the four classes.
example .
the third example in table ishows an example of many to many mapping.
the missing api is the methoditerator from the class hits which is often used in the scenario to iterate over all hits for a search query and get the documentfor each hit.
however in the version .
.
lucene core provides another set of apis to realize this scenario.
therefore these apis often used together should be replaced together.
g. insights from our study results we have several insights.
i1 tools are needed to help developers find replacement apis for missing apis in library update as missing apis are prevalent especially in major version updates.
i2 multiple sources should be leveraged together to find replacements for missing apis as a single source alone usually fails to find replacements for all missing apis.
i3 replacement apis can be found by searching deprecation message in javadoc or searching similar methods in the own library or some external libraries as missing apis might have deprecation message to indicate their replacements and are often refactored or substituted into a similar method in thesearching deprecation messagesearching own librarysearching external library library databasereplacement apis missing apilibrary update fig.
.
approach overview of r epfinder own library or some external libraries.
i5 it is still useful to only find one to one mapping for missing apis as most missing apis have a one to one mapping to their replacements.
iii.
o urapproach based on the insights from our study we propose a heuristicbased approach named r epfinder to automatically find replacements for missing apis in library update.
as shown in fig.
it takes as inputs a library update i.e.
an old library version lobefore the update and a new library version lnafter the update and a missing api mothat is resides in lobut is missing inln and returns a set of replacement apis m.repfinder has three steps i.e.
parsing deprecation message searchingown library and searching external library to find m. each step leverages one of the three sources to heuristically find m. repfinder has a library database where the jar file javadoc file and pom file for all library releases and jdk libraries arestored.
we have a pipeline to regularly crawl them from maven.
to ease the approach presentation we formally define two terms.
a library version lis denoted as a three tuple angbracketleftgroup artifact version angbracketright where group andartifact denote the vendor and name of the library and version denotes the version number of the library.
an api which is considered as a publicmethod in a public class in this work is denoted as a six tuple angbracketleftlib pkg cls ret name param angbracketright where lib pkg andclsdenote its residing library version package and class retdenotes its return type name denotes its method name and param denotes a list of its parameter types.
a. searching deprecation message given lo lnandmo the first step of r epfinder is to find replacement apis by searching deprecation message.
as deprecation often follows a deprecate replace remove cycle momight be deprecated in a library version before ln.
thus r epfinder first retrieves a sorted list of the javadoc files for all the library versions from lotoln denoted as d from our library database.
as revealed by our empirical study a deprecation message may use a hyper link or a text to indicate the replacements.
besides there is no deprecation message for moifmo.clsis deprecated 270p1.
use a href link text a p2.
use code text code p3.
use text p4.
replaced a href link text a p5.
replaced text p6.
in favor of a href link text a p7.
in favor of text p8.
rename to a href link text a p9.
rename to textp10.
call a href link text a p11.
move to text p12.
be removed fig.
.
matching patterns for deprecation message as a whole.
thus r epfinder then iterates over din a reverse order to search deprecation messages with following heuristics.
method deprecation with link.
repfinder analyzes the deprecation message by matching patterns in fig.
3summarized through our empirical study.
if a pattern is matched it extracts the hyper link of the replacement apis and resolves their pkg cls ret name andparam from the documentation.
method deprecation with text.
repfinder extracts the textual information e.g.
cls name andparam about the replacement apis by matching patterns in fig.
.
if matched it uses the textual information to validate the existence of the re placement apis in javadoc.
if validated it resolves their pkg cls ret name andparam from their documentation.
class deprecation with link.
repfinder extracts the hyper link of the replacement class of mo.clsby matching patterns in fig.
.
if matched it identifies the replacement api whose method name equals to mo.name and whose parameter types equal to mo.param .
if identified it resolves its pkg cls ret name andparam from the documentation.
class deprecation with text.
repfinder extracts the name of the replacement class of mo.clsby matching patterns in fig.
.
if matched it validates the existence of the replacement class in javadoc.
if validated it finds the replacement api whose method name equals to mo.name and whose parameter types equal to mo.param .
if found it resolves its pkg cls ret name andparam from the documentation.
it is worth mentioning that i we use exact matching to find re placement classes and apis to improve the accuracy ii we mayfind multiple replacement apis as the method deprecation mes sage might list multiple replacement apis and iii once the last pattern in fig.
3is matched we conclude no replacement.
finally r epfinder validates whether the replacement apis exist in lnby searching the javadoc file of lnbecause the replacement apis might be resolved from the javadoc file of a library version before ln.
if validated r epfinder resolves the lib puts the replacement apis to m and returns m. if not repfinder continues to the next two steps.
b. searching own library given lo lnandmo the second step of r epfinder is to find the replacement api by searching ln.repfinder retrieves the jar file of lnfrom our library database and finds the replacementapi by sequentially applying following heuristics.
our idea is to first find the api with identical name in super or similar classes asmomay be moved to such classes see table ii and then find the api with similar name in super or similar classes as momay be moved to such classes and changed see table ii .
search identical api in super classes.
repfinder checks whether mo.clsexists in ln.
if yes it analyzes mo.clsto obtain its parent class and grant parent class.
here we empiri cally only track two super classes based on observations fromour empirical study.
then it checks whether each super classexists in ln.
if yes it analyzes the super class in lnto find the replacement api whose name equals to mo.name and whose parameter types equal to mo.param .
if found it puts the replacement api to mand returns m. notice that if we find the replacement api from both its parent class and grant parent class we use the replacement api from its parent class.
search identical api in similar classes.
repfinder checks whether mo.pkg exists in ln.
if yes it iterates over each class clsunder mo.pkg inlnto compute the distance from clsto mo.clsby tokenizing class name according to camel case and changing plurals into singles before applying levenshtein dis tance .
for the classes that are similar to mo.cls i.e.
the class distance is smaller than thc it analyzes the class from the smallest class distance to the largest class distance to find the replacement api whose name equals to mo.name and whose parameter types equal to mo.param .
once it finds the replacement api it puts it to mand returns m. besides if mo.pkg does not exist in ln it searches across all packages inlnin the same way to the above procedure.
search similar api in super classes.
this heuristic shares the same procedure to the first heuristic except that it finds the re placement api that is similar but not identical to mo.
to this end we borrow the distance metric from nguyen et al.
s work which is computed as a weighted sum of the distances of return types method names and parameter types as shown in eq.
where dis computes the levenshtein distance .
dis mo mn .
dis mo.ret m n.ret .
dis mo.name m n.name .
dis mo.param m n.param for the apis whose distance to mois smaller than th1 m it selects the api with the smallest distance as the candidate api which will be finally determined in the last step.
search similar api in similar classes.
this heuristic has the same procedure to the second heuristic except that it finds the replacement api that is similar but not identical to mo.
thus it applies the same distance metric to the third heuristic to find candidate api except that a different threshold th2 mis used.
c. searching external library given lo ln moand the candidate api the last step of repfinder is triggered only when r epfinder does not find the replacement apis or only finds the candidate api in the previous steps.
our idea is to find the api with identical name in super or identical classes in some external libraries as mo may be moved to such classes see table ii .
271to this end it first collects four lists of external libraries respectively for jdk library dependency library vendor library and similar library see sec.
ii d .
specifically it retrieves the jar file of a specific jdk library version which can be configured by users as they often know the jdk library version their projects use from our library database and puts it to lj.
besides it retrieves the pom file of ln uses the method in wang et al.
to parse the pom file for a list of direct library dependencies of ln retrieves their jar file from our library database and puts them to ld.
further it queries our library database for all the libraries with the same group to lo.group but a different artifact to lo.artifact .
for each of such vendor libraries it selects the same version number to ln.version if exists otherwise it selects the version number whose release date is no later than lnbut is closest to ln and then retrieves its jar file from our library database and puts it to jv.
finally it uses tokens in mo.pkg mo.clsandmo.name to query our library database which is indexed with libraries group and artifact selects the top ten hits as similar libraries selects their version number whose release date is no later than lnbut is closest to ln and puts their jar files to js.
then r epfinder sequentially iterates over the four types of external libraries lj ld lvandlsto find the replacement api.
this order is inspired by our empirical study as ljhas the highest possibility to provide the replacement while lshas the lowest possibility.
once a replacement api is found during theiteration r epfinder returns it.
only if no replacement api is found in these external libraries r epfinder returns the candidate api as the replacement.
r epfinder uses following two heuristics to find the replacement in an external library le.
search identical api in super classes.
this heuristic has the same procedure as the first heuristic in sec.
iii b except that it checks whether each super class exists in lebut not ln and if yes it finds the identical api in the super class in le.
search identical api in identical classes.
this heuristic is similar to the second heuristic in sec.
iii b .
it checks whether mo.pkg exists in le.
if yes it iterates over each class clsundermo.pkg inleto find the class whose name is identical to mo.cls.
if found it analyzes the class to find the replacement api whose name is identical to mo.name and whose parameter types are identical to mo.param .
once it finds the replacement api it puts it to mand returns m. besides if mo.pkg does not exist in le it searches across all packages inlein the same way to the above procedure.
iv .
e v aluation we have implemented a prototype of r epfinder in .2k lines of java code and released the source code at our website with our experimental data set.
a. evaluation setup to evaluate the effectiveness and efficiency of r epfinder we designed our evaluation to answer four research questions.
rq5 effectiveness evaluation how is the effectiveness of repfinder compared with state of the art approaches?table iv.
effectiveness comparison to state of the art approach tp fp fn pre.
rec.
aura .
.
refdiff .
.
repfinder .
.
rq6 efficiency evaluation how is the time overhead of repfinder in finding replacement apis?
rq7 sensitivity analysis how is the sensitivity of each parameter in r epfinder to the effectiveness of r epfinder ?
rq8 application analysis how is effectiveness of applying r epfinder to library update in real life projects?
data set.
we used the missing apis whose replacements were found or considered as none in our study see sec.
ii a s the data set for answering rq5 rq6 and rq7 i.e.
we did not include the uncertain missing apis.
besides to answer rq8 we used github java projects to update their used libraries.
comparison approaches.
for rq5 we selected two stateof the art approaches i a ura which is a hybrid approach that combines similarity based and usage based approaches.
weselected it because it achieved the best performance over previ ous approaches.
ii r efdiff which is the state of the art refactoring detection tool.
although r efdiffis not designed to find replacement apis we selected it because our study showed that a large part of missing apis were refactored into their replacement apis.
notice that we failed to compare r epfinder with h ima which is another hybrid approach as it requires libraries to use svn but now libraries seldom use svn.
a ura and r efdifftake as inputs two library versions and detect all api mappings or api refactorings between the two versions.
to align with our data set we filtered their results to check whetherthey found the replacements for the missing api in our data set.
evaluation metrics.
we used precision and recall as the indicator of effectiveness as they were widely used in prior work.for the ease of computation for precision and recall similar to a ura we converted a one to many mapping as many oneto one mappings a one to some mapping as a one to one mapping i.e.
we treated finding one of the some replacements as correct and a many to one mapping as a one to one mapping and a many to many mapping as many one to one mappings i.e.
we only targeted the missing api .
due to such conversion we had mappings to find for missing apis.
b. effectiveness evaluation rq5 table ivreports the overall results of a ura refdiffand repfinder with respect to true positive tp false positive fp false negative fn precision pre.
and recall rec.
.
we can see that r epfinder significantly increased the number of true positives and reduced the number of false negatives and thus significantly outperformed a ura and r efdiffin recall by .
and .
.
however r epfinder had a higher number of false positives than r efdiff resulting in a .
decrease in precision than r efdiff but r epfinder had a lower number of false positives than a ura resulting in a .
increase in precision than a ura.
besides although r efdiff was not originally designed for finding replacements it achieved the highest precision as it could accurately detect refactorings.
272table v. effectiveness comparison w.r.t.
sources source num.aura refdiff repfinder tp fp fn pre.
rec.
tp fp fn pre.
rec.
tp fp fn pre.
rec.
deprecation message .
.
.
.
.
.
own library .
.
.
.
.
.
external library .
.
.
.
.
.
none .
.
.
.
.
.
table vi.
effectiveness comparison w.r.t.
code changes code change change level change action num.aura refdiff repfinder pre.
rec.
pre.
rec.
pre.
rec.
refactoringclassmove class .
.
.
.
.
.
rename class .
.
.
.
.
.
methodpull up method .
.
.
.
.
.
push down method .
.
.
.
.
.
change method signature .
.
.
.
.
.
move method .
.
.
.
.
.
substitutionclasssubstitute by method with different name from another class26 .
.
.
.
.
.
substitute by method with same name from another class8 .
.
.
.
.
.
methodsubstitute by method with different name from own class5 .
.
.
.
.
.
deletionclass delete class .
.
.
.
.
.
method delete method .
.
.
.
.
.
composition na na .
.
.
.
.
.
moreover table vbreaks down the effectiveness results according to the sources where the replacements are found where the second column i.e.
num.
reports the number of mappings each approach should find i.e.
their sum should be .
we can observe that a ura and r efdiffachieved precision and recall for missing apis whose replacements were found in external libraries while r epfinder had a precision and recall of .
and .
.
it owes to the fact that a ura and r efdiffare designed to not use the source of external libraries.
besides forthe source of deprecation message a ura and r efdiffcould still find some replacement apis by using the libraries but repfinder achieved the highest recall by directly leveraging the knowledge in deprecation message.
for the source of own library r epfinder achieved the highest precision and recall as our heuristics are designed based on a deep understanding ofthe characteristics of missing apis and their replacements.
forthe missing apis with no replacement r epfinder had a lower recall.
these results demonstrate the importance of combining different knowledge sources for finding replacements.
in addition table vibreaks down the effectiveness results according to the code changes between missing apis and their re placements.
we can observe that for refactoring r efdiffhad a precision for move class and move method and a low recall because i r efdiffoften works at the commit level but it may work not well at the library version level due to the large amount of changes between versions and ii replacements can bein external libraries.
a ura achieved low precision and recall across most change actions because i some missing apis have limited usages and ii replacements can be in external libraries.
instead r epfinder achieved a balanced precision and recall except for move method because the missing api can be moved into a class that has a dissimilar name from its original residing class.
for substitution a ura and r efdiffalmost failed to find replacements.
r epfinder also achieved low precision and recall because the missing apican be substituted by a dissimilar method in a dissimilar class .
for deletion r epfinder had a lower recall than a ura and refdiffbecause a ura and r efdifffound no replacement for a large number of missing apis.
for composition allapproaches had low precision and recall while r epfinder was the best.
these results indicate that syntactic similarity measures used in r epfinder may not be good enough to find replacement apis and some semantic similarity measures may be designed to further improve r epfinder .
repfinder significantly improved the state of the art approaches in recall by up to .
while having a slightdecrease in precision by .
.
we believe a slight decrease in precision is acceptable as recall increases satisfactorily.
c. efficiency evaluation rq6 repfinder took seconds for finding replacements for missing apis.
on average r epfinder took about one second to find the replacements for a missing api.
we believethe efficiency of r epfinder is good and it can be practically used by developers.
the good efficiency of r epfinder owes to the availability of a library database as well as our lightweightdesign of heuristics.
notice that we did not compared the time overhead of a ura and r efdiffbecause they found all api mappings or refactorings between two library versions.
repfinder took about one second to find the replacements for a missing api which was acceptable for practical usage by developers.
d. sensitivity analysis rq7 three thresholds i.e.
the class distance threshold thcand two method distance thresholds th1 mandth2m are configurable in the second step of r epfinder see sec.
iii b .
the default configuration is .
and which is used in the experiment for a thc b th1 m c th2m fig.
.
results of parameter sensitivity analysis table vii.
code change between missing apis and their replacements code change change level change action deprecation message own library external library none refactoringclassmove class rename class methodpull up method push down method change method signature move method substitutionclasssubstitute by method with different name from another class1 substitute by method with same name from another class4 methodsubstitute by method with different name from own class1 deletionclass delete class method delete method composition na na rq5 rq6 and rq8 .
to evaluate their sensitivity to the effectiveness of r epfinder we re configured one threshold and fixed the other two and re ran r epfinder against our data set.
specifically thcwas configured from to by a step of and th1 mandth2mwere configured from .
to by a step of .
.
fig.4presents the impact of three thresholds on the precision and recall of r epfinder where x axis denotes the value of threshold and y axis denotes the precision or recall.
overall as thcincreased the recall of r epfinder first increased and then stabilized while its precision was almost stable.
thus we believe .
is a good value for thc.a s th1mincreased the recall and precision of r epfinder were first stable and then decreased.
thus we believe .
is a good value for th1m.
asth2mincreased the recall of r epfinder first greatly increased and then slightly decreased while its precision slightly decreased.
hence we believe is a good value for th2m.
overall the sensitivity of the configurable parameters to the effectiveness of r epfinder is acceptable.
e. application analysis rq8 to apply r epfinder to library update in real life projects we initially selected github java projects which had more than stars and used maven as the build tool.
we analyzed the library dependencies in these projects and found that projects used outdated library versions.
here we set our goal to update these outdated library versions to their latest version.
thus we analyzed library api usage in these projects and found that outdated library versions in projects had used apis missing in their latest version.
two of the authorstable viii.
effectiveness comparison to state of the art approach tp fp fn pre.
rec.
aura .
.
refdiff .
.
repfinder .
.
followed the same procedure to sec.
ii a to manually find the replacements but could not determine the replacements for missing apis.
hence we ran r epfinder against these missing apis involving outdated library versions in projects.
notice that these missing apis had a overlapof missing apis to our data set in rq5 .
moreover we also categorized code changes of these missing apis to their replacements in table vii.
compared to the results in table ii three change actions i.e.
push down method move method and delete class were not covered indicating a relatively good representativity of this data set.
repfinder achieved a precision of .
and a recall of .
on the mappings for these missing apis which were comparable to the results in rq5 demonstrating the generality of r epfinder .
specifically r epfinder successfully found replacements for all missing apis for .
projects for partial missing apis for .
projects but for no missing apis for .
projects.
this result indicates that repfinder can be effectively used in real life projects.
moreover we also compared r epfinder with a ura and refdiffon this data set as reported in table viii.
while refdiffand r epfinder achieved similar performance when compared to the results in table iv a ura had a performance degradation.
besides we also broke down the effectivenessresults on this data set according to the sources and code 274table ix.
effectiveness comparison w.r.t.
sources source num.aura refdiff repfinder tp fp fn pre.
rec.
tp fp fn pre.
rec.
tp fp fn pre.
rec.
deprecation message .
.
.
.
.
.
own library .
.
.
.
.
.
external library .
.
.
.
.
.
none .
.
.
.
.
.
table x. effectiveness comparison w.r.t.
code changes code change change level change action num.aura refdiff repfinder pre.
rec.
pre.
rec.
pre.
rec.
refactoringclassmove class .
.
.
.
.
.
rename class .
.
.
.
.
.
methodpull up method .
.
.
.
.
.
push down method change method signature .
.
.
.
.
.
move method substitutionclasssubstitute by method with different name from another class3 .
.
.
.
.
.
substitute by method with same name from another class5 .
.
.
.
.
.
methodsubstitute by method with different name from own class1 .
.
.
.
.
.
deletionclass delete class method delete method .
.
.
.
.
.
composition na na .
.
.
.
.
.
changes as shown in table ixandx.
compared to the results in table vandvi most of the findings still hold.
these results further demonstrate the generality of r epfinder .
repfinder effectively found replacements for all missing apis for .
projects when all their outdated library versions were updated to the latest version.
f .
discussion limitations.
first r epfinder mainly supports one to one mappings and only provides partial support for one to many and one to some mappings by searching deprecation messages.
we believe it is still useful as the majority of missing apis have a one to one mapping to their replacements.
one potential way to enhance r epfinder is to consider the apis called around the missing api and its found replacement to determine the possibility of a many to many mapping.
second r epfinder does not achieve good performance when the replacement api is dissimilar from the missing api or the residing class of replacement api is dissimilar from the residing class of missing api because r epfinder only leverages syntactic similarity measures.
we plan to leverage semantic similarity measures e.g.
code representation learning to improve repfinder .
third r epfinder is currently implemented for the java programming language.
it is interesting to explore the generality of r epfinder to other programming languages.
threats.
the main threat to our empirical study and evaluation is the manual construction of the replacements for missing apis.
to mitigate the threat two of the authors conducted an independent analysis followed by a group discussion to make conclusions about replacement apis.
further we also intention ally focused on missing apis that were actually used in client projects such that we could use the api usage information to help conclude whether the replacement apis identified by two of the authors were correct or not.v.
r elated work we discuss the closely relevant work in five aspects i.e.
api adaptation api deprecation api breaking api evolution and refactoring detection.
a. api adaptation a number of api adaptation approaches have been developed to update usages of missing apis in client projects to usages of their replacement apis for the ease of library update.
to find themapping between a missing api and its replacement chow andnotkin and nita and notkin designed method to allow library developers to manually specify the mapping.
henkel anddiwan developed an ide plugin to allow library developers to record api refactoring actions and allow client developers toreplay them.
these approaches often provide accurate mappingsdue to the manual involvement of library developers.
in practice however such involvement is often not available which hindersthe generalizability of these approaches.
godfrey and zou proposed a semi automated origin analysis using similarities ofname declaration complexity metrics and call dependencies.
in spired by this approach kim et al.
extended the similarity measures and automated godfrey and zou s approach.
xing andstroulia used a set of heuristics to infer replacement apis based on api changes identified from logical design models oftwo library versions.
these similarity based approaches identifyreplacement apis from the source of the library itself but do notconsider other sources.
sch afer et al.
proposed to mine the mapping from api usage changes in library s instantiation code e.g.
client projects and dagenais and robillard tried to mine the mapping from api usage changes in library s owncode.
these usage based approaches heavily rely on api usagesin instantiation code or own code and are practically infeasibleas api usages are often not rich since library s own code doesnot call every api and only a small portion of apis are called 275across client projects .
wu et al.
combined similaritybased and usage based approaches and considered the source of libraries of the same vendor.
meng et al.
analyzed commit message to infer the mapping in two consecutive commits andconfirmed the mapping by analyzing source code expanded themapping in the similar way to similarity based and usage basedapproaches and aggregated the mapping across commits.
these hybrid approaches share similar limitations to similarity based and usage based approaches.
cossette and walker reported a retroactive study with five java libraries to manually evaluate aset of techniques.
lamothe and shang explored how documentation and commits could be leveraged to find the mapping for android apis.
wu et al.
investigated how imperfect mappings affected client developers in updating libraries.
it is worth mentioning that several approaches have been proposed for finding api mappings across similar libraries e.g.
and different programming languages e.g.
.
to update usages of a missing api in client projects to usages of its replacement several approaches have been proposed e.g.
by replacing calls to a deprecated api with its bodies by type constraint analysis by heuristic rules and by historical update examples .
our approach is orthogonal to these approaches.
b. api deprecation various empirical studies have been conducted to understand api deprecation in different programming languages.
zhou et al.
found that the classic deprecate replace remove cycle is often not followed as many apis were removed without prior deprecation many deprecated apis were un deprecated later and many removed apis are even resurrected.
some studies explored why developers deprecated apis e.g.
avoiding bad code practices functional and security bugs redundantmethods merged into existing methods and renaming methods.
these studies reveal the importance of reacting to api deprecation.
otherwise the quality or maintainability of client projects might be hurt.
however some studies studied how developers reacted to api deprecation and found that deprecated apis were still widely used due to reasons likeno suitable replacements and high update effort.
besides somestudies investigated the quality of documentation for deprecated apis .
they found that and of the apis were deprecated with replacement messages in java c javascript python and android.
apart from api documentation we leverage other sources for findingreplacement apis.
except for api deprecation cogo et al.
analyzed how often and why package releases were deprecated in npm and how client packages adopted deprecated releases.
c. api breaking many empirical studies have investigated api breaking to analyze how and why developers break apis how api breaking impacts client projects etc.
besides several advances have been made to detect api breaking.
theoremproving and symbolic execution areused to detect behavioral api breaking but suffer scalability is sues.
to be scalable testing techniques are used to dynamicallydetect behavioral api breaking in java and heuristics are applied to statically detect signature api breaking e.g.
changes to api signatures in java .
in javascript testing techniques are used to identify signature breaking and behavioral breaking and heuristics are used to detect both signature and behavioral breaking .
our approach is focused on signature api breaking as there is no need to find replacements for behavioral breaking apis.
d. api evolution several empirical studies have explored api evolution to understand how refactoring affects api evolution how client developers react to api evolution how api stability is measured how android api evolution affects apps user ratings how apis are changed and used in apache and eclipse how api evolution triggers stack overflow discussions how and why apis are evolved etc.
our empirical study on missing apis has a different goal than these studies and provides insights for our approach.e.
refactoring detection several refactoring detection approaches have been proposed e.g.
r efdiff r epfinder and rm iner .
however such tool cannot be directly applied to find replacement apis because they are mostly work at the commit level and library version level changes would be much more complex than commit level changes.
vi.
c onclusions in this paper we have presented an empirical study to understand the characteristics of missing apis and their replacements.
inspired by our study results we have propose a heuristic based approach named r epfinder to automatically find replacements for missing apis in library update.
the key idea of repfinder is to leverage multiple sources to find replacements.
our evaluation has demonstrated that r epfinder can find replacement apis effectively and efficiently and significantly outperformed the state of the art approaches.
acknowledgment this work was supported by the national natural science foundation of china grant no.
.
bihuan chen is the corresponding author of this paper.