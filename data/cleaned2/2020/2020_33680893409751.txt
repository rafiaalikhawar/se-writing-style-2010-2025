rulepad interactive authoring of checkable design rules sahar mehrpour smehrpou gmu.edu george mason university fairfax virginia usathomas d. latoza tlatoza gmu.edu george mason university fairfax virginia usahamed sarvari hsarvari gmu.edu george mason university fairfax virginia usa abstract good documentation offers the promise of enabling developers to easily understand design decisions.
unfortunately in practice design documents are often rarely updated becoming inaccurate incomplete and untrustworthy.
a better solution is to enable developers to write down design rules which are checked against code for consistency.
but existing rule checkers require learning specialized query languages or program analysis frameworks creating a barrier to writing project specific rules.
we introduce two new techniques for authoring design rules snippet based authoring and semi natural language authoring.
in snippet based authoring developers specify characteristics of elements to match by writing partial code snippets.
in semi natural language authoring a textual representation offers a representation for understanding design rules and resolving ambiguities.
we implemented these approaches in rulepad.
to evaluate rulepad we conducted a between subjects study with participants comparing rulepad to the pmd designer a utility for writing rules in a popular rule checker.
we found that those with rulepad were able to successfully author times more query elements in significantly less time and reported being significantly more willing to use rulepad in their everyday work.
ccs concepts software and its engineering software maintenance tools human centered computing interactive systems and tools .
keywords design rules documentation programming tools bug finding static analysis acm reference format sahar mehrpour thomas d. latoza and hamed sarvari.
.
rulepad interactive authoring of checkable design rules.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
https introduction writing good documentation has long been viewed as key to helping developers successfully follow and understand the rationale behind permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa association for computing machinery.
acm isbn .
.
.
.
decisions helping to prevent software defects and code decay .
a design decision encompasses rationale explaining developers reasoning which led to the decision as well as constraints imposed by the design decision on how code can be written.
in this paper we refer to the constraints imposed by a design decision as a design rule .
traditional approaches to documentation rely on developers first writing decisions down in documents or comments and then consistently updating the documentation as the code changes.
however this often does not occur in practice resulting in documentation which is inaccurate incomplete and untrustworthy and encouraging developers to ignore documentation and reverse engineer design directly from code .
this makes questions about design rationale some of the most frequently reported hard to answer questions and one of the most serious problems developers report facing .
a potential solution is to ensure that design rules are checkable expressed in a representation where a program analysis tool can continuously check for inconsistencies and flag divergences between the documented rule and code .
to achieve this developers might use static analysis tools such as checkstyle pmd and findbugs to write custom project specific rules describing a defect pattern to avoid.
however existing tools require developers to either write program analyses in a general purpose programming language e.g.
findbugs or use complex query notations to describe patterns e.g.
xpath in pmd .
this restricts authoring and changing design rules to those with specialized program analysis knowledge preventing most developers from creating or maintaining design knowledge through checkable design rules.
to author checkable design rules developers should be able to work with design rules in simple and expressive representations.
we propose two techniques for authoring checkable design rules snippet based authoring in which design rules are represented in code based templates and semi natural language authoring .
these techniques are complimentary offering different levels of simplicity and expressiveness.
snippet based authoring enables developers to easily express rule through templates that look like code but may be ambiguous with complex rules.
semi natural language authoring lets developers author design rules in an expressive and unambiguous textual representation but while simpler than complex query notations requires the developer to learn a semi natural language.
we implemented these techniques in a system for authoring checkable design rules rulepad as a design rule graphical editorandtextual editor .
as developers edit design rules in the graphical editor they receive immediate feedback and can view examples of code which satisfies and violates the rule.
as a rule is constructed in the graphical editor rulepad constructs a natural language textual representation of the rule using the grammar of the textual editor which is bidirectionally synchronized.
developers may also edit or author new rules using the textual esec fse november virtual event usa sahar mehrpour thomas d. latoza and hamed sarvari representation including resolving ambiguities in situations where the graphical representation of a rule is ambiguous e.g.
elements are combined through either conjunction or disjunction .
to evaluate the ability of rulepad to enable developers to author checkable design rules more easily we conducted a user study.
participants were asked to author design rules with either rulepad or pmd an existing widely used static rule checker.
this study also offered a first usability evaluation of using pmd to author custom rules.
participants with rulepad were able to successfully author times more query elements in significantly less time and reported being significantly more willing to use rulepad in their everyday work.
participants working with the pmd designer experienced challenges with both the tool and its documentation which hindered them from making significant progress.
in the following sections we first review design rules present a motivating example describe the two approaches for authoring design rules describe the design of our system and report the results from our evaluation study.
we conclude with related work and a discussion of potential future directions.
design rules when writing code developers make design decisions choosing between alternatives formulating design rules specifying constraints to ensure that code is consistent with the design.
violating these constraints causes code to decay and drift from the originally intended design which may alter the code s behavior reduce its maintainability or prevent extensibility.
design rules vary in their scope and complexity.
some may manifest as statement level constraints.
for example consider an application in which data is persisted.
to ensure correct retrieval of persisted data in concurrently executing code a design rule might impose immediate persistence requiring a specific method call to immediately save data save calls should always be committed immediately.
ifthesave method of the persistence library is called then thenow method must be followed immediately.
ofy .save .entity this .now design rules may also manifest as constraints on how classes or methods are declared.
for example in order for specific data to be persisted as expected a design rule might dictate that all subclasses must be persisted by requiring a specific annotation artifacts should be marked for persistence with entity annotations.
ifan object is an artifact subclass then it needs to be an entity marked with subclass .
subclass index true public class adt extends artifact ... design rules may also express higher level constraints such as an architectural style.
high level design rules may be decomposed into lower level design rules that can then be directly checked.
for example adopting a sharded architectural style might be expressed through several rules.
one might specify a constraint to create intermediate classes a command to capture communication betweenshards and a second might specify how sharded commands are executed.
all microtask commands must be handled by command subclasses.
ifa method is a static method on command then it should implement its behavior by constructing a new command subclass instance.
public abstract class functioncommand extends command public static functioncommand create ... return new create ... protected static class create extends functioncommand .. ... commands must implement execute .
ifa class is a subclass of command then it must implement execute.
public abstract class adtcommand extends command protected static class create extends adtcommand public void execute function funct string projectid ... ... design rules can be expressed through an if then structure.
this structure specifies when andhow it should apply.
this can be expressed through a quantifier describing when the rule applies andconstraints describing what must be true.
motivating examples we illustrate how rulepad enables developers to author design rules through three examples.
.
basic authoring alice is a developer working on a bank application1.
while implementing a feature she formulates a design rule about the responsibilities of classes in the controller package by expressing a constraint on the allowed public methods.
if a method is in a public class then it must be void or have a name which begins with get search orfind.
alice opens rulepad and reads a brief tutorial explaining each element of the interface and offering an example of how to write a simple design rule.
she writes a title and a description explaining the rationale assigns tags and specifies that the rule should apply only to files in the controller package figure .a c .
alice notices the dynamic guide figure .d which lists three steps with the first highlighted.
the first step instructs her to describe the code to matched in the graphical editor .
alice writes the if part of the rule public class specifying public in the dropdown figure .e .
the dynamic guide now indicates that the first step has been finished and highlights the second step.
the second step asks her to specify the constraints which matched code must satisfy by marking one or more of the elements as constraints.
she specifies that the function return type should be void.
realizing she needs to match function names which start with a prefix she writes get... search... find... to match identifiers which begin with get search or find.
she then checks the boxes to indicate that both the function return type and identifier should be treated as constraints.
387rulepad interactive authoring of checkable design rules esec fse november virtual event usa abcd e fg figure a developer using rulepad to create a new design rule may first specify a title and description a assign tags b and specify where the rule applies c .
using the graphical editor e the developer may then write code snippets in a structured editor interactively refining the rule to resolve ambiguity.
developers may verify the rule by f reading a description in the textual editor which they may also optionally edit.
while authoring rules developers may g view a list of code snippets which satisfy and violate the rule to check its behavior.
returning to the dynamic guide the third step suggests she consider editing the rule in the textual editor to change and to or if necessary.
she reads the generated text class with visibility public must have function with type void and name get... search... find... .
realizing this is not what she intended she edits and to or figure .f .
to check if the rule behaves as she expects alice inspects the list of matches and violations figure .g .
she sees that the rule is still not quite as she intended.
two additional method identifiers should be included login and make... .
she edits the method name pattern matching expression in the graphical editor .
glancing figure by default rulepad use the lowest common ancestor of constraint elements as the element of interest.
in this example there is a single constraint element get... .
rulepad selects the containing element a method as the element of interest indicated by a golden star.
figure clicking the golden star on the class updates the element of interest to the class.
this is reflected in the updated textual description and updated list of violations.
again at the updated list of matches and violations she finds that the rule now works as she intends.
.
advanced authoring working on another feature alice formulates a rule if a class is public then it must have at least one method whose name begins with get.
while creating the design rule she notices that the textual editor indicates that it is matching the methods inpublic classes rather than the public classes themselves.
the tool indicates that there are violations figure which should not be violations.
recalling the tutorial she realizes that she needs to set the class to be the element of interest.
she clicks on the star on the right side of the class element.
the text in the textual editor now indicates that public classes will be matched figure .
388esec fse november virtual event usa sahar mehrpour thomas d. latoza and hamed sarvari figure developers can write design rules using the textual editor .
autocomplete provides suggestions including documentation and examples of its use.
.
authoring design rules through the textual editor alice formulates a rule that if there is a field in a class then it must be private .
after seeing the representation of the past rules she has authored in the textual editor she decides to write the rule using the textual editor .
based on her prior experience she begins the design rule with the element of interest declaration statements .
as she types autocomplete provides suggestions figure .
alice reads the documentation of each suggestion and selects the next token by clicking on the suggestion.
techniques for authoring design rules developers traditionally document design rules in design documents such as by using example code snippets describing how to write code correctly or in prose describing constraints on how code should be written.
rulepad enables developers to author and work with design rules in these forms.
a key challenge in supporting authoring design rules is the inherent tradeoff between simplicity and expressiveness in representing rules.
we introduce snippet based authoring and semi natural language authoring as complimentary techniques for authoring checkable design rules.
representing the design rule in a representation close to what will be matched code enables a direct manipulation interaction where developers can rapidly write and edit what they wish to see matched and immediately see what is matched.
using the graphical editor developers can then begin to refine rules in increasingly complex ways using code snippets to express the essence of the rule and interactively refining it as necessary.
in more complex rules additional information is needed to resolve ambiguities.
the textual editor enables developers to understand how the code snippets they have added are composed to form a design rule as well as enabling more experienced developers more control.
our key goal was to keep the design of of rulepad simple enough that developers inexperienced with program analysis and query notations are able to rapidly author design rules while making it expressive enough to cover most of the design rules expressible in existing ast based rule checkers.
.
snippet based authoring enabling developers to author design rules using code snippets is a natural and appealing approach.
developers already know code and can simply write down what they wish to match.
however code snippets by themselves are often ambiguous.
consider mapper string mapper seems to be a name but for what?
and how is string related?
additional information is needed to determine what ast elements these code snippets should be matched against and how these elements are related.
using code snippets entered in a traditional text editor is not straightforward as the text is ambiguous.
to address this challenge we introduce rule authoring through code based templates.
the code based template enables developers to specify this information using a structured editing experience to select options and type text into boxes which correspond to specific ast elements that the developer wishes to match.
other additional information is sometimes needed.
elements may define a quantifier or constraints of design rules section describing either when the rule applies or what code must exist when it does apply.
design rules must also specify an element of interest eoi describing to which element it applies.
without specifying this the rule may be ambiguous.
for example while the design rules in figures and have identical partial code snippets they have different meanings.
the design rule in figure applies to functions indicating that all public functions must be getters.
the design rule in figure instead applies to classes indicating that all public classes must have getters.
to resolve this ambiguity developers can interactively indicate the element of interest in the interface.
.
semi natural language authoring developers often author design rules in text as it can contain explanations and other information about design rules.
however natural language text is difficult to use directly by tools particularly as it may be ambiguous.
traditionally rule checkers have met this challenge by introducing specialized query notations such as xpath queries.
however these notations are often unnatural with little resemblance to natural language.
this imposes a barrier to both rule authors and readers.
to understand rules written in these notations developers first need to know the syntax and meaning of the notation.
to author rules users must learn how to express the desired rule correctly in the notation.
in particular developers must learn how specific ast elements map into a corresponding representation in the query notation.
to make it easier for developers to work with design rules in textual form we created a semi natural language for design rules.
our goal was to create a language with easily understandable syntax and semantics simplifying the complexity of the underlying mapping to the complex notations used by analysis tools.
the language is translated into xpath queries by rulepad but masks the complexity of this notation from the developer.
design rules are expressed using an if then structure with a quantifier followed by a constraint.
in the design rule syntax this take the form of text which first describes the quantifier followed by must have and then text describing one or more constraints.
rather than use an if then syntax we chose to encode the if then structure using a must have syntax as it is more compact.
for example compare class with visibility private must have function 389rulepad interactive authoring of checkable design rules esec fse november virtual event usa table the semi natural language offers a more natural and compact representation of design rules.
the top row lists a design rule and its corresponding representation in the semi natural language second row and a traditional query language xpath bottom row .
model classes should have private fields and getters.
class must have declaration statement with visibility private and function with name get... compilationunit packagedeclaration name classorinterfacedeclaration count classorinterfacebody classorinterfacebodydeclaration fielddeclaration or count classorinterfacebody classorinterfacebodydeclaration methoddeclaration methoddeclarator with name get... and if class has visibility private then it must have function with name get... .
the must have syntax requires words and only one reference to class while in the if then syntax there are words and two