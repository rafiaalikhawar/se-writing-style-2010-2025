isrustused safelybyso f twaredevelopers?
ana noraevans ananevans virginia.edu universityof virginiabradford campbell bradjc virginia.edu universityof virginiamary lousoffa soffa virginia.edu universityof virginia abstract rust anemergingprogramminglanguagewithexplosivegrowth providesarobusttypesystemthatenablesprogrammerstowrite memory safeanddata racefreecode.toallowaccesstoamachine s hardwareandtosupportlow levelperformanceoptimizations a second language unsafe rust is embedded in rust.
it contains support for operations that are difficult to statically check such as c style pointers for access to arbitrary memory locations and mutable global variables.
when a program uses these features the compiler is unable to statically guarantee the safety properties rust promotes.
in this work we perform a large scale empirical study to explore how software developers are using unsafe rust in real world rust libraries and applications.
our results indicate that softwareengineersusethekeyword unsafeinlessthan30 ofrust libraries butmorethanhalfcannotbeentirelystaticallychecked by the rust compiler because of unsafe rust hidden somewhere inalibrary scallchain.weconcludethatalthoughtheuseofthe keyword unsafeis limited the propagation of unsafeness offers a challenge to the claim of rust as a memory safe language.
furthermore we recommend changes to the rust compiler and to the centralrustrepository sinterfacetohelprustsoftwaredevelopers be aware of when theirrust code is unsafe.
acmreference format ana nora evans bradford campbell and mary lou soffa.
.
is rust usedsafelybysoftwaredevelopers?.in 42ndinternationalconferenceon softwareengineering icse may23 seoul republicofkorea.
acm newyork ny usa pages.
introduction programming languages directly impact the reliability safety and correctnessofsoftware andtheirfeaturesimpacttheprevalenceof bugsinactualsoftware.arelativelynewprogramminglanguage rust is explicitly designed to help programmers write more reliable software by using the compiler to help reduce memory and data race errors.
rust is referred to as a safe systems programminglanguage indicatingthatitstypesystem ownershipmodel automaticmemorymanagementwithoutgarbagecollection and staticcompilermakeitwellsuitedforwritinglower levelorcore softwarewithoutthecommonbugsthatcanplaguecodewritten in c andc .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn ... .
design aspects that make rust safe such as no arbitrary pointers or arbitrary type casting however would also make writingmostoralllow levelcodeimpossible.operationssuchasconfiguring hardware or reading a network socket involve manipulating memory in ways that the compiler cannot guarantee to be safe.
therefore rust includes an escape hatch with the unsafekeyword1that allows programmers to deactivate some but not all of therustcompiler schecksforcertainregionsofcode.thisfunctionalitywasoriginallydescribedas pragmaticsafety whenrust was firstintroduced and allowsdevelopers to use their own discretion when writing rust code.
part of the justificationfor allowing unsaferust codeisthatusesof unsafewouldbeeasytolocateand audit andthatdeveloperscandecidehowmuchuncheckedcode they are willing to acceptin their software.
modern software development leverages and builds upon libraries whichoftenuseyetotherlibraries.auditingsoftwarefor usesofunsaferequires auditing alldependent libraries a potentially cumbersome task.
this overhead is mitigated however if usageofunsafeisscarceandeasytolocateintherustsoftware ecosystem orifmakingadeterminationaboutthevalidityofthe unsafeusage is typically straightforward.
therefore understanding how developers are actually using unsafeis necessary to evaluate whether pragmatic safety is valid and if rust provides a safe programming environment in practice.
our study is further motivated by recent interest in rust as a safealternativetocforsystemssoftware and by the development of formal definitions for rust s type system including unsafe rust .
for example the rust belt project proposes formal tools for verifying unsafe rust and oxide presents a formalization of a language very similar to rust.
the rust open source community recently formed a new rust working group to create a unsafe code guideline reference to help guide developers .theseareencouragingsteps andunderstanding howunsafe rust is being used by developers will help guide the successfulformationof thesestrategies.
toacquirethisunderstanding weperformalarge scalestudy and an analysis of publicly available rust libraries and application code.
we first determine how frequently the unsafekeyword is used.
then we analyze the call graph of every function in our data set to identify if at any point the function may use code that is not safe and not checked by the compiler.
this analysis enables us to find code that lookssafe but is actually unsafe rust .
to better understand how developers are using unsafe we also identify the underlyingcodebehaviorthatnecessitatestheuseof unsaferust toanalyzethefrequencyofthevarious unsafeoperations.further we observe the use of unsafe rust over time to see if there are evolving changes in the community.
1rustkeywordsaregreenandboldedwhilethesafeandunsafeconditionsareitalicized.
ieee acm 42nd international conference on software engineering icse icse may23 seoul republic of korea ana nora evans bradford campbell and marylou soffa to perform this analysis we developed and implemented an algorithmforconstructinganextendedcallgraphofrustfunctions that uses the type information to increase the call graph precision.
building a call graph for rust is difficult however as rust s runtimepolymorphismandhigherorderfunctionscomplicatestatically buildingacallgraphwithoutmissingedgesoraddingextraedges.in ourapproach weidentifytheseambiguities andbuildtwoversions ofthecallgraphbyapplyingbothaconservative assumethecall will be to unsafe code and an optimistic assume the call we be to code statically checked to be safe analysis to help bound the useofunsaferust inrustlibraries.wethentraverseandanalyze the resulting extended call graph to determine how unsafeness propagatesin real world rust code.
after analyzing over of the valid rust libraries available at the start of our study we find that contain at least one explicit use of unsafe.
when considering the dependency tree however that number increases to around meaning half of rust libraries use unsafe rust or rely on other libraries that use unsaferust .narrowingdowntojustthemostusedanddownloaded libraries increases the use of unsafe rust as around of popular crates include unsafe rust .
the majority of unsafeuses in the rust ecosystem are to call other rust functions that are marked unsafe.
we find that only of these unsafefunctions are to external libraries implemented in c suggesting that a majority oftheunsaferust isactuallyfromrustcodewherethesoftware developerdecidedtodisablethecompilerchecks.finally wesee negligible increases in the frequency of unsafeused over the past tenmonths.
basedonthesefindings weproposeseveralrecommendations to help realize the original vision of pragmatic safety in rust including programmer assisted automated checks additional tooling tohelpdevelopersidentifyusesof unsafe andmorevisiblecode reviews to audit uses of unsafe.
these changes would allow developers to better exploit the benefits of unsafe rust while managing its risksto overallsoftware reliability.
the contributionsof this paper are alarge scalestudyandanalysisof unsafeuseintherust software ecosystem.
a callgraph constructionalgorithm whichhandles generic polymorphism.
findings that indicate that a majority of crates are not guaranteed bythe compilerbe memory safeanddata race free.
highlightsofourfindingsindicatethatunsafefunctioncalls are the most common use of unsafeness which is caused through library dependencies rather than the use of the unsafekeyword andthemostdownloadedcrateshavemore unsafecode thanotherothercrates recommendations to enhance the rust compiler and its ecosystem to help developers understand when they are usingunsafe rust in their software.
section contains abrief introduction to rust unsafe rust see section .
the rust software ecosystem see section .
and the terms we define to facilitate discussion throughout of paper see section .
.
in section we present the research questions that guidedour experimentandthe selection criteriafor the rust code that comprises our data set.
section contains the approach toansweringtheresearch questions.in section5 wedefinethedata set we used in the experiments and the answers to the research questions based on the experimental results.
we conclude with our recommendations see section threats to validity see section relatedwork see section andconclusions see section .
background first weprovideaworkingexamplethatwillbereferencedthroughoutthepaper.wethendescribethekeyfeaturesof saferust and unsaferust thatarerelevanttoourstudy.next wedefineterms that we use to categorize rust code.
finally we provide some background information aboutthe generalrust software ecosystem.
.
workingexample figure a shows a set of functions in pseudocode from several librariesselectedtoillustratehowunsafetycanpropagateinacodebase.wewillusethesefunctionstoexplainconceptsthroughout the paper.
the functions are organized in five different libraries.
the starting point is function foo in library1 which calls the function bar in library2.
the symbol separates the library name from the function called from that library.
in function bar from library2 the call to my object.baz is a run time polymorphic calltothemethod baz ofaninstanceimplementingtheinterface hasbaz.theinterface hasbazhastwoimplementationsinlibrary3 andlibrary5.
figure1 b showstheresultinglibrarydependencygraphfrom the example functions.
a library depends on other libraries if it usesfunctionsfromthoselibraries andthereforerequirestheother libraries to completely compileabinary.
for functions with run time polymorphism we generate two callgraphs conservativeandoptimistic seefigure1 b .wewill explainthis further in section .
.
safe rust rustincludesafewbasicconceptsthatenablethecompilertoenforce safety guarantees.
the ownership mechanism in safe rust requiresthata uniquevariableistheownerforeverymemorylocation.
memory locations are immutable unless explicitly declared otherwise.
variable assignment results in a copy or a transfer of ownership andoncethevariablelosesownershipofthememory location that variable becomes unusable.
to enable sharing the borrowmechanismallowscreatingmemoryaliaseswhichpermit anynumberofread only referencesandexactlyonemutableone.
thefoo function infigure a shows an example borrow operation.together the ownership andborrowmechanismspreventa large class ofmemory safetyerrorsanddata races.
thedefinitionofmemory safetyusedbyrustissimilartothe oneproposedbyszekeres etal.
.arustprogramismemorysafe if it isfree of anymemoryerrors such as dereferencing a null or dangling pointer reading or writing unaligned pointers and reading uninitialized memory .
memory leaks are explicitly considered definedbehavior andthus not memory errors.
247is rustused safely by so f tware developers?
icse may23 seoul republic of korea fnfoo x myobject new x owns the object y x borrow occurs here ... library2 bar fnbar my obj implements hasbaz hasbaz my obj my obj.baz !
!
impl hasbaz fnbaz a !
impl hasbaz fnbaz unsafe my global qux !
unsafefnqux b my obj obj b return my obj !
.
.
!
.
.
!
.
a working examplefunctions.!
!
!
!
!
b library1 dependency graph.!
.
.
!
!
.
.
!
c foo extended call graph.
figure workingexample of rust functions inmultiple libraries that are either safe unsafe oronly appear safe.
for instances where program operation requires violating these constraints unsafe rust allows developers to assert to the compiler that they are manually implementing the necessary checks to preserve memory safetyanddata race freedom.
.
unsafe rust unsaferust providesthenecessaryoperationsforlow levelsystems programming such as arbitrary memory accesses with c style pointers invokingsystemcalls callingforeignfunctions usuallyc functions executinginlineassemblyinstructions elidingbounds checks for performance and accessing global static memory.
to use anyof these features developersmust mark the codewith the unsafekeyword.inlisting1 unsafeisnecessaryforcastingan address to a rust struct for memory mapped io and to use global variables to reference unique resources e.g.
com1port .
1implserialport 2pub unsafe fn new base usize quotesingle.varstatic mutserialport mut baseas mutself 7pub static com1 mutex serialport 8mutex new serialport new 0x3f8 9pub unsafe fn init 10com1.lock .init listing transmute withinan unsafe region the compiler stillchecksthe saferust types but the operations listed above are permitted as well.
unsafe rustdoes not grant the programmer complete freedom but subverting overall system safety is certainly possible.
programmers usingunsafe rust are responsible for writing code free of safety violationsandundefinedbehavior however whatconstitutesundefined behavior is currently not well specified and can change with different versions of the compiler.
this situation makes safely usingunsafe rust difficult.
.
sourcesof unsafe rust thereareseveralsourcesof unsaferust includingunsafeoperations unsafefunctions andunsafetraits.
.
.
unsafe operations adevelopermaydirectlyuse unsafe rustby creating a code block labeled with the keyword unsafe whichis requiredfor the following operations callingafunctionmarked unsafe non rustexternalfunction oracompilerintrinsic afunctionwhoseimplementationishandled speciallyby the compiler .
dereferencing ac stylepointer.
accessingamutable globalvariable.
using inline assembly instructions.
accessingafield of aunion type.
function baz in library5 contains an example of unsafe rust operation an assignment to a global variable my global enclosed in anunsafeblock.
an example of a possibly dangerous unsafefunction call is the mem transmute functionusedtocoercethecontentsofanarbitrarymemorylocationintoaspecificrusttype.thisisnecessary when raw data such as from a network socket but can easily violatetype safetyifusedimproperly.further the mem transmute function also makes use after free memory errors possible when it isusedtoextendthecompilercalculatedcodeboundswherethe variable islive.
1let mut hello string new 2lethello ref mutstring letr mutstring muthello 4unsafe mut r undefined behavior!
a second mutable reference 5hello.push str quotedbl.varhello quotedbl.var 6hello ref.push str quotedbl.varworld!
quotedbl.var 7println!
quotedbl.var ?
quotedbl.var hello listing multiple mutablereferences usingunsafealso makes mutable reference aliasing possible leadingtoundefinedbehavior.intherustlisting2 usingsimplified rust syntax two mutable