crfuzz fuzzing multi purpose programs through input validation suhwan song seoul national university sshkeb96 snu.ac.krchengyu song uc riverside csong cs.ucr.edu yeongjin jang oregon state university yeongjin.jang oregonstate.edubyoungyoung lee seoul national university byoungyoung snu.ac.kr abstract fuzz testing has been proved its effectiveness in discovering software vulnerabilities.
empowered its randomness nature along with a coverage guiding feature fuzzing has been identified a vast number of vulnerabilities in real world programs.
this paper begins with an observation that the design of the current state of the art fuzzers is not well suited for a particular but yet important set of software programs.
specifically current fuzzers have limitations in fuzzing programs serving multiple purposes where each purpose is controlled by extra options.
this paper proposes crfuzz which overcomes this limitation.
crfuzz designs a clustering analysis to automatically predict if a newly given input would be accepted or not by a target program.
exploiting this prediction capability crfuzz is designed to efficiently explore the programs with multiple purposes.
we employed crfuzz for three state of the art fuzzers afl qsym and mopt andcrfuzz augmented versions have shown .
and .
better path and edge coverage on average.
more importantly during two weeks of long running experiments crfuzz discovered previously unknown vulnerabilities where of those are already confirmed and fixed by the respected vendors.
we would like to emphasize that many of these vulnerabilities were discoverd from ffmpeg imagemagick and graphicsmagick all of which are targets of google s oss fuzz project and thus heavily fuzzed for last three years by far.
nevertheless crfuzz identified a remarkable number of vulnerabilities demonstrating its effectiveness of vulnerability finding capability.
ccs concepts security and privacy software security engineering .
keywords fuzz testing coverage guided fuzzing corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
reference format suhwan song chengyu song yeongjin jang and byoungyoung lee.
.
crfuzz fuzzing multi purpose programs through input validation.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
introduction the fuzz testing is a popular technique to discover software vulnerabilities.
it keeps generating a random input and testing a target program if the program exhibits a violation behavior such as memory access violation or triggering safety assertions.
one notable feature that most state of the art fuzzers are employing today is a coverage guided fuzzing feature.
under the assumption that more testing coverage would yield better vulnerability detection capability this feature keeps tracking of execution coverage at runtime and provides coverage feedback to guide the fuzzing procedure e.g.
guiding how the fuzzer generates mutates or selects an input .
indeed fuzz testing has been proved its effectiveness in discovering vulnerabilities in a vast number of real world software .
this research started with a research question whether current state of the art fuzzers are well designed for all different set of target programs.
in particular we observe that current fuzzers are not suited to fuzz programs taking various command line options which we call multi purpose programs.
multi purpose programs serve multiple operational behaviors e.g.
in the case of ffmpeg it supports encoding decoding with a large number of codecs as well as many different filtering features and the command line option is used to specify which operational behavior would be activated at runtime.
since current fuzzers are not designed to cater this command line option it is challenging to efficiently explore various operational behaviors while switching the command line options.
this limitation stems from the fact that current fuzzers are designed to handle a single dimensional input space which is often a file input .
as such since command line options introduce an additional input space the coverage guided features of current fuzzers are not tailored to fuzz with such multi dimensional input space.
in this paper we propose crfuzz a fuzzing technique to specifically designed to fuzz multi purpose programs.
the key component ofcrfuzz is a validity checker which utilizes a machine learning technique particularly a clustering analysis.
the validity checker faithfully predicts if a newly provided input is a valid input i.e.
anesec fse november virtual event usa suhwan song chengyu song yeongjin jang and byoungyoung lee file input corpusfile input queuemutation engineexecution enginetarget binarycommand optionsave input if new coverage figure the workflow of general coverage guided fuzzers file input corpuscmd selector file input queuemutation engineexecution enginetarget binary execute all command options per one file input mutationcommand option1 command option2 command option3save input if new coverage figure the workflow of naive multi purpose program fuzzer input supposed to be accepted by a target program or an invalid input i.e.
an input rejected by the target program .
observing that the coverage feedback used by current fuzzers is not suited for the validity checker crfuzz designs new coverage feedback metric a validity pair which efficiently captures the differences between valid input execution and invalid input execution.
leveraging this validity checker crfuzz develops a multi purpose program fuzzer which efficiently explores many different operational behaviors.
to clearly show its effectiveness we applied crfuzz for three popular state of the art fuzzers afl qsym and mopt.
accordingly to our evaluation crfuzz has shown .
and .
better path coverage and edge coverage respectively.
more importantly crfuzz has shown outstanding performances in discovering new vulnerabilities.
crfuzz discovered new vulnerabilities from popular programs including ffmpeg libtiff ghostscript libsixel xfig mupdf imagemagick graphicsmagick where of those are already been patched by the respected open source community.
background and motivation in this section we first provide necessary background of this paper .
particularly related to coverage guided fuzzing and multipurpose programs.
then we describe the motivation behind this paper how to efficiently fuzz multi purpose programs .
.
.
background coverage guided fuzzing.
a coverage guided fuzzing technique is arguably the most popular fuzzing technique to find vulnerabilities.
similar to traditional fuzzers it keeps generating or mutating an input to execute a target program in hopes that such an input may trigger a corner case of program s logic.
the key insight behind the coverage guided fuzzing is that it keeps tracking the execution coverage of each input s execution and leverages the coverage tomutate the input to be fuzzed next.
in other words its fuzzing process is designed to favor the input which exhibits a new coverage such that the fuzzer can explore deep inside of program s logic.
in general coverage guided fuzzers work in following steps depicted in figure .
first it inserts the initial inputs so called seeds to the file input queue step .
then it picks one input from the file input queue step .
after that the fuzzer mutates the selected input with pre determined mutation methods e.g.
a bit flip performing arithmetic operations replacing with specific integer values or splicing step .
then the fuzzer runs a target program with this mutated input step while i checking if it triggers exception and ii keeping track of the execution coverage.
if the mutated input visits the new coverage that that input is inserted to the file input queue step a .
otherwise the mutated input will be dropped and ignored step b .
then the fuzzer repeat this fuzzing process by returning back to step .
parser backend output file input terminate terminate a single purpose program backend backend backend 3parser output file input command line option terminate terminate b multi purpose program figure a general program logic of single purpose programs and multi purpose programs.
multi purpose programs.
in this paper as described in figure we categorize the programs into two types single purpose programs and multi purpose programs depending on whether a program takes command line options or not to control its multiple operational behaviors.
in other words whereas the single purpose program simply takes a file input and does not take a command line option the multi purpose program takes both file input and command line options.
more specifically the multi purpose program first attempts to parse the file input.
if the given input file is invalid the program would be terminated as it is early rejected by the parser.
if valid the program moves on to the processing stage performing one of backend operations as instructed by the command line option.
we note that there are many multi purpose programs as developers ship many different features within a single program binary.
the representative example of multi purpose programs would be ffmpeg which is a popular video and audio converter and used as a library by a vast number of video audio tools.
since ffmpeg provides many different features where each feature is being served by an individual backend engine from encoding decoding engines crfuzz fuzzing multi purpose programs through input validation esec fse november virtual event usa file inputv i v v i i i v v i v icommand line optiontotal executions 1v valid file input i invalid file input crfuzz execution early rejected execution naive execution 2mutate file input change command line figure input space of multi purpose program dedicated backend engines for various video audio to various filters to be applied .
another example would be imagemagick a popular image editor.
it takes more than different command line options to control its behavior such as converting gif to png format which activates various backend operations.
.
motivation inefficient to fuzz multi purpose programs.
we observe that all currently known fuzzers including afl qsym mopt etc.
are not suitable to fuzz multi purpose programs mainly due to the fact it does not cater command line options.
more specifically current fuzzers are designed to fuzz single purpose programs which simply simply fixes a specific command line option when running a target program.
hence current fuzzers cannot explore various features provided by backends critically limiting its testing capability.
one may attempt to redesign the current fuzzers by enumerating all available command line options but this redesign alone is not sufficient.
in order to clearly demonstrate this limitation we introduce a naive multi purpose fuzzer which exhaustively enumerates all available command line options and thus would be a naive extension of current fuzzers.
a naive multi purpose program fuzzer.
the key component of a naive multi purpose program fuzzer is an operation input selector as shown in figure .
using this selector this fuzzer ensures to fuzz all available command line options for each mutated input file.
in other words for each mutated input file it keeps executing a target program for all available command line options.
however we found that such an enumeration over all command line options is inefficient.
the problem is that if the mutated file input is invalid and thus early rejected by the parser it is meant to be failed for all command line options.
however since this naive multi purpose program fuzzer is not aware of such early rejection by the parser it simply runs the target program with all command line options all of which do not result in any benefit in terms of increasing the testing coverage.
we also observe that using a single command option shows limited execution coverage compared to using various command options.
to clearly understand this we have measured the edge coverage while providing a different number of command options figure .
as shown in the figure the edge coverage is increased as more command options are provide.
in particular comparing the edge coverage between a single command option and command edge coverage imagemagick xfig mupdf1 cmd option cmd options cmd options cmd options cmd optionsfigure measuring the edge coverage while changing the number of specified command options options imagemagick fig2dev and mupdf show and more edge coverage respectively.
our approach.
in order to efficiently fuzz multi purpose programs our key idea behind crfuzz is that we leverage a machine learning technique to notice if an execution is terminated due to the early rejection by the parser or not.
specifically crfuzz aims at distinguishing following two cases i when the execution is early terminated by the parser i.e.
the provided file input to the target program is invalid and ii when the execution is proceeded to one of backend engines i.e.
the provided file input is valid .
to this end crfuzz captures statistical differences in terms of execution coverage because aforementioned two cases must have different patterns in terms of execution coverage i.e.
a invalid file input case should not cover any of backend engines while a valid file input case should cover one of backend engines.
design now we describe the design of crfuzz an efficient multi purpose program fuzzer figure .
the core component of crfuzz is its validity checker .
which performs a clustering analysis to determine if a given input is valid or not.
crfuzz first converts an execution feedback of an input into validity pair a custom defined metric to efficiently measure input validity which is then used for training the validity model.
crfuzz leverages this validity checker while performing the fuzzing both file inputs and command line options .
.
instead of enumerating all available command line options crfuzz first checks if a provided input file is invalid through the validity checker by executing the input file with one command line option.
then crfuzz only attempts to enumerate other command line options only if the input file is valid.
.
learning and testing validity the goal of the validity checker is to check if a given execution feedback of an input is valid i.e.
the input is accepted by the parser of a target program or invalid i.e.
the input is rejected by the parser .
in order to check the validity we leverage data mining or machine learning approaches.
more specifically we employ aesec fse november virtual event usa suhwan song chengyu song yeongjin jang and byoungyoung lee file input corpuscmd selector file input queuemutation engineexecution enginetarget binarycheck validity of file input command option1 command option2 command option3save input if new coveragevalidity checkerif invalid skip other command options figure the overall workflow of crfuzz an efficient multipurpose program fuzzer given input c2 5validity pair file input c cvalidc c c invalid cvalidcinvalid figure an example snapshot of showing how the validity pair is computed conversion invalid dissimilarityvalid similarity conversion invalid dissimilarityvalid similaritytwo dimension high dimensionality v1v2 clusteringdecision boundarybranch coverage b1 b2 bn.
..valid input branch coverage b1 b2 bn.
..invalid inputbranch coverage b1 b2 bn.
..valid inputsreference input set branch coverage b1 b2 bn.
..invalid inputs parsing error processing phaseparsing phase valid cluster invalid cluster figure overview of validity checker cluster analysis i.e.
a unsupervised learning such that each input can be grouped into either valid or invalid.
it is worth noting that supervised learning is not a suitable approach for the validity checking.
this is largely due to the fact that it is difficult to obtain a large number of labeled data i.e.
a set of inputs labeled as valid or invalid .
to obtain a labeled data one would need perform a sophisticated program analysis on the parser of a target program.
however this would be challenging since the validity checking logic is hard coded within the parser and understanding such a hard coded logic requires non trivial reverse engineering efforts.
.
.
validity feature selection.
coverage as a cluster feature.
in performing statistical data analysis one important thing is to select a good feature vector for the analysis.
particularly focusing on the clustering problem that crfuzz attempts to solve a desired feature vector would clearly distinguish two clusters valid and invalid i.e.
maximizing the distance between valid and invalid clusters .
in this regard coverage information of a corresponding input which is provided as an execution feedback may seem to be a good feature selection for crfuzz .
first the coverage information is easy to obtain as most fuzzers today are coverage guided fuzzers which always produce the coverage information per execution.
second the coverage information would have clear differences depending on whether target program s parser accepts i.e.
valid or rejects i.e.
invalid .
this is because accept reject logic in the parser should follow a different code path so the input should result in clearly different coverage information if accepted rejected.
limitation coverage as a cluster feature.
however we found that using a coverage information as it is has critical limitation particularly with respect to clustering performance.
this is due to the fact that using a coverage as a feature vector results in an extremely high dimension space a well known challenge in clustering.
in other words if the input feature has high dimension the time complexity for clustering increases exponentially.
specifically if using the coverage the number of dimension would be either the number of basic blocks in the case of codecoverage guided fuzzers or the number of edges in the case of path coverage guided fuzzers and typical programs have very high number of basic blocks and edges.
for instance ffmpeg has 50k and 130k different basic blocks and edges which is far beyond the number of dimensions that crfuzz can handle.
our solution validity pair as a cluster feature.
crfuzz defines a new metric a validity pair in order to overcome the limitation of simply using the coverage.
the insight behind the validity pair is in using two reference coverages which well represents valid invalid input s coverage respectively thereby identifying important dimensions for validity clustering.
more precisely the validity pair is defined as two scalar values v1 v2 where v1 c c cinvalid and v2 c cvalid.
here crepresents the coverage of a given input and cvalid and cinvalid represent the reference coverage of a valid input and an invalid input respectively.
in other words v1is designed to capture the coverage dissimilarity between the given input and the reference invalid input and v2is to capture the coverage similarity between the given input and the reference valid input the example is described in figure .
this validity pair is a performance efficient metric for crfuzz .
compared to naively using the coverage metric as it is the validity pair only has two dimensions.
furthermore it still captures the valid invalid characteristics of a given input.
this is because if two scalar values of a validity pair is higher it implicates that the given input is more likely to be similar to a valid input.crfuzz fuzzing multi purpose programs through input validation esec fse november virtual event usa .
.
learning validity cluster.
crfuzz learns the validity clustering model using the aforementioned validity pair as the base metric.
specifically crfuzz performs k means clustering where kis two to represent valid and invalid clusters in following steps each step is described in figure .
preparing reference inputs.
crfuzz prepares the reference coverage of a valid input i.e.
cvalid by manually collecting a reference valid input and then obtaining the execution coverage of it.
the reference valid input in crfuzz implies a well known good input that is accepted by target program s parser.
most programs provide a sample working input which demonstrates its basic features i.e.
a sample video audio file for ffmpeg and a sample pdf file for mupdf andcrfuzz leverages such a sample working input.
we note that it is not necessary for crfuzz to have these sample inputs completely represent a valid behavior of the target program.
instead it is sufficient for crfuzz to have sample inputs not to be early rejected by the parsing logic such that crfuzz can distinguish whether a certain input would be early rejected or not.
in addition crfuzz prepares a reference invalid input by generating a completely random input i.e.
the value of each input byte as well as the size of the input is randomly determined.
since this input is randomly generated it is very unlikely to be accepted by the target program s parser.
as such its execution coverage i.e.
cinvalid would be well representing target program s early rejection behavior.
clustering using validity pairs.
for each new input i.e.
an input that is either generated or mutated for fuzzing crfuzz computes a validity pair i.e.
v1andv2 based on the reference coverage of valid and invalid inputs i.e.
cvalid andcinvalid .
then the validity pair of each input is projected into a point in two dimensional euclidean space so as to compare euclidean distance between inputs.
in other words x axis is represented with v1 i.e.
the coverage dissimilarity from the reference invalid input and y axis is represented with v2 i.e.
the coverage similarity from the reference valid input .
after that crfuzz performs a generic k means clustering method.
first crfuzz randomly selects two points at random where each point represents each input as initial centroids of two clusters.
then all other points are assigned to their closest centroid where its distance measure is using the squared point to point euclidean distance step .
then it re computes two centroids by computing the average of all of each cluster s points step .
after updating all centroids it re assigns all points to their closest updated centroid and then re updates each centroids again.
the aforementioned step and step are repeated until meeting one of two termination conditions.
the first termination condition is that the sum of square euclidean distances reaches to the minimum value.
more specifically the objective function to be minimized is defined as l where x is a data point s0ands1are invalid and valid clusters respectively andciis centroid of si.
l argmin sk i 1 xj si xj ci crfuzz computes sum of the squared euclidean distances between point and centroid of its cluster.
then crfuzz repeats aforementioned process until this object function is minimized.
the secondtermination condition is that the number of iteration reaches to the pre defined maximum number.
in our experiment we used as the maximum number.
once the k means clustering analysis is terminated crfuzz obtains two centroids.
the centroid on the right top side represents the centroid of a valid cluster and the other centroid on the leftbottom side represents the centroid of an invalid cluster.
this is because as an input point is more close to the right top side it is more likely indicating following two things i it is more dissimilar from the reference invalid input i.e.
v1is bigger than others and ii it is more similar to the reference valid input i.e.
v2is bigger than others .
incremental clustering.
crfuzz supports an incremental clustering in consideration of the inherent characteristic of fuzzing procedure.
more specifically fuzzers keep generating new inputs for testing and such a new input can be kept being provided to crfuzz which can improve the accuracy of crfuzz s cluster analysis.
however a downside of such an incremental clustering is runtime performance.
if crfuzz keeps computing mean square error until it reaches the stable centroids every time a new input is generated it would significantly slow down the runtime performance of crfuzz .
therefore crfuzz attempts to strike a balance between cluster analysis accuracy and its runtime performances through dynamically adjusting the frequency of an incremental clustering analysis.
the key insight behind this is that inputs provided during the initial phase are impacting the accuracy far more than the inputs provided during the later phase.
thus crfuzz gradually decreases the frequency of the incremental analysis i.e.
decreasing the frequency as a factor of two whenever the number of provided inputs are doubled.
for instance if the number of provided inputs is less than crfuzz performs incremental clustering every time a new input arrives.
if the number of provided inputs is between 28and crfuzz performs incremental clustering when every two new inputs arrive.
.
.
testing validity.
crfuzz utilizes aforementioned a validity model to check if a new input is valid or invalid.
to be specific it first computes a validity pair of a new input and computes euclidean distances from valid and invalid centroids respectively.
then it is determined to be either valid or invalid if it is more close to valid or invalid centroids respectively.
.
multi purpose program fuzzing crfuzz utilizes validity checker to address the limitation of naive multi purpose program fuzzers.
in particular it executes all command options only if the provided file input is predicted to be a valid file input.
if not crfuzz stops fuzzing other command options which allows crfuzz to significantly save the fuzzing time.
to better illustrate this figure depicts the high level comparison between naive multi purpose program fuzzing and crfuzz s multi purpose program fuzzing particularly highlighting how crfuzz can efficiently handle various command options.
in this figure each file input is fuzzed with all different command options represented as1in y axis .
after enumerating all command options the fuzzer generates or mutates another file input is fuzzed represented as 2in x axis .
in the case of the naive multi purpose program fuzzer esec fse november virtual event usa suhwan song chengyu song yeongjin jang and byoungyoung lee it would execute all combinations i.e.
all boxes in the figure as it cannot notice if a provided input is valid or not.
on the contrary crfuzz s multi purpose program fuzzer can predict if a provided input is valid or not using the validity checker so it does not need to fuzz other command options if the provided input file is predicted to be invalid.
as a result crfuzz s fuzzer only needs to execute the gray boxes which is significantly less than all the boxes that the naive fuzzer should fuzz.
algorithm algorithm of crfuzz s multi purpose program fuzzing loop qf qc cinvalid cvalid load qfandqcwith the provided valid file input s and cmd options respectively compute cinvalid andcvalid while truedo f dequeue qf f mutate f forcinqcdo execute program with f andc compute v1 v2 off iffind new coverage then qf enqueue f iffindnnew inputs then perform incremental clustering ifcis first cmd option then validitychecker v1 v2 iff is invalid then break more specifically we designed crfuzz to skip over unnecessary command options if the provided input is predicted to be invalid the detailed algorithm is described in algorithm .
implementation we implemented crfuzz and applied it for three different stateof the art fuzzers afl qsym and mopt.
since all these fuzzers are not designed to support multi purpose program fuzzing we first implemented a naive multi purpose program fuzzer of these as follows.
in the case of afl and mopt we first modified the fork server of afl and mopt as its fork server routine is hardcoded for a single command line option.
hence we extended such a routine to support multiple command line options.
then for each mutated file input that afl and mopt are generating we ensured that all command line options are executed in order.
in the case of qsym we replaced two original afl instances of qsym into two aforementioned native multi purpose afl fuzzer instances the original qsym runs three instances in parallel two afl instances and a single concolic execution instance.
we applied crfuzz to these naive multi purpose program fuzzers which we call afl crfuzz for afl qsym crfuzz for qsym and mopt crfuzz for mopt respectively.
to be more specific for each fuzzer we first implemented the validity checker as described in .
which converts the coverage feedback into the validity pair and performs the k means clustering.
then we first run the mutated file with one command line option then check the input validity of antable fuzzer settings for evaluation fuzzerssetup instances description afl afl master and afl slaves afl crfuzz afl crfuzz master and afl crfuzz slaves qsym concolic executor afl master and slave each using docker qsym crfuzz concolic executor afl crfuzz master and slave each using docker mopt mopt master and mopt slaves option l mopt crfuzz mopt crfuzz master and mopt crfuzz slaves option l execution through the validity checker.
if predicted to be an invalid input crfuzz augmented fuzzers stop fuzzing other command line options but proceeding to fuzz another mutated file.
evaluation experimental setup.
in this evaluation we performed an experiment with crfuzz augmented fuzzers afl crfuzz qsym crfuzz and mopt crfuzz where its fuzzing instance configuration is listed in table .
under this configuration we ran nine multipurpose programs graphicsmagick mupdf xpdf imagemagick xfig libsixel libtiff ffmpeg ghostscript for cpu hours and then repeated the experiment for five times.
all our experiments were carried out a machine of intel xeon gold with cpu cores and 512gb ram which runs ubuntu .
lts.
research questions.
in the following of this evaluation section we aim to answer following research questions rq1.
what is the accuracy of crfuzz s clustering analysis in its validity checker?
rq2.
does crfuzz s fuzzing approach truly improve the multipurpose program fuzzing capability particularly with respect to path and edge coverage?
rq3.
what are the new vulnerabilities that are discovered by crfuzz ?
.
accuracy of validity checker rq1 as described in .
crfuzz leverages validity checking capability for fuzzing.
since the validity checker performs the clustering analysis crfuzz s overall fuzzing performance relies on the accuracy of the clustering analysis.
as such this subsection analyzes such accuracy of crfuzz s validity checker.
in order to collect the ground truth i.e.
a set of files labeled as either a valid or invalid file we manually analyzed the source code of following three target programs including ffmpeg libtiff and ghostscript .
then we identified the termination routine due to both parsing issues and non parsing issues.
we instrumented such termination routine such that we can mark a label suggesting which input file is valid or not.
given these labeled files we first plotted all data points figure for each program.
when plotting we projected each data point according to the validity pair distance metric as described in .
.
.
in these figures each red cross mark denotes an invalid input and each blue circle denotes a valid file.
it can be observed that overall red crosses are located closed to the bottom left corner while blue circles are located closed to the top right corner.
this overall location pattern implies that the validity pair is an effective metric capturing the execution differences between valid and invalid files.crfuzz fuzzing multi purpose programs through input validation esec fse november virtual event usa table accuracy of validity checker program description versionactual total exec inferred total exec rfp rfninvalid valid invalid fn valid fp ffmpeg mp4 to mov .
.36m 203k .36m .96k 203k .10k .
.
libtiff tiff to ps .
.
.3m .82m .7m .4k .36m 610k .
.
ghostscript ps to pgm .51rc1 181k .9k 181k .1k .
.
we acknowledge that the each plot shows some overlaps i.e.
it may not seem straight forward to draw a decision boundary bisecting two labels but we would like to emphasize the number of those overlapped data points are relatively small compared to the number of entire data points which we further evaluate next.
in order to clearly evaluate the clustering accuracy we measured the false positive and false negatives of crfuzz sk means clustering.
more precisely we measured false positives rfp and false negatives rfn as follows.
rfp nfp ni 100and rfn nfn nv .
in these two measures nfpandnfndenote the number of false positive and false negative in total executions.
niandnvdenote the total number of executions with invalid and valid files respectively.
the result of false positives and false negatives are shown in table .
overall rfpis always less than .
it is worth noting that if the false positive occurs i.e.
an invalid file is predicted to be valid crfuzz would not leverage the performance optimization of crfuzz as it would enumerate all command line options without much coverage benefits.
on the other hand rfnis measured in the range from .
to .
if the false negative happens i.e.
a valid file is predicted to be invalid crfuzz would stop trying more command line options although it would be more likely beneficial to try more options with respect to extend the execution coverage.
given these results on rfpandrfn although crfuzz s clustering analysis does not yield perfect accuracy we believe its result is good enough to significantly augment the fuzzing capability for multi purpose programs which we demonstrate in the next subsection.
runtime speed of clustering analysis.
over the entire hours of fuzzing time the validity checker used eight minutes on average i.e.
three minutes for clustering and five minutes for predicting the validity which only account for .
of entire fuzzing time.
based on this result we believe that the dimension reduction with the validity pair along with incremental learning features is efficient enough to fuzz multi purpose programs.
.
fuzzing efficiency of crfuzz rq2 naive vs. crfuzz augmented frruzzers.
compared to a naive multi purpose program fuzzer crfuzz leverages the feedback from the validity checker to accelerate the fuzzing performances.
in particular we implemented both naive and crfuzz versions for three fuzzers afl qsym and mopt described in .
using these fuzzers we ran nine multi purpose programs for cpu hours repeated five times .
then we compared its average performance with respect to path coverage and edge coverage as shown in table and table respectively.
according to the result afl crfuzz qsym crfuzz and mopt crfuzz achieved better path and edge a ffmpeg b libtiff c ghostscript figure plotted results of input files according to the validity pair distance metric i.e.
x axis represents v1and y axis represents v2 .
each red cross represents an invalid file and each blue dot represents a valid file.
coverage for all nine multi purpose programs than the naive version.
on average crfuzz showed .
better path coverage and .
better edge coverage to that of the naive multi purpose fuzzer demonstrating crfuzz s efficiency in exploring more testing coverage for multi purpose programs.
efficiency while varying command line options.
in order to understand the fuzzing efficiency over the number of command line options we varied the number of command line options and compared the fuzzing performance between the naive and crfuzz augmented versions figure .
for both version of fuzzers as more command line options are provided its path and edge coverage are extended as it enables to explore more features in the backend engines.
however it is noticeable that crfuzz augmented versions are always show better performance and such performance advantage gap is increased more as more command line options are given i.e.
the gap between three and six command options .
this is because as more command line options are given the search space for command line options are doubled.
hence naive multipurpose fuzzers would waste more of its fuzzing time on invalid files with more command line options while crfuzz augmented multi purpose fuzzers can save its fuzzing time by quickly dropping such invalid files with the help from the validity checker.
.
new vulnerabilities found by crfuzz rq3 over the course of evaluating crfuzz we kept running crfuzz augmented fuzzers for two weeks against nine multi purpose programs to find new vulnerabilities.
to summarize crfuzz found new vulnerabilities in total where of those are already confirmed and accordingly fixed by the respective vendors as shown in table .
we highlight that many target programs particularly graphicsmagick mupdf imagemagick libtiff ffmpeg and ghostscript are fuzzed by many security researchers due to its popularity andesec fse november virtual event usa suhwan song chengyu song yeongjin jang and byoungyoung lee table path coverage found in multi purpose programs using three command line options w o and w crfuzz in cpu hours programpath coverage afl qsym mopt orig.
crfuzz orig.
crfuzz orig.
crfuzz ffmpeg .
.
.
graphicsmagick .
.
.
mupdf .
.
.
xpdf .
.
.
imagemagick .
.
.
xfig .
.
.
libsixel .
.
.
libtiff .
.
.
ghostscript .
.
average .
.
.
table edge coverage found in multi purpose programs using three command line options w o and w crfuzz in cpu hours programedge coverage afl qsym mopt orig.
crfuzz orig.
crfuzz orig.
crfuzz ffmpeg .
.
.
graphicsmagick .
.
.
mupdf .
.
.
xpdf .
.
.
imagemagick .
.
.
xfig .
.
.
libsixel .
.
.
libtiff .
.
.
ghostscript .
.
average .
.
.
thus those are fuzzed for numerous cpu hours by far.
more importantly all of those except ghostscript are selected by google s oss fuzz project and heavily fuzzed for last three years.
however in spite of such heavy fuzzing efforts towards these programs crfuzz discovered a striking number of new vulnerabilities demonstrating significantly better fuzzing capability of crfuzz .
in the case of graphicsmagick it takes bmp image files as input and convert it to other formatted files such as vector image files like pdf which identified new vulnerabilities.
for mutool we found seven vulnerabilities when it resizes the pdf images.
imagemagick provides over command line options and crfuzz identified vulnerabilities.
xfig takes figfiles as input and converts it to different formats.
crfuzz identified vulnerabilities all of which found in backend engines.
libsixel converts png files into sixel files and we identified multiple bugs from the command which converts image colors.
libtiff takes tiff files as input and convert it to various levels of psfiles the default configuration is set to be level and crfuzz identified the vulnerability which is only activated when the level is .
ffmpeg is a popular video image decoder which provides over different command line options.crfuzz identified different vulnerabilities most of which are identified from its backend engine.
related work advanced fuzz scheduling.
aflfast and fair fuzz change seed scheduling algorithm to prioritize rarely exercised branches for higher coverage.
mopt uses a customized particle swarm optimization pso algorithm to optimize the mutation operation scheduler.
cerebro utilizes various factors such as code complexity coverage and execution time to improve seed scheduling strategy.
aflgo and hawkeye leverage seed scheduling to guide the fuzzer towards target locations of program based on distance metrics.
solving hard constraints.
to overcome the limitation of solving hard constraints such as magic bytes various approaches have been suggested.
for example steelix and laf intel split magic bytes to make them as weak constraint with extra implemetation.
vuzzer angora and matryoshka use taint analysis to help the fuzzer solve constraints through control and data flow information.
redqueen utilizes program state analysis to solve magic bytes and checksum without taint or symbolic execution.crfuzz fuzzing multi purpose programs through input validation esec fse november virtual event usa table newly discovered vulnerabilities by crfuzz program version vulnerability type found fixed ffmpegstack buffer overflow heap buffer overflow heap use after free memory leak assertion invalid free segmentation fault .
division by zero .
signed integer overflow outside the range of representable out of bound left shift of negative value left shift cannot be represented in type int null pointer passed as argument load of null pointer pointer index expression overflowed ghostscript .51rc1global buffer overflow stack buffer overflow heap buffer overflow heap use after free memory leak segmentation fault division by zero libtiff .
.
heap buffer overflow libsixel1.
.
heap buffer overflow .
.
memory leak xfig .
.7bglobal buffer overflow stack buffer overflow heap buffer overflow segmentation fault mupdf .
.0heap buffer overflow heap use after free assertion imagemagickheap buffer overflow heap use after free memory leak .
.
division by zero .
.
signed integer overflow outside the range of representable shift exponent is too large unsigned offset overflowed graphicsmagick .
.34heap buffer overflow assertion total t fuzz removes sanitiy checks in the programs to bypass the hard constraints.
hybrid fuzzers leverage a concolic executor to solve the hard constraints.
for example qsym and intriguer optimize symbolic emulation for a fast concolic executor.
savior guides the concolic executor towards the bug in the program.esec fse november virtual event usa suhwan song chengyu song yeongjin jang and byoungyoung lee a afl b qsym c mopt figure path and edge coverage test using three and six command line options.
the x axis reprents the hour and yaxis represent the coverage the y axis of top graphs represents the path coverage and y axis of bottom graphs represents the edge coverage.
input aware fuzzing.
profuzzer infers the input type of each byte to enhance the mutation efficiency by probing changes of program behaviors edge coverage change .
by so it improves the mutation strategy to generate semantically valid input to find deep bugs.
recent studies guide the fuzzer to generatehighly structured inputs by using coverage feedback.
for example nautilus leverages grammar specification to better generate and mutate the test inputs with coverage guidance.
in constrast grimoire leverages coverage feedback to synthesize highly structured inputs without any form of human interaction.
improving fitness function.
collafl and instrim enhance the way of coverage instrumentation to achieve more accurate and lightweight coverage information.
tortoisefuzz and ankou propose new coverage evaluation techinques for better seed scheduling.
some studies have focused on detecting algorithmic complexity vulnerabilities based on new coverage metrics such as resource usage or execution path length.
learning based fuzzing.
recent studies use learning techniques to help the fuzzers to increase the coverage and find bugs.
learn fuzz uses rnn recurrent neural network to generate valid highlystructured inputs.
skyfire learns a probabilistic contextsensitive grammar pcsg from highly structured inputs to generate well distributed seeds.
angora uses taint analysis and gradient descent to solve the hard constraints.
in this approach the taint analysis tells the position of magic bytes to the fuzzer and then gradient descent shows how to mutate that position of bytes to solve the constraint.
neuzz uses deep learning to synthesize the program behaviors to improve the coverage.
fuzzguard which is used in directed guided fuzzing uses deep learning to filter out unreachable input without executing it.
conclusion this paper proposed crfuzz an efficient multi purpose program fuzzer.
it implements a clustering analysis to predict if a new input file would be accepted by a target program or not.
utilizing this clustering analysis it redesigns current state of the art fuzzers including afl qsym and mopt to efficiently fuzz multi purpose program.
according to the evaluation crfuzz augmented fuzzers have shown reasonable better coverage as well as uncovering new vulnerabilities in various software programs.
acknowledgment we thank anonymous reviewers for their insightful comments which significantly improved the final version of this paper.
this work was partially supported by agency for defense development add in south korea no.
ue191003ed and by the national research foundation nrf of south korea grant funded by the korean government msit no.
2019r1c1c1006095 .