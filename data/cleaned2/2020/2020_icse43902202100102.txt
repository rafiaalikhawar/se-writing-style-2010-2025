sustainable solving reducing the memory footprint of ifds based data flow analyses using intelligent garbage collection steven arzt secure software engineering group fraunhofer institute for secure information technology darmstadt germany email steven.arzt sit.fraunhofer.de abstract static data flow analysis is an integral building block for many applications ranging from compile time code optimization to security and privacy analysis.
when assessing whether a mobile app is trustworthy for example analysts need to identify which of the user s personal data is sent to external parties such as the app developer or cloud providers.
since accessing and sending data is usually done via api calls tracking the data flow between source and sink api is often the method of choice.
precise algorithms such as ifds help reduce the number of false positives but also introduce significant performance penalties.
with its fixpoint iteration over the program s entire exploded supergraph ifds is particularly memory intensive consuming hundreds of megabytes or even several gigabytes for medium sized apps.
in this paper we present a technique called c lean droid for reducing the memory footprint of a precise ifds based data flow analysis and demonstrate its effectiveness in the popular flowdroid open source data flow solver.
c lean droid efficiently removes edges from the path edge table used for the ifds fixpoint iteration without affecting termination.
as we show on realworld android apps from the google play store c lean droid reduces the average per app memory consumption by around to .
at the same time c lean droid speeds up the analysis by up to .
i. i ntroduction static dataflow analysis is a well researched area.
its algorithms build the foundation for many applications especially in security and privacy analysis.
modern mobile applications process large amounts of sensitive personal data such as contacts e mails banking and health data text messages or location data.
several stakeholders have incentives to gain access to such data usually without the user s notice be it for targeted advertising or impersonation .
to prevent such unauthorized data leaks mobile applications must be vetted for how they operate on sensitive data i.e.
which data they access and where they transfer this data.
due to the large number of apps in modern app stores manually inspecting each application before publishing it to end users is clearly infeasible.
therefore automated techniques are required.
the properties in question are traditional data flow properties.
apps obtain sensitive data by calling api methods provided by the respective framework or operating system such as android.
if they need to transfer data to remote locations e.g.
via network connections they again need to call an api method.
the semantic transmission of the data record from the phone to the remote server directly translates to a codelevel data flow between two api calls .
especially when dealing with large amounts of applications on specialized platforms such as mobile devices or large amounts of possible code configurations static data flow analysis is a common choice.
dynamic analyses are often not a suitable alternative because of the well known code coverage problem .
additionally dynamic analyses on thousands of apps are infeasible on real world mobile devices despite recent advances in scalability .
even though emulators exist they require the complete mobile operating system to be emulated along with the app which is significant overhead.
furthermore the performance of emulating an arm based mobile phone on an x64 desktop computer or server is poor and not all apps are available for the rather uncommon x86based mobile os versions .
static data flow analysis must be precise and avoid false positives to be suitable for a mass inspection of hundreds or even thousands of apps.
therefore analyzers such as flowdroid rely on the context and flow sensitive ifds framework and its implementations for popular program analysis frameworks .
the ifds algorithm reduces the data flow problem to graph reachability in a structure called the exploded supergraph.
the number of nodes in the exploded supergraph is ino n m wherenis the number of statements in the program and mis the number of possible different data flow abstractions.
section ii explains ifds in more detail.
this paper focuses on the memory consumption of an ifdsbased data flow analyzer which is largely driven by the size of the exploded supergraph.
modern apps have hundreds of thousands of lines of code.
if we assume that a taint abstraction encodes the tainted variable there are hundreds of thousands of different taint abstractions in an analysis leading to a huge exploded supergraph.
in fact as we show in our evaluation in section v this amounts to hundreds of megabytes or even gigabytes for modern apps of moderate size.
while such hardware requirements might still be feasible for a small number of apps on a dedicated machine it effectively hinders ieee acm 43rd international conference on software engineering icse .
ieee analyzing many apps at once as it would be required for vetting a large app store within a realistic time frame.
note that ifds performs a fixed point iteration on the exploded supergraph.
modern ifds implementations such as heros or flowdroid s fastsolver reduce their memory footprint by incrementally building the exploded supergraph.
a node in the graph for a statement sand a data flow abstraction dis only created once the taint dactually arrives at s instead of building the maximum graph sxd upfront.
nevertheless the resulting graphs are huge.
since building these graphs is essentially a fixpoint operation that terminates when no additional edges are added to the graph anymore the graph grows continuously.
once an edge has been added to the graph it remains in the graph until the analysis has finished.
when creating the edge the analysis cannot determine whether it will later encounter a loop or recursive call in the code and thus return to the same nodes in the exploded supergraph.
it therefore assumes that each new edge is potentially relevant for detecting that a fixpoint has been reached and to ensure the termination of the analysis.
consequently the memory consumption grows over time.
the key observation of this paper is twofold.
firstly the majority of edges are only visited once and are therefore not actually relevant for ensuring the termination of the analysis.
secondly there is a frontier in taint propagation i.e.
the current set of edges over which taints are propagated.
the ifds solver can only return to edges that are reachable from this frontier.
inversely all other edges can be removed.
while propagation continues the frontier shifts and more edges become redundant.
this paper presents c lean droid an approach for efficiently computing the frontier of the taint propagation as well as the set of redundant edges.
it then removes the redundant edges from the exploded supergraph to regain memory while guaranteeing that the overall data flow analysis still terminates.
note that removing edges also implicitly removes those taint abstractions that are no longer referenced by any edge therefore freeing up significant amounts of memory.
we consider our approach to be a semantic garbage collector for ifds based analyses.
computing the frontier and identifying the redundant edges introduces additional computational overhead.
we therefore evaluate the effects of different computation strategies e.g.
when to perform garbage collection on memory consumption and computation time.
particular challenges arise in modern multi threaded ifds solvers that propagate taints as one independent work item per edge.
when new taints are created each taint is propagated individually potentially in different threads even if all of them originate from the same statement.
consequently the frontier is never stable i.e.
the set of taint abstractions at any given statement can change at any time depending on thread scheduling.
there is no inherent ordering when taints arrive at a particular statement or when the taint set of that statement is complete.
garbage collection cannot introduce such synchronization points without massive adverse effects on the performance and scalability of the solver.
we designed c lean droid such that it operates on a movingtarget without stopping the solver threads.
this paper presents the following original contributions clean droid an approach for efficiently garbagecollecting edges from an ifds exploded supergraph to regain memory during the analysis an implementation of c lean droid in the flowdroid open source data flow analysis tool and an evaluation on the performance time and memory effects of c lean droid in flowdroid on real world android apps from the google play store.
we will contribute c lean droid to the flowdroid opensource project once this paper has been accepted.
note that our approach is applicable to ifds in general and not limited to a particular implementation.
the remainder of this paper is structured as follows in section ii we give a short introduction into the ifds framework before presenting the c lean droid approach in section iii.
we discuss our implementation in section iv.
in section v we evaluate the time overhead and the memory gains of our approach before presenting related work in section vi and concluding the paper in section vii.
ii.
b ackground this section explains the key concepts and algorithms to which this paper presents novel extensions.
a. ifds in their paper reps et al.
define a set of problems called ifds inter procedural finite distributed subset and provide an algorithm for solving them.
many data flow problems fall in this category such as taint tracking for privacy sensitive data in android apps or checks for injection vulnerabilities .
the set of possible data flow abstractions is finite if we assume the abstraction to simply reference the tainted variable or access path which is a variable followed by a sequence of field dereferences such as var.f1.f21 .
the sets of tainted variables or access paths for two different paths through the inter procedural control flow graph can be computed independently and unioned at the join point i.e.
the statement in the code where the two paths meet.
therefore the problem is a distributed subset problem.
the core idea of ifds is to reduce the data flow problem to a graph reachability problem.
there is one node for each possible combination of access path and statement denoting that a specific access path is tainted at a specific statement.
an edge from one node to another indicates that if the source of the edge holds e.g.
x is tainted at statement s the destination of the edge e.g.
y is tainted at statement t also holds.
tautologies are placed at the sources z is tainted represented as edges from the special zero node to the respective access path.
the graph that consists of the pairs of statements and access paths as nodes and the effects of statements on taints as edges is called the exploded supergraph.
to detect whether data 1access paths are generally unbounded for recursive data structures but techniques exist to approximate them to a finite subset .
10990xyz x source y x z func y sink z b a return b ab0 fig.
example for exploded supergraph obtained from a source api call at a statement sis leaked through a sink api call at a statement t the analyzer searches for a path from node s to node x t assuming that xis the variable that is passed into the sink.
figure shows an example.
the left side code portion is the main method with the program entry point.
the right side code portion is a callee.
the dotted arrows between the statements represent the interprocedural control flow graph.
the solid black lines in the exploded supergraph indicate the path from the tautology x source to the sink node z sink z .
the dashed lines inside the exploded supergraph represent edges that are computed but not relevant for the path in question.
note that modern ifds implementations do not compute complete exploded supergraph upfront and then perform a graph search.
instead they incrementally extend the graph i.e.
start at each source s with the respective access path and then incrementally add new edges by processing each transitive successor statement in the interprocedual control flow graph.
the operation finishes once a fixpoint is reached and no further edges are added.
this approach avoids adding unnecessary edges to the graph.
in practice only a minority of all possible combinations of statement and access path can actually receive a taint.
conversely only a small subset of the entire exploded supergraph is actually required for the analysis.
furthermore client analyses can check whether a sink has been reached when propagating new edges i.e.
during taint propagation.
therefore they never perform a full graph search to find leaks and thus only need the graph for their termination checks on the fixpoint iteration.
still even such minimal fractions of the exploded supergraph can grow very large as we show in section v b. for ensuring that a fixpoint is reached when incrementally adding new edges classical ifds implementations never remove any edges.
note that the interprocedural control flow graph may contain loops e.g.
due to recursive method calls or loops in the program code.
therefore keeping a set of edges that have already been traversed is essential for termination i.e.
for detecting that the fixpoint has been reached.
in this paper we present and evaluate techniques for selectively garbagecollecting edges in this set at appropriate stages during the overall fixpoint iteration.summaries are another key concept of ifds.
in the example an incoming taint on the first parameter of the callee always leads to the return value being tainted regardless of the concrete call site.
the analysis therefore creates a contextspecific summary.
whenever it encounters another call site for the same callee in which the first argument is tainted as well it immediately taints the return value i.e.
applies the summary without propagating any edges through the callee.
we will use this property in section iii to delete edges from callees that are guaranteed to be fully replaced by summaries.
also note that modern multi threaded ifds solvers propagate their edges point wise and independently.
each edge to be propagated is a new work item that is picked up by the next available worker thread.
this allows the solver to use as many threads as there are edges currently being worked on which effectively exploits modern multi core processors.
therefore even if one incoming taint at one statement yields a set of new abstractions to be propagated i.e.
new edges from the same start node in the exploded supergraph these edges are all independent.
there is no notion of a path being complete aside from the overall fixpoint.
b. ide clean droid is applicable to arbitrary ide problems as well.
ide is an extension to the ifds framework and consists of two phases where the first phase propagates path edges with functions as taint abstractions.
in the second phase ide computes concrete values along the path edges in the exploded supergraph by computing the respective sequence of functions on a given input value.
we observe that the first phase is equivalent to ifds only with a special universe of taint abstractions.
nothing in c lean droid is specific to a certain type of taint abstraction.
c lean droid garbagecollects path edges in the first phase of ide which reduces the memory consumption for the exploded supergraph.
note that the second phase which is by far less memory intensive remains unchanged.
in fact popular ifds solvers such as heros are built on top of ide solvers and c lean droid would be integrated into the ide solver in such a case.
c. ifds based alias analysis flowdroid uses an ifds based alias analysis implemented through a second instance of an ifds solver which operates on an inverse backward interprocedural control flow.
whenever a heap object is tainted the forward solver which handles the normal taint propagation injects an edge into the backward solver.
the backward solver propagates this edge backward since aliases are introduced before they are used.
once an alias is found the backward solver injects a new taint on the respective access path into the forward solver which propagates the taint on the alias along with all other normal taints.
with passing edges between solvers flowdroid is able to retain context sensitivity in the alias analysis.
for the details of the two interleaved solvers we refer the reader to the original paper .
in the context of this work it is sufficient to note that edges may be propagated by two different 1100solvers which each build up their own independent exploded supergraphs.
this property is important for the notion of edge liveliness which we introduce in section iii.
note other ifdsbased works also use multiple interleaved solvers i.e.
this property is not specific to flowdroid.
we therefore design clean droid to support multiple solvers.
d. callgraph analysis clean droid requires an inter procedural control flow graph icfg which combines intra procedural control flow with a callgraph in a single graph.
we re use the existing icfg analysis in flowdroid without any modifications as flowdroid precisely models the android application lifecycle.
it generates a dummy main method that serves as the program entry point for soot s spark callgraph algorithm .
since clean droid uses the icfg as a black box input it is not specific to flowdroid.
note that loops and recursive calls are equivalent in the icfg since the icfg contains call return edges as well as edges inside methods.
iii.
a pproach the challenge of garbage collecting edges in the exploded supergraph is equivalent to identifying those edges that will not be visited by the ifds solver anymore.
we call these edges redundant edges.
we call edges that are not redundant edges i.e.
that can still be visited live edges.
when checking whether a given edge is a redundant edge or a live edge this current edge is called a candidate edge.
in other words a candidate edge is live if the solver may generate a set of intermediate edges in the exploded supergraph in the future such that its propagation returns to the candidate edge.
falsely considering a candidate edge as live wastes memory and reduces the effectiveness of the garbage collector.
falsely considering a candidate edge as redundant on the other hand may lead to a non terminating solver.
therefore the algorithm should conservatively only consider those edges as redundant that are definitely unreachable from all edges that are currently being propagated.
we call the edges that are currently being processed the frontier of the taint propagation.
note that in a multi threaded solver the set of frontier edges is the union of the edges in the solver s worklist that are currently waiting for an executor with free capacity and those edges that are currently being worked on.
frontier edges are by definition always live.
not all live edges are frontier edges though.
recall that an edge is live when the solver transitively returns to it in the future which may require starting at a frontier edge and then propagating an arbitrary number of intermediate edges before reaching the live edge in question.
as explained in section ii c we design c lean droid for ifds analyses with multiple solvers.
we assume that each solver keeps its own exploded supergraph.
each solver can inject arbitrary edges into the other solver for propagation.
we call a set of solvers that may inject edges into each other a solver peer group.
from the perspective of a single solver a new edge can appear at any node without requiring any path to that node inside the current solver s explodedsupergraph as it may be contributed by another solver.
we therefore define the union of all frontiers of all solvers inside a peer group as the global frontier.
there may be multiple peer groups but the global frontier is always relative to a single peer group.
similarly a globally redundant edge is redundant for all solvers in a peer group.
if an edge is only redundant for a subset of solvers we call it locally redundant.
as an example of dependencies between solvers let us assume that we remove an edge that is only locally redundant for solver s but not for solver t in the same peer group from the exploded supergraph of s. in this case solver t may inject the same edge back into s. then assume the same edge becomes locally redundant for t and is removed from t s exploded supergraph until s re injects the edge into t which re creates the original situation.
due to the intermittent removals followed by reinjections none of the two supergraphs reaches a fixpoint and the analysis never terminates.
we therefore conclude that only globally redundant edges may be removed from any exploded supergraph in any solver of the peer group.
to simplify the presentation we assume the global properties unless explicitly stated otherwise or obvious from context e.g.
frontier usually refers to global frontier .
each solver runs its own garbage collector.
the garbage collectors of all solvers in a peer group form a garbage collector peer group.
we use the term peer group interchangeably for solver peer groups and garbage collector peer groups in the respective context.
whenever a solver schedules a new edge for propagation this new edge becomes part of the frontier and the solver registers it as live with its associated garbage collector.
when an edge has been processed i.e.
the graph has been extended with potentially new edges beyond the current one it is no longer part of the frontier and unregistered from the garbage collector.
this allows each garbage collector to keep track of the local frontier for its corresponding solver.
listing target program for ifds analysis 1p u b l i c void main s t r i n g a r g s f i n t a s o u r c e f o r i n t i i i f i n t b c a l l e e a a c a l l e e b 6g 7g we now use the example in listing to give a better intuition of live edges in an interprocedural analysis.
we later use the same example to explain an efficient approximation for live edges.
for simplicity we describe a traditional java program instead of an android app.
in the example we consider the methods callee1 andcallee2 to be arbitrary computations of significant code size whose details are not important.
as explained in section ii the ifds analysis only terminates when reaching a fixpoint on the edges of the exploded supergraph.
in the example we assume that the global frontier only contains edges from method callee1.
we observe that the analysis will later return from callee1 1101callcallee2 and return from callee2 again.
it will then taint variable ain the main method before following the control flow graph back to the loop header and finally arriving back at the call to callee1.
therefore the edge that brings variable ainto the loop is live as it is visited transitively from the frontier in method callee1.
an ideal garbage collector would precisely compute the set of all outgoing paths through the exploded supergraph from the frontier and mark all edges on these paths as live.
in the example this would include all edges in the loop to ensure that the incremental generation of this cyclic subgraph reaches its fixpoint.
however the problem of precisely enumerating the live edges and thus checking whether a candidate edge is live or redundant is equivalent to the ifds problem.
edges are created incrementally and the full exploded supergraph is only known when the full ifds problem has been solved.
while creating this graph the analysis cannot already traverse the edges that are yet to be created to see whether it will re visit a certain candidate edge in the future.
to avoid this problem c lean droid applies conservative over approximation of live edges.
our approach reduces the frontier computation problem to a graph search in the immutable call graph of the program which is not only much smaller than the exploded supergraph but which can be precomputed before the ifds analysis begins.
we observe that the solver can only re visit the edges in a particular method if it can return to that method via a control flow edge.
in the following we build a recursive over approximated definition of live edges around this observation.
note that considering too many edges live reduces the effectiveness of the garbage collection but does not impact the correctness or termination property of the ifds algorithm.
in fact c lean droid gracefully degenerates to basic ifds in the worst scenario.
therefore the approach retains these properties of ifds as long as the approximation is complete i.e contains at least those methods in which the solver may propagate edges in the future.
reducing the computation to a callgraph search is efficient because since plain ifds already requires the interprocedural control flow graph which is in turn based on the callgraph.
therefore this data structure already exists in a plain ifds analysis and does not require additional work to implement c lean droid .
in practice we translate the callgraph into a map from each method to the set of transitive callees of that method for faster queries.
the time and memory required to create and store this map respectively are not significant.
as we show in section v c lean droid reduces both the time and memory consumption of the ifds analysis in comparison to the original flowdroid implementation.
our approximation is recursively defined as follows.
we consider a method as live if there is at least one edge known to be live in that method.
recall that frontier edges are live i.e.
they are the base case in our definition.
a method is also live if it directly or transitively calls a method that is already known to be live.
all edges inside a live method are considered live as well.
a method that is not live is called redundant.
all edges inside a redundant method are consideredredundant.
the basic idea behind this approximation is as follows we assume that all methods in which the solver is currently propagating edges or to which the solver might return i.e.
transitive callers may potentially contain loops.
all these potential loops may lead to cyclic subgraphs in the exploded supergraph i.e.
we conservatively consider all edges in these methods live.
c lean droid makes no attempt to verify whether the solver may actually return to a specific edge inside any of these methods over approximation .
we use the example in listing to explain why our approximation of live methods is complete i.e.
no live methods are considered redundant by our approximation.
note that redundant methods may be considered live though.
we also show why our definition of live methods only needs to consider method returns and not method calls.
in the example we again assume a state in which all current frontier edges belong to method callee1.
therefore method callee1 is live.
it might contain a loop and removing edges from inside a loop may lead to non termination.
more precisely removing edges from this part of the exploded supergraph therefore poses the risk that this edge is a part of a cyclic subgraph and removing it would lead to an intraprocedural infinite propagate remove cycle.
method main is live because its callee callee1 is live.
in other words the ifds solver eventually returns to main from callee1 via a return edge.
removing edges frommain can therefore lead to the issue we described when introducing the example.
if the taint abstraction on variable ais always removed while working on callee1 and recreated upon return before processing callee1 again an infinite propagate remove cycle may occur.
method callee2 on the other hand is not live.
it does not contain any frontier edges nor does it call any live method.
we now explain why this does not impact termination.
recall from section ii that ifds creates method summaries for methods that have already been processed.
when the solver processes a method call for the same callee and context for which a summary exists it applies the summary instead of propagating edges through the callee again.
the edges in methods for which summaries exist can therefore safely be removed.
consider method callee2 in the example.
if a summary for a given incoming taint abstraction already exists and the call is encountered once again the solver applies the summary instead of propagating edges through callee2.
if no summary exists for the current context i.e.
the incoming taint abstraction the solver propagates through the method once.
while this propagation is running the method is live because its edges are on the frontier and thus live.
alternatively the solver has descended into transitive callees which also makes the method live since it has live callees.
once the solver has completed analyzing the transitive callees rooted incallee2 and the method is no longer live the summary exists.
therefore the edges inside callee2 are never visited again for this context and can be deleted safely.
note that edges are context sensitive just like summaries.
therefore c lean droid only deletes those edges that correspond to the same context for which the summary was created.
c lean droid 1102never deletes summary edges.
in the notation of naeem et al.
we only remove entries from the pathedge table.
since c lean droid is designed for ifds problems with multiple interacting solvers each garbage collector queries its entire peer group whether a particular method is redundant.
the edges inside a method are only removed if the method and thus all edges in it are globally redundant in all solvers of the peer group.
note that all solvers share the same control flow graph allowing for a shared cache of transitive callee relationships already queried before.
algorithm shows the implementation of the garbage collector.
the global variable maps methods to the number of unfinished edge propagations in that method while variable ccontains the candidate methods for garbage collection once they are no longer live.
method initialize is called before the ifds solver schedules its first edge for processing.
method rungarbagecollector is run in a separate thread concurrently to the garbage collector and constantly checks for edges that can be removed.
the ifds solver invokes method onedgescheduled whenever it schedules a new edge for processing.
note that we define the method to take a full edgehd1 n d 2ias parameter to be consistent with common presentations of the ifds algorithm .
once an edge has been taken from the worklist and has been fully processed the solver calls method onedgepropagated.
the ifds solver only needs to be modified to call these methods in the garbage collector and can otherwise remain unmodified.
frontier computation is handled in method transitivecallees which obtains the set of transitive callees of a given method via a callgraph search.
with a call to methodof the garbage collector can retrieve the method that contains a given statement.
in the algorithm we iterate over all edges in the exploded supergraph represented by the edge set graph to find all edges in a given method and remove them one by one.
in our actual implementation we instead adapted the solver to quickly remove all edges within a given method without having to iterate over all edges in the graph.
method rungarbagecollector is run concurrently to the other methods.
it computes the set of live methods based on a method reference counter which is concurrently being modified by onedgescheduled andonedgepropagated.
when the solver processes an edge that leads to one or more new edges being added to the worklist it calls onedgescheduled on all of them.
only then it marks its current edge as done via onedgepropagated.
therefore clean droid works on an over approximation of live edges to prevent infinite sequences of edge removal and re creation as explained above.
as we show in section v d even on a highly concurrent system with cores and as many ifds worker threads c lean droid is thread safe.
recall that flowdroid checks for leaks while propagating edges i.e.
whenever it processes a statement it checks whether this statement is a sink and whether the incoming data flow abstraction