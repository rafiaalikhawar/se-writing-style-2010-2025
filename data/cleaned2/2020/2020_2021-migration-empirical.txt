a large scale empirical study onjava librarymigrations prevalence trends and rationales hao he departmentof computer scienceandtechnology peking university and key laboratory of highconfidence softwaretechnologies ministry of education beijing china heh pku.edu.cnrunzhihe departmentof computer scienceandtechnology peking university and key laboratory of highconfidence softwaretechnologies ministry of education beijing china rzhe pku.edu.cn haiqiaogu departmentof physics tsinghuauniversity beijing china ghq17 mails.tsinghua.edu.cnminghuizhou2 departmentof computer scienceandtechnology peking university and key laboratory of highconfidence softwaretechnologies ministry of education beijing china zhmh pku.edu.cn abstract with the rise of open source software and package hosting platforms reusing3rd partylibrarieshasbecomeacommonpractice.
due to various failures during software evolution a project may removeausedlibraryandreplaceitwithanotherlibrary whichwe calllibrary migration .despite substantial researchon dependency management the understanding of how and why library migrations occur is still lacking.
achieving this understanding may help practitioners optimize their library selection criteria develop automatedapproachestomonitordependencies andprovidemigration suggestions for their libraries or software projects.
in this paper throughafine grainedcommit levelanalysisof19 652javagithub projects we extract the largest migration dataset to date migrationrules 163migrationcommits .weshowthat8 .
projects having at least one library removal .
lowerbound to .
upper bound projects have at least one migration and a median project with migrationshas to migrationsintotal.wediscoverthatlibrarymigrationsaredominatedby severaldomains logging json testingandwebservice presenting alongtaildistribution.also migrationsarehighlyunidirectional inthatlibrariesareeithermostlyabandonedormostlychosenin our project corpus.
a thematic analysis on related commit messages issues and pull requests identifies14 frequently mentioned migration reasons e.g.
lack of maintenance usability integration etc 7ofwhicharenotdiscussedinpreviouswork.ourfindings can be operationalized into actionable insights for package hosting platforms project maintainers and library developers.
we provide areplication package at .
works doneat peking university 2corresponding author permissionto make digitalor hard copies of part orall ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrightsforthird partycomponentsofthisworkmustbehonored.
forallotheruses contactthe owner author s .
esec fse august 23 28 athens greece copyright heldby the owner author s .
acm isbn .
concepts softwareanditsengineering softwarelibrariesandrepositories maintainingsoftware software evolution .
keywords librarymigration miningsoftwarerepositories evolutionandmaintenance empirical software engineering acmreference format haohe runzhihe haiqiaogu andminghuizhou.
.alarge scaleempiricalstudyonjavalibrarymigrations prevalence trends andrationales.
inproceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august23 28 athens greece.
acm newyork ny usa 13pages.
introduction reusingexisting3rd partylibraries1withready to usefeatureshas long been a common practice in software development which can increasesoftware quality anddevelopmentproductivity .still itis notuntilthe riseofopen source softwareandthe availability of central hosting platforms e.g.
maven npm pypi etc intherecentdecadethatsoftwarereusebecomessoeasyfor both library users and library developers.
the number of newly publishedjarsonmavencentralhasgrownfrom86 161in2010 to in and in .
as a result 3rd party librariesarewidelyadoptedinbothopen sourceandproprietary softwareprojects andanon trivialsoftwareprojectoftenreuses dozensoreven hundredsof existing libraries .
meanwhile the adoption of 3rd party libraries brings unique challenges in the entire software life cycle .
first given the wide spectrum of available libraries even the task of choosing the right library for a specific purpose becomes non trivial in which 1developersusedifferenttermsinterchangeably suchaslibraries packages dependencies components frameworks etc to refer to a piece of reusable software e.g.
a jar file availablefordownloadinacentralhostingplatform e.g.mavencentral .
for consistency weuse theterm library to referto thereusable softwareitself and the term dependency to emphasizethat it is used by anothersoftwareproject.
478esec fse august athens greece haohe runzhi he haiqiaogu andminghuizhou complex socio technical factors need to be considered .
second increasingconcernsarebeingraisedabouttheriskofusing outdated libraries as they may contain security vulnerabilities and unresolvedissues challengingtheconventionalstrategyof ifitain tbroke don tfixit.
consequently researchersstudy thecharacteristics reasons anddriversoflibraryupdates andpractitionersproposeindustrysolutions e.g.synk whitesource and github advisories that aim to keep libraries up to date and vulnerability free.
however failures or misalignment witha libraryinevitablyhappens and may not be resolvable by updating its version.
in such cases the library has to be completelyremovedandreplacedbyanotherlibrary whicharecalled librarymigration inthe literature .
whilealargebodyofexistingresearchesareconductedtocharacterizeandunderstandlibraryadoption andlibraryupdates researches on library migrations are still fragmented and incomplete.
more specifically we lack understanding on how a large number of projects migratetheir dependencies as awhole and what factors drive such migrations.
as the ultimate consequenceoflibraryadoptionfailures suchunderstandingwillbe avaluablesourceofinformationfordevelopers decisionmakers and stakeholders.
it may help them optimize their library selection criteria developautomatedapproachestomonitordependencies andprovidemigrationsuggestionsfortheirlibrariesorsoftware projects.
to bridge this knowledge gap we seek to conduct a descriptivemixedmethodsstudyonlarge scaleopen sourcedatato holistically understand how and why library migrations happen.
more specifically we ask the following researchquestions rq1 howcommon are library migrations?
rq2 howdomigrationshappen between libraries?
rq3 what are the frequently mentioned reasons when developers conduct alibrary migration?
wefaceseveralchallengeswhenansweringtheseresearchquestions.firstofall theparallelanddistributednatureof git based developmentpresentsuniquepeculiarities inanattempttoreconstruct accurate library change histories for a specific project.
second it is difficult to precisely define library migration and identify librarymigrationsin commithistory while existingstudies sufferfrommethodologicallimitations detailsinsection2 .
to address these challenges we propose an event based dependencychangemodel formulatelibrarymigrationbasedon dependencychangesandself admittedcommitmessages retrieve migrationsusing a state of the art mining algorithm and analyze migration frequency using upper bound and lower bound estimations.byapplyingourmethodon19 652javaprojectsand libraries we extract dependency changes and migration commits the largest dataset compared with previous works in table .
we conduct exploratory data analysis for rq1 and apply thematic analysis to migration related commits issues andpull requests to answer rq3.
the key findingsare both library removals and migrations are prevalent in the java projects in which have at least one library removal and lower bound to upper bound have at least one library migration.
they are more likely tohappenamongprojectswithlargernumberofcommitsanddependencies.amedianprojectwithlibraryremovals hasoneremovalper139commitsandamedianprojectwith migrationshas 2to 4migrationsintotal.
librarymigrationsfromfourdomains logging testing json and web service dominate the dataset presenting a long taildistribution.and migrationsarehighlyunidirectional in that libraries within the same domain are either mostly abandonedormostly adoptedinthe studiedprojects.
projectsconductlibrarymigrationsfor14differentlibrarysideandproject specificreasons.weidentify7 reasonsnot discussed in previous works.
the most frequent reasons includelackofmaintenance feature usability integration withprojectcontext andsimplification of dependencies.
based on our findings we summarize actionable insights for package hosting platforms project maintainers and library developers includinghowtoformulateandpublicizebestpractices how to select and integrate libraries what to do with unmaintained libraries andwhattoprioritizeforlibrarydevelopment.wealso identify aspects where currenttoolingsupport does notsuffice and suggestfuture researchdirections.
we provide a full replication package at zenodo.2the scripts anddocumentationcanalsobeaccessedinthisgithubrepository.
backgroundand related work migrationisacommonphenomenonduringsoftwaremaintenance which may refer to different development activities that stem from variousmotivations.commoncasesofmigrationinclude migratingfromoneversiontoanotherversion oneapitoanother api oneprogramminglanguagetoanotherprogramminglanguage oneplatformtoanotherplatform oronelibrary to another library .
in this paper we use the term library migration to refer to the process of replacing one library withanother4functionally similar or equivalent library.
given a librarymigrationfromlibrary l1tolibrary l2 wereferto l1asthe source library l2as thetarget library and l1 l2 as amigration rule inthe subsequent paper.
threesteps aretypicallyrequired foralibrarymigration justifyingthenecessityofamigration findingthebesttargetlibrary and modifying the code to use the new library.
for open source projects the first two steps are often facilitated through public discussions in issue trackers where the benefits and costs are evaluated by developers .
such discussions may not result in a migrationifnoconsensusisreachedortheperceivedbenefitsdo not outweigh the costs .
the cost mainly comes from the third step which is known to be tedious error prone and sometimes difficult .
there are efforts that aim to improve development efficiencyforthethird step byusingapiwrappers mining api mappings or directly editing code to use the new api .studiesalsoshowthatlibrarymigrationsmayimprove code quality but performance israrelyimproved .
inthispaper wefocusonunderstandingthefirsttwostepsof librarymigration followingexistingstudies .
4moreprecisely by anotherwemeanthe names i.e.
groupid artifactid injava of the twolibrariesaredifferent.
479a large scale empirical studyonjava library migrations prevalence trends andrationales esec fse august athens greece table summary ofrelated workon library migration paper subjectofstudy reportedprevalence reportedreasons teytonetal.
migrationrules n.a.
convenience outdated incompatibilities teytonetal.
migration rules migrations commit messages5.
of projects feature performance configuration bug environment kabinnaetal.
logging library migration attempts successful of asf projects .
feature performance flexibility reduce future maintenance reduce dependencies teyton et al.
propose the concept of migration graph and a methodtominemigrationgraphfromsoftwarereleases wherethey get migration rules and three reasons from real world examples.
in their subsequent study they use a modified approach on thecommithistoryof15 168projectsandget329migrationrules 198migrationsand26commitmessagesthatmentionedmigrationreasons.kabinnaetal.
analyzedeveloperdiscussionsof logginglibrarymigrationsinapachesoftwarefoundation asf projects where they identify migration attempts and five major reasons.however theexistingstudies haveseverallimitations.inparticular onlyobtainasmallnumberofmigrations donot haveasolidmethodologyfoundationandarehard toreproduce.bytheirdefinition alibrarymigrationhappensiftwo libraries with similar functionalities co exist and one gets removed in project history.
the notion of similar is ambiguous and library migrations by this definition may be over estimations.
they also do not provide sufficient details about their manual identificationcriteria nordotheysharetheirdatasetoflibrarymigrations.
furthermore usesonlysource code analysis for identifying libraries whichmaymissmigrationsthatonlymodifyconfigurationfiles e.g.
migratelogger5ordatabase6 .finally focuses on a relatively small number of logginglibrary migrations.
consequently thefindingsin cannotreflectgeneraltrendsand maynotgeneralizetootherkindoflibraries.inthisstudy wemine large scale historical data to provide a comprehensive overview of how and why library migrations happen among a large number of projectsandlibraries.
ourworkisalsopartiallyinspiredbyrecentstudiesonlibrary adoption andlibraryupdates .intermsoflibraryadoption researchers use interviews and surveys to summarize developer considerations whenchoosingjavascriptframeworks decidingwhethertoreimplement and selecting libraries in general .
researchers also employ different modeling approaches to identifyfactors that leadtoadoptionbetweenrdataframelibraries andbetween javascript ci cd tools .in terms oflibrary update researchershaveinvestigatedhowdevelopersupdate ornotupdate libraries mechanisms to support library update and the impact of security vulnerabilities introducedbyoutdatedlibraries .however theydonotconsider migrationsbetween differentlibraries andourstudycancomplementexistingresearchesbyprovidingfindingsabouthowprevious library adoptions fail in projects and why developers choose to replace alibrary instead ofupdatingit.
data collection .
collecting projects andlibraries we beginwith the latest libraries.io dataset releasedinjan which is widely used in related research e.g.
.
wechooseto focusonjavaprojects because ofjava spopularity andindustrialimportance andbecauseallpreviousworksinthis topicfocusonjava .weconsiderarepositoryongithub as a project and use the github repository list in the dataset to select relevant repositories.
as a simple threshold for ensuring the qualityofselectedrepositories weselectnon forkjavarepositories with more than stars leaving us with repositories.
we do notfilterbythenumberofcommitsandrecentactivitiesbecause thegoalofourstudyistodepictgenerallongitudinaltrends notto observethestate of the artpracticebymatureprojects.then to retrieveversioncontroldatafortheseprojects weusetheworld of code database version r constructed in april .
to simplifythetaskofdependencyextraction wefocusonprojects that use maven for build and dependency management.
these projectscontainoneorseveralconfigurationfilesnamed pom.xml in their project paths which has a dependencies section where developersdeclarethegroupids artifactids andversionnumbers of required libraries.
the declarations are strict in that a build attempt will fail if a used library is not declared or included as a transitive dependency but an unused library may still be declared whichisathreattovalidity section .
.bykeepingrepositories with at least one pom.xmlfile in one of the repository s commits we retain 652repositories 437commits intotal .
the dependencies declared in project pom.xmlfiles may not fit thedefinitionofa library becausetheymaybeinternalproject modulesnotintendedforreusebyotherprojects.tofilteroutsuch cases weonlyconsiderdependenciesthat1 areaccessibleinmaven central and2 havebeenincludedinthe pom.xmlsofmorethan 10repositoriesintheaforementioned19 652repositories.finally we get libraries.7we sample libraries confidence level confidenceinterval anddeterminewhethertheyare librariesornotbyinspectingtheirdescriptionsinmavencentral andsearchingthemontheweb.ninety threeof94samples .
containpublicinformationindicatingtheirappropriatenessofreuse e.g.
terms such as library framework platform specification etc whichjustifiesour selection criteria.
7following general conventions we consider a unique group id artifact id pair as a library and the version string for distinguishingdifferentversionsof a library.
8theonlyexceptionis io.prometheus simpleclient common whichdescribesitself ascommoncodeusedby various modules ofthe simpleclient .
480esec fse august athens greece haohe runzhi he haiqiaogu andminghuizhou figure anexample projectcommit history.
.
computing dependency changes with projects and libraries collected our next task is to extract dependencychangesfromprojectcommithistories asthesedependencychangesmayindicatelibrarymigrations.however simply sorting and comparing all versions by time for a given pom.xml file will generate too many false positives because a project may have many parallel branches which may or may not be merged effectivelyformingadirectedacyclicgraph dag seefigure .
totakethedagintoconsideration wemodeleach dependency changeas aneventhappened in one commit which can be either an adoption a removal or a version change.
the event is computed from comparing with the prior pom.xmlfile version in the parent commit.
more precisely let commit c1be the parent of commit c2 l1be the set of dependencies in pom.xmlfilefof commitc1 andl2infilefofcommit c2.forc2 thesetofadoptions d c2 l2 l1 thesetofremovals d c2 l1 l2 andthesetofversionchanges dvc2 l l l1 l l2 ver l c1 ver l c2 .for c2in figure f tool pom.xml d c2 org.slf4j slf4j jdk14 d c2 log4j log4j anddvc2 org.slf4j slf4j api .
we ignore merge commits based on the assumption that merge commits are seldom usedformakingnewchangesother than conflictresolution.
to validate this assumption we collect merge commits withpom.xmldifffromallrepositories 553intotal .
ofall mergecommits andfindthatonly6 havenewdependency changes.
through an iteration over all commit diffs of all projects we get2 992dependency changes from commits.
.
identifying librarymigrations thedependencychangeswecollectedbeforemaynotbenecessarily related to a library migration but it is non trivial to define and identify real library migrations from dependency changes.
first we need to determine whether a migration is feasible between two arbitrary library pairs i.e.
for l1andl2 whether l1 l2 is a migration rule .
next we need to identify commits related to a library migration.
to deal with these challenges we define a commit as a migrationcommit when its commitmessage clearly indicatesamigration e.g.
replaceorg.jsonwithjackson and define l1 l2 as amigration rule if and only if we can find a migrationcommit that conductedthe migrationfrom l1tol2.
we acquire migration commits and migration rules from the dependency changes using a state of art mining algorithm and manually validate the returned results.
for each source library query the algorithm mines possible target libraries rank each targetlibrarybyaconfidencevalue andreturnspossiblemigrationtable statistics ofthe collected dataset data size statistics projects p stars median stddev .
commits median stddev .
active months median stddev .
pom.xmlfiles median stddev .
libraries l versions median stddev .
includedrepositories median stddev .
dependency changes d 774commits adoptions d 691commits removals d commits versionchanges dv commits migrationrules r renames migrationcommits m 459renames commits from the source library to the target library based on the collecteddependencychanges.however itgeneratesatremendous amountofoutputifwequeryusingallthe4 022libraries.toreduce humaninspectioneffort weuseacombinationof1 sourcelibraries providedin 500most popular libraries bynumberof adoptionsinourrepositorydataset asthequerytothealgorithm queries in total .
for the output of each query we focus on inspecting the returned commits for target libraries that have non zero confidencevalue ranktop 20amongallreturnedtargetlibraries and exist in the aforementioned libraries.
after validation we obtain migration rules 390source libraries 562target libraries and3 163migrationcommits.weobtainthelargestdataset comparedwithpreviouswork butthesizeofmigration commits by this definition is doomed to be small because most commitsdonothaveinformativecommitmessages .thus this setofmigrationscanonlybeviewedasa subsetofrealworldmigrations and inadequate for answering migration popularity rq1 but they are guaranteed to be correct and invaluable for unveiling migrationbehavior rq2 andreasons for migration rq3 .
some migrations happen because of a library rename which oftenaccompaniesimportantlibrarychanges e.g.
majorversion update license change organization switch etc and falls near the boundary of library update and library migration.
we detect these rules by finding all rules whose artifact ids contain overlapping terms excludingtermslike api core all etc andmanuallyvalidatingtheresults resultingin393 renamerules .teytonetal.
exclude rename rules by manually mapping groupid artifactid to librarynames.
however libraryrenamesare1 verycommonat least in java maven developers also state them as migrations in commitmessages and3 theirapisareoftensignificantlyreworked.
thus wechoosetoretainrenamerulesinsubsequentanalysisas aspecialtypeofmigrationrule anddistinguishthemfromother ruleswhere theirproperty significantly differs.
in theremainder ofthispaper we denote pas theset ofrepositories i.e.
projects las the set of libraries das the set of dependencychanges d d dvforadoption removalandversion changes respectively ras the set of migration rules and mas the set of migration commits.
the statistics of collected data are summarizedintable .
481a large scale empirical studyonjava library migrations prevalence trends andrationales esec fse august athens greece number of commits .
.
.
.
.
.0percentage of projects removal version change number of dependencies .
.
.
.
.
.0percentage of projects removal version change figure distribution of prby number of commits dependencies withthatof pv p p p dvp forcomparison.
rq1 howcommon are library migrations?
since library migration is the process of removing a library and introducing another library a library removal and a library adoption arenecessary for a library migration.
to the best of our knowledge library removals during software evolution have never been studiedbefore.intuitively ifmanyprojectsremovealibrary itis probablyfollowedbymigrations anditisunknownexactlyhow manyremovalsarerelatedtomigrationsandhowmigrationsare distributedinour projectcorpus.thus we ask twosub rqs rq1.
howfrequentlydoprojectsremove alibrary?
rq1.
howfrequentlydoprojectsmigratealibrary?
.
rq1.
removal frequency analysis .
.
methodology.
we consider all types of dependency changes during analysis for comparison purposes.
for project p p letcp bethesetofcommitsfor p dpbethesetofdependencychanges happenedin p i.e.
dp uniontext.
c cpdc .wefirstconsiderprojects pr pwithatleastoneremoval i.e.
pr p p p d p and analyzeitsdistributionwithin p.then for p pr wecomputeand comparethedistributionsfor1 thenumberofchangesinproject p forallchangetypes i.e.
summationtext.
c cp d ford dc d c d c dvc and the average number of commits between changes for all change types i.e.
cp c c cp d ford dc d c d c dvc .
we use the latter to estimate the frequency or interval of each changetype alongthe projectdevelopmenthistory.
.
.
results.
for all projects p .
projects do not have any dependency changes because their pom.xmlfiles have noorempty dependencies sections.
among theremaining 254projects .
haveatleastoneversionchangeand .
have at least one removal.
the two major reasons for not having any removals or version changes are that these projects do not have sufficient development historiesor only have a few number of dependencies.
by dividing the projects into equally sized chunks separated by number of commits we show on the left side of figure 2that migrations are more likely to happen in projects with higher number of commits and the trend isverysimilartothatofversionchanges.aspearmancorrelation testbetweennumberofremovalsandnumberofcommitsforall projectsyields acoefficient of .
p .
which indicates moderate to strong correlation.
a similar trend can be observed fornumberofdependenciesontherightsideoffigure butthe correlation isweaker .
p .
.
number of changes all adoption removal version all adoption removal versionchange type number of commits per change 3248139167figure3 distributionofthenumberofchanges below and theaverage numberofcommits between changes above .
for the projects with at least one removal pr we plot the distributionofthenumberofchangesandtheaveragenumberof commits between changes for all change types in figure .
among pr amedianprojecthas35adoptions 6removals 6versionchanges oneadoptionper48commits oneremovalper139commits andone versionchangeper167commits.thevariationsarealsohighacross different projects with version changes having higher variance than removals.
we conclude that apart from library updates and adoptions libraryremovalsarealsoverycommonfortheseprojects.
summary for rq1.
among projects with dependencies .
have at least one library removal.
for those projects a median project has one removalper139commits forcomparison oneversionchange per commits .
removals are more likely to happen for projectswithhigher number of commits anddependencies.
.
rq1.
migration frequency analysis .
.
methodology.
we begin with mandrmentioned in section3.
which contains libraries denote as lm l .
by limiting our analysis on projects that have once adopted any of theselibraries weobtain17 426projectsanddenoteas pm p p p l l lm l d p .
the computation of frequency for library migrations is difficult becausewecannotguaranteethecompletenessofminedmigrations for any non trivial mining approach .
as mentioned in section3.
mandraresubsetsofrealworldmigrationcommitsand migrationrules whichcanonlybeusedtoestimatelower bound frequencies.werefertosuchcasesas confirmed migrations in this section and denote pcm pas the set of projects with at least one confirmed migration.
as an upper bound estimation we proposeitislikelythat phasalsoconductedthesamemigration if l1 l2 is a migration rule and l1is removed and l2is added in apom.xmlfile of project p. more formally let dp fbe the set of dependency changes happened in pom.xmlfilefof project p we hypothesize that if l1 l2 r l1 d p f l2 d p f a library migrationmayhavehappenedin fofp.similarto pcm werefer to such cases as possible migrations and denote ppm pas the setofprojectswithat leastone possible migration.
similar to rq1 we first analyze the distribution of pcmandppm withinpmanditsrelationshipwithnumberofcommitsandnumberofdependencies.then weanalyzethedistributionoflibrary migrationswithin pcmandppm.foreachproject p wecountthe numberofmigrationsbythenumberofmigrationrulestoavoid 482esec fse august athens greece haohe runzhi he haiqiaogu andminghuizhou number of commits .
.
.
.
.
.0percentage of projects removal possible migration confirmed migration number of dependencies .
.
.
.
.
.0percentage of projects removal possible migration confirmed migration figure4 distributionof pcmandppmbynumberofcommits and dependencies.
we also show the results of p r p p pm d p forcomparison.
duplicationwhen aproject simultaneously performs the samemigration in many pom.xmlfiles or in different branches in which somemaynot be merged.more formally we define migcnt p l1 l2 l1 l2 r l1 d p f l2 d p f finally for each migration commit m m we use its commit timestamp to plot alongitudinal trend oflibrary migrations.
.
.
results.
amongthe17 426projects pm .
have at least one removal of libraries in lm .
projects have at least one possible migration ppm and .
projects haveatleastoneconfirmedmigration pcm .asaroughestimation upto62.
oftheprojectshaveremovalsthatleadto a library migration for .
of which we can confirm in commit messages.
although library migrations may not be verycommon in pmwhich contains projectswith fewcommits or few dependencies we show that library migrations are much more commonforprojectswithmanycommitsanddependencies figure4 .
p .001forcommits and .
p .
fordependenciesusingspearmancorrelationtest .amongthe3 projectswithmorethan10dependenciesand143commits both aremedianvaluesin pm .
.
projectshave atleastonepossible confirmedmigration.furthermore weplot thedistributionofprojectsbynumberofmigrationshappenedin ppmandpcm figure5 .asexpected theirdistributionsresemble the shape of a long tail distribution where most projects have one or a few migrations and some projects have many more.
a median projectin ppmhasundergone4possiblemigrations mean .
stddev .
max and a median project in pcmhas undergone2confirmedmigrations mean .
stddev .
max .
although there are extreme cases the majority of projects .
.
have no more than five migrations.
finally figure6shows the number of migration commits in each year and we can observe a clear increasing trend note that we only have partial data for .
this indicates that library migrations are becoming increasinglyprevalentinthe java mavenecosystemsince the publication ofteytonetal.
.
summary for rq1.
inthestudiedprojectcorpus .
to28.
haveundergone atleastonelibrarymigration.forthoseprojects mosthave no more than five migrations.
the probability of undergoing a library migrationbecomes significantly higherforprojects withlarger number ofcommits anddependencies.
number of possible migrations 1000number of projects1134 number of confirmed migrations 400number of projects522 0figure distribution ofprojectsby numberofmigrations.
year 500number of migration commits figure numberofmigrationcommits ineachyear.
rq2 howdomigrationshappen between libraries?
the results of rq1 have demonstrated that library migrations have happenedinasignificantnumberofsoftwareprojects.however itisstillunclearhowexactlylibrarymigrationsareconducted in particular what kind of migrations are performed among what kind of libraries and whether or not the migrations share common behavior.
therefore we ask rq2 how do migrations happen between libraries?
.
methodology we adopt the concept of migration graph proposed by teyton et al.
as the basis to facilitate further analysis.
we define the migration graph in our study as a weighted directed graph lm r w where librariesin lmarenodes migration rulesin r areedges and w isanedgeweightingfunction.for l1 l2 r we compute weight w l1 l2 by counting the number of projects that have performedamigrationfrom l1tol2inm.
todemonstratetheextenttowhichalibraryismorelikelytobe amigrationsourceoramigrationtarget wedefinethefollowing metricflow l for library l lm flow l deg l deg l deg l deg l wheredeg l istheweightedindegreefornode landdeg l isthe weightedoutdegreefornode l.obviously flow l where flow l meanslis always a target library and flow l meanslisalwaysasourcelibrary.
to understand what kind of migrations are performed and to effectivelyvisualizethegraph wedividemigrationrulesintodifferentapplicationdomains.first weuselouvaincommunitydetection onthemigrationgraphtoget116initialclusters.then we use library descriptions labels in maven central and information fromsearch enginestomergeclusters resolveclusternames and correcterrors.theapplicationdomainofeachmigrationrule l1 l2 483a large scale empirical studyonjava library migrations prevalence trends andrationales esec fse august athens greece http clients .
jdbc pools .
metrics .
build .
command line .
cache .
tag .
webservice .
logging .
json .
testing .
other .
xml .
database .
persistence .
dependency injection .
bytecode .
figure distribution of rby application domain.
number of migrations happened logging json testing webservice other http clients xml core utilities database persistence i o bytecode metrics build dependency injection jdbc pools code analyzers mail command line figure number of migrations for migration rules in each application domain summationtext.
p pmigcnt p equation .
is assigned from the domain of l1andl2when the two libraries areinthesamedomain whichisthecasefor1 055rules .
.
for the remaining rules l1andl2fall into different domains either because the boundariesbetweendomains issometimes unclearor migrationscanhappenbetweendifferentdomains e.g.fromaxml library to a json library for serialization .
we get application domainsintotal amongwhich16 domainshave morethan 10migrationrules.thedomaindistributionisshowninfigure .four domains web service logging json and testing dominate the dataset with648migrationrules .
.if we countthe number of migrations happened figure migrations between logging libraries and json libraries happen .
.7x more than testing and webservicelibraries.finally wevisualizesub graphsforimportant applicationdomainsusingsankeydiagrams whichareoften usedto visualizehowthings flowincomplex networks.
.
results figure9 top shows the distribution of flow l forl lm.
surprisingly thedistributionisextremelydistorted.for154libraries .
flow l 1andfor326libraries .
flow l .
theremaininglibrariesgenerateauniformdistributionintheintervalof .thedistributionshapedoesnotchangeevenifwe onlyconsiderlibrarieswithhigher indegree andoutdegree values figure9second top although there are slightly more libraries that fall withinthe intervalof .
.
.
the distribution shape also does not change even if renamerules are excluded figure9secondbottomandbottom .wecanconcludefromthis observation that a large number of libraries are either mostly abandonedormostlyadoptedasmigrationtargetsbydevelopers which .
.
.
.
.
.
.
.
.
migration flow with deg l deg l for all rules 400count157 .
.
.
.
.
.
.
.
.
migration flow with deg l deg l for all rules 100count52 .
.
.
.
.
.
.
.
.
migration flow with deg l deg l without rename rules 300count129 .
.
.
.
.
.
.
.
.
migration flow with deg l deg l without rename rules 40count29 029figure9 distributionof flow l underdifferentconditions.
indicates that some libraries are more competitive than others and should be recommendedto use instead of the otherlibraries.
as illustrating examples we visualize the sub graphs of three most popular application domains logging testing and json in figure .
we exclude the sub graph for web service due to space constraints.
to make the graphs readable we only retain migration rules l1 l2 withw l1 l2 for testing and json andw l1 l2 for logging.
the unidirectional trend is clearly visible using sankey diagrams.
in the case of logging libraries commons logging andlog4j aretwomostlyabandonedlibraries whilelibrariesundergroupid org.apache.logging.log4j i.e.
log4j2 aremostlyadopted.librariesrelatedto slf4j andlogback aresomewhereinbetween.thereasonforsuch phenomenon may be that thejavacommunity hastwomajorlogging practice changes one is from ad hoc logging libraries e.g.
log4j to logging abstraction libraries e.g.
slf4j another is fromloggingabstractionlibrariestologgingunificationlibraries e.g.
log4j2 .suchmultipleparadigmshiftscanalsobeobserved injsonlibraries e.g.
gson isfirstadoptedbutthen switched tojackson but not obvious in testing libraries.
we can also seethatrenamerulesconstitutealargenumberofmigrationsfor testing and json many non rename rules are omittedinfigure becausetheyhappeninlessthan10projects .inallcases hardly canweseetwolibrarieswithmajorbi directionalflows exceptthe caseofjunit junit andorg.testng testng whichmaybe theresults ofearly competitionwhen bothlibraries areimmature.
summary for rq2 librarymigrationsfromfourdomains logging testing json and web service among dominate the dataset presenting a long tail distribution.
also library migrations are highly unidirectionalinthatmostlibrariesareeithermostlyadopted ormostly abandoned.
484esec fse august athens greece haohe runzhi he haiqiaogu andminghuizhou figure10 themigrationsub graphsforlogging testing andjsonlibraries.migrationsflowfromlefttoright.eachrectangle isagraphnode i.e library andeachgreybandisagraphedge i.e.
migrationrule .foreachedge itsbandwidthencodesthe numberofrepositorieswhere migrationshappened forthismigrationrule.
rq3 whatare the frequently mentionedreasons when developersconducta library migration?
rq1 and rq2 demonstrate howlibrary migrations happen in java software projects but it is still unclear whylibrary migrations happen in these projects.
understanding the latter is important becausewecanextractretrospectiveinsightsforpractitionersby summarizing the rationale behindprevious migrations.
therefore we askrq3 what are the frequently mentioned reasons when developers conduct alibrary migration?
.
methodology toanswerrq3 wechoosetostudydeveloper writtentextsrelated to existing migrations.
we begin with the commit messages of the migration commits m section3.
.
to extend available data we follow github conventions to identify issue