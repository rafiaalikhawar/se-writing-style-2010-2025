see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation lightweight global and local contexts guided method name recommendation with prior knowledge conf erence paper july .
.
citations 41reads author s shang wen w ang national univ ersity of def ense t echnolog y publica tions citations see profile ming wen huazhong univ ersity of scienc e and t echnolog y publica tions citations see profile bo lin national univ ersity of def ense t echnolog y publica tions citations see profile xiaoguang mao national univ ersity of def ense t echnolog y publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y shang wen w ang on july .
the user has r equest ed enhanc ement of the do wnlo aded file.lightweight global and local contexts guided method name recommendation with prior knowledge shangwen wang wangshangwen13 nudt.edu.cn college of computer science national university of defense technology changsha chinaming wen mwenaa hust.edu.cn school of cyber science and engineering huazhong university of science and technology wuhan chinab bo lin linbo19 nudt.edu.cn college of computer science national university of defense technology changsha chinaxiaoguang mao xgmao nudt.edu.cn college of computer science national university of defense technology changsha china abstract the quality of method names is critical for the readability and maintainability of source code.
however it is often challenging to construct concise method names.
to alleviate this problem a number of approaches have been proposed to automatically recommend high quality names for methods.
despite being effective existing approaches meet their bottlenecks mainly in two aspects the leveraged information is restricted to the target method itself and lack of distinctions towards the contributions of tokens extracted from different program contexts.
through a large scale empirical analysis on 12m methods from 14k real world projects we found that the tokens composing a method s name can be frequently observed in its callers callees and tokens extracted from different specific contexts have diverse probabilities to compose the target method s name.
motivated by our findings we propose in this paper a context guided method name recommender which mainly embodies two key ideas apart from the local context which is extracted from the target method itself we also consider theglobal context which is extracted from other methods in the project that have call relations with the target method to include more useful information and we utilize our empirical results as the prior knowledge to guide the generation of method names and also to restrict the number of tokens extracted from the global contexts.
we implemented the idea as cognac and performed extensive experiments to assess its effectiveness.
results reveal that cognac can perform better than existing approaches on the method name recommendation task e.g.
it achieves an f score of .
.
.
and .
respectively on four widely used datasets which all outperform existing techniques and achieve co first and corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
performance than existing techniques on the method name consistency checking task e.g.
its overall accuracy reaches .
outperforming the state of the art mnire by .
.
further results reveal that the caller callee information and the prior knowledge all contribute significantly to the overall performance of cognac .
ccs concepts software and its engineering software maintenance tools maintaining software software evolution .
keywords method name recommendation deep learning code embedding.
acm reference format shangwen wang ming wen bo lin and xiaoguang mao.
.
lightweight global and local contexts guided method name recommendation with prior knowledge.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction the quality of identifier names plays critical roles in the readability and maintainability of source code .
due to the huge amount of information contained towards the semantic of diverse program elements e.g.
variables and classes developers often rely heavily on identifiers for program comprehension .
method names as a special type of identifiers are especially important since they are the smallest named units of aggregated behaviour and also the cornerstone of abstraction in most conventional programming languages .
nevertheless in practice developers often find it hard to name identifiers and they often write inconsistent names in programs due to various reasons such as insufficient communication among development teams and lack of understanding of project development histories .
actually constructing high quality method names is considered as a challenging task especially for inexperienced developers .
it will cause many side effects if a method name does not match its associated method body i.e.
an inconsistent method name .
specifically it can affect the readability and maintenance of theesec fse august athens greece shangwen wang ming wen bo lin and xiaoguang mao code and hence induce potential software defects or api misuses .
for instance abebe et al.
found that inconsistent method names can negatively influence software maintenance activities.
besides butler et al.
also observed that inappropriate names can significantly increase the number of code quality issues detected by static checkers such as findbugs .
to alleviate this problem various approaches have been proposed recently to automatically recommend high quality names given the implementation of a method .
for instance code2vec represents source code using the paths that connect two leaf nodes in the abstract syntax tree ast and then recommends to reuse the name of those methods who share similar syntax structures with the target one i.e.
the method whose name is going to be inferred .
existing studies deem that method names and identifiers are composed of tokens which are split from the name based on the camel case and underscore naming conventions.
for instance identifier methodname is composed of tokens method and name .
mnire then treats method name recommendation as an abstract summarization task based on the seq2seq paradigm and generates the tokens to compose the method names using those extracted from the implementation of the methods .
despite their effectiveness the major limitation concerning the performance of existing techniques is that they only consider the information locally to recommend names.
specifically they only consider the implementation of a method to infer its method name .
however a recent study shows that a large proportion of the method name tokens cannot be observed from the interfaces and implementations of the methods .
in this study we find that such method name tokens can be often observed from the callees of the target method.
besides recent studies have also shown that the information of program dependencies such as the caller callee relations can effectively serve for diverse software engineering tasks .
therefore it motivates us to investigate whether the context information of method call relations can be utilized to better infer appropriate method names.
incorporating more information however will inevitably increase the number of tokens feeding to a recommendation model.
consequently it will bring new challenges since the long sequence input might induce more potential noises and may also reduce the generality of the learned model as revealed by recent studies .
we also observe that those tokens constituting method names tend to occur more frequently in certain contexts e.g.
parameters return types and other types of statements which indicates that the contributions of tokens under diverse program contexts to compose an appropriate method name are different.
therefore we take the following two steps to address the aforementioned challenges.
first we propose to prioritize input tokens utilizing context information to better focus on critical tokens that have higher probabilities to compose method names.
second we adopt a lightweight strategy which restricts the number of tokens extracted from the caller callee methods.
in pursuit of designing a more effective approach to recommend appropriate method names we first performed a large scale empirical study on 14k top starred github repositories with 12m methods to validate our observations and motivations.
we found that the methods that have call relations with the target one can provide abundant information to help infer method names.
in detail the tokens of a caller s method name can be found in its callee either the interface or the implementation for .
of the total cases.
we also found that the tokens extracted from different contexts of a method have diverse probabilities to compose the name of a method.
for instance tokens from the returnstatement generally possess higher probabilities e.g.
nearly .
to compose the target method name than those from other types of statements.
such empirical results confirmed our observations and intuitions.
supported by our empirical findings we propose a contextguided method name re commender cognac which in general follows the seq2seq paradigm to infer method names utilizing program entity names.
in such a paradigm the extracted program entity tokens are rephrased into a short sequence of tokens which forms the recommended method name.
the reason why cognac adopts the seq2seq paradigm is that previous studies have shown the superiorities of code tokens on name prediction .
in particular nguyen et al.
have revealed that purely relying on the representation of code tokens yields better results than that of using the ast or program dependence graph pdg structures for method name recommendation .
although cognac follows the seq2seq paradigm as adopted by the state of the art it embodies two major novel ideas.
first apart from the local context which is extracted from the target method itself including program entity tokens and the associated contexts it also extracts tokens and their contextual information from other methods that possess call relations with the target method.
such information is denoted as the global context which can include tokens from a global perspective to help better infer the name of the target method.
second cognac utilizes the empirical results as the prior knowledge to better focus on the critical tokens.
recall that our empirical study has revealed that the probabilities of tokens under diverse specific contexts to compose method names are different and we denote such probabilities as theprior knowledge in this study.
the prior knowledge is utilized to serve for two main purposes to guide the method name generation as well as to reduce the size of the input sequences.
on one hand different from the state of the art mnire which completely relies on the attention mechanism to decide which tokens to focus on when generating the output token we integrate the prior knowledge with the learned attention weight i.e.
the probabilities of each token from the attention mechanism to focus on those tokens with higher probabilities.
on the other hand we leverage the prior knowledge to limit the number of tokens that are extracted from the callers callees and thus our utilized global context is lightweight .
specifically we only accept the top ten tokens such a number is empirically determined through a pre study experiment from the implementation of each callee prioritized by the prior knowledge.
we exclude the implementation of the caller methods from the input incognac to avoid data leakage since the caller s implementation will definitely contain the target method name.
to evaluate the effectiveness of our approach for recommending high quality method names we trained and tested cognac on totally four different datasets which are the java small java med and java large from alon et al.
and the one constructed by nguyen et al.
containing 1k .5k and more than 10k java projects from github respectively.
we then compared it against totally baseline approaches.
results show that cognac outperforms all thelightweight global and local contexts guided method name recommendation with prior knowledge esec fse august athens greece state of the art approaches by at least .
.
.
and .
on the four datasets respectively w.r.t f score .
moreover we also applied cognac to detect inconsistent method names via checking the lexical similarity between the original method name and the recommended one by cognac following the way as adopted by nguyen et al.
.
specifically we utilized the dataset collected by liu et al.
which includes inconsistent method name cases mined from java projects.
results reveal that cognac outperforms the state of the art mnire significantly the overall accuracy exceeds that of mnire by .
.
furthermore an ablation study shows that all the design decisions i.e.
information from the caller callee methods as well as the guidance from the prior knowledge contribute to the performance of cognac on both tasks among which the information from the callee methods is the most significant one.
specifically without the information from the callee methods the overall performance of cognac will drop by .
.
on the four datasets for method name recommendation.
in summary our study makes the following contributions empirical results our study deepens the understanding towards the naturalness of method names w.r.t their correlations with the caller callee methods and their tendencies to be observed among different contexts.
method name recommendation with cognac we implement a method name recommender that explores not only the local context but also the global context in a lightweight strategy and then generates the method name guided by our prior knowledge .
performance assessment we perform extensive experiments to assess the performance of cognac .
results reveal that cognac achieves overall significantly better performance than the existing approaches on both the method name recommendation and method name consistency checking tasks.
background and related work .
definitions methods are declared and used under certain contexts.
to ease our representation we define several concepts here which will be used in the following contents of this study.
implementation context given a method all the program entities in the method body are referred to as its implementation context .
it includes all names and structures that are used to implement the method.
interface context given a method the types of the input parameters and the return type of this method are referred to as its interface context .
technically it describes the method s input and output.
enclosing context given a method the name of the class in which the method is defined is referred to as the enclosing context .
such context provides the information of the general task purpose of the class where the method is implemented.
call relation given two methods aandb ifbis triggered in theimplementation context ofa then the call relation a bis established where ais the caller while bis the callee .
.
method name recommendation given the critical role of method names in the readability of source code various techniques have been proposed to address the method name recommendation mnr task that is to automaticallygenerate high quality method names.
existing techniques can be broadly categorized into program structure dependent and independent.
we next introduce each of the state of the art in detail.
.
.
program structure dependent.
parsing programs from the ast aspect can obtain the syntax structure information and hence is leveraged by various approaches in program analysis .
mou et al.
proposed a tree based convolutional neural network tbcnn for programming language processing in which a convolution kernel is designed over programs asts to capture the structure information.
recently bui et al.
fused capsule networks with tbcnn to achieve higher learning accuracies based on tree structure.
utilizing ast paths that link any two leaf nodes in asts is an advanced program representation technique .
code2vec and code2seq represent a method body into a distributed vector by aggregating the bag of ast paths with the attention mechanism.
they then recommend to reuse names of the methods who share similar ast structures with the target method.
besides utilizing the structure information from the ast researchers also propose to capture the data flow andcontrol flow information and represent programs as pdg i.e.
program dependency graph to jointly model syntactic and semantic information which is named as gated graph neural network ggnn .
to mitigate the long distance relationship problem within the sequence encoder fernandes et al.
developed a framework to extend existing sequence encoders with a graph neural network sequence gnn .
wang et al.
developed a novel graph neural architecture ginn which unlike the standard gnn focuses exclusively on intervals for mining the feature representation of a program and operates on a hierarchy of intervals for scaling the learning to large graphs.
great is another model that combines long distance information with the structure information.
.
.
program structure independent.
without the guidance from program structures researchers can also rely on the sequence of method tokens to finish the mnr task.
allamanis et al.
introduced a log bilinear neural probabilistic language model for source code which can embed each token into a high dimensional continuous space and select the name that is most similar in this embedding space to those of the function body.
they later considered mnr as an extreme summarization task where the method name is regarded as the summary of the method body and then introduced an attentional neural network that employs convolution on the input code tokens .
mnire follows the seq2seq paradigm to generate the tokens of method names using the sequence composed by tokens from the implementation context interface context and enclosing context of the target method.
hema is a heuristic based mnr approach that is specially designed for getter setter functions and delegations.
we note that a study recently accepted also utilizes call relations to guide the method name generation.
however it significantly differs from our approach in the following aspects.
first the design of cognac is supported by the results of systematic empirical studies.
particularly thanks to the prior knowledge we can represent all input tokens well with a single encoder.
however without the distinction provided by our prior knowledge the existing study needs to use totally four encoders to represent different contexts.
such a design leads to a much more complex model than ours we have calculated that in the encoder part ouresec fse august athens greece shangwen wang ming wen bo lin and xiaoguang mao 1public static list getmenulist return loadconfig listing the getmenulist method in the addressbook project.
model needs to learn .8m parameters while such a number of is .6m .
consequently needs more data and resources to train the model.
on the contrary our model is more generalizable especially when there is limited training data which is critical in language models .
.
method name consistency checking given that inappropriate method names may make programs hard to understand or even lead to program defects researchers also try to solve the method name consistency checking mcc problem which is to automatically check whether the method name is consistent with its implementation.
h st and stvold exploited the java language naming convention for extracting rules of method names which are further used to identify naming bugs .
kim et al.
built a code dictionary from the existing api documents and then detected inconsistent names based on this dictionary.
allamanis et al.
proposed to learn the domain specific naming convention from local contexts to enhance the stylistic consistency including identifier naming and formatting.
with the idea that similar code should be named with similar names liu et al.
separately encoded method names and method implementations.
then given a method named m they considered two sets which are the set of method names that are close tomin the name vector space and the set of method names whose implementations are close to that of min the code vector space.
if the similarity of the two sets is lower than a threshold m is considered as inconsistent.
mnire can also be applied to the mcc task by checking the similarity between the recommended name and the original name of the method.
.
code summarization apart from generating high quality names for methods another perspective to enhance the comprehensibility of programs is to automatically generate natural language descriptions for code .
such techniques have been shown to be feasible for solving program comprehension problems in practice.
for instance panichella et al.
leveraged the coverage information to summarize test cases and the generated test summaries helped developers find more bugs.
a number of source code summarization works emphasize that limiting the consideration scope to the target method itself is insufficient for generating good summaries.
specifically mcburney and mcmillan improved the effectiveness of code summarization techniques by including the information about how the target methods are invoked.
haque et al.
considered the sibling methods within the same file with the target method and used an attention mechanism to find words and concepts to utilize in summaries.
these works also motivate us to investigate if we can perform the mnr task from a global perspective.
motivating examples1public static list loadconfig list list new arraylist list elementlist domutil.getrootelement for object obj elementlist menuitem menu new menuitem menu.setname list.add menu collections.sort list return list listing the loadconfig method in the addressbook project.
1public list refreshticks graphics2d g2 axisstate state rectangle2d dataarea rectangleedge edge list ticks null if rectangleedge.istoporbottom edge ticks refreshtickshorizontal g2 dataarea edge else if rectangleedge.isleftorright edge ticks refreshticksvertical g2 dataarea edge return ticks listing the refreshticks method in the jfreechart project.
in this section we discuss our observations that motivate cognac on method name recommendations.
observation .
tokens composing the target method s name can be frequently observed from its caller and callee methods.
for instance in the method getmenulist as shown in listing of the addressbook project 1there is only one statement calling another method named loadconfig as shown in listing within the method implementation.
unfortunately for the caller method i.e.
getmenulist the tokens of the method name cannot be found in its implementation and insufficient information can be extracted from the implementation context to help us infer the appropriate name.
the only useful information that we can find from itself for guiding method name recommendation is its interface context that is the return type i.e.
list contains certain tokens of the method name.
on the contrary abundant useful information can be extracted from its callee i.e.
the loadconfig method .
specifically all three tokens composing the method name i.e.
get menu and list2 appear in the implementation context of the callee method loadconfig .
such results reveal that the information from the methods that possess call relations with the target method e.g.
callee methods in this example but in general caller methods can also be included might provide extra information for us to suggest more appropriate method names for the target method.
however the majority of existing techniques limit the research scope to the target method itself.
the only one that considers information beyond the target method is mnire which also takes the class name into consideration.
they thus missed the opportunities to leverage more useful information from a global perspective.
observation .
tokens composing the target method s name tend to occur more frequently in specific types of contexts.
for instance considering the method in listing which is from the jfreechart 2please note that the analysis of method name tokens is case insensitive in this paperlightweight global and local contexts guided method name recommendation with prior knowledge esec fse august athens greece project 3its function is to refresh the ticks given a rectangle.
this instance confirms the previous observation from nguyen et al.
which also motivates this study that names of program entities in the implementation context usually carry certain meaning that is related to the intention of the target method.
specifically in this method the two tokens of the method name i.e.
refresh andticks can both be found in the variables names or method invocations in the method body e.g.
ticks andrefreshtickshorizontal .
nevertheless we note that the probabilities of tokens under diverse statement types to compose the method name are different.
in this example lines and are two ifstatements while none of the tokens in these two statements contain the tokens of the method name.
on the contrary although the returnstatement in line contains only one token it exactly matches the tokens of the method name.
such results indicate that for a specific program entity the probability of its name to compose the method name may differ significantly according to its context i.e.
the type of the statement where it locates .
therefore if we use the entity names to predict the tokens that compose the method name incorporating the context information of each program entity can help us better focus on those critical tokens that have higher probabilities to compose the method name.
empirical study .
experiment setup inspired by our observations we further performed an empirical study to investigate whether such observations are pervasive among large scale open source projects.
specifically we aim to answer the following research questions rq1 can the tokens composing the name of a target method be frequently observed in its caller callee methods?
rq2 do the tokens composing the name of a target method tend to occur more frequently in specific contexts than the others?
the answers to these questions provide empirical foundations on whether the information obtained from those caller callee methods can help us better predict the method names and whether the information of different program contexts such as different statement types can be utilized to better predict the method names.
such foundations are of great importance to our approach designs.
data collection and processing.
following a previous study we chose to use the dataset of well maintained and longhistory java projects on github which is collected by allamanis and sutton .
this is a dataset of high quality since all duplicated projects have already been removed and all selected projects have been forked by github users by at least once.
unlike the previous study we only focused on the source code to reduce potential bias in this study.
that means any code from the test files will be excluded in our investigation.
as a result we totally parsed methods in our experiment.
for each investigated method we collected the method s name and all the names of the entities w.r.t the method s implementation context andinterface context .
finally all these names were split into tokens based on the camel case and underscore naming conventions and the obtained tokens were critical frequencies of tokens from caller callee.
number frequency unique caller unique callee call relations caller whose tokens in callee .
callee whose tokens in caller .
caller whose tokens in callee caller whose tokens in callee s interface .
caller whose tokens in callee s implementation .
caller whose tokens in callee s interface uniquely .
caller whose tokens in callee s implementation uniquely .
methods whose tokens cannot be found from itself methods whose tokens not in itself but in its caller .
methods whose tokens not in itself but in its callee .
transformed to their lowercase form following the practices of previous studies .
to extract the global contexts in our study we established call relations via analyzing the names within each methodinvocation ast node in the project.
note that we excluded constructors from this empirical analysis as well as the evaluation of our approach following previous studies .
the behind intuition is that it is unlikely that developers do not know how to name constructors.
.
frequencies of tokens from caller callee critical results from our investigation are illustrated in table .
totally we found call relations with unique callers and unique callees since a method can be involved in multiple call relations .
such figures indicate that on average a method is involved in the call relation for more than once which indicates the pervasiveness of call relations in real world programs and on average a caller method invokes more than two callees .
from the perspective of a caller we found that for all the call relations the tokens composing the caller s method name if any occur in the callee for .
of the cases .
such results indicate that there is a significant portion i.e.
around of callers whose method name tokens can be found in the corresponding callees.
we also investigated in which part of the callee i.e.
the implementation context orinterface context can we observe such tokens.
we found that for all the call relations where the tokens of the caller s name occur in the callees the tokens occur in the interface context of the callees for cases .
while in the implementation context of the callees for cases .
.
more in depth analysis reveals that the method name tokens occur in the interface context of the callee uniquely which means tokens occur only in the interface context of the callee but not in its implementation context for cases while the number of the implementation context is .
such results reveal that the interface context of the callee method can provide abundant information for inferring the caller s name and the implementation context of the callee method can provide more predictive information for its caller s name than its interface context .
from the perspective of a callee since we know that the method name of the callee can definitely be found in the implementation context of its callers i.e.
through method invocations which form the caller callee relation we thus only focused on the interface context of its callers.
we found that for the call relations the tokens composing the callee s method name can be found inesec fse august athens greece shangwen wang ming wen bo lin and xiaoguang mao theinterface context of the callers for .
of the cases.
such results also indicate that the interface context of the caller can provide abundant predictive information for its callee s name.
we also investigated the unique contribution from caller callee methods.
totally we found methods where none of the name tokens can be found locally from the method s implementation context andinterface context .
among them .
methods can find at least one method name token in their callers interface context and .
methods can find at least one token in their callees.
such results indicate that call relations can uniquely contribute to predicting appropriate method names even if the method name tokens cannot be found locally.
the method name tokens of considerable proportions of callers callees .
and .
respectively can be found in their corresponding callees callers which indicate that call relations can contribute significantly to predicting method names.
besides for methods whose name tokens cannot be found locally we can find the tokens in their caller callee methods for a non negligible proportion of cases e.g.
tokens can be found in callees for .
of them .
.
frequencies of tokens under different contexts we investigated whether the tokens composing the name of the target method tend to occur more frequently in specific contexts.
in our study we analyzed the context from two granularities which are thecoarse grained context andfine grained context .coarse grained context denotes the six different sources where the tokens of the target method name can be potentially observed including the target method s implementation context interface context and enclosing context the implementation context of its callees the interface contextof its callees and the interface context of its callers.
note that we included the enclosing context of the target method in this analysis as well as in our approach since a previous study shows that tokens from this context can help infer the name of the target method.
we omitted the implementation context of the target method s callers since they already contain the name of the target method.
fine grained context denotes in this study the specific type of the statement where each token is extracted.
for the interface context we further split it into two sub categories based on where the tokens are extracted which are the returntype and parametertype .
consequently the detailed context can be represented as a pair of elements including the source type and the statement type e.g.
target method implementation context returnstatement callee interface context returntype .
we recorded for each target method the number of tokens under each context and the number of tokens that compose the target method name under each context.
the final statistics are summed over the whole dataset and the probability of a certain type of context is calculated as the number of tokens that compose the target method divided by the total number of tokens under such a context.
we utilize the proportion such calculated to approximate the probability.
note that beyond the statement type there are also other granularities of context information e.g.
the expression type .
we chose to use the statement type in this study since the previous study hastable occurrence probability of tokens from different contexts.
course grained context fined grained context total in method name probability enclosing context classname .
target method interface contextreturntype .
parametertype .
target method implementation contextexpressionstatement .
variabledeclarationstatement .
assertstatement .
whilestatement .
ifstatement .
trystatement .
throwstatement .
switchstatement .
switchcase .
returnstatement .
dostatement .
forstatement .
fielddeclaration .
synchronizedstatement .
caller interface contextreturntype .
parametertype .
callee interface contextreturntype .
parametertype .
callee implementation contextexpressionstatement .
variabledeclarationstatement .
assertstatement .
whilestatement .
ifstatement .
trystatement .
throwstatement .
switchstatement .
switchcase .
returnstatement .
dostatement .
forstatement .
fielddeclaration .
synchronizedstatement .
demonstrated that incorporating too fine grained program information may reduce the overall effectiveness in the task of method name recommendation.
the results are displayed in table .
be noted that there are statement types in the eclipse document while we only list in this table those statements where we observed any method name tokens over the dataset.
we noted that the probability of tokens under different contexts to compose method names differs significantly.
the maximum value is obtained from the returnstatement from the target method implementation context with a probability of around one fifth while the minimum probability is from the trystatement from the callee implementation context whose value is only .
.
we note that both the coarse grained context andfine grained contextcontribute to such differences.
for instance taking tokens from thereturntype contexts for consideration the probability of those tokens extracted from the target method interface context is significantly higher than those from the caller interface context andcallee interface context .
vs. less than .
.
from another perspective for tokens from the target method implementation context those from the returnstatement are much more likely to compose the method name than those from trystatement a probability of .
vs. .
.
such results confirm our intuition in section that the tokens from diverse contexts differ with each other w.r.t the possibility to compose the name of the target method.
the probability of a token to compose the target method name differs significantly according to its contexts.
the maximum probability is nearly two orders of magnitude higher than the minimum one.
methodology in this work we propose cognac a deep learning based approach to recommend high quality names for a given method guided by the global and local context information with prior knowledge.lightweight global and local contexts guided method name recommendation with prior knowledge esec fse august athens greece as a program structure independent approach which does not require the ast or pdg of programs the workflow of cognac is straightforward.
specifically given a method cognac first extracts the targeted tokens from its local contexts as well as its global contexts.
when extracting those tokens cognac also records the specific contexts e.g.
the type of statements where such tokens are collected.
cognac then integrates those tokens as a sequence and sends it into a pointer generator network with the attention mechanism guided by the prior knowledge learned from our empirical study.
finally cognac outputs another sequence of tokens which forms the recommended method names.
the following introduces cognac in detail.
.
key ideas in general our approach adopts the abstractive summarization strategy to generate the tokens of method names from the tokens of both global and local contexts following the state of the art mnire .
such a paradigm is to rephrase extracted program entity tokens into a short sequence of tokens which forms the method name to be recommended.
at each timestep a learned attention weight is used to decide which input tokens to focus on when generating the next output token.
our approach despite falling into such a workflow embodies the following two key ideas.
first in addition to considering the program entity tokens and the associated contexts extracted from the target method which are denoted as the local context we propose to include tokens and their contextual information from other methods that possess call relations with the target one as the global context .
such a design can utilize more useful information from other relevant methods in the project that might contribute to inferring the name of the target method.
second we utilize the empirical results as the prior knowledge to help us better focus on the critical tokens.
recall that the probabilities of tokens under diverse contexts to compose method names are different which have been revealed by our largescale empirical analysis.
such probabilities are hence utilized as the prior knowledge which serves for two main purposes.
on the one hand it is integrated with the learned attention weight to jointly decide which input tokens to focus on under each timestep in the network.
we postulate that such prior knowledge could guide the model to focus more on those critical tokens and thus improve the effectiveness of the learned model confirmed in section .
.
on the other hand we leverage the prior knowledge to limit the number of tokens that are extracted from the callers callees and thus our utilized global context is lightweight .
the behind intuition is that one method can possess call relations with multiple methods cf.
section .
therefore the input token sequence would be too long if taking all tokens from the implementations of caller callee methods into consideration.
such long sequence inputs may introduce potential noises and reduce the generality of the learned model according to previous studies .
we have gained the observation that the caller callee methods interface context can already provide sufficient information to infer the name of target method cf.
section .
.
we therefore decide to consider the interface context of the caller callee methods as well as the top ten tokens in the implementation context of each callee method with the highest probabilities to compose method names we omit theimplementation context of the caller methods to avoid data leakage as aforementioned .
the number is set to ten empirically we performed a pre study experiment using and tokens from theimplementation context of each callee method separately and found that selecting ten tokens achieves the optimum.
we also tried to keep all the tokens in each callee but observed inferior results compared to that of using ten tokens see section .
.
note that in general tokens from the implementation context of the target method possess higher probabilities to compose the method name than those from the implementation context of its callee methods cf.
table .
we therefore take all tokens from the implementation context of the target method into consideration.
.
source extraction given a method the first step of cognac is to extract token sequence that will be used to infer the method name.
we respectively extract the entity names from the enclosing context the interface context of the callers the interface context of the callees the implementation context of the callees the interface context of the target method and its implementation context resulting in totally six sources after which these names are broken into tokens based on the camel cases and underscore naming conventions.
note that to restrict the length of the input sequence we limit the number of tokens extracted from the implementation context of each callee method to be ten.
such tokens are ranked by their probabilities to compose the method name according to their detailed contexts cf.
table and for tied tokens they are further ranked by their orders in the token sequence of the callee method.
for each token we also assign it with an indicator according to the detailed context where it is extracted which could result in totally different indicators shown in table e.g.
enclosing context classname callee implementation context returnstatement .
such indicators will be utilized to provide the prior knowledge in the attention mechanism in our model.
.
pointer generator network a qualified method name generation model should possess two key features first it should be able to generate out of vocabulary oov tokens in its output considering the uniqueness of specific methods second it should be able to generate tokens that does not appear in the input sequence since a non negligible amount of method name tokens cannot be found from our considered contexts .
therefore we adopt a novel pointer generator network in the design of cognac since it satisfies the two requirements.
figure illustrates the overview of the model architecture.
due to page limit we only briefly introduce this model in the paper and more details could be referred to the existing work .
context vector calculation.
as shown in the bottom left part in figure the inputs of cognac are a token sequence where tokens are extracted from both the global context andlocal context along with the contextual indicator i.e.
the probability of the token under such a context as revealed in the empirical study for each token.
the encoder then embeds the tokens into a vector x x1 x2 ... xm and then encodes them into a hidden representation h h1 h2 ... hm through a single layer bidirectional lstm.
at the same time the value of the context indicator of each input token which is listed in table according to the detailed contextesec fse august athens greece shangwen wang ming wen bo lin and xiaoguang mao figure architecture of cognac .
of each input token is recorded as vc vc1 vc2 ... vcm .
at each timestept the attention distribution over the whole input sequence is calculated via summing up the learned distribution and the prior knowledge recorded in vc at softmax et softmax vc whereetis learned using the encoder hidden state and decoder hidden state at this step while vcrepresents the prior knowledge which is the probability of each input token to compose the method name.
then the attention distribution is used to produce the context vectorh twhich can be regarded as the representation of what has been read from the input at this step h t iat ihi.
output generation.
the obtained context vector serves for two main purposes.
first it is jointly learned with the encoder hidden state and decoder hidden state to produce the generation probability pgen at this step which denotes the probability of generating tokens from the fixed vocabulary which is the set of tokens that can be observed in the training dataset.
on the contrary 1pgendenotes the probability of copying a token directly from the input sequence which is to select a token from the input as the output of the current timestep.
second it is concatenated with the decoder hidden state to learn the probability distribution over all tokens in the fixed vocabulary ptoken .
finally the probability of outputting the token wat this step is calculated as p w pgenptoken w pgen i wi wat i where the first part denotes the probability of generating wfrom thefixed vocabulary while the second part denotes the probability of copyingwfrom the input.
loss calculation.
during training the overall loss for the whole sequence is calculated as the average loss at each step which is the negative log likelihood of the oracle word wo tfor that step loss tt t logp wo t evaluation .
research questions to evaluate the performance of cognac we seek to answer the following research questions rq3 how does cognac perform on the method name recommendation task compared with the state of the art?
rq4 how does cognac perform on the method name consistency checking task compared with the state of the art?
rq5 to what extent do diverse design decisions affect the performance of cognac on the above two tasks?
.
the mnr task rq3 .
.
dataset.
to evaluate the effectiveness of cognac on the method name recommendation task we in total used four different datasets.
we first reused three widely adopted datasets in the community constructed by alon et al.
which are named as java small java med and java large containing 1k and .5k java projects from github respectively.
to evaluate the effectiveness of mnire nguyen et al.
built another dataset containing more than 10k java projects .
due to the unavailability of the source code of mnire we can only compare with its reported performance.
therefore in our study we chose to reuse their dataset for fair comparison against the state of the art mnire.
note that the mnire s dataset does not contain fixed training and testing data.
we thus randomly split all the projects in this dataset into training and testing projects following nguyen et al.
.
it should be noted that in all these datasets the training and test examples are shuffled by projects to avoid the performance enhancement caused by file based shuffling .
.
.
metrics.
following previous studies we focused on precision recall and f score for measuring the performance of cognac .
in particular for a specific method whose oracle name is o while the recommended name is r its precision recall and fscore are calculated as precision token r token o token r recall token r token o token o f score precision recall precision recall respectively wheretoken x returns the tokens in the name xsplit by the camel case and underscore naming conventions.
then the performances on the whole dataset are computed as the average values of all the methods in the dataset.
.
.
results.
the results of cognac on the four datasets are listed in table where we also present the results of ten state of the art approaches.
we performed a thorough literature review to include as many state of the art approaches as possible for performance comparison.
we do not include liger since it is applied to c and python languages and the source code is unavailable.
note that we only list the results of other approaches on the datasets where they have also been evaluated.
we found that the values achieved by cognac w.r.t all the three metrics are higher than those from the state of the art on all the four different datasets.
specifically cognac outperforms the stateof the art w.r.t f score by at least .
.
vs. .
from sequence ginn .
.
vs. .
from treecaps .
.
vs. .
from treecaps and .
.
vs. .
from mnire on the four datasets respectively.
we noted that some existing approacheslightweight global and local contexts guided method name recommendation with prior knowledge esec fse august athens greece table effectiveness of cognac on the mnr task in .
dataset approach pre.
rec.
f score java smallsequence ginn .
.
.
sequence gnn .
ggnn .
.
.
code2vec .
.
.
code2seq .
.
.
treecaps .
.
.
great .
.
.
tbcnn .
.
.
cognac .
.
.
java medhema .
.
.
ggnn .
.
.
code2vec .
.
.
code2seq .
.
.
treecaps .
.
.
great .
.
.
tbcnn .
.
.
cognac .
.
.
java largeggnn .
.
.
code2vec .
.
.
code2seq .
.
.
treecaps .
.
.
great .
.
.
tbcnn .
.
.
cognac .
.
.
mnire smnire .
.
.
cognac .
.
.
data of other approaches are extracted from the recent studies .
denotes no relevant information.
can achieve similar performance w.r.t a specific metric compared with cognac e.g.
the precision of code2seq and treecaps are close to that of cognac on the java med dataset .
nevertheless cognac can achieve both high precision and high recall which leads to an overall significant better performance i.e.
f score than existing approaches.
a concrete example here is that when trained on the mnire s dataset cognac recommends listmenu for the method as shown in listing achieving a precision and a recall around .
such a name is semantically similar to the developer provided one which indicates the practical usefulness of cognac .
such a name however cannot be generated if the information from the callee method is ignored indicating the significance of our concerned call relations.
a notable phenomenon is that the performances of cognac on those datasets with more projects i.e.
java large and the mnire s dataset are better than those from the datasets with fewer projects i.e.
java small andjava med .
such results indicate that the sufficiency and diversity of the training data can help enhance the generality of the learned model.
cognac outperforms the state of the art approaches by at least .
.
.
and .
on the four datasets respectively w.r.t f score.
moreover its performances w.r.t different metrics all exceed those from the existing state of the art on all the datasets.
.
the mcc task rq4 .
.
dataset.
to evaluate the effectiveness of cognac on the method name consistency checking task we used the dataset collected by liu et al.
which is also used to evaluate the state ofthe art mnire .
this dataset is collected from well maintainedjava open source projects from four communities namely apache spring hibernate and google.
for the training data they select totally methods excluding main methods and constructors.
for the testing data they select totally methods whose names are inconsistent by parsing the commit history of each project which satisfy the following two requirements the method name should be changed in a commit without any modification on the body code which ensures the change is to fix the method name and the method name and body code should become stable after the change which ensures the fixed version of the name is not revealed to be buggy later on.
after training cognac on the training data we randomly split the testing data into two classes note that the testing data splitting is also random in previous studies .
for the inconsistent class ic we used the buggy versions of the method names and labeled them as inconsistent.
for the consistent class c we used the fixed versions of the method names and labeled them as consistent.
.
.
metrics.
to apply cognac on the mcc task we adopted the same strategy as mnire which computes the similarity sim r o between the recommended name rand the original name o note that for the inconsistent class ic the original name ois the buggy method name while for the consistent class c it is the fixed method name .
specifically such a similarity is defined as the portion of the tokens that are shared between rando sim r o token r token o token r token o .
the consistency of this method is then determined using an empirically decided threshold t. in particular if sim r o t the method is considered as inconsistent otherwise it is classified as consistent.
to measure the performance on the mcc task we used the same metric as previous studies including precision recall and f score for both the icandcclasses as well as the total accuracy .
the above metrics are computed based on the following numbers.
true positive tp an inconsistent name in icis identified as inconsistent false positive fp a consistent name in cis identified as inconsistent true negative tn a consistent name in cis identified as consistent false negative fn an inconsistent name inicis identified as consistent.
therefore for the icclass precision tp tp fp andrecall tp tp fn .
for thecclass precision tn tn fn andrecall tn tn fp .
for both the ic andcclasses the f score is calculated as2 precision recall precision recall.
the accuracy on the whole dataset is defined as tp tn tp fp tn fn .
note that whether cognac identifies a specific method name as consistent or not depends on the similarity threshold t. in the previous study the authors vary the similarity threshold tin the range of .
and separately report the maximum values of f score on theicandcclasses and the maximum accuracy .
however we never know a method name is consistent or not before the detection in practice.
therefore we decide to set the tas a fixed value.
specifically in our study to determine the threshold we chose the value where the overall accuracy reaches the maximum which is is .
in this study.
.
.
results.
the results of cognac and the existing state of theart are listed in table .
we noted that cognac achieves the highest overallaccuracy which outperforms mnire by .
.
vs.esec fse august athens greece shangwen wang ming wen bo lin and xiaoguang mao table effectiveness of cognac on the mcc task in .
liuet al.
mnire cognac icprecision .
.
.
recall .
.
.
f score .
.
.
cprecision .
.
.
recall .
.
.
f score .
.
.
accuracy .
.
.
table performance of variants of cognac on the mnr task in .
modeldataset java small java med java large mnire s f f f f no caller information .
.
.
.
.
.
.
.
no callee information .
.
.
.
.
.
.
.
no prior knowledge .
.
.
.
.
.
.
.
cognac original model .
.
.
.
denotes performance degradation.
.
.
for the icclass cognac s precision recall and f score are .
.
and .
higher than those of mnire respectively.
such results reveal that compared with mnire cognac can detect more inconsistent method names and the method names that are labelled as inconsistent are more likely to be the real inconsistent ones.
for thecclass we observed that the precision of cognac is much higher than that of mnire .
vs. .
while the recall ofcognac is much lower than that of mnire .
vs. .
.
such phenomenon could be caused by the fact that mnire adopts a varying threshold t. specifically for mnire the threshold used for thecclass is lower than that for the icclass the consequence of which is that more names are labelled as consistent we recall that a method name is labelled as consistent if the similarity exceeds the threshold hence the lower the threshold is the more names will be labelled as consistent .
consequently its recall w.r.t the c class is high.
on the contrary we set a fixed value for t which may prevent many method names from being labelled as consistent.
nevertheless cognac still achieves the highest f score on this class which exceeds that of mnire by .
.
vs. .
.
with a fixed threshold cognac still outperforms the state of the art approaches on the mcc task significantly.
specifically its overall accuracy exceeds that of mnire by .
and it outperforms mnire by .
w.r.t f score for detecting inconsistent method names.
.
ablation study rq5 .
.
experiment setting.
we in this rq investigated the influences from three factors on the performance of cognac which are the tokens from the caller callee methods respectively and the prior knowledge.
note that in the ablation study the contribution of the prior knowledge refers to its guidance on method name generation see equation .
in the first two experiments we omitted tokens from the caller methods and callee methods respectively in the input token sequence.
in the last one we omitted the prior knowledge which means we only used the learned matrix etto decide the attention distribution in equation .
we performed such experiments on both the mnr task and mcc task.
.
.
results.
results of the ablation study on the mnr task are demonstrated in table .
generally speaking all our model decisions make contributions to the final performance more or less.
fortable performance of variants of cognac on the mcc task in .
modelic c accuracy f f no caller information .
.
.
.
.
.
no callee information .
.
.
.
.
.
no prior knowledge .
.
.
.
.
.
cognac original model .
.
.
denotes performance degradation.
instance if we do not use the prior knowledge to guide the attention weight putting on each input token the overall performance w.r.t f score will be decreased by .
.
on the four datasets.
we noted that the information from the callee methods contributes the most to the overall performance of cognac among the three factors without which the f score will degrade the most on all the four datasets.
specifically if the tokens from the callee methods are not included the f score ofcognac will be decreased by on the java med dataset which is the largest degradation we witnessed in this ablation study.
on the other hand the contribution from the caller methods is relatively small without which the degradation is only .
.
on the four datasets.
such results could be caused by the fact that we only include the interface context of the caller methods recall that we have excluded the tokens of the implementation context from the callers to avoid data leakage .
however the implementation context of the callee methods are included in our approach since there is no data leakage.
we also noted that the contribution from our prior knowledge is non negligible without which the performances of cognac could not exceed those achieved by the existing approaches.
for instance cognac achieves an f score of .
without the prior knowledge on the java small dataset while the value of sequence ginn is .
.
this confirms our intuition that incorporating the context information with prior knowledge can help our model better capture the critical information and thus improve its effectiveness.
similar trends can be observed from the results of the ablation study on the mcc task which are shown in table .
for the mcc task the callee information is still the major part that contributes to the overall performance of cognac without which the accuracy and thef scores on theicandcclasses will be decreased by .
.
and .
respectively.
the prior knowledge still plays a significant role.
for instance without the guidance from the prior knowledge the f score ofcognac on thecclass will reach only .
a reduction of .
lower than that of mnire .
.
all the design decisions in cognac contribute to its outstanding performance among which the information from the callee methods is the most rewarding one.
specifically if omitting the tokens from the callee methods cognac will suffer from decreases of .
.
.
and .
w.r.t f score on the four datasets on the mnr task as well as a decrease of .
w.r.t accuracy on the mcc task.
discussion .
performance enhancement from the pointer generator model we note that the seq2seq model in the existing approach mnire is simple it is only capable of generating tokens from the fixed vocabulary while is unable to copy a token from the input.
on thelightweight global and local contexts guided method name recommendation with prior knowledge esec fse august athens greece contrary our cognac adopts a novel pointer generator model which is capable for both generating tokens from the fixed vocabulary and copying from the input tokens.
nonetheless the superiority of cognac is still majorly attributed by the caller callee information and the utilized prior knowledge.
specifically we demonstrate this via the following experiment.
we implemented a simple seq2seq model which still incorporates the prior knowledge i.e.
the way to calculate the attention weight is identical to the original cognac .
the difference between this model and the original cognac is that in equation the pgenalways equals to which means that it is incapable of copying tokens from the input.
we then trained and tested this model on the mnire s dataset.
the experimental results show that this model achieves an overall performance of .
w.r.t f score which is much higher than that from mnire .
but only slightly lower than that from the original cognac .
.
this is reasonable considering that the pointer generator model is proposed to mainly deal with the oov tokens while the number of oov tokens could be rather limited if the training dataset is large enough in our study it contains methods from projects .
such results indicate that cognac outperforms the existing approaches mainly due to the integrated caller callee information and the prior knowledge.
the adopted novel pointer generator model helps it reach the optimum.
.
rationality of the lightweight strategy in our approach we utilize the global context in a lightweight manner that is to limit the number of tokens extracted from the implementation context of each callee method to be .
the behind intuition is that we have demonstrated through our empirical analysis that on average a caller calls more than two callees and thus the input token sequences for these methods could be rather long if we consider all their implementations.
training on such long input sequences could reduce the generality of the learned model as revealed by the previous studies .
to demonstrate the rationality of this decision we performed another experiment where we used all tokens from the implementation context of the callee methods in cognac and then assessed its performances w.r.t the mnr task.
results show that cognac achieves .
.
.
and .
respectively on the four different datasets for the mnr task w.r.t f score thus witnessing a degradation of .
.
.
.
respectively.
this could be explained as too much noisy data in the input reduces the generality ofcognac .
such results reveal that the performances of cognac will be significantly compromised if the information is utilized inappropriately therefore our lightweight strategy to utilize the global context is reasonable.
.
threats to validity a threat to validity is that we only focus on the java programming language pl .
hence all findings and evaluation results are restricted to this domain.
being that said the principle of cognac it not limited to one specific pl.
it would be interesting to investigate the performance of cognac on other pls such as c and compare against other existing approaches like liger .
however it requires another large scale empirical analysis to build the prior knowledge and thus we leave it as future work.another threat is that it is impossible to ensure that all of the methods in our empirical dataset have consistent names.
consequently the constructed prior knowledge might be biased.
to address this threat we choose to use a dataset composed of highquality and well maintained open source projects .
furthermore literature approaches always assume that most of the names from top ranked high quality projects are good .
such an assumption can be backed up by the fact that during preparing the dataset for the mcc task only among totally methods i.e.
.
are found to be inconsistent.
moreover such noises are actually acceptable for learning based techniques since they are supposed to learn common features from the majority instead of the minority.
therefore even if names in our datasets are not always of high quality their impacts are limited.
besides we choose to use the statistical metrics e.g.
precision and recall as adopted by previous studies to evaluate and compare the performance of cognac .
unfortunately whether a recommended name is really helpful for developers in practice remains unknown and is left as our future work.
.
application scenario we briefly discuss the application scenario of cognac .
we recall that the inputs of our approach are the class name the interface context of callers the interface implementation context of callees and the interface implementation context of the target method.
that means we actually do not need to know how the target method should be invoked since we excluded the implementation of callers.
therefore we do not need to arbitrarily name a method and then run our approach to verify the name after implementation.
on the contrary we can perform just in time name recommendation after obtaining the implicit calling relations to acquire the global contexts which is also required by .
therefore the application scenarios ofcognac aremethod name recommendation after obtaining the calling relations and method name inconsistency checking after a whole project has been implemented.
conclusion we introduce cognac a deep learning based approach to recommend high quality method names.
the key observations in this paper obtained through a large scale empirical analysis are call relations can be utilized for better inferring method names and tokens under diverse specific contexts generally possess different probabilities to compose the method name.
therefore we implemented cognac which takes into consideration the caller callee methods of the target one to incorporate more information and utilizes the empirical results as prior knowledge to better focus on critical information.
evaluation results show that cognac can achieve significantly better results than the state of the art on both the tasks of method name recommendation andmethod name consistency checking .
artifacts all data in this study are publicly available at .