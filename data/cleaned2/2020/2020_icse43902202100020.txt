semantic patches for adaptation of javascript programs to evolving libraries benjamin barslev nielsen aarhus university barslev cs.au.dkmartin toldam torp aarhus university torp cs.au.dkanders m ller aarhus university amoeller cs.au.dk abstract javascript libraries are often updated and sometimes breaking changes are introduced in the process resulting in the client developers having to adapt their code to the changes.
in addition to locating the affected parts of their code the client developers must apply suitable patches which is a tedious errorprone and entirely manual process.
to reduce the manual effort we present jsfix .
given a collection of semantic patches which are formalized descriptions of the breaking changes the tool detects the locations affected by breaking changes and then transforms those parts of the code to become compatible with the new library version.
jsfix relies on an existing static analysis to approximate the set of affected locations and an interactive process where the user answers questions about the client code to filter away false positives.
an evaluation involving popular javascript libraries and clients shows that our notion of semantic patches can accurately express most of the breaking changes that occur in practice and that jsfix can successfully adapt most of the clients to the changes.
in particular clients have accepted pull requests made by jsfix indicating that the code quality is good enough for practical usage.
it takes jsfix only a few seconds to patch on average .
source locations affected by breaking changes in each client with only .
questions to the user which suggests that the approach can significantly reduce the manual effort required when adapting javascript programs to evolving libraries.
i. i ntroduction the javascript based npm ecosystem consists of more than a million packages most of them libraries used by many javascript applications.
libraries constantly evolve and client developers want to use the latest versions to get new features and bug fixes.
however not all library updates are backwards compatible so the client developers may be discouraged from switching to newer versions of the libraries because of changes that break the client code.
currently to update a client to a new major version of a library the client developer needs to examine the changelog to discover which parts of the client code are affected by breaking changes and find out how to adapt the code accordingly a process which is entirely manual errorprone and time consuming.
existing tools such as github s dependabot 1only warn about outdated dependencies and provide no other assistance in this process.
a detection pattern language and an accompanying analysis tapir have recently been proposed for finding locations in client code affected by breaking changes .
inspired by the tool in this paper we build on top of tapir and introduce a notion of code templates for expressing how to also patch the affected locations.
paired with a detection pattern a code template forms a semantic patch.
provided with a collection of semantic patches specifying where breaking changes occur the detection patterns and how to adapt the affected code the code templates for a library update our tool jsfix can semi automatically adapt clients to become compatible with the new version of the library.
a run of jsfix goes through three phases an analysis phase based on the tapir analysis for over approximating the set of affected locations an interactive phase for filtering away false positives from that set and a transformation phase for adapting the client code using the code templates.
in the interactive phase jsfix asks the user a set of yes no questions about the behavior of the client code to remedy inherent limitations in the tapir analysis all those questions concern properties the client developer would have to consider anyway if performing the patching manually.
we envision that semantic patches can be written either by the library developer or by someone familiar with the library code along with the customary changelogs.
with jsfix all the clients of the library then benefit from the mostly automatic adaptation of their code and the client developers do not need to understand the notation for semantic patches .
to summarize the contributions of this paper are we propose a notion of code templates to formalize the transformations required to adapt client code to typical breaking changes.
a tapir detection pattern together with a code template form a semantic patch.
we present the jsfix tool which based on a collection of semantic patches semiautomatically adapts client code to breaking changes in a library update sections iii and iv .
we propose an interactive mechanism for filtering away false positives from the detection pattern matches reported bytapir section v .
we present the results of an evaluation based on major updates of popular npm packages and clients showing that most breaking changes can easily be expressed as semantic patches and that jsfix in most cases succeeds in making the clients compatible with the new versions of the libraries.
furthermore the evaluation demonstrates the practicality of jsfix .
it takes only a few seconds to patch ieee acm 43rd international conference on software engineering icse .
ieee import observable from rxjs observable import subject from rxjs subject import rxjs add observable timer import rxjs add operator takeuntil import defaultifempty take takeuntil tap from rxjs operators import timer subject from rxjs const c new subject .take observable .timer warntimeout .takeuntil c .defaultifempty true .do ... .subscribe const c new subject .pipe take timer warntimeout .pipe takeuntil c .pipe defaultifempty true tap ... .subscribe fig.
excerpts from redux logic before marked with red background and and after green and adapting to the breaking changes in the library rxjs .
.
.
on average .
affected locations per client with only .
questions to the user and pull requests based on the output from jsfix have been accepted which shows that the quality of the patches is good enough for practical use section vi .
ii.
m otivating example the rxjs library 2with more than million weekly downloads is a popular library for writing reactive javascript applications.
in april rxjs was updated to version .
.
a massive major update introducing many new features bug fixes and performance improvements but unfortunately also many breaking changes.
our manual investigation of the rxjs changelog shows that it contains at least separate breaking changes many of which involve multiple functions and modules.
the developers of rxjs who were probably well aware that these breaking changes would discourage many client developers from upgrading decided to create both an auxiliary compatibility package that introduces temporary workarounds and a migration guide detailing how clients should adapt to all the breaking changes in the new version of rxjs.
while the migration guide is quite helpful and also not something provided with most major updates of other libraries it may still take a significant amount of work for a client developer to upgrade to rxjs .
.
.
consider for example the redux logic package that depends on rxjs.3in september redux logic was updated to depend on rxjs .
.
.
this update required additions and deletions to files over commits 4by no means a small task.
figure shows two excerpts of the update of redux logic to rxjs .
.
modulo some newlines and insignificant differences in variable naming .
the first change is that observable is no longer imported from rxjs observable as in line in fact 4counted using git s notion of additions and deletions.it is not imported at all.
this is because the timer function observable .timer in line in rxjs .
.
should be accessed directly from rxjs as can be seen by the import in line .
therefore line is also updated to use timer directly.
the second change is that subject should be imported from rxjs instead of rxjs subject which is why the import in line is replaced with the import of subject in line .
the imports in lines add properties to observable and rxjs observables through observable .prototype but have been removed in the new version.
instead of using those properties the functions should now be imported from either rxjs or rxjs operators as can be seen in the imports on lines and .
line used one of these properties take which in the new version should be replaced with a call to .pipe where the operator function take is then provided as an argument as shown in line in the patched code.
for the same reason lines have been updated to use .pipe in lines .
evidently adapting client code to breaking changes in a library can be difficult and time consuming so tool support is desirable.
while the redux logic example is one of the more extreme cases it clearly demonstrates that updating dependencies is no minor undertaking.
considering that the average npm package already in had an average of direct dependencies and that number has been growing over time keeping everything up to date becomes insurmountable.
using jsfix it would have been possible for the reduxlogic developer to adapt the client code almost automatically.
given a collection of semantic patches that describe the breaking changes in the library jsfix is designed to both find the locations in the client code that are affected by the breaking changes and to adapt those parts of the client code to the new version of the library.
the analysis that finds the affected locations is designed such that it leans towards overapproximating meaning that it may flag too many source code locations as potentially requiring changes but rarely too few.
when it cannot establish with complete certainty whether some source location is affected by the breaking changes it asks the client developer for advice.
in this specific case the reduxlogic developer would only have to answer simple yes no questions which all concern only redux logic notrxjs .
for transforming the excerpts shown in figure jsfix does not ask any questions.
however suppose the analysis were too imprecise to determine that c on line is an rxjs observable then jsfix would have asked this question src createlogicaction .js is the receiver an rxjs observable?
all the questions are of this kind but with different source code locations and they all originate from such analysis imprecision.
with the help from the redux logic developer the uncertainty can be resolved and the patches produced by jsfix for the affected locations successfully adapt the reduxlogic source code to the new version of the rxjs library.
comparing the jsfix autogenerated transformations with the patches made manually by the developer of redux logic shows that the transformations are identical ignoring white space and the order of property names in imports .
75iii.
o verview the tool jsfix is designed to adapt client code to breaking changes in libraries.
an execution of jsfix is divided into three phases an analysis phase an interactive phase and a code transformation phase.
as input it takes a client that depends on an old version of a library together with a collection of semantic patches that describe the breaking changes in the library.
each semantic patch contains a detection pattern that describes where a breaking change occurs in the library api and a code template that describes how to adapt the client code.
we explain the notion of semantic patches in more detail in section iv.
as output jsfix produces a transformed version of the client that under certain assumptions described in section v preserves the semantics of the old client code but now uses the new version of the library.
the analysis phase uses the tapir light weight static analysis to detect locations in client code that may be affected by breaking changes in the library.
we treat tapir as a blackbox component as it is only loosely coupled with the other phases of jsfix .
the input to tapir consists of the client code and the detection patterns coming from the semantic patches and as output it produces a set of locations in the client code that match the detection patterns meaning that they may be affected by the breaking changes in the library.
being fully automatic tapir cannot always find the exact set of affected locations but the analysis is designed such that it leans towards over approximating meaning that it sometimes reports too many locations but rarely too few.
moreover it is capable of classifying each match being reported as either a high or a low confidence match.
in practice all false positives appear among the low confidence matches meaning that only those need to be manually validated.
in jsfix we take advantage of that confidence information.
in the second phase of jsfix it asks the user for help at each low confidence match such that the false positives from tapir can be eliminated.
the text for the questions to the user comes from the semantic patches.
the questions all take yes no answers and they concern only the client code not the library code.
we describe the interactive phase in more detail in section v where we also give additional representative examples of questions presented to the user.
next jsfix runs a transformation phase where the client code is patched to adapt to the changes in the library.
the transformations are specified using a form of code templates that specify how each affected location should be transformed to become compatible with the new version of the library.
the transformation process is explained together with the notation for semantic patches in the next section.
iv.
a s emantic patch language to adapt client code to breaking changes in a library the parts of the client code that use the affected parts of the library api must be transformed accordingly.
example lines in the following program use the maxfunction from the lodash library.
var require lodash .max coll iteratee thisarg .max coll iteratee .bind thisarg the optional third argument on line thisarg lets the client specify a custom receiver of the second argument iteratee .
in version .
.
of lodash the support for the third argument was removed from 64functions including the maxfunction.
to restore the old behavior clients using maxor one of the other functions would have to explicitly bind thisarg to iteratee .
for example for the program above line has to be transformed by inserting a call to bind as shown on line .
example lines in the program below use the async library s queue data structure which holds a queue of tasks asynchronous functions to be processed.
var async require async var q async.
queue ... q .drain console .log done q .drain console .log done on line a function is written to the drain property of the queue.
in version of async this function is called when all tasks in the queue have been processed.
however in version ofasync drain is no longer a property the client should write but instead a function the client should call.
the function to be called once the queue has been processed is then passed as an argument to drain .
hence the call to drain must be transformed as shown on line .
example lines below import the find and map functions from the rxjs library.
import find from rxjs operator find import map from rxjs operator map import find map from rxjs operators in version of rxjs these import paths rxjs operator find and rxjs operator map are no longer available.
instead clients must import the functions from rxjs operators as demonstrated by the transformed import on line .
to automate the transformation of the client code we define a suitable notion of semantic patches.
a semantic patch models a breaking change and consists of a detection pattern that identifies the affected part of the library api the affected location and a code template that describes how client code that uses that part of the api can be transformed to adapt to the new version of the library.
a semantic patch can also contain question text for the interactive phase which we describe in section v. the detection patterns are identical to the patterns used by the api access point detection tool tapir so we omit a detailed description of the pattern language in this paper.
although we treat the accompanying algorithm that performs the matching between the patterns and the client code as a black box as mentioned in section iii we provide intuitive explanations of the meaning of the concrete detection patterns that appear in examples in the remainder of this paper.
to adapt a client that uses some library with breaking changes for example to perform the transformations in examples we need a mechanism for specifying the 2expression .
.
.
j refelement refelement j moduleelement j ireplacer?
refelement prop replacer?jvalue jbase j callee jijargs selector?
replacer s1 s0 .
.
.
sn s0 n selector j moduleelement sj j ireplacer?
fig.
grammar for code templates.
the in the first production refers to the ordinary constructs of javascript expressions.
the notation x x?
andx mean zero or more zero or one and one or more occurrences of x respectively.
the meta variable sranges over strings iranges over positive integers and jandkrange over integers.
required transformations.
for this purpose we introduce the notion of a code template which is an incomplete javascript expression that has one or more missing pieces or holes that must be instantiated with other javascript expressions for the template to become a syntactically valid javascript expression.
we can view a code template as a form of meta program that takes one or more expressions as input and then interpolates these expressions into the holes of the template to form a valid javascript expression.
the key idea behind the templating mechanism is that the holes of the template are instantiated with code from the vicinity of the location in the client code that is matched by the detection pattern .
a detection pattern can either match a call a property read a property write or a module import.
in a transformation parts of the subtree of the matched ast node have to be replaced as in example or in some cases the kind of the matched ast node has to change as in example where a property write operation is changed into a method call .
in either case the variable names and literals used in the original client code typically also have to appear in the transformed version of code for the transformation to be correct.
for example it is essential that the function written to the drain property on line is the same function passed to the drain function on line .
to facilitate these kinds of transformations we introduce an ast reference notation that is used to specify both the holes of the templates and how expressions should be retrieved for these holes.
the idea is that one can use this notation to interpolate expressions into the template where these expressions are retrieved relative to the ast node matched by .
for example if matches a call node then an ast reference can be used to obtain for example the receiver or the arguments of that call.
while ast