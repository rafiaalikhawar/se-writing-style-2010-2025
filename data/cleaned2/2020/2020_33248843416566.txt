on the effectiveness of unified debugging an extensive study on program repair systems samuel benton the university of texas at dallas samuel.benton1 utdallas.eduxia li kennesaw state university xli37 kennesaw.edu yiling lou peking university louyiling pku.edu.cnlingming zhang university of illinois at urbana champaign lingming illinois.edu abstract automated debuggingtechniques including faultlocalization and program repair have been studied for over a decade.
however the onlyexistingconnectionbetweenfaultlocalizationandprogramrepairisthatfaultlocalizationcomputesthepotentialbuggyelements for program repair to patch.
recently a pioneering work profl explored the idea of unified debugging to unify fault localization andprogramrepairintheotherdirectionforthefirsttimetoboost both areas.
more specifically profl utilizes the patch execution resultsfromonestate of the artrepairsystem prapr tohelpimprovestate of the artfaultlocalization.inthisway proflnotonly improves fault localization for manual repair but also extends the application scope of automated repair to all possible bugs not only thesmallratioofbugsthatcanbeautomaticallyfixed .however profl only considers one apr system i.e.
prapr and it is not clearhowotherexistingaprsystemsbasedondifferentdesigns contributetounifieddebugging.inthiswork weperformanexten sivestudyoftheunified debuggingapproachon16state of the art program repair systems for thefi rst time.
our experimental results on the widely studied defects4j benchmark suite reveal variouspractical guidelines for unified debugging such as nearly all thestudied16repairsystemscanpositivelycontributetounified debugging despite their varying repairing capabilities repairsystems targeting multi edit patches can bring extraneous noise intounifieddebugging repairsystemswithmoreexecuted plausible patchestend toperform better forunified debugging and unified debugging effectiveness does not rely on the availability of correctpatchesinautomatedrepair.basedonourresults wefurther proposeanadvancedunifieddebuggingtechnique unidebug whichcanlocalizeover20 morebugswithintop 1positionsthan state of the art unified debugging technique profl.
this work was mainly done when they are visiting phd students at ut dallas.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on thefi rst page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
concepts software and its engineering software testing and debugging.
keywords unified debugging program repair fault localization acm reference format samuelbenton xiali yilinglou andlingmingzhang.
.ontheeffectiveness ofunified debugging an extensivestudy on16 programrepair systems.
in 35th ieee acm international conference on automated software engineering ase september virtual event australia.
acm new york ny usa pages.
introduction withtherapiddevelopmentofinformationtechnology software systems have been widely adopted in almost all aspects of modern society.
however software bugs also called software faults in this paper areinevitablebecauseofthecomplexityofmodernsoftware systems.
software faults can cause software systems to crash or perform unexpected behaviors both scenarios resulting in disas ter e.g.
costing trillions of dollars infi nancial loss and affecting billionsofpeople .inpractice softwaredebuggingisessential forremovingbugsfromexistingfaultysoftwaresystems.manual debugging however can be extremely challenging tedious andcostly.
such impediments consume over of the development time effort and cost the global economy billions of dollars .
to date a huge body of research effort has been dedicated to automateddebuggingtorelievedeveloperburdens investigating both fault localization and automatedprogramrepair techniques.
fault localization aims to precisely localize buggy elements within a buggy system based on dynamic and or static programanalysis andcanautomaticallyproducearankedlistof suspiciouscodeelementsfordevelopers reducingtheireffortfor manual bug checking.
classic spectrum based fault localization sbfl techniques mainly analyze the statistical correlation between code coverage and test outcomes to infer potential buggylocations.forexample acodeelementprimarilyexecuted byfailedtestsarelikelytobemoresuspicious.however usingonly coverage information may not be precise enough.
therefore researchersfurtherproposemutation basedfaultlocalization mbfl techniques by further considering the impact information between mutated code elements and tests simulated via mutations .
recently machine learning techniques have been used 35th ieee acm international conference on automated software engineering ase to combine various dimensions of debugging information for more powerful fault localization .
whilefaultlocalizationstillrequiresmanualrepair automated programrepair apr aimstodirectlyfixsoftwarebugsautomatically with minimal human intervention.
a typical test driven apr techniquetakesafaultyprogramanditstestsuiteasinputandgeneratesprogrampatcheswiththeendgoaltofindapatchpassingalltests.duetoitspromisingfuture variousaprtechniqueshavebeen proposed including search based semantics driven and learningbasedtechniques .formoredetails pleaserefer to recent surveys on fault localization and apr .
despiteextensiveresearchonautomateddebuggingoverthepast decades we still lack practical automated debugging techniques.current fault localization techniques has limited effectiveness in practice theyeitherrequiremassivetrainingdatathatmaynot always be available or are ineffective for debugging realworld systems .
furthermore it is rather challenging for apr techniques tofi x all possible bugs even state of the art apr techniques can onlyfi x a small ratio of real bugs i.e.
for defects4j automatically.
toenablemorepracticaldebugging theunifieddebuggingapproach profl wasrecentlyproposedtounifyfaultlocalizationand apr to boost both areas .
while both fault localization and apr havebeenstudied forover adecade theironly priorconnection is that fault localization is leveraged as a supplier for pointing out potentially buggy locations for apr tofi x. the unified debugging approach profl unifies the two areas in the other direction forthefirsttime i.e.leveraginglargenumberofpatchexecutionre sults generated during apr even when apr fails tofi x the bug tofurtherboostfaultlocalization.thebasicintuitionisthatifapatch passessomeoriginallyfailingtest s thepatchedlocationisvery likely to have some close relationship with the real buggy location e.g.
sharing the same method or even same line since otherwise thepatchcannotmutethebugimpactandpasstheoriginallyfailing test s .
using the recent prapr apr system profl is able to substantially boost outperform state of the art sbfl mbfl and unsupervised supervised learning based fault localization .
in this way given any buggy project profl not only directly returnsthepatcheswhen automatedrepair works butalsoprovides improved fault localization hints for manual repair for all other cases.
that is profl not only significantly improves fault localization formanual repair but also extends the application scope of automated repair to all possible bugs not only the small portion of bugs that can be automaticallyfi xed .
despite this promising direction the profl work only considers one apr system i.e.
prapr while there are many other available apr systems based on different designs and it is not clear how other apr systems contribute to unified debugging.
therefore tobridgethisgap weconductthefirstextensivestudyofunified debuggingon16state of the artaprsystems.these16systems represent recent public java apr systems that execute without requiringspecializeddataorinfrastructure.theseselectedsystems utilize constraint based heuristic based and template based repair approaches seen in recent repair literature.
furthermore we use thedefects4j benchmark suitefor ourevaluationsinceitisthemostwidelyusedbenchmarkinrecentfaultlocalizationandaprwork includingtheunifieddebugging work .ourexperimentalresultsrevealvariouspracticalguidelinesforfurtheradvancingunifieddebuggingandevensoftware debugging in general.
to summarize this paper makes the following main contributions study.thispaperpresentsthefirstextensivestudyofunified debugging using state of the art apr systems.
dataset.
our detailed experimental data including patch executioninformation experimentalscript andresultanaly sisforfaultlocalization apr andunifieddebugging onthe studied defects4j subjects are publicly available online .
guidelines.
our study reveals various practical guidelines including nearly all the studied apr tools can pos itively contribute to unified debugging despite their varying repairing capabilities apr tools targeting multi edit patches bring noise and degrade performance for unified de bugging aprtoolswithmoreexecuted plausiblepatches tend to perform better for unified debugging and unifieddebuggingeffectivenessdoesnotexclusivelyrelyonthe availability of correct patches from apr.
technique.
based on our study results we further proposeanadvancedunifieddebuggingtechnique unidebug whichcanlocalize21 morebugswithintop 1thanstateof the art unified debugging technique profl.
studied approach in this section wefi rst briefly discuss the traditional fault localizationandprogramrepairprocess section2.
tomotivateunified debugging.
then we present the basic process for the studied unifieddebuggingprocess section2.
.lastly wepresentareal world example to further motivate our study in this paper section .
.
.
fault localization and program repair given a buggy program and its failing test suite test based fault localization computes each code element s probability to be buggy based on various techniques .
for example the widely studied spectrum based fault localization sbfl willcollectthedynamiccoverageinformationforeachfailing passingtesttocomputeeachcodeelement ssuspiciousnessvalue.in thisway developerscanchoosetodirectlystart manualrepair with the help of such suspiciousness information.
alternatively developerscanalsochoosetodirectlyperform automated program repair apr .
typical apr techniques leverage fault localization techniques to compute the potential buggylocationsforpatching e.g.
theochiaisbfltechniquehas been widely used in recent apr work such as prapr simfix andcapgen .afterthepatchgenerationandvalidation all theplausible patches i.e.
the patches that can pass all tests are returned for manual inspection tofi nd thefinal correct patches i.e.
thepatchessemanticallyequivalenttodeveloperpatches .inthis way thefinalcorrectpatchesaretheonlyusefuloutcomefromapr in fact even plausible but incorrect patches are treated as harmful intraditionalaprwork sincetheyrequiretime consuming and tedious manual inspection.
however to date even state ofthe artaprcanonlyproducecorrectpatchesforasmallratioof real world bugs making apr a waste of resources for all the other 908figure unified debugging cases.forexample thecurrentmosteffectiveaprwork cannotevenfix20 ofbugsfromthewidelystudieddefects4j .
.
unified debugging to further boost both the fault localization and apr areas unified debugging aims to unify these two areas from the other directionforthefirsttime.thebasicinsightofunifieddebuggingis thatthemassivepatchexecutioninformationfromapr evenones thatdonotleadtocorrectpatches canfurtherhelpsubstantially improvefaultlocalizationtofacilitatemanualrepair.inthisway unifieddebuggingcanreportcorrectpatcheswhenpossible and moreimportantlycanalsoreturnrefinedfaultlocalizationforall cases even the cases without correct patches .
unified debugging not onlyextends theapplication scopeof aprto allpossible bugs notonlythebugsthatcanbedirectlyautomaticallyfixed butalso providesmoreprecisefaultlocalization.forexample profl thefi rst unified debugging technique based on the recent prapr aprsystem significantlyimproves outperforms variousstate ofthe artfaultlocalizationtechniques e.g.
sbfl mbfl and even learning based techniques .
the basic assumption of unified debugging is that if a patch can pass some originally failing tests its patch location may be closely related to the actually buggy locations e.g.
sharing the same code element such as method .
similarly if a patch fails some originally passing tests its patch location may be closely related to correct locations since otherwise the passing tests would have been failed before patching .
in this way all the generated patches can be categorized into the following categories according to execu tion information automatically collected during patch validation forunifieddebugging cleanfixpatches patchespassingonat least one originally failed test and not failing on any originallypassed test noisyfix patches patches passing on at least one originally failed tests but also failing on some originally passed tests nonefixpatches patchesnotimpactingtheoutcomefor any originally failed or passed test negfix patches patches not passing any originally failed test but failing on some originallypassed tests.
note that all such patch validation information can be directly obtained from the studied test based apr tools.
unified debuggingsimplyleveragessuchexistinginformationtoclassify each patch into the aforementioned categories.table example of math suspicious method sbfl prapr kali a tbar unidebug polyhedronsset.
init .0nonefix unmodified unmodified nonefix polygonsset.compute... .0nonefix cleanfix nonefix cleanfix polygonsset.followloop .0nonefix nonefix unmodified nonefix avltree.getnotsmaller .0nonefix nonefix nonefix nonefix theoverallapproachofunifieddebuggingispresentedinfigure1.givenanybuggyprogramanditstestsuite unifieddebugging first applies off the shelf apr systems to generate and execute various possible patches.
then while existing apr work only returns the correct patches to the developers unified debugging further utilizestheexecutioninformationforallpatchesandcategorizes them into relevant categories discussed in the previous paragraph.
then for each code element e.g.
method unified debugging then adopts the best category from its corresponding patches according tothispredefinedorder i.e.
cleanfix noisyfix nonefix negfix .finally alltheelementsarere rankedfirstaccordingto their patch categories e.g.
all elements with the cleanfix category are ranked higher than all elements with the noisyfix category after that the elements within the samecategory are then further re ranked in the descending order by their initial suspiciousness scorescomputedbyanyexistingfaultlocalizationtechnique i.e.
ochiai bydefault .inthisway thedeveloperswillobtainlargely refinedfaultlocalizationforallpossiblebugs evenincludingthe case where no correct or plausible patch is found .
.
motivating example while the existing unified debugging technique profl has demonstrated promising results in this section we use math from defects4j v1.
.
a widely used real world java bug benchmark to motivate our study.
math denotes the 32nd buggy version ofapachecommonsmathproject.thebugislocatedinmethod computegeometricalproperties of class polygonsset.
table1shows4examplesuspiciousmethodsincludingtheactual buggy method shown in gray.
please note that we disregard theargumentssincetheclassandmethodnamescansufficiently distinguish them.
inthetable column sbfl indicatesthesuspiciousnessscore of each method according to the state of the art sbfl techniqueochiai with aggregation strategy which aggregates the maximumsuspiciousnessvaluesfromstatementstomethodsand 909protected void computegeometricalproperties ... if v.length final bsptree euclidean2d tree gettree false if boolean tree.getattribute if false the instance covers the whole space setsize double.positive infinity setbarycenter vector2d.nan ... protected void computegeometricalproperties ... if v.length final bsptree euclidean2d tree gettree false if boolean tree.getattribute if tree.getcut null boolean tree.getattribute the instance covers the whole space setsize double.positive infinity setbarycenter vector2d.nan ... figure generated patch of kali a and developer patch for math has been demonstrated to substantially outperform raw methodlevel sbfl.
columns prapr kali a and tbar represent the unifieddebuggingapproaches usingthepatch executioninformationfrom aprsystems prapr kali a andtbar respectively.
the patchcategoryinformationforeachmethodisincludedinthetable.
unmodified herebyreferredtoasnon modify representsanew patchcategoryimplyingthatthesecodeelementsareneverpatched by an apr tool.
lastly column unidebug presents the techniquesimplyusingallpatchesfromthepriorthreeaprsystems.
from the motivating example we have the following interesting findings first unified debugging using other apr systems can have promisingfaultlocalizationresultsevenwhenthepraprsystem used by profl cannot help improve the performance.
for example kali acandirectlyrankthebuggymethodatthe1stlocation while bothsbflandproflwithpraprrankthebugatthe4thlocation.
figure2representsthepatchgeneratedbykali a leftside andthecorrectpatchprovidedbydevelopers rightside .fromthepatches we found that kali a generates a patch by changing the buggy conditional statement into if false which is useless forfixing the real bug however this patch does help pinpoint the actual bug location demonstrating the generality of unified debugging for all possible apr systems.
thisfi nding motivates us to perform an extensive study to investigate the effectiveness of different apr systemsforunifieddebugging.second differentaprsystemshavedifferentunifieddebuggingperformancesandcombiningthemmaypotentiallyresultinevenmorepowerfulunifieddebugging.shown in the last column of table simply combining all patches gen erated by different apr systems can also localize the bug within top .
study design .
research questions inthisstudy weaimtoinvestigatethefollowingresearchquestions rq1 how does unified debugging perform with all studied apr systems?
rq2 howdounmodifiedcodeelementsduringaprimpact unified debugging?
rq3 howdoes unified debuggingcorrelatewith program repair effectiveness?
rq4 how do we further advance state of the art unified debugging with all studied apr systems?tool category tools constraint based acs cardumen dynamoth heuristic based arja genprog a jgenprog jkali jmutrepair kali a rsrepair a simfix template based avatar fixminer kpar prapr tbar table repair systems studied project name bugs tests loc chart jfreechart 96k lang apache lang 22k math apache math 85k time joda time 28k total 231k table studied bugs from defects4j v1.
.
.
experimental setup for this study we considered all the program repair systems accessiblefromarecentstudy .furthermore wealsoconsideredtherecentpraprrepairsystem whichtheinitialunified debuggingworkisbasedon.table2showsthebreakdownofall the apr systems studied including heuristic based arja genprog a jgenprog jkali jmutrepair kali a rsrepair a andsimfix constraint based acs cardumen and dynamoth and template based avatar fixminer kpar tbar and prapr .
we manuallymodifiedallstudiedaprsystemstocollectthedetailedpatch execution information required by unified debugging and ensured thatourmodifiedversiondidnotimpactthetoolfunctionality.
eachsystemusedoriginaltimesettingssuggestedbytheoriginal papers.
most of the studied apr systems have been implemented to target version .
.
and older of the widely used defects4j benchmark whichincludes357real worldbugsfromfivereal world software systems.
meanwhile in our evaluation process we found thatmanyofthestudiedtools e.g.
capgen acs arja genprog a etc.
do not support or cannot successfully execute closure from defects4j1.
.
accordingtotheiroriginalpublications .
therefore for fair comparison all of our experiments are performed on the remainingfoursubjectsfromdefects4j1.
.
thechart time lang and math projects.
detailed statistics are shown in table .
each tool was executed using each the same jdk version found inthetool soriginalpublication allowingustoobtainrepairexecutionresultsascloseaspossibletothetool soriginalresults.thus 1note that we fail to get the our modified version of nopol functional due to the specificdesignofnopol.nevertheless webelievethatexcludingonespecifictooldoes not impact the generalfi ndings and contributions of this study especially we also have many other constraint based apr systems studied .
910inourexperiments weultimatelyutilizedtwojdkversions jdk .
.
.
herebyreferredtoasjdk1.
andjdk1.
.
.
hereby referred to as jdk .
.
systems simfix and dynamoth executed using jdk .
exclusively.
systems cardumen jgenprog jkali and jgenprog executed usingjdk .
and validatedsystem test suites with jdk .
.
all other systems executed using jdk .
exclusively.
all our experiments were conducted within the following environment .0ghz intel xeon platinum processors 60gbs of memory and ubuntu .
.
lts operating system.
.
implementation details .
.
profl configuration.
although unified debugging can be used to refine any existing fault localization technique by default the original unified debugging work profl utilizes apr to refinestate of the artsbfltechnique ochiai withaggregation strategy .
actually the original profl work demonstrates that unifieddebugginghasconsistentperformanceforrefiningdifferent state of the art faultlocalization techniques.therefore in thispaper wealsofocusonusingochiai withaggregation toinvestigate the impact of different repair systems.
furthermore following the originalproflwork thisstudyalsofocusesonmethod levelfaultlocalization i.e.
localizing potential buggy methods as researchers have demonstrated that class level fault localization can be too coarse grained while statement level fault localization can be toofi ne grained and miss necessary contextual information .
.
.
non modifycategory.
fortheoriginalproflwork theused praprrepairsystem isextremelyfastduetothebytecode level manipulationand cangeneratepatchesfor almostallthe possible suspicious methods i.e.
methods executed by failed tests since methods not executed by failed tests should not be responsible for the current test failures .
however for all other apr tools there may exist many suspicious methods without any patch since itisexpensiveforaprtoolstogeneratepatchesforeverymethod.
therefore besides the four categories of methods mentioned in section2.
wecreateanewcategory non modify torepresentthe methodsthatdonotreceiveanypatchforaspecificaprsystem.
itisunclearhowthisnewcategorycompareswiththeotherfour categoriesstudiedintheoriginalunifieddebuggingwork.therefore we explore the impact of the ranking this new non modifycategorywithintheexistingfourproflcategoriesinsection4.
.
note that as the default setting we put non modify alongside the negfixcategorysincethepluralityof allpatches fallintothenegfix category thus themajorityofnon modify methodsmayalsofall intothenegfixcategoryiftheyhadbeengeneratedwithpatches .
.
.
repairtoolintegrationwithprofl.
theoriginalprofltool hasbeenimplementedasapubliclyavailablemavenplugin.weob tainedtheoriginalproflsourcecodefromtheauthorsandanalyzed the interface between profl and its underlying apr system.
then we modified all the studied apr systems to produce detailed patch execution information consistent with the original proflinterface e.g.
regarding the patch location failing and passing tests for each patch .
in this way we can safely replace the original praprsystemwithanyotherstudiedaprsystemsforourstudy.
pleasenotethatwealsoaugmenttheoriginalproflcodetohandle the new non modify method category.
.
evaluation metrics following prior work we measure the number of bugs localized within top top and top positions as the primary metricsforthisstudy.thereasonisthatresearchershaveobserved that most developers will abort automated debugging tools if they cannot return the actual buggy elements within the top posi tions .
specifically given a set of methods which tie for the same rank each method is assigned the worstrank of the tied methods followingpriorwork .furthermore wealso presentthemeanfirstrank mfr andmeanaveragerank mar resultswidelyusedinpriorfaultlocalization andunified debugging work.morespecifically forpreciselocalizationof allbuggyelementsofeachbug wecomputetheaverageranking of all the buggy elements for each bug mar is simply the mean of theaveragerankingof allbugs.
similarly forabug withmultiple buggyelements thelocalizationofthefirstbuggyelementiscriticalsincetherestbuggyelementsmaybedirectlylocalizedafter that therefore weusemfrtocomputethemeanofthefirstbuggy element s rank for each bug.
result analysis .
rq1 performance of unified debugging with different apr systems inthisresearchquestion wefirstinvestigatetheeffectivenessof unifieddebuggingonallthe16studiedaprsystems.figure3shows thefaultlocalizationresultsonallthestudiedsubjects i.e.
lang chart time and math from the defects4j benchmark in terms of the top top top mfr and mar metrics.
the upper subfigurerepresentsthetop nresultsandbottomsub figureindicates themfr marresults.eachbarinbothsub figuresrepresentsdifferent apr systems.
note that we use the default treatment for the non modify category which inserts such methods alongside the negfix category i.e.
cleanfix noisyfix nonefix negfix non modify discussed in section .
.
.
also note that the 16repair systems in thisfi gure are ordered chronologically with respecttothedateforeachpublication followingtheexistingapr study .
we also include the result of state of the art sbfl i.e.
ochiai with aggregation and thefi rst unified debugging technique i.e.
profl with prapr in the last for comparison note that profl has been demonstrated to outperform improve all state of the art fault localization .
from thefi gure we have the following observations.
first unified debugging with most apr systems performsbetterthanstate of the artsbfl!forexample intermsof top out of tools can help improve sbfl and only arja fails to meet the initial sbfl results.
that said arja can still localize faults within top which is fairly close to the sbfl result.
this findingindicatesthebroadapplicabilityoftheunifieddebugging approach.
second even though existing apr study has observedthatmorerecentaprsystemscanfixmorebugsthanearlier systems there is no obvious trend showing that unified debugging with more recent i.e.
chronologically later apr systems can help localizemorebugsthanearlierones.thisfindingdemonstratesthat apr systems capability to produce correct patches is not highly correlatedtotheunifieddebuggingeffectivenessinfaultlocalization.
lastly different results of the apr systems indicate that .
.
.
.
.. .
.
.
.
.
!
!
.
.
.
.
.
.
.
.
.
.
.
!
figure unified debugging results with all studied apr systems each apr system has its own advantages and disadvantages for unified debugging.
the potential reason is that some tools haveexclusive abilities to repair various classes of bugs by leveraging differentalgorithmstogeneratepatches incurringvariouslevelsof effectivenessforfaultlocalization.thisfindingfurthermotivates us to combine multiple apr systems to advance state of the art unified debugging studied in section .
.
finding despite their varying repair capabilities almost all the studied apr systems individually boost state ofthe art sbfl and contribute to unified debugging.
.
.1qu alitative analysis.
now we perform a detailed qualitative analysis to investigate the different performanceof different apr systems.
table shows a subset of the unified debugging results withdifferentaprsystemsfrommath .notethatwealsoinclude the results for unidebug which simply uses all patches fromdifferent apr systems.
column eid describes the id for eachmethod.
column category represents the category computedfor each method based on each tool.
column rank describes howeachmethodranksinthefinalresults.
math 77failsontwo tests testbasicfunctions within class arrayrealvectortest and testbasicfunctions within class sparserealvectortest both from the org.apache.commons.math.linear package.
the buggymethodsformath 77involvemodificationsofmethods e4 and e5 according to developer patch in figure .
according to traditional sbfl allfi ve methods tie and are ranked 5th according to theworstranking .
we next discuss the performance of three example apr systems for unified debugging tbarisabletogenerateacleanfixpatchbyexclusivelymodifying method e4 shown in figure .
this cleanfix patch successfully passes one of the originally failed tests and passes every othertest.eventhoughthispatchisnotacorrectpatch itdoeshelpto boosttherankofonebuggymethodtotop .thereasonisthat the patch shares the same location with the bug and thus is able to mutethebugimpactviamodifyingthereturnvalue.thisfurther demonstrates the effectiveness of unified debugging.rsrepair a generates negfix and nonefix patches across unique methods for this bug.
allfi ve methods in table are nonefix based on rsrepair a. from this categorization e1 e5 are ranked the same as the sbfl results.
note that in this case although rsrepair a was not able to improve sbfl it will not deteriorate the fault localization results when combining with the more effective tbar.
the reason is that when putting all patches together methods with higher patch categories will still be ranked higher.
arjais a very interesting case.
it actually produces many incorrect but cleanfix patches for math including for allfi ve suspicious methods shown in table .
we were surprised by the fact that arja canproducesomanycleanfixsincetheyareusuallyhardtogenerate.diggingintovarioussuchpatches wefoundthereasonto be that arja specifically targets multi edit patches i.e.
each patch modifiesmultipleprogramlocations .forexample onesuchcleanfixpatchisshowninfigure6.inthisway aslongasone partof the multiple edits within a multi edit patch can make some failing teststopass thepatchcanpotentiallybecleanfix makingallmodified methods of this patch to be highly ranked.
furthermore such noiseincurredbymulti editaprsystemscanalsobeharmfulwhen combining different apr systems for unified debugging.
for example showninthelastcolumnoftable4 unidebug alsocannot distinguish thefive suspiciousmethods.
therefore we excludeall such multi edit apr toolswhen combining different apr systems for unified debugging section .
to remove unnecessary noise.
912eid suspicious methodsbfl tbar rsrepair a arja unidebug susp.
rank category rank category rank category rank category rank e1 abstractrealvector getl1norm d .
non modify nonefix cleanfix cleanfix e2 abstractrealvector getnorm d .
non modify nonefix cleanfix cleanfix e3 arrayrealvector getl1norm d .
non modify nonefix cleanfix cleanfix e4 arrayrealvector getlinfnorm d .
5cleanfix 1nonefix 5cleanfix 5cleanfix e5 openmaprealvector getlinfnorm d .
non modify nonefix cleanfix cleanfix table unified debugging with different apr systems for math org.apache.commons .math.linear.ar rayrealvector.
java public double getlinfnorm double max for double a data max math.max max math.abs a max math.max max math.abs a return max org.apache.commons.math.linear.openmaprealvector.java public double getlinfnorm double max iterator iter entrie s.iterator while iter.hasnext iter.advance max iter.value return max figure correct developer patch for math org.apache.commons.math.linear.ar rayrealvector.
java public double getlinfnorm double max for double a data max math.max max math.abs a return max return getdimension figure tbar s incorrect cleanfix patch for math finding2 aprtoolsspecificallytargetingmulti editpatches can bring noise into unified debugging as each multi edit patch involves multiple modifications and many modifica tions are not helpful in muting the bug impacts even the patch can pass some originally failing test s .
.
.2qu antitativeanalysis.
sincethecapabilitytoproducecorrect patchesisnothighlycorrelatedwithunifieddebuggingeffectiveness we further performs detailed quantitative analysis to explore what factors of apr systems are highly correlated to the effectivenessofunifieddebugging.figure7representsthecorrelation analysisbetweendifferentfactors ofaprsystemsandrepresentativefaultlocalizationmetrics i.e.
top 1andmfr .notethatwe also excluded apr tools targeting multi edit patches.
in thisfigure totalpatch represents the number of all executed compilable patchesgeneratedfromeachaprtool methodbytotal represents thenumberofuniquemethodsmodifiedbyallexecutedpatches plausiblepatch represents the number of plausible patches generatedbyeachtool and methodsbyplausible representsthenumber ofuniquemethodscoveredbytheplausiblepatches.withineach sub figure each data point represents one studied apr system and we perform pearson correlation coefficient analysis a t significancelevelof0.
.fromthisfigure wecanobservethatapr systems tend to perform significantly better for unified debugging when executing more patches for more methods and or producing more plausible patches for more methods.
thefi nding is statis tically significant for all the sub figures at the significance levelof .
.
although thefi nding is surprisingly uniform this makesintuitive sense since apr systems patching more code elements tendtoaccumulatemoreinformationfordebugging.thisfinding suggests future apr systems to explore more patches for morepowerfulunifieddebugging andalsocallsforresearchforfasterpatch execution otherwise apr systems cannot afford massive patch executions .
finding3 aprsystemsexecutingmorepatchesacrosscode elements and or producing more plausible patches tend toperform better for unified debugging calling for future research on fast exhaustive patch exploration .
.
rq2 impacts of non modify code elements on unified debugging as discussed in section .
.
we add one new patch category nonmodify which represents suspicious methods that some apr tools do not afford to modify.
thefi rst research question has demonstrated the effectiveness of default unified debugging setting on apr systems by treating non modify equivalently as the fourth patch category negfix.
in this research question we further evaluate the unified debugging effectiveness when casting the non modify category into each of the four different profl categories.figure represents the representative top and mfr results ofall the apr systems with such four settings represented withlines in different colors.
from thefi gure we can observe that for mostsystems castingnon modifycodeelementsintothelastnegfix category performs better than casting them into other threecategories in terms of both top and mfr.
for example simfix can localize bugs within top when casting non modify into negfix category and can only localize bugs within top when casting non modify into nonefix noisyfix cleanfix category.also intermsofmfr kali acanachieve5.53withnegfix which is also significantly better than kali a with other three categories .
.
.
.
the reason is that negfix patches are more prevalent for most code elements including non modify ones while other patch categories can be harder to generate.
finding4 non modifycodeelements i.e.
elementswithno patches canbetreatedinthesamewayaselementswithonly negfixpatches i.e.
thepatchesthatcannotfixanyfailing testbut cancauseoriginally passingtests tofail for preciseunified debugging.
arrayrealvector.
java public double getlinfnorm double max for double a data max math.max max math.abs a return max return data.length a modifications for arrayrealvector.java openmaprealvector.java public double getlinfnorm double max iterator iter entries .iterator while iter.hasnext iter.advance max iter.value return max return virtualsize b modifications for openmaprealvector.java abstractrealvector.
java public double getl1norm double norm iterator entry it sparseiterator entry e while it.hasnext e it.next !
null norm math.
abs e.getval ue while it.hasnext e it.next !
null norm math.abs e.getva lue return norm c modifications for abstractrealvector.java figure an incorrect arja cleanfix patch with three modified methods for math r .
p .
totalpatchtop1 r .
p .
.
.
.
methodbytotaltop1 r .
p .
.
.
.
plausiblepatchtop1 r .
p .5e .
.
methodsbyplausibletop1 r .
p .
.
.
totalpatchmfr r .
p .
.
.
.
.
.
.
methodbytotalmfr r .
p .
.
.
.
.
.
plausiblepatchmfr r .
p .
.
.
.
.
.
methodsbyplausiblemfr figure correlation analysis acs arja avatar cardumen dynamoth fixminer genprog a jgenprog jkali jmutrepair kali a kpar prapr rsrepair a simfix tbar tooltop1 .
.
.
.
.
.
acs arja avatar cardumen dynamoth fixminer genprog a jgenprog jkali jmutrepair kali a kpar prapr rsrepair a simfix tbar toolmfr negfix nonefixnoisyfixcleanfix figure impact of casting non modify code elements into different categories .
rq3 how does unified debugging correlate with apr effectiveness?
aprsystemsallaim toproducecorrectpatchesforas manybugs as possible.
however this is a rather challenging goal and even state of the art apr tools can onlyfi x less than of the studied bugs .therefore inthisresearchquestion weempiricallystudy whether unified debugging is also limited by the apr effectiveness i.e.
in producing correct patches .
the three sub figures in figure show the representative top metric for sbfl and unifieddebuggingusingeachaprsystemon buggyversionswherethe corresponding apr system has correct patches buggy versions withincorrectbutplausiblepatches and buggyversionswithoutevenplausiblepatches respectively.pleasenotethatweomit the apr systems that did not present detailed correct patch ids in their original publications in thisfi gure.
from thefi gures we canobservethatdifferentaprsystemsperformdifferentlyinall three different bug sets and almost all apr systems can contribute to unified debugging to outperform sbfl.
more importantly we acs arja avatar dynamoth fixminer jkali jmutrepair kpar simfix tbar tooltop1 sbfl profl acs arja avatar dynamoth fixminer jkali jmutrepair kpar simfix tbar tooltop1 sbfl profl acs arja avatar dynamoth fixminer jkali jmutrepair kpar simfix tbar tooltop1 sbfl profl figure unified debugging on buggy versions with correct incorrect but plausible and implausible patches table effectiveness of unidebug and unidebug tech name top 1top 3top 5mfrmar sbfl .
.
profl .
.
unidebug all951601774.
.
unidebug all1191681804.
.
unidebug .
.
unidebug .
.
observe that almost all apr systems consistently outperform sbfl in all the three bug sets.
one potential reason is that as long asapatchcanpasssomeoriginallyfailingtest s itspatchlocation maybecloselyrelatedtotheactualbuggylocationsinceotherwise it cannot mute the bug impact to pass failing tests.
in this way patchesdonotneedbecorrectoreven plausibletocontributeto unifieddebugging.furthermore eventhepatchesthatonlymake originally passing tests turn to fail can help eliminate the potentiallycorrect benignlocationstoalsoboostunifieddebugging.
thisfurtherdemonstratesthegeneralapplicabilityandpromisingfuture for unified debugging.
finding unified debugging effectiveness does not rely on the availabilityof correct or even plausiblepatches from apr.
similar as when conducting manual program repair apr patch execution results from even incorrect implausible patches can still reveal actual buggy locations when they pass some failing test s or eliminate correct locations even when they only fail on originally passing tests .
.
rq4 more advanced unified debugging tocombinethestrengthsofdifferentaprsystems onenaivewayis to simply combine the patches of different apr systems for unifieddebugging i.e.
theunidebug techniquethatwehavetalkedabout.table example for unidebug sbfl tool1 tool2 tool3 unidebug unidebug e10.8cleanfix cleanfix cleanfix cleanfix cleanfix e20.8cleanfix negfix cleanfix cleanfix cleanfix e30.8cleanfix nonefix nonefix cleanfix cleanfix inthisway thefinalcategoryinformationforacodeelementcan bedeterminedbythebestcategoryinformationofallpatchesofthe code element from the combined apr systems.
in this section we furtherproposeamoreadvancedtechnique unidebug which further distinguishes code elements with the same suspiciousness values in thesame category.
more specifically after assigning the patch groupcategory for patches generated byall combined apr systems toacodeelementinthecategoryaggregationstep showninfigure1 wefurthercountthetotalnumberofaprsystemsthat generate patches in the same category as this code element.
the intuition is that if more apr systems can assign the best categoryinformationtoacodeelement thiselementshouldhave higherpriorityintherankedlistcomparedtoitstiedpeers.table6showsansimpleexampletoillustrateunidebug .inthisexample elements e1 e2ande3havethesamesbflsuspiciousnessvalue .8andareallinthecleanfixcategoryaccordingtounidebug therefore they cannot be distinguished when using unidebug .in contrast unidebug further considers the number pf apr systemsproducingcleanfixpatchesforeachelement.forexample e1has cleanfix patches when using all three apr systems and shouldberankedhigherthanotherelements.inthisway wecan leverage more precise apr information for more powerful unified debugging.
table shows the results of original sbfl profl unidebug andunidebug intermsoftop top top mfrandmar.
note that as discussed in section .
.
apr systems specifically targetingmulti editpatchescanintroduceextranoiseforunified debugging and have been excluded for unidebug and unide bug .
meanwhile we also include as