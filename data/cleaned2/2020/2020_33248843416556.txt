flashregex deducing anti redos regexes from examples yeting li state key laboratory of computer science instituteofsoftware chinese academy of sciences university of chinese academy of sciences beijing china liyt ios.ac.cnzhiwu xu college of computer science and software engineering shenzhen university shenzhen china xuzhiwu szu.edu.cnjialun cao department of computer science and engineering the hong kong university of science and technology hong kong china jcaoap cse.ust.hk haiming chen state key laboratory of computer science instituteofsoftware chinese academy of sciences beijing china chm ios.ac.cntingjian ge university of massachusetts lowell united states ge cs.uml.edushing chi cheung department of computer science and engineering the hong kong university of science and technology hong kong china scc cse.ust.hk haoren zhao shaanxi normal university xi an china zhaohaoren666 gmail.com abstract regular expressions regexes are widely used in different fields of computer science such as programming languages string processinganddatabases.however existingtoolsforsynthesizingorrepairingregexeswerenotdesignedtoberesilienttoregexdenialof service redos attacks.specifically ifaregexhassuper linear sl worst case complexity an attacker could provide carefully crafted inputstolaunchredosattacks.therefore inthispaper weproposeaprogramming by exampleframework flashregex forgenerating anti redos regexes by either synthesizing or repairing from given examples.itisthefirstframeworkthatintegratesregexsynthesis andrepairwiththeawarenessofredos vulnerabilities.wepresent novel algorithms to deduce anti redos regexes by reducing the ambiguityoftheseregexesandbyusingbooleansatisfiability sat or neighborhood search ns techniques.
we evaluate flashregex with five related state of the art tools.
the evaluation results show thatourworkcaneffectivelyandefficientlygenerateanti redos regexesfromgivenexamples andalsorevealthatexistingsynthesis andrepairtoolshaveneglectedredos vulnerabilitiesofregexes.
specifically the existing synthesis and repair tools generated up to redos vulnerable regex within few seconds to more than one haiming chen is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
seconds.
furthermore the evaluation results on redos vulnerable regexrepairalsoshowthatflashregexhasbettercapabilitythan existing repair tools and even human experts achieving more redos invulnerable regex after repair without trimming and resorting highlightingtheusefulnessofflashregexintermsofthe generality automation and user friendliness.
keywords regular expression regexes anti redos program synthesis program repair acm reference format yetingli zhiwuxu jialuncao haimingchen tingjiange shing chicheung andhaorenzhao.
.flashregex deducinganti redosregexes fromexamples.in 35thieee acminternationalconferenceonautomated softwareengineering ase september21 virtualevent australia.acm new york ny usa pages.
introduction regular expressions regexes are a fundamental concept across the fields of computer science e.g.
programming languages string processingtools anddatabasequerylanguages .
though popular regexes are hard for users and even experts to understandandcompose .toalleviatethisproblem varioustechniques havebeenproposed.from eitherpositiveand ornegativeexamples thesetechniquescansynthesize regexes by accepting all positive examples while rejecting allnegativeones.this programming by example pbe technique has the salient advantage of allowing users to provide examples to reflecttheirtrueintentions.however existingworks 35th ieee acm international conference on automated software engineering ase donotconsidertheissueofsecurityvulnerabilityinregexsynthesis.
as such the synthesized regexes are subject to attacks.
to bemore specific if a regexhas super linear worst case complexity abbrev.slregex anattackermaybeabletotriggerthis complexitybymaligninput exhaustingthevictim scpuresources and causing regex denial of service redos .
in other words slregexesareredos vulnerable sincefortheseregexes theevaluationcouldtakehigher degreepolynomials i.e.
quadraticorworse orevenexponentialtimeinthesizeoftheinput.in2016 redosled to an outage at stackoverflow and rendered vulnerable any websites built with the popular express.js framework .
furthermore arecentstudy foundthatslregexesarerathercommon inpractice theyappearinthecorenode.js javascript andpython libraries as well as in thousands of modules in the npm and pypi module registries including some popular modules with millions of downloads per month.
similar concerns are made by wstholz sinceitisoftendifficultforhumanstoreasonabout thecomplexityofregularexpressionmatching webelievethereisa realneedfortechniquesthatcanautomaticallysynthesizeequivalent regular expressions with linear complexity .
we extend this idea to notonly synthesize redos invulnerable regexes butalsohelp repairincorrect1and orredos vulnerable regexes.existingtechniques thataimatrepairingregexes usually focusonly on theincorrect ones.
thereis only twoline of work targeting on repairing redos vulnerable regexes yet the restriction to revisions that would match the exact same languages refertosection2fordefinition isactuallyrarelyapplicable in practice for example cases and in table according to .
to achieve the aforementioned goals there are three challenges to be addressed.
huge search space .
for both regex synthesis and repair the searchspaceisextremelylarge becausepracticalregexes i arelarge ii operateoververylargealphabetsize and iii contain variousoperatorssuchasdisjunction concatenation quantifiers and so on.
difficultyoflearningregexesfromexamples.
theproblem of synthesis and repair from examples is shown to be an np completeproblem.wefurtheraddtherequirementofredosinvulnerabilities making the problem even harder.
difficulty of prevention of redos vulnerabilities .
instead ofavoidingcertainpatternsofregexesasprerequisitesofredosat tacks developersorusersexpecttoaddressredos vulnerability fromitsrootcause theambiguityofregexes.indeed ambiguity can lead to sl behavior also known as catastrophic backtracking that causes redos attacks .
how to avoid generating these ambiguousregexes effectivelyis adistinct meritof ourwork over existing techniques.
ourkeyideaisthatusing deterministicregexes dres can prevent generating sl regexes.
as its name implies determinism means that when matching a string from left to right against a regex a symbolin the string canbe matched to onlyone position intheregexwithoutlookahead.taketwoequivalent2regexesas an example i non deterministic regex s ?
s and ii dre s s ?
.
if we input a whitespace character i.e.
s 1a regex is incorrect if it is not consistent with all the given examples.
2two regexes are equal iff the corresponding languages are equivalent.the first regex cannot decide which s the first or the second should be matched without looking ahead while the dre can efficientlymatchthefirst s withoutambiguity.fromthisexample we can see that one merit of dres is their efficient matching with maligninputavoidingcatastrophicbacktracking becauseeach matchingpositionintheinputwordcanbeuniquelydecided which is in line with the spirit of avoiding redos vulnerabilities.
this paper proposes flashregex with three functionalities i regexsynthesis ii incorrectregexrepair and iii redos vulnerable i.e.
sl regex repair.
given positive and or negative examples flashregex automatically generates anti redos regexes that are consistent with the given examples.
we develop novel algorithms that generate anti redos regexes by reducingthe ambiguityof theseregexes andby usingboolean satisfiability sat andneighborhoodsearch ns techniques.in particular we design boolean formulae for the determinism constraintandpositive and negative example constraints and use a heuristic strategy called local constraints strengthening lcs to furtherspeeduptheprocess seefigure3insection4 enablingus to encode the synthesis problem into sat.
for regex repair flashregex adopts a strategy that a regex after repair is as closetoitsoriginalregexaspossible.tothisend wepresentawayofslightly changing the edges of the current regex represented by anautomaton i.e.
theneighborhood andperformneighborhood searchstartingfromtheoriginalregexusinga measurefunction see section until a solution is found.
in fact the synthesis problem andtherepairproblemarerelated.thelattercanbereducedtotheformerbydisregardingthe originalregex.
however the regexsuch repaired may be very dissimilar to the original one.
although in this paper we only consider the regexes that do not containnon regularoperators e.g.
positivelookahead ourtool isexpressiveenoughtocapturemostoftheregexesappearingin practical applications according to the statistical result .
we evaluateflashregexbycomparingflashregexwithfivestate ofthe arttoolsintermsofeffectiveness includingthecorrectnessandredos vulnerabilities andtimeefficiencyonthepubliclyavailable benchmarks.theevaluationresultsrevealthatflashregexisthe only technique that can run on all benchmarks with higher efficiency and generate anti redos regexes while the results of other tools can be redos vulnerable.
for example on benchmark multisyn regex flashregexreducestheaverageruntimefrommorethan hour by gp regexgolf containing redos vulnerable results to seconds and without redos vulnerabilities.
the evaluation resultsonredos vulnerableregexrepairalsoshowthatflashregex has better capability than existing repair tools and even human experts seesection6.
demonstratingtheusefulnessofourwork.
to summarize this paper makes three main contributions we develop flashregex a programming by example framework to deduce anti redos regexes by either synthesizing or repairing from given examples.
to the best of our knowledge itisthefirstframeworkthatintegratesregexsynthesis and repair with the awareness of redos vulnerabilities.
wepresentnovelalgorithmstogenerateanti redosregexes byreducingtheambiguityoftheseregexes.theprocesses are greatly accelerated by using deterministic automata and optimizations such as the lcs strategy and sat techniques.
we conduct a series of comprehensive experiments comparingflashregexwiththestate of the arttools.theevaluation results show that flashregex can effectively and efficiently generate anti redos regexes from given examples and also revealthatexistingsynthesisandrepairtools haveneglected redos vulnerabilities of regexes.
preliminaries let be a finite alphabet of symbols.
the set of all words over is denoted by .
the empty word and the empty set are denoted by and respectively.
aregular expression regex over is defined inductively as follows anda are regular expressions for regular expressions r1andr2 the disjunction r1 r2 the concatenation r1r2 and the quantifier r1 m n wherem n n n andm n arealsoregularexpressions.besides r?
r r andr i wherei n areabbreviationsof r r r andr i i respectively.
r1 m is often simplified as r1 m .
thelanguage l r of a regex ris defined as follows l l l a a l r1 r2 l r1 l r2 l r1r2 vw v l r1 w l r2 l r m n uniontext.
m lessorequalslanti lessorequalslantnl r i. practical regexes support special operators also known as characterclasses todenotecertainsetsofcharacters.commoncharacter classesinclude i s whichcontainsallwhitespacecharacters ii d whichcontainsdigitalcharacters iii intervals which specifies a range of characters from c1toc2by using a hyphen for example the regex is the same as a b c d .
a marked form of a regex ris denoted as r which is obtained by marking symbols in rwith subscripts such that each marked symbol occurs only once in r. for instance given an expression r a a b ab its marked form can be a1 a2 b1 a3b2 .
the samenotationwillalsobeusedforunmarking namely dropping off subscripts from the marked symbols r r. we extend this notation for words and sets of symbols in the same way.
the set of symbols that occur in a regex ris denoted by sym r .
definition .
deterministic regular expression dre .
letrbe a marked form of the expression r ris deterministic if and only if for all words uxv uyw l r wherex y sym r andu v w sym r i fx ythenx y. an expression ris deterministic iff ris deterministic.
theregex r1 a aisnondeterministicsince r1 a 1a2isnondeterministic given two words a1a2 a2 l r1 there isa1 a2 a buta1 a2.
similarly one can verify that r2 aa is deterministic.
noticethatdres are arestrictedsubclassofregularexpressions i.e.
not every regular expression has an equivalent dre.
definition .
ak occurrence regular expression k ore isaregularexpressioninwhicheveryalphabetsymboloccursat mostktimes.
for example ab is a ore and a ab ?b is a ore. note that1 oreisalsoknownassingle occurrenceregularexpression sore .ak occurrenceautomaton k oa isaspecifictype of finite state automaton defined in the following where the states are labeled with symbols while edges are not .
definition .
k occurrence automaton k oa .
akoa is a node labeled graph g v r lab where vis a finite set of nodes also known as states with a distinguished source srcand sinksnk.
ris a set of edge relations representing reachable paths.
src hasonlyoutgoingedgesand snkhasonlyincomingedges.
everyv v src snk is reachable by a path from srctosnk.
labis the labeling function v src snk .
thereareatmost kstateslabeledwiththesamesymbolin .
we useout v to denote v1 v v1 ra n d lab v1 i.e.
the set of direct successors of a state vinathat are labeled .
asingle occurrenceautomaton soa isaspecialcase ofk oa where k .
a markedk oaais ak oa where each nodeismarkedwithasubscriptsuchthateachnodelabelisunique ina.
it is clear that a marked k o ai sa ns o a .a deterministic k oa is ak oa in which for each node v vand out v contains at most one state.
we can use an adjacency matrix to represent a k oa.
the oa afor the regex a ab ?b and its adjacency matrix agare shown in figure .
src a a b b snkag aabbs n k parenlefttpa parenleftexa parenleftexa parenleftexa parenleftexa parenleftbta parenrighttpa parenrightexa parenrightexa parenrightexa parenrightexa parenrightbtasrctfff f aftft f afftf f bffft f bffft t figure oa afora ab ?b and its adjacency matrix ag.
overview in this section we present an overview of our approach.
regex synthesis.
the first problem we target at is to synthesize anti redosregexesfrompositiveandnegativeexamples.thatis given a positive example set s and a negative example set s the goalistolearnaregex rsuchthat i s l r ands l r and ii ris invulnerable to redos attacks.
the key of our solution to tackle this problem is the use of deterministic regexes.
in particular our solution consists of twosteps namely k oa synthesis section .
and regex extraction section .
.
k oa synthesis takes the given positive and negative examplesasinputandtriestosynthesizeadeterministic k oafrom the examples via sat.
this task first uses a boolean variable to representapossibleedgerelationbetweentwonodes wherein t represents an edge exists while frepresents no edge exists and thenitencodesthepropertiesofthepossible k oasintoboolean formulas which are then fed into a sat solver.
if the formulas are satisfiable the sat solver returns a solution from which k oa synthesis builds ak oa.
after that regex extraction marks the synthesized deterministic k oa and extracts a marked regex from the marked k oa by callingtheprocedure soa2soreusedinfreydenbergerandkotzing s work .thisprocedure soa2sorebuildsfromagivensoa aan sorerthat minimally generalizes l a see for the explanation of minimal generalization .
then regex extraction unmarks the regex and returns it if it is deterministic.
661generally regexes with smaller nested quantifiers e.g.
star height arelesslikelytosufferfromredosattacks.wealsofind that a regex extracted from a k oa with a smallervalue ofkhas a smallernested quantifiers.
thus our solution will perform these twotasksstartingfrom k .onceapossibleregexisfound our solution returns this regex immediately.
furthermore a kof is sufficienttocapturetheintendedsemanticsof95 .
oftheregexes fromregexlib anditistreatedasauserparametercontrolling how long the synthesizer searches.
the bounding of kis helpful in reducing the huge search space.
regex repair.
the second problem is to repair an incorrect i.e.
rejectingsomeexamplesin s oracceptingsomeexamplesin s or redos vulnerableregex r i.e.
redos prone withrespecttoapositiveexampleset s andanegativeexampleset s .theideaisquite similar to regex synthesis to use deterministic regexes when possible.
that is our solution section5 tries to derive a deterministic regex from rto achieve the same goal of regex synthesis.
indetail oursolutionstartswithadeterministic k oa which is converted from the given regex r. then it searches for a k oa whichcanacceptthemostpositiveexamplesand orrejectthemost negative ones among those in the neighborhood i.e.
those with onedifferent valuefrom thecurrent k oa .our methodkeeps on searching until it finds a deterministic k oa that accepts all the positive examples and rejects all the negative ones or the number of iterations exceeds a given number set to be in this paper .a case study of regex synthesis.
weillustrateoursolutionwith an example whose positive example set is s ab abbb aabb and negative example set is s ba aab baba .
assume the automaton to synthesize is a deterministic oa.
that is to say we have at most two nodes labeled with a resp.b which are denoted asa1anda2 resp.b1andb2 respectively.andwerepresentapossibleedgebetweentwonodes uandvasabooleanvariable au v. firstly asthe2 oaisdeterministic thereisatmostonenodethatislabelledbyanysymbol a b aswellasdirectsuccessorsofany nodev a1 a2 b1 b2 src snk .thatistosay out v containsat mostonenode whichcanbeencodedasabooleanformula.forex ample theconditionfor out a1 a canbeencodedasthefollowing formula aa1 a1 aa1 a2 aa1 a1 aa1 a2 aa1 a1 aa1 a2 .
wedothesametoother out v s.secondly eachword wins should be accepted by this synthesizd oa hence there existsa path for w. takeabas an example.
as both aandbhave two possiblelabellednodes therearefourpossiblecasesforthepathof ab which can be represented as the following formula asrc a1 aa1 b1 ab1 snk asrc a1 aa1 b2 ab2 snk asrc a2 aa2 b1 ab1 snk asrc a2 aa2 b2 ab2 snk itisthesamewiththeotherwordsin s .finally wealsorequire that each word wins should notbeacceptedby the oa which can be converted into boolean formulas similarly with a negation onthetop .whentheformulasaregenerated3 wefeedtheformulas intothesatsolverandgetasolution whichisillustratedasthe matrixaginfigure1.basedonthissolution adeterministic2 oa a2can be built easily which is also given in figure .
3we can also generate the formulas according to the local properties such as 2successive steps of the given words to synthesize a sound k oa faster which are called local constraints strengthening lcs heuristic strategy see section .
for more detail .src a1 b 2snk a2b1 ?
figure an intermediate soa in soa2sore a2 next we mark a2 on which we call the procedure soa2sore to extract a regex.
figure gives an intermediate soa obtained insoa2sore a2 from which a marked regex a1 a2b1 ?b 2is built bysoa2sore.
therefore the final regex we extract for a2isr2 a ab ?b .
synthesis algorithm in this section we present the details of our synthesis algorithm synregex.
our synthesis algorithm is shown in algorithm which tries to synthesize a possible k ore for kranging in .
here kmaxis a customized parameter and in this paper kmaxis set to due to the reason discussed in .
in detail for a given k our algorithm first synthesizes a deterministic k oa from the given examples line which is introduced in section .
and then it extracts a regex from the marked version of the synthesized k oa line which is presented in section .
if the k oa is not null.
finally ouralgorithmreturnstheregexwiththesmallest kiffound lines or returns nullotherwise line .
algorithm synregex input a positive set s and a negative set s output a deterministic regex rwiths l r and s l r if solvable for kmax o rnull otherwise 1fork 1tokmaxdo 2a synkoa s s k 3ifa nullthen 4r genregex a ifr nullthen returnr 7returnnull .
k oa synthesis this section presents the k oa synthesis algorithm which synthesizeadeterministic k oabyencodingthesynthesisproblemintoa boolean satisfiability problem sat .
asshowninfigure1 section2 a k oacanberepresentedasa boolean adjacency matrix.
therefore we use a boolean variable to represent a possible edge in a k oa.
once all the boolean variables are fixed a k oa is obtained meanwhile.
recallthatthe k oatobesynthesized a isdeterministicand b acceptsthewordsin s whilerejectingthewordsin s .forthe condition a out v contains at most one state for any v v and .
then this deterministic condition on a k oa can be encodedintoaformulaviatheconstraintgenerator deter k which 662is shown in figure where is the alphabet m nand tare indexedstatesfor andau visabooleanvariablerepresenting apossibleedge i.e.
aunitinthebooleanadjacencymatrix fortwo indexed states uandv.
letusconsiderthecondition b .asillustratedinsection3 both positiveexamplesandnegativeexamplescanbeentirelydealtwith by a general example constraint generator called global constraint generator .
thus the longer the example the more the possible cases i.e.
theconjunctiveclausesyieldedbythetransformationon thecorrespondinglogicformulas .moreover fornegativeexamples atopnegationneedstobetaken sothatthenumberofcasesfor anegativeexample wwouldbe w timesthatofapositive exampleofthesamelength where w denotesthelengthof w.a s a result with the increase of negative examples the runtime of the algorithm could grow significantly especially for the long ones.
tospeedupthe k oasynthesisalgorithm wepresentaheuristic algorithm fastkoa which adopts local constraints rather than the global constraintson the whole words.
wecall the strategy as local constraints strengthening lcs heuristic one.
thelocalconstraintgeneratorsarealsogiveninfigure3 where exam w k denotes the global constraint generator for positive examples.differentfromthe globalconstraintgenerator thepositive example constraint generator posadoes not ensure that there existsapathinthe k oaforeachword winthepositiveset s but ensuresthateverystepofapossiblepathfor wexistsink oa.this isclearlyaweakercondition.toensurethesoundness weenhance our constraints with another generator posb.posbchecks that if a step of a possible path for w s exists in the k oa then its next successive steps exists as well.
the condition is a complement of posa andthecompositionof posaandposbisastrongercondition.
take the word w abcadefor example.
posb abcade k requires thatboth2 successive steps bcanddeshouldbenexttoeverystate labelledby ainthek oa.whilethenegativeexampleconstraint generator neg w k requiresthatforeachstepofapossiblepath forw s none of its next successive steps in the path exists in thek oa.
the condition is a stronger one as well.
note that only one of the next successive steps does not exist in the k oa maybesufficient.forexample if abcadeisnegative thenoneof bc anddenot following ais sufficient.
but this is similar to the global constraint generator there is a top level negation.
in brief local constraint generators take steps forward for each step.
this step size2issetupbasedonourexperience whichcanguaranteethe solvability of most problems and speedupthe solution process.
the algorithm fastkoa is shown in algorithm which first encodesour k oasynthesisintoasatviatheconstraintgenerators infigure3 lines1 andthensolvesthesatproblemifsatisfiable lines7 .ifsatisunsatisfiable thenthealgorithm willinvoke the exact version ikoa line wherein the global constraint generatorforexamplesareusedinstead.notethatthepruningstep aims to delete useless states and edges in an automaton especially thetrapstates whichwillnotaffecttheacceptancesoftheexamples but could cause the procedure soa2soreused inregex extraction to fail.
we remark that our algorithm is flexible.
from the synthesis process it can be seen that our algorithm not only supports regexalgorithm fastkoa input a positive set s a negative set s a valuek output a deterministic k oaaornull 1initialize the formula set d 2add deter k to d 3forw s do 4add pos a w k posb w k to d 5forw s do 6add neg w k to d 7put d in a sat solver 8ifdis satisfiable then 9convert boolean variables matrix to a k oaa 10a pruneaw.r.t.s ands 11returna 12else return ikoa s s k synthesis from positive and negative examples but it can also synthesize regular expressions from positive or negative examples onlybyremovingthecorrespondingconstraintsofnegative orpositive examples.
moreover our algorithm is incremental since one can synthesize a correct regex by feeding more and more examples gradually.
.
regex extraction in this section we present our procedure genregex to extract a regexfromamarked k oa.asmentionedinsection2 amarked koa is also an soa.
freydenberger and kotzing have proposed an efficient procedure soa2soreto convert a given soa ato an sorerthat minimally generalizes l a .
this procedure recurses first on all strongly connected looped components and then on the directed acyclic graph obtained by contracting all strongly connected components sccs i.e.
a maximal subgraph in which every node is reachable from every other node with pluses .
here we use this procedure to extract regex from a marked k oa.
the procedure genregex proceeds as follows genregex first invokessoa2sore a to converta marked k oaainto ansore i.e.
amarkedregex r thendropsoffthemarksofallsymbolsin r and finally returns the unmarked regex if it is deterministic4 o r returnsnullotherwise.
further we adopted a regex rewriting step to prettify the synthesized regex rin order to get a more concise and practical one by performing on rthe rewritingrules infigure 4until nomore rule is applicable.
finally as shown in algorithm our algorithm may return null i.e.
fail which is mainly due to i the parameter kmay not be sufficientlylarge and ii noteveryregexhasanequivalentdeter ministicversion asdeterministicregexesare arestrictedsubclass of regexes.
repair algorithm in practice one may write an incorrect or redos vulnerable regex.
so inthesection wepresentanalgorithmbasedonneighborhood 4the determinism of a regex can be decided in linear time .
determinism constraint generator deter k logicalanddisplay.
braceleftbigg bracketleftbig logicalordisplay.
m k parenleftbigasrc m logicalanddisplay.
n k n m asrc n parenrightbig bracketrightbig parenleftbig logicalanddisplay.
m k asrc m parenrightbig bracerightbigg logicalanddisplay.
logicalanddisplay.
t k braceleftbigg bracketleftbig logicalordisplay.
m k parenleftbiga t m logicalanddisplay.
n k n m a t n parenrightbig bracketrightbig parenleftbig logicalanddisplay.
m k a t m parenrightbig bracerightbigg positive example constraint generators posa w k a src snk w logicalordisplay.
m k parenleftbigasrc w m aw m snk parenrightbig w logicalordisplay.
m1 kasrc w m1 logicalanddisplay.
i w parenleftbig logicalordisplay.
m k n kaw m w n parenrightbig logicalordisplay.
m w kaw m w snk w posb w k t w logicalanddisplay.
m1 k bracketleftbig asrc w m1 logicalanddisplay.
m k parenleftbigaw m1 w m aw m snk parenrightbig bracketrightbig w bracketleftbig logicalanddisplay.
m1 k parenleftbigasrc w m1 logicalordisplay.
m kaw m1 w m parenleftbig logicalordisplay.
n kaw m w n parenrightbig parenrightbig bracketrightbig bracketleftbig logicalanddisplay.
m k logicalanddisplay.
n k parenleftbigaw m w n logicalordisplay.
t k parenleftbigaw n w t aw t snk parenrightbig parenrightbig bracketrightbig w bracketleftbig logicalanddisplay.
m1 k parenleftbigasrc w m1 logicalordisplay.
m kaw m1 w m parenleftbig logicalordisplay.
n kaw m w n parenrightbig parenrightbig bracketrightbig bracketleftbig logicalanddisplay.
i w logicalanddisplay.
m k logicalanddisplay.
n k parenleftbigaw m w n logicalortext.
t kaw n w t parenleftbig logicalortext.
o kaw t w o parenrightbig parenrightbig bracketrightbig bracketleftbig logicalanddisplay.
m k logicalanddisplay.
n k parenleftbigaw m w n logicalordisplay.
t k parenleftbigaw n w t aw t snk parenrightbig parenrightbig bracketrightbig w negative example constraint generators neg w k exam w k w bracketleftbig logicalanddisplay.
m k parenleftbigasrc w m parenleftbig logicalordisplay.
n kaw m w n parenleftbig logicalordisplay.
t kaw n w t parenrightbig parenrightbig parenrightbig bracketrightbig bracketleftbig logicalanddisplay.
m k logicalanddisplay.
n k parenleftbigaw m w n parenleftbig logicalordisplay.
t k parenleftbigaw n w t aw t snk parenrightbig parenrightbig parenrightbig bracketrightbig w bracketleftbig logicalanddisplay.
m k parenleftbigasrc w m parenleftbig logicalordisplay.
n kaw m w n parenleftbig logicalordisplay.
t kaw n w t parenrightbig parenrightbig parenrightbig bracketrightbig bracketleftbig logicalanddisplay.
i w logicalanddisplay.
m k logicalanddisplay.
n k parenleftbigaw m w n parenleftbig logicalortext.
t kaw n w t parenleftbig logicalortext.
o kaw t w o parenrightbig parenrightbig parenrightbig bracketrightbig bracketleftbig logicalanddisplay.
m k logicalanddisplay.
n k parenleftbigaw m w n parenleftbig logicalordisplay.
t k parenleftbigaw n w t aw t snk parenrightbig parenrightbig parenrightbig bracketrightbig w figure determinism constraint generator and local constraint generators c1 ... cn w r1...r1 bracehtipupleft bracehext bracehext bracehext bracehext bracehtipdownright bracehtipdownleft bracehext bracehext bracehext bracehext bracehtipupright ktimes r1 k r1...r1 bracehtipupleft bracehext bracehext bracehext bracehext bracehtipdownright bracehtipdownleft bracehext bracehext bracehext bracehext bracehtipupright ktimesr r1 k d s r1...r1 bracehtipupleft bracehext bracehext bracehext bracehext bracehtipdownright bracehtipdownleft bracehext bracehext bracehext bracehext bracehtipupright ktimesr1?
r1 k k r1...r1 bracehtipupleft bracehext bracehext bracehext bracehext bracehtipdownright bracehtipdownleft bracehext bracehext bracehext bracehext bracehtipupright ktimesr r1 k figure rewriting rules for regex search ns to repair such an incorrect or redos vulnerable regex to achieve the same goals as our synthesis algorithm.
in particular given an incorrect or redos vulnerable regex rand sets of positive and negative examples it returns a redos invulnerable regex r prime that is consistent with the examples.
we assume that the given regex is close to a solution.
so the key idea of our algorithm is to search for a better solution i.e.
one that accepts more positive samples and or rejects more negative samples from the neighborhoods of a candidate k oa.
to start with we define the neighborhood and an evaluation criterion of ak oaa.
given a k oaa i.e.
a boolean matrix we define its neighborhood denoted as n a as the set of k oas which can be obtainedbyflippingone booleanvalueof a.inordertoselecta k oa among a set of k oas we define a measure fonk oa with respectto s ands as f a s s tp fn tn fp s s where we have tp w s w l a fn w s w l a tn w s w l a fp w s w l a and s isthenumberofelementsintheset s.intuitively thehigherthefvalue the better the k oa.
especially the k oa with fvalue will acceptall positive samplesand reject allnegative samples.
in addition iftwo k oassharethesame fvalue wewillselecttheone withfewersccs orloops .moreover similartoregexsynthesis we use deterministic regexes to avoid redos vulnerabilities.
the repair algorithm is shown in algorithm .
it starts with a deterministic k oaathatisconvertedfromthemarkedversion ofthegivenregex r line1 .then thealgorithmselects the k oa withthemaximum fvalue denotedas amax fromtheneighborhoods of a line .
next it compares the fvalues between the currentk oa and the selected k oa.
if the selected k oa gets a higherfvalue then the algorithm replaces the current k oa by the deterministic version of the selected k oa lines .
after that itcheckswhetherthecurrent k oaissatisfied namely the fvalue is .
if it is the algorithm returns a regex extracted from the pruned version of the current k oa lines .
while if the selectedk oa gets a lower fvalue then the current k oa may bealocalmaximum sothealgorithmreturns null5 line12 .the algorithm repeats the processing above until a satisfactory k oa is returnedortheiterationnumberexceedsiter max lines3 .
finally the algorithm returns nullif the iteration number exceeds iter max line .
ak oacanbeobtainedeasilyfromthemarkedform rofr i eachsymbolin rformsastateof k oa ii foreachsymbol a there is an edge from ato any symbol that follows ainr iii there is an edgefrom srctoanysymbolthatmaybematchedfirstin r similar 5enlarging the neighborhood is a possible but ineffective approach to search a better solution.
664algorithm repairingre input a regexr a positive set s a negative set s output a deterministic regex rwiths l r and s l r if solvable or nullotherwise 1a disambiguate re2koa r s s 2i 3whilei iter max do 4amax arg max a prime n a f a prime s s 5iff amax s s f a s s then a disambiguate amax s s iff a s s 1then a pruneaw.r.t.s ands r genregex a returnr i i 12else return null 13returnnull tosink.
then a deterministic version can be obtained by removing the superfluous edges via the procedure disambiguate given in algorithm .
algorithm disambiguate input ak oaa a positive set s a negative set s output a deterministic k oaa 1while s a.vand .
out v 1do 2c 3fort out v do a prime a delete s t prime ina primefor allt prime out v t adda primeinc 7a arg max a prime cf a prime s s 8returna note that character classes can be treated as special symbols such that all special symbols are pairwise disjoint.
inaddition therepairalgorithmisincrementalaswell.theuser may think that if she keeps on repairing the regex with some more interesting positive or negative examples then she could finally get the equivalent one that she wants.
however the fact is that our neighborhood search may not find such a solution in a limited number of iterations if the given examples are too many or the given regex is far away from a solution.
nevertheless in that case we would strongly suggest the user to use the synthesis algorithm instead.
evaluation weimplementedflashregexbasedonz3 smtsolverinpython and conducted experiments on a machine with cores intel xeon cpu e5620 .40ghz with 12mb cache 24gb ram running windows10operatingsystem.ouropen sourceimplementationtable benchmarks task benchmark number sources description synthesisbin syn rege x5 0alpharegexpublic autotutor alphabet size is binary multi syn regex 50regex golf regexlib alphabet size is large repair incorrect pos rep regex rebele et al.
incorrect regex positive examples only pos neg rep regex 129regexlib autotutor incorrect regex positive and negative examples repair sl sl regex2 0owasp stackoverflow snyk regexlib davis et al.
cve redos vulnerable regex positive and negative examples andthedatasetsoftheexperimentsareavailableonline6.theexperiments were designed to study three sets of research questions concerning flashregex s functionalities i.e.
synthesizing regexes repairing incorrect regexes and repairing sl regexes .
rq1.evaluation of regex synthesis.
can flashregex synthesize regexes efficiently?
.
.
can flashregex synthesize regexes from examples correctly?
.
.
can flashregex synthesizesaferegexesthatarefreefromredos vulnerabilities?
.
.
canthelocalconstraintss peedupthe solutionprocess?
.
.
rq2.evaluationofincorrectregexrepair.
canflashregexrepair incorrect regexes efficiently?
.
.
can flashregex repair incorrect regexes from examples correctly?
.
.
canflashregexrepairincorrectregexessothattheyarefree from redos vulnerabilities?
.
.
rq3.evaluation of sl regex repair.
canflashregex repairsl regexesefficiently?
.
.
canflashregexrepairslregexes from examplescorrectly?
.
.
canflashregex repair sl regexessothattheyarefreefromredos vulnerabilitiesafter repair?
.
.
.
benchmarks and existing tools to evaluate flashregex in three application scenarios under differentprerequisites weconstructedtenseparatebenchmarksaccordingly collectedfrom widely usedsources i regex golf ii alpharegexpublic iii autotutor dataset iv the regexlib library v rebele et al.
vi owasp7 vii stackoverflow8 viii snyk9 ix davis et al.
and x common vulnerabilities and exposures cve .
some information of them is given in table .
we compared flashregex with five state of the art tools gpregexgolf alpharegex regexgenerator rfixer andtheonerecentlyproposedby rebeleetal.
.amongthem gp regexgolf alpharegex and regexgenerator were developed for regex synthesis while the remaining two for regex repair.
furthermore we used three tools to detect redos vulnerabilities rescue rexploiter andsdlfuzzer andmanuallychecked all inconsistent results concluded by these tools.
665table the effectiveness and efficiency of regex synthesis benchmarks bin syn rege x multi syn rege x technique sol csol vulavg.
sol csol vulavg.
time s time s regexgenerator .
gp regexgolf .
alpharegex .
flashregex exact .
.
flashregex lcs .
.
flashregex .
.
.
evaluation of regex synthesis in this experiment we evaluated the effectiveness and efficiency of regex synthesis as well as its comparison with the exact directed flashregex exact and local directed flashregex lcs constraint encodings.
the evaluation results are shown in table .
the experiments were conducted on two benchmarks bin syn regex and multi syn regex measuring the performance on benchmarks with different alphabet sizes.
columns in each benchmark represent the number of synthesized regexes by each tool sol the number of correctly synthesized ones by each tool i.e.
the ones that areconsistent with all the examples csol the number of redosvulnerableonesinthesynthesizedresults vul andtheaverage time of synthesizing one regex in seconds avg time respectively.
thesymbol indicatesthatthetooldoesnotsupportthecorresponding benchmark functionally.
.
.1efficiencyofregexsynthesis .table2comparestheruntime efficiency of flashregex with three synthesis tools by their average time in seconds taken to synthesize a regex on the corresponding benchmark.
on benchmark bin syn regex with binary alphabetsize thoughthedifferencesinaveragetimearesmall rang ingfrom1.1to7.6seconds theaverageruntimeofflashregex .
seconds isstilllessthanhalfofthatofalpharegex .6seconds .
on benchmark mul syn regex with multiple alphabet sizes the average time varies greatly from one hour to few seconds.
note that the time in table refers to average time so the total running time taken by regexgenerator and gp regexgolf on this benchmark are more than hours and hours respectively which is considered unaffordable in practice.
in contrast flashregex using eitherofthesynthesisalgorithms onlytakesanaverage4seconds which is significantly more efficient than the other tools.
.
.2correctness of regex synthesis .theresultsoncorrectnessaresummarizedbycolumn csolintable2.thecorrectnessof synthesized regex is crucial.
it guarantees the quality of regexes aftersynthesis.theexperimentsshowthatthecorrectnessofexisting toolsisunsatisfactory.wecanseethatthoughregexgenerator and gp regexgolf can synthesize all the regexes on the second benchmark only3and7ofthemarecorrect.itismainlybecause theyrequirethesynthesizedregextobeconsistentwithasmany givenexamplesaspossible insteadofalltheexamples.bycontrast flashregex and alpharegex achieve correctness ratio becausetheyaimtofindaregexthatacceptsallthepositiveexamples while rejecting all the negative examples.
figure ?
figure ?
.
.3redos vulnerabilityofregexsynthesis .thetwo vul columns in table show that and regexes synthesized by gpregexgolf and alpharegex respectively are redos vulnerable.in other words the consistency with given examples does notnecessarily guarantee the synthesized regexes free from redosvulnerability.incontrast alltheregexessynthesizedbyflashregex are redos invulnerable.
letusgiveanexamplefrom bin syn regex toillustratethedifferencebetweenredos vulnerableandredos invulnerableregexes.
given the same set of positive and negative examples alpharegex synthesizes ?
whileflashregexsynthesizes ?
.
although the two regexes are equivalent their evaluations take exponential and linear time in the length of the input respectively.
let us consider therailroad diagrams of these two regexes which are given in figures and .
suppose the given string is there are two possible paths in figure to generate this string while thereisonlyonepathinfigure6.whenthegivenstringis there are four possible paths in figure whereas there is still one possiblepathinfigure6.thisillustrateshowthetwosearchspaces differ as the length of the input increases.
.
.4evaluation of different constraint encodings .table shows that flashregex exact is more effective than flashregexlcs in synthesizing significantly more regexes.
on the other hand flashregex lcsismoreefficientbyleveragingthelcsheuristic strategy.thereare14 benchmarkson bin syn regex multi synregex that flashregex exact can solve while flashregex lcs cannot.
flashregex exact is on average .0x slower than flashregexlcs onbin syn regex and .6x slower on multi syn regex.
the two constraint encodings are complementary on effectiveness and efficiency.
summarytorq1 flashregexcansynthesizeregexefficiently correctlyandsafely.theadvantageofhighefficiencyofflashregexbecomesmoreobviouswiththeincreaseofthealphabetsize.also the two constraint encodings of flashregex are complementary oneffectivenessandefficiency.theresultsalsoconfirmedthelack of focus on redos vulnerability in previous works thus making further repair a necessity.
.
evaluation of incorrect regex repair table shows the evaluation results of repairing incorrect regexes in terms of efficiency correctness and redos vulnerability.
it uses the same columns as table .
the experiments were conducted on pos rep regex andpos neg rep regex benchmarks.forcomparison thetools proposedby rebeleet al and rfixerwere evaluated.
notethattheregexesunderrepairintheevaluationareincorrect.
666table redos vulnerable regexes repaired by rfixer and flashregex.
rv denotes redos vulnerable.
no.
source sl sub regexrfixer flashregex repaired sub regex time s rv repaired sub regex time s rv 1owasp a aa a aa .
v a .
i owasp a a?
a?
.
i a .
i owasp .
v .
i stackoverflow x x y x y .
v xx y .
i snyk w d c w d c .
v d c .
i regexlib d d d d .
v d d .
i regexlib d d .
v d d .
i regexlib d d .
d d d .
d .
v .
?
d .
i davis et al.
s ?
s s ?
s .
v s s ?
.
i davis et al.
n s n s .
v n s .
i davis et al.
.
v .
i cve a a .
v a .
i cve a b c d a b c d .
v a b c d .
i cve s s s s .
i s s .
i cve s s ?
s s ?
.
v s s ?
.
i cve s n s n s .
i n s .
i cve s ?
s ?
.
v s s ?
.
i cve ?
?
.
v ?
.
i cve ?
?
.
v ?
d .
i cve .
i .
i table redos vulnerable regexes repaired by experts and flashregex.
rv denotes redos vulnerable.
source sl regexexpert flashregex strategy fix solution rv strategy fix solution rv cve a b c d revise a ?
b c d i revise a b c d i cve s s revise s s v revise s s i cve s s ?
trim limit match string only allow max spaces and charset string revise s s ?
i cve s n s resort i splitthelineby n and ii trimeach line iii then join each line by revise n s i cve s ?
revise s ?
v revise s s ?
i cve ?
revise ?
i revise ?
i cve ?
revise ?
i revise ?
d i cve revise i revise i they either reject some positive examples or accept some negative ones.
table the effectiveness and efficiency of incorrect regex repair benchmarks pos rep rege x pos neg rep rege x technique sol csol vulavg.
sol csol vulavg.
time s time s rebele et al .
rfixer .
.
.
flashregex .
.
.
.
.1efficiencyofincorrectregexrepair .thetoolproposed by rebele et al.
ran the fastest .
seconds on the first benchmark i.e.
the one from the tool but it cannot handle negative examples.
rfixer took the longest average time on both benchmarks.
ittookmuchmoreaveragetimeonthegivennegativeexamples.in constrast theefficiencyofflashregexwasmildlyaffectedbythe negative samples.the averagetime it tookincreased mildlyfrom .
to .
seconds.
.
.2correctness of incorrect regex repair .table shows thatthetoolproposedbyrebeleetal.
canrepairthemostnumber of regexes on the first benchmark but it is not able to process any negativeexamples on thesecond benchmark.
flashregexcan repair .
of the incorrect regexes .
more regexes than those repaired by rfixer on the second benchmark.
.
.3redos vulnerabilityofincorrectregexrepair .according to the vul coulmn in table three .
redos vulnerable regexes were generated by rfixer on the first benchmark.
the number increases significantly on the second benchmark.
there were .
regexes repaired by rfixer suffered from redosvulnerability.incontrast flashregexcanrepair337moreregexes than rfixer with no redos vulnerable regexes generated.
letuspresentafewincorrectregexestoillustratethevulnerable and invulnerable repairs.
from pos neg rep regex for the incorrectregex arepairedregexproducedbyrfixeris whichisredosvulnerable.
wecan seethat althoughthis regex isconsistent with the given examples it still causes ambiguity because its star height i.e.
nestedquantifiers equalstotwo.forexample thestring can be either consumed by the inner quantifier or the outer one leadingtoincorrectbehaviorwithworst caseexponential costs on a mismatch.
in contrast flashregex deduced the regex ?
which successfully avoids the security issue.
similarincorrectonesrepairedbyrfixerhavealsobeenfoundfrom pos rep regex they are d and ?
d .
?
.both are redos vulnerable.
summary to rq2 flashregex can repair incorrect regex efficiently correctlyandsafely.theefficiencyisnotaffectedsignificantly by negative examples and the regex after repair is free from redos vulnerability.
.
evaluation of sl regex repair the evaluation results of sl regex repair are shown in table .
we compared flashregex with rfixer which is designed to repair regexes from both positive and negative examples.
the benchmark contains20slregexes listedintable3 withpositiveandnegative examples.
due to the space constraint we only show the problematicsub regexesforsomeregexes.examplescorrespondingtothese sub regexesaregeneratedmanuallyorbasedonthebricsautomaton library .
specifically the positive examples are enumerated byrandomlytraversingthedeterministicfiniteautomaton dfa of the given regex resp.
the negative examples are synthesized bystochasticallytraversingthedfaofthenegationofthegiven regex .thecolumnsinthetablerepresentthesourcesofeachregex source the redos vulnerable regex sl sub regex columns in rfixerandflashregexaretheregexrepairedbythecorresponding tools repaired sub regex therunningtimeinseconds time and whether the repaired regexes are redos vulnerable rv v for vulnerable ifor invulnerable .
.
.1efficiencyofslregexrepair .theaveragerunningtime takenforrepairingvariesacrossregexes.rfixertookfromlessthan .
to seconds and .
seconds on average.
flashregex offersamorestableandbetterefficiency rangingfrom0.04to23.
seconds and .
seconds on average.
.
.2correctness of sl regex repair .in table all the repaired regexes are consistent with the given examples.
this suggests the correctness of both tools.
the results are also in line with the results of repairing incorrect regexes in table .
.
.3redos vulnerability of sl regex repair .according to table regexes repaired by rfixer are still vulnerable to redos attacks.
in constrast all the sl regexes repaired by flashregex are free from redos vulnerabilities.
we further compared the results repaired by flashregex with theresultsachievedbydeveloperexperts whicharegiveninta ble .
we found that experts repaired sl regexes using one of three strategies introduced by davis et al.
revising the regex trimming the input or resorting it to alternate logic.
the first one ismotivatedbutnoteasyto results regexes repaired by experts are still vulnerable to redos attacks and the invulnerable ones may be difficult for users tofollow e.g.
thefirstoneusingback referenceandthelastone usingboundediteration .incontrast alltheslregexesrepairedby flashregex are free from redos vulnerabilities.
the second one works well but is not friendly to users while the last one is only effective for some special regexes i.e.
it cannot be generalized .
summary to rq3 flashregex can repair redos vulnerable regex efficiently and correctly.
the experiment also indicates the incapability of existing work for repairing redos vulnerable regex.
further comparing with the manual repair flashregex worksinan automatic anduser friendlymanner keepingusers intention meanwhile getting rid of the redos vulnerability.
threats to flashregex s validity considering that flashregex is aprogramming by example pbe algorithm thequalityofregexsynthesizedbyflashregexhighly dependsonthequalityofexamples.inotherwords ifuserscannot provide sufficient characteristic examples the synthesized regexes willbeunsatisfactory i.e.
over fittingorunder fitting .toalleviate this problem we can adopt the following three strategies generalizedexamples.theusersprovidesomeabstractgeneralizedexamples ratherthanconcreteexamples.the generalizedexamples can reduce the amount of required concrete characteristic examplesmeanwhilelesseningtheworkloadfromusers thereby improving the quality of regex synthesis by generalizing concrete examples.forinstance wecanuseageneralizedexample num dog instead of concrete examples e.g.
1dog 2dog 3dog .
integration of pbe and programming by natural language pbnl .
wecanleveragepbnltechniquestoovercomethedrawbacksof pbetechniques.specifically incorporatingnaturallanguagecan greatlyimprovethegeneralizationofpbetechniques.forexample we can use the natural language description lines with vowels after lower case letters as a major resource and some concrete example e.g.
biiiiandcee insteadofalargenumberofconcrete examples.
interactionwithusers.amoreuser friendlystrategyisthatwhenever the generated regex is out of expectation of users they can add delete updateexamplesinteractivelysothattheresultingregex can be adjusted dynamically until meet users requirements.
11due to space constraint only solutions from cve are given.
related work programming by example pbe .
pbe techniques have been the subject of research in the past few decades and successful paradigms for program synthesis allowing end users to construct and run new programs by providing examples of the intended programbehavior .recently pbetechniqueshavebeensuccessfullyusedforstringtransformations datafiltering datastructuremanipulations tabletransformations sqlqueries mapreduceprograms andalsoregex synthesis .inthispaper wetakeadvantage ofpbetechniquestoenhanceuser friendlinessbyallowingusers to provide examples to reflect their true intentions.
redosdetectionandprevention.
varioustechniqueshavebeen proposed toidentifyredos vulnerabilities which can be mainly classified into two paradigms static analysis and dynamic fuzzing .
to prevent redos attacks davis et al.
identified three anti patterns of regexes as prerequisites of redos attacks andrecommended avoiding using them.
these anti patterns include i regexes with nested quantifiers e.g.
a b c d ii regexes withquantifiedoverlappingdisjunction qod e.g.
w d and iii regexes with quantified overlapping adjacency qoa e.g.
s ?
s .inourwork weadoptdeterministic k oaanddeterministicregexconstraintstoavoidtheambiguitycausedbyqodorqoainflashregexalgorithms andsearchingforsolutionsstarting fromk can effectively avoid nested quantifiers.
redosattackscanalsobealleviatedbyregexmatchingspeedup whichispossibleinsomespecialcases e.g.
byparallelalgorithms gpu basedalgorithms state mergingalgorithms andthompson snon deterministicfiniteautomatonalgorithm .however these can only alleviate the redos vulnerability problem sincetheregexesthemselvesarestillsubjecttoredosattacks.in our work we address this issue from the regexes side.regexes synthesis.
the problem of automatic regex synthesis fromexampleshasbeenexploredinmanydomains .
alpharegex is an enumeration algorithm for synthesizing simple regexes over binary alphabets from examples.
however all the synthesized expressions are over alphabets of size .
regexgenerator is a state of the art approach for the synthesis of regexes from examples.
the fact that regexgenerator utilizes genetic programming means that it is not guaranteed to generate a correct solution i.e.
accepting all the positiveexampleswhilerejectingallthenegativeexamples.lotsof existingworksfocusonxmlschemasinference via resorting to infer regexes from examples.
these approaches usuallyaimtotacklerestrictedformsof deterministic regexes frompositiveexamplesonly.
gp regexgolf isanapproachbased on genetic programming for playing regex golf automatically i.e.
for writing the shortest regex that matches all positive strings and does not match any negative string.
unlike many of these efforts which aim to generalize beyond the provided examples gpregexgolf focuses on binary classifying input strings and it does notrequireaformofgeneralization i.e.
theabilityofinducinga generalpatternfromtheprovidedexamples.severalworksfrom the natural language processing community address the problemofgeneratingregexesfromnaturallanguagespecificationsbased on sequence to sequence seq2seq model .
all of the synthesis techniques above barely pay attention to preventing redos during the synthesis process making the synthesized regexes hyper vulnerable to redos attacks.regexesrepair.
thereareseveralworkstargetingatrepairingor modifyingregexesfromexamples specificallytheincorrectregexes.
we discuss two main paradigms of them.
in the first paradigm works only consider either positive or negative examples.
li et al.
proposed relie which can modify complex regexes by rejectingthenewly inputnegativeexamples.bycontrast rebele et al.
proposed a novel way to generalize a given regex so that itacceptsthegivenpositiveexamples.ontheotherhand works in thesecond paradigmtake bothpositive and negativeexamples into consideration.
pan et al.
designed rfixer a tool for repairing incorrect regexes using both examples.
it took advantage of skeletons of regexes to effectively prune out the search space and itemployedsmtsolverstoefficientlyexplorethesetsofpossible character classes and numerical quantifiers.
our work is similarto their work yet differs in the effectiveness and quality of repairedregexes weconsidernotonlythecorrectness butalsothe redos invulnerability of the regexes.
thereisonlytwoworkexploringhowtorepairredos vulnerable regexes which considers revisions that match the exact same languages of the original regexes.
however the exact equivalence is too strong to use in practice .
conclusion manytechniquesforsynthesizingorrepairingregexeshavebeen proposed.
however the lack of attention to redos vulnerabilities affects the security of existing tools.
we propose a pbe framework flashregex which provides three core functionalities including regex synthesis incorrect regex repair and redos vulnerable i.e.
sl regexrepair.thisisachievedbydevisingnovelalgorithmsto deducedeterministicregexesfrombothpositiveandnegativeexam plesbasedonsatorns.oursisthefirstframeworkthatintegrates thesynthesisandrepairofregexeswiththeawarenessofredosvulnerabilities.
the evaluation results show that our work can effectively and efficiently generate anti redos regexes from given examples andhasbettercapabilitythanexistingrepairtoolsand evenhumanexpertsonredos vulnerableregexrepair demonstrat ingtheusefulnessofourwork.the resultsalsorev ealthatexisting synthesis and repair tools have neglected redos vulnerabilities of regexes.
although ourexperiments haveshown theeffectiveness andefficiencyofflahsregex weplantoconductalargerscaleof evaluation with more complex subjects in our future work.
acknowledgment the authors would like to thank the anonymous reviewers for their comments and suggestions.
this work is supported in part by nationalnaturalsciencefoundationofchina grants nsfgrant iis guangdong basic and applied basic research foundation under grant 2019a1515011577 and huawei phd fellowship msra collaborative research grant.
669references maaz bin safeer ahmad and alvin cheung.
.
leveraging parallel data processingframeworkswithverifiedlifting.in proceedingsfifth workshopon synthesis synt cav toronto canada july .
.
adam baldwin.
.
regular expression denial of service affecting express.js.
alberto bartoli giorgio davanzo andrea de lorenzo eric medvet and enrico sorio.
.
automatic synthesis of regular expressions from examples.
ieee computer .
alberto bartoli andrea de lorenzo eric medvet and fabiano tarlao.
.
playing regex golf with genetic programming.
in genetic and evolutionary computation conference gecco vancouver bc canada july .
.
alberto bartoli andrea de lorenzo eric medvet and fabiano tarlao.
.inference of regular expressions for text extraction from examples.
ieee trans.
knowl.
data eng.
.
michela becchi and srihari cadambi.
.
memory efficient regular expres sion search using state merging.
in infocom .
26th ieee international conference on computer communications joint conference of the ieee computer and communications societies may anchorage alaska usa.
ieee .
geert jan bex wouter gelade frank neven and stijn vansummeren.
.
learningdeterministicregularexpressionsfortheinferenceofschemasfrom xml data.
tweb4 .
geert jan bex frank neven thomas schwentick and stijn vansummeren.
.
inferenceofconciseregularexpressionsanddtds.
acmtrans.databasesyst.
.
anne br ggemann klein.
.
unambiguity of extended regular expressions insgmldocumentgrammars.in algorithms esa firstannualeuropean symposium bad honnef germany september october proceedings.
.
carl chapman peipei wang and kathryn t. stolee.
.
exploring regular expressioncomprehension.in proceedingsofthe32ndieee acminternational conferenceonautomatedsoftwareengineering ase2017 urbana il usa october november .
.
brendan cody kenny michael fenton adrian ronayne eoghan considine thomas mcguire and michael o neill.
.
a search for improved performance in regular expressions.
in proceedings of the genetic and evolutionary computationconference gecco2017 berlin germany july15 .
.
russcox.
.regularexpressionmatchingcanbesimpleandfast butisslowinjava perl php python ruby ... .
lorisd antoni rishabhsingh andmichaelvaughn.
.
nofaq synthesizing command repairs from examples.
in proceedings of the 11th joint meeting on foundations of software engineering esec fse paderborn germany september .
.
james c. davis christy a. coghlan francisco servant and dongyoon lee.
.
the impact of regular expression denial of service redos in practice an empiricalstudyattheecosystemscale.in proceedingsofthe2018acmjoint meeting on european software engineering conference and symposium on the foundationsofsoftwareengineering esec sigsoftfse2018 lakebuenavista fl usa november .
.
james c. davis louis g. michael iv christy a. coghlan francisco servant and dongyoon lee.
.
why aren t regular expressions a lingua franca?
anempiricalstudyonthere useand portabilityofregularexpressions.in proceedingsoftheacmjointmeetingoneuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec sigsoftfse tallinn estonia august .
.
leonardo mendon a de moura and nikolaj bj rner.
.
z3 an efficient smt solver.
in tools and algorithms for the construction and analysis of systems 14th international conference tacas held as part of the joint european conferences on theory and practiceof software etaps budapest hungary march april .
proceedings.
.
erling ellingsen.
.
regex golf.
kevinellisandsumitgulwani.
.learningtolearnprogramsfromexamples goingbeyondprogramstructure.in proceedingsofthetwenty sixthinternational jointconferenceonartificialintelligence ijcai2017 melbourne australia august .
.
stack exchange.
.
outage postmortem.
outage postmortem july yu feng ruben martins jacob van geffen isil dillig and swarat chaudhuri.
.
component based synthesis of table consolidation and transformation tasks from examples.
in proceedings of the 38th acm sigplan conference on programming language design and implementation pldi barcelona spain june .
.
henning fernau.
.
algorithms for learning regular expressions from positive data.
inf.
comput.
.
john k. feser swarat chaudhuri and isil dillig.
.
synthesizing data structure transformations from input output examples.
in proceedings of the 36th acmsigplanconferenceonprogramminglanguagedesignandimplementation portland or usa june .
.
python software foundation.
.
pypi the python package index.
https pypi.org dominik d. freydenberger and timo k tzing.
.
fast learning of restricted regular expressions and dtds.
theory comput.
syst.
.
e. markgold.
.
complexityofautomatonidentificationfrom givendata.
information and control .
beno t groz and sebastian maneth.
.
efficient testing and matching of deterministic regular expressions.
j. comput.
syst.
sci.
.
sumitgulwani.
.
automatingstringprocessinginspreadsheetsusinginputoutput examples.
in proceedings of the 38th acm sigplan sigact symposium onprinciplesofprogramminglanguages popl2011 austin tx usa january .
.
william r. harris and sumit gulwani.
.
spreadsheet table transformations fromexamples.in proceedingsofthe32ndacmsigplanconferenceonprogramminglanguagedesignandimplementation pldi2011 sanjose ca usa june .
.
louisg.michael iv jamesdonohue james c.davis dongyoonlee and francisco servant.
.
regexes are hard decision making difficulties and risks inprogrammingregularexpressions.in 34thieee acminternationalconference on automated software engineering ase san diego ca usa november .
.
james kirrage asiri rathnayake and hayo thielecke.
.
static analysis for regularexpression denial of serviceattacks.in networkand systemsecurity7th international conference nss madrid spain june .
proceedings.
.
natekushmanandreginabarzilay.
.usingsemanticunificationtogenerate regular expressionsfromnatural language.in human languagetechnologies conference of the north american chapter of the association of computationallinguistics proceedings june westin peachtree plaza hotel atlanta georgia usa.
.
mina lee sunbeom so and hakjoo oh.
.
synthesizing regular expressions fromexamplesforintroductoryautomataassignments.in proceedingsofthe 2016acmsigplaninternationalconferenceongenerativeprogramming concepts and experiences gpce amsterdam the netherlands october november .
.
yunyao li rajasekar krishnamurthy sriram raghavan shivakumar vaithyanathan and h. v. jagadish.
.
regular expression learning for information extraction.
in conference on empirical methods in natural languageprocessing emnlp2008 proceedingsoftheconference 27october honolulu hawaii usa a meeting of sigdat a special interest group of the acl.
.
yeting li xiaolan zhang jialun cao haiming chen and chong gao.
.learning k occurrence regular expressions with interleaving.
in database systems for advanced applications 24th international conference dasfaa chiang mai thailand april proceedings part ii.
.
cheng hung lin chen hsiung liu and shih chieh chang.
.
accelerating regular expression matching using hierarchical parallel machines on gpu.
inproceedingsoftheglobalcommunicationsconference globecom2011 december houston texas usa.
ieee .
nicholaslocascio karthiknarasimhan eduardodeleon natekushman and regina barzilay.
.
neural generation of regular expressions from natural languagewithminimaldomainknowledge.in proceedingsofthe2016conference on empirical methods in natural language processing emnlp austin texas usa november .
.
andersm ller.
.
dk.brics.automaton finite stateautomataandregular expressions for java.
inc. npm.
.
npm.
rong pan qinheping hu gaowei xu and loris d antoni.
.
automatic repair of regular expressions.
pacmpl oopsla .
jun u. park sang ki ko marco cognetta and yo sub han.
.
softregex generatingregexfromnaturallanguagedescriptionsusingsoftenedregex equivalence.
in proceedings of the conference on empirical methods in naturallanguage processingandthe 9thinternationaljoint conferenceonnatural languageprocessing emnlp ijcnlp2019 hongkong china november3 .
.
theofilospetsios jasonzhao angelosd.keromytis andsumanjana.
.
slowfuzz automated domain independent detection of algorithmic complexity vulnerabilities.
in proceedings of the acm sigsac conference on computer and communications security ccs dallas tx usa october november .
.
asirirathnayake.
.
semantics analysisandsecurityofbacktrackingregular expression matchers.
ph.d. dissertation.
university of birmingham uk.
asiri rathnayake and hayo thielecke.
.
static analysis for regular ex pression exponential runtime via substructural logics.
corrabs .
.
thomasrebele katerinatzompanaki andfabianm.suchanek.
.
adding missing words to regular expressions.
in advances in knowledge discovery and data mining 22nd pacific asia conference pakdd melbourne vic australia june proceedings part ii.
.
regexlib.
.
regular expression library.
david e. shaw william r. swartout and c. cordell green.
.
inferring lisp programs from examples.
in advance papers of the fourth international joint conference on artificial intelligence tbilisi georgia ussr september .
.
yuju shen yanyan jiang chang xu ping yu xiaoxing ma and jian lu.
.rescue crafting regular expression dos attacks.
in proceedings of the 33rd acm ieeeinternationalconferenceonautomatedsoftwareengineering ase2018 montpellier france september .
.
rishabh singh.
.
blinkfill semi supervised programming byexample for syntactic string transformations.
pvldb9 .
rishabh singh and sumit gulwani.
.
learning semantic string transformations from examples.
pvldb5 .
calvinsmithandawsalbarghouthi.
.
mapreduceprogramsynthesis.in proceedings of the 37th acm sigplan conference on programming language design and implementation pldi santa barbara ca usa june .
.
eric spishak werner dietl and michael d. ernst.
.
a type system for regularexpressions.in proceedingsofthe14thworkshoponformaltechniques for java like programs ftfjp beijing china june .
.
satoshisugiyamaandyasuhikominamide.
.
checkingtimelinearityof regular expression matching based on backtracking.
information and media technologies .
bryansullivan.
.
newtool sdlregexfuzzer.
com microsoftsecure new tool sdl regex fuzzer ken thompson.
.
regular expression search algorithm.
commun.
acm .
brink van der merwe nicolaas weideman and martin berglund.
.
turning evil regexes harmless.
in proceedings of the south african institute of computer scientists and information technologists saicsit thaba nchu south africa september .
.
chenglongwang alvincheung andrastislavbod k. .
synthesizinghighly expressive sql queries from input output examples.
in proceedings of the 38th acmsigplanconferenceonprogramminglanguagedesignandimplementation pldi barcelona spain june .
.
xinyu wang sumit gulwani and rishabh singh.
.
fidex filtering spreadsheetdatausingexamples.in proceedingsofthe2016acmsigplaninternational conference on object oriented programming systems languages and applications oopsla2016 partofsplash2016 amsterdam thenetherlands october november .
.
nicolaas weideman brink van der merwe martin berglund and bruce w. watson.
.
analyzing matching time behavior of backtracking regular expressionmatchers byusing ambiguityof nfa.
in implementationand application ofautomata 21stinternationalconference ciaa2016 seoul southkorea july proceedings.
.
valentinw stholz oswaldoolivo marijnj.h.heule andisildillig.
.
static detection of dos vulnerabilities in programs that use regular expressions.
in tools and algorithms for the construction and analysis of systems 23rd international conference tacas held as part of the european joint conferences on theoryandpracticeofsoftware etaps2017 uppsala sweden april22 proceedings part ii.
.
navidyaghmazadeh christianklinger isil dillig andswaratchaudhuri.
.
synthesizing transformations on hierarchically structured data.
in proceedings of the 37th acm sigplan conference on programming language design and implementation pldi santa barbara ca usa june .
.
xiaodongyuandmichelabecchi.
.
gpuaccelerationofregularexpressionmatchingforlargedatasets exploringtheimplementationspace.in computing frontiers conference cf ischia italy may hubertus franke alexander heinecke krishna v. palem and eli upfal eds.
.
acm .
sai zhang and yuyin sun.
.
automatically synthesizing sql queries from input outputexamples.in 201328thieee acminternationalconferenceonautomated software engineering ase silicon valley ca usa november .
.
zexuanzhong jiaqiguo weiyang jianpeng taoxie jian guanglou tingliu anddongmeizhang.
.
semregex asemantics basedapproachforgenerat ing regular expressions from natural language specifications.
in proceedings of the2018conferenceonempiricalmethodsinnaturallanguageprocessing brussels belgium october november .
.