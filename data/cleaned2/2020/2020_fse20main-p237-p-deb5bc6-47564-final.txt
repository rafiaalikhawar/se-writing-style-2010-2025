past sensitivepointer analysis forsymbolic execution davidtrabish tel aviv university israel davivtra post.tau.ac.iltimotej kapus imperialcollegelondon unitedkingdom t.kapus imperial.ac.uk noamrinetzky tel aviv university israel maon cs.tau.ac.ilcristian cadar imperialcollegelondon unitedkingdom c.cadar imperial.ac.uk abstract weproposeanovelfine grainedintegrationofpointeranalysiswith dynamicanalysis includingdynamicsymbolicexecution.thisis achieved via past sensitive pointer analysis an on demand pointer analysisinstantiatedwithanabstractionofthedynamicstateon whichitisinvoked.
weevaluateourtechniqueinthreeapplicationscenarios chopped symbolicexecution symbolicpointerresolution andwriteintegrity testing.our preliminary results showthat the approachcan have a significantimpactinthesescenarios byeffectivelyimprovingthe precisionofstandardpointeranalysiswithonlyamodestperformance overhead.
ccs concepts softwareanditsengineering softwaretestinganddebugging.
keywords symbolic execution pointer analysis acmreference format davidtrabish timotejkapus noamrinetzky andcristiancadar.
.
past sensitivepointeranalysisforsymbolicexecution.in proceedingsofthe 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november 8 virtual event usa.
acm new york ny usa 12pages.https introduction wepresentanoveltechniqueforincreasingtheprecisionof pointer analysis when used in the context of dynamic analysis and dynamic symbolicexecution .1we show that theincreased 1wenotethatfromtheperspectiveofrunningapointeranalysisinadynamiccontext the dynamic analysis scenario is simply a particular case of the dynamic symbolic executiononeinwhichasinglepathisexploredandnosymbolicdata inparticular permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse november 8 13 virtual event usa associationfor computing machinery.
acm isbn ... .
whichcomeswith a modestperformanceoverhead can benefit three applications chopped symbolic execution symbolic pointer resolution andwriteintegritytesting.
our approach.
existing dynamic analyses which employ static pointer analysis run the pointer analysis first and then utilize its results .weproposeamorefine grainedintegration invoke the pointer analysis on demand whenever the symbolic exploration reaches a certain program point2where the points to information is needed and at that point instantiate the analysis withapath specific abstractionofthecurrentsymbolicstate.specifically our abstraction distinguishes objects already allocated in the past which are assigned a unique allocation site from objects allocatedinthefuture whichcanshareallocationsites toanextent depending on the sensitivity of the pointer analysis.
we call our analysispast sensitivepointeranalysis pspa .
applications.
manydynamicanalysistechniques suchasvarious formsofintegrityenforcement anddifferentextensions of dynamic symbolic execution rely on the results of a pointer analysis.
in our paper we specifically explore chopped symbolicexecution symbolicpointerresolution and write integrity testing .
choppedsymbolicexecution.
dynamicsymbolicexecution dse computes an under approximation of the program s behavior by systematicallyexploring multiple butnotall programpaths.unfortunately scalingsymbolicexecutiontohandlelargeprogramsis challenging due tothe well knownstate explosion problem.
thus attemptshavebeen madeto utilizeinformation gainedbypointer analysisduringthesymbolicexploration .choppedsymbolicexecution isadsevariantthatcanskipcallstofunctions thatusers deemasirrelevant tothecode theywanttoanalyze.to safely do so the analysis relies on the results of a pointer analysis whichprovidesconservativeinformationaboutthe sideeffects of theskippedfunctioncalls i.e.thememorylocationsthatmaybe modified by their code.
if those locations are later read by the analyzedcode a recoveryprocesstakesplace inwhichrelevantparts oftheskippedcodeareexecuted.ofcourse themoreprecisethe results of the pointer analysis the fewer unnecessary recoveries takeplaceandthusthemoreeffectivethetechnique.weshowthat by running the pointer analysis in the symbolic state just before symbolicpointers arepresent.therefore intheremainingofthepaperwemainly discuss ourtechnique in the moregeneral context of symbolicexecution.
2technically weonly invokepointer analysis at procedurecallsites.
197esec fse november8 virtualevent usa david trabish timotej kapus noam rinetzkyandcristian cadar skippedfunctioncalls thenumberofrecoveriescanbesignificantly reduced .
.
symbolic pointer resolution.
symbolic pointers present a particular challengefordse .moderndsesystemstypicallymap each symbolic memory object into a different solver array.
queries involving symbolic memory objects are then easily translated into smt constraints involving the corresponding smt arrays.
since symbolicpointerscanpotentiallyrefertomultiplememoryobjects the dse system first needs to find all the memory objects to which the pointer could refer to so that the right smt arrays can be referenced.inoneofthemostpopularmemorymodels the forking model the dse system scans each memory object in turn issuing solver queries to determine if the pointer can refer to that memory object.
if a pointer analysis determines that the pointercannotrefertoanobject thatobjectcanbeignored saving potentiallyexpensivesolverqueries.inthispaper weshowthatour approachcansignificantlyspeedupsymbolicpointerresolution byeliminatingamuchlargernumberofsolverqueriescompared to astandardstaticpointer analysis .
.
write integrity testing wit .
wit is a well known defense against certain classes of security attacks.
at a high level wit uses a pointer analysis to determine which pointers are allowed to access which objects.
for instance the pointer analysis might determinethatapointer pcanonlyrefertoobjects aandb.dynamic instrumentation is then added to enforce the results of the static analysis e.g.
if pis used to access another object cvia a buffer overflow executionissafelyterminated.ofcourse theprecisionof the pointer analysis has a direct impact on the effectiveness of the analysis.inourexperimentswithwit weshowthatcomputing theanalysisinthedynamiccontextwheretheprogramhasalready finisheditsinitializationcanleadtosignificantimprovementsin precision andthus effectiveness .
.
maincontributions.
ourmain results canbe summarized asfollows we propose past sensitivity a new form of sensitivity in pointer analysis which makes use of the dynamic context underwhichitisinvoked.
wedescribeatechniqueforgeneratingpath specificpointer abstractionsinthecontextofdynamicanalysisandsymbolic execution.
we provide an implementation based on the state of theart symbolic execution engine klee which we make available as open source.
we show the benefits of our technique in three different scenarios chopped symbolic execution symbolic pointer resolution andwriteintegritytesting.
overview ofourapproach wedemonstrateourapproachbyapplyingittothesymbolicexecution ofthe simpleprogram showninfigure .4first the program allocates two hash tables t1andt2 and inserts even elements 4the example demonstratescodepatterns that weencountered in realcode libtasn1 createsatree likedatastructurewherenodesareallocatedinsidealoopand m4utilizes multiple hashtables.
include stdio.h include stdlib.h include string.h define n 6typedef struct elem t unsigned k char v structelem t next elem t 8typedef struct unsigned n elem t array table t 10table t table alloc unsigned n 11table t t malloc sizeof table t 12t array calloc sizeof elem t n 13t n n 14returnt 17elem t table lookup table t t unsigned k 18unsigned int hash k t n 19elem t e t array 20while e if e k k break e e next 24returne 27voidtable insert table t t unsigned k char v 28elem t e table lookup t k 29if !e e malloc sizeof elem t e v malloc e k k inthash k t n e next t array t array e 37strcpy e v v 40voidrun table t t 41while ... wait for key and data table insert t k v 47voidmain 48table t t1 table alloc n 49table t t2 table alloc n 50for unsigned i i n i table t t i ?
t1 t2 table insert t i ... 54unsigned k1 k2 symbolic 55table insert t1 k1 foo 56elem t e table lookup t2 k2 57run t2 figure motivatingexample.
intot1and odd elements into t2 line52 .
at line 55it inserts a new element into table t1with the symbolic key k1.
the insertion function uses table lookup to check if the element already exists in the table which in turn computes the hash of the input key and 198past sensitive pointeranalysis forsymbolicexecution esec fse november8 virtualevent usa a e tt1 t1.array t1.array t2 t2.array t2.array figure abstractionwith static pointeranalysis.
a e e ... t t1 t1.array t1.array a e e ... t t2 t2.array t2.array figure abstractionwith past sensitive pointeranalysis.
iterates over the nodes of the relevant bucket to find the matching element.
assumethatadeveloperisinterestedintestingthepartofthe code operating on table t2.
the developer could try to reduce path explosion e.g.
duetothe whileloopatlines 20 23 byskipping the invocation of function table insert at line55using chopped symbolic execution.
however an attempt to skip the invocation atline55usingtheoriginaltechnique whichreliesonflow and context insensitivepointeranalysis willnotbesuccessful sincethe analysis will report a false dependency between the side effects of table insert atline55andthelocationsreadby table lookup at line56.
the relevant part of the abstraction computed by the whole program pointeranalysisisshowninfigure .notethat acontext and flow sensitivepointeranalysiswillnotsolve our problem sincetheelementsofbothtablesareallocatedinthesame context at line 30oftable insert whichiscalledfrom line .
leveraging the fact that we need the side effects information duringtheexecution inparticularbeforethecallatline and notnecessarilyatitsstart weaimtotakeadvantageofthedynamic information at hand.
in order to run a pointer analysis from a dynamic context we need the ability to compute the abstraction of thecurrentsymbolicstate.akeyobservationisthatwecanbenefit from the ability to distinguish between objects which were already allocated when the analysis is invoked even if they have the same staticallocation site.
the abstraction computed using our pspaapproach at the callsite oftable insert at line55 is shown in figure .
for each of the objects allocated until that point at lines 12and30 we assignauniqueallocationsite intheabstractstate.therefore when functiontable insert iscalledatline weknowfromthedynamicabstractionthat t1pointsto t1 thefield arrayoft1pointstoa1 andthepointersofthatarraypoint index insensitively to e1 e2 ... the elements that were already allocated at line .
usingthisinformation wecancomputepreciseenoughsideeffects forthefunction table insert whichallows us to eliminatethe spuriousdata dependencies.
another challenge arising from our example is the process of symbolicpointerresolution awell knownchallengeindynamic symbolic execution .
note that in our example when at line 55table insert callstable lookup the value of the pointer e at line19is symbolic since it depends on the symbolic hashvalue whichisderivedfrom k1.therefore atline e kdereferences asymbolic pointer.
typically symbolicexecutorscreateonesmtsolverarrayfor each symbolic memory object .
dereferences of symbolic pointersposeachallengetothisapproach aseachsymbolicpointer mayrefertomultipleobjects.asdiscussedintheintroduction one of the most common approaches for handling symbolic pointers is theforking model used by e.g.
klee when a symbolic pointer isencountered theentirememoryisscannedtofindalltheobjects to which the pointer could refer.
then for each possible object the pointer is constrained to refer to that object only making it straightforward to express smt constraints involving that pointer.
determiningwhether thesymbolicpointercan refertoa certain memory objectisexpensive as itinvolves solver queries.
we remark that the blind process of memory scanning can be improved if one has points to information in hand.
if the symbolic pointercannotstatically point to an object which has an allocation siteas thenobjectswhoseallocationsiteis ascanbeignoredin the scanning process thus saving solver queries.
obviously the successofthisapproachdependsdirectlyontheprecisionofthe pointeranalysis.considerthesymbolicpointerdereference e k discussed above.
with static pointer analysis the scanned space will be reduced to the objects whose allocation site is e i.e.
theelementsallocatedbybothtables t1andt2 .withour pspa approach the scanned space will be further reduced to objects whoseallocationsitesisoneof e1 e2 ... thusreducing the number ofscannedobjectsbyafactor of .
so far we discussed the benefits of our dynamic approach in the contextofsymbolicexecution.nowwewillshowthebenefitsof our approach in the context of write integrity testing which we introducedin .considertheexecutionofthe runfunction which waits for akeyand a value ofanarbitrarysize and insertsthem into the table t2usingtable insert .
note that if our value vis longenough thenabufferoverflowwilloccurduringtheexecution oftable insert at line37.
whenwitisenforcedwithstaticpointeranalysis allthestring buffers allocatedatline 31correspond toa singlestatic allocation site and witonlyenforcesthatthe strcpyaccessesone ofthese buffers.
therefore when the strcpyfunction overrides the next objectinmemory whichcouldbeanotherstringbuffer abuffer overflowcanbemissed.withourdynamicapproach wecanperform the pointer analysis just before the invocationof run which 5note that thisprocess canbe optimized to scan only part of the memory space buttools like klee don tusethese optimizationsas theypose some implementation challenges.
other memory models can also work better in some scenarios but present various trade offs.
context based resolution can accelerate future resolutions butisanorthogonalapproach.
199esec fse november8 virtualevent usa david trabish timotej kapus noam rinetzkyandcristian cadar enables us to distinguish between each of the already allocated values andthose that willbe allocatedin thefuture.
in particular wecandistinguishbetweenvaluesallocatedfor t1andt2.since runonly