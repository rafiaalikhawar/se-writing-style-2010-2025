checking conformance of applications against gui policies zhen zhang university of washington seattle usa zgzhen cs.washington.eduyu feng university of california santa barbara santa barbara usa yufeng cs.ucsb.edumichael d. ernst university of washington seattle usa mernst cs.washington.edu sebastian porst google mountain view usa sporst google.comisil dillig university of texas austin austin usa isil cs.utexas.edu abstract a good graphical user interface gui is crucial for an application s usability so vendors and regulatory agencies increasingly place restrictions on how gui elements should appear to and interact with users.
motivated by this concern this paper presents a new technique based on static analysis for checking conformance between android applications and gui policies expressed in a formal specification language.
in particular this paper describes a specification language for formalizing gui policies proposes a new program abstraction called an event driven layout forest and describes a static analysis for constructing this abstraction and checking it against a gui policy.
we have implemented the proposed approach in a tool called venus and we evaluate it on android applications and policies.
our evaluation shows that venus can uncover malicious applications that perform ad fraud and identify violations of gui design guidelines and gdpr laws.
ccs concepts software and its engineering software verification and validation security and privacy human and societal aspects of security and privacy software security engineering .
keywords ad fraud static analysis user interface android mobile app acm reference format zhen zhang yu feng michael d. ernst sebastian porst and isil dillig.
.
checking conformance of applications against gui policies.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
android appstatic analysisvenusui policy figure architecture of venus .ais an event driven layout forest elf defined in section .
and is a gui policy written in vesper language section .
introduction good graphical user interfaces guis are essential for the success and popularity of mobile applications.
a bad user interface can significantly degrade the user s overall experience causing the app to become unpopular even if it provides otherwise useful functionality.
beyond leading to poor user experience bad gui designs can indicate malicious intent for example many ad fraud applications provide a misleading user interface to trick their users into clicking on unwanted links.
such behavior violates one of the advertisement policies published by mobile platforms and according to a recent report click fraud a major type of ad policy violation accounts for more than of all potentially harmful applications.
furthermore several companies and governmental agencies have others types of policies concerning the user interface of mobile apps.
for instance both google and apple publish ui design guidelines and the european union s general data protection regulation gdpr laws impose restrictions on how mobile apps may interact with users via their user interfaces.
despite the increasing importance of ensuring compliance between gui policies and mobile applications there are no existing techniques that can be used to check whether an app conforms to such gui policies.
this work aims to address this problem by proposing a new technique and its implementation in a tool called venus figure for checking conformance between a mobile application written in the android framework and a gui policy.
we envision such a tool being utilized in two different ways first venus can be used by developers to ensure that their user interface is consistent with existing policies thereby improving overall user experience and ensuring compliance with applicable laws.
second venus can be used by security analysts to detect ad fraud applications that trick users through a misleading user interface.
esec fse august athens greece zhen zhang yu feng michael d. ernst sebastian porst and isil dillig in practice checking conformance between an app and a gui policy turns out to be challenging for two key reasons.
first android applications consist of several interacting activities all of which provide a different and dynamically changing interface.
thus checking adherence to a gui policy requires exploring the possibly infinite ways that a user can interact with the app.
second by studying existing gui policies we found that many of them concern not only thestatic appearance of the app but also how the interface needs to dynamically evolve as users interact with it.
thus verifying an app against a gui policy requires reasoning about the dynamic behavior of the app in relation to the gui elements it provides.
in this paper we address these challenges through an end toend solution that statically reasons about an app s gui related behaviors.
our solution consists of three ingredients that make it possible to specify and check such properties policy language we present a formal policy language called vesper for expressing realistic gui design guidelines.
vesper allows specifying both spatial relations between gui elements as well as their behavioral properties such as how a button should react to a click event.
elf abstraction we propose a new program abstraction called event driven layout forest elf that summarizes spatial and behavioral properties of gui elements.
while elfbears resemblance to other android abstractions like window transition graph and iccg it differs from them in that nodes correspond to individual gui elements rather than activities and node labels computed using numeric abstract domains and pointer analysis track gui related properties.
conformance checking to check whether an android app corresponds to a vesper specification venus needs to decide whether a given elfabstraction is a model of the input vesper specification.
venus achieves this task by encoding both the elfabstraction and the vesper policy as logical formulas and reduces conformance checking to a satisfiability query.
to evaluate the effectiveness of our proposed approach we performed an extensive experimental evaluation on android applications.
specifically we formalized existing gui policies as vesper specifications and then used venus to check each android application against these policies.
our evaluation shows that venus is able to accurately pinpoint violations of gui policies with a low false positive rate around .
.
furthermore venus can identify previously unknown ad fraud instances and detect violations of a subset of gdpr general data protection regulation regulations.
in short this paper makes the following key contributions we propose a policy language called vesper for describing gui policies section .
we introduce a new program abstraction called event driven layout forest that is suitable for checking such gui policies and present a static analysis technique for automatically constructing the proposed elfabstraction section we implement venus the first tool for statically checking conformance between android applications and gui specifications and we extensively evaluate venus by checking conformance between android applications and several existing gui policies section .
click continue a b coordinatorlayout buttonimageviewtextviewappbarlayoutconstraintlayouttoolbar c a b coordinatorlayout buttonimageviewtextviewappbarlayoutconstraintlayouttoolbar c clickfigure example demonstrating a typical event driven flow in android apps.
listing defines the layout shown in a and b .
the transition from b to c is defined in listing .
constraintlayout ... textview android id id demo title android text default title ... imageview app layout constrainttop tobottomof id demo title ... button android id id continue button android text continue ... constraintlayout listing activity layout for the app shown in figure b .
1class mainactivity extends activity void oncreate ... ... setcontentview r. layout .
activity main textview demotitle findviewbyid r.id.
demo title demotitle .
settext venus demo button continuebutton findviewbyid r.id.
continue button continuebutton .
setonclicklistener new view .
onclicklistener void onclick view v alertdialog d new d. builder ... .
create ... d. setbutton dialoginterface .
button positive yes new dialoginterface .
onclicklistener void onclick ... d. dismiss d. show ... listing oncreate source code for activity from figure b .
background on android gui in android the basis of an app s user interface is an activity which always has a window associated with it.
activities can start other activities by a message passing system known as intercomponent communication icc .
an android icc message is an intent which can be thought of as a description of what the launched component should do.
an intent object specifies both the action to perform e.g.
view edit etc.
and provides the relevant data.
the android framework provides two types of basic gui elements namely view s and viewgroup s. aview element is a widget such as a button or progress bar that the user can see and interact with.
a viewgroup is an invisible container that stitches 96checking conformance of applications against gui policies esec fse august athens greece together view s and viewgroup s. android provides different types ofviewgroup s such a linearlayout for arranging gui elements horizontally or vertically.
the user interface of a gui activity corresponds to a tree data structure figure a where internal nodes are viewgroup elements and all leaves are view objects.
each android gui element also has a set of attributes that define its properties including height width alignment position etc.
declaring and manipulating gui elements.
in android there are two ways to declare gui elements.
the first option is to specify the layout through an xml file.
in addition to defining the hierarchical user interface of an activity the xml file can also specify the attribute values of each gui element such as the text attribute continue of a button on line of listing .
during compilation the xml file is translated into a so called layout resource that can be loaded in the application s source code by calling setcontentview r.layout.layout name e.g.
line of listing .
an alternative way to create a layout is to do so programmatically by calling methods provided by the android framework.
for instance rather than statically declaring the text attribute in the xml file a program can do this at run time by calling the settext method.
in practice programmers often combine xml based declaration of gui elements with programmatic modifications at run time.
for example line of listing loads the layout declared in the xml file but the two subsequent lines modify the title of the nested textview element to venus demo from its original name default title declared in line of listing .
hence understanding an application s user interface requires analysis of both xml files and source code.
interacting with gui elements.
to facilitate interaction with users gui elements register callbacks that get invoked upon specific types of user events e.g.
click hover etc.
.
in particular android gui elements can respond to events of type xby registering an onxlistener object whose onxmethod gets executed when event xoccurs.
for instance lines in listing cause the widget to pop up a dialog box when the user clicks continue .
this behavior is illustrated in the transition from figure b to figure c .
overview this section gives an overview of the venus framework through a simple but realistic motivating example.
.
example gui policy for adfraud detection fig.
shows the screenshot of an ad fraud application called super cleaner that was recently submitted to the google play store.
this app does not conform to a google admob policy which states that transparent backgrounds should not display ads upon a click event.
however as shown in parts b and c of figure the super cleaner application blatantly violates this policy.
in order to use venus to check conformance between this app and the admob policies the user first needs to formalize the policy invenus s specification language.
in particular figure shows a formalization for the policy transparent backgrounds should not display ads upon click events in our policy language called vesper .
here the first line declares a view element called bg.
next the assume statement stipulates that bgis the background of some other view element.
then on line the letbinding defines a custom predicate called popad v which evaluates to true if clicking on v clickable transparent background launchesbrowser clickableicon launchesrelevant activity a main activity b battery saver activity c untrusted website figure clicking on the white space will surprisingly trigger the display of untrusted website 1public class mainactivity extends activity implements onclicklistener private button saverbtn protected void oncreate ... setcontentview r. layout .
activity main saverbtn findviewbyid r.id.
btn save saverbtn .
setonclicklistener this public void onclick view view intent intent new intent this batterysaver .
class startactivity intent listing main activity 1public class batterysaver extends activity public void oncreate bundle bundle setcontentview r. layout .
battery saver ad framelayout framelayout framelayout findviewbyid r.id.
content view a new nativeadviewbuild .f framelayout .
addview a 10class nativeadviewbuild public view f view adview new unifiednativeadview view bgview findviewbyid r.id.
bg view set a transparent background bgview .
setopacity bgview .
setonclicklistener this return adview public void onclick view arg0 suspicious url loadurl http funtest .
afatwallet .
com listing battery saver activity shows a new window v that corresponds to an adview gui element.
finally the assertion specifies the desired property.
section will present more about vesper .
given this vesper policy and the source code of the super cleaner application shown in listing and listing we next explain how venus automatically identifies this policy violation.
97esec fse august athens greece zhen zhang yu feng michael d. ernst sebastian porst and isil dillig .viewbg .assume v. view v background bg v .letpopad v v .
showwindow v click v adview v .assert transparent bg popad bg figure vesper specification for the policy transparent backgrounds should not be clickable .
.
elfgeneration via static analysis as mentioned earlier venus uses static analysis to construct an even driven layout forest elf abstraction of the application.
at a high level this abstraction captures all relevant behavior of the app with respect to the vesper policy language.
for example figure shows the elfabstraction for the super cleaner application.
here each node corresponds to a gui element node labels e.g.
for bgview indicate attribute values e.g.
opacity width and there are two types of edges a spatial solid edge from node nton indicates that gui element n is nested inside n and a behavioral dashed edge from nton labeled with eindicates that gui element nlaunches another gui element n upon event e. for example in figure there is a spatial solid edge from mainactwindow tosaverbtn since the latter is spatially nested within the window of the main activity see figure .
on the other hand there is a behavioral dashed edge from saverbtn to batterysaverwindow labeled with showwindow click because clicking on the saverbtn results in opening the window of the batterysaver activity see code .
in practice constructing a sufficiently precise elfabstraction of the application requires non trivial static analysis.
for example the construction of behavioral edges between gui elements requires reasoning about heap objects and callbacks as well as analysis of inter component communication icc .
on the other hand reasoning about gui element attributes e.g.
height width requires reasoning about numeric values.
.
checking conformance our method uses the computed elfabstraction to check conformance against any vesper policy.
at a high level we can think of theelfabstraction as defining a conjunction of ground predicates invesper .
thus checking conformance between the app and policy boils down to determining whether the formula defined by the elf abstraction implies the specification.
going back to our example we can determine that super cleaner violates the vesper policy from figure using the following chain of inferences first since bgview is nested inside nativeadview and has the same width height of its parent figure we determine that bgview is the background of nativeadview .
thus bgview satisfies the assumption from line of figure .
next because the opacity attribute of bgview is0 see figure transparent evaluates to true for bgview .
in addition bgview satisfies the popad predicate because figure contains a behavioral edge from bgview toadviewwindow labeled with click .
finally because bgview satisfies both the assumption at line as well as the transparent andpopad predicates the assertion at line of figure is violated.
therefore venus reports that the super cleaner app does not conform to the vesper policy from figure .
4vesper specifications as shown in figure a specification in vesper starts with a set of declarations is followed by a sequence of statements i.e.
definitions and assumptions and ends in a set of assertions.
while vesper provides built in predicates relevant to the spatial and behavioral properties of gui elements figure the user can also definecustom predicates through let bindings.
for instance in figure showwindow is an example of a built in predicate whereas popad is a custom predicate defined by the user.
vesper also provides a way to define a setof gui elements through the set comprehension syntax v .
expressions.
invesper the most basic expressions are variables v integer constants c and pre defined android events such as click ortouch .vesper allows performing arithmetic operations over integers as well as aggregation over sets.
for instance the expression count v returns the number of elements in set v. built in predicates.
vesper provides a core set of built in predicates that constrain spatial and behavioral properties of gui elements.
figure shows examples of these predicates which are classified into three categories element type predicates describe the type of a gui element e.g.
button dialog .
note that unlike the actual android api vesper does not differentiate between views and view groups and every gui element is considered to be a view.
thus views can contain nested views under vesper s semantics.
spatial predicates refer to visual properties of gui elements e.g.
height width as well as spatial relationships between different gui elements e.g.
containment .
behavioral predicates constrain how gui elements react to user events e.g.
what methods they can invoke which other gui elements they can display etc.
.
example .
consider the following vesper specification vieww let lview v x y. width v x x height v y y let lads v adview v contains w v lview v assert count lads this specification requires that every window contains at most one large ad meaning that the width and height of the ad is above a certain threshold.
here the combination of set comprehension syntax and the count function allows constraining the number of gui elements with a certain property.
we present the formal semantics of vesper policies in appendix a. at a high level the semantics of vesper policies are defined over execution traces and we consider a predicate p o to be true in an execution if it holds on objects oat any time during .
for example the predicate startbrowser e v evaluates to true in execution ifvstarts the browser at some point during .
given 98checking conformance of applications against gui policies esec fse august athens greece adviewwindow uri funtest.afatwallet.com batterysaverwindowframelayout nativeadview width height 400bgview gravity center width height opacity 0mainactwindow...saverbtnclick...click figure simplified elffor motivating example of sec.
.
.
solid resp.
dashed lines represent spatial resp.
behavioral edges.
policy d s a decld v d d stmts letv v letp v assume s s asserta assert a a expre v c f e1 ... e n pred p e 1 2 1 2 1 2 v. v. event click longclick ... touch type view dialog ... button a attributes c intf built in fns p built in predicates user defined predicates figure the vesper policy language element type predicates button v dialog v imageview v adview v .
.
.
spatial predicates height v h viewvhas heighth width v w viewvhas widthw textsize v s text viewvhas text size s transparent v viewvis transparent contains u v ucontainsvas a sub view background u v uis the background container of v behavioral predicates entryview v vis the top level window that is displayed when the app starts invoke u e m user eventeon gui element u directly causes invocation of method m showwindow u e v eventeonuresults immediately in display of element v launchdialog w e v windoww s eventecauses new dialog v to be immediately displayed startmarketplace e v eventeonvresults immediately in starting a new marketplace window startbrowser e v eventeonvresults immediately in starting a new browser window figure examples of built in predicates provided by vesper the truth value of built in predicates under evaluation of the full policy under largely follows the standard semantics of first order logic with some modifications to handle set comprehension see appendix a .
finally we say that an app aconforms to a vesper policypifpevaluates to true in all executions of a. static conformance checking in this section we introduce the elfabstraction describe our static analysis for computing it and then discuss how to use the elf abstraction to check conformance against vesper policies.
.
the elfabstraction an event driven layout forest elf is a tupleg n n e l where nis a set of nodes where each node is a pair o representing an abstract heap object oof gui element type .
nodesn0 nareinitial nodes that may correspond to the main window of the application.
edgese es ebencode relationships between gui elements.
we refer to edges n n esasspatial edges and n n eb asbehavioral edges .
labeling function l n attrib abstractval maps attributes of gui elements to their abstract values.
as mentioned in section a spatial edge n n encodes that gui elementnis nested within n whereas a behavioral edge n n indicates that user system event on gui element ndirectly results in the display of element of n .
the labeling function lcan refer to both spatial and behavioral properties of gui elements.
for example theheight attribute refers to a spatial property of the node whereas click is a behavioral property that identifies which methods may be invoked upon a click event.
in general since venus cannot exactly determine the values of node attributes using static analysis the labeling function lmaps these attributes to abstract rather than concrete values however the choice of abstract domain depends on the type of the attribute see section .
.
xml analysis for layout schema as mentioned in section gui elements in android are typically declared via an xml file and then loaded by the application code at run time.
thus to facilitate static analysis venus encodes the guirelated information declared in the xml file as a so called layout schema .
as shown in figure a layout schema maps each layout name to its structure represented as a multi map from attributes to their type tand default value c. given a layout name nand its definition n we write defaultval n to indicate an object with fields a1 ... anwhere each fieldaiinitialized to ci.
example .
consider the following layout xml linearlayout id lin orientation vertical textview id txt1 width height 99esec fse august athens greece zhen zhang yu feng michael d. ernst sebastian porst and isil dillig schema layoutname layout attrib t c typet int string float builtin layoutname constantc int string float defaultval layoutname defaultval builtin builtin button textview ... attrib orientation subview ... figure layout schema definition text hello i am a textview linearlayout we represent this as the following layout schema lin orientation string vertical subview textview defaultval txt1 txt1 width int height int .
static analysis in this section we describe our static analysis for computing the elfabstraction using datalog style inference rules.
note that the event driven layout forest is a global abstraction of the entire application however our static analysis for computing is both flowand context sensitive.
our analysis leverages the layout schema extracted from the xml file section.
.
as well as the results of standard techniques like pointer analysis.
we formalize our static analysis using three different types of predicates summarized in table source code predicates refer to statements in the source code.
for instance addview l m v v2 indicates that there is an api call of the form v1.addview v2 at locationlof methodm.
pre analysis predicates refer to program facts computed by off the shelf static analyzers.
for example pointsto c l v o indicates that variable vpoints to heap object oat program location lin calling context c. similarly aval c l v a indicates that variablevhas abstract value aat locationlin calling context c. output predicates collectively define our elfabstraction.
for example the predicate sattrib o a val indicates that the abstract value for spatial attribute aofoisval and bedge o o indicates that there is a behavior edge between oando labeled .
as mentioned earlier we present our static analysis see figure using datalog style rules of the form h x1 ... xn b1 ... ... bk ... .
the meaning of such a rule is that the predicate h x1 ... xn is true if all the of the predicates b1 ... bkin the rule body are satisfied.
we refer to has the head predicate and thebi s as body predicates .
in our case the head predicates are either auxiliary or output predicates computed by our analysis whereas body predicates alsoinvolve source code and pre analysis predicates.
if an argument to a predicate does not matter we use the symbol to indicate that it matches anything.
we now explain the rules from figure in more detail.
nodes.
according to the first rule in figure any abstract heap object that corresponds to a gui element i.e.
is subtype of view is a node in the event driven layout forest abstraction.table predicates used or computed by our analysis source code predicates loadview l m v n load layoutntovat locationlof methodm addview l m v v2 v2is added as sub view of v1atlin methodm setcontentview l m v v2 addv2as content view of v1atlin methodm setattrib l m v a v attributeaofvis set tov atlin methodm setxlistener l m v m methodm is set asv sxlistener showwindow l m v locationlhas a call to display window v icc l m intent perform icc using intent atlof methodm mainact a ais the app s main activity pre analysis predicates inctx m c cis a calling context of method m aval c l v a vhas abstract value aat locationlin contextc pointsto c l v o vpoints to object oat locationlin contextc pointsto c l o f o theffield ofopoints too atlin contextc call c m m mdirectly or transitively calls m in contextc hastype o heap objectohas type ... ... output predicates node o ois a gui element node of type inelf sattrib o as val nodeohas spatial attribute aswith value val battrib o ab val nodeohas behavioral attribute abwith val entryview v vis a window shown on app startup sedge o o viewocontains view o bedge o o viewoleads to view o under event rootview o1 o2 o1has root view o2 root view.
the second rule computes a predicate rootview o o indicating that activity osets its main window to be gui element o .
since root views are set via an api call v.setcontentview v this rule looks up the heap objects pointed to by variables v v at the program location l in method m where the api call occurs.
note that our analysis is context sensitive in that we look up the points to sets of v v in feasible calling contexts of m. entry view.
the next rule marks the initial nodes of the elfabstraction.
to determine the initial nodes we first identify all heap objectsothat are of instance of type a whereais the main activity of the application.
we then mark all root views of oas initial nodes using the auxiliary rootview predicate from rule .
behavioral attributes.
the next rule describes how we compute behavioral attributes of each node.
in particular behavioral attributes map each gui event to a set of methods that can be used to handle that event.
since event handlers are registered via setlistener methods this rule uses the setxlistener l m v m source code predicate which indicates that method m is registered as the listener for event xfor variable v andl mcorrespond to the program location and method where the registration occurs respectively.
if vpoints to a heap object othat is a node in the elf abstraction behavioral attribute xis mapped to method m .
note that in general there may be multiple methods m1 ... mkthat are used to handle event x. in this case our analysis computes multiple facts of the form battrib o x m ... battrib o x m meaning that behavioral attribute xis mapped to the set m1 ... mk .
spatial attributes.
the next three rules describe the computation of spatial attributes.
unlike behavioral attributes that have a finite domain i.e.
a set of methods spatial attributes like height have an infinite domain i.e.
all integers .
thus our method uses abstract interpretation to reason about such attributes.
in particular rule initializes all spatial attributes to as standard.
the next two rules essentially describe a fixed point computation where we take the join of existing values with a new value.
100checking conformance of applications against gui policies esec fse august athens greece table gui policies that we formalized as vesper specifications.
category total description examplead relatedfraudulent 8violation of policy often indicates ad fraud e.g.
the size ratio between the ad and the screen is required to be greater than a minimum threshold .
unwanted 3violation of policy considered annoying aggressive e.g.
activities that display full screen ads should call the preload function of the ad when they are created.
non adappearance guidelines about the appearance spacing of gui elements e.g.
the smallest recommended font size is 10sp gdpr consent 2gdpr laws about acquiring user consent e.g.
applications that display personalized ads should get user consent when they are started node o pointsto v o hastype o view.
rootview o o setcontentview l m v v inctx m c pointsto c l v o pointsto c l v o .
entryview o mainact a instanceof o a rootview o o .
battrib o x m node o setxlistener l v m inctx m c pointsto c l v o .
sattrib o a node o view a attribs .
sattrib o a val loadview l m v n inctx m c pointsto c l v o .a dom n a subview n a t val0 sattrib o a val val val val0 sattrib o a val setattrib l m v a v inctx m c pointsto c l v o aval c l v val sattrib o a val val val val .
sedge o o loadview l m v n inctx m c pointsto c l v o o n subview .
sedge o1 o2 addview l m v v2 inctx m c pointsto c l v o1 pointsto c l v o2 .
bedge o1 x o battrib o1 x m inctx m c call c m m inctx m c showwindow l m v pointsto c l v o .
bedge o1 x o battrib o1 x m inctx m c call c m m inctx m c icc l m i pointsto c l i o pointsto c l o tgt o rootview o o2 .
figure datalog style inference rules describing elfconstruction.
here is an abstraction function for the underlying abstract domain and is the corresponding join operator.
refers to the layout schema from section .
.
specifically in rule we deal with api calls that load a view from the xml file.
in particular suppose that we have determined that attributeaof layout name ncan have default value caccording to the analysis from section .
.
now if we encounter an api call that loads layout ninto variable v we first look up the points to target oofvand addcto the set of possible values of o.aby taking the join with the old abstract value with c. next rule deals with spatial attributes that are set programmatically via an api call.
we represent such api calls using thesource code predicate setattrib l m v a v indicating that attribute aof variable vis set to variable v at program location linside methodm.
to update the elfabstraction we first look up the abstract value aof variablev at program location lin some calling contextcof methodm.
ifvpoints to heap object oat the same program location land calling context c we then update o.ato be the join of aando.a s old abstract value.
our implementation uses the interval abstract domain for numeric attributes and the so called bounded set abstraction for strings.
spatial edges.
the next two rules and describe the introduction of spatial edges due to loading views from the xml file and programmatically adding sub views respectively.
since these rules are very similar we only focus on .
consider an api call for adding view v2as a sub view of v1at program point lin methodm.
ifv v point to heap objects o o at program location lin the same calling context cof methodm we introduce a spatial edge from otoo in the elfabstraction.
in general v v can have multiple points to targets thus this rule can end up introducing multiple spatial edges for the same source code statement.
behavioral edges.
the last two rules and deal with the introduction of behavioral edges.
recall that a behavioral edge indicates that gui element olaunches gui element o upon event x. in general ocan launcho in one of two ways the handler of eventx transitively calls a method that a either directly displays o by calling an api e.g.
showwindow or b indirectly displays o by performing inter component communication via an intent object whose target has root view o .
in figure rule deals with case a and rule deals with case b .
since both of these rules rely on knowing the handler method for event x the body of the rule matches the battrib predicate computed by the other rules.
.
checking conformance once venus generates the elfabstraction it translates attributes and edges in the elfabstraction to ground built in predicates in the vesper specification language in the expected way.
for instance the spatial edge o o in the elfcorresponds to the predicate contains o o in the vesper dsl.
similarly a behavioral edge o o corresponds to the vesper predicate showwindow o o ifo is another window and for instance to startbrowser o ifo is the browser.
thus venus can directly convert the elfabstraction to a formulafthat is a conjunction of ground predicates.
next to decide whether the input program pentails specification venus checks whetherfimplies .
to do so venus first 101esec fse august athens greece zhen zhang yu feng michael d. ernst sebastian porst and isil dillig converts to a logical formula using the j kfunction defined in appendix a and then checks the satisfiability of the formula f using a datalog solver.if this formula is satisfiable the specification is violated under the computed elfabstraction and venus produces a model of f as a potential counterexample.
on the other hand the unsatisfiability of f constitutes a proof of conformance since fover approximates the app s relevant behavior with respect to the vesper specification language.
implementation and evaluation we implemented our core static analysis on top of the soot framework and the ic3 tool for android .
we use the spark framework provided by soot to perform pointer analysis and construct a call graph.
our implementation uses the interval abstract domain for reasoning about numeric attributes and the boundedset abstraction for strings.
venus also leverages the souffl datalog solver for checking conformance between the elf abstraction and the vesper specification.
as described in section our analysis is context sensitive and uses the call site representation proposed in .
venus is openly available on github.
experimental set up.
all of our experiments are conducted on a shared core server with intel xeon e7 cpu and 500g memory running the centos .
operating system.
.
benchmarks to evaluate venus we collected android applications from three different sources google play we collected popular applications that were available on the google play store in jan .
gpp benchmarks the google play protect gpp team provided us with a labeled data set consisting of android apps and their label benign or type of malware .
all of these applications were flagged as potential malware by google s internal tools and manually audited by google security analysts.
adfraudbench we also evaluate our approach on a dataset taken for detecting ad fraud .
this dataset includes ad fraud samples and benign applications.
.
properties to evaluate venus we collected a total of representative gui policies from google play ads policy admob help material design and eu general data protection regulation .
among those policies are too vague to formalize e.g.
ensure that none of the ad attributes look like navigation features within the app.
.
among the remaining seven of them cannot be expressed in vesper e.g.
require temporal logic .
this leaves us with a total of policies that we formalized in vesper .
to give the reader some intuition table shows a categorization of these policies and provides some examples of the types of policies we formalized.
see the appendix for their vesper formalizations.
.
results on google play dataset we evaluated venus on the google play apps by checking conformance against all policies summarized in table .
as shown 1details are hidden for double blind review purpose.
the experimental artifact including the tool will be submitted after acceptance.
figure results on the gpp dataset in the first row of table venus reports a total of violations across apps with an average running time of .
seconds per app.
among the reports reports pertain to violations of ad related policies reports concern gdpr regulations and the remaining reports pertain to material design guidelines.
manual inspection.
since there is no ground truth label for the apps in the google play dataset we manually inspected of the apps for which venus reports at least one violation.
for these apps venus reports a total of warnings.
we now report on the findings from our manual inspection.
gdpr violations among the apps we inspected venus reports a total of gdpr violations and we manually confirmed that of them indeed access private user information without ever displaying a user consent form.
ad fraud across the manually inspected apps venus reports of them to violate an ad related property.
in particular of these are true positives and are previously unknown ad fraud instances confirmed by google security auditors .
design guidelines venus reports of the apps to violate a material design guideline related property and of these indeed violate the design guidelines we encoded.
false positive analysis.
among all sampled apps venus reported violations of which are true positives.
based on our manual inspection most of the false positives are due to imprecision in the pointer analysis.
using the estimation of proportion method we conclude that it is likely that the false positive rate for the whole dataset is between and .
result among the apps we manually inspected venus identified previously unknown ad fraud instances confirmed and google play apps that violate gdpr regulations.
furthermore venus s false positive rate for the inspected apps is around .
.
results on gpp dataset the gpp dataset consists of apps where each app is either labeled as benign or malicious.
if the app is malicious the label also indicates the type of malware e.g.
ad fraud spyware .
for this dataset we used venus to detect ad fraud instances by checking 102checking conformance of applications against gui policies esec fse august athens greece table summary of venus results across all three datasets apps violating apps violations recall precision avg.
time s google play n a .
.
gpp .
.
.
adfraudbench .
.
.
all n a .
.
conformance between each app and the eight ad fraud related policies that we formalized in vesper .
as summarized in the second row of table the recall of venus on this dataset is .
and the precision is .
.
the average running time is .
seconds.
comparison against virustotal.
to put these results in context we compare venus s results with those of virustotal which is a widely used service for detecting several types of malware.
virustotal uses more than sixty state of the art malware detection engines to analyze an app and shows the aggregate results.
since virustotal does not report a single result and covers a broader class of malware than just ad fraud there is no obviously right way to compare against it for the purposes of our evaluation.
thus we consider two different but equally plausible ways of interpreting virustotal results virustotal a as in prior work on ad fraud detection we consider virustotal to classify an app as ad fraud if at least two of its underlying malware detection engines label it as ad fraud.
virustotal b since the security community typically uses virustotal as a binary classifier we consider an app to be ad fraud if at least two of the underlying malware detectors label the app asnotbenign.
the results of our comparison are shown in figure .
here blue bars with pattern show recall whereas dark magenta bars with pattern indicate precision.
as we can see from this bar chart both variants of virustotal yield much lower recall and precision compared to venus .
analysis of false positives and negatives.
we manually inspected the apps that are incorrectly classified by venus to better understand the root causes of false positives and false negatives.
most of the false positives are caused by imprecision in the pointer analysis e.g.
additional spurious methods are identified as event handlers .
on the other hand false negatives are mainly caused by foreign binary code that our static analyzer cannot reason about.
for instance the casino classic app from the gpp dataset employs the unity framework that contains code in the common intermediate language cil binary format.
since our tool cannot analyze cil binary it fails to understand some ad related functionality and this leads to false negatives.
result on apps flagged as potentially malicious by google s internal tools and manually labeled by security analysts venus has a precision of .
and recall of .
.
furthermore venus outperforms virustotal by a factor of .
in terms of precision and by a factor of .
in terms of recall.
2recall that all applications in these datasets are either benign or ad fraud.table results on adfraudbench venus frauddroid virustotal a virustotal b precision .
.
.
.
recall .
.
.
.
.
results on adfraudbench dataset in our next experiment we evaluate venus on the adfraudbench dataset used in prior work .
since this data set is specifically targeted for ad fraud detection we check these apps against the eight ad fraud related policies formalized in vesper .
as shown in table venus has a precision of .
and recall .
on this dataset and its average running time per app is .
seconds.
to put these results in context we also compare venus s results against those of virustotal as well as frauddroid which is a dynamic analysis tool specifically for detecting ad fraud .3the results of this comparison are shown in table which shows that venus outperforms virustotal and frauddroid both in terms of precision and recall.
result venus outperforms frauddroid a dynamic analysis tool for ad fraud detection significantly in terms of recall while also attaining better precision.
.
evaluation of the elfabstraction in our final experiment we evaluate the benefits of our proposed elfabstraction by performing ablation studies and comparing it against the windown transition graph wtg abstraction proposed in prior work .
wtg abstraction.
as mentioned earlier the wtg abstraction from the gator tool is somewhat similar to elfin that it is a graph abstraction of android applications where nodes are windows and edges annotated with events represent communication between them.
however wtg differs from our proposed elfabstraction in two important ways first nodes in a wtg correspond to main windows of activities so it does not contain nodes for any nested gui elements.
second a wtg does not contain any information about spatial attributes of windows.
to use the wtg abstraction to check vesper specifications we use the following 3frauddroid is not available so we cannot evaluate it on gpp apps.
4dong et al.
report recall on apps from the adfraudbench instead of the apps dataset.
after we manually inspected the ground truth for those apps we noticed that frauddroid actually mislabeled malicious apps as benign.
to resolve this discrepancy we further confirmed our results by uploading those apps to virustotal which also marked those apps as malware.
we further contacted the co authors of frauddroid and they also agreed that those apps should all be ad fraud.
that is why the actual recall is around .
103esec fse august athens greece zhen zhang yu feng michael d. ernst sebastian porst and isil dillig table evaluation of our abstraction.
prec.
is precision toolgpp adfraudbench prec.
recall f prec.
recall f gator .
.
.
.
.
.
venus s53.
.
.
.
.
.
venus b69.
.
.
.
.
.
venus .
.
.
.
.
.
methodology first since wtg only contains main windows of activities we consider any gui element mentioned in the vesper specification but not in the wtg as being non existent in the app.
clearly this may result in gator reporting false negatives.
second since a wtg does not contain any information about spatial attributes we consider the abstract value of any spatial attribute to be which can result in false positives.
thus in principle using gator to check for vesper specifications can suffer from both false positives as well as false negatives.
ablations of elf.in this evaluation we also compare our proposed elfabstraction against two of its own ablations.
since one of our claims is that many gui policies require reasoning about both spatial andbehavioral properties in practice we consider the following two ablations of elf venus s this is a variant of venus that does not contain spatial attributes.
in other words we do not perform abstract interpretation to reason about values of spatial attributes such as height size etc.
and simply map all of them to .
venus b this is a variant of venus that does not contain any behavioral edges or attributes.
in particular we do not reason about event handlers of gui elements i.e.
behavioral attributes and we also do not reason about communication between different gui elements i.e.
behavioral edges .
at first glance it might seem that venus sshould have only false positives whereas venus bwould suffer from only false negatives.
however since vesper predicates may appear negated in the specification in principle venus sandvenus bcan have both false negatives and false positives.
table presents the results of our evaluation of the elfabstraction by comparing it against wtg venus s and venus bon both the gpp and adfraudbench datasets for which we know the ground truth.
our first observation is that gator has high precision but very poor recall.
while the poor recall is perhaps expected the high precision is surprising since we treat spacial attributes as when using the wtg abstraction to check vesper policies.
however the reason for this is that gator reports a grand total of violations among the actual violations in the gpp dataset and all of these three reports turn out to be real violations.
however the recall is extremely poor resulting in f1 scores of .024and0.
on the gpp and adfraudbench datasets compared to that of .
and0.937ofvenus .
next we compare venus against its two ablations.
while the recall of both ablations are significantly higher than the wtg abstraction the overall f1 scores of substantially worse than venus .
5alternatively we could consider a node to represent all views nested within it however this requires significant additional analysis that gator does not perform.these results indicate that our proposed elfabstraction is highly beneficial for checking apps against gui policies.
result our proposed elfabstraction significantly outperforms the wtg abstraction in terms of recall and it also outperforms its own ablations in terms of f1 score.
related work .
program analysis for user interfaces gui analysis for mobile apps.
in the space of gui analysis tools of mobile apps the most related one is gator which statically analyzes android applications to build models of their gui related behavior.
these models include so called constraint graphs and more related to this work window transition graphs .
however as shown in section .
the models produced by gator do not provide sufficient information to check an app against vesperspecifications.
another static analyzer that is related to this work is the backstage tool for identifying which sensitive api functions can be invoked through which ui elements.
backstage checks for specific unintended behaviors of gui elements such as leaking a user s location when she clicks the upload picture button.
in contrast to backstage venus supports a general class of policies expressed in the vesper policy language and also reasons about spatial properties of gui elements as well as communication patterns between them.
there are also some gui related analysis tools based on dynamic techniques.
for instance cornidroid tests an application against a set of ui constraints given by the user.
as another example gvt dynamically checks whether the user interface of a mobile app is implemented according to its design mock up by monitoring its visual appearance.
similarly remaui can automatically identify certain types of ui elements e.g.
images and text using optical character recognition ocr and computer vision techniques.
compared to these dynamic techniques static techniques like venus provide complementary advantages such as higher coverage for behaviors that are hard to trigger at run time.
gui analysis for web applications.
beyond mobile applications gui analysis has also attracted some interest in the context of web applications.
for example cilla finds unused css selectors by dynamically monitoring the relationship between css rules and webpage elements selected by those rules.
another related work in this space is the cassius framework for building semanticsaware css tools.
specifically cassius formalizes the semantics of css in first order logic and can be used to check spatial properties of gui elements displayed on a webpage.
however since the user interface of web applications is rendered exclusively based on declarative html and css code cassius does not need to analyze javascript programs.
in contrast checking an android application against a vesper specification requires both precise reasoning about java code as well as the declarative layout definitions provided in xml files.
besides cassius there are other tools specifically built for addressing accessibility problems in web pages .
compared to these tools that are typically based on dynamic testing venus has the potential to cover code that is hard to reach by dynamic 104checking conformance of applications against gui policies esec fse august athens greece analysis.
furthermore accessibility tools can only check spatial properties of gui elements while venus reasons about both spatial and behavioral properties.
.
static analysis of android applications due to the popularity and security critical nature of android applications there is a rich literature of program analysis techniques for the android framework .
a key challenge in statically analyzing android applications is reasoning about dependencies between different components such as activities and services.
thus several papers focus on inter component communication icc analysis for android .
in this work we leverage the icc analysis techniques proposed in prior research.
among techniques for analyzing android applications a particularly relevant work is the apposcopy system for malware detection .
similar to venus apposcopy provides a specification language for describing semantic behaviors of android apps and allows statically checking an app against such a specification.
however the specification language of apposcopy is tailored for spyware detection and does not allow referring to gui elements.
thus beyond icc analysis the underlying static analyses performed by apposcopy and venus are quite different.
.
android malware detection since one of the use cases for venus is to detect ad fraud venus is also related to a long line of work on android malware detection .
most malware detection tools in this space focus on information leakage rather than gui related behavior and are therefore not suitable for accurately detecting ad fraud applications.
as mentioned earlier the most relevant work in this space is the frauddroid tool for detecting malware in the ad fraud category.
however unlike venus frauddroid is based on dynamic analysis and as demonstrated in section .
it has significantly worse recall compared to venus .
conclusion we introduced a new framework called venus for checking conformance between android apps and gui policies expressed in a policy language called vesper .
we manually studied gui policies from multiple different sources and among english policies that are precise enough to be formalized we showed that around are expressible in the vesper policy language.
we used venus to check conformance between these policies and over android applications and showed that venus can uncover previously unknown ad fraud instances as well as violations of gdpr regulations.
our comparison against virustotal and frauddroid indicates that venus advances the state of the art in ad fraud detection in terms of both precision and recall.
finally our comparison against gator as well as the two ablation studies highlight the benefits of our proposed elfabstraction.