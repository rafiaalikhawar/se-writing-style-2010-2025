a differential testing approach for evaluating abstract syntax tree mapping algorithms yuanrui fan y xin xiazx david lo ahmed e. hassank yuan wang shanping li zhejiang university china ypengcheng laboratory china zmonash university australia singapore management university singapore kqueen s university canada huawei sweden research center fyrfan shang zju.edu.cn xin.xia monash.edu davidlo smu.edu.sg ahmed cs.queensu.ca yuan.wang1 huawei.com abstract abstract syntax tree ast mapping algorithms are widely used to analyze changes in source code.
despite the foundational role of ast mapping algorithms little effort has been made to evaluate the accuracy of ast mapping algorithms i.e.
the extent to which an algorithm captures the evolution of code.
we observe that a program element often has only one best mapped program element.
based on this observation we propose a hierarchical approach to automatically compare the similarity of mapped statements and tokens by different algorithms.
by performing the comparison we determine if each of the compared algorithms generates inaccurate mappings for a statement or its tokens.
we invite external experts to determine if three commonly used ast mapping algorithms generate accurate mappings for a statement and its tokens for statements.
based on the experts feedback we observe that our approach achieves a precision of .
.
and a recall of .
.
.
furthermore we conduct a large scale study with a dataset of ten java projects containing a total of file revisions.
our approach determines that gumtree mtdiff and ijm generate inaccurate mappings for and of the file revisions respectively.
our experimental results show that state of the art ast mapping algorithms still need improvements.
index terms program element mapping abstract syntax trees software evolution i. i ntroduction program element mapping algorithms are the underlying basis for analyzing changes between two versions of a source code file i.e.
a file revision .
abstract syntax tree ast mapping algorithms represent a file revision and program elements of the file as two abstract syntax trees asts and nodes respectively .
the algorithms approximate the similarity of nodes and calculate mappings of nodes between the two asts.
we define accurate mappings as mappings that can reflect the evolution of code well.
edit actions including adding deleting moving and updating nodes of an ast can be calculated based on the generated mappings by an ast mapping algorithm .
such edit actions can describe changes to the syntactic structure of code e.g.
parameters added in a method call can be represented as added nodes in an ast.
accurate mappings lead to accurate edit actions that can reflect a developer s intent.
many prior studies apply ast mapping algorithms to calculate edit actions for further analyses e.g.
api recommendation mining code change patterns and xcorresponding author.automated program repair .
the accuracy of the used ast mapping algorithms is vital for the correctness of the proposed approaches by prior studies.
however evaluations of the accuracy of ast mapping algorithms are limited.
when evaluating the generated mappings by an algorithm prior work relies heavily on manual analysis of the derived edit actions from the mappings .
since it is infeasible to analyze all file revisions by hand prior studies select a small sample for analysis.
the many cases where ast mapping algorithms perform badly cannot be revealed.
furthermore manually analyzing the mappings of program elements is time consuming and tedious.
an approach that can automatically find the inaccurate mappings as generated by ast mapping algorithms would be helpful.
practitioners and researchers can leverage such an approach to explore and navigate the generated mappings by an algorithm before performing further analyses.
in this paper we propose an approach for evaluating ast mapping algorithms.
we observe that a program element e often has only one best mapped program element ein a file revision.
the element emight be empty i.e.
eshould not be mapped.
if two algorithms inconsistently map such an element at least one of the algorithms inaccurately mapped the element.
we define similarity of two program elements in a file revision as the likelihood of the two elements to be mapped.
our idea is that if an algorithm maps a more similar program element forethan another algorithm the latter algorithm is likely to have made a mistake.
we aim to automatically compare the similarity of mapped program elements by different ast mapping algorithms.
in the software testing area this approach is referred to as differential testing .
to ease analysis we refine the mappings of ast nodes into mappings of each statement and tokens in the statement.
and we treat each statement as an analysis unit.
by so we avoid analyzing the mappings of ast nodes at all granularity levels.
notice that statements include declarations e.g.
method declarations in our paper.
a token is defined as a sequence of characters representing a program element such that none of its subsequences represents a program element.
given two algorithms if they inconsistently map a statement or its tokens we refer to such statements as statements with inconsistent mappings for the two algorithms.
if an algorithm inaccurately maps a statement or its tokens we refer to such statements as statements with inaccurate mappings for the ieee acm 43rd international conference on software engineering icse .
ieee algorithm.
we analyzed three ast mapping algorithms in our paper namely gumtree mtdiff and ijm iterative java matcher .
as shorthand notations we use gt and mtd to represent gumtree and mtdiff respectively.
we manually analyze statements with inconsistent mappings for comparing the algorithms.
through the manual analysis we design a hierarchical approach to automatically compare the similarity of mapped statements and tokens by different algorithms.
this hierarchical approach uses six measures collectively to perform the comparison.
by performing the comparison we determine statements with inaccurate mappings for each of the compared algorithms.
we invite external experts to determine if the studied algorithms generate inaccurate mappings at the statement or token level for statements.
compared to the experts evaluation we find that our approach achieves a precision of .
.
and a recall of .
.
.
we run the studied algorithms on all the file revisions of ten java projects.
we use our approach to analyze the generated mappings by the algorithms.
for and of the file revisions gt mtd and ijm are determined to generate inaccurate mappings respectively.
the results show that stateof the art ast mapping algorithms still need improvements.
we make our code and data publicly available on .
our contributions are summarized as follows we propose an approach that can automatically detect statements with inaccurate mappings for ast mapping algorithms.
almost all of the statements with inaccurate mappings as determined by our approach are also determined as such by experts .
we use our approach to analyze the generated mappings by gt mtd and ijm for file revisions.
the three algorithms are determined to generate inaccurate mappings for a considerable number of file revisions.
ii.
p reliminaries abstract syntax tree.
a source code file can be parsed as an abstract syntax tree ast .
an ast is a labeled ordered rooted tree which is composed of a set of nodes that are connected by edges.
an edge represents a parent child relationship.
a node n1is the parent of another node n2 ifn2is a child of n1.
the node that has no parent is called the root node .
a node that has no child is called a leaf node .
for a node the nodes along the path to the root node are called its ancestors .
and the node is called their descendant .
each node in an ast represents a code element e.g.
a statement with a label to indicate its type.
some nodes have a value to indicate the corresponding tokens of the element.
example .
.
fig.
b and fig.
present the two asts before and after the code changes at lines in fig.
a .
the asts are built using gt .
we only show partial asts for clarity.
the ast in fig.
b contains nodes.
the node n4has three child nodes n5 n6andn13 and its label is fielddeclaration .
the label of n5ismodifier and typedeclaration n23 modifier public n24 simplename publishedaddresspolicy n25 fielddeclaration n26 modifier private n27 parameterizedtype n28 simpletype n29 simplename map n30 simpletype n31 simplename integer n32 simpletype n33 simplename integer n34 variabledeclarationfragment n35 simplename portmapping n36 classinstancecreation n37 parameterizedtype n38 simpletype n39 simplename hashmap n40 simpletype n41 simplename integer n42 simpletype n43 simplename integer n44 fielddeclaration n45 modifier private n46 parameterizedtype n47 simpletype n48 simplename map n49 simpletype n50 simplename integer n51 simpletype n52 simplename integer n53 variabledeclarationfragment n54 simplename hostmapping n55 classinstancecreation n56 parameterizedtype n57 simpletype n58 simplename hashmap n59 simpletype n60 simplename integer n61 simpletype n62 simplename integer n63 n1 n23 n2 n24 n3 n25 n4 n26 n5 n27 n6 n28 n7 n58 n8 n59 n9 n31 n10 n32 n11 n33 n12 n34 n13 n35 n14 n36 n15 n37 n16 n38 n17 n39 n18 n40 n19 n41 n20 n42 n21 n43 n22 n44 add n45 n1 add n46 n45 add n47 n45 add n54 n45 add n29 n6 add n48 n47 add n50 n47 add n52 n47 add n55 n54 add n56 n54 add n30 n29 add n49 n48 add n51 n50 add n53 n52 add n59 n58 mov n7 n57 add n60 n57 add n62 n57 add n61 n60 add n63 n62 a partial changes of publishedaddresspo licy.java in the commit 4800a7 of activemq typedeclaration n1 modifier public n2 simplename publishedaddresspolicy n3 fielddeclaration n4 modifier private n5 parameterizedtype n6 simpletype n7 simplename hashmap n8 simpletype n9 simplename integer n10 simpletype n11 simplename integer n12 variabledeclarationfragment n13 simplename portmapping n14 classinstancecreation n15 parameterizedtype n16 simpletype n17 simplename hashmap n18 simpletype n19 simplename integer n20 simpletype n21 simplename integer n22 b partial ast before changes c partial ast after changes d mappings and edit actions by gtpublic class publishedaddresspolicy ... private hashmap integer integer portmapping new hashmap integer integer private map integer integer portmapping new hashmap integer integer private map string string hostmapping new hashmap string string ... 3fig.
mappings of ast nodes and edit actions as calculated by gt for the partial changes of a file in the commit 4800a7 of activemq.
it has a string value private indicating the field declaration is private for the class.
ast mapping algorithms.
given a file revision an ast mapping algorithm parses the file before and after the revision as two asts.
let us denote the two asts as source ast and target ast respectively.
by approximating the similarity of nodes the algorithm calculates mappings of nodes between the two asts.
only the nodes that have the same label can be mapped.
the mappings are a set of pairs hns nti in which ns belongs to the source ast and ntbelongs to the target ast.
example .
.
we leverage gt to calculate mappings of nodes between the asts shown in fig.
b and fig.
c .
fig.
d presents the mappings in the first column.
specially n4is mapped to n26 indicating that the field declaration portmapping at line in fig.
a is mapped to the field declaration portmapping at line in fig.
a .
in addition n7andn8are mapped to n58andn59 respectively.
such mappings indicate that the first hashmap of line and the hashmap of line in fig.
a are mapped i.e.
gt considers that the two hashmap tokens are the same element across the file revision.
edit actions.
based on mappings of ast nodes a series of edit actions can be calculated to transform the source ast to the target ast .
prior studies apply the chawathe et al.
algorithm to calculate the edit actions .
1175generally there are four types of edit actions upd n v replaces the value of the node nwith a value v. add n p i adds a node nas the ithchild of the node pifpis not null.
otherwise the node nis added as the new root node.
del n deletes a leaf node n. mov n p i moves the node nas the ithchild of the node p. the subtree rooted at nis moved together with n. example .
.
fig.
d presents the edit actions that are calculated based on the mappings shown in the same figure.
we use gt s implementation of chawathe et al.
s algorithm.
gt produces a sequence of edit actions.
one of the actions is mov n7 n57 .
this action moves the first hashmap of line in fig.
a to line in fig.
a .
current evaluations of ast mapping algorithms.
current evaluations of ast mapping algorithms include automatic and manual evaluations .
they are both based on the edit actions that are calculated from the generated mappings by different algorithms.
the number of edit actions is commonly used as an automatic measure for estimating the cognitive load for a developer when understanding the essence of a file revision .
mappings with fewer edit actions are considered to be better.
however the number of edit actions cannot reflect the accuracy of the mappings .
prior work relies heavily on manual analyses of the edit actions to determine the accuracy of the mappings .
frick et al.
proposed three criteria for determining if a mapping is accurate each mapping should be comprehensible i.e.
why the two program elements should be mapped the generated edit actions should be helpful in understanding the changes there exists no other comprehensible mappings resulting in fewer actions.
example .
.
in fig.
d we determine the accuracy of the mappings and highlight the inaccurate mappings with a yellow background.
the mappings hn7 n58iandhn8 n59i are determined to be inaccurate.
the nodes in the asts and edit actions that relate to the inaccurate mappings are also highlighted.
we consider that it is not comprehensible to map the first hashmap of line to the hashmap of line in fig.
a .
also the action mov n7 n57 is not helpful in understanding the changes.
it is better to map n7andn8to n29andn30 i.e.
map the first hashmap of line and the map of line in fig.
a .
thus the mappings for the nodes n29andn30are also considered to be inaccurate.
iii.
m otivation prior evaluations of ast mapping algorithms are limited to manually analyzing a small sample of file revisions .
for instance to evaluate gt falleri et al.
manually analyzed file revisions .
to evaluate mtd dotzler et al.
manually analyzed file revisions .
the many cases where an ast mapping algorithm performs badly cannot be revealed.
an approach that can automatically find inaccurate typedeclaration publishedadddresspolicy n9 modifier public n10 fielddeclaration n11 modifier private n12 parameterizedtype map integer integer n13 variabledeclarationfragment portmapping n14 classinstancecreation n15 parameterizedtype hashmap integer integer n16 fielddeclaration n17 modifier private n18 parameterizedtype map integer integer n19 variabledeclarationfragment hostmapping n20 classinstancecreation n21 parameterizedtype hashmap integer integer n22 typedeclaration publishedaddresspolicy n1 modifier public n2 fielddeclaration n3 modifier private n4 parameterizedtype hashmap integer integer n5 variabledeclarationfragment portmapping n6 classinstancecreation n7 parameterizedtype hashmap integer integer n8 n1 n9 n2 n10 n3 n11 n4 n12 n5 n13 n6 n14 n7 n15 n8 n16 a partial ast before changes b partial ast after changes c mappings by ijmfig.
mappings of ast nodes calculated by ijm for the changes shown in fig.
a .
private hashmap integer integer portmapping new hashmap integer integer private map integer integer portmapping new hashmap integer integer private map string string hostmapping new hashmap string string ijm gt1 fig.
the generated mappings by gt and ijm in fig.
and fig.
.
dashed lines show the inconsistent mappings.
mappings as generated by an algorithm would be helpful for both researchers and practitioners.
we observe that for a file revision a program element e1 often has only one best mapped element e2.
the element e2 can be empty indicating that e1should not be mapped.
for instance in fig.
a the first hashmap of line should be mapped to the map of line .
if two algorithms inconsistently map such a program element at least one of the algorithms inaccurately maps the element.
the inaccurate mappings can be found by analyzing the inconsistencies between the two algorithms.
we provide an example.
for the file revision shown in fig.
a we use ijm to calculate mappings of ast nodes.
different ast mapping algorithms may use different asts to represent the same file.
fig.
a and b show the ijm s asts that represent the changes at lines in fig.
a .
fig.
c presents the generated mappings by ijm.
the value of n5 denotes the first hashmap integer integer of line in fig.
a .
the value of n13denotes the map integer integer of line in fig.
a .
as shown in fig.
c ijm maps n5ton13.
by further mapping the tokens in the value of the two nodes we find that ijm accurately maps the first hashmap of line in fig.
a .
this mapping is inconsistent with the generated mappings by gt.
fig.
visualizes the generated mappings by gt and ijm and their inconsistent mappings.
we find that both gt and ijm map the statement at line to the statement at line in fig.
.
the first hashmap of line and the map of line belong to the mapped statements.
1176they both denote the type of the field portmapping .
on the other hand the first hashmap of line and the hashmap of line belong to unmapped statements.
thus in comparison to thehashmap of line the map of line is more similar to the first hashmap of line .
finally the inaccurately mapped hashmap by gt is detected.
in this motivational example we attempt to automatically perform the above analysis and find the inaccurate mappings as generated by ast mapping algorithms.
iv.
s tudied ast m apping algorithms in this study we analyze three state of the art ast mapping algorithms namely gumtree mtdiff and ijm .
we briefly introduce the three algorithms below.
gumtree gt is proposed by falleri et al .
given two asts gt matches nodes between the asts in two phases in the first phase gt applies a greedy top down algorithm to search and map identical subtrees.
in the second phase gt applies a bottom up algorithm to map a pair of nodes between the two asts if they share a significant number of mapped descendants.
then gt tries to map previously unmapped descendants of those nodes.
mtdiff mtd is proposed by dotzler et al.
.
mtd is based on the changedistiller algorithm .
first mtd applies the identical subtree optimization to reduce the mapping problem by removing unchanged subtrees from the asts.
then mtd maps nodes using the changedistiller algorithm.
another four optimizations are finally applied to find additional mappings of nodes.
ijm is proposed by frick et al.
.
ijm is an ast mapping algorithm specialized for java.
in comparison to gt ijm works on a reduced ast in which many name nodes are pruned and the value of each pruned node is merged to its parent node.
then ijm splits the ast into parts along each declaration.
finally it maps ast nodes from the corresponding parts between the two asts using an adaptation of the gt algorithm.
the adaptation adds name awareness to gt which considers similarity of values when mapping two nodes.
in this study we apply the implementations of the three algorithms that are provided on github .
v. a pproach in this section we describe the details of our approach.
notice that our approach is general.
we implement it for java programs but we can modify it to support other programs as long as we can generate asts from them.
the granularity of ast nodes ranges from a statement to a single literal.
it is too complex to analyze mappings of ast nodes of all granularity levels.
furthermore finding the corresponding nodes from the used asts by different algorithms is a big challenge.
because different algorithms may use asts with different sets of nodes including leaf nodes to represent the same file as shown in fig.
and fig.
.
we observe that different algorithms commonly encode statements as ast nodes.
additionally tokens of a file are ......file revision stmt1 stmt2stmt1 stmt2 ... ...a1 a2 stmt1 stmt2 ...a1a2 step tokenizationmappings of ast nodesstep grouping mappings along statements step creating mappings of statements and tokens step calculating statements with inconsistent mappings statements with inaccurate mappingsoutputinput token1 token2 token3token1 token2 token3 ... ...stmt1 stmt2 ... ... token1 token2 token3token1 token2 token1 token2token1 token2 token3stmt1 stmt2 ... ... token1 token2 token3token1 token1 token2token1 token2 token3token3a1a2 step algorithm accuracy determinationfig.
overview of our approach.
the red color and green color denote that the program element is from the file before and after the revision respectively.
not impacted by the composing nodes of an ast.
to solve the above issues we refine the mappings of ast nodes into mappings of statements and tokens.
moreover we treat each statement including the statement itself and its tokens as an analysis unit.
fig.
presents the overview of our approach.
given the generated mappings by two algorithms a1anda2 for a file revision we take five steps to calculate the statements with inaccurate mappings for each algorithm.
in sections v a to v e we describe the five steps respectively.
in section v f we elaborate how to compare the similarity of mapped statements and tokens by different algorithms.
a. tokenization in this step we tokenize the file before and after a revision.
instead of using punctuation and spaces we use the parsed ast of the source file to tokenize the file.
for example a string literal containing punctuation and spaces is considered as a single token.
for a java file we first use the eclipse jdt parser to generate a standard jdt ast.
then we extract the tokens from value of each ast node.
notice that we ignore ast nodes representing comments and javadocs.
because comments and javadocs are typically not treated as code .
as a result we retrieve two token lists for a file before and after a revision respectively.
the token lists are not impacted by the used ast by each algorithm b. grouping mappings along statements in this step we separately group mappings of ast nodes along statements for a1anda2.
in an ast a statement e.g.
a method declaration can have descendant statements.
for each statement in the source and target asts that are being analyzed by an algorithm we first group the nodes that belong to the statement but do not belong 1177to its descendant statements.
for instance our framework groups n1 n2 and n3in fig.
b for the type declaration publishedaddresspolicy .
then we find the generated mappings by the algorithm for the grouped nodes.
these mappings are grouped for the statement.
c. creating mappings of statements and tokens in this step we separately calculate mappings of statements and tokens for a1anda2.
among the grouped mappings for each statement we can directly find the mapping for the statement.
for instance in fig.
b n1represents the type declaration publishedaddresspolicy and the mapping ofn1is considered as the mapping of the declaration.
for a token we refer to an ast node whose corresponding program element contains the token as a relevant node of the token.
among the relevant nodes of a token we refer to the node of the lowest level as the directly relevant node of the token.
in return we refer to the token as a directly relevant token of the node.
we take the first hashmap of line in fig.
a as an example.
in the used ast by gt shown in fig.
b n1 n4 n6 n7andn8are relevant nodes of the token.
and the directly relevant node for the token is n8.
in the used ast by ijm shown in fig.
a n1 n3andn5are relevant nodes of the token.
and the directly relevant node for the token is n5.
an ast node can have several directly relevant tokens.
for instance the node n5in fig.
a has three directly relevant tokens including a hashmap and two integer tokens.
such tokens compose the value of n5.
another example is n1 in fig.
which has two directly relevant tokens including theclass andpublishedaddresspolicy tokens in fig.
a .
the publishedaddresspolicy token is the value of the node while the class token does not belong to its value.
we observe that a token s mapping is determined by the mapping of its directly relevant node.
we also take the first hashmap of line in fig.
a as an example.
in fig.
gt maps n8ton59 indicating that the token is mapped to the hashmap of line in fig.
a .
and in fig.
ijm maps n5ton13 indicating that the token can only be mapped to a directly relevant token of n13.
for each node of the source and target asts we calculate all the directly relevant tokens and list the tokens according to their character positions.
then for each pair of mapped nodes we map tokens from the lists of directly relevant tokens of the nodes.
if both lists have only one token we directly map two tokens.
otherwise we separately map the tokens composing the value of the nodes and other tokens since tokens composing the value of a node can only be mapped to those composing the value of another node.
for the tokens composing the values of the two nodes we first sequentially map identical tokens between the two lists and then map the tokens including the first and last tokens that are surrounded by already mapped pairs of tokens.
mapping program elements surrounded by already mapped pairs is a commonly used heuristic by program element mapping algorithms .
afterthat our framework applies the same method to map the tokens that do not belong to the value of the two nodes.
for instance in fig.
n5andn13are mapped.
the directly relevant tokens of n5include hashmap integer andinteger .
and the directly relevant tokens of n13include map integer andinteger .
all of the tokens belong to the values of the two nodes.
we first sequentially map the two integer tokens between the two lists.
hashmap andmap are surrounded by already mapped tokens and they are further mapped.
as a result we calculate mappings of tokens using the generated mappings of the ast nodes by a1anda2.
we further group mappings of tokens along each statement based on the grouped mappings of ast nodes for the statement.
d. calculating statements with inconsistent mappings in this step we calculate statements with inconsistent mappings for comparing a1anda2.
for each statement in the file before and after the revision we first calculate whether the two algorithms inconsistently map the statement.
then for each token in the statement we calculate whether the two algorithms inconsistently map the token.
finally we output statements with inconsistent mappings and for each statement we group the inconsistent mappings of the statement and its tokens by comparing the two algorithms.
e. algorithm accuracy determination in this step we compare the similarity of mapped statements and tokens across each pair of different algorithms.
by performing the comparison we determine the accuracy of each algorithm in the mapping of a statement or a token.
in this section we introduce how to determine the accuracy of each algorithm by performing the comparison.
in section v f we elaborate how to compare the similarity of mapped statements and tokens by different algorithms.
let us denote the similarity between two program elements eand eassim e e .
the elements can be statements or tokens.
suppose that two algorithms a0anda1 map a program element e0to two different elements e1and e2 respectively.
we notice that the two algorithms also inconsistently map e1ande2.
suppose that a0maps an element e3toe2 and a1maps an element e4toe1.
in other words a0generates two mappings fhe0 e1i he3 e2ig.
and a1generates two mappings fhe0 e2i he4 e1ig.
suppose that sim e0 e1 is larger than sim e0 e2 we determine that a0is more accurate than a1in mapping e0.
however it is not enough to determine that the mapping of e0 toe1is better than the generated mappings by a1.
we must also check the condition sim e0 e1 sim e4 e1 i.e.
a0 is also more accurate than a1in mapping e1.
if this condition is also satisfied we determine that a1inaccurately maps e0 ande1.
similarly we can also determine if the two generated mappings by a0are inaccurate.
given a pair of algorithms and a file revision we calculate the statements with inconsistent mappings.
for each statement with inconsistent mappings we perform the above comparison 1178table i statistics of the studied projects.
projects commit file revision activemq commons io commons lang commons math junit4 hibernate orm hibernate search spring framework spring roo netty total for the mappings of the statement and its tokens as generated by the two algorithms that are being compared.
consequently we calculate statements with inaccurate mappings for each algorithm.
for each studied algorithm we separately compare it with the other two studied algorithms.
finally we calculate a union set of statements with inaccurate mappings for any of the algorithms that are being compared.
f .
similarity comparison our aim is to automatically compare the similarity of mapped statements and tokens by different algorithms.
to realize this aim we perform a manual analysis of statements with inconsistent mappings.
also we verify if statements with inconsistent mappings can expose the inaccurate mappings as generated by the algorithms.
in this study we analyze ten open source java projects.
table i presents statistics of the ten studied projects.
these projects were analyzed by prior studies .
we collect the commits of the projects from the creation date of the projects to january .
we can compare three pairs of algorithms namely gt vs. mtd gt vs. ijm and mtd vs. ijm.
for each pair of algorithms we sample file revisions for which the two algorithms inconsistently map program elements from the studied projects.
for each file revision we analyze all the statements before and after the revision that involve the inconsistent mappings.
we analyze and statements for comparing the three pairs of algorithms respectively.
in total we analyze statements.
for each statement we determine the accuracy of mappings as generated by each of compared algorithms using frick et al.
s criteria .
in total we make determinations.
the first and second author of this paper separately analyzed the statements with inconsistent mappings.
both authors have at least three years of programming experience in java.
we calculate fleiss kappa to estimate the agreement of the two annotators determination results.
the kappa value is .
which indicates an excellent agreement.
finally the two annotators compared their determination results to uncover disagreements.
for each statement with a disagreement the annotators further discussed the accuracy of the generated mappings by the two compared algorithms.we analyze all the statements with inaccurate mappings to design similarity measures to distinguish accurate and inaccurate mappings of statements and tokens.
we categorize the statements with inaccurate mappings for the algorithms along each similarity measure.
for each statement with inaccurate mappings we consider if we have designed a measure that can identify the inaccurate mappings.
if we have designed such a measure we categorize the statement to the category of the measure.
otherwise we try to design a new similarity measure to distinguish the accurate and inaccurate mappings.
by so we design hierarchical similarity measures for two statements and two tokens.
from our manual analysis we have the following findings.
among the statements for comparing gt and mtd and statements involve inaccurate mappings as generated by gt and mtd respectively.
among the statements for comparing gt and ijm and statements involve inaccurate mappings as generated by gt and ijm respectively.
among the statements for comparing mtd and ijm and statements involve inaccurate mappings as generated by mtd and ijm respectively.
for each statement with inconsistent mappings for comparing two algorithms at least one algorithm is determined to generate inaccurate mappings.
hence statements with inconsistent mappings can expose the inaccurate mappings as generated by the algorithms.
there exist cases where two algorithms consistently produce an inaccurate mapping of a statement or a token.
in total we find statements with inaccurate mappings for gt mtd and ijm respectively.
based on our observation we design two similarity measures for comparing two statements and four similarity measures for comparing two tokens.
table ii presents the six measures.
notice that we define two tokens with the same value as identical tokens .
we use the six similarity measures collectively to compare the generated mappings by different algorithms.
in the remaining part of this section we first introduce the six measures and our categorization results for the statements with inaccurate mappings.
then we describe the usage of the proposed measures.
the six similarity measures are elaborated below.
nit is defined as the number of mapped identical tokens between a pair of mapped statements.
two mapped statements with a larger nit are more similar and an nit of indicates that the two statements are highly dissimilar.
if two statements are mapped with an nit of we determine the mapping as inaccurate.
otherwise for a pair of mapped statements we check if the mapping of one of the statements to another statement can achieve a larger nit.
for instance in fig.
a mtd inaccurately maps the statements at lines and and the nit is .
in fig.
b gt maps the statements at lines and with an nit of five.
ijm maps the statements at lines and with an nit of four.
we determine that gt is more accurate than ijm in mapping the statement at line .
1179table ii the similarity measures for statements and tokens.
element measure measure description gt mtd ijm stmt.nit number of mapped identical tokens between a pair of mapped statements.
pm whether the parent nodes of a pair of mapped statements are mapped.
tokentype whether mapped tokens have the same type.
stmt whether mapped tokens belong to a pair of mapped statements.
v al whether mapped tokens have the same value.
llcs length of the longest common subsequence calculated using mapped tokens between mapped statements.
other assertequals msg array size mismatch end start array.length cos.write i mtd1 private static boolean isappxml string mime ... static boolean istestxml string mime ... static boolean isappxml string mime ... ijmgt1 a partial changes of countoutputstreamtest.java from commit 4ab6a3 of commons io nit b partial changes of xmlstreamreader.java from commit d46782 of commons io nit 3public void testfilterset iofilefilter filter filefilterutils.namefilefilter a final iofilefilter filter filefilterutils.namefilefilter a public void testfilterlist fromarray throws exception final iofilefilter filter filefilterutils.namefilefilter a ijm gt c partial changes of filefiltertestcase.java from commit 6aa007 of pm fig.
illustrative examples of inaccurately mapped statements that can be identified using our measures.
pm characterizes whether the parent nodes of a pair of mapped statements are also mapped.
we observe that statements with mapped parent nodes are more likely to be mapped.
for a pair of mapped statements we check if mapping one of the statements to another statement with mapped parent nodes can achieve the same nit.
for instance in fig.
c ijm maps the statements at lines and with mapped parent nodes while gt maps the statements at lines and with parent nodes not mapped.
we determine that ijm is more accurate than gt in mapping the statement at line .
furthermore we notice a special type of statements i.e.
blocks.
a block is a group of statements between balanced braces i.e.
f and g .
we observe that a block should be mapped along with its parent nodes e.g.
the f following the method testfilterset in fig.
c should be mapped along with the method declaration.
thus mapped blocks with unmapped parent nodes are determined to be inaccurate.
type characterizes whether mapped tokens have the same type.
for a token whose directly relevant node is not a name node we define the type of the token as the label of its directly relevant node.
for tokens whose directly relevant node is a name node we define four types variable name type name method name and declaration name.
following frick et al.
we consider the mapping of tokens with different types as inaccurate.
for instance in fig.
a gt maps a variable name value to a method name bytevalue we determine that such a mapping is inaccurate.
stmt characterizes whether mapped tokens belong to a pair of mapped statements.
two tokens from mapped statements are more likely to be mapped.
we observe that mapping tokens return value mutablebyte obj .value return value mutablebyte obj .bytevalue gt filterable filterable filterable runner filterable filterable filterable child gt a partial changes of mutablebyte.java from commit 49e1f1 of commons lang type buf.writebytes request.geturi .toasciistring .getbytes buf.writebytes request.geturi .getbytes d partial changes of httprequestencoder.java from commit 2d9277 of netty value 2ijm gt ijm e partial changes of filter.java from commit 42beed of junit4 lcst private hashmap integer integer portmapping new hashmap integer integer private map integer integer portmapping new hashmap integer integer private map string string hostmapping new hashmap string string ijm gt1 c partial changes of publishedaddressp olicy.java from commit 4800a7 of activemq stmt appenddetail buffer fieldname object value appenddetail buffer fieldname value gt1 b partial changes of tostringstyle.java from commit 85d334 of commons lang stmt ijm does not map the two tokens.
ijmijm does not map the two tokens.fig.
illustrative examples of inaccurately mapped tokens that can be identified using our measures.
from mapped statements is better than not mapping the tokens and mapping tokens from unmapped statements.
for instance in fig.
b the two value tokens are both variable names and they belong to a pair of mapped statements.
gt maps the two tokens while ijm does not map them.
we determine that gt is more accurate than ijm in mapping the two tokens.
as another example we find that both gt and ijm map the statement at line to the statement at line in fig.
c .
gt maps the two hashmap tokens in unmapped statements while ijm maps the hashmap to the map from the mapped statements.
using the stmt measure we determine that ijm is more accurate in mapping the hashmap at line than gt.
val characterizes whether mapped tokens have the same string value.
two identical tokens in a pair of mapped statements are more likely to be mapped.
we consider that mapping such two tokens is better than mapping one of the tokens to another token with different values between the two statements.
for instance in fig.
d gt maps getbytes to writebytes while ijm maps the two getbytes tokens.
using the v al measure we determine that ijm is more accurate in mapping the getbytes tokens than gt.
llcs is defined as the length of the longest common subsequence lcs that is calculated using the mapped tokens between mapped statements.
we observe that the order of tokens is infrequently changed in a statement.
we use llcs to quantify the number of tokens that are sequentially mapped between the mapped statements.
for instance in 1180fig.
e gt changes the orders of the two filterable tokens in the statement at line .
as a result at most three tokens are sequentially mapped between the statements i.e.
filterable andrunner .
the llcs for the mapped tokens is calculated as three.
ijm sequentially maps the five tokens between the two statements.
the llcs for the mapped tokens is calculated as five.
using the llcs measure we determine that ijm is more accurate in mapping the filterable tokens than gt.
table ii shows the number of statements that are categorized along the measures.
the measures can identify and of the statements with inaccurate mappings for gt mtd and ijm respectively.
the other statements with inaccurate mappings are categorized into the other category.
for these statements we find that determining the accuracy of the mappings of statements and tokens requires more comprehension of the changes.
usage of the similarity measures.
we compare the generated mappings by two algorithms using the following steps.
step .
if an algorithm maps two non block statements with an nit of we determine the mapping as inaccurate.
if an algorithm maps two blocks with unmapped parent nodes we determine the mapping as inaccurate.
if an algorithm maps two tokens with different types we determine the mapping as inaccurate.
step .
when the two algorithms map a statement to different statements mapping statements with a larger nit is considered to be more accurate.
if the two pairs of statements have the same nit mapping statements with mapped parent nodes is considered to be more accurate than mapping statements with unmapped parent nodes.
step .
when the two algorithms consistently map a statement we assume that the two algorithms accurately map the statement.
from the statement we retrieve all the tokens that are inconsistently mapped by the two algorithms.
for a token that is inconsistently mapped by the two algorithms we first use the stmt measure to compare the generated mappings for the token by the two algorithms.
if both algorithms map tokens from the mapped statements mapping identical tokens is considered to be more accurate than mapping tokens with different values.
if both algorithms map identical tokens from the mapped statements the mapped tokens with larger llcs are considered to be more accurate.
vi.
e valuation we evaluate our approach by answering three research questions.
in this section we present the three research questions and our answer to each question.
a. rq1 how effective is our approach in detecting statements with inaccurate mappings for the studied algorithms?
motivation.
by answering this research question we investigate if our approach can effectively find the statements with inaccurate mappings as generated by the studied algorithms.method.
our approach may be over fit on the used dataset in our manual analysis.
thus we conduct an experiment with external experts.
the experts include phd students and postdoctors majoring in software engineering.
they have three to seven years of programming experience in java.
seven experts have prior experience working in industry.
for each project we randomly select statements from all the file revisions.
for each selected statement at least two studied algorithms inconsistently map the statement or its tokens.
in total we select of such statements with inconsistent mappings.
the selected statements involve various change patterns including adding deleting moving and updating statements and tokens.
we randomly divide the statements into four groups with each group having statements.
we also divide the experts into four groups with each group having three experts.
we invite the four groups of experts to analyze the four groups of statements respectively.
for each statement we provide the mappings of the statement and its tokens as generated by each of the studied algorithms.
notice that we do not provide the algorithm that generates the mappings.
we let the experts determine if the mapping of the statement or a token of the statement is inaccurate.
for each group of statements we calculate fleiss kappa to estimate the agreement of the three experts determination results.
for each studied algorithm we have three determination results on the accuracy of algorithm in mapping each statement and its tokens.
for each statement and the generated mappings of the statement and its tokens by an algorithm we label the mappings as inaccurate if at least two experts determine that inaccurate mappings exist.
then we run our approach to determine statements with inaccurate mappings for gt mtd and ijm from the statements.
finally we compare the determination results of our approach with the experts determination results.
we define a true positive as a statement with inaccurate mappings for an algorithm that is determined as such by both our approach and experts.
we define a false positive as a statement with inaccurate mappings for an algorithm that is determined as such by our approach but not determined as such by experts.
we define a false negative as a statement with inaccurate mappings for an algorithm that is determined as such by experts but not determined as such by our approach.
let us denote the number of true positives false positives and false negatives as tp fp and fn.
we calculate the precision of our approach astp tp fp.
and we calculate the recall of our approach astp tp fn.
results.
for the four groups of statements the kappa values for the experts determination results are .
.
.
and .
respectively.
thus the experts determination results have an excellent agreement.
table iii presents the tp fp fn precision and recall of our approach in determining statements with inaccurate mappings for the studied algorithms.
as shown in the table our approach achieves a precision of .
.
and a recall of .
.
.
almost all of the statements with inaccurate mappings as determined by our approach are also determined as such by log.trace redelivery redeliverycount of messagereference.getmessageid with delay delay dest messagereference.getregiondestination .getactivemqdestination destination regiondestination destination messagereference.getregiondestination log.trace redelivery redeliverycount of messagereference.getmessageid with delay delay dest regiondestination.getactivemqdestination mtdgt ijm1 3fig.
gt and ijm generates accurate mappings but our approach determines the mapping of a token as inaccurate.
table iii tp fp fn precision and recall of our approach.
alg.
tp fp fn precision recall gt .
.
mtd .
.
ijm .
.
experts.
for the false positives and false negatives we further asked the experts why they considered that an algorithm inaccurately maps a statement or tokens of the statement.
we analyze cases of false positives and false negatives.
for the two false positives we find that gt and ijm generate the accurate mappings for a statement and its tokens but our approach determines the mapping of a token as inaccurate.
we show this case in fig.
.
as shown in fig.
the code involves a refactoring that extracts the method invocation messagereference.getregiondestination in the statement at line as a new variable.
gt and ijm accurately map the invocation to the statement at line while mtd maps messagereference in the statement at line to theregiondestination in the statement at line .
in this case mapping tokens from unmapped statements is better than mapping tokens from mapped statements.
however when comparing the generated mappings by gt ijm and mtd our approach considers that mtd generates a better mapping than gt and ijm.
this case indicates that our approach can be further improved by considering refactoring changes.
for cases of false negatives we find that our similarity measures can distinguish the accurate and inaccurate mappings of statements or tokens.
however all three algorithms generate inaccurate mappings.
hence the inaccurate mappings cannot be detected by comparing the similarity measures of the mapped statements and tokens between different algorithms.
we observe cases where an algorithm maps two tokens from unmapped statements and another algorithm separately maps the two tokens to empty elements.
we observe cases where an algorithm maps two statements and another algorithm separately maps the two statements to empty elements.
we further observe cases where two algorithms map a statement or token to different statements or tokens but our similarity measures cannot distinguish accurate and inaccurate mappings.
in these cases determining the inaccurate algorithm requires more syntactic information to determine if mapping two tokens or two statements helps understand the changes.
summary.
our approach achieves a precision of .
.
and a recall of .
.
in determining the statementstable iv tp fp fn precision and recall of our approach when comparing an algorithm with another algorithm.
comparison alg.
tp fp fn precision recall gt vs. mtdgt .
.
mtd .
.
gt vs. ijmgt .
.
ijm .
.
mtd vs. ijmmtd .
.
ijm .
.
with inaccurate mappings for the studied algorithms.
any statements with inaccurate mappings that we detect are highly likely to be correct although there may be additional inaccurate mappings that we cannot detect.
our approach can be used to estimate the lower bound on the effectiveness of ast mapping algorithms.
b. rq2 how effective is our approach when comparing an algorithm with multiple algorithms than when comparing it with another algorithm?
motivation.
as described in section v e we separately compare an algorithm with the other two algorithms.
then we calculate a union set of statements with inaccurate mappings for the algorithm.
we investigate if comparing an algorithm with the other two algorithms is more effective in detecting statements with inaccurate mappings than comparing it with another algorithm.
method.
we have three pairs of studied algorithms namely gt vs. mtd gt vs. ijm and mtd vs. ijm.
for the analyzed statements in rq1 we use our approach to compare the generated mappings for statements and tokens by each pair of algorithms.
for each pair of algorithms we calculate a set of statements with inaccurate mappings.
in such a case we compare an algorithm with another algorithm.
then we calculate the precision and recall of our approach in detecting statements with inaccurate mappings for the two algorithms.
the precision and recall of our approach that compares an algorithm with the other two algorithms are shown in table iii.
finally we compare the results shown in the table with the precision and recall of our approach that compares an algorithm with another algorithm.
results.
table iv presents tp fp fn precision and recall of our approach when comparing an algorithm with another algorithm.
by comparing the results show in tables iii and iv we find that our approach achieves a better recall with a difference of when comparing an algorithm with two algorithms than when comparing it with another algorithm.
on the other hand the precision of our approach is not impacted.
1182table v number of statements and file revisions for which the studied algorithms are determined to generate inaccurate mappings.
projectsstatements file revisions gt mtd ijm gt mtd ijm activemq commons io commons lang commons math junit4 hibernate orm hibernate search spring framework spring roo netty as described in section v f two algorithms may generate the same mapping that is inaccurate.
such an inaccurate mapping cannot be detected by comparing the two algorithms.
if another algorithm generates the accurate mapping comparing the third algorithm with the former two algorithms may reveal the inaccurate mapping.
thus comparing an algorithm with multiple algorithms can detect more inaccurate mappings.
summary.
our approach can detect more statements with inaccurate mappings when comparing an algorithm with the other two algorithms than when comparing it with another algorithm.
c. rq3 do state of the art ast mapping algorithms generate many inaccurate mappings?
motivation.
we show that our approach achieves a nearly perfect precision in finding statements with inaccurate mappings for the studied algorithms.
hence we leverage our approach to investigate whether the studied algorithms generate many inaccurate mappings.
method.
we leverage gt mtd and ijm to calculate the mappings of the ast nodes for all the file revisions of the ten studied projects.
for each file revision we use our approach to detect the statements with inaccurate mappings for each studied algorithm.
for each project we count the detected statements with inaccurate mappings for each algorithm.
we also count the file revisions for which the studied algorithms are determined to generate inaccurate mappings.
results.
table v presents the number of statements with inaccurate mappings as detected by our approach.
we also show the number of file revisions for which the studied algorithms are determined to generate inaccurate mappings.
as shown in the table the three studied algorithms may generate a considerable number of inaccurate mappings.
for each project we further calculate the ratio of file revisions for which the studied algorithms are determined to generate inaccurate mappings.
we find that gt mtd and ijm are determined to generate inaccurate mappings for and of the file revisions respectively.
summary.
gt mtd and ijm are determined to generate inaccurate mappings for a considerable number of file revisions.
state of the art ast mapping algorithms still have room for improvement.vii.
d iscussion a. threats to validity the primary threats to the validity of our experiments are twofold.
first we compare the determination results of our approach and experts on the accuracy of generated mappings by the studied algorithms for statements.
the number of analyzed statements is not very large scale.
this is because such a manual analysis is time consuming with understanding mappings of each statement and each token.
on average each expert takes .
hours to analyze the allocated statements.
the statements are randomly taken from different projects and they are from different file revisions.
dotzler et al.
analyzed only file revisions when evaluating mtd .
our analysis involves much more file revisions than their analysis.
second when we select the statements we require that at least two studied algorithms inconsistently map the statement or its tokens.
there may exist cases where the studied algorithms consistently map a statement and its tokens but the mapping of the statement or a token of the statement is inaccurate.
the selected statements do not consider such cases and our approach cannot detect the inaccurate mapping in such cases.
we manually analyzed statements for which the studied algorithms generate consistent mappings at both statement and token levels.
we did not observe the cases where the three algorithms produce inaccurate mappings.
nevertheless our code and data are made publicly available and researchers are encouraged to investigate this possibility.
b. limitations from our experiments we observe two limitations of our approach.
first as described in our answer to rq1 refactoring changes may impact the precision of our approach.
in refactoring changes mapping tokens from unmapped statements may be better than mapping tokens from mapped statements.
we note that researchers proposed several refactoring detection tools e.g.
.
incorporating such tools into our approach may deal with this limitation.
on the other hand there still exists a considerable number of inaccurate mappings that cannot be detected by our approach.
according to our answer to rq2 comparing an algorithm with more algorithms may detect more inaccurate mappings as generated 1183by the algorithm.
moreover researchers have proposed various heuristics to map program elements .
additional similarity measures can be derived from these heuristics.
such measures may further improve the recall of our approach.
our code and data are made publicly available and researchers are encouraged to extend our approach.
viii.
r elated work a. ast mapping algorithms many ast mapping algorithms were proposed in prior studies.
yang proposed an ast mapping algorithm using a branch and bound implementation of the largest common subtree problem .
this algorithm does not consider moved ast nodes.
fluri et al.
proposed changedistiller an ast mapping algorithm that uses a reduced ast in which code statements are encoded as leaf nodes .
hashimoto et al.
proposed diff ts an algorithm that works with raw asts and supports multiple languages .
nguyen et al.
proposed jsync which leverages a classic text based mapping algorithm to map ast nodes .
recently researchers proposed gumtree mtdiff and ijm .
these algorithms are the state of the art ast mapping algorithms and are analyzed in our paper.
different from them we focus on evaluating ast mapping algorithms rather than proposing a new ast mapping algorithm.
b. use of ast mapping algorithms ast mapping algorithms are widely used in several se research areas.
changedistiller has been used to identify nonessential modifications and automate repetitive edits .
nguyen et al.
used jsync to track cloned code in the software evolution process .
moreover many studies used gumtree to analyze code patterns of changes such as bug fixing changes logging changes and changes to online code examples .
also prior work trained models based on the edit actions of changes that are calculated using gumtree .
such models are used to recommend changes such as patches and logging changes .
different from them we focus on evaluating ast mapping algorithms instead of using the algorithms to analyze changes.
ix.
c onclusion and future work in this paper we propose a differential testing approach that can automatically determine the statements with inaccurate mappings for ast mapping algorithms.
given a file revision we first compare the generated mappings by different algorithms and extract the statements with inconsistent mappings.
then we use six similarity measures collectively to compare the mapped statements and tokens by different algorithms.
by so we determine the statements with inaccurate mappings for each of the algorithms.
by conducting an experiment with experts we show that our approach achieves a precision of .
.
and a recall of .
.
.
the studied algorithms are determined to generate inaccurate mappings for a considerable number of file revisions in our studied projects.
hence state of theart ast mapping algorithms still need improvements.
ast mapping algorithms play a foundational role in many existing studies.
it is necessary to investigate if the inaccurate mappings as generated by the algorithms impact the conclusions of existing studies.
acknowledgement this research was partially supported by the national key r d program of china no.
2019yfb1600700 australian research council s discovery early career researcher award decra funding scheme de200100021 arc discovery grant dp200100020 key research and development program of zhejing province no.
2021c01014 and the national research foundation sinapore under its industry alignment fund prepositioning iaf pp funding initiative.
any opinions findings and conclusions or recommendations expressed in this material are those of the author s and do not reflect the views of national research foundation singapore.