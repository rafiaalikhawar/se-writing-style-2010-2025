smartcommit a graph based interactive assistant for activity oriented commits bo shen key lab of high confidence software technology peking university moe beijing chinawei zhang key lab of high confidence software technology peking university moe beijing chinachristian k stner carnegie mellon university pittsburgh pa usa haiyan zhao key lab of high confidence software technology peking university moe beijing chinazhao wei huawei technologies co. ltd. beijing chinaguangtai liang huawei technologies co. ltd. beijing china zhi jin key lab of high confidence software technology peking university moe beijing china abstract in collaborative software development it is considered to be a best practice to submit code changes as a sequence of cohesive commits each of which records the work result of a specific development activity such as adding a new feature bug fixing and refactoring.
however rather than following this best practice developers often submit a set of loosely related changes serving for different development activities as a composite commit due to the tedious manual work and lack of effective tool support to decompose such atangled changeset .
composite commits often obfuscate the change history of software artifacts and bring challenges to efficient collaboration among developers.
to encourage activity oriented commits we propose smartcommit a graph partitioning based interactive approach to tangled changeset decomposition that leverages not only the efficiency of algorithms but also the knowledge of developers.
to evaluate the effectiveness of our approach we deployed smartcommit in an international it company and analyzed usage data collected from a field study with engineers over months and conducted a controlled experiment on synthetic composite commits from diverse open source projects.
results show that smartcommit achieves a median accuracy between when decomposing composite commits without developer involvement and significantly helps developers follow the best practice of submitting activity oriented commits with acceptable interaction effort and time cost in real collaborative software development.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
concepts software and its engineering software configuration management and version control systems collaboration in software development .
keywords revision control system code commit changes decomposition acm reference format bo shen wei zhang christian k stner haiyan zhao zhao wei guangtai liang and zhi jin.
.
smartcommit a graph based interactive assistant for activity oriented commits.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction in collaborative software development software artifacts are usually under continuous evolution.
developers modify software artifacts for various development tasks activities such as implementing new features fixing bugs or vulnerabilities and refactoring.
to efficiently manage the life cycle of software artifacts the version control system vcs like git is employed to track the change history of software artifacts as a sequence of commits each commit consists of a set of differences diffs representing the changes of source code since the last version as well as a textual description commit message summarizing the content and intent of these code changes.
consequently commits act as the basic unit to organize changes on software artifacts upon which many other vcs functions are built.
it is considered to be a best practice to submit code changes as a sequence of cohesive commits each of which records the work result of a specific development activity such kind of commits is also called atomic single activity oractivity oriented commits.
when following this practice a clear change history of software artifacts can be maintained which benefits various activities related to software development .
for an individual developer activityoriented commits make it easier to revert a buggy commit or reuseesec fse august athens greece bo shen wei zhang christian k stner haiyan zhao zhao wei guangtai liang and zhi jin specific changes.
for a team of developers activity oriented commits make it easier for a developer to understand and review code changes made by other developers .
for a researcher in the field of software development activity oriented commits bring less noise when carrying out studies that depend on historical data e.g.
mining software repositories .
because of these benefits developers are encouraged to follow this best practice in many opensource communities e.g.
git official1and angular2 and companies e.g.
google3 through explicit regulations and guidelines.
however rather than following this best practice developers often submit a set of loosely related changes serving for different development activities as a composite commit due to the tedious manual work and lack of effective tool support to decompose such a tangled changeset .
in daily development developers are often observed to perform several independent activities simultaneously such as refactoring the code structure while working on a new feature floss refactoring or fixing a bug along the way while optimizing a function leading to a tangled changeset in the workspace.
prior empirical studies repeatedly and consistently confirmed that composite commits are common in software projects both for open source and industrial ones.
herzig and zeller found that composite commits occur in up to of all bug fix commits in open source projects.
tao and kim studied code changes from open source projects and concluded that on average and up to of all commits are composite and address two or more issues.
barnett et al.
found that changesets can be decomposed in over of code reviews at microsoft.
in researches on defect prediction and localization nguyen et al.
reported that to of bug fix commits include other changes.
worse still the chances of depending on developers to eliminate composite commits are slim because of unawareness or tedious manual effort .
on one hand some developers simply do not know the best practice.
on another hand although some vcss like git interactive staging4 or tools like gitkraken andfork do provide functions to decompose changes in a developer s workspace these functions totally depend on manual operations.
researchers have proposed various approaches to address the problem of composite commits by decomposing them with algorithms typically based on heuristic rules program slicing techniques code dependency or pattern matching .
but there are still two weaknesses in these approaches.
first most of these approaches identify and decompose composite commits temporarily at the code review stage where composite commits have been recorded in the version history or shared with collaborators.
we argue that it is more meaningful to prevent the occurrence of composite commits by proactively decomposing the corresponding tangled changeset before the submission as also suggested in several works .
second these approaches often generate too fine grained decomposition results which can hardly be used as activity oriented commits.
the cause is that these approaches usually rely on a limited set of information retrieved from source code many valuable relations between diff hunks are out of consideration leading to the result that two diff hunks that should submitted together are separated.
we argue that a promising approach should identify and utilize a diverse set of information even including knowledge from developers.
for the purpose of reminding leading and assisting developers to follow the best practice of activity oriented commits in this work we propose an interactive approach named smartcommit which leverages both the efficiency of the algorithm and the knowledge of the developer.
in particular this approach has two features.
first it assumes that it is very difficult to design a fully automated algorithm that can decompose tangled changesets accurately and without developers intervention since what constitutes an activity oriented commit is closely related to a project s characteristics and a developer s subjective criteria for this reason it employs an intuitive gui based interaction mechanism for a developer to participate in the decomposing process efficiently.
second it adopts an extensible graph representation named diff hunk graph to capture comprehensive semantic and heuristic relations between changes and transforms the problem of changeset decomposition into a graph partition problem correspondingly.
we evaluated smartcommit with regard to effectiveness and scalability under industrial as well as open source settings.
on one hand we deployed smartcommit in an international it company and recruited engineers to use it for months.
on the other hand we generated synthetic tangled changesets from popular open source projects with different scales and from different domains and compared the decomposition suggested by smartcommit with the original commits i.e.
the ground truth .
the industrial field study shows that smartcommit could help developers submit activity oriented commits with acceptable manual effort .
operations on average .
the open source experiment shows that smartcommit achieves a median accuracy of .
.
with stable performance under different input sizes less than seconds in cases .
overall our work makes the following contributions an extensible graph representation to capture categories of relations between code changes including the hard links soft links refactoring links andcosmetic links .
a graph partitioning based algorithm to decompose tangled changesets which outperforms the state of the art approach in terms of accuracy and interpretability.
an interaction mechanism between the decomposing algorithm and the developer which leverages developers knowledge through two kinds of simple adjustment operation.
a well engineered open source tool for smartcommit which stands the test of a month practical use as well as an extensive evaluation on diverse open source projects.
motivating example and exploratory study in figure we show a real composite commit from jruby project.5in this commit two java source files were changed with diff regions but the diff content and the commit message both indicate that this commit contains code changes for multiple activities including refactoring fixing two issues and cleaning up some dead code.
although this commit comes with a clear bullet list description a graph based interactive assistant for activity oriented commits esec fse august athens greece whereas many composite commits do not it is still difficult to review integrate or reuse since changes corresponding to different activities are mixing up and intersecting with each other.
to better understand the state of the practice about composite commits we conducted semi structured interviews with software practitioners for their viewpoints about composite commits.
they were recruited through our professional network four p1 p4 are industrial software engineers two are open source contributors p5 and p6 and all of them have more than year experience of java programming.
after showing them the above motivating example we asked each participant to find composite commits from the historical commits or pull requests in their own projects so as to ground the later discussion.
inspired by contextual inquiry techniques we discussed with participants about the composite commits they have submitted recently to collect insights about the cause and effect of composite commits.
each interview was conducted with an observation phase we observed how each participant decomposed composite commits with git interactive staging and a discussion phase we asked them questions about the cause and effect of composite commits as well as the expected assistance .
details about questions process and quoted user responses are available in our supplementary data repository .
we categorized the collected insights into topics benefits all participants agreed that the best practice of activity oriented commits would generally be beneficial for development maintenance and collaboration among developers e.g.
making it easier to describe understand revert and integrate code changes.
for example one developer p3 mentioned that when using git bisect to locate bugs it will be good if the buggy commit is small to safely revert.
causes by recalling the submission process of historical composite commits participants pointed out three major causes of composite commits interleaved development tasks the time stress and the absence of regulations guidelines tool support in practice e.g.
our team have regulations about code style but nothing about commit style.
p2 clues when manually decomposing changesets participants tended to find clues like code structure and dependency change similarity and refactoring.
other clues included systematic edits change couplings and frameworks.
for example one developer p6 told us his experience to fix a buggy condition in if for while i am used to also check other similar ones.
expectations when asked to imagine an automatic tool for changeset decomposition they all thought it is difficult and also unsafe to fully automate this process.
but they did expect such a tool to save their effort in reviewing and organizing changes with an intuitive gui and if it would not change their code some inaccuracy would be find a few errors are tolerable as long as i can correct them quickly.
p5 the benefits andcauses insights confirmed the findings in the previous works and the clues insights motivated us to design an approach to decomposing changesets by simulating the process of manual decomposition.
the expectations from developers motivated us to make it interactive and co work with the developer to improve its feasibility in practice.
project jrubycommit id f79d6c3087b93b08f47a122aa42e72d7ddf87a3dcommit message fixes plus partial refactor of selectexecutor.
eliminate fdsarray since we already have an object and fields.first step to reducing allocation.
attach list of fdsto key to allow both read and write to reg.
update rather than replace key ops with additional operations.
use selectorpoolto acquire release selectors.
misccleanup of dead code.fixes 2102fixes 2106changedfiles core src main java org jruby ir compiler.javacore src main java org jruby util io selectexecutor.java... irubyobjectselectend threadcontextcontext int i irubyobjectselectend threadcontextcontext throws ioexception fdterm readkeylist fdterm writekeylist fdterm errorkeylist ... for i i i fdterm fds clear cancelled keys with selectnow and return to pool for selector selector selectors.values try selector.selectnow finally context.runtime.getselectorpool .put selector ... private static void fdset list fds int offset channelfdfd if fds null fds new arraylist fds .add fd ... irubyobjectread write except list selectionkey fds new list final irubyobjectread write except list selectionkey readkeylist list selectionkey writekeylist list selectionkey errorkeylist list channelfd unselectablereadfds list channelfd unselectablewritefds list channelfd pendingreadfds ...figure an example composite commit from the jruby project in which multiple activities were done and two issues were addressed in single commit.
allchangesinonegrouponechangeineachgroupinitialstateextremestateaccepteddecompositioninitialsuggestioncoarsecontrolfinetuning figure getting close to the accepted decomposition through coarse and fine interactions.
approach in this section we first describe the target problem as well as the major challenge.
after that we present an approach named smartcommit to address the problem and challenge.
.
problem statement the target problem is to decompose a tangled changeset into a sequence of activity oriented subsets each of which corresponds to the work result of a specific development activity.
the major challenge of this problem is how to group low level operational code changes according to implicitly specified high level development activities which can hardly be fully automated for two reasons.
first what constitutes an activity oriented commit is often specific to project and subjective to developer.
existing approaches try to decompose changesets typically based on predefined heuristics about source code and code changes and have been proved to be too rigid to meet the developer s expectation .
second it is difficult to encode information beyond source code e.g.
project changespecific knowledge or developer specific criteria into an algorithm to improve the decomposition process.
to cope with the above challenge we argue that a promising approach should be a human in the loop solution which integrates the developer knowledge with a semi automatic algorithm in the decomposition process.
as shown in figure we consider the target problem in general as finding an accepted decomposition between the initial state where all changes are submitted as a single commit and the extreme state where each change is submitted as a separate commit .
in this way the decomposition is a process where an algorithm co works with the author of code changes to find an activity oriented decomposition.esec fse august athens greece bo shen wei zhang christian k stner haiyan zhao zhao wei guangtai liang and zhi jin commitssubmissioninteractivedecompositiongraphconstructionpreprocessingrepository figure1.overview headversion1version2version3diffhunkgraph accepted groupsgeneratedgroupscommits changesetbasecurrent1234start enddiff hunk 1diff hunk 2diff hunk ncoarsecontrolfinetuning figure an overview of the proposed approach.
.
approach overview based on the collected insights in the exploratory study section we propose an interactive approach named smartcommit to addressing the target problem.
initially without the developer s involvement smartcommit generates a decomposition as the initial suggestion which will be presented to the developer for review.
the developer then can perform coarse control andfine tuning see figure to quickly adjust it towards the accepted decomposition .
as a result the decomposition generated by the algorithm offers a good start to save manual effort whereas adjustment operations i.e.
coarse control and fine tuning improves flexibility of our approach as well as trustworthiness of the final result.
specifically smartcommit takes the changed files in a developer s workspace as input and forms the accepted decomposition through consecutive stages as shown in figure .
in a preprocessing stage changes contained in the changed files are retrieved and structured as a set of diff hunks .
in the subsequent graph construction stage a diff hunk graph cf.
definition .
is constructed which models a series of explicit and implicit links between diff hunks.
in the next interactive decomposition stage first an edge shrinking algorithm is used to partition the diff hunk graph into a set of sub graphs each of which represents a group of closely related diff hunks as the initial decomposition.
the developer can review the decomposition to determine whether to adjust it or not.
in particular via coarse control the developer can adjust the parameter of the partition algorithm which will lead to an updated decomposition at a different granularity until it is close enough to the expectation and via fine tuning the developer can directly move diff hunks between change groups to further refine it accurately.
in the final commit submission stage the developer selects all or a sub set of change groups writes commit messages and submits them as a sequence of separate commits.
next we will explain each of these stages in detail.
.
preprocessing the preprocessing stage targets at collecting the internal and context information for code changes and representing them in the form of diff hunks .
in our approach we treat diff hunk as the basic unit to organize code changes.
intuitively a diff hunk is a combination of the textual diff with involved syntactic code elements abstract syntax subtree s .
a diffhunk is represented as a tuple h file index index change type base hunk current hunk a pair of hunks namely base hunk and current hunk corresponds to the version before and after the change respectively.
the combination of file index andindex indicates its location in the changeset and also serves as an unique identifier of a diff hunk .
.
graph construction we design a graph representation named diff hunk graph for later decomposition which is defined as follows definition .
diff hunk graph .
a diff hunk graph is a labeled weighted and directed graphg v e w t where vis the vertex set each element of which represents a diff hunk in the changeset with a unique id file index index .
e source target type source target v v source target type t is the edge set.
each element in estands for a specific link between two diff hunks.
w e is the function that maps each element in e to a weight value which denotes the strength of the link.
t depend refactor similar proximate reformat cleanup moving non code is the set of link types currently supported which is amenable to be extended.
edges in this graph represent relational links between diff hunks identified from code changes that suggest two changes may result from the same development activity.
currently we consider categories of link hard links represent syntactic and semantic constraints between ast nodes covered by diff hunks where code in a diff hunk explicitly or implicitly depends on code in others.
to detect such links we first build a graph that combines the ast data dependency and call graph from the base and current versions of all changed files respectively then locate all nodes covered by diff hunks.
if two diff hunks contain nodes with direct hierarchical relation or dependency then adirect dependency link will be added if they contain nodes with multi hop dependency then an indirect dependency link will be added.
soft links represent heuristic factors like similarity and proximity of diff hunks to associate repetitive change patterns and spatially related changes.
our approach compares eachsmartcommit a graph based interactive assistant for activity oriented commits esec fse august athens greece pair of diff hunks to measure the similarity textually and syntactically and the proximity according to the syntactic hierarchy of their covered nodes.
refactoring links represent multiple edits in different locations that likely originate from the same refactoring e.g.
renaming a method and all corresponding calls to it.
we first detect all refactored nodes in the whole changeset then connect the involved diff hunks.
cosmetic links relate diff hunks that are cosmetic changes in nature i.e.
they do not affect the program semantics such as reformatting fixing typos in comments or cleaning up comments.
we detect such links by comparing the snippet and covered nodes of the base hunk and current hunk.
each link has a weight to indicate the relative confidence that two linked diff hunks should be committed together.
for the direct dependency in hard links the weight is assigned a maximum value of .
to indicate that if such links exist the source and target vertex should almost certainly be committed together but the developer can still override the decision with adjustments .
for other links indirect dependency similarity proximity etc.
we assign lower weights based on a measure that is specific to the kind of link.
for example the weight of indirect dependency is the reciprocal of the hop number of the shortest path between all nodes covered by two diff hunks the similarity is with the average of textual similarity of code snippets and tree similarity of covered syntax tree nodes and the proximity is the reciprocal of the maximal hop number from the covered nodes to their common ancestor node see supplementary data repository for detailed calculation rules .
different from previous works our approach does not depend on particular heuristic rules or features although it does cover common heuristics in previous works.
there are often multiple links of different types between two diff hunks and we combine the information carried by different links in a flexible and extensible way via an extensible graph representation.
it is easy to add new kinds of links through extra analyses e.g.
the evolutionary coupling and the timing information of recorded edits .
.
interactive decomposition .
.
generating the initial suggestion.
based on the concept of diff hunk graph we transform the problem of tangled changeset decomposition into a graph partitioning problem.
inspired by the multilevel graph partitioning and kruskal s algorithm we design an edge shrinking algorithm see algorithm to partition the diff hunk graph based on edges which encode relations for decomposition.
the main steps of this algorithm are described as follows.
initially the algorithm creates an empty priority queue qand a map representing a disjoint set s which initializes single vertex partition i.e.
each element in sis a group consisting of exactly one vertex connected with itself .
then each edge u v type in the graph is added into the priority queue as a triple wt u v where the priority of an edge is determined by the weight of the edge wt w u v type first descending the source vertex id unext ascending and the target vertex id vlast ascending .
after that the algorithm enters a loop where the edge with the highest priority inqis popped out in each iteration.
if the edge s two endpoints are already in the same group the loop will continue to the nextiteration.
otherwise if the edge s weight is above a threshold .
by default tuned through experiments on real composite commits in the exploratory study the two groups that respectively contains the edge s two endpoints will be merged via the union find algorithm.
if the edge s weight is under the threshold or there are no edges left in q the loop will break then we traverse sto generate groups from connected subsets.
in the last if there exist groups still with only one original vertex these groups will be merged into one gathering the isolated vertices that stand for trivial changes.
a set of groups will be generated from the connected subsets of s as the initial suggested decomposition for the tangled changeset.
algorithm edge shrinking graph partitioning input g v e w t the diff hunk graph of a changeset w the edge filtering threshold output a suggested decomposition d 1function partition g w 2q priorityqueue s u u u v foreache u v type edo 4q.add w e u v end whileqnot empty do 7wt u v q.pop the edge with the highest priority ifwt wthen break already in the same group then skip iffind u find v then continue iffind u u find v vthen bothuandvare in single vertex groups s v wt group them with confidence wt else union u v s union the groups that contains uandv end end 18d generategroups s get connected subsets as groups returnd 20end 21function generategroups s 22d set trivial foreachu v wt sdo ifu vthen trivial .add u collect still isolated vertices else merge the groups that contains uandv merge getgroup d u getgroup d v end end d.add trivial append the group consisting of all trivial changes return d 33end figure shows an example of diff hunk graph to illustrate how the algorithm works.
each vertex in the graph represents a diff hunk with its idas the label.
each edge represents the link with the maximum weight value between a pair of diff hunks other links are hidden for simplification .
at the beginning of the algorithm all edges are added into a priority queue in the form of weight source index target index .
in each iteration of the loop the edge with the largest weight value and the smallest id is popped out from the queue and the source and target vertices will be put into one group if the weight is above the threshold and the two vertices do not belong to the same group yet.
the algorithm terminates when there are no unvisited edges with a weight value above the threshold.
finally it partitions the vertices into groups each of which is expected to correspond to an activity e.g.
feature addition refactoring adding test and reformatting .esec fse august athens greece bo shen wei zhang christian k stner haiyan zhao zhao wei guangtai liang and zhi jin hardlinkscosmetic linkssoftlinksrefactoring linkssimilar .7reformat .4thresholddepend .0similar .35proximate .33similar .4depend .0depend .0depend .5depend .
reformat .85depend .0similar .8moving .25proximate .5extract .0proximate .
.
.
.
.
.
.
.
.
.
.712345678910orderofedgesarevisited3 .
.
... figure a simplified example of diff hunk graph .
the vertices are decomposed into groups.
numbers on vertices denote the file index diff hunk index while numbers besides edges indicate the order they are visited.
.
.
interacting with the developer.
the initial suggestion will be presented through a graphical user interface with which the developer can review and adjust the suggested decomposition.
corresponding to figure we design two kinds of adjustment operation coarse control andfine tuning coarse control is an operation that regenerates a suggested decomposition at different granularity by assigning a new value to the threshold wthat controls the shrinking criteria of edges and the stop criteria of the decomposition algorithm.
fine tuning is an operation through which the developer can manually move diff hunks across groups or move a group to change its order.
we consider the above interacting mechanism as important as the decomposition algorithm for two reasons.
first the algorithm makes use of the feedback from the developer to quickly reach a better state that requires no or minimal extra manual effort and can greatly save manual effort to follow the best practice of activity oriented commits.
second considering that the code submission is essentially a human computer interaction process choosing changes to stage and writing descriptions the interaction can be seamlessly embedded in developers normal workflow with the additional benefits of greatly improving the credibility and reliability of our approach.
.
commits submission the last stage is to submit the groups as a list of consecutive commits appended in the version history.
when the developer is ready to commit they should select part or all of the generated groups complete the corresponding messages and submit them with one single click.
in this stage smartcommit will perform two steps correctly reorder the groups by default diff hunks with directed dependency are kept in the same group to avoid commits with compilation errors.
however this property can be broken by developers unconsciously or on purpose e.g.
for stacked pull requests6 .
therefore before submission the selected groups are reordered by the topological order of their vertices in the diff hunk graph to make sure the diff that is depended on by others is committed before or with its dependents.
if this criterion cannot be satisfied an error will be reported for further fine tuning.
incrementally apply the changes since all diff hunks are computed upon the original head commit the last commit before all submission but it moves forward as groups are committed so the changes cannot be applied directly.
we solve this problem with incremental patch which includes changes in the to be submitted group and all changes in the previously submitted groups so as to be applied on the originalhead version to get a correct workspace for submission.
evaluation we implement smartcommit as an open source tool see figure which works either as a standalone software a plugin in intellij idea or as a customized git sub command git sc .
the source code with about lines of java code is available on github.7in the implementation we extract the hierarchical and dependency relations with eclipse jdtparser8and symbol resolver and detect refactoring with the state of the art tool refactoringminer .
we adopt parallelization and cache diff hunk graph in memory to quickly respond to coarse control.
smartcommit takes the working directory of a git repository as input and presents the suggested decomposition as a list of groups which can be adjusted in two ways change the threshold with the sliding bar on the left side to coarsely change the granularity and drag drop specific diff hunks for fine tuning.
when ready to commit the user can select one or several groups with the check marks in green background complete the commit message and then click the commit button at the top right corner to trigger the submission.
.
research questions the goal of our approach is to quickly reach a good initial decomposition which the developer then can refine without too much effort.
hence we evaluate accuracy of the initial decomposition interactivity performance and usefulness with research questions rq1 accuracy what is the accuracy of initial decomposition suggested by smartcommit ?
rq2 interactivity are the manual effort to adjust the suggested decomposition acceptable for developers?
rq3 performance what about the performance and how does it change with different input sizes?
rq4 usefulness issmartcommit useful for developers to follow the best practice?
.
research design we conducted the evaluation with mixed methods research andtriangulate results from two complementary studies conducted in parallel a field study in which we observed software engineers in an international it company use smartcommit for months and interviewed a subset of them and an experiment without human subjects in a controlled setting of synthetic composite commits from well known open source projects from a graph based interactive assistant for activity oriented commits esec fse august athens greece figure a screenshot of the gui of smartcommit .
various domains.
by mixing both qualitative and quantitative evaluations in the field and in controlled settings we triangulate between evaluations in different settings and environments to gain more confidence in the conclusion .
in particular the two studies exhibit the traditional tradeoff between internal and external validity .
the field study was performed within the realism of an industrial setting when developers perform their daily tasks but this realism supporting external validity comes at the cost of limited control threatening internal validity .
in contrast the open source experiment was highly controlled and allows us to evaluate the approach under various experimental conditions on an extensive dataset supporting internal validity but these tangled changesets were generated synthetically to provide a reliable ground truth threatening external validity .
taken together triangulating results from the two studies increases confidence that our conclusions are not simply accidental due to a weakness in one specific study design.
.
.
industrial field study.
we conducted our field study in a large international it company from to .
a total of experienced software engineers from two product teams were involved the first team included developers working on a music application for android project a and the second team comprised developers working on a general cloud computing platform project b .
all participants have more than years of programming experience with java and write code in intellij idea .
correspondingly we deployed smartcommit as a plugin.
we conducted a quick start training course through an online conference about the best practice of activity oriented commits and the usage instructions of smartcommit .
although we initially recommended these engineers to use smartcommit for every commit we did not intervene in their daily work they were free to choose any other existing tools to submit commits like git commands or the built in git support in idea .
if they chose to use smartcommit this tool would analyze changes in the local workspace and open a web based gui similar to figure when the analysis was done.
from startup to exit smartcommitcollected the following telemetry data for further analysis the meta information e.g.
timestamp user id repository name the change information e.g.
number of changed files and lines of code the decomposition information i.e.
the initial suggestion and the final commits and interactive operations.
after the end of the field study we conducted a focus group session to collect comments and feedback from users.
specifically we recruited the top active users by usage frequency from each team active users and users who just tried a few less than times inactive users from project a and from project b .
the online meeting with all participants was started by one of the researchers with warm up questions about the pros and cons of smartcommit which laid the foundation for further discussions.
during the discussion another researcher was responsible for recording the responses and discussions.
after the meeting researchers worked together to analyze the collected information using inductive thematic analysis .
.
.
controlled open source experiment.
the main challenge of a controlled study that evaluates the accuracy of smartcommit is to establish the ground truth decomposition for a large set of diverse composite commits.
unfortunately we are not aware of any existing validated dataset and it will also open doors for many forms of bias if asking experienced developers to decompose commits or contacting commit authors for the ground truth.9therefore we adopted an approach that synthesizes composite commits from existing individual commits in this way these individual commits provide the ground truth decomposition.
the key idea inspired by past research is to artificially simulate a composite commit by merging multiple consecutive noncomposite commits of the same author from the version history.
that is we merged code where a developer actually split work 9we did try the latter approach but discarded it for two reasons given a commit determining whether it is composite is challenging especially for project outsiders due to the complexity of studied projects manually decomposing suspected composite commits could bias the ground truth especially when the changeset is large.
we also built an online platform and contacted authors of suspected composite commits to validate the decomposition but the response rate was too low for rigorous analysis.esec fse august athens greece bo shen wei zhang christian k stner haiyan zhao zhao wei guangtai liang and zhi jin table studied projects project field stars total atomic rocketmq messaging and streaming .1k nomulus domain name registry .4k glide image loading library 29k antlr4 parser generator .7k storm realtime computation .1k realm java mobile database .9k netty web application .5k cassandra partitioned row store .1k deeplearning4j deep learning .8k elasticsearch search engine .7k the last three columns represent the number of stargazers stars the number of all commits total and atomic commits atomic collected on the master or main branch until feb. .
into multiple commits to simulate a setting where they did not.
specifically we generated synthetic composite commits from open source projects by merging or consecutive noncomposite commits.
we picked these numbers to mirror the normal size and number of activities observed in real composite commits and these numbers are also consistent with finally submitted groups in our later statistics for the field study results.
then we decomposed the tangled changeset in each synthetic composite commit with smartcommit and compared suggested decomposition with original commits to measure the accuracy as well as the distance in terms of the minimal number of fine grained operations to get from the suggested decomposition to the ground truth.
select studied projects.
to select representative and diverse sample projects we first searched for projects with java as the main language on github and ranked them by the number of stargazers.
then we chose projects that are popular with at least stargazers mature with at least commits and well known in their domains.
the selected projects are listed in table .
collect atomic commits.
to generate synthetic composite commits we first needed to identify atomic non composite commits as inputs.
according to common characteristics of composite commits from previous works and our manual validation on sample commits from studied projects we considered a commit as non composite if its commit message did not satisfy any of the following criteria