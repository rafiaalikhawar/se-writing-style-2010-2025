improving test case generation for rest apis through hierarchical clustering dimitri stallenberg delft university of technology delft the netherlands d.m.stallenberg tudelft.nlmitchell olsthoorn delft university of technology delft the netherlands m.j.g.olsthoorn tudelft.nlannibale panichella delft university of technology delft the netherlands a.panichella tudelft.nl abstract with the ever increasing use of web apis in modernday applications it is becoming more important to test the system as a whole.
in the last decade tools and approaches have beenproposed to automate the creation of system level test casesfor these apis using evolutionary algorithms eas .
one of thelimiting factors of eas is that the genetic operators crossover andmutation are fully randomized potentially breaking promisingpatterns in the sequences of api requests discovered duringthe search.
breaking these patterns has a negative impact onthe effectiveness of the test case generation process.
to addressthis limitation this paper proposes a new approach that usesagglomerative hierarchical clustering ahc to infer a linkagetree model which captures replicates and preserves thesepatterns in new test cases.
we evaluate our approach called lt mosa by performing an empirical study on real world benchmark applications w.r.t.
branch coverage and real fault detection capability.
we also compare lt mosa with the two existing state of the art white box techniques mio mosa for rest api testing.
our results show that lt mosa achieves a statistically significant increase in test target coverage i.e.
lines and branches compared to mio and mosa in and out of applications respectively.
furthermore lt mosa discovers and unique real faults that are left undetected by mio and mosa r espectively.
index t erms system level testing test case generation machine learning search based software engineering i. i ntroduction over the last decade the software landscape has been characterized by the shift from large monolithic applications to component based systems such as microservices.
thesesystems together with their many diverse client applications make heavy use of web apis for communication.
web apisare almost ubiquitous today and rely on well establishedcommunication standards such as soap and rest .the shift towards component based systems makes it ever increasingly more important to test the system as a whole sincemany different components have to work together.
manuallywriting system level test cases is however time consumingand error prone .
for these reasons researchers have come up with different techniques to automate the generation of test cases.
oneclass of such techniques is search based software testing.recent advances have shown that search based approachescan achieve a high code coverage also compared tomanually written test cases and are able to detect unknownbugs .
search based test case generation useslisting motivating example of patterns in api requests.
1post authenticate?user admin password pwd 2post product?id price .
token key 3update product ?price .
token key 4get product ?token key evolutionary algorithms eas to evolve a pool of test casesthrough randomized genetic operators namely mutations and crossover recombination.
more precisely test cases are en coded as chromosomes while statements i.e.
method calls and test data are encoded as the genes .
in the contextof rest api testing a test case is a sequence of apirequests i.e.
http requests and sql commands on specific resources .
representational state transfer rest apis deal with states.
each individual request changes the state of the api and therefore its execution result depends on the state of theapplication i.e.
the previously executed requests .
listing shows an example of http requests made to a rest apithat manages products.
in the example the first request authenticates the client to the api with the given username andpassword.
in return the client receives a token that can be used to make subsequent requests.
the second requestcreates a new product by specifying the id price and the token.
the price is then updated in the third request and the changes are retrieved in the last request.
the example above contains patterns of http requests that strongly depend on the previous ones.
the get request can not retrieve a product that does not exist and therefore cannot be successfully executed without request .
similarly theupdate request can not be executed before the product is created.
lastly request and all depend on request 1for the authentication token.
hence http requests should notbe executed in any random order .
test generation tools rely on eas to build up sequences of http requests iteratively through genetic operators i.e.
crossover and mutation .
while these opera tors can successfully create promising sequences of httprequests they do not directly recognize and preserve themwhen creating new test cases .
for example the geneticoperators may remove request from the test case in listing breaking requests and unintentionally.
in this paper we argue that detecting and preserving patterns 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee of http requests hereafter referred to as linkage structures improves the effectiveness of the test case generation process.
we propose a new approach that uses agglomerative hierar chical clustering ahc to infer these linkage structures fromautomatically generated test cases in the context of restapis testing.
in particular ahc generates a linkage tree l t model from the test cases that are the closest to reachuncovered test targets i.e.
lines and branches .
this model is used by the genetic operators to determine which sequencesof http requests should not be broken up and should bereplicated in new tests.
to evaluate the feasibility and effectiveness of our approach we implemented a prototype based on e vomaster the stateof the art test case generation tool for java based rest apis.we performed an empirical study with 7benchmark web enterprise applications from the e vomaster benchmark emb dataset.
we compared our approach against the two state of the art algorithms for system level test generations imple mented in e vomaster namely many independent objective mio and many objective search algorithm mosa .
our results show that lt mosa covers signi ficantly more test targets in and out of the applications comparedto mio and mosa respectively.
on average lt mosa covered11.
more test targets than mio with a max improvement of .
and8.
more than mosa with a max improvement of .
.
furthermore lt mosa could detect on average 27and18unique real faults that were not detected by mio and mosa respectively.
in summary we make the following contributions a novel approach that uses agglomerative hierarchical clustering to learn and preserve linkage structures embedded in rest api.
an empirical evaluation of the proposed approach with the two state of the art algorithms mio and mosa on a benchmark of 7web enterprise applications.
a full replication package including code and results .
the remainder of this paper is organized as follows.
section ii summarizes the related work and background concepts.
section iii introduces our approach called lt mosa and gives a detailed breakdown of how it works.
section ivdescribes the setup of our empirical study.
section v discussesthe obtained results and presents our findings.
section vidiscusses the threats to validity and section vii draws con clusions and identifies possible directions for future work.
ii.
b ackground and rela ted work this section provides an overview of basic concepts and related work in search based software testing rest apitesting test case generation and linkage learning.
a. search based software testing search based software testing has become a widely used and effective method of automating the generation of test cases and test data .
automatic test case generationsignificantly reduces the time needed for testing and debuggingapplications e.g.
and it has been successfully used in industry e.g.
.
popular tools for automatically generating test cases include evosuite for unit testing and sapienz for android testing.
evolutionary algorithms eas are one of the most commonly used class of meta heuristics in search based testing.eas have been used to generate both test data and testcases .
the latter includes test data method sequencesand assertions.
eas are inspired by the biological processof evolution.
it initializes and evolves a population of ran domly generated individuals test cases .
these individualsare then evaluated based on a predefined fitness function.the individuals with the best fitness value are selected for reproduction through crossovers swapping elements between two individuals and random mutations small changes to individuals .
the offspring test cases resulting from the repro duction are then evaluated.
finally the population for the next generation is created by selecting the best individuals acrossthe previous population and the newly generated tests elitism .this loop reproduction evaluation and selection continuesuntil a stopping condition has been reached.
the final test suiteis created based on the population s best individuals.
b. rest api testing a representational state transfer rest api is oriented around resources.
this differs from a command oriented api like for example the remote procedure call rpc standard.
arest api request performs an action on a specific resource.these actions are encoded by the different methods defined inthe http protocol.
common http methods include get head post put patch and delete.
these actions are performed on an endpoint which is the location of theresource.
an example of this would be performing a get action on the user endpoint to retrieve the information of a user with a user id of .
another example would beperforming a post action on the user endpoint to create a new user.
with the recent rise in popularity of rest apis in the last decade it is becoming more important to test this criticalcommunication layer.
there are two different ways system level api testing can be approached black box and white box testing.
black box testing frameworks e.g.
resttest gen evomaster black box examine the functional ity of the system without looking at the internals of the system.
in contrast white box testing approaches rely on the internal structure of the system and measure the adequacy of the testsbased on coverage criteria e.g.
branch coverage .
this allows the algorithm to easily identify which paths have been coveredand which have not.
prior studies show white box techniquesachieve better results than their black box counterparts .additionally white box techniques allow to integrate sqldatabases in the test case generation process .
c. test case generation for rest apis e vomaster is a tool that aims to generate system level test cases for rest apis.
it internally uses evolutionary 118algorithms to evolve the test cases iteratively.
at the time of writing e vomaster provides two eas.
the first algorithm is the many independent objective mio algorithm proposedby arcuri et al.
.
the second algorithm is a variant of the many objective sorting algorithm mosa proposed bypanichella et al.
.
both of these algorithms are specifically designed for test case generation and consider the peculiaritiesof these systems.
the pseudo code of these algorithms can befound in the respective papers.
mio the many independent objective mio algorithm is an evolutionary algorithm that aims to improve thescalability of many objective search algorithms for programswith a very large number of testing targets in the orderof millions .
it works under the assumption that i each target can be independently optimized ii targets canbe strongly related for example when nested or completelyindependent iii not all targets can be covered.
based onthese assumptions mio maintains a separate population foreach target of the system under test sut .
the fitnessfunction for each population consists solely of the objectiveof that population.
so each population compares and ranksthe individuals based on a single testing target.
at the startof the algorithm all populations are empty.
each iteration the algorithm either samples a random new test case witha certain probability or it samples a test case from one ofthe populations with an uncovered target.
this test case isthen added to all populations with an uncovered target andevaluated independently.
the population that is chosen whena test case is sampled from one of the populations is basedon the number of times a test case has been sampled fromthat population before.
each time a population is sampled acounter is incremented.
if a test case with a better fitness valueis added to the population the counter is reset to zero.
thesampling mechanism chooses the population with the lowestcounter.
this makes sure that the algorithm won t get stuckon an unreachable target.
when a population reaches a certainpredefined size it removes the test case with the worst fitnessvalue.
at the end of the algorithm a test suite is built withthe best test case from each population.
mosa the many objective sorting algorithm mosa is an evolutionary algorithm that focuses on optimiz ing multiple objectives e.g.
branches at the same time .
it adapts the nsga ii algorithm which is one of the mostpopular multi objective search algorithms .
in mosa a test case is represented as a chromosome.
each testing target e.g.
branch line in the code corresponds to a separate objective measuring the distance of a given test toward reachingthat target.
the fitness of the test cases is measured accordingto a vector of scalar values that represent these differentobjectives.
since mosa has many dif ferent objectives it uses two preference criteria to determine which test casesshould be selected and evolved first i minimal distance to theuncovered target ii test case length.
more precisely it firstlooks for the subset of the pareto front that contains test caseswith a minimum distance for each uncovered objective.
whenmultiple test cases are equally close to cover the same target the smallest test case will be selected.
in each generation anarchive collects the test cases that cover previously uncoveredtargets.
the archive is updated every time a newly generatedtest case covers new targets or covers already covered targetsbut with fewer statements.
comparison both mio and mosa produce good results in both unit and system level tests.
in the context ofsystem level testing arcuri showed that mio achievesthe best average results but there are web enterprise appli cations in which mosa achieves higher coverage.
in unit testing campos et al.
showed that mosa and its variants achieves overall better coverage than mio.
therefore inthis paper we consider both mio and mosa as they e xcel in different scenarios and are the state of the art in test casegeneration for rest apis.
notice that an extension of mosa called dynamosa has been proposed in the related literaturefor unit testing.
compared to mosa dynamosa organizes the coverage targets e.g.
branches of a given code unit into a global hierarchy based on their structural dependencies.
then the list of search objectives is updated dynamically basedon their structural dependencies and the previously coveredtargets.
while previous studies in unit testing showed thatdynamosa outperforms its predecessor mosa it cannot be applied for rest apis as no global hierarchyexists across the coverage targets of different microservicesor functions classes within the same microservice .
chromosome representation test cases in both search algorithms included in e vomaster are represented by two genes action gene and input gene.
the action gene representsthe structure and order of the http requests in the test case.
e vomaster extracts these actions from the swagger openapi documentation that has to be provided for each systemunder test.
an action gene consists of the http method andthe rest endpoint.
an example of an action gene would be post authentication .
the input gene represents the input data for the http request.
an example of this input data would be the usernameand password that are required by the authentication endpoint.
this input data is sampled from the source code ofthe sut.
d. linkage learning in eas linkage learning refers to a large body of work in the evolutionary computation community that aims to infer linkage structures present in promising individuals .
linkage structures are groups of good genes that contribute to the fitness of a given population.
accurate inference of linkage structures has been used to design competent genetic operators fornumerical problems.
these operators are designed to replicaterather than break groups of genes patterns into the offspring.
to learn linkage structures from numerical chromosomes researchers have used different unsupervised machine learningalgorithms.
boa constructs a bayesian network and 1micro services are loosely coupled and deployable independently.
119creates new numerical chromosomes using the joint distribution encoded by the network.
dsmga uses dependencystructure matrix dsm clustering and applies the crossoverby exchanging gene clusters between parent chromosomes.3lo employs local optimization as an alternative methodfor linkage learning.
two state of the art eas for numerical problems are l t ga and gomea .
both algorithms use clustering toinfer linkage trees representing the linkage structures betweengenes problem variables using tree like structures.
gomeauses agglomerative hierarchical clustering as a faster and moreefficient way to learn linkage trees .
gomea uses thegene pool optimal mixing to create new solutions by applying a local search within the recombination procedure.
moreprecisely it creates offspring solutions from one single parentby iteratively replicating copying gene clusters from differentdonors.
in each iteration the new solution is evaluated if itsfitness improves the replicated genes are kept otherwise thechange is reverted.
linkage models have been successfully applied to evolutionary algorithms for numerical permutation andbinary optimization problems with fixed lengthchromosomes.
however test cases for rest apis are char acterized by a more complex structure each test is asequence of http requests towards a restful service eachwith input data such as http headers url parameters andpayloads for post put patch methods.
besides a test case might include sql data and commands for microservices thatuse databases .
finally test cases have a variable size and their lengths can also vary throughout the generations.therefore we need to tailor existing linkage learning methods according to the test case characteristics discussed above.
iii.
a pproach this section presents our approach called lt mosa for system level test cases generation and that incorporates andtailors linkage learning into mosa .
we selected mosa as the base algorithm to apply linkage learning because itevolves a single population of test cases which is a require ment for the learning process.
additionally mosa has been proved to be very competitive in the context of restful apitesting unit testing and dnn testing .
algorithm outlines the pseudo code of lt mosa.
the parts where lt mosa de viates from mosa are highlighted with a blue color.
lt mosa starts with initializing the populationpand computing the corresponding objective scores line .
each test case is composed of http calls actions and sql commands database actions .
the random popula tion function also executes the generated tests andcomputes their objective scores using the branch distance .
the branch distance is a well known heuristic in search based testing to measure how far each test case is from reaching agiven coverage target e.g.
branch .
then the test cases are sorted in sub dominance fronts using the preference sorting algorithm in line .
the test cases within the first front front are the closest ones in pto reach the coveragealgorithm l t mosa input coverage targets 1 ... n population size m frequency kfor updating the linkage tree model result a test suite t 1begin 2p random popula tion m archive upda te archive p fronts preference sorting r while not stop condition do l learn linkage model fronts k p prime for index ..m do parent tournament selection p ifapply recombination then donor tournament selection p offspring linkage recomb parent donor l offspring mut a tion offspring else offspring mut a tion parent p prime p prime uniontext offspring archive upda te archive archive offspring r p uniontextp prime fronts preference sorting r p environment al selection fronts m 21t archive targets and therefore the fittest individuals to consider for model learning.
afterwards the population pis evolved through subsequent generations within the loop in lines .
each generationstarts by training a linkage tree model on the first nondominated front line with the goal of learning patterns ofhttp and sql actions that strongly contribute to the opti mality of the population.
we discuss the learning procedure indetail in section iii a. once the linkage tree model is obtained l t mosa selects the fittest test cases using the tournament selection line and and creates an offspring population p primeby using a linkage based recombination line and mutation line and .
the linkage based recombination is a specialized crossover that relies on the linkage tree model to decide which patterns of genes http requests can be copied into the offspring test cases.
we describe thelinkage based recombination operator in section iii b. l t mosa adds the newly generated tests into the offspring population line executes them and updates the archive line in case new coverage targets have been reached.
thegeneration ends by selecting the best m test cases across the existing population pand the offspring population p prime.
this selection is made by combining the two population into onesingle pool rof size2 m line applying the preference sorting line and selecting m solutions from the nondominated fronts starting from front until reaching thepopulation size m line .
the search stops when the termination criteria are met condition in line the final test suite will then be composedof all test cases that have been stored in the archive throughout 120the search.
note that lt mosa updates the archive in each generation by storing the shortest test case covering each target i. finally the list of objectives is updated such that the search focuses only on the targets branches that are left uncovered.
in the following sub sections we detail the key novel ingredients in lt mosa namely the linkage model learning l t section iii a the linkage based recombination operator section iii b and the mutation operator section iii c .
a. linkage tree learning in this section we describe the main changes we applied to the traditional linkage learning and adapt it to our context i.e.
test case generation for restful apis.
linkage encoding the first problem we had to solve is encoding the test cases into discrete vectors of equallength which can be interpreted and analyzed via hierarchicalclustering.
to this aim we opted for encoding test cases as binary vectors whose entries denote the presence or not of the possible http requests.
given an sut softwareunder tests there are n possible http requests to the available apis.
this information can be extracted from theswagger openapi definition which is a widely used toolfor rest api documentation.
a swagger definition containsthe http operations available for each api endpoint.
eachoperation contains both fixed and variable parts.
the fixed partincludes the type of operation post get put patch and delete the ip address or the url of the target api and the http headers.
for the variable part the swagger definitionincludes information about the input data e.g.
string double date etc.
that can vary.
therefore for each api endpoint weidentify the available http operations hereafter referred toasactions by parsing the swagger definition.
lets s ... s n be the set of nhttp actions available for the target sut.
we encode each test case tas a binary string of size nas follows e t angbracketlefte1 ... e n angbracketrightwith e i braceleftbigg 0if s i t 1if s i t in other words each element eiin the encoded vector e t is set to if the test case tcontains the actionsi otherwise.
the linkage model is trained on the binary coded vectorsrather than on the original test cases.
this encoding is usedto determine via statistical analysis which group of httpactions often appear together within the fittest test cases and which ones never occur together.
this information is used tocreate more efficient recombination operators.
linkage model training in this paper we use agglomerative hierarchical clustering ahc over other techniques e.g.
bayesian networks for linkage tree learning.
this is becauseprior studies show ahc is more efficient .
in particular we apply the upgma unweighted pair group method witharithmetic mean algorithm .
in each iteration upgmamerges two clusters that are most similar based on the averagedistance across the data points genes in our case in the twoclusters.
the similarity between two http actions genes s is1 s2s3 s4...s1 s2 s3 s4s3 s4 ...s1 s2 s3 s4 ...distance fig.
example of linkage tree model and the family of subset fos andsjis computed using the mutual information as suggested by thierens and bosman mi si sj h si h sj h si sj whereh .
denotes the information entropy .
note that lt mosa infers the linkage tree for the most promising part of the population i.e.
the first non dominated front line in algorithm .
furthermore the training process is applied to the encoded test cases according to the schemadescribed in section iii a1 rather than on the actual test cases.hence the linkage tree obtained with upgma captures the hierarchical relationship between http actions in our case.
for example let us consider the linkage tree depicted in fig.
.
in the example the set of actions s s s2 s3 s4 ... the root of the tree are partitioned into two clusters s1 s2ands3 s4 ... each sub cluster can be further divided in sub cluster until reaching the leaf node.
ingeneral the linkage tree has n leaves and n 1internal nodes.
the root node contains all http actions of the sut.each internal node divides the set of http actions intotwo mutually exclusive clusters the child nodes .
finally theleaves contain the individual http actions which are thestarting point of the upgma algorithm.
the linkage tree nodes are often referred to as family of subsets f in the related literature .
each node or subset f prime f with f has two mutually exclusive subsets or child nodes fxandfysuch that fx intersectiontextfy andfx uniontextfy f prime.
each subset f prime f represents a cluster of http actions that often appear together and characterized thebest test cases in the population.
therefore the recombinationoperator should be applied by preserving these subsets pat terns when creating new offspring tests.
the next subsectiondescribes the subsets preserving recombination operator weimplemented in lt mosa.
the computation complexity of upgma is o n m wherenis the number of genes and m is the population size.
to reduce its overhead the linkage tree learning procedure isnot applied in each generation.
instead the linkage tree modelis re trained every kgenerations line of algorithm .
121b.
linkage based recombination mosa creates offspring tests using the single point crossover .
this crossover operator is the classic recombination operator used in genetic algorithms and test case generation .
this operator generates two offsprings by randomly swapping statements between two parent tests t1 andt2.
as argued in section i exchanging statements between test cases in a randomized manner can lead to breaking genepatterns http actions that characterized the fittest indi viduals.
randomized recombination is also disruptive towardbuilding good partial solutions building blocks negativelyaffecting the overall convergence .
therefore lt mosa uses a linkage based recombination operator rather than the classical single point crossover to preserve the patterns of http actions identified by the linkagetree model.
the recombination operator generates only one offspring starting from two existing test cases called parent and donor.
both test cases are selected from the current population pas indicated in lines and .
the offspring is created by copying all genes http actions with input data from the parent and further injecting only some genes from thedonor.
these genes are selected by exploiting the linkage tree model trained according to section iii a. more precisely we first identify the gene patterns i.e.
the subsetsf prime f that the donor contains.
this is done by iterating across all subsets in the linkage tree model fand identifying the subsets f prime f that appear in the encoded vector see section iii a1 of the donor.
l t mosa randomly selects one of the identified subsets in f primeand inserts it into the offspring.
the injection point is randomly chosen and the selected genes http actions with test data are inserted intothe offspring in the exact order as they appear in the donor.
if the donor does not contain any subset according to the linkage tree i.e.
f prime then the offspring is generated by applying the traditional single point crossover.
this operator can be applied to the latter case since the linkage tree model could not identify any useful gene pattern within the donor.
c. mutation in mosa each test case is mutated with a probability pm l where lis the test case length .
this also reflects the existing guidelines in evolutionary compu tation which suggest using a mutation probabilityp mproportional to the size of the chromosome.
in recent years arcuri improved the mutation operator in the context of system level test case generation by usinga variable mutation rate.
indeed the mutation operator in mio increases the number of mutations applied to each test case from start of the search up to end ofthe search with linear incremental steps.
the importance ofhaving a large mutation rate for restful api testing has alsobeen confirmed by a recent study results .
based on these observations lt mosa uses the same mutation rate of mio i.e.
increasing mutation rate from up to mutations rather than the fixed mutation rate of mosa.iv .
e mpirical study this section details the empirical study that we carried out to evaluate the effectiveness of the proposed solution called l t mosa and compare it with the state of the art algorithms mio mosa w.r .t.
to the following testing criteria i code line and branch coverage and ii fault detection capability.
a. benchmark this study uses the e vomaster benchmark emb version .
.
.
this benchmark was specifically created asa set of web enterprise applications for evaluating the testcase generation algorithms implemented in e vomaster .w e selected this benchmark since it has been widely used in theliterature to assess test case generation approaches for restapis .
in this study we used five real world open source java web applications and two artificial java web applications.
catwatch is a metrics dashboard for github organizations.
featuresservice is a rest microservice for managing feature models of products.
ocvn open contracting vietnam is a visual data analytics platform for the vietnam public procurementdata.
proxyprint is a platform for comparing and making requests to print shops.
scout api is a restful web service for the hosted monitoring service scout .
ncs numerical case study is an artificial application containing numericalexamples.
scs string case study is an artificial application containing string manipulation code examples.
we use ncs and scs since they have been designed for assessing test generation tools.
these artificial web applications allow tocover many different scenarios e.g.
deceptive branches .compared to previous studies we added the ocvn application as it is the largest real world system in the bench mark.
we additionally removed the rest news application as it contains artifical examples that are used for classroomteaching.
table i summarizes the main characteristics of the applications in the benchmark such as the number of classes thenumber of test coverage targets and the number of endpointsincluded in the service.
this benchmark contains a total of1655 classes with around test coverage targets and endpoints not including tests or third party libraries.
e vomaster requires a test driver for the application under test.
this test driver contains a controller that is responsiblefor starting resetting and stopping the sut.
we used thetest drivers available in the emb benchmark for the webapplications used in this study.
b. research questions our empirical evaluation aims to answer the following research questions rq1 how does l t mosa perform compared to the state ofthe art approaches with regard to code coverage?
rq2 how effective is l t mosa compared to the state of theart approaches in detecting real faults?
122t able i web applications from the e vomaster benchmark emb used in the empirical study.
reports the number of java classes test coverage targets i.e.
lines and branches and the number of endpoints.
application classes coverage targets endpoints catwatch features service ncs ocvn proxyprint scout api scs total rq3 how effective is l t mosa at covering test targets over time compared to the state of the art approaches?
the first two research questions aim to evaluate if preserving patterns in http requests through linkage learning can im prove the effectiveness of test case generation for rest apis by reaching a higher coverage and detecting more faults.
the last research question aims to answer if our approach l t mosa is more efficient in covering these test targets by measuring how many test targets are covered at different timeswithin the search budget.
c. baseline to answer our research questions we compare lt mosa with the two state of the art search based test case generation algorithm for rest apis as a baseline many independent objective mio is the state of theart for rest api testing and it is the default searchalgorithm in e vomaster .
mio aims to improve the scalability of many objective search algorithms for pro grams with a very large number of testing targets seesection ii c1 .
many objective sorting algorithm mosa is the base algorithm we use to build and design lt mosa.
therefore we want to assess that our approach outperformsits predecessor.
furthermore mosa has been proven to be very competitive in the context of rest apis testing see section ii c2 .
d. prototype tool we have implemented lt mosa in a prototype tool that extends e vomaster an automated system level test case generation framework.
in particular we implemented the ap proach as described in section iii within e vomaster .
the variant of mosa implemented in e vomaster differs from the original algorithm proposed by panichella et al.
.
the e vomaster variant does not use the crossover operator but merely relies on the mutation operator to create new testcases.
therefore we implemented the single point crossover as described in and adapted it to the encoding schemaused for representing rest api requests in e vomaster .
see section ii c2 for more details.we chose e vomaster because it already implements the state of the art test case generation algorithms and it is pub licly available on github.
besides e vomaster implements testability transformations to improve the guidance for searchbased algorithms and can handle sql databases .
e. parameter setting for this study we have chosen to adopt the default search algorithm parameter values set by e vomaster .
it has been empirically shown that although parameter tuning has an impact on the effectiveness of a search algorithm thedefault values which are commonly used in literature providereasonable and acceptable results.
thus this section only listsa few of the most important search parameters and their values search budget we chose a search budget stopping condition based on time instead of the number of executedtests.
this choice was made as search time provides thefairest comparison given that we consider different kindsof algorithms with diverse internal routines also in termsof computational complexity .
additionally practitioners willoften only allocate a certain amount of time for the algorithmto run.
the search budget for all algorithms was set to 30minutes as this strikes a balance between giving the algorithmsenough time to explore the search space and making the studyinfeasible to execute.
if the algorithm has covered all its testobjectives it will stop prematurely.
note that running timeis considered a less biased stopping condition than countingthe number of executed tests since not all tests have the samerunning time .
we further discuss this aspectin the threats to validity.
mio parameters for mio we used the default settings as provided in the original paper by arcuri et al.
.
population size we use the default population size of individuals per testing target.
notice that mio usesseparate populations for the different targets.
mutation we use the default number of applied mutations on sampled individuals which linearly increasesfrom to by the end of the search.
f we use the default percentage of time after which a focused search should start of .
.
pr we use the default probability of sampling at random instead of sampling from one of the populations of .
.this value will linearly increase decrease based on theconsumed search budget and the value of f. mosa parameters for mosa we used the default settings described in the original paper et al.
.
population size individuals test cases .
mutation we use the uniform mutation which either changes the test case structures adding deleting orreplacing api requests or the input data.
test structureand test data mutation are equally probable i.e eachhas probability of being applied.
the mutationprobability for each statement data gene is equal to n wherenis the number of statements in the test case.
recombination operator we use the single point crossover with a crossover probability of .
.
selection we use the tournament selection with the default tournament size of .
l t mosa parameters for l t mosa we used the same parameters as for the mosa algorithm except for the mutation operator for which we use the mutation described in section iii c. additionally we use the following parametervalues for the linkage learning model frequency we use a frequency of generations for generating a new linkage tree model.
from a prelimi nary experiment that we have performed this provides abalance between having too much overhead and having an outdated model .
recombination operator we use the linkage based recombination with a probability of .
.
f .
real fault detection to find out the number of unique faults that the search algorithms can detect e vomaster checks the returned status codes from the http requests for 5xx server errors as an indicator for a fault.
since web applications handle manydifferent clients when an error occurs it is not desirable forthe application to crash or exit as this would also impact theother clients.
thus web applications return a status code inthe5xx range indicating an error has occurred on the server s side.
e vomaster keeps track of the last executed statement in the sut excluding third party libraries when a 5xx status code is returned to distinguish between different errors thathappen on the same endpoint.
g. experimental protocol for each web application all three search algorithms mosa mio l t mosa are s eparately executed and the resulting number of test targets that are covered is recorded.
since all three search algorithm used in the study are randomized we can expect a fair amount of variation in the results.
to mitigate this we repeated every experiment20times with a different random seed and computed the average median results.
in total we performed executions three search algorithms for seven web applications with 20repetitions each.
with each execution taking minutes thetotal execution time is .
days of consecutive running time.
to determine if the results i.e.
code coverage and fault detection capability of the three different algorithms arestatistically significant we use the unpaired wilcoxon rank sum test with a threshold of .
.
this is a non parametric statistical test that determines if two data distributions aresignificantly different.
since we have three different datadistributions one for each search algorithm we performthe wilcoxon test pairwise between each configuration pair i l t mosa and mosa ii lt mosa and mio.
w e combine this with the v argha delaney statistic to measurethe effect size of the result which determines how large thedifference between the two configuration pairs is.
to determine how the two configuration pairs compare in terms of efficiency we analyze the code coverage at differentpoints in time.
while the effectiveness measures the codet able ii median number of covered test targets.
applicationmio mosa l t mosa median iqr median iqr median iqr catw atch .
.
.
.
.
.
features service .
.
.
.
.
.
ncs .
.
.
.
.
.
ocvn .
.
.
.
.
.
proxyprint .
.
.
.
.
.
scout api .
.
.
.
.
.
scs .
.
.
.
.
.
coverage only at the end of the allocated time we alsowant to analyze how algorithms perform during the search.one way to quantify the efficiency of an algorithm is byplotting the number of test targets at predefined intervalsduring the search process.
this is called a convergence graph.we collected the number of targets that have been coveredfor every generation of each independent run.
to express theefficiency of the experimented algorithms using a single scalarvalue we computed the overall convergence rate as the areaunder the curve auc delimited by the convergence graph.this metric is normalized by dividing the auc in each runby the maximum possible auc per application .
v. r esul ts this section details the results of the empirical study with the aim of answering our research questions.
a. rq1 code coverage table ii reports the median and inter quartile range iqr of the number of test targets covered by mio mosa and l t mosa for each of the seven applications.
from table ii we observe that lt mosa achieved the highest median value avg.
.
targets for four out of the seven applications and mosa and mio both achieved the highest median value .
and .
targets respectively for out of the applications.
the largest increase in codecoverage is observable for ocvn for which lt mosa covered .
more targets.
for scs both lt mosa and mio covered the same number of targets .
.
for both artificial applications namely ncs and scs the difference between the search algorithms is minimal .
in terms of variability iqr there is no clear trend with regard to the applications under test and or the searchapproaches.
for example in some cases the winning con figuration lt mosa on catwatch has the highest iqr with a significant margin .
vs. .
or .
.
onscout api l t mosa yields the lowest iqr by a significant margin .
vs. .
or .
.
within and across each searchalgorithm the iqr varies.
table iii reports the statistical significance p value calculated by the wilcoxon test of the difference between thenumber of targets covered by lt mosa and the two baselines mio and mosa.
it also reports the magnitude of the differences according to the v argha delaney a 12statistic.
3which corresponds to the area of the box with a height of the maximum code coverage and a width equal to the search budget.
124t able iii statistical results p value and a12 for the covered test targets rq1 .
significant p values i.e.
p value .
are marked gray.
applicationlt mosa vs mio l t mosa vs mosa p v alue a12 p v alue a12 catw atch .
.
large .
.
small features service .
.
.
.
large ncs .
.
.
.
small ocvn .
.
large .
.
large proxyprint .
.
large .
.
large scout api .
.
large .
.
large scs .
.
small .
.
t able iv median number of detected real faults.
applicationmio mosa l t mosa median iqr median iqr median iqr catw atch .
.
.
.
.
.
features service .
.
.
.
.
.
ncs .
.
.
ocvn .
.
.
.
.
.
proxyprint .
.
.
.
.
.
scout api .
.
.
.
.
.
scs .
.
.
from table iii we can observe that for the non artificial web applications lt mosa achieves a significantly higher code coverage than mio in four out of five applications with alarge effect size a12statistics .
lt mosa significantly outperforms mosa in all five applications.
the effect size islarge in four applications and small forcatwatch.
for the two artificial applications ncs and scs there is no statistical difference between the results of lt mosa and the two baselines mio and mosa .
this confirms our preliminary results reported in table ii.
moreover the difference between l t mosa and mio is not significant for features service.
finally in none of the applications in our benchmark neitherof the baselines achieved a significantly larger coverage than l t mosa.
in summary lt mosa achieves significantly higher most of the cases or equal code coverage when applied to restapis as compared to both mio and mosa.
b. rq2 fault detection capability table iv reports the median number of real faults and the corresponding iqr detected by mio mosa and l t mosa for each of the seven applications.
we observe that for both the artificial applications ncs and scs the number of faults that have been detected by any search algorithm is zero.
this is because these artificialapplications are not designed to fail softly by returning 5xx faults.
for the open source applications lt mosa detects the largest number of faults avg.
.
faults in all fivecases.
the largest increase in fault detection rate is observablefor the ocvn application with .
more faults detected by l t mosa than the baselines.
it is noteworthy that thet able v statistical results p value and a for the detected real faults rq2 .
significant p values i.e.
p value .
are marked gray.
applicationlt mosa vs mio l t mosa vs mosa p v alue a12 p v alue a12 catw atch .
.
large .
.
large features service .
.
large .
.
large ncs ocvn .
.
large .
.
large proxyprint .
.
large .
.
small scout api .
.
large .
.
large scs t able vi median normalized auc for the number ofcovered test targets.
the highest values are marked in gray.
application mio mosa l t mosa catwatch .
.
.
features service .
.
.
ncs .
.
.
ocvn .
.
.
proxyprint .
.
.
scout api .
.
.
scs .
.
.
largest difference between lt mosa and the baselines is on the ocvn application which is the application with by far the most classes i.e.
and endpoints i.e.
in our benchmark.
this could be explained by the fact that l t mosa also achieved a much higher code coverage for this application.
however the difference in detected faultsfor ocvn is larger than for the other applications in the benchmark which could indicate that lt mosa is especially effective for testing large rest apis.
the faults detectedby lt mosa are a superset of the faults detected by mioand mosa.
these newly discovered faults originate from the additional coverage that lt mosa achieves.
table v reports the results of the statistical test namely the wilcoxon test applied to the number of faults detectedby l t mosa and the two baselines mio and mosa.
it also reports the magnitude of the differences if any obtainedwith the v argha delaney a statistic.
significant p values i.e.
p value .
are highlighted with gray color.
from table v we can observe that lt mosa detects a significantly higher number of faults than mio and mosa in all nonartificial applications.
the effect size a12 i s large in all comparisons except for proxyprint where the effect size is small when comparing lt mosa and mosa.
since none of the algorithms detected any faults in the artificial applications table v does not report any p value or a 12statistics for these applications.
in summary we can conclude that lt mosa detects more faults than the state of the art approaches namely mio and mosa for all applications in our benchmark.
7lph vhfrqgv 1xpehu ri ryhuhg udqfkhv6hdufk ojrulwkpv 7 026 fig.
average number of targets covered by our approach l t mosa and the baselines mosa mio for ocvn .
c. rq3 code coverage over time table vi reports the median area under the curve auc related to the number of targets covered over time by mio mosa and l t mosa for each of the seven applications.
the auc indicates how efficient the search algorithms are atreaching a certain code coverage.
for more information onhow the auc is calculated and normalized see section iv g.table vi highlights the search algorithm in gray color thatachieved the highest auc value.
we observe that for the open source applications ltmosa has the highest auc avg.
.
in four out of five applications with the largest difference .
in the ocvn application.
for catwatch both mosa and l t mosa have the same auc i.e.
.
.
from tables ii and iii however we can see that lt mosa covers significantly more targets .
after minutes of search budget.
this means that mosa reaches a higher coverage in the beginning but loses to l t mosa over time.
fig.
shows the median number of targets covered over time by the different search algorithms for ocvn which is the largest application in our benchmark.
in the beginning ofthe experiment seconds mio and lt mosa perform roughly equal.
after the first seconds lt mosa outperforms mio.
this results in a much larger auc value .
for l t mosa compared to mio as indicated in table vi.
we conclude that lt mosa significantly outperforms both mosa and mio in term of effectiveness and efficiency on this application.
to reaffirm this we can observe that in fig.
mio never reaches covered targets mosa takes seconds to reach that many targets and lt mosa performs this in just seconds almost half the time of mosa.
for the two artificial applications ncs and scs the difference in auc between the three search algorithms is veryminimal .
.
from table ii we can also see that ltmosa covers one target more than mosa on scs and one target less on ncs .
however they both yield the same auc i.e.
.
scs and .
ncs .
these results are in line withthe results from rq1.
in summary we can conclude that lt mosa achieves higher auc values than the baselines i.e.
it covers moretargets and in less time.
vi.
t hrea ts to validity this section discusses the potential threats to the validity of the study performed in this paper.
threats to construct validity.
we rely on well established metrics in software testing to compare the different test casegeneration approaches namely code coverage fault detectioncapability and running time.
as a stopping condition for thesearch we measured the search budget in terms of runningtime i.e.
minutes rather than considering the number of executed tests or http requests.
given that the differentalgorithms in the comparison use different genetic operators with different overhead execution time provides a fairermeasure of time allocation.
threats to external validity.
an important threat regards the number of web services in our benchmark.
we selected sevenweb enterprise applications from the emb benchmark.
thebenchmark has been widely used in the related literature ontesting for rest apis.
the applications are diverse in termsof size application domain and purpose.
further experimentson a larger set of web enterprise applications would increasethe confidence in the generalizability of our study.
a largerempirical evaluation is part of our future agenda.
threats to conclusion validity are related to the randomized nature of eas.
to minimize this risk we have performedeach experiment times with different random seeds.
wehave followed the best practices for running experimentswith randomized algorithms as laid out in well establishedguidelines and analyzed the possible impact of differentrandom seeds on our results.
we used the unpaired wilcoxonrank sum test and the v argha delaney a 12effect size to assess the significance and magnitude of our results.
vii.
c onclusions and future work in this paper we have used agglomerative hierarchical clustering to learn a linkage tree model that captures promising patterns of http requests in automatically generated system level test cases.
we proposed a novel algorithm called ltmosa that extends state of the art approaches by tailoring and incorporating linkage learning within its genetic operators.
linkage learning helps to preserve and replicate patterns ofapi requests that depend on each other.
we implemented lt mosa in e vomaster and evaluated it on seven web applications from the emb benchmark.our results show that lt mosa significantly improves code coverage and can detect more faults than two state of the art approaches in rest api testing namely mio and mosa .
this suggests that using unsupervised machine learning and agglomerative hierarchical clustering in our case is a very promising research direction.
126based on our promising results there are multiple potential directions for future works.
in this paper we used the upgma algorithm for hierarchical clustering.
therefore we intend toinvestigate more learning algorithms within the hierarchicalclustering category.
we also plan to investigate other categoriesof machine learning methods alternative to hierarchical cluster ing such as bayesian network .
finally lt mosa uses a fixed parameter kfor the linkage learning frequency.
we plan to investigate alternative more adaptive mechanisms to decidewhether the linkage tree model needs to be retrained or not.finally we intend to implement and apply linkage learning tounit test case generation as well.
r eferences f. curbera m. duftler r. khalaf w .
nagy n. mukhi and s. weerawarana unraveling the web services web an introduction to soap wsdl and uddi ieee internet computing vol.
no.
pp.
.
r. t. fielding architectural styles and the design of network based software architectures.
university of california irvine irvine vol.
.
v .
lenarduzzi and a. panichella serverless testing tool vendors and experts points of view ieee software vol.
no.
pp.
.
v .
lenarduzzi j. daly a. martini s. panichella and d. a. tamburri toward a technical debt conceptualization for serverless computing ieee software vol.
no.
pp.
.
j. campos y .
ge n. albunian g. fraser m. eler and a. arcuri an empirical evaluation of evolutionary algorithms for unit test suitegeneration information and software technology vol.
pp.
.
a. panichella and u. r. molina java unit testing tool competition fifth round in ieee acm 10th international workshop on searchbased software testing sbst .
ieee pp.
.
g. fraser and a. arcuri faults in projects automatically finding faults while achieving high coverage with evosuite empirical software engineering vol.
no.
pp.
.
s. shamshiri r. just j. m. rojas g. fraser p .
mcminn and a. arcuri do automatically generated unit tests find real faults?
an empiricalstudy of effectiveness and challenges t in 30th ieee acm international conference on automated software engineering ase .ieee pp.
.
a. arcuri and j. p .
galeotti handling sql databases in automated system test generation acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
p .
tonella evolutionary testing of classes acm sigsoft software engineering notes vol.
no.
pp.
.
a. arcuri restful api automated test case generation with evomaster acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
m. zhang b. marculescu and a. arcuri resource based test case generation for restful web services in proceedings of the genetic and evolutionary computation conference pp.
.
a. arcuri test suite generation with the many independent objective mio algorithm information and software technology vol.
pp.
.
r. a. watson and t. jansen a building block royal road where crossover is provably essential in proceedings of the 9th annual conference on genetic and evolutionary computation pp.
.
d. stallenberg m. olsthoorn and a. panichella replication package of improving test case generation for rest apis through hierarchicalclustering .
p .
mcminn search based software test data generation a survey software testing v erification and reliability vol.
no.
pp.
.
s. anand e. k. burke t. y .
chen j. clark m. b. cohen w .
grieskamp m. harman m. j. harrold p .
mcminn a. bertolinoet al.
an orchestrated survey of methodologies for automated softwaretest case generation journal of systems and software vol.
no.
pp.
.
m. soltani a. panichella and a. v an deursen search based crash reproduction and its impact on debugging ieee transactions on software engineering vol.
no.
pp.
.
s. ali m. z. iqbal a. arcuri and l. c. briand generating test data from ocl constraints with search techniques ieee transactions on software engineering vol.
no.
pp.
.
n. alshahwan x. gao m. harman y .
jia k. mao a. mols t. tei and i. zorin deploying search based software engineering with sapienzat facebook in international symposium on search based software engineering.
springer pp.
.
g. fraser and a. arcuri evosuite automatic test suite generation for object oriented software in proceedings of the 19th acm sigsoft symposium and the 13th european conference on f oundations of soft ware engineering pp.
.
k. mao m. harman and y .
jia sapienz multi objective automated testing for android applications in proceedings of the 25th international symposium on software testing and analysis pp.
.
e. viglianisi m. dallago and m. ceccato resttestgen automated black box testing of restful apis in ieee 13th international conference on software testing v alidation and v erification icst .ieee pp.
.
a. panichella f. m. kifetew and p .
tonella reformulating branch coverage as a many objective optimization problem in proceedings of the international conference on software testing v erification andv alidation icst graz austria pp.
.
k. deb a. pratap s. agarwal and t. meyarivan a fast and elitist multiobjective genetic algorithm nsga ii ieee transactions on evolutionary computation vol.
no.
pp.
.
a. panichella f. m. kifetew and p .
tonella automated test case generation as a many objective optimisation problem with dynamicselection of the targets ieee transactions on software engineering vol.
no.
pp.
feb .
r. a. watson g. s. hornby and j. b. pollack modeling buildingblock interdependency in international conference on parallel problem solving from nature.
springer pp.
.
m. pelikan and d. e. goldberg escaping hierarchical traps with competent genetic algorithms in proceedings of the 3rd annual conference on genetic and evolutionary computation pp.
.
m. pelikan d. e. goldberg e. cant paz et al.
boa the bayesian optimization algorithm in proceedings of the genetic and evolutionary computation conference gecco vol.
.
citeseer pp.
.
t. l. y u d. e. goldberg k. sastry c. f. lima and m. pelikan dependency structure matrix genetic algorithms and effective recombination evolutionary computation vol.
no.
pp.
.
m. w .
przewozniczek and m. m. komarnicki empirical linkage learning ieee transactions on evolutionary computation vol.
no.
pp.
.
d. thierens the linkage tree genetic algorithm in international conference on parallel problem solving from nature.
springer pp.
.
d. thierens and p .
a. bosman optimal mixing evolutionary algorithms in proceedings of the 13th annual conference on genetic and evolutionary computation pp.
.
a. bouter t. alderliesten c. witteveen and p .
a. bosman exploiting linkage information in real valued optimization with the real valuedgene pool optimal mixing evolutionary algorithm in proceedings of the genetic and evolutionary computation conference pp.
.
p .
a. bosman n. h. luong and d. thierens expanding from discrete cartesian to permutation gene pool optimal mixing evolutionary algo rithms in proceedings of the genetic and evolutionary computation conference pp.
.
m. olsthoorn and a. panichella multi objective test case selection through linkage learning based crossover in international symposium on search based software engineering.
springer .
a. panichella f. m. kifetew and p .
tonella a large scale empirical comparison of state of the art search based test case generators information and software technology vol.
pp.
.
f. u. haq d. shin l. c. briand t. stifter and j. wang automatic test suite generation for key points detection dnns using many objectivesearch arxiv preprint arxiv .
.
b. korel automated software test data generation ieee transactions on software engineering vol.
no.
pp.
.
r. sokal and c. d. michener a statistical method for evaluating systematic relationships university of kansas science bulletin vol.
pp.
.
c. e. shannon a mathematical theory of communication acm sigmobile mobile computing and communications review vol.
no.
pp.
.
s. sivanandam and s. deepa genetic algorithms in introduction to genetic algorithms.
springer pp.
.
j. d. schaffer r. caruana l. j. eshelman and r. das a study of control parameters affecting online performance of genetic algorithmsfor function optimization in proceedings of the 3rd international conference on genetic algorithms pp.
.
j. e. smith and t. c. fogarty adaptively parameterised evolutionary systems self adaptive recombination and mutation in a genetic algo rithm in international conference on parallel problem solving from nature.
springer pp.
.
a. arcuri and j. p .
galeotti testability transformations for existing apis in ieee 13th international conference on software testing v alidation and v erification icst .
ieee pp.
.
a. arcuri and g. fraser parameter tuning or default values?
an empirical investigation in search based software engineering empirical software engineering vol.
no.
pp.
.
a. arcuri many independent objective mio algorithm for test suite generation in proceedings of the international symposium on search based software engineering ssbse .
paderborn germany springer international publishing pp.
.
w .
j. conover practical nonparametric statistics .
john wiley sons vol.
.
a. v argha and h. d. delaney a critique and improvement of the cl common language effect size statistics of mcgraw and wong journal of educational and behavioral statistics vol.
no.
pp.
.
a. arcuri and l. briand a hitchhiker s guide to statistical tests for assessing randomized algorithms in software engineering software testing v erification and reliability vol.
no.
pp.
.