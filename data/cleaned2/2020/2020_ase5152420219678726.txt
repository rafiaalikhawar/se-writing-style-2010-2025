dynamic generation of python bindings for hpc kernels steven zhu nader al awar mattan erez and milos gligoric the university of texas at austin stevenzhu nader.alawar mattan.erez gligoric utexas.edu abstract traditionally high performance kernels hpks have been written in statically typed languages such as c c and fortran.
a recent trend among scientists prototyping ap plications in dynamic languages such as python created a gapbetween the applications and existing hpks.
thus scientistshave to either reimplement necessary kernels or manually createa connection layer to leverage existing kernels.
either optionrequires substantial development effort and slows down progressin science.
we present a technique dubbed w ayout which automatically generates the entire connection layer for hpksinvoked from python and written in c c .
w ayoutperforms a hybrid analysis it statically analyzes header files to generatepython wrapper classes and functions and dynamically generatesbindings for those kernels.
by leveraging the type informationavailable at run time it generates only the necessary bindings.
weevaluate w ayoutby rewriting dozens of existing examples from c c to python and leveraging hpks enabled by w ayout.
our experiments show the feasibility of our technique as wellas negligible performance overhead on hpks performance.
index t erms bindings high performance kernels dynamic program analysis python i. i ntroduction traditionally high performance computing hpc applications are written in statically typed and low level programming languages such as c c and fortran .
theselanguages are the de facto standard in the hpc area due tothe excellent performance of the resulting applications.
hpc applications spend most of their execution time in so called high performance kernels hpks such as linear algebra operations and solvers .
over the last several years the number of hpks has been steadily growing and existinghpks are constantly optimized and updated to support newhardware platforms.
recently several frameworks were introduced to enable developers to write performance portable hpks.
namely adeveloper can write an hpk only once and the frameworkautomatically enables the execution of that hpk on a variety ofhardware platforms e.g.
intel cpus nvidia gpus and amdgpus .
some of the most notable frameworks that supportperformance portability include kokkos and raja .these frameworks enable the rapid development of new hpks although they are still based on c c .
meanwhile scientists are transitioning to dynamically typed languages such as python julia or lua for writingtheir applications.
in order to obtain good performance sci entists have to either a implement hpks in their languageof choice using high performance libraries like numba or pykokkos or b create bindings to existing hpks implemented in c c or one of the frameworks that supportsperformance portability using libraries like pybind11 .in either case substantial work is required .
main tenance of manually written bindings as hpks evolve intro duces additional challenges.
we present w ayout a novel approach to automatically generating connection layers for existing performanceportable hpks to be used by python applications.
w ayout is the first approach that combines static and dynamic pro gram analysis.
specifically for a given header file w ayout performs static analysis to create wrapper classes and functions i.e.
a python api provided to scientists that reflectthe given header file and header files with templated bindings that will be instantiated at run time.
when a pythonapplication is executed and one of the wrapper functions is in voked w ayoutintercepts the call instantiates and generates thebindings for the given types and invokes an existing hpk.
one of the key insights behind w ayoutis that it postpones binding generation until it has the types needed which are notavailable statically in python .
w ayoutalso caches generated bindings so only the very first invocation of each function with one set of type arguments introduces some overhead the cache is saved across application runs.
we designed w ayoutto overcome the limitations of cppyy and pyximport which target the same task buttake very different approaches.
unfortunately neither of thetwo mentioned approaches could be used to invoke existinghpks from within a python application.
cppyy depends ona powerful but immature tool chain including pypy an alternative implementation of the python interpreter andcling an interactive c interpreter.
on the other hand pyximport does not support dynamic instantiation of templatesand thus is unable to instantiate bindings if types are knownonly at run time.
we overcome a set of critical challenges to realize w ayout including the lack of function and method overloading in python concurrent use of multiple templateinstantiations of the same class inferring types of returnedobjects and ambiguously typed template arguments.
we evaluate w ayoutby automatically generating bindings for kokkos kernels one of the most popular frameworksfor hpks and thrust a powerful template library con taining parallel algorithms.
we rewrote a number of existingexamples that use kokkos kernels and thrust from c c 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee to python.
our experiments show the feasibility of our technique as well as its negligible performance overhead on hpkperformance.
in our experiments we also show that w ayout does not impact the performance portability of hpks we wereable to execute all the examples on both cpus and gpus.
this paper makes the following key contributions design of w ayout a novel approach for automatically generating a connection layer for existing hpks to be used in python applications.
w ayoutuses a hybrid approach a combination of static and dynamic program analysis toinstantiate the connection layer.
implementation of w ayoutfor python.
the design of wayoutis modular and others could use our processing of header files to support connection layer with other pro gramming languages e.g.
lua.
source code of w ayoutis available at evaluation of w ayoutby rewriting a number of existing examples from c c to python and using existing hpksfrom kokkos kernels and thrust.
we chose kokkos becauseit is a popular performance portability framework and itcurrently has only a few manually written bindings wechose thrust to demonstrate the generality of our approach.
ii.
m otiv ation in this section we provide some background on hpks and binding generation as well as motivation for w ayout.
a. hpks the usage of hand optimized hpks in scientific computing is extremely common.
typically these kernels are writtenusing high performance c c frameworks that can exploitparallelism on multi core processors such as openmp forcpus and cuda for gpus.
more recently frameworkssuch as kokkos and raja build abstractions ontop of these device specific frameworks to enable performanceportability i.e.
code that is portable across devices while stillachieving good performance.
as such these frameworks are anatural choice for writing high performance kernels.
kokkos for example is used by numerous applications and packagesfor large scale scientific computing such as trilinos lammps albany empire and others.
kokkos kernels is a collection of performance portable kernels written in kokkos.
it includes a large variety of mathkernels and data structures commonly used in linear algebraand graph algorithms.
one such example of a linear algebrakernel is the sparse matrix vector multiply kernel or spmv for short.
the following code snippet shows how spmv canbe called in a kokkos c application where ais a sparse matrix alpha andbeta are scalars and xandyare vectors.
kokkossparse spmv n alpha a x beta y b. binding generation the target audience for these hpks is largely composed of scientists who need them for simulations andexperiments.
however these scientists typically do not havepython user codec hpkcall hpk return resultlanguage bindingscall bindings return result fig.
an illustration of language bindings.
formal training in programming so using c which isnotorious for its poor error messages and complicated buildsystems can be a huge deterrent.
instead they prefer higherlevel languages with batteries included such as python.
several attempts have been made to expose these libraries and kernels to other languages .
this requiresthe use of language bindings which allow for interoperability between different languages.
figure shows a high levelillustration of language bindings between python and c .numerous frameworks have been implemented to providepython bindings to c code such as boost.python pybind11 and swig .
the following code snippetshows what a call to spmv could look like once it has been exposed to python through one of the binding frameworks.
spmv char ptr n alpha a x beta y however manually writing these bindings can be tedious and challenging.
for example the python bindings for creatinga kokkos view the main multi dimensional data structurein kokkos are written in pybind11.
despite only bindinga small part of kokkos the total lines of code for thesebindings is over as they make heavy use of c macrosand compile time template instantiation to generate all the different combinations of template arguments.
for kokkosviews this includes different data types int16 t int32 t double etc.
dimensions one through eight memory lay outs memory spaces and memory traits.
each combinationof these arguments forms a single template instantiation.
thefollowing code snippet shows one such instantiation.
kokkos view int layoutleft hostspace besides being hard to write compiling the bindings takes a large amount of time around hours on our machinesfor a commonly used subset of all combinations due to thelarge number of template instantiations that need to happen.
inaddition to the time overhead compilation occasionally runsout of memory due to the large number of template argumentcombinations meaning that the process will not terminatesuccessfully on some machines.
prior work on automatic generation of python bindings for c code extracts library apis by parsing headerfiles for class and function declarations.
while this simplifieswriting the bindings it requires that the user manually addscode to instantiate all the needed template arguments sincethese frameworks employ static analysis.
also this does not 93solve the compilation issues for large numbers of template instantiations.
therefore such an approach does not work wellfor templated libraries such as kokkos kernels and thrust.
as a result we propose generating these bindings dynamically i.e.
on demand at run time such that only thenecessary template instantiations are created.
this allows typesto be passed at run time removing the need for the user tomanually add template instantiation.
it also reduces the costof compilation by compiling bindings only when needed.
weshow that this approach can achieve performance comparableto manually written bindings.
iii.
w ayoutoverview in this section we show an example of high performance kernel hpk from kokkos kernels and then use this hpk todemonstrate the workflow of w ayout.
we encountered multiple challenges during the design and implementation of w ayout.
we highlight these challenges like so and then outline our design choices and how we solved these challenges.
a. example figure shows the function signature of the spmv hpk spmv line and the class declaration of crsmatrix the sparse matrix data structure it operates on line .
this kernel performs the operation y beta y alpha a x. the template parameters of spmv are used to set the types used in the kernel at compile time alphatype betatype are the scalar types xvector andyvector are the vector types and amatrix is the sparse matrix type which can be set to crsmatrix in this example.
the template arguments forcrsmatrix are as follows scalartype is the type of entries contained in the matrix ordinaltype is the type of the matrix index device specifies on which device s memory e.g.
gpu the matrix is located in memorytraits specifies the kokkos memory access trait to be used atomic randomaccess etc.
and sizetype specifies the type of the row offset.
figure shows an example using spmv andcrsmatrix.
to call the kernel the user first defines mat t to alias the instantiated crsmatrix type line and instantiates the matrix and vectors lines .
the crsmatrix constructor takes in as arguments the number of rows columns andelements followed by views containing the matrix entries row offsets and column indices.
views yandxrepresent the one dimensional vectors and their constructor specifies thesize of the view.
the view constructor is templated on thedatatype and dimensionality one dimensional double in this case .
finally the user can call the spmv kernel as shown on line .
the arguments passed to the call are a stringspecifying the operation mode no transpose transpose orconjugate transpose the scalar alpha the matrix a the vector x the scalar beta and the vector y. the latter is passed by reference and will hold the result of the operation upon returnfrom the function.1template class alphatype class amatrix class xvector class betatype class yvector 4void spmv const char mode const alphatype alpha const amatrix a const xvector x const betatype beta const yvector y ... 9template class scalartype class ordinaltype class device class memorytraits void class sizetype typename kokkos viewtraits ordinaltype device void void size type 13class crsmatrix ... fig.
an example of a kernel and data structure declaration from kokkos kernels.
1int main ... using mat t kokkossparse crsmatrix double int kokkos defaultexecutionspace void int mat t a mat t numrows numcols nnz val ptr in view double y n view double x n kokkossparse spmv n alpha a x beta y fig.
an example using a kernel and data structure from kokkos kernels.
b. workflow figure shows a high level overview of w ayout in this section we highlight the user workflow.
there are two main steps to w ayout s workflow.
first the user provides the path to the header files or the include directory.
w ayoutthen generates a python api consisting of wrappers for the c api which was declared in the passed header files.
the usercan then access the c api using the python api exposedby the generated wrappers.
header files the first step in using w ayoutis passing in the header files containing the required class andfunction declarations that together constitute the api step circlecopyrt in figure .
w ayoutcan then generate python wrappers that mirror the c api kernel.py in figure .
python wrappers once the python wrappers have been generated they can be imported step circlecopyrt and called step circlecopyrt by the user.
calling a wrapper for the first time will generatethe templated bindings which will then be compiled into ashared library circlecopyrt.
figure shows the spmv example using the generated wrappers.
similar to the c version we first aliasthe matrix type line and then define the matrix and vectors lines .
we call the crsmatrix class method nnz which returns the number of entries in the matrix to demonstratehow a class method can be called line .
finally we call thespmv kernel line .
w ayoutgenerates wrappers for both function and class declarations as well as wrappers for public fields and methods 94fig.
an overview of w ayout s workflow.
1if name main assume constructor arguments are initialized mat t crsmatrix float int kokkos defaultexecutionspace none int a mat t numrows numcols nnz val ptr ind print num elem a.nnz y view double n x view double n spmv char ptr n alpha a x beta b fig.
python w ayoutexample using spmv andcrsmatrix.
1if name main assume constructor arguments are initialized crsmat t crsmatrix float int kokkos defaultexecutionspace none int a generate structured matrix2d fd structure template args fig.
python w ayoutexample using template args.
in the original c api.
functions.
one python wrapper function is generated for each c function.
an issue that arises here is overloaded functions.
python does not allow overloaded functions i.e.
redefining a function with a different number and differenttypes of arguments.
to account for this w ayoutinstead generates a single wrapper function with a variable number ofarguments for each unique function name.
at run time if anoverloaded function is used the correct instance will be calledbased on the number and types of the arguments passed bythe user.
users can call templated functions normally because the template arguments can be deduced from the argument typesat run time in most cases.
in some cases these types cannot be deduced and so have to be explicitly specifiedby the user.
for example figure shows a code snippettaken from a kokkos kernels tutorial using crsmatrix.
instead of calling the constructor directly it calls thegenerate structured matrix2d kernel to initialize the matrix.
in c this kernel is templated on the type of thematrix to be initialized.
the two arguments are for stenciltype and matrix structure.
these arguments do not hint atwhat the type of the generated matrix should be so the usersmust pass the template argument to w ayout otherwise c compilation fails.
these arguments can be passed in via thekeyword argument template args.
when the user calls a function the arguments are passed to the underlying kernels by reference.
however there are caseswhere a kernel expects an argument as a pointer.
to supportthis w ayoutprovides a simple class named ptr which the user can use to wrap their object and indicate that the argumentshould be passed as a pointer.
a similar issue occurs withstring arguments some functions require the standard c string whereas others accept character pointers.
to support this python strings are cast to standard strings by default and arguments that are character pointers use the char ptr wrapper class.
line in figure shows an example of this.
if a function returns a pointer the default behavior is to treat it as a reference i.e.
assume that c retains ownership ofthe object.
this means that when the resource is freed pythonwould not attempt to garbage collect the object and assumethe c run time would do so.
to override this behavior theuser can set the boolean keyword argument take ownership so that python is responsible for freeing memory.
classes.
one wrapper class is generated for each c class.
the init method i.e.
the constructor in python of the wrapper class is used to pass in template arguments creating atype object that can also be used as a type alias figure line .
to create an instance of the class the user callsthe type object passing in the constructor arguments to the call method line .
wrapper classes can accept a variable number of templates to support optional template arguments.
additionally if thetemplate argument is a primitive data type i.e.
int float etc.
the corresponding python data type can be used.
if thetemplate argument is a class type it can be set to a type alias orit can be passed as a string.
the latter is useful for referring totypedefs defined in the header files.
for instance in kokkosthedefaultexecutionspace type is simply a typedef that changes depending on compile time flags but we can still useit as a template argument in python by passing it as a string tothe class constructor line .
this can also be used to specify 95pointer types e.g.
double for template arguments line .
once an object has been created it can be used like any python object.
the wrapper class contains all class fields and methods present in the c version.
private fields andmethods are not accessible.
as w ayoutsupports inheritance attributes from the parent class are accessible as well.
anyobject returned from a function call will be automaticallywrapped using the correct wrapper class.
figure shows the generated python wrappers for the spmv example.
the spmv wrapper is defined on line and thecrsmatrix wrapper is defined on line the contents of these wrappers are explained in the next section.
iv .
t echniques in this section we describe our binding generation approach including both static and dynamic phases.
in thestatic phase section iv a w ayoutparses c header files to generate python wrappers and templated bindings.
in thedynamic phase section iv b w ayoutintercepts calls to the python wrappers.
then it instantiates compiles and importsthe templated bindings based on the types known only atrun time completing the link between python and c .
wethen describe the casting mechanisms used to move argumentsfrom python to c and vice versa section iv c .
next wedescribe our techniques to support inheritance section iv d and operator overloading section iv e .
finally we discussgpu support section iv f and integration with manuallywritten bindings section iv g .
there are two highlights to our approach first generating python code in the form of wrapper classes and functionsallows the user to easily use and potentially modify thegenerated bindings second the lazy approach to bindinginstantiation and compilation reduces the otherwise high com putational cost of binding and compiling everything ahead oftime.
once a binding has been compiled it is cached on thefile system for later use.
a. static generation we use clang to parse the header files and pybind11 as the bindings library.
we chose pybind11 due to its popularity flexibility and ease of use.
writing bindingsusing pybind11 involves defining a python module object which is used to register classes and functions so that theycan be accessed from python.
when w ayoutis invoked by a user it uses the clang python api to parse the header files and return the root nodeof the corresponding abstract syntax tree ast .
w ayout can then extract the api from header files by traversing theast recursively to discover classes and functions.
one issuewith this approach is that python does not allow function or method overloading both of which are used heavily inhpks such as kokkos kernels especially for constructors.to deal with this w ayoutfirst stores function names in a set so that only one wrapper function is generated even ifother overloaded instances exist.
inside the wrapper functionsfor overloaded functions w ayoutadds code that selects1defspmv args template args none take ownership false mod name generate func binding spmv kokkossparse args includes template args take ownership args res getattr mod name args return cast return res 8class crsmatrix compressed sparse row implementation of a sparse matrix.
namespace kokkossparse def init self template args handle none self.
handle handle self.
cpp name handle.
cpp type ifhandle else register class crsmatrix self.
namespace template args def call self args ifself.
handle if hasattr self cpp call return self.
cpp call args raise runtimeerror error can t call constructor on instance!
mod name generate constructor self.
cpp name args includes args inst copy.copy self inst.
handle getattr mod name args return inst defnnz self args take ownership false !
the number of stored entries in the sparse matrix.
mod name generate class func binding self nnz args includes take ownership args res getattr mod name self.
handle args return cast return res ... fig.
python wrapper generated by w ayoutforspmv and crsmatrix.
include pybind11 pybind11.h include kokkossparse crsmatrix.hpp 3template class t 4void generate class pybind11 module mod const char name const char cpp type pybind11 class t class mod name class.def property readonly static cpp type const pybind11 object return cpp type class.def readwrite graph t graph class.def readwrite values t values ... fig.
generated c templated header for the crsmatrix.
the appropriate overloaded instance at run time based on the types of the arguments.
these types are extracted from thearguments using the python built in function type .
w ayoutthen generates python wrappers mirroring the original c api.
figure partially shows the generatedwrappers for the spmv function and crsmatrix class with the latter also containing wrapper methods for its correspondingc class methods.
in addition to python wrappers w ayoutgenerates one c header file for each class encountered during ast traver sal.
figure shows the header generated for the crsmatrix class.
the header file contains a function templated on t where tis the type to be registered via pybind11.
the 96function registers the type twith pybind11 as well as all the class fields.
since all instances of a templated class have the same members the header file can be reused bydifferent instantiations of the templated class at run time e.g.
crsmatrix double ... orcrsmatrix int ... .
b. dynamic generation at run time the user imports and calls the generated python wrappers shown in figure .
internally the wrappers call w ayoutto instantiate the templated functions based on the types passed generating a c source file that uses thetemplated binding header files generated in the static phase.
w ayoutthen compiles the c source into a shared object file or simply dso that can be imported and used by thewrapper.
later calls to the same wrappers will reuse theexisting dso if the types are unchanged.
wrapper in figure the spmv wrapper calls the w ayoutfunction generate function binding line to generate the function binding.
this call captures infor mation such as function name spmv and namespace kokkossparse which are needed to uniquely identifythe c function that needs to be bound.
this is needed incombination with the arguments and optionally the templatearguments to generate a hash that uniquely identifies the bind ing instantiation.
similarly the methods of crsmatrix call w ayoutto generate instantiated bindings.
the generate functions check to see if a module matching the hash has beenimported.
if so it simply returns the module object containingthe function.
if the module has not been imported w ayout attempts to import it from the file system.
if the correspondingdso does not exist then w ayoutgenerates the binding instantiation source code for the function.
binding generation there are two main types of bindings.
one is for registering classes so pybind11 knows howto cast objects between python and c while the otheris for binding an instantiated templated function.
for classregistration the binding source code first includes the classheader shown in figure generated during the static phaseand uses it to register classes.
for function bindings w ayout generates intermediate c functions that cast arguments frompython types to the corresponding c types and internallycall the api function.
figure shows examples for both types of bindings.
during class registration a python module object is first created usingthepybind11 module line .
the first argument is the name of the kernel which is set to the unique hash correspondingto that instantiation.
the second argument is a handle to themodule object that is used to register functions for that module.then the class is registered in pybind11 line .
w ayoutdefines an intermediate function for each method lines and which accepts as input an argument oftype pybind11 args containing a list of arguments.
we use auto as the return type of the intermediate functions and rely on the compiler to deduce it from the argument types.
each intermediate function explicitly casts each argument to its corresponding c type e.g.
lines and then calls1 generated binding code for registering crsmatrix include crsmatrix.hpp 4pybind11 module f f8ee838d9c3174dc82a k generate class kokkossparse crsmatrix double int kokkos defaultexecutionspace void int k f f8ee838d9c3174dc82a kokkossparse crsmatrix double int kokkos defaultexecutionspace void int generated binding code for crsmatrix constructor 15auto func pybind11 args args auto a0 args .cast std string auto a1 args .cast int ... return new kokkossparse crsmatrix double int kokkos defaultexecutionspace void int a0 a1 a2 a3 a4 a5 a6 generated binding code for nnz method of crsmatrix 26auto func pybind11 args args auto a0 args .cast kokkossparse crsmatrix double int kokkos defaultexecutionspace void int return a0.nnz generated binding code for spmv 35auto func pybind11 args args auto a0 args .cast std string auto a1 args .cast double ... return kokkossparse spmv a0.c str a1 a2 a3 a4 a5 fig.
generated c binding instantiation code for the spmv example.
the c api function.
the first function calls the crsmatrix constructor line the second function calls the nnz class method line and the third function calls the standalone spmv function line .
the bindings are then compiled into object files.
intuitively wayoutwould then link the files containing all the instantiations into one single dso file and import it.
whenever anew instantiation is generated and linked w ayoutwould reload the dso.
however this will not work because python does not provide support for dynamically reloadingdsos unless their reference count reaches zero and they aregarbage collected.
waiting for the garbage collector to run isunreliable and might not even happen before the applicationcompletes.
our solution is to generate a separate dso for eachtemplate instantiation of every class and function.
this has theadded benefit of avoiding the extra linking overhead when newbindings are generated.
it also allows w ayoutto elegantly support overloading and templates by separating them intodifferent modules and avoiding re definition errors in python since each combination of arguments would correspond to adifferent module.
97the generated python wrapper can then access and call functions registered in the module using the built in getattr function figure lines and .
c. casting when the user calls a bound function such as spmv in figure line w ayoutcasts the passed arguments from types that are valid in python to types that are valid in c .
once control returns to the python side the returned bindingobject is also cast to the correct wrapper class.
w ayoutuses three forms of casting explicit implicit and autocasting.
explicit casting as mentioned previously intermediate functions accept as input a list of arguments args .
explicitcasting refers to calling the pybind11 cast method on elements of args to convert them into types that can be used in c storing them in local variables figure lines .these variables can then be passed to the c function call.
the type to be cast to is passed as a template argument.
since the binding instantiation is generated at run time thesetypes are chosen based on the types of the passed arguments.this form of casting works fine if the argument is a primitive e.g.
int .
however if the argument type is one of the wrapper classes e.g.
crsmatrix an additional implicit cast may be required.
implicit casting in heavily templated classes it is common for objects with slightly different template instantia tions to be semantically equivalent.
for instance the kokkosview object has an execution space template argument whichcan either be of type device ormemoryspace which are interchangeable.
in the spmv example spmv can accept both kokkos view double hostspace and kokkos view double device openmp hostspace for its view arguments even if they are different types be cause kokkos internally implements implicit casting betweenthe two.
in order for pybind11 s cast to work on non primitive types w ayoutmust use the type that was obtained during class registration as that is the type that pybind11 recognizes.otherwise cast throws an exception for an illegal cast.
in some cases different parts of a c api depend on different template instantiations of the same class even ifthey are semantically equivalent.
this is a challenge for w ayout since it uses pybind11 to cast objects to the exact type needed by functions which will result in an exception ifthere is any difference in types.
to solve this w ayoutcaches information about the c type of a binding object by adding an extra cpp type field during class registration.
this extra field is a string set tothe fully qualified c type name.
therefore during bindinggeneration w ayoutcan use this stored name to cast the argument to the appropriate type.
autocasting when an object is returned from a function pybind11 does not cast it to one of wayout s wrapper classes so it cannot be used to access the fieldsand methods.
ideally the functions would return objects ofthe same type as the generated wrapper class.w ayouttherefore wraps these objects in the appropriate wrapper class so the class fields and methods can still beaccessed normally figure line .
to do so w ayout first checks if the returned object has the cpp type field.
if not then the returned object is a primitive and no castingis needed.
otherwise w ayoutinitializes a wrapper object using the binding object as the handle.
additional complications occur when the return type has not been registered with pybind11.
for example assume the usercalls a function that returns a matrix type that has not beeninstantiated before.
to solve this we also generate dummy functions which return empty instances of the return type.when a module is imported w ayoutalso calls the dummy function.
if the class is not registered a typeerror will be thrown by pybind11 which we catch and parse to extract theclass that needs to be registered.
since this only needs to bedone once when a module is imported the overhead is minimaland guarantees that all return types are registered.
d. inheritance inheritance is a commonly used feature in c to facilitate code reuse.
while it is not used much in kokkos kernels thrust extensively utilizes inheritance in its variousstructures.
w ayoutsupports inheritance during the static phase where the name of the parent can be extracted fromthe ast.
then we can naturally emulate the c inheritancerelationship by having the python wrapper class of a c childclass inherit from the python wrapper class of the parent.
e. operator overloading operator overloading in c is used to implement the built in operators for custom datatypes e.g.
using the operator to access elements in a data structure.
w ayoutsupports operator overloading by treating them as class methods withthe caveat that the method name is mapped to the corre sponding python magic method name e.g.
operator to setitem and getitem .
since w ayoutalready uses the call magic method for invoking the constructor we map the c call operator to a new cpp call method which is invoked when a class instance is called e.g.
figure line .
w ayoutcurrently supports the c addition subtraction bracket call and dereference operators although support for others is planned.
f .
gpu support as most hpks support heterogeneous systems it is important for w ayoutto support gpus as well.
code that runs on gpus e.g.
cuda or hip typically cannot be compiled using a regular c compiler such as g .
instead it needs tobe compiled with a specific compiler e.g.
nvcc for cuda .this is easy to do in w ayout as the only modification needed is to switch to the right compiler.
additionally sinceone of the main targets of our work is kokkos the kernelinterface does not change when running with a gpu so nofurther modifications to w ayoutare needed.
98g.
integration of manually written bindings there are instances where it is still beneficial to use manually written bindings for convenience reasons.
for instance the kokkos view object is a general purpose n dimensionaldata structure.
it overloads the parentheses operator for readingand modifying data instead of the commonly used squarebrackets e.g.
int x view .
this does not work well with pybind11 since the parentheses operator returns a refer ence to a primitive which pybind11 handles by passing byvalue to python meaning that modification of the contentsis not possible.
however kokkos does have python bindings manually written for views .
these bindings leverage apybind11 feature that allows the python buffer protocol to be implemented for the raw data buffer contained in views which allows the internal data to be accessed normally frompython.
since they are implemented using pybind11 thesebindings can be used seamlessly with w ayout.
v. e v aluation we evaluate w ayoutby answering the following four research questions rq1.
how effective is w ayoutat generating bindings for kokkos kernels and cuda thrust?rq2.
what is the run time performance overhead of the bindings generated by w ayout?
rq3.
how does the run time performance of the automatically generated bindings compare to handwritten bindings?rq4.
what is the time needed to generate the bindings?
we ran all experiments on an ubuntu .
machine with a 6core intel core i7 .20ghz cpu and 64gb of ram andan nvidia geforce gpu with 8gb of memory.
we usedpython .
.
gcc .
openmp .
and cuda .
.
weused kokkos .
.
and kokkos kernels from the develop branch commit .
finally we used thrust .
.
.
all data presented are averaged over runs and the thrust subjects were run for iterations.
a. results rq1 how effective is w ayout at generating bindings for kokkos kernels and cuda thrust?
using w ayout we automatically generated bindings for allthe kernels in the kokkos kernels framework.
we verified that w ayoutis able to run all kernels present in the kokkos kernels wiki as well as the sparse matrix container crsmatrix and numerous other helper functions used for memory allocation and initialization.
we then ported existing c programs that use these kernels to python.
specifically we implemented applications fromthe official kokkos repository in python cgsolve implements a conjugate gradient algorithm forsolving systems of linear equations of the form ax b. cgsolve spilukprecond similar to cgsolve but uses preconditioning for faster convergence.
gaussseidel implements the gauss seidel method forsolving a system of linear equations.
graphcoloring assigns colors to elements of a graphsuch that no neighboring nodes have the same color.
innerproduct calculates the inner product of the form y a x yt a x. spgemm implements sparse matrix matrix multiplication in two phases symbolic followed by numeric witha kernel for each phase.
spiluk implements sparse k level incomplete lu fac torization.
we also need python bindings for kokkos views as theyappear frequently in our test subjects and in kokkos kernels.in our subjects we used both the manually written pythonbindings and bindings automatically generated by w ayout.
as mentioned before views use the c parentheses operatorto modify data meaning that they cannot be directly modifiedin python using the automatically generated bindings so weimplement only four of our subjects using the latter.
to demonstrate the generality of our approach we also generated bindings for kernels in the thrust library.
we ported7 examples from the official thrust repository to python histogram mode saxpy set operations sort sparse and sum.
in summary w ayoutsuccessfully generated bindings to kokkos kernels and thrust which we were able to use to portworkloads from c to python.
rq2 what is the run time performance overhead of the bindings generated by w ayout?
figure shows plots of computation time y axis vs. input data size x axis for our subjects from kokkos kernels andthrust.
for w ayout we show computation time after the bindings have been instantiated and compiled for all types thatoccur in each subject.
we show binding generation time inrq4.
the time shown does not include time spent to initializethe subject as most subjects initialize arrays in sequentialloops which dominates the running time for larger input sizes.including that time would mean comparing python to c rather than measuring the overhead of the generated bindings.
for most subjects our python implementation can achieve performance comparable to the original c implementation.
for the cgsolve subject we observe overhead that scales with the size of the input data.
this happens because thesubject runs most of its computations in a loop that calls thekernel internally.
it also computes a square root in pythonusing the math.sqrt function.
the number of iterations of this loop scales with the size of the input data increasing thenumber of calls to math.sqrt which in turn increases the total time taken compared to the c implementation.
we also observe noticeable performance overhead for the set operations subject figure 10k .
this subject invokes various functions that each allocates a result vector and callsa different set operation e.g.
merge union .
in c theresult vector is allocated on the stack while in python theobject must be allocated on the heap.
both heap allocation andpython s garbage collector introduce substantial overhead.
thus these two outliers can be attributed to python itself rather than w ayout.
in summary bindings generated by wayoutintroduce minimal performance overhead.
6l h 7lph v d 6royh d 2xw 2shq03 .rnnrv 2shq03 d 2xw .rnnrv 6l h e 6royhb6s .suhfrqg d 2xw 2shq03 .rnnrv 2shq03 d 2xw .rnnrv 6l h f dxvv6hlgho d 2xw 2shq03 .rnnrv 2shq03 d 2xw .rnnrv 6l h 7lph v g udsk rorulqj d 2xw 2shq03 .rnnrv 2shq03 d 2xw .rnnrv 6l h h qqhu3urgxfw d 2xw 2shq03 .rnnrv 2shq03 d 2xw .rnnrv 6l h i 6s d 2xw 2shq03 .rnnrv 2shq03 d 2xw .rnnrv 6l h 7lph v j 6s .
d 2xw 2shq03 .rnnrv 2shq03 d 2xw .rnnrv 6l h k klvwrjudp d 2xw 2shq03 7kuxvw 2shq03 d 2xw 7kuxvw 6l h l prgh d 2xw 2shq03 7kuxvw 2shq03 d 2xw 7kuxvw 6l h 7lph v m vd s d 2xw 2shq03 7kuxvw 2shq03 d 2xw 7kuxvw 6l h n vhwbrshudwlrqv d 2xw 2shq03 7kuxvw 2shq03 d 2xw 7kuxvw 6l h o vruw d 2xw 2shq03 7kuxvw 2shq03 d 2xw 7kuxvw 6l h 7lph v p vsduvh d 2xw 2shq03 7kuxvw 2shq03 d 2xw 7kuxvw 6l h q vxp d 2xw 2shq03 7kuxvw 2shq03 d 2xw 7kuxvw fig.
kernel time using w ayoutgenerated bindings vs. original kokkos kernels thrust implementation.
100table i performance of generated versus manually written bindings.
subject size openmp time cuda time manual generated ratio manual generated ratio cgsolve spilukprecond .
.
.
.
.
.
gaussseidel .
.
.
.
.
.
innerproduct .
.
.
.
.
.
spiluk .
.
.
.
.
.
table ii bindings build time kokkos kernels on the left and thrust on the right .
subject kernels modules static phase dynamic phase g dynamic phase nvcc subject kernels modules static phase dynamic phase g dynamic phase nvcc cgsolve .
.
.
histogram .
.
.
cg spiluk .
.
.
mode .
.
.
gaussseidel .
.
.
saxpy .
.
.
graphcoloring .
.
.
setoperations .
.
.
innerproduct .
.
.
sort .
.
.
spgemm .
.
.
sparse .
.
.
spiluk .
.
.
sum .
.
.
rq3 how does the run time performance of the automatically generated bindings compare to manually written bindings?
we compare the manually written python bindings provided in the kokkos repository for the view class against the bindings generated by w ayout.
table i shows the performance of the generated bindings versus the handwritten ones withboth openmp and cuda.
the first column shows the nameof the subject.
the second column shows the size of the inputdata.
the rest of the table shows computation time for boththe manually written and automatically generated bindings aswell as the ratio of generated time to manual time.
the results show that the performance of the bindings generated by w ayoutmatches that of the manually written bindings.
this is expected as both sets of bindings use py bind11 and w ayoutonly generates an additional lightweight python wrapper which has minimal performance overhead.
rq4 what is the time needed to generate the bindings?
table ii shows the average time taken to automatically generate the bindings for each library.
the columns show the name of the subject the number of kernels used the numberof modules generated i.e.
dsos that instantiate the classesand functions the time taken during the static phase andthe time taken during the dynamic phase for g and nvccrespectively.
the results show that w ayouthas acceptable execution time.
the largest cause of performance overhead in eitherphase is caused by calling the c compiler.
the time takenduring the static phase is mostly caused by compiling theenums dso file and does not vary greatly across subjects.the time taken during the dynamic phase varies dependingon the number of modules generated and the compiler used.more kernel calls with different types results in more templateinstantiations and therefore more modules generated.
forexample the cgsolve spilukprecond subject has a largedynamic phase execution time as it calls kernels andgenerates modules more than any other subject.
it is important to note that the execution time shown here only occurs once when the bindings are instantiated for thefirst time.
later calls of kernels with the same types andeven later runs of the same application would not incur thisoverhead as the modules are cached on the filesystem.
w ayoutis also considerably faster than the approach used in the kokkos view bindings which is a purely staticapproach that instantiates all combinations of types duringcompilation.
on our machine compiling those bindings takesover hours and runs out of memory on another machine.
vi.
l imitations c allows passing arguments and returning values by value pointer or reference.
python always passes primitivesby value and objects by reference.
as such the python apigenerated by w ayoutwill not always exactly match the functionality of the c api primitives are always passed andreturned by value and objects are always passed by referenceor pointer.
w ayoutallows passing pointers with ptr and character pointers with char ptr.
another limitation of w ayoutis that the generated wrappers may not be very pythonic .
for example while ptr andchar ptr are practical solutions to pointer arguments such constructs will be unfamiliar to python programmers.additionally the generated wrappers do not make use ofcertain python features such as keyword arguments i.e.
kwargs and dynamic typing.
it would be possible to make the generated apis more pythonic by adding another layer of abstraction on top of thewrappers generated by w ayout.
currently this would require additional effort from the user although we plan to explore away to automate this step in future work.
101some kernels in thrust accept a function object as an argument in order for the user to define kernel behavior.
w ayout does not support these kernels as this would require translating python code to c an earlier work pykokkos supportstranslation from python to c .
however since the goal of w ayoutis to bind existing hpks where the behavior is already defined this is a minor limitation.
finally we focused primarily on kokkos and thrust in our evaluation.
we chose kokkos because it is a popularperformance portability framework with a large number ofkernels and thrust is a popular cuda library.
vii.
r elated work a. binding frameworks boost.python pybind11 swig and pyximport are frameworks that allow binding c or c code sothat it can be called from python.
typically these frameworksrequire that the user specify the c interface to be boundusing some form of domain specific language or configurationfile.
w ayoutonly asks the user for the header files containing class and function declarations and automatically generatesthe bindings with no extra effort from the user.
b. static binding generation cffi is a python library that can import c code using c like declarations and generate the necessary bindings in a c file.
however it does not support c and requires the userto manually declare the interface.
autowig provides apython api to pass in header files and then generates bindingsusing boost.python.
additionally the user has to provide aheader file that contains all the needed template instantiationsfor templated classes and functions.
afterwards the usermust compile the generated bindings.
similarly binder statically parses header files to obtain all classes and functions.as with autowig the desired template instantiations mustbe explicitly used or specified in the header files.
in contrastto autowig it is meant to be used entirely through thecommand line.
w ayoutis more flexible and more pythonic through its dynamic analysis templates are only instantiatedat run time through types passed to automatically generatedpython wrapper classes.
the user does not have to specify allthe types that they want to use ahead of time.
c. dynamic binding generation cppyy dynamically generates bindings to c libraries.
it uses cling a c interpreter based on clang and llvm to generate c code that instantiates and calls classesand functions included in header files and then binds thatcode to enable accessing it from python.
the definitionsof those classes and functions are loaded at run time bydynamically linking a shared object library.
this presents aproblem for libraries such as kokkos kernels which currentlycan only be compiled to a static library.
w ayoutprovides the flexibility of linking a static library during compilation insteadof exclusively requiring shared object libraries as cppyy does.additionally w ayout s use of pybind11 to interface betweenpython and c allows the user to manually write bindingsfor some classes to make them more pythonic if desired.
furthermore the dependence on cling also limits supported libraries to features supported by cling.
for instance it doesnot have support for thread level storage symbol relocation which is used in the shared object for kokkos.
anotherexample is cuda support.
since w ayoutinvokes a compiler to compile shared objects it has flexibility of choosing nvccrather than g as the compiler whereas cling support forcuda is still experimental.
d. high performance python pykokkos is a framework for writing performance portable kernels in python.
the user writes kernels in a small statically typed subset of python which pykokkosthen translates to c kokkos to obtain better performance.numba is a python jit compiler based on llvm.cython adds c like language extensions to python toimprove performance.
w ayoutis not meant for writing kernels.
w ayoutprovides access to pre existing hand tuned high performance kernels.
numpy and scipy both contain data structures and kernels used in scientific computing.
a significant part of bothlibraries is implemented in c and c and manually wrappedso it can be accessed from python.
w ayoutautomatically generates bindings to interoperate between python and c .
viii.
c onclusion we present w ayout a technique for automatically generating python bindings for c code specifically high performance kernels.
w ayoutcombines static and dynamic analysis in order to reconcile python s dynamic nature withc s static typing and is able to support heavily templatedclasses and functions.
we implement w ayoutby building python and c code generators that produce a connectionlayer between the two languages.
our evaluation shows that w ayoutcan support kokkos kernels framework and cuda thrust with minimal performance overhead.
additionally wayoutcan generate bindings at an acceptable performance cost making it more feasible than manually written and stati cally generated bindings.
we believe that w ayoutenables faster development of scientific applications by connectingpython a high level language frequently used by scientists to existing hpks written in c .
a cknowledgment we thank george biros martin burtscher ian henriksen jonathan r. madsen arthur peters keshav pingali sivasankaran rajamanickam christopher j. rossbach karlw.
schulz christian trott and the anonymous reviewersfor their feedback on this work.
this work was partiallysupported by the us national science foundation under grantnos.
ccf and ccf and the departmentof energy national nuclear security administration underaward number de na0003969.
102references c. r. trott examinimd .
d. lebrun grandi e a. prokopenko b. turcksin and s. r. slattery arborx a performance portable geometric search library acm transactions on mathematical software vol.
no.
pp.
.
s. slattery cabana .
s. rajamanickam s. acer l. berger vergiat v .
dang n. ellingwood e. harvey b. kelley c. r. trott j. wilke and i. yamazaki kokkoskernels performance portable sparse dense linear algebra and graphkernels .
h. c. edwards c. r. trott and d. sunderland kokkos enabling manycore performance portability through polymorphic memory accesspatterns journal of parallel and distributed computing vol.
no.
pp.
.
c. trott l. berger vergiat d. poliakoff s. rajamanickam d. lebrungrandie j. madsen m. gligoric n. al awar g. shipman andg.
womeldorff the kokkos ecosystem comprehensive performanceportability for high performance computing computing in science and engineering.
d. a. beckingsale j. burmark r. hornung h. jones w. killian a. j. kunen o. pearce p. robinson b. s. ryujin and t. r. scogland raja portable performance for large scale scientific applications inworkshop on performance portability and productivity in hpc pp.
.
t. e. oliphant python for scientific computing computing in science and engineering vol.
no.
pp.
.
j. bezanson a. edelman s. karpinski and v .
b. shah julia a fresh approach to numerical computing siam review vol.
no.
pp.
.
s. k. lam a. pitrou and s. seibert numba a llvm based python jit compiler in workshop on the llvm compiler infrastructure in hpc pp.
.
n. al awar s. zhu g. biros and m. gligoric a performance portability framework for python in international conference on supercomputing pp.
.
pybind11 documentation stable intro.html.
j. r. madsen kokkos python kokkos python .
e. slaughter and a. aiken pygion flexible scalable task based parallelism with python in parallel applications workshop alternatives to mpi pp.
.
w. t. lavrijsen and a. dutta high performance python c bindings with pypy and cling in workshop on python for high performance and scientific computing pyhpc p. .
p. virtanen r. gommers t. e. oliphant m. haberland t. reddy d. cournapeau e. burovski p. peterson w. weckesser j. bright s. j.van der walt m. brett j. wilson k. j. millman n. mayorov a. r. j.nelson e. jones r. kern e. larson c. j. carey i. polat y .
feng e. w. moore j. vanderplas d. laxalde j. perktold r. cimrman i. henriksen e. a. quintero c. r. harris a. m. archibald a. h. ribeiro f. pedregosa p. van mulbregt and scipy .
contributors scipy .
s. behnel r. bradshaw c. citro l. dalcin d. s. seljebotn and k. smith cython the best of both worlds in computing in science and engineering pp.
.
pypy v .
vassilev p. canal a. naumann l. moneta and p. russo cling the new interactive interpreter for root in journal of physics conference series pp.
.
n. bell and j. hoberock chapter thrust a productivity oriented library for cuda in gpu computing gems jade edition pp.
.
openmp cuda zone the trilinos project team the trilinos project website.
lammps molecular dynamics simulator .
albany multiphysics code .
m. t. bettencourt and s. shields empire sandia s next generation plasma tool sandia national lab.
snl nm albuquerque nm united states tech.
rep. .fundamental algorithms for scientific computing in python nature methods vol.
pp.
.
c. r. harris k. j. millman s. j. van der walt r. gommers p. virtanen d. cournapeau e. wieser j. taylor s. berg n. j. smith r. kern m. picus s. hoyer m. h. van kerkwijk m. brett a. haldane j. f.del rio m. wiebe p. peterson p. gerard marchant k. sheppard t. reddy w. weckesser h. abbasi c. gohlke and t. e. oliphant array programming with numpy nature vol.
no.
pp.
.
d. abrahams and r. w. grosse kunstleve building hybrid systems with boost.python the c c users journal vol.
.
d. beazley automated scientific software scripting with swig future generation computer systems vol.
no.
pp.
.
p. fernique and c. pradal autowig automatic generation of python bindings for c libraries peerj computer science vol.
.
rosettacommons binder binder .
c. lattner and v .
adve llvm a compilation framework for lifelong program analysis transformation in international symposium on code generation and optimization pp.
.
t. oliphant and c. banks pep revising the buffer protocol .
s. rajamanickam kokkos kernels wiki kokkos kernels wiki apireference .
c. r. trott kokkos tutorials kokkos tutorials .
thrust .
cffi documentation .