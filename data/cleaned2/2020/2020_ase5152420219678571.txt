automated v erification of go programs via bounded model checking nicolas dilley department of computing university of kent canterbury united kingdom nd315 kent.ac.ukjulien lange department of computer science royal holloway university of london egham united kingdom julien.lange rhul.ac.uk abstract the go programming language offers a wide range of primitives to coordinate lightweight threads e.g.
channels waitgroups and mutexes all of which may cause concurrencybugs.
static checkers that guarantee the absence of bugs areessential to help programmers avoid these costly errors beforetheir code is executed.
however existing tools either miss toomany bugs or cannot handle large programs.
to address theselimitations we propose a static checker for go programs whichrelies on performing bounded model checking of their concurrentbehaviours.
in contrast to previous works our approach dealswith large codebases supports programs that have staticallyunknown parameters and is extensible to additional concurrencyprimitives.
our work includes a detailed presentation of theextraction algorithm from go programs to models an algorithmto automatically check programs with statically unknown param eters and a large scale evaluation of our approach.
the lattershows that our approach outperforms the state of the art.
index t erms go concurrency static verification behavioural types model checking i. i ntroduction developing concurrent software is particularly difficult because concurrency related bugs are often difficult to detect.
typically these bugs do not occur in every execution e.g.
dueto non determinism or because they depend on the program sarguments and some may not be easily observable e.g.
theymight only affect the memory footprint of the program .
message passing concurrency as supported natively by the go programming language offers a higher level of abstractionthan traditional shared memory based concurrency.
howeverbugs are still a common problem in message passing soft ware and it is thus essential to develop reliable static checkers that can rule out these bugs.
static verification hasthe advantage of ruling out bugs for every execution and to do this before the code is executed and released.
amongst recent works on static checkers for go we distinguish those that aim for soundness e.g.
using a behaviouraltype approach and those that aim forcompleteness e.g.
gcatch .
existing checkers based onbehavioural types tend to raise too many false alarms do notscale to large codebases and support a very limited subset ofgo.
in contrast gcatch can handle large codebases has a lowrate of false alarm but tends to miss many bugs.
additionally it is not easy to predict the type of bugs it misses.in this work we build on the behavioural types approach first formalised in where models that represent the com munication structure behavioural types are extracted fromgo programs.
these models over approximate their programsand can be verified using an off the shelf model checker.
our work builds on our earlier prototype which uses promela as a behaviour type language.
our extension consistsof a combination of four key insights.
to deal with programs whose concurrent structure depends on arguments that are decided at run time we extract parameterised behavioural types i.e.
models from programs.
these models can then be verified up to user provided bounds.
tracking parameters that affect the concurrent structure ofprograms allows us to decrease the number of false alarms which plagued earlier behavioural types based approaches.
to deal with large codebases we divide go programs into independently verifiable components.
this allows us to verify a large project like kubernetes more than million loc in minutes.
most projects are checked under minutes.
our approach supports programs that coordinate over the three main concurrency primitives channels waitgroups mutexes and can easily be extended to support more primitives.
our approach is explicit wrt.
the subset of go it supports and which constructs are over approximated.
additionally our tool returns confidence levels when it is applied to pa rameterised programs.
hence it is easier for developers tounderstand the risk and potential cause of false alarms.
we describe the technical insights of our approach using a bug our tool discovered in the wild with example .
example .
the program in figure is adapted from code found on the github repository of trillian a verifiable data store developed at google.
at line function preload spawns trees worker goroutines which send the result of dosomework over channel ch.
to limit the number of concurrent threads each goroutine acquires a token receive at line before executing dosomework and returns it send at line before terminating.
note that theparent thread fills channel limitch with tokens at lines .
at line the parent thread spawns another goroutine that waits for the worker goroutines to finish using a waitgroup 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee 1func preload trees string nint ch make chan string n new chan with capacity n limitch make chan int runtime.numcpu for i i runtime.numcpu i limitch send token on chan limitch var wg sync.waitgroup for t range trees wg.add increment wg counter go func v string spawn goroutine limitch receive token before starting work s dosomework v ch s limitch return token wg.done decrement wg counter t go func spawn goroutine wg.wait wait for wg to reach close ch set ch to closed for s range ch receive message from ch ifiserror s return fig.
example of a blocking bug adapted from .
wg .
when all goroutines have invoked wg.done operationwg.wait succeeds and channel ch isclosed.
after spawning trees goroutines the parent is ready to consume the data sent on ch via a range loop on ch line .
this construct iterates over each element sent on ch until the channel is closed.
if a message contains an error i.e.
iserror s returns true preload returns.
figure contains a subtle bug that leads to several goroutines becoming permanently stuck.
consider the case where runtime.numcpu and0 n trees .
the number of send actions on channel ch is greater than its capacity hence some worker goroutines will be blocked at line 13until the parent thread receives some messages line .
ifpreload returns line before consuming all messages it may leave up to trees runtime.numcpu goroutines permanently blocked.
blocked goroutines are problematic even when the program as a whole is not stuck.
they cannot be garbage collected hence they silently consume resources until the whole programterminates.
for instance if function preload is called often with the wrong arguments this would affect significantlythe memory footprint of the program.
programs like example are difficult to reason about because they use several coordination mechanisms in non trivial ways which makes it hard to enumerate all possibleinterleavings.
this is particularly challenging when the numberof spawned goroutines and or the capacity of channels areunknowns as the programmer has to think of how differentvalues will affect the possible executions.
our main insight to verify these programs in a scalable way is to first identify the parameters which directlyaffect their concurrent structures e.g.
trees n and runtime.numcpu in example .
given such parameters we extract parameterised models from go code which arethen verified using bounded model checking.
we use spinas a back end but our approach is not necessarily boundto it.
given a user defined set of values we model checkevery possible instantiation of a parameterised model.
our toolreturns the result of each verification as well as an aggregatescore that helps distinguishing false alarms from real bugs.
contributions iii describes a novel algorithm to extract parameterised behavioural types from go code.
iv describes a bounded model checking technique to verify these behavioural types.
we have implemented these algorithms ina tool gomela outlined in v. in vi we give a thorough experimental evaluation of gomela against related work .
out of real world buggy programs weshow that gomela detects bugs at least .
more than other tools .
additionally we demonstrate the scalabilityof our approach using most starred go repositories fromgithub.
ii.
p reliminaries we review key aspects of the go programming language and give a brief overview of spin and promela the modelchecker and language we use to verify go programs .
a. go programs and their properties a go program consists of a list of declarations of functions structures struct on which one can define methods and interfaces i.e.
sets of method signatures which can beimplemented by structures .
the special function main is the entry point of the program.
go is known for its distinctive support for concurrent programming advocating for message passing instead of sharedmemory.
go natively supports channels chan over whichlightweight threads a.k.a.
goroutines coordinate their tasks.the standard library also offers two popular concurrencyprimitives waitgroups and mutexes.
figure gives an overview of the control flow constructs and concurrency operations of interest in this work.
the firstpart of the figure lists control flow constructs.
call f a is a blocking call to function f while gof a spawns function f in a concurrent thread of execution.
by convention we write afor a possibly empty sequence a1 ... a k withk .
conditionals if then else and traditional iterations for loops are standard.
note that while loops do not exist in go.
go additionally provides constructs to range over collections orchannels.
a fori x rangel s block executes sfor eachxinl iis bound to the index of xin the collection .
a forx range ch s block executes sfor every message received from ch and exits when ch is closed and empty.
instruction ch make chan t e creates a new channel ch of capacity e an integer expression .
a channel carries a single type t of messages.
if eevaluates to the channel is synchronous both send and receive actions areblocking otherwise it is asynchronous send actions are non blocking as long as the channel has not reached full capacity .instruction ch esendseonch while chreceives from ch.
invoking close ch closes ch.
receiving on a closed 1017f a call fwith arguments a gof a spawn fwith arguments a ifethens1elses2 conditional fori e1 e2 r s for loop fori x rangel s iteration over collection l forx range ch s iteration over channel ch ch make chan t e declare a chan.
with capacity e ch e sendeover ch ch receive on channel ch close ch close channel ch select case i si i i guarded choice var wgsync.waitgroup declare a waitgroup wg wg.add e addetowg wg.done decrement wg by1 wg.wait wait until wg reaches var musync.mutex declare a mutex mu var musync.rwmutex declare a rwmutex mu mu.lock lock mutex rwmutex mu.unlock lock mutex rwmutex mu.rlock lock for read access mu.runlock unlock read access fig.
key statements in go some may be blocking and or may trigger a run time error .
channel is non blocking but sending on or closing a closed channel triggers a runtime error.
a select statement allows a goroutine to wait for several operations e.g.
send receiveon a channel .
it blocks until one of its cases succeeds thenexecutes the corresponding branch.
a select statement may contain a default branch which is executed if all other branches are blocked.
instruction var wgsync.waitgroup creates a new waitgroup wg.
operation wg.add e addse which evaluates to a positive or negative integer to the waitgroup s counter while wg.done decrements the counter by .
operation wg.wait blocks until wg s counter reaches .
a waitgroup whose counter becomes negative triggers a runtime error.
go s standard library provides mutex andrwmutex.
the former is used to protect a critical section with exclu sive access i.e.
both writers and readers use mu.lock and mu.unlock .
the latter allows several readers to access a critical section but at most one writer .
read ers use mu.rlock and mu.runlock .
both primitives trigger a runtime error when invoking mu.unlock or mu.runlock on an unlocked mutex.
concurrency bugs in go we distinguish between blocking bugs and safety bugs.
blocking bugs occur when a goroutine is permanently stuck waiting for a blocking operation to succeed e.g.
a receive waiting for a message to be sent.
potentiallyblocking operations are marked with in figure .
blocking bugs are often referred to as goroutine leaks in the go community.
blocked goroutines may notably cause the wholeprogram to get stuck global deadlock or lead to memoryleaks as they cannot be garbage collected see example .
safety bugs occur when an operation is unexpectedly invoked on a concurrency primitive and triggers a run time er ror e.g.
sending on a closed channel causes a run time error.operations that may trigger a run time error are marked with1func main var wg sync.waitgroup somelist int for range somelist go func wg.done may trigger a run time error wg.add wg.wait fig.
negative counter bug adapted from .
in figure .
observe that all three concurrency primitives we consider can trigger such errors.
example .
figure adapted from kubernetes shows a typical safety bug.
this program spawns several worker goroutines.
each goroutine invokes wg.done once they have completed their job.
however the parent threadinvokes wg.add after spawning each goroutine.
in an execution where e.g.
the first worker goroutine finishes its jobquickly it may decrement wg before it is incremented thus may trigger a run time error panic sync negativewaitgroup counter .
f ocus of this work for the sake of space and clarity the core of this paper focuses on the subset of go identified byfigure .
we explain how our tool handles additional features e.g.
structs methods and anonymous functions in v. our aim is to develop a technique that is sound for a well understood subset of go.
the language features ourapproach does not currently support are programs that recursively spawn goroutines or create concurrency primitives virtual method calls higher order functions mutable mutatedconcurrency primitives e.g.
channel variables that are re assigned and collections containing concurrency primitives.
b. promela as a behavioural type language the crux of our technique is to over approximate go programs with behavioural types where each go function is assigned a type codifying its interactions with concurrencyprimitives thus abstracting away from non concurrencyrelated constructs but preserving the concurrent behaviours.our approach has three key differences compared to earlierworks.
i we use a subset of promela the language of spin as our behavioural type language.
this has the advantage ofgiving us a direct implementation strategy while keeping theextraction function relatively abstract.
the model extractionwe present in iii can easily be adapted to other modellinglanguages that feature processes communicating over chan nels.
ii while the work in and its extensions abstract away from all computational aspect our behavioural types do keep track of some data when it directly affects the structure of the concurrent programs.
iii we support the threemain concurrency primitives of go.
spin verifies models specified in promela wrt.
properties expressed in linear temporal logic l tl .
a promela 1018model consists of a set of processes that interact over channels.
promela processes are declared using proctype f p s where fis the name of the process pis a list of typed parameters and sis a list of promela statements.
promela statements and expressions include basic boolean and arithmetic expressions as well as declarations and instanti ations of variables and structures.
statement run f e spawns a new instance of process fwith arguments e. channels are a special data type over which processes can communicate.
forexample chan c of bool creates a new channel c with capacity 2that can carry boolean values.
like goroutines in go processes may send expressions angbracketleft e angbracketrightover channel ch with ch!
angbracketlefte angbracketright.
they can receive messages with ch?
angbracketleftx angbracketright which binds the received values to variables x. we omit the payload angbracketlefte angbracketrightof a send receive when it is not relevant.
promela provides two types of control flow constructs loops and branching.
loop for n..m s repeats statements sform n iterations.
branching constructs encode possibly non deterministic choices between several behaviours.promela uses if anddo constructs to encode choices but we use a graphical automata statechart like notation in this paperfor the sake of readability.
the branches of a choice may beguarded or not.
a guarded branch is labelled with or s wheregis a guard boolean expression is either a send or receive action and sis a promela instruction.
a guarded branch is fireable when its guard gholds and a matching event for is available if is specified .
upon firing instruction sis executed.
unguarded branches labelled with can fire silently at any point.
spin checks properties of promela models that are encoded either via an l tl formula and or using assertions error states in the model.
spin checks that all possible executions ofthe model validate the l tl formula and or that no executionreaches an error state.
spin explores all possible states of amodel hence models must be finite state e.g.
they cannot spawn infinitely many processes.
iii.
e xtracting p arameterised models we describe our approach to extract several models from a go program.
for each go function that does not take a concurrency primitive as parameter we generate a model.
eachfunction becomes an entry points to a model that can beverified independently.
this strategy allows us to decomposethe verification of large programs into smaller pieces.
besidesthe benefit wrt.
scalability this decomposition allows our toolto detect some partial deadlocks and to give function levelfeedback when a bug is detected by the model checker.
the model extraction is done via three procedures i a top level procedure translates declarations of go functionsto promela processes ii procedure e s s identifies the concurrency parameters in go statements s iii procedure ts s extracts a parameterised model from go statements s. the models we generate consists of two types of promela processes a primitive processes which model concurrency primitives channels waitgroups mutexes and b function processes which model go functions and goroutines.a.
extracting concurrency parameters our goal is to identify the computational elements of a function that affect its concurrent structure i.e.
integerexpressions in the source program that affect the number ofspawned goroutines the number of exchanged messages andthe values held in the counters of waitgroups.
we define function e e e which extracts the concurrency parameters from a go expression e by computing its free variables and other unknown