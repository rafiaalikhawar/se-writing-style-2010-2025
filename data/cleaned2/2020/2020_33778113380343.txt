tailoring programs for static analysis via program transformation rijnard van tonder school of computer science carnegie mellon university usa rvt cs.cmu.educlaire le goues school of computer science carnegie mellon university usa clegoues cs.cmu.edu abstract static analysis is a proven technique for catching bugs during software development.
however analysis tooling must approximate both theoretically and in the interest of practicality.
false positives are a pervading manifestation of such approximations tool configuration and customization is therefore crucial for usability and directing analysis behavior.
to suppress false positives developers readily disable bug checks or insert comments that suppress spurious bug reports.
existing work shows that these mechanisms fall short of developer needs and present a significant pain point for using or adopting analyses.
we draw on the insight that an analysis user always has one notable ability to influence analysis behavior regardless of analyzer options and implementation modifying their program.
we present a new technique for automated generic and temporary code changes that tailor to suppress spurious analysis errors.
we adopt a rule based approach where simple declarative templates describe general syntactic changes for code patterns that are known to be problematic for the analyzer.
our technique promotes program transformation as a general primitive for improving the fidelity of analysis reports we treat any given analyzer as a black box .
we evaluate using five different static analyzers supporting three different languages c java and php on large real world programs up to 800kloc .
we show that our approach is effective in sidestepping long standing and complex issues in analysis implementations.
acm reference format rijnard van tonder and claire le goues.
.
tailoring programs for static analysis via program transformation.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction writing and maintaining high quality bug free software remains a largely manual and expensive process.
static analysis has proven indispensable in software quality assurance for automatically catching bugs early in the development process .
a number of open challenges underlie successful adoption and integration of static permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .. .
.
in practice.
analyses must approximate both theoretically and in the interest of practicality .
developers are sensitive to whether tools integrate seamlessly into their existing workflows at minimum analyses must be fast surface few false positives and provide mechanisms to suppress warnings .
the problem is that the choices that tools make toward these ends are broadly generic and the divergence between tool assumptions and program reality i.e.
language features or quality concerns can lead to unhelpful overwhelming or incorrect output .
tool configuration and customization is crucial for usability and directing analysis behavior.
the inability to easily and selectively disable analysis checks and suppress warnings presents a significant pain point for analysis users .
common existing mechanisms include analysis options for turning off entire bug classes generally too coarse or adding comment like annotations that suppress spurious warnings at particular lines a predominantly manual exercise that leads to code smells and is insufficiently granular .
it is notably the analysis author not the user who has agency over the shape of these analysis knobs which configuration options are available and how to suppress errors.
it follows that it is infeasible for analysis writers to foresee and accommodate individual user preferences or analysis corner cases through a myriad of configuration options or suppression mechanisms.
ananalysis user always has one notable ability to influence analysis behavior and output modifying their program.
for example developers may slightly modify existing code in a way that suppresses false positives or undesired warnings.
a concrete example is the following change which was made in rsyslog1to suppress a clang static analyzer warning if strcmp rectype end clang static analyzer work around const char const const end end if strcmp rectype const end the analyzer warns that a potential out of bounds access occurs when comparing two strings using strcmp .
however the warning only surfaces when complex macro expansions take place in this case macro expansion activates for strcmp because the second argument is a string literal .
one contributor notes that under normal circumstances these warnings are suppressed for macros but can surface if macro preprocessing is done manually.2the workaround in this case extracts the string literal out of the strcmp call so that no macro expansion takes place.
after the change the analyzer sees strcmp as a c library function and no longer emits a warning.
ieee acm 42nd international conference on software engineering icse in practice modifying programs to avoid analyzer issues are exercised as manual one off changes.
changes like the one above can have the undesirable side effect of persisting in the code solely to suppress unwanted analysis warnings.
despite these shortcomings modification of the analysis target the program does however allow a primitive for analysis users to draw on their particular domain knowledge of their code to positively influence analysis behavior.
for example a developer may recognize that a particular api call is the cause of a false positive resource leak and modify or model the call differently to suppress a false positive.3our technique in particular affords agency to analysis users to change and suppress analysis behavior when no recourse is available in tool support e.g.
when analysis maintainers delay fixing analysis issues or limit tool configuration options .
our insight is that the same flavor of oneoff manual code changes like the one above can apply generally and automatically to remedy analysis shortcomings.
additionally workaround changes need not have the undesirable trait of persisting in production code and are applied only temporarily while performing analysis.
we propose a rule based approach where simple declarative templates describe general syntactic changes for known problematic code patterns.
undesired warnings and false positives are thus removed during analysis by rewriting code fragments.
our approach can be seen as a preprocessing step that tailors programs for analysis using lightweight syntactic changes.
it operates on the basis of temporary suppression a desirable trait in configuring analyses and also enables catching false positives before they happen by rewriting problematic patterns.
since patterns can occur across projects codifying transformations as reusable templates amortizes developer effort for suppressing false positives.
the notion that syntactic transformations abstract semantic transformations underpins our intuition that manipulating syntax can achieve desirable changes in the analysis domain and implementation.
work on semantic properties of transformations emphasize the potential for improving analysis precision and recent work suggests that automatic bug fixing transformations can improve analysis results in popular real world programs .
despite anecdotal and theoretical appeal for tailoring analyses via transformation there is currently little demonstrated applicability or benefit in practice.
a key objective of our work is to demonstrate the broad feasibility applicability and effectiveness of these ideas for the first time in practice.
to this end we evaluate on large real world programs written in a variety of popular languages.
a significant challenge lies in recognizing and transforming syntactically diverse languages for such an approach to work.
recent techniques in declarative syntax transformation help to address this challenge and forms the basis for operationalizing our approach.
we address analysis issues broadly by considering a user reported false positives across multiple active analyzers and b historic user commits for suppressing analysis warnings.
we develop transformations that tailor programs to address shortcomings in analysis implementation and reasoning.
our contributions are as follows we operationalize the process of tailoring programs for static analysis using declarative syntax rewriting.
1function test void if file fopen file wb false return analyzer complains that file may be false if fputcsv file false fclose file return ... fclose file a assigning the result of fopen to file in line confuses the analyzer.
it doesn t track the effect that file is not false on line and emits a false positive warning that file may be false when passed to putcsv.
1function test void file fopen file wb if file false return ... b an analysis user proposed this workaround extract the assignment out of the conditional.
this allows the analyzer to correctly track the assignment effect and does not emit a false positive.
unfortunately this approach is hard to blanket apply automatically and diverges from developer preferences who prefer the former style for readability.
figure variable assignment inside if statements can cause a false positive report in phpstan.
a workaround is to put the assignment outside of the if conditional.
we show that our approach is effective in improving existing static analyses and resolves real including yet unresolved false positive issues affecting analysis users.
we show that our approach is efficient transformation typically takes one to three seconds compared to analyses that typically take in the order of minutes we present empirical results of our approach on realworld projects including large ones 100kloc across three languages php java and c and develop transformation templates for improving the analysis output of five modern and active analyzers clang infer phpstan spotbugs and codesonar .
motivation fig.
2a illustrates a past issue in phpstan a popular php analyzer.
a file is opened in line and assigned to a handle file inside the if condition on line .
if opening the file fails file is assigned the value false the condition evaluates to true and the function immediately returns line .
on the other hand if execution passes the check then file is guaranteed to be valid i.e.
not false .
the problem is that phpstan would not track the effect of assignments inif conditions and reports an error saying that file may be false when passed as an argument to fputcsv on line .
825the issue for this false positive stayed open and unresolved for over a year on github and is cross referenced in related user reported issues.4one project member responded that the issue is important and will be fixed in the future but that no one has yet figured out how to implement it without rewriting major part of the analysis core .
the fix imposed significant effort on analysis authors which delayed a resolution for months.
although some analysis authors were in favor of code that avoided assignments in conditionals others found the style improves readability.
multiple users noted that the false positive can be avoided by a code change that extracts the assignment out of the conditional .5however one user also noted that this workaround was a bit annoying because it introduced redundancy.
the proposed workaround also imposes a burden on the user to identify and refactor all affected instances.
our approach introduces a new way to address these tensions.
the intuition is that workarounds via code changes as in fig.
2b cangeneralize to cater for individual user preferences and overcome long standing analysis issues.
the high level idea is to write simple declarative syntactic templates that can blanket apply automatically over an entire code base.
although the code changes could be persisted in the code they need not be our approach foremost promotes code changes as a temporary suppression mechanism with respect to a particular analysis.
in our approach a match template specifies a pattern that is syntactically close to the problematic pattern in fig.
2a if false arewrite template replaces all instances of the match template extracting the assignment out of the if condition.
the rewrite template is syntactically close to the pattern suggested by the user in fig.
2b if false the match template matches on the syntactic pattern where variable vis assigned the return value of calling a function fnwith arguments args the notation binds matching syntax to a variable identifier .
all other syntax is matched concretely whitespace in the template matches all contiguous whitespace in the source code.
for illustration we use this template to match on function call syntax because the analysis particularly tracks values for modeled functions like fopen .
the rewrite template