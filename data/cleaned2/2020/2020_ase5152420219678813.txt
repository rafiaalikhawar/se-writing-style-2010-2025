rulf rust library fuzzing via api dependency graph traversal jianfeng jiang hui xu y angfan zhou school of computer science fudan university shanghai china.
shanghai key laboratory of intelligent information processing shanghai china.
email jfjiang19 xuh zyf fudan.edu.cn abstract robustness is a key concern for rust library development because rust promises no risks of undefined behaviors if developers use safe apis only.
fuzzing is a practical approachfor examining the robustness of programs.
however existingfuzzing tools are not directly applicable to library apis dueto the absence of fuzz targets.
it mainly relies on humanefforts to design fuzz targets case by case which is labor intensive.
to address this problem this paper proposes a novelautomated fuzz target generation approach for fuzzing rustlibraries via api dependency graph traversal.
we identify severalessential requirements for library fuzzing including validity andeffectiveness of fuzz targets high api coverage and efficiency.to meet these requirements we first employ breadth first searchwith pruning to find api sequences under a length threshold thenwe backward search longer sequences for uncovered apis andfinally we optimize the sequence set as a set covering problem.we implement our fuzz target generator and conduct fuzzingexperiments with afl on several real world popular rustprojects.
our tool finally generates to fuzz targets for eachlibrary with api coverage up to .
.
we exercise each targetwith a threshold of hours and find previously unknownbugs from seven libraries.
index t erms fuzzing program synthesis rust i. i ntroduction rust is an emerging programming language that promotes memory safety features while not sacrificing much performance.
it promises developers that their programs would notsuffer undefined behaviors if they do not use unsafe code.meanwhile the language embraces many novel features andbest practices of other programming languages such as smartpointers and raii resource acquisition is initialization .due to these advantages rust has surged into popularity inrecent years and has been adopted by many academicprojects e.g.
redleaf theseus tock and industrial ones e.g.
intel cloud hypervisor vmm tidb occlum .
although rust provides specially tailored mechanisms at the language level to enhance security many severe bugs arestill reported in existing rust projects.
in particular advisory db and trophy case are two well known publicrepositories with hundreds of bugs found in rust projects.
aninteresting phenomenon of these bugs is that most of their hostprograms are libraries .
such bugs can only be triggeredby composing a program with a specific usage of the libraryapis.
since rust emphasizes software security and robustness it is essential to hunt these library bugs.
unfortunately we stilllack effective tools for examining the robustness of apis.
forexample fuzzing and symbolic execution generallyrequire executable problems formal verification cannot befully automated for third party library apis.
in this paper we aim to bridge the gap between rust library fuzzing and existing fuzzing tools.
fuzzing is a widely adoptedtesting method that exercises a program by automaticallygenerating inputs in a random or heuristic way.
however a major problem confronted by rust library fuzzing is theabsence of fuzz targets.
a fuzz target defines an array ofbytes as input for executing a program composed with somelibrary apis .
fuzzing tools can mutate the input of fuzztargets to explore different paths.
existing fuzzing tools suchas afl honggfuzz and libfuzzer all requirefuzz targets for library fuzzing and writing fuzz targets mainlyrelies on human efforts.
fudge is a recently proposedfuzz target generator for c c programs by extracting codesnippets from google code bases.
however its effectivenesslargely depends on the library usage and suffers substantiallimitations.
for example it is not applicable to newly releasedlibraries or apis or it cannot generate fuzz targets for unusedapis but bugs may relate to rarely used features.
this paper investigates an automated fuzz target generation approach.
our approach pursues four objectives validity which means the program should be successfully compiled effectiveness which means the fuzz targets should be friendly to fuzzing tools in reaching high code coverage or bug finding coverage and efficiency meaning the fuzz targets should cover as many apis as possible and their set should be as small aspossible.
to ensure validity we compose fuzz targets based onthe api dependency graph of a given library.
since each fuzztarget can be viewed as a sequence of api calls we breadth first search bfs api sequences under a length threshold onthe graph.
for each uncovered api deep api due to thelength limitation we backward search their dependent apisequences.
finally we refine our set of sequences to obtain aminimum subset that covers the same set of apis.
we implement a fuzz target generator rulf .
given the api specification of a rust library it can generate a set offuzz targets and seamlessly integrated with afl forfuzzing.
we conduct experiments with popular rust li braries including three from github and eleven from crates.io 1the acronym of ru stlibrary fuzzing 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee the official rust crate registry .
with a depth bound of three for bfs we generate fuzz targets for each library.further we fuzz each target with a budget of hours andfind previously unknown bugs in seven libraries.
we summarize the main contributions of this paper as follows our work serves as a pilot study to automatically generatefuzz targets for rust libraries.
it extends the applicabilityof existing fuzzing techniques and such extension isurgently needed by rust considering its intolerance ofundefined behaviors.
our proposed approach leverages a sophisticated traversalalgorithm which can achieve high api coverage withonly a small set of shallow fuzz targets.
such an approachis proven effective and efficient.
it can shed light tofurther investigation on code traversal.
we have implemented an open source prototype fuzztarget generator for rust libraries .
with the tool we successfully find previously unknown bugs in sevenpopular rust libraries.
the rest of our paper is organized as follows.
section ii presents our motivation and research goals.
we defineapi dependency graph and introduce our proposed traversalalgorithm in section iii followed by the implementation of ourprototype tool in section iv.
section v presents our evaluationexperiments.
section vi reviews related work.
we concludeour paper in section vii.
ii.
p roblem of rust library fuzzing a. motivating example as rust surges into popularity many bugs of projects written in rust have been reported and analyzed such asthose collected in advisory db and trophy case.
a specialcharacteristic of these bugs is that most of them are located inlibraries .
note that testing libraries is very different fromtesting executable programs.
for library testing developersshould compose their use cases of library apis before testingthem or base the testing on unit tests.
since there could bedifferent ways or contexts of using an api library testing ismore challenging.
figure a demonstrates a library bug 3found in a rust crate just.
the term crate represents the minimal compilation unit in rust.
in this paper we call a rust library a crate.
the bug lies in the method justfile which is defined on a struct parser.
the method justfile uses a thirdparty data structure putback to store tokens.
in the buggy code the first two statements fetch two tokens and the nexttwo statements put the two tokens back via put back .
however put back can put only one single item back each time.
if putting two items back the first item will beoverwritten.
as a result justfile may parse an input string incorrectly and panic the application.
the patch simply 2rulf is publicly available on 3issue link the struct putback with another one putbackn that allows putting back multiple items.
a the bug detail.
use just token lexer parser justfile let input export aa let tokens vec token lexer lex input ?
let parser parser parser new input tokens let justfile justfile parser.justfile ?
b code to reproduce the bug.
fig.
.
an example bug in rust crate just.
this bug had existed in the crate for over versions before it was found by a fuzzing tool.
reproducing the bug requires composing a testing program for justfile and some specific test cases.
to this end the testing programshould create a parser object via parser new str vec token and vec token can be created by callinglexer lex .
figure b presents a sample testing program based on the analysis.
specifying export aa as thevalue of input would crash the program.
b. challenge of fuzz target generation to fuzz a library program we need a set of testing programs as fuzz targets.
such testing programs are similar to thosediscussed in figure .
however how to automatically generatesuch testing programs is a challenging problem.
note thatthere could be dozens or even hundreds of apis for a libraryprogram and the fuzz targets should consider each api.
taking the library in figure2 a as an example.
the crate toylib has two structs s1 ands2 and five public apis f1 tof5 .
we may design one specific fuzz target for each api or a large target that covers all apis or two potential fuzztargets figure b and figure c that can cover all apisusing each api only once.
such options are essential factorsaffecting the effectiveness and efficiency of library fuzzing.
below we discuss four objectives for the fuzz target generation problem.
validity the synthesized fuzz targets should be able to be successfully compiled i.e.
all the parameters of each api should be correctly settled.
rulf achieves thisobjective by traversing the api dependency graph.
582struct s1 struct s2 fn f1 a i16 s1 fn f2 b u32 s2 fn f3 c s2 fn f4 s1 s1 s2 mut s2 s2 fn f5 s2 s2 d str a a toy rust crate toylib.fn fuzz target 1 for toylib data if data.len return let a to i16 data let c to slice u8 data data.len let s1 toylib f1 a let mut s2 toylib f3 c let toylib f4 s1 mut s2 b fuzz target .fn fuzz target 2 for toylib data if data.len return let b to u32 data let d to str data data.len let s2 toylib f2 b let toylib f5 s2 d c fuzz target .
fig.
.
a sample problem for fuzz target generation.
api coverage for a library program each of apis has a potential to contain bugs.
therefore the set of generated fuzz targets should cover as many apis as possible.
efficiency the set of generated fuzz targets should be efficient for fuzzing.
on the one hand the number offuzz targets should be manageable since fuzzing eachtarget generally requires several hours.
on the other hand we should avoid employing the same precedent apis indifferent fuzz targets if possible because fuzzing the sameapi multiple times may not be helpful.
effectiveness the generated targets should be friendly to fuzzing tools for bug hunting.
in order to fuzz anapi effectively the generated program should be small.otherwise the fuzzing effort would be wasted on thetesting program or other apis rather than the target api.
iii.
a pproach we model the problem of fuzz targets generation as an api dependency graph traversal problem.
this section first definesthe api dependency graph and then introduces our traversalalgorithm.
a. api dependency graph if the return value of one api and the parameter of another api are of the same type we can synthesize a valid program that call the second api with the return value of the first apias the parameter.
in other words we say there is one possibledata flow dependency between the two apis.
informally anapi dependency graph is a directed graph that captures allsuch possible data flow dependencies among the apis of acrate.
formally we define an api dependency graph as a directed graph g fn m pa r n pe p ce q over a set of apis where fn m api nodes corresponds to all mapis in pa r n parameter nodes corresponds to a subset of api parameters in excluding those of primitive types.
we do not consider primitive types because they can be providedby fuzzer engines.
pe p producer edges fn m pa r n where an edge fni par jimplies fnireturns a value of type or can be inferred as type par j. ce q consumer edges pa r n fn m where an edge par i fnjimplies par iis a non primitive parameter for fnj.
the edge is weighted if fnjrequires multiple par is as its parameters.
fig.
.
an api dependency graph of crate toylib.
we introduce parameter nodes into the graph to better distinguish two types of dependencies an api requires two pa rameters returned by both two apis fn i par j fni par j and an api requires one parameter returned by either of the two apis fn i par j fni par j .
figure demonstrates the api dependency graph for toylib discussed in figure a .
the graph contains five api nodesfn f1 f2 f3 f4 f5 and two parameter nodes pa r s1 s2 .
s1 ands2 are two non primitive type parameters required to call f4 s2 is one non primitive type that can be produced by either f2 orf3.
we further define two kinds of special api nodes start node that consumes no non primitive parameters and end node that returns no non primitive values.
in figure f1 f2 f3 are start nodes and f5 is an end node.
f4 is neither a start node nor an end node.
besides an api node can be both a startnode and an end node.
b. v alidity of api sequence on an api dependency graph an api node is reachable if and only if it is a start node or all its required parameter nodes are reachable and the weights of consumer edges are satisfied.similarly a parameter node is reachable if at least one apinode that can produce the parameter is reachable.
we say an api sequence fn ... fn kis valid if fn0 is a start node and each fni i k is reachable given the subsequences of fn0 ... fn i .
this is an essential requirement for synthesizing valid fuzz targets.
for example f2 f5 is a valid sequence in figure f1 f4 is invalid because s2 is not reachable for reaching f4.
note that our definition of a valid api sequence does not enforce a precedence relationship between each pair ofadjacent api nodes.
in this way a sequence with duplicated 583subsequences or duplicated apis or with multiple end nodes can also be valid.
this is essential to deal with the movesemantics in rust.
briefly move semantics mean the returnvalue can be used only once.
if an api has two parametersof the same type we may call f1 twice to serve the two parameters.
therefore f1 f1 is also a valid sequence.
c. api sequence generation we generate valid api sequences by traversing the api dependency graph.
according to the objective of fuzz targetgeneration discussed in section ii b. the algorithm shouldmeet three objectives api coverage efficiency and effective ness.
to this end we first employ bfs with pruning to obtaina set of api sequences that can cover the maximum numberof apis given a length threshold next we backward searchvalid sequences for uncovered apis with lengths larger thanthe bfs threshold.
finally we merge the two sets as one andfurther refine it to remove redundancies.
bfs with pruning we choose bfs as a basic algorithm to generate valid sequences because fuzzing prefers shortsequences.
other traversal algorithms like random walk arenot suitable.
algorithm introduces our basic algorithm.
the main part of the algorithm is a while loop line that iterates overthe length of the generated sequences and terminates oncereaching a threshold.
we start from a set with an emptysequence.
in each iteration we extend the sequences of lengthi with one more api node to generate new sequences line .
to ensure validity we perform reachabilitytest line for each candidate api as discussed in section iii b.besides we employ an endnodetest function line and a redundancytest function line to optimize the sequence generation algorithm.
theendnodetest function intends to terminate one thread earlier once it reaches an end node.
if we continuouslyappend new apis to a sequence with an end node theremust be another different sequence which is the same lengthand contains the same set of apis and producer edges.
forexample f2 f5 is a sequence of toylib and f5 is an end node.
if we append another api f3 to the sequence we will get f2 f5 f3 which contains the same set of apis and producer edges with another equal length sequence f2 f3 f5 .
for such cases our algorithm will generate f2 f3 f5 only and prune f2 f5 f3 as redundant.
theredundancytest function is designed to filter another type of redundant sequences.
such sequences contain anapi in the middle of the sequence that is not the dependencyof any following api.
for instance f1 is such an api in the sequence f3 f1 f5 .
the sequence is redundant since bfs has already generated another two shorter sequences f1 and f3 f5 that contain the same apis and producer edges.
for such cases our algorithm will generate f1 and f3 f5 and prune f3 f1 f5 as redundant line in algorithm .
backward search bfs with a threshold of sequence length cannot cover apis that require longer sequences deep algorithm bfs with pruning.
input a graph g fn pa r pe ce sequence length threshold max len output a set of sequences sbfs 1init 2sbfs snew 3slast empty sequence 4i 5bfs with pruning while i max len do forseq inslast do ifendnodetest seq then continue forfn ing fn do ifreachabilitytest g seq fn then new seq seq .append fn snew .add new seq sbfs .append s new slast snew snew i i forseq insbfs do ifredundancytest seq then sbfs .remove seq apis .
for example an api that accepts several parametersmay need a long call sequence to satisfy each parameterrequirement.
we observe that after running bfs with anarbitrary threshold three only a few apis cannot be covered.to reach these apis continuously searching for longer validsequences with bfs would be inefficient.
however we cansearch the dependencies for these remaining uncovered apisbackward.
for each uncovered api our backward search approach finds its parameters directly based on already generated se quences.
for toylib after performing bfs with a threshold one we will generate three sequences f1 f2 f3 .
then we backward search for the dependencies of f4 which ares1 ands2.
to produce s1 ands2 we can find a producer edge from f1 tos1 and another producer edge from f2 tos2.
since all parameters of f4 are satisfied we can generate a new sequence f1 f2 f4 covering f4.
similarly we can generate a sequence f2 f5 covering f5.
we perform backward search iteratively until no more apis can be covered.
merge and refine now we merge the sequence sets generated by bfs and backward search and refine the set.the goal of our refinement is to select a minimum subset ofsequences offering equivalent api coverage.
this is in generalaset covering problem scp which is np complete.
to solve the problem we employ a greedy algorithm .
our algorithm selects a sequence that contributes most to thecoverage until all apis are covered.
in particular we prefer acandidate sequence a over b based on the following rules.
fig.
.
overview of our workflow.
a covers more new nodes than b. a and b cover the same number of new nodes but acovers more new edges than b. a and b cover the same number of new nodes and edges but a is shorter than b. if there are multiple sequences with equal contribution based on the above rules we randomly select one from them.
suppose f3 and f3 f5 are two candidate sequences for selection.
if f5 or the production edge from f3 tos2 the parameter node of f5 has not been covered we select f3 f5 because it contributes more to coverage.
otherwise we select f3 because it is shorter.
after applying all the sequence generation steps to toylib we finally obtain two sequences as shown in the boxes infigure b and c or two similar sequences .
iv .
i mplementa tion we implement a prototype tool rulf to automatically generate fuzz targets for rust libraries.
our tool is based onrust .
.
dev and contains about 6k lines of rust codes.
figure overviews the workflow of rulf that inputs a rust lib crate and outputs a set of fuzz targets.
there arethree essential components.
the first is to construct an apidependency graph based on api signatures.
the second is togenerate valid sequences by traversing the graph.
the thirdis to synthesize rust programs ready to compile from validsequences.
next we discuss the implementation details of each component.
a. construct api dependency graph we construct an api dependency graph in two stages.
first we extract all public api signatures from the source code.
we base rulf on an existing tool rustdoc which is an official doc tool to generate api documentation for rustprojects.
internally rustdoc calls rust compiler to compile thecrate and extract api information from the compilation results.we directly add our codes into librustdoc.
after we extract all public api signatures we infer dependencies among apis based on type inference to builddependency graph.
we define call type for type inference.
ifthere is a call type from type a to type b a and b are thesame type or a can be converted to b. all call types can beseen in table i. note that call types can be nested e.g.
there is a call type from option t to t which is borrowed reference unwrap option .
table i call types for type inference .t e are any rust type .
call type example direct call t t borrowed reference t t mutable borrowed reference t mut t const raw pointer t const t mutable raw pointer t mut t dereference borrowed reference t t dereference raw pointer const t t unwrap result result angbracketleftt e angbracketright t unwrap option option angbracketleftt angbracketright t to option t option t call types defined in table i can be divided into two categories.
the first seven are general call types from direct call todereference raw pointer .
the last three are specific call types for two types result andoption from unwrap result toto option .
result andoption are two heavilyused enumeration types in rust.
result is used to return recoverable errors.
option indicates a value that may be empty.
these two types are used to wrap a normal type e.g.
u8 is an bit integer type while option u8 can be a normal u8 ornone.
we can get the real u8 type by unwrapping option u8 if it is not none.
if these two types are not specially treated it will greatly affect the validity oftype inference.
more wrapper types can be treated specially e.g.
box.
special treatment of these types helps infer dependencies moreaccurately.
rulf can support this by adding a new call type.
b. generate api sequences after we construct an api dependency graph we generate valid sequences by traversing the graph.
the main approach is mentioned in the previous section.
here are more details.
api dependency graph can only capture all possible data flow dependencies but this is not enough for generating allpossible sequences.
figure demonstrates such a case.
since 585the return value of toylib f4 is never used this sequence will be removed by redundancyt est in previous section.
however toylib f5 uses the variable mutated by f4.
so toylib f4 is not a redundant api.
let s1 toylib f1 let mut s2 toylib f2 let toylib f4 s1 mut s2 f4 mutates s2let toylib f5 s2 a f5 uses the variable mutated by f4 fig.
.
a mutation case on crate toylib.
to deal with this case we integrate endnodet est and redundancyt est with mutation analysis.
if an api has no return value or returns a primitive type it is an end node according to the definition in the previous section.
however ifthe api can mutate the value of a variable like setter methodsin java it is not appropriate that we treat this api as anend node.
the endnodet est is based on the fact that the api behind an end node can exchange orders with other endnodes.
this fact does not hold if the end node can mutate thevalue.
so we redefine an api that satisfies the following tworequirements as an end node the api has no return valueor returns a primitive type.
the api does not mutate thevalue of any variable that another api returns.
we modify redundancyt est similarly if neither the return value of an api nor variables whose values are mutated bythis api are used by other apis this api can be called a deadnode.
sequences containing such a dead node are redundantand can be filtered.
determining whether an api can mutate a value in rust programs is easy.
rust has a keyword mut.
only if the parameter of an api is modified with the keyword mut t h e api has the ability to mutate a value e.g.
toylib f4 can mutate the value of s2 .
after modifying the definitions of endnodet est andredundancyt est we can still use the algorithms in the previous section.
interior mutability in rust allowing unsafe code in a function to mutate the value of aparameter even if the parameter is not modified with mut may affect the effectiveness of mutation analysis.
however interior mutability does not affect the validity of sequencesgenerated by rulf.
so we ignore the limitation in the currentimplementation of rulf.
to generate sequences that can pass the compiler s check we take rust s language features into account.
ownership isrust s most unique feature.
in rust each value has only onevariable as its owner which has the exclusive ownership ofthe value.
the ownership can be transferred among variables which is called move.
if a variable transfers the ownership the variable cannot visit the value anymore.
figure demon strates a simple move case.
s1 defined in line is used by toylib f4 in line .
s1 transfers the ownership in line .
we cannot use s1 in line any more otherwise it will report a compilation error.
passing a value to a function may result in the value moved or copied so we should distinguish between moving andcopying cases.
if a value is moved we add a tag to thevariable which owns the value and do not use this variablein the following statements.
whether a value moves dependson the combination of call type and variable type.
consideringthat there are many call types call types can be nested andvariable types it is not easy to distinguish moving and copyingcases correctly.
in practice we adopt a conservative strategy.we select some combinations of variable types and call typesthat we think are commonly used in api calls and mark thesecombinations as copying cases if they do be.
for example ifthe variable type is immutable reference and the call type isdirect call we will mark this case as a copying case.
exceptfor several cases marked as copying cases we assume that allother cases are moving cases.
let s1 toylib f1 let mut s2 toylib f2 toylib f4 s1 mut s2 s1 moves.
s1 cannot be used any more.
toylib f4 s1 mut s2 compilation error!
fig.
.
a simple move case on crate toylib.
reference is also carefully dealt with.
v ariables without ownership can visit a value by having a reference.
thereare two categories of reference immutable reference sharedreference and mutable reference exclusive reference .
toavoid data race immutable reference and mutable referenceof the same value cannot coexist.
multiple mutable referencesof the same value are not allowed to coexist too.
we adda tag to variables that have a reference to make sure that therules about