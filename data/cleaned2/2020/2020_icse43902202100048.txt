automatic web testing using curiosity driven reinforcement learning yan zhengy z yi liuz h xiaofei xiez yepang liuh lei ma jianye haoy and yang liuz ytianjin university tianjin china znanyang technological university singapore hdept.
of comp.
sci.
and engr.
guangdong provincial key laboratory of brain inspired intelligent computation southern university of science and technology shenzhen china kyushu university fukuoka japan.
abstract web testing has long been recognized as a notoriously difficult task.
even nowadays web testing still heavily relies on manual efforts while automated web testing is far from achieving human level performance.
key challenges in web testing include dynamic content update and deep bugs hiding under complicated user interactions and specific input values which can only be triggered by certain action sequences in the huge search space.
in this paper we propose webexplor an automatic end to end web testing framework to achieve an adaptive exploration of web applications.
webexplor adopts curiosity driven reinforcement learning to generate high quality action sequences test cases satisfying temporal logical relations.
besides webexplor incrementally builds an automaton during the online testing process which provides high level guidance to further improve the testing efficiency.
we have conducted comprehensive evaluations of webexplor on six real world projects a commercial saas web application and performed an in thewild study of the top web applications in the world.
the results demonstrate that in most cases webexplor can achieve significantly higher failure detection rate code coverage and efficiency than existing state of the art web testing techniques.
webexplor also detected previously unknown failures in the commercial web application which have been confirmed and fixed by the developers.
furthermore our in the wild study further uncovered exceptions and errors.
i. i ntroduction the past decades have witnessed the unprecedentedly rapid development and innovation of web technologies.
nowadays web applications have become as powerful as native desktop applications.
they are competitively convenient and do not require complicated installation either.
however web applications can be difficult to test due to their complicated business logic implemented in different languages across the client and server side e.g.
html javascript c and java .
in general the more web pages are explored with more states covered the higher the possibility of discovering defects becomes.
hence various kinds of approaches have been proposed to achieve a sufficient exploration by generating test cases.
manual designing with the aid of automation frameworks such as selenium is a useful way to create test cases.
the tester is required to create test scripts simulating user corresponding author xiaofei xie.
yan zheng and yi liu contributed equally to this work and yan zheng is with the school of new media and communication in tianjin university.
35homepage unknown pages invalid operations web pages operations navigation model activate an operation fig.
.
an intuitive visualization of exploring web pages.
operations e.g.
clicking buttons and filling in forms on the web application s graphical user interface gui .
however such manual work is laborintensive and costly where the testing effectiveness heavily depends on the human testers domain knowledge.
besides web applications frequently evolve and the manually written test cases normally require substantial modifications before testing the new versions .
random based approaches generate pseudo random operations to fuzz the web applications.
despite the wide adoption in practical development the shortcomings of such approaches are obvious.
that is they often create invalid test cases like performing input operations on buttons.
also the testing is unbalanced and some hard to reach web pages may never be explored.
model based approaches build a navigation model of the web application under testing and then generate test cases accordingly by random or sophisticated search strategies.
in spite of the guidance of the navigation model existing approaches still suffer from several limitations.
firstly the constructed navigation model may cover only a part of the web application restricting the exploration power of the generated test cases.
as depicted in fig.
pages and cannot be tested as they are not included in the navigation model.
also domain knowledge is usually required in building high quality models .
besides the content of web applications is usually dynamically updated e.g.
via javascript code execution which cannot be easily captured by the static navigation models.
secondly in web applications ieee acm 43rd international conference on software engineering icse .
ieee long sequences of actions e.g.
path !
!
!
are often needed to complete certain tasks such as filling in and submitting forms.
the business logic of real world web applications can be arbitrarily complex.
for example page can be visited only when page is properly navigated.
it could be challenging for random or search based strategies to generate effective action sequences.
to address the aforementioned challenges an effective and end to end automatic testing is needed.
recently reinforcement learning rl has demonstrated its potential for learning a policy to test and interact with complicated games or android applications which provides the possibility of applying rl on automatic web testing.
however existing techniques cannot be easily adapted to test web applications for the following reasons.
firstly the testing domains are different which make the rl modeling totally different.
for example the reward function may be different.
game playing usually has concrete goals to achieve e.g.
winning the game or maximizing a score which is not the case in web testing.
the state definition and abstraction are different either.
game playing defines the state based on the outputs of apis and android testing uses an existing tool uiautomator to extract structures as the states which are both not applicable in web testing.
secondly one fundamental challenge of rl is how to perform effective exploration especially when the space of the environment is huge .
the existing techniques mainly guide the exploration with simple reward functions which could be ineffective for web applications that have complex business logic and frequent dynamic update.
thus more effective exploration is needed for rl based web testing.
considering the dynamic and highly interactive nature of web applications an effective model free web testing technology can be highly desirable.
in this paper we propose a novel web testing framework named webexplor which performs an end to end automated web testing.
webexplor leverages rl to perform an adaptive exploration of web applications and generate high quality action sequences which may be prerequisite operations e.g.
filling forms before submission for discovering new pages.
in particular webexplor performs an on the fly testing while constantly training the agent policies rather than the usual ai solutions that can only be used after training .
to achieve both high coverage and efficiency during testing we first propose the state abstraction based on the html pages.
then we propose a curiosity driven reward function which provides low level guidance for the exploration of rl such that the learned policy could explore more behaviors of the web applications.
to avoid falling into local optima especially when the learning space is huge we further propose a deterministic finite automaton dfa guided exploration strategy that provides high level guidance for rl to efficiently explore the web applications.
in particular the dfa records the transitions and states visited during the rl exploration and is continuously updated.
when rl gets stuck i.e.
cannot find a new state within a given time budget webexplor selects one path from dfa based on the curiosity timelinet0 ti... tj gid48 gid68 gid85 gid78 gid82 gid89 gid3 gid39 gid72 gid70 gid76 gid86 gid76 gid82 gid81 gid3 gid51 gid85 gid82 gid70 gid72 gid86 gid86 agentbrowseractionstate reward gid48 gid68 gid85 gid78 gid82 gid89 gid3 gid39 gid72 gid70 gid76 gid86 gid76 gid82 gid81 gid3 gid51 gid85 gid82 gid70 gid72 gid86 gid86 agentbrowseractionstate rewardfig.
.
web interactions as a markov decision process.
and guides rl to explore along this path further.
both the lowlevel guidance from the reward function and the high level guidance from the dfa play important roles in achieving effective web testing.
to demonstrate the effectiveness of our technique we implemented webexplor and conducted a large scale evaluation on a research benchmark of six realworld projects and a commercial saas web application.
we also conducted an in the wild study of the top web applications in the world .
the contributions of this paper are summarized as follows.
we propose a novel web testing framework webexplor to efficiently and effectively test real world web applications.
to the best of our knowledge webexplor is the first end to end web testing framework leveraging reinforcement learning.
we propose a curiosity driven reward function and a dfa to guide rl to efficiently explore diverse behaviors of web applications.
we comprehensively evaluate webexplor on six opensource web applications a commercial web application and top real world web applications.
in the commercial application 12previously unknown failures including logical and security defects are discovered by webexplor and confirmed and fixed by the developers.
furthermore 466exceptions and errors are discovered in the top web applications.
ii.
p reliminaries a. web application and reinforcement learning a typical web application requires the end user to input a sequence of actions e.g.
clicks to interact which in turn will change the web application s states e.g.
url or gui .
this process can be modeled as a markov decision process mdp .
mdp can be defined as a tuple hs a r pi wheres arepresent the sets of states and actions respectively.
as shown in fig.
the agent tester interacts with the environment browser over the time horizon.
at timestamp t the agent observes the state st2s of the web applications e.g.
gui or html and selects an action at2 a to execute after which the agent receives an immediate reward rt r st at and the environment can change to a new state st p st at .
ther andp are reward function and probability transition function both of which depend only on precedingstandat.
homepage add ownerfig.
.
the action sequence of adding a new owner.
intelligently the agent selects an action a s to execute according to a probabilistic policy function .
the agent interacting with the environment gives rise to a trajectory as follows traj s0 a0 r0 st at rt where the subscripts denote different timestamps over the finite time horizon.
each trajectory has a return defined aspt t trt where rewards are discounted by a factor .
in general rl aims at finding one optimal trajectory with the maximum return rather than diverse trajectories.
however this is often not the goal of web testing which seeks to explore diverse trajectories and states.
therefore an adaptive reward function is required to guide rl to continuously generate diverse trajectories which will be detailed in section iii c .
b. problem formulation in general given a web application the goal of testing is to generate action sequences along with suitable inputs in order to explore diverse states and behaviors of the application potentially covering more logical application scenarios .
definition web state a statesis a description of a web application s current status e.g.
the html page .
from a human perspective the image i.e.
screenshot that captures the changes of the html page is a natural representation of web states.
however due to the wide use of animations images may not reliably represent web states e.g.
two completely different images may correspond to the same state of a web application .
in comparison the html page s code is a more precise representation as it encodes the url and the structural characteristics of html pages.
thus we propose a novel state representation by analyzing the html page s code in sec iii b .
unless stated otherwise a concrete html page instance is referred to as the state.
definition action an actionais a valid operation in a given web state i.e.
an html page .
given a web state we focus on the operable dom elements e.g.
links buttons or input boxes on which the operations may result in changes of application status e.g.
submitting a form or url jumping .
it is worth mentioning that different states may contain different action dom sets.
for example in fig.
the homepage has valid actions i.e.
elements in thenavigation bar while the add owner page has more valid actions input boxes and a button .
definition test case a test case is a sequence of actions a0 at with necessary input values.
for example in fig.
the add owner function consists of three parts navigating to the adding page filling the form and clicking the submit button.
one feasible action sequence in red for testing the add owner function is visualized in fig.
.
this sequence together with necessary inputs constitute a test case a0 a7 .
when operating on an inputtable element our technique will provide a suitable value to make a test case continue which will be detailed in the section iii b .
similar to the existing work we say a test case fails if exceptions or errors are thrown during the execution of the test case including the javascript runtime exceptions client errors or server errors which can be analyzed via the returning status code .
for simplicity we refer to the exceptions and errors as failures in the subsequent sections.
definition web testing for a web application the tester aims at learning an adaptive policy to continuously generate test cases for web exploration and failure detection.
intuitively the more states are uncovered the higher the chance of finding failures is.
consequently the goal of web testing is to generate test cases that can reach more diverse states on which failures may be discovered.
it is worth emphasizing that discovering test cases that can trigger business logic e.g.
creating data is critical for testing as it may be a prerequisite for discovering new scenarios e.g.
editing data .
iii.
a utomatic webtesting a. an overview of webexplor in a nutshell webexplor is an end to end framework aiming at achieving automatic web testing in an online fashion.
its goal is to automatically generate diverse sequences of actions to explore more behaviors of the web application under testing.
to achieve this webexplor leverage curiositydriven reinforcement learning rl to constantly optimize a policy which can generate diverse test cases.
in particular the rl training and web testing are intertwined which is different from usual ai solutions that performs training before deploying.
fig.
4shows an overview of webexplor which comprises three major components.
1the pre processing component maps an html page to an abstract state.
its main purpose is to avoid the state explosion caused by dynamic updates in a web page such that a good policy can be learned effectively.
2thecuriosity driven policy learning component is designed for learning a policy that could explore diverse states of the web application.
3the dfa guided exploration component further improves the efficiency of the exploration of rl by maintaining a continuously updated deterministic finite automaton dfa that records all visited states and their frequencies.
when rl cannot discover new states within a certain time budget webexplor selects one novel state as the starting point of the next exploration based on the global information of dfa so as to avoid being trapped around the local optima.
425preprocessing state abstraction element filter state actions failed tests curiosity model low level curiosity reward high level dfa guidance?
oracle action sequence 3html page update dfa curious trace selection yes no adaptive policy state next action dfa guided exploration curiosity based policy learning fig.
.
the workflow of webexplor .
algorithm 1presents the details of our approach.
webexplor takes the target web application env and the pre processing function as the inputs and outputs a set of failed test cases f.webexplor first initializes the policy the dfam and the failed test set f line .
then it continuously tests the web application until the pre defined time budget exhausts line .
during testing to avoid reaching stuck webpages that cannot jump to other pages and continue further we limit the maximum number of steps for one test case line .
after reaching the maximum number we reset the web application jump to the default homepage p0 line set the initial action sequence which includes only an empty action line and gets the initial state s0 line .
each test case starts from the initial state i.e.
the homepage line .webexplor performs on the fly testing by executing the current action sequenceacton the current page p0 line e.g.
submitting a form .
during the execution webexplor monitors the status of the browser s console such that failures can be captured automatically.
the environment returns a new html page pand the error status.
if an error is found the test case is added into the failed test set line .webexplor encodes the current page and returns the corresponding state sand valid actions vain the states0 line .
ifwebexplor cannot identify a new state within a certain amount of time the rl may enter into the local optima.
webexplor checks the dfa dthat records the global visit information and selects one trace that is less visited line .
it returns the trace tand the action sequence act from which the trace can be restored.
the web application is then reset to the homepage line and the number of the current steps is set with the length of tracet line .
after a state sis explored webexplor calculates the curiosity rewardr line .
the policy is trained with the current transition s0 a s and its reward r line .
in addition the dfadand the current test case are updated with the transition lines .
the next action is selected by feeding the current state sto the policy line .
then the previous state and html page are updated lines .
b. pre processing for policy learning via reinforcement learning we need to define the state representation.
a straightforward way is to leverage web page representations e.g.
gui or htmlalgorithm webexplor input the target web application env the pre processing function output the set of failed test cases f 1initialize policy dfa mand test case set f 2repeat 3p0 reset env 4act 5s0 p0 6t repeat 8p failed env p0 act .on the fly testing iffailed then f fsftg 1s va p .see algorithm update valid actions of s usingva ifno curious state within some time then 3act selecttrace m .see algorithm p0 reset env update the number of the current steps with the action sequence act continue 2calculater curiosity s0 a s 19a act train policy using s0 a r s .
q learning update dfa dusing transition s0 a s 22t append a s .store state action sequence 23act 24s0 s 25p0 p until reach maximum steps 27until until time budget exhausts 28returnf document .
however if one adopts such a method the number of states can be quite large and even infinite due to the dynamic nature of web applications.
for example html documents can be different if the user operates differently e.g.
different form values or infinite scrolling pages .
thus adopting html document as states often suffers from the state explosion problem resulting in low effectiveness of rl .
to overcome such a limitation we propose a novel state representation.
the intuition is that html pages that focus on the same business logic should be consolidated into one state.
for example in a webpage the content of a table may 426algorithm pre processing input html page p hurl htmldoci output states valid action set va 1letsbe the current state set of the web application 2va retrievevalidelement htmldoc 3fors2sdo fetchhurl0 htmldoc0ifrom the existing state s ifurl6 url0then continue 7sim computesimlarity htmldoc htmldoc0 ifsim threshold then returns va 10create new state susinghurl htmldoci 11s ssfsg 12returns va be updated constantly e.g.
by adding or removing items .
although the html document may vary a lot the pages still look similar and handle the same user interactions.
we do not treat such pages as different states.
given an html page we use its url andhtml document as the approximation of the business logic.
it is intuitive that if two pages have the same url and their html documents are very similar they are more likely to focus on the same business logic.
we argue that such similar pages represent the same state and algorithm 2describes how to distinguish different pages.
the basic idea is to calculate the html structure similarity of two pages.
if the structure similarity via tag wise comparison is above a threshold it is more likely that they focus on the same business logic and should be considered as the same state.
algorithm 2takes the code of the html page as the input and outputs the state sas well as a set of valid actions vain the current page.
we use sto represent the existing states during testing.
we adopt the browser built in protocols to filter some elements e.g.
no rendering or invisible and only keep the ones that can be operated on i.e.
valid actions on this page line .
these elements include the clickable buttons links input boxes selectors.
next we check the similarity between the current page pand pages in the previous states until one similar state is found.
specifically for each previous state s we obtain its page information line and calculate the similarity between pand the page in sas follows.
firstly we compare their urls.
intuitively if the urls are not the same the pages often tend to execute different business logic.
hence we do not count them to be the same state line .
otherwise we calculate the similarity between the two html documents line .
more specifically we convert an html document to a sequence of tags and adopt the gestalt pattern matching algorithm to calculate the similarity between two sequences.
if the similarity is above a pre defined threshold the previously existing state sandvaare returned line .
note that we extract all tags in the html document without any filtering so that no feature information in html will get lost.
if the current page does not match any existing states we create anew statesusing the current page s code line add it into sand return the results.
it is worth noting that different urls may represent the same business logic creating multiple states corresponding to the same business logic line .
however such a correspondence causes little performance loss and doesn t affect webexplor s soundness.
meanwhile webexplor focuses on generating action sequences rather than input values even though input values can also affect the testing procedure.
to be aligned with prior works and carry out testing procedure when operating on inputtable elements random values will be generated according to the w3c standards .
note that webexplor can leverage dictionaries or user specified values to enhance the testing capability which will be studied as the future work.
c. testing via curiosity driven rl webexplor leverages rl to achieve an end to end testing by directly interacting with the web applications.
specifically the purpose is to learn a policy i.e.
that provides an exploration strategy to generate diverse test cases.
to achieve such a policy we need to define an effective reward function that determines the optimal policy.
reward function.
common rl tasks e.g.
game playing usually have a concrete goal such as winning a game or achieving a high score which eases the design of the reward functions .
however in web testing reward function design becomes challenging as the goal is vague i.e.
to explore as many different behaviors of the web applications as possible.
moreover a web application can be dynamically updated indicating that the goal should also be dynamically adjusted.
to address the challenge we leverage the notion of curiosity which has been proposed to counter the problem of coarse reward in rl .
specifically we have devised a curiosity driven reward function that adopts a general and adaptive mechanism to guide the exploration such that diverse states could be reached.
for curiosity measurement line in algorithm during testing webexplor maintains a visit count table to record the number of each transition denoted byn s0 a s .
the curiosity is measured by mbie eb curiosity s0 a s 1p n s0 a s n s0 a s is initialized to .
each time when the state s0 transits tosby performing the action a the corresponding n s0 a s is increased by .
q learning.
webexplor leverages a model free rl algorithm q learning to optimize the policy with the curiositydriven reward.
q learning has a function q s a!r which returns the q value for a state action pair.
each time a new state sis reached from the previous state s0 i.e.
s0 a s we update the qfunction line 20in algorithm q s0 a curiosity s0 a maxa0q s a0 where is a discount factor.
the qfunction keeps the temporal relations between actions since the q values will propagate to the ones in antecedent states recursively.
35root state d undiscovered state discovered state discovered action undiscovered action a 35root state a 35root state b 35root state c a activate a fig.
.
an intuitive illustration of curiosity model.
based on the qfunction the policy measures the weights of the valid actions in a state susing the gumbel softmax method p a exp q s a ga p ai2aexp q s ai gi whereais the valid action set at the state s is a temperature coefficient and g are i.i.d noise sampled from gumbel distribution.
an action with a higher qvalue is more likely to be selected for interaction line 23in algorithm .
this enables webexplor to balance between exploration and exploitation.
actions that discover a new state are given a high curiosity reward and are more likely to be selected for the execution.
this trait ensures efficient exploitation as such actions have high possibility in discovering diverse behaviors.
in the meantime the curiosity decreases along with the action execution making other less executed actions to be selected for execution.
this facilitates sufficient exploration and helps to find complex business logic in the web application as we will demonstrate in our evaluation.
example.
fig.
5illustrates how the curiosity based rl works for web testing and how it can explore complex business logic.
assume that webexplor starts from the root state s0 and different action a s can be selected for execution.
executing actions cause state transitions e.g.
a results in s0!s1.
initially the probability of choosing a a anda are the same.
assume that s3is firstly covered through the red path fig.
a then the value of q s2 a q s1 a andq s0 a will be updated via backpropagation through the path.
in this way the temporal relations along this path is built and encoded in the policy .
the curiosity reward curiosity s0 a s1 is decreased.
in fig.
b and fig.
c actions a anda with higher curiosity are selected.
note that after s6is reached some previously invalid actions e.g.
a may become valid due to the specific business logic.
for example an item in the table can only be deleted after being added.
in this case as curiosity s0 a s6 decreases a anda regains the same chance to be selected which is critical for exploring the newly activated states i.e.
s7 opening a new untouched area to be explored.
.
.
.
.
.
s0sm fig.
.
an intuitive illustration of transition in long path.
algorithm selecttrace input dfam output action setact sm am sm arg max s0 a s curiosity s0 a s 2find the shortest trace tr s0 a0 s1 a1 sm am sm 3return a0 a1 am d. dfa guided exploration exploration is widely regarded as one of the most challenging problems of reinforcement learning .
in the web application a function is usually triggered by executing the actions in the specific order e.g.
the approval process in the office automation oa system .
the exploration becomes more challenging as the sequence of actions gets longer.
although the curiosity driven reward function provides guidance for the action selection due to its stochastic nature rl may still have low probability to select other actions especially in a long sequence of actions interrupting the testing of the target function.
consider the example in fig.
a policy with 9probability of selecting right actions red arrow to statesm .
however the possibility of reaching sm 1is only 53since the path can be interrupted whenever the policy takes an action.
the longer a path becomes the more frequent an interruption may occur making reaching a desirable transition harder especially when facing a long path.
to address this challenge we propose to build an on thefly deterministic finite automaton dfa during the testing which provides a high level guidance for boosting the rl exploration.
specifically if new states cannot be found after some time webexplor starts to find a transition which has the highest curiosity from the dfa.
then the shortest path that can reach the transition is detected such that the rl could directly reach this transition.
definition dfa a deterministic finite automaton dfa mis a tuple s a s f wheresis a finite set of states ais a set of actions s a!sis a set of transitions s0is the initial state and fis a finite set of states that cannot transit to other states.
during testing once a new transition s0 a s is explored the dfa will be updated i.e.
sf s0 a s g line 21of algorithm .
algorithm 3presents the basic idea of curiositydriven trace selection.
from the dfa we first select the transition with the highest curiosity sm am sm .
then we adopt the dijkstra s algorithm to identify the shortest trace tr that can reach the target sm am sm .
with this trace rl 428could directly restore to the target transition.
intuitively some transitions could be very deep and thus difficult to reach by rl.
for these transitions webexplor leverages dfa to further enhance the exploration efficiency and testing effectiveness.
theoretically the non deterministic finite automaton can represent the dynamicity of the stochastic environment more accurately.
however we use dfa due to the following reasons the automaton is used to guide the selection of one viable path for exploration.
due to dynamic factors e.g.
network one path in dfa may be infeasible but it doesn t affect the soundness of webexplor because the dynamic execution will ignore such infeasible paths the construction of nondeterministic finite automaton could be more expensive especially on estimating the transition probabilities.
considering the trade off between efficiency and granularity of automaton construction dfa is a good enough solution for webexplor .
iv.
e mpirical evaluation we have implemented webexplor based on python .
.
and pytorch .
.
with more than lines of code1.
to demonstrate the effectiveness and efficiency of webexplor we conduct an empirical evaluation investigating the following four research questions.
rq1 code coverage how is the exploration capability ofwebexplor in terms of code coverage?
rq2 failure detection how effective is webexplor for detecting failures of web applications?
rq3 dfa guidance how effective is dfa in guiding the exploration during testing?
rq4 scalability how effective is webexplor in testing real world web applications?
a. experiment setup benchmarks our large scale evaluation uses three benchmarks including a research benchmark from the prior work to compare webexplor with the state of the art techniques a benchmark of top real world web applications to evaluate the scalability of webexplor and an industrial web application to conduct a detailed case study.
research benchmark we adopt a benchmark containing six popular github projects each has more than stars from the prior work .
these projects use six most popular javascript frameworks dimeshift backbone.js pagekit vue.js splittypie ember.js phoenix trello phoenix react retroboard react and petclinic angularjs .
real world web applications according to the ranking we select the top web applications in the world for evaluation.
to investigate the scalability we directly leverage webexplor for an end to end testing of these applications without fine tuning.
industrial web application a complex software as a service saas system is adopted for the further case studies.
we omit the system name for anonymous review reasons.
1more details can be found in our website .
web application failures in subsequent experiments we collect the system level failures defined in section ii b reported in the browser s console to study the failure detection capability of related approaches.
note that user level failures may or may not cause system level failures which depends on the system s robustness.
for example if user level failures are well handled by the web system e.g.
strict input field checking no system level failures will occur.
otherwise failures will be triggered and captured by webexplor .
for identifying the root cause of failures e.g.
by users or system we adopt manual analysis.
it is worth emphasizing that all discovered failures are manually vetted to ensure that the thrown exceptions and errors are actually failures i.e.
no false alarms .
baselines approaches to evaluate the effectiveness of webexplor we select three state of the art approaches as baselines for a comparative study.
these baselines include both the model based to model free algorithms.
besides one random strategy that adapts the idea of monkey is adopted as a baseline.
moreover to evaluate the advantage of leveraging dfa a variant of webexplor is also implemented for the ablation evaluation.
dig is a navigation model based approach leveraging a diversity based test case generator for web testing.
subweb is a navigation model based approach considering the uncovered branches and using a search based strategy to achieve web testing.
crawljax is a navigation model free approach discovering and clustering pages on the fly and adopting a crawlingbased random test case generator for web testing.
random is a model free approach randomly selecting one of the available actions to explore web states.
webexplor no dfa is a variant of webexplor without the dfa guidance.
configurations for all experiments we give each tool the same time budget i.e.
minutes .
to counteract the randomness from a statistical perspective we repeat each experiment times and calculate the average results.
for the similarity in the pre processing we set .
as the threshold.
dfa provides high level guidance for webexplor if no new states are discovered in minutes.
for the discount factor in rl we set .
in all experiments.
we conduct an comprehensive evaluation in spending more than cpu hours i.e.
projects settings for tools .
hour time budget for single round repetitions in total.
besides during testing actions that lead to external links via domain checking will be recorded during testing marked as invalid actions and not executed in the subsequent testing.
b. code coverage rq1 to conduct a comprehensive comparison for dig and subweb we use the naviation models which are based on automatically and manually generated page objects denoted by apo and mpo respectively.
to counteract implementation bias both the apo and mpo are directly adopted from the prior work .
comparisons in terms of the branch coverage 429of javascript code are conducted on six web applications.
the averaged results of runs are summarized in table i where bold numbers indicate the best result.
overall we have the following findings.
the model based methods dig and subweb can achieve an overall better branch coverage than model free methods crawljax and random in most cases.
this is because navigation models can provide more information e.g.
web structure which is beneficial for effective testing.
however a counterfactual finding is that model free webexplor achieves competitive performance in terms of code coverage significantly outperforming i.e.
calculated by mann whitney u test at .
confidence level model based methods in web applications bold numbers in table i .
it not only demonstrates the exploration capability of webexplor in terms of the code coverage but also the robustness which could be obtained by the model free testing fashion.
besides we perform an in depth analysis on the test cases generated by webexplor to figure out why webexplor as a model free algorithm can achieve better performance than other model free algorithms i.e.
crawljax and random .
take petclinic for an example shown in fig.
we find that webexplor can generate the correct operation sequence i.e.
filling form values before adding an owner to achieve effective testing.
normally generating such logically related sequence actions is hard for random based model free algorithms.
however by leveraging the curiosity driven rl webexplor can capture such relations and encode this knowledge in the policy to create effective test cases without navigation models.
furthermore compared to model based algorithms i.e.
dig and subweb we found that webexplor performs much better in four subjects and similarly for the rest.
we investigate the reason and find that some pages in splittypie and retroboard need complex inputs that are difficult to generate randomly.
for instance the transaction page in splittypie can only be discovered after typing in a time value with a non standard w3c format e.g.
mmdd .
however webexplor follows w3c standards and cannot generate such inputs without human knowledge.
meantime we analyze apo and mpo in dig and subweb and find that both kinds of navigation models have been manually fine tuned with humanknowledge which enables non standard input generation for higher coverage.
detailed results and analysis can be found in .
in rest four subjects such non standard inputs barely exist where webexplor achieves much better results.
answer to rq1 in contrast to model based approaches webexplor achieves better code coverage and robustness in most cases with no navigation models or prior knowledge.
c.failur e detection rq2 wecontinue to analyze the ability of each baseline in discovering f ailures defined in section iv a2 .
table ishows the statistical results of the average number of failures disco vered during the allocated testing time see section iv a4 .
as one failure can be discov ered multiple times during the entiretesting proces s here we only count the unique f ailures for all methods.
overall we ha vethe follo wing findings.
first compared with other baselines random approach achiev es relati vely poor performance which is consistent with the intuition that simple random e xploration is ineffecti vefor large web applications.
model based approaches can discov er more f ailures than the random approach b ut exhibit instability .
among all baselines webexplor discov ers the most number of failures bold numbers in table i significantly exceeding other methods i.e.
calculated by mann whitne y utest at .
confidence le vel .
this re veals not only the competiti veperformance in failure detection b ut also generality of webexplor .
another counterintuiti vefinding is that in splittypie and retroboard subjects although webexplor achiev es lo wer code coverage than dig in table i itstill detects more f ailures in table i .
we analyze the test cases generated bywebexplor and dig compare the logs see detailed logs in and find that webexplor discov ers more server request errors e.g.
error code and500 via generating test cases with illegal operation sequences.
intuiti vely the code related to each operation can be easily covered by independent e xecution.
howe ver some failures are only triggered by illegal operation orders indicating that it seems inef fectiv e todetect f ailures by simply impro ving code coverage.
moreo ver dig combines a sequence of actions with a specific order as a macro operation in both apo and mpo ignoring the fact that different orders or executing only part of the sequence may result in potential failures.
this e xplains wh ywebexplor performs better in generating ef fectiv e test cases.
answer to rq2 compared to other baselines webexplor achieves the best performance in failure detection while requiring no human knowledge or fine tuned navigation models revealing its potentials across different subjects.
d.dfa guidance rq3 this section investigates how dfa contributes to boosting the testing efficienc y through high le velguidance.
compar isons between webexplor andwebexplor no df a are conducted to evaluate the failure detection rate and ef ficiency .
fig7illustrates the results where the x axis is the testing time and y axis failures and co verage are the average number of disco vered failures and code coverage rate respectiv ely.to avoid statistical bias the results are averaged using runs and the bold lines and shado w areas represent the mean and standard de viation.
first in fig.
top we observe that webexplor can not only discov er more failures than the one without dfa butalso a higher f ailure detection efficienc y blue line rises faster .
meanwhile df a achie vesan early performance jump regarding the number of discov ered f ailures especially in the dimeshift pagekit and petclinic subjects.
all the adv antages benefit from a better exploration guided by dfa.
take the petclinic subject for e xample man y failures disco vered by webexplor have long execution traces containing man y actions that need to be executed in a specific order .
consider 430table i comparisons of related baselines regarding the averaged branch coverage and failure detection with the corresponding standard deviation .
v alues in bold indicate the best average results using 15runs .
subjectsaverage branch coverage average unique failures webexplor crawljax random dig subweb webexplor crawljax random dig subweb navigation model free apo mpo apo mpo navigation model free apo mpo apo mpo dimeshift .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
pagekit .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
splittypie .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
phoenix .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
retroboard .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
petclinic .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
average .
.
.
.
.
.
.
.
.
.
.
.
.
.
dimeshift pagekit splittypie phoenix retroboard petclinic coverage failures min webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa webexplor webexplor no dfa min min min min min min min min min min min min min min min min min min min min min min min fig.
.
evaluation of dfa regarding averaged number of discovered failures top code coverage bottom and testing efficiency runs .
the results are averaged using runs while the solid line and shaded represent the mean value and standard deviation respectively.
this page transition trace as an example homepage !ownerlist!owner info!pet list!pet info!visit info page.
many failures can only be discovered when entering the visitinfo page and submit a form with invalid values.
webexplor can efficiently achieve this transition via dfa guidance and start subsequent testing.
otherwise any interruption in the process will result in visiting another page degrading the testing efficiency e.g.
fig.
.
therefore such high level guidance effectively leads to promising testing directions by which webexplor achieves efficient and effective web testing.
another finding is that dfa can achieve a more stable performance in terms of both failure discovery and code coverage.
as shown in fig.
the standard deviation shaded area of using dfa is smaller than not using dfa.
the variation is particularly obvious in pagekit phoenix and petclinic subjects.
answer to rq3 dfa complements curiosity driven rl by providing high level guidance for effective exploration and high efficiency.
webexplor achieves a better performance in terms of failure detection rate code coverage and stability.
e. evaluation on real w orld w eb applications rq4 rq4 aims to evaluate the ef fectiv eness of webexplor on real world web applications.
according to thealexa rank list top most popular web applications are chosen for e valuation.
in total webexplor discov ered failures.
after manual inspection we find these failures consist of 889javascript f ailures server failures i.e.
status code and other f ailures more details in .
moreo ver we analyze the urls of the detected failures and find that .
failures come from the original web applications while the rest are from third party libraries.
this indicates that most failures indeed e xist in the original web applications resulting in an urgent need of end to end testing such as webexplor .
on the other hand we find that the failures can be caused by either the client or serv er sides including static resources loading errors javascript errors due to uncommon operation sequences and crossi ng site errors due to accessing different servers refer to for details which demonstrates the effecti veness ofwebexplor in detecting failures in real world web applications.
moreov er webexplor leverages no manually tuned parameters demonstrating high scalability among v arious modern web applications.
more ana lysis and failure screenshots including web pages and cons ole outputs can be found on our website .
furthermore a commercial saas platform o vera million lines of code is employed as adetailed case study.
webexplor successfully finds unspotted failures which are confirmed and fix ed by developers.
w e analyze some specific cases of discov ered f ailures as follows.
asynchronous rendering the follo wing code segment shows a disco vered failure where gray lines are newly added fixing solutions.
the elements i.e.
kg container is asynchronously rendered which will be a null pointer before 431finishing rendering.
therefore a failure will be triggered once accessing such a null pointer line .
this finding also suggests that developers should pay attention when using asynchronous techniques in web applications.
disable default right click behavior if !
!document.getelementbyid kg container throws null point exception without checking document.getelementbyid kg container .oncontextmenu function e e.preventdefault check invalid email if match email kg container register email email security defect the following example shows a module loading failure that results in a security defect.
specifically when webexplor operates on the online editor in the browser the server tries to load a non existent module brace mode c cpp by traversing all folders line .
consequently as shown in fig.
the server exposes all folders and folder structure to the client which could be exploited by malicious attackers and results in security problems.
the online editor is difficult to reach but webexplor discovered it by adopting an effective exploration.
fig.
.
the exposure of sensitive server information.
beyond these webexplor discovered some other failures.
for instance a password reset api throws an internal exception bad request once receiving an invalid email input.
besides when webexplor executes the tab switching behaviors an event handler error is thrown which results in incorrect data rendering.
moreover searching api throws an error internal server error if the request payload contains no product or organization id which cannot be handled.
more analysis and details can be found in our website .
answer to rq4 webexplor tests modern web applications in an end to end fashion with no additional manual efforts e.g.
building a navigation model .
besides failures detected from the real world applications further demonstrate the effectiveness of webexplor in failure detection.
f .thr eatstovalidity randomness can beamajor threat during testing and the web interaction.
wereduce this threat by repeating timesfor each testing configuration and a verage the results.
besides the oracle we proposed may not be complete and thus webexplor may miss some other unknown failures likeui bugs or other types of bugs.
as webexplor performs black box web testing the server side codes are assumed to be unav ailable.
therefore only the co verage of the client side codes e.g.
javascript are reported and the e valuation ofwebexplor in terms of the code coverage may be incomprehensi ve.the selection of the rl algorithm used for training policies could be biased.
w e mitig ate this problem by selecting the standard rl algorithm for web testing.
furthermore h yperparameters may be a potential threat.
the choice of such h yperparameters is dependent on the domain kno wledge and may be biased.
besides the selection of the web applications could be biased.
toaddress this a research benchmark and various real world web applications including acti vecommercial websites are adopted for evaluation.
v.relatedwork many techniques ha vebeen proposed to automate web testing.
in the follo wing we briefly discuss the most relev ant solutions and their limitations which moti vates the need for a novel and efficient web testing technique.
model based t esting.
model based technique is a major paradigm for achieving automatic web testing .
this kind of techniques build models to describe the web applications beha viors in advance and then deriv e test cases from the models to find b ugs.
f or instance approaches lik e dig subw eb and atusa extract paths from the na vigation model where genetic algorithm is adopted for performing path selection and input generation.
further an incremental tw o steps algorithm inwertgen isproposed where the generation of navig ation model and test cases are intertwined.
overall model based techniques exhibit the advantage of fast test cases generation since no web interaction is required.
howe ver the navig ation model may co veronly some beha viors of the web applications while others cannot be tested.
besides e xpert domain knowledge are required in building high quality models.
such limitations moti vate the need for a model free testing technique.
webexplor to the best of our kno wledge is the first rl based technique that performs an end to end automated web t esting for real world applications and achiev es competiti veperformance comparing to the state of the art techniques.
testcase generation .
test case generation consists of building test path and corresponding input values .
gi ven a navig ation model test paths can be generated by searchbased approaches and inputs can be generated using random or evolutionar y algorithms .
in many cases search based techniques need to explicitly address path feasibility resulting in tremendous e xecutions of test case candidates.
search based algorithms also need to evaluate each test case s fitness v alue which is costly since plenty of candidates need to be generated and executed in the bro wser before con verging .
existing techniques for automated test case generation either ignore path feasibility or require 432a large number of executions.
as for input values random strategy can generate feasible inputs in most cases.
furthermore symbolic execution techniques e.g.
apollo jalangi and symjs use systematic strategies to generate specific inputs to cover hard to reach codes.
however generating such specific inputs is not the primary concern ofwebexplor and all advanced input generation techniques can be incorporated in the webexplor to further enhance the performance.
recently there are also some research on testing deep learning models which could be used to test reinforcement learning models.
reinforcement learning based testing .
in recent years rl has also been applied to help software testing.
for instance wuji leverages rl and multi objective optimization for game testing which is rather different from web applications.
b ottinger et al.
introduce the first rl based fuzzer to learn high reward seed mutations for testing traditional software.
retecs uses rl to facilitate test prioritization and selection in regression testing.
besides rl is also adopted in mobile testing techniques ranging from qbe for crash detection to gui testing .
the most recent q testing achieves the best mobile testing performance by leveraging the curiosity reward which is similar to webexplor .
both webexplor andq testing are built on theq learning however due to different characteristics between android and web applications the challenges addressed by the two works are different.
in webexplor we carefully design state representation and suitable rewards for web testing which are different from q testing.
furthermore we also found that it is not effective when only using qlearning.
thus dfa augmented exploration is proposed in webexplor which is also a key difference compared with q testing.
the existing studies most related to both the rl and web domains are artemis and dom q net that utilize rl to perform explicitly defined web based tasks.
different from completing explicit tasks webexplor targets at web testing via exploring diverse behaviors using curiositydriven rl which has not been tackled before.
vi.
c onclusion this paper proposes webexplor a new rl based approach for automatic web testing.
webexplor leverages the curiositydriven rl to achieve efficient and adaptive exploration.
meanwhile dfa is proposed to provide high level guidance so as to further boost the testing efficacy.
experiments show that webexplor outperforms existing web testing techniques in both code coverage and failure detection.
in the future we plan to extend webexplor with hierarchical rl for a better exploration and extract business scenarios from the dfa whereby fault localization can be achievable.
vii.
a cknowledgements the work is supported in part by the national natural science foundation of china grant no.
u1836214 special program of artificial intelligence and special program of artificial intelligence of tianjin municipal science and technologycommission no.
17zxrggx00150 tianjin natural science fund no.
19jcybjc16300 research on data platform technology based on automotive electronic identification system singapore national research foundation under its national cybersecurity r d program no.
nrf2018ncrncr005 singapore national research foundation under ncr no.
nrf2018ncr nsoe003 nrf investigatorship no.
nrfi06 jsps kakenhi grant no.
20h04168 19k24348 19h04086 jst mirai program grant no.
jpmjmi18bb japan and guangdong provincial key laboratory grant no.
2020b121201001 china.