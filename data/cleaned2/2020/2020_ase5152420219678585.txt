refactorings and technical debt in docker projects an empirical study emna ksontini marouane kessentini thiago do n. ferreira and foyzul hassan university of michigan dearborn dearborn mi usa emna marouane thiagod foyzul umich.edu abstract software containers such as docker are recently considered as the mainstream technology of providing reusable software artifacts.
developers can easily build and deploy theirapplications based on the large number of reusable dockerimages that are publicly available.
thus a current popular trendin industry is to move towards the containerization of their appli cations.
however container based projects compromise differentcomponents including the docker and docker compose files andseveral other dependencies to the source code combining differentcontainers and facilitating the interactions with them.
similar toany other complex systems container based projects are proneto various quality and technical debt issues related to differentartifacts docker and docker compose files and regular sourcecode ones.
unfortunately there is a gap of knowledge in howcontainer based projects actually evolve and are maintained.
in this paper we address the above gap by studying refactorings i.e.
structural changes while preserving the behavior applied in open source docker projects and the technical debtissues they alleviate.
we analyzed projects consisting of 5mloc along with manually examined commits.
the resultsindicate that developers refactor these docker projects for a vari ety of reasons that are specific to the configuration combinationand execution of containers leading to several new technical debtcategories and refactoring types compared to existing refactoringdomains.
for instance refactorings for reducing the image sizeof dockerfiles improving the extensibility of docker composefiles and regular source code refactorings are mainly associatedwith the evolution of docker and docker compose files.
we alsointroduced new docker specific refactorings and technical debtcategories respectively and defined different best practices.
theimplications of this study will assist practitioners tool builders and educators in improving the quality of docker projects.
index t erms docker containers refactoring technical debt maintenance i. i ntroduction the containerization of software applications has recently becoming popular in software industry to improve the reusability modularity portability security and costs of systems andtheir development .
among containerization frame works docker is the main containerization framework inthe open source community and industry as of itcompanies use it .
indeed docker enables packaging anapplication with its dependencies and execution environmentinto a standardized self contained unit which can be usedfor software development and to increase the portability ofthe applications .
the contents of a docker container aredefined in a dockerfile.
the docker compose is a tool forrunning multi container applications on docker and it is de fined by a compose file format to orchestrate their execution.source code repositories of docker projects contain dockerand docker compose files as well as regular source code fileswritten in a traditional programming language such as java to implement the app hosting the containers and facilitate theirexecution and synchronization with other features.
similar to any other complex systems container based projects are prone to various quality and technical debt issuesrelated to different artifacts docker and docker compose filesand regular source code ones.
unfortunately there is a gapof knowledge in how container based projects actually evolveand are maintained.
few recent studies focused mainly on thedetection of the quality issues related to the dockerfiles interms of the violation of the basic shell scripts practices .
however there is no holistic understanding of thequality issues of docker projects that could affect differentartifacts beyond just the shell scripts in the dockerfiles.furthermore the correction of these issues via refactorings defined as changes to improve the structure while preservingthe behavior is still not yet explore in the literature unlikeother refactoring domains .
as docker projects becomemore complex and expensive to maintain it is critical tounderstand the refactorings that developers would apply.
in this paper we address the above gap by conducting an empirical study on refactorings i.e.
structural changeswhile preserving the behavior applied in open source dockerprojects.
the new knowledge out of the empirical studyincludes the discovery of a the types of technical debtaddressed and whether they are specific to docker projects b the refactoring types that are common in the different artifactsof docker projects and c new generalizable docker specificrefactorings and technical debt categories if any.
studying the refactoring types and technical debt categories that are typically found within docker projects can lead tonew automated docker specific refactoring techniques qualityissues detection tools for docker and docker compose filesand associated source code and automated docker specificrefactoring mining tools and techniques.
the implications ofthe empirical study of this paper will help to i understandhow and why quality issues and technical debts appear indocker projects and how refactorings would address thoseissues ii design new automated tools to integrate noveldocker specific refactorings iii provide guidelines for bestpractices and anti patterns bad smells for practitioners inevolving effectively docker projects and iv assist educatorsin teaching quality issues related to docker projects.
36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee we analyzed projects consisting of mloc along with manually examined commits that include refactorings.
the analyzed refactorings were labeled as being per formed in docker and docker compose files or regular codefiles and related to the docker specific debt they alleviated.for the regular code refactorings we used refminer to detect the refactorings in java files.
with the identifiedrefactorings in docker projects we developed a refactoringtaxonomy.
the results indicate that developers refactor thesedocker projects for a variety of reasons that are specific tothe configuration combination and execution of containers by leading to several new technical debt categories and refac toring types compared to traditional source focused refactor ing domains.
for instance the reduction of the image sizeparticularly involved refactorings of dockerfiles improvingthe extensibility is one of the main reasons for refactoringthe docker compose and regular source code refactoringsare mainly associated with the evolution of dockerfiles anddocker compose.
our study indicates that i improving thebuild time maintainability and reducing the image size are themain quality issues addressed in dockerfiles ii increasing thereusability understandably and extensibility are driven most ofthe applied refactoring applied to docker compose files and iii the evolution of the docker and docker compose filesresulted in various refactorings applied to the source coderelated to the docker projects.
the main contributions of this paper can be summarized as follows based on the manual analysis of docker projects we propose a rich taxonomy of generic and docker specific refactorings.
furthermore this study provides tothe community the first dataset on refactorings in dockerprojects.
we also introduce new refactorings and new tech nical debt categories specific to docker projects.
we propose recommendations best practices and anti patterns for the evolution of docker and docker composefiles from our in depth analysis of docker projects.
replication package.
all material and data used in our study are available in our replication package .
ii.
b ackground a. docker and container based projects docker is the most popular container virtualization technology .
it aims on packaging application s codeand dependencies into a light weight standalone and portableexecution environment.
thus deploying containerized appli cations is an agile process.
docker container images are builtusing dockerfile a document containing a sequence of instructions used for creating the computational environment following the notion of infrastructure as code iac .
listing illustrates an example of dockerfile.
it starts from a previously existing base image defined by the from instruction which acts as a starting point from which thedocker image will inherit infrastructure definitions.
this par ent image can be an official docker image e.g.
alpine or1 from node argon create app directory workdir usr src app install app dependencies copy package .json usr src app run npm install bundle app source copy .
usr src app expose the app to the outside world expose cmd listing dockerfile example.
any other existing image e.g.
with a pre installed software .in order to suit the application needs and to create the desiredenvironment dockerfile offers a list of setup instructionswhich can be listed in table i. t able i dockerfile setup instructions.
instruction description env setting the environment variables arg defining variables that can be set at build time workdir setting working directory for all subsequent instructions copy copying files from host to the docker image addsimilar to copy instruction but supports two additional tricks.
it supports the use of url instead of a local file and can recognize the archive format and extract it directly into the destination label key value pairs indicating image metadata run executing any command expose informs docker that the container is exposing a particular port cmdsetting a command and or parameters that executes when thecontainer is starting and which can be overwritten at build time entrypointsetting executable that will always run when the container isinitiated and cannot be overwritten.
in the docker paradigm each container captures one particular component of the software e.g.
database .
thus when creating multi component application using docker it isunavoidable to combine multiple software components con tainers into an intricate workflow.
to tackle this challenge containers need to be instantiated and properly integrated.docker compose can be used to mitigate this challengeby providing a unified setup routine that deploys severalcontainers using a y aml configuration file as known as docker compose.yml or just docker compose .
version .
services server build .
ports environment db address database mongo db port port depends on database database image mongo latest volumes mydata data db volumes mydata listing docker compose example.
an example of a docker compose file is available in listing .
the example shows that the docker compose 782file is composed of two components containers server and database .
the server component is represented by a local image built from a dockerfile for instance that one available in listing and the database component is created from the mongo image hosted in dockerhub an online registry for docker images .
docker compose filealso provides a list of setup attributes which can be listedin table ii.
t able ii docker compose setup attributes.
attribute description build setting path to the build context image setting the image to start the container from ports specify ports binding environment setting environment variables depends on expressing dependency between services volumes setting volume bindings host paths or named volumes any typical docker project includes the above files along with source code files written in a typical programminglanguages such as java to host the containers and enable theirexecutions and synchronization with other features of the appthat may not be containerized.
b. technical debt and refactoring software technical debt reflects the implied cost of additional rework caused by choosing an easy limited solution now instead of using a better approach that would take longerwhen designing and evolving software systems .
to deal with technical debt refactorings are widely used practice .
martin fowler defines refactoring as achange made to the internal structure of software to make iteasier to understand and cheaper to modify without changingits observable behavior .
this implies that refactoring is amethod that reconfigures code structures without altering itsbehavior to improve code quality in terms of maintainability extensibility and reusability.
different refactoring types aredefined in the literature including move method extractmethod move class move attributes etc.
a full list oftypical code refactoring types can be found in .
recent empirical studies on refactoring show that theserefactorings are widely used in open source projects .
however refactoring is still under explored for dockerand containerization unlike other paradigms such as object oriented programming web services etc.
iii.
m ethodology based mainly on manual analysis we investigated the common refactorings in docker projects.
this study may presentan empirical foundation for new refactoring types for thedifferent artifacts of docker projects to support practitionersin addressing docker related technical debts.
a. projects selection the proposed study includes a total of open source docker projects as described in table iii.
they differ significantly in their size and their popularity.
these projects arecomprising a total of mloc with an average evolutionhistory of years per project.
we first selected dockerprojects from the public github archive on bigquery where our initial list included open source dockerprojects.
then we eliminated non existing projects sincebigquery s last update was in and removed repositoriesforked from other repositories to avoid biasing our study aslarge and popular projects are forked frequently.
we applied a selection criterion aiming to have at least one commit message mentioning the keywords refactor and docker and at least one part of the project must include docker.
the number of commits having the required keywordswas initially commits with a maximum of commitsper repository.
in our final selection we focused mainly ona total of docker projects that were mostly written injava for the code beyond the docker and docker composefiles as it is a popular programming language to developapps hosting containers .
however we still also considereddocker projects with significant evolution written in otherlanguages including c .
to support the manual analysis ofthe java code we used an assisting tool refminer butwe note that most of the manual investigation efforts weremainly on the docker and docker compose files to identifyrelevant docker specific refactorings beyond the traditionalobject oriented refactoring.
the above selection mechanism yielded a total of commits having the required keywords ranging from to 12commit per project column kws and a total of dockerspecific file changes column dfc .
we manually examined the changes associated with these commits to find patches rep resenting possible refactoring and addressed technical debts.
b. commits mining to extracted commits that include refactorings from bigquery achieve we used the sql query presented in listing .
select from bigquery public data.github repos.commits where message like refactor and message like docker listing sql instructions for bigquery.
the keywords were queried via the sql like operator where the sign was used to represent zero one or multiplecharacters.
the expression refactor matches strings containing the word refactor .e.g.
refactoring refactored andthe expression docker matches strings containing the word docker e.g.
dockerfile docker compose .
c. refactorings identification since it is the first study about docker specific refactorings it was necessary to manually inspect commits for refactoring identification.
the keywords matching commits were chosenfor manual examination to find patches in dockerfile anddocker compose files representing one or more possible refac toring which required not only non trivial efforts but alsodeep knowledge of the domain.
three of the authors have 783t able iii studied projects.
subject kloc dfc kws alebabai linden honey .
all of us workbench .
amazeeio lagoon .
artemkaaas indy sdk .
aspuru guzik group mission control .
asqatasun contrast finder .
bagage cadastre conflation .
benbromhead cassandra operator .
blobor skipass.site .
bookbrainz bookbrainz site .
bsw ang denverdino.github.io .
builtondev pipeline byran cyber dojo web .
cdietrich che cgi eoss ftep cloudfoundry incubator diego release cogstack cogstack pipeline .
collinbarrett filterlists crunchydata crunchy containers .
crunchydata crunchy postgresql manager .
crunchydata postgres operator .
cyber dojo languages image builder .
cyber dojo retired storer cyber dojo commander .
di unipi socc dockerfinder .
drasko mainflux .
duderoot generator jhipster .
eclipse repairnator .
ethereum hive .
gchq stroom geotrellis geodocker cluster .
go ggz ggz harvard vpal bridge adaptivity .
hexagonkt hexagon .
humanexposure factotum .
innovateukgithub innovation funding service .
instructure straitjacket .
itisfoundation osparc lab .
kr1sp1n node vault .
kuzzleio kuzzle .
labsai eddi .
lixiaocong lxccms .
lockss laaws metadataservice .
luismayta dotfiles .
macarthur lab matchbox mars lan datahub .
martin2112 trillian .
metabarj0 carrier .
mondediefr mondedie chat .
muccg rdrf openpitrix openpitrix openzipkin zipkin ory am hydra .
outlierbio ob pipelines .
overture stack song .
rackerlabs blueflood .
rancher mesos catalog .
reportportal service api richardknop go oauth2 server .
robymes ordinglcdocker .
scalableminds webknossos .
simonsdave cloudfeaster ska sciencedataprocessor integration prototype .
soluto tweek .
stafli org stafli.stack.php .
unbalancedparentheses docker erlang vietj vertx pg client .
xhochy arrow total .
extensive expertise in refactoring technical debt and empirical software engineering.
another author is an expert in dockerand continuous integration including build repairs.
each of thefour authors analyzed separately all the considered commitsto identify the refactorings and later their rationale.
they alsodiscussed the identified refactoring at the end of the process and not before to avoid any bias to solidify the resultsespecially when there are disagreements among the authors.
cohen s kappa coefficients for refactoring identification and related commits including docker and docker compose files and regular source code files were .
.
and .
respectively which indicates a high confidence ofagreement.
since the authors may not be very knowledgeableabout the code of the projects as they are not their originaldevelopers they marked the refactorings and their associatedcommits only when they are very confident that the changesare actual refactorings.
the authors also used commit mes sages and comments in the code whenever available to confirmtheir decisions which is a common practice .
d. refactoring classification after the refactoring identification phase and in order to understand the refactoring types performed in docker projects we analyzed the code changes within the selected list to deter mine the refactoring types and their rationale e.g.
technicaldebts whether the refactoring was applied in a dockerfile ora docker compose file or regular source code file e.g.
java .
discovered refactorings were then organized into a hierarchy based on the addressed technical debts.
hence afew categories were grouped beneath distinctive parent cat egories within the hierarchy i.e.
change sets containing afew interconnected refactorings were assembled into morecommon parent categories.
a few of the refactorings weremore disconnected i.e.
change sets comprising one sort ofrefactoring and difficult to generalize.
since the identified refactoring types of dockerfile and docker compose may impact the regular source of the ap plication hosting the containers we have also manually in vestigated the selected commits in this study to look at theintroduced code changes of java c files within the samecommit whenever a docker specific refactoring is detected.to support the manual identification of refactoring we usedrefminer to confirm our manual findings.
finally an inter rater agreement analysis was used to develop a classification scheme to categorize the identifiedrefactorings under different technical debt categories.
we alsoapplied the cohen s kappa coefficient by reaching .
asresult between all the authors which indicates high confidenceof agreement.
the few cases of disagreement were discussedbetween the authors at the end of the process and we wereable to find a consensus for all of them.
iv .
r esults a. quantitative analysis we manually examined unique commits from the different projects listed in table iii.
the identification of refactor ings in these commits and analyzing is a very labor intensivemanual task due to the lack of automated tools support.
wefound that commits have dockerfile related refactoring 51commits have docker compose related refactorings and 55commits of regular code refactorings e.g.
java c etc.
due to changes in dockerfile or docker compose.
we observed 784t able iv discovered docker specific refactoring types refactoring type artifact description extract stage dockerfile extract multi stage building from a single stage building inline stage dockerfile aggregate multi stage building into a single stage move stage dockerfile move a stage from a multi stage context into another single stage context in a different dockerfile sort instructions dockerfile order instructions sequence from the least frequently changing to the most frequently changing replace add instruction with copy instructiondockerfilereplace add instruction with copy instruction when files directories need to be only copied from host tocontainer extract run instructions dockerfile extract run instructions commands into a separate script file inline run instructions dockerfile inline run instructions into a single run instruction using operator remove run instructionincluding mv commanddockerfile delete run instruction with mv command and use previous copy or add instructions to set the correct path update base imagedockerfile avoid using unnecessary heavy image replace base image with a lighter one dockerfileavoid building and downloading dependencies on top of base image replace base image with a larger one ifdependencies are fixed and a similar image exits in public or private repo use an existing image rename imagedocker compose set a relevant name and t ag including the necessary information of your image version software.. dockerfile add or rename image alias update run instruction dockerfilereformat run instruction commands split commands into multiple lines where each line represents a singleoption argument order option argument alphabetically use backslash ... update base image t agdockerfiledry principle set a dynamic t ag using arg instruction to avoid creating a new dockerfile when t ag isonly changing dockerfile change t ag value or replace latest t ag with an explicit t ag add env variabledockerfileadd env variables to store useful system wide valuesdocker compose add arg instruction dockerfiledry principle set dynamic instructions using arg instruction to avoid creating a new dockerfile for similarimages extract ports attribute docker compose extract ports attribute into an override docker compose file extract v olume attribute docker compose extract volume attribute into an override docker compose file extract env attribute docker compose extract env attribute into an override docker compose file or use .env file move service docker compose extract service into an override docker compose file rename service docker compose set a relevant name for the service rename container docker compose set a relevant name for the container rename v olume docker compose set a relevant name for the volume add extends attribute docker compose add extends attribute to inherit configuration from an existing service thus avoiding duplication reorder services docker compose order services based on their dependency order update image t ag docker compose change t ag value or replace latest t ag with an explicit t ag a total of commits containing false positive .
the false positive commits i.e.
keywords matching commits thatdid not include any refactorings occurred due to differentreasons including i the keyword refactor was used in non refactoring commit messages to highlight the needs forfuture refactorings ii refactoring occurred out of docker specific context or iii the lack of knowledge about thedomain as docker specific refactorings are a new concept andwere not explored before in the literature thus some commitmessages described regular changes that alternate the behavioras refactoring.
the identified docker specific technical debts are listed in table v. for dockerfiles we found technical debt cate gories related to image size build time duplication maintainability understandability and modularity.
for dockercompose files out of these dockerfile categories arealso applicable duplication maintainability and understandability.
furthermore we found that extensibility is another technical debt addressed by developers in docker composefiles.
docker specific technical debts maintainability was a major technical debt target for applied refactorings indocker projects representing occurrences and foundin dockerfile and docker composed files.
indeed container based technologies are meant to provide the possibility toapply central modifications with having them rolled out overthe system with small endeavors and no downtime.
further more this technical debt was mainly associated mainly withthe excessive usage of environmental variables commits and t ag updates commits in both dockerfile and docker compose files.
understandability is the major refactorings target in dockercompose files.
in this category of the refactorings wereperformed to improve naming.
the observed renaming hadvariety of motivation such as avoiding the usage of irrelevantnames e.g.
using app as a service name including softwareinformation e.g.
software version in the image and t agnames as well as keeping naming consistency throughout theproject.
renaming was also present in dockerfile commits .
build time was among the least addressed debts in dockerfile .
.
in fact the order of the dockerfile in structions highly matters when re building because when astep s cache is invalidated by changing files or modifying linesin the dockerfile subsequent steps of their cache will break.thus ordering steps from least to most frequently changing is something to keep in mind when creating a dockerfile inorder to optimize caching.
regarding to modularity we found occurrences addressing only dockerfiles where they try to apply multi stagebuilding by separating the build from the run time environ785t able v discovered docker specific technical debt categories.
technical debt artifact goal situation consequence image size dockerfilerefactorings are used to reduce the final image sizeadding new changing componentsrequires huge modifications andmay lead to unexpected behaviors huge disk space difficult to uploadand a huge attack surface build time dockerfilerefactorings are used to reduce the build or re build time docker engine takes a lot of timeto build the final image evolving and changing the image be came difficult process extensibilitydockercomposerefactorings are performed to increase the levelof abstractions and improve the reusability ofthe dockerfile and docker compose files.
adding new components requireduplicationduplication duplicationdockercomposerefactorings are introduced to fix duplicatedfragments in dockerfile and docker compose.duplicated fragmentsadding new changing existing com ponents is difficult and error prone maintainability bothrefactorings are performed to ease the modifi cation as well as preventing large impact spreadof future bugs unexpected behavior adding new changing componentsrequires modifying existing filesmodifications and upgrades requirehuge endeavors and conceivabledowntime understandability bothrefactorings are applied to reduce the effort tounderstand code e.g.
renaming elementshuge efforts to understand codeslight and simple modifications willbecome time consuming modularity dockerfilerefactorings are used to reduce image complex ity by breaking image into various stages.complex imageadding new changing existing com ponents is difficult and error prone ment which helps avoiding the inclusion of unnecessary build dependencies in the final image.
docker specific refactoring types we organized the different refactoring types into a hierarchy based on thetechnical debt they addressed.
figure shows the proposedtaxonomy of the refactorings and their rationale.
we havealso highlighted the number of occurrence of these refactoringtypes in the analyzed commits.
the gray square representsthe refactoring type along with the number of occurrences the blue ellipse represents the artifact dockerfile or docker compose and the purple hexagon represents the technicaldebts which the detected refactoring addressed.
we categorized true positive refactorings by manually classifying them into new unique refactoring types.
table ivshows the lists of refactorings that were identified among theanalyzed commits.
we defined a total of new dockerfile related refactoring types and new docker compose onesas described in table iv.
the overall number of refactoringsidentified in the manual commits analysis is to addressthe aforementioned technical debts.
we found three extra dockerfile related refactoring types performed to improve maintainability namely update base image commits extract run instructions commits and replace add instruction with copy instruction commits .
the first refactoring type consists of using existing imageswhenever it is possible to avoid building and downloadingdependencies on top of the base image.
this will reduce main tainability efforts as all required installations are done and bestpractices are probably applied especially when using officialimages.
the second refactoring type consists in extractinga shell script for a specific subsequent run instructions indockerfile.
this refactoring types does not only shrinks theimage size but also groups commands in a much more cleaner simpler and portable format.
finally the third refactoringoperation embraces in using copy instruction instead of addinstruction when files directories need to be only copied fromhost to container.
it is important to notice that the add instruction supports other functionalities such as the use of url instead ofa local files and it can also recognize the archive formatand extract it directly into the destination.
this additionalfunctionalities might be considered as tricky in practice asadd instruction may behave extremely unpredictable.
theresult of such unreliable behavior often came down to copyingwhen we want to extract and extracting when we want to copy.unsurprisingly a large proportion of the analyzed refactoringsin dockerfile aimed at reducing the image size .
regarding image size we found five possible refactorings composed of extract run instructions commits inline run instructions commits remove run instruction including mv command commits update base image commits and extract stage commits were also included in this category.
remove run instruction including mv command in particular aims at reducing layers number inattempt to shrinking the image size by removing the runinstruction with mv command and using previous copy oradd instructions to set the correct path if possible.
we also found several refactorings applied to make the dockerfile less confusing and more modular.
such changesinvolved the improvement of structural aspects.
for example update run instruction commits in dockerfile which consists in formatting commands within run instructions e.g.
splitting commands into multiple lines where each linerepresents a single option argument and reorder services commits in docker compose where developers reordered theservices sequence based on their dependency order.
unlike extract stage inline stage commits and move stage commits aims at aggregating multi stage building into a single stage when multi staging is unnecessary i.e.
nosignificant dependencies and extracting a stage from a multi stage context into a new single stage context e.g.
extractingtest stage into a new dockerfile respectively.
the reasonbehind these refactorings is to improve the build time whenmulti staging can be avoided.
as multi staging requires build ing intermediary images that significantly affects the buildtime.
we also found in dockerfile commits refactorings aimed at improving code design by avoiding duplication and fostering 786 .
.
.
.
.
.
.
.
.
!
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
fig.
docker specific refactorings taxonomy.
the reuse of the code fragments.
add arg instruction commits in dockerfile involves adding arguments using the arg instruction to define common identifiers e.g.
softwareversion and file directories paths that can be later used insideother instructions such as copy add and run leadingto a dynamically changing dockerfile as these identifierscan be affected at build time.
besides a total of otherdocker compose related refactorings were found to make theconfiguration code more generalizable commits reusable commits and inter operable commits by movingattributes to an override docker compose file.
such practicehelps developers to reuse a single docker compose file acrossdevelopment and production while being able to run differentservices.
on the vertical axis and regular code refactorings are represented on the horizontal axis.
each cell in the heatmapindicates the number of occurrences of a docker specificrefactoring type along with a regular code refactoring type.darker colored cells indicates a strong co occurence frequencywhile a lighter color signifies a weaker co occurence.
theobserved refactorings included regular code refactoringtypes along with docker specific refactorings types fordocker compose a and for dockerfile b .
it is clear thatupdate image tag update base image and extract stage are associated with extensive code refactoring of the hostingapplication involving almost all the refactoring types.
in fact those docker specific refactorings directly impact the codehosting the containers as they introduce significant changesin the image or the stage s which are typically called fromthe hosting code similar to functions in apis in other contexts.
b. qualitative analysis the qualitative analysis aims at obtaining and analyzing some examples of commits where the docker specific refactorings were found to address the most common importanttechnical debt issues discussed in the previous section.
dockerfile technical debt and refactoring examples several of analyzed refactorings aimed at improving maintain add env variableupdate image tagrename service rename variablemove attributeextract class rename methodrename class change parameter typeextract superclassextract methodinline variablepull up methodmove class inline method rename parameterpull up attributemove method a docker compose.
extract stageupdate base imageadd arg instructionupdate base image tagsort instructionsadd env variable extract subclassrename variable modify parameter annotationmove attributeextract class extract attributerename methodrename class modify attribute annotationpush down method change parameter typeextract superclasschange return typeextract methodinline variable push down attributepull up methodmove class rename parametermove method b dockerfile.
fig.
refactorings co evolution regular code refactoringsand docker specific refactorings.
ability from several perspectives.
let us consider the example of the update base image refactoring shown in listing .
in this listing openjdk was initially used as a base image line and dockerize software was installed using run instructions lines .
however the official dockerize image already exists with the required version v0.
.
and itcan be easily pulled from dockerhub to act as a starting pointof the dockerfile line .
this can save a lot of time spenton maintenance because all the installation steps are done andofficial images can be highly trusted.
build time is another critical technical debt in docker projects.
when working on evolving and changing the image build time is considered a dead time.
the sort instructions diff git dockerfile a docker elasticsearch dockerfile b docker elasticsearch dockerfile from openjdk from jwilder dockerize .
.
run apt get update apt get install y wget apt get install y curl env dockerize version v0.
.
run wget tar c usr local bin xzvf docker rm dockerize linux amd64 dockeriz listing commit 4f221f9 from datahub refactored dockerfile to reduce the number of pushed layers on a rebuild.
refactoring presented in listing can address build time issues.
in this example a simple recompile of the app willchange the app.jar file line leading to a non valid caching step when rebuilding the image and the subsequentsteps of the cache will then break lines .
orderinginstructions from the least frequently changing to the mostfrequently changing will be highly efficient in such scenario.as mentioned in the commit message the goal was to reducethe amount of pushed layers on a simple recompile leadingto an optimize caching and a faster build time.
diff git dockerfile src main docker dockerfile src main docker dockerfile add ifs data service .
snapshot.jar app.jar run sh c touch app.jar entrypoint jar app.jar cmd curl f healthcheck interval 10s timeout 3s cmd curl f run sh c touch app.jar entrypoint jar app.jar add ifs data service .
snapshot.jar app.jar listing commit f7b5921 from innovationfunding service refactored dockerfile to reducethe number of pushed layer on re build.
image size is the second most frequent category of technical debts in dockerfile besides maintainbility.
indeed docker projects are prone to image size increases due to layerbased structure of the image.
in general the smaller theimage the quicker it is uploaded and the faster it can scale.besides small images are considered to have less vulnera bilities.
the update image refactoring shown in listing can used to fix issues related to the image size.
in thisexample ubuntu .
base image was replaced with phusion baseimage and the subsequent run instructions lines were extracted in a separate shell script calledinstall.sh.
this new base image is also an ubuntu based image but it includes modifications for docker friendliness.therefore as each run instruction represents a unique andsingle layer this refactoring can shrink the image by reducingthe number of layers.
besides the goal of this refactoring wasalso described in the commit message refactor of dockerfileto generate images that occupy less space .
diff git dockerfile a .
rc1 dockerfile b .
rc1 dockerfile from ubuntu .
from phusion baseimage run cd usr src tar xf otp src erlang version .tar.gz cd otp src erlang version .
configure make make install run build install.sh diff git install.sh dev null b .
rc1 install.sh listing commit 9787e1a fromdocker erlang refactored dockerfile to generate a smaller image.
docker compose technical debt and refactoring examples regarding to docker compose files extensibility is a common and frequent technical debt as described in thequantitative analysis.
in general the docker compose file sextensibility should be improved when both development andproduction environments are located in the same file.
move services refactoring shown in listing can be used to improve the extensibility of docker compose files.
in this exampledevelopers moved benchmark resin services lines to a new override file line .
therefore they wereable to reuse a single docker compose file while being ableto run different services.
diff git docker compose.yaml a docker compose.yaml b docker compose.yaml services benchmark resin build depends on ports diff git hexagon benchmark docker compose.yaml dev null b hexagon benchmark docker compose.yaml listing commit 99109b6 from hexagon refactored docker compose file to make benchmark services optional.
we have also found that the inheritance was mainly improved in docker compose files to remove duplication.
the add extends attribute refactoring presented in listing is a common refactoring type for docker compose to addressduplication issues.
this refactoring helped to solve the con figuration duplication issue by using the extends attribute line and specifying the parent service db from the parent docker compose file .
v. i mplica tions and discussions a. refactorings co evolution we found that several refactoring types when applied to dockerfile and docker compose files impact the source codeof the project that should be also refactored using regularrefactorings as well.
this co evolution process is currentlyperformed manually by developers and there is no semi automate tool to support them.
thus there are significant diff git a docker compose jasper.yml a docker compose jasper.yml b docker compose jasper.yml db image muccg postgres ssl .
environment postgres user rdrfapp postgres password rdrfapp ports extends file docker compose common.yml service db listing commit f7d2b4d fromrdrf refactored dockercompose file to remove duplicated configuration.
costs that can be associated with docker specific refactorings which can make developers reluctant to apply them.
thisstudy identified the most common co evolution patterns thatwe found in multiple commits and then a semi automated toolcan be designed to recommend code refactorings based on theapplied docker specific refactorings.
b. docker specific refactorings and technical debt we observed in section iv that in practice software developers applied several refactoring types at the dockerfile and docker compose levels.
currently all the identified refactoringtypes are manually applied due to the lack of any semi automated tool support.
with this proposed empirical study we described the scientific foundations required to enable theimplementation of the refactoring types identified for docker files and docker compose files.
the same observation apply tothe technical debt categories for docker projects.
thus toolbuilders can use the definition and symptoms discovered inthis empirical foundation to define validate and implementdetection rules to automatically identify the quality issues indockerfile and docker compose files.
such tools could notonly save developers effort and time but could also bringa discipline toward refactorings of docker projects within asoftware development team.
although we do not expect practitioners to fix all the detected technical debts independently from the context weexpect them to judge which quality issues in dockerfilesand docker compose files are more relevant and adequate fortheir specific context.
team leads can work with developersto establish customized guidelines from this study for dealingwith technical debts in docker projects.
these guidelines couldalso trigger developers to capture the impact and the rationaleof their docker changes appropriately for each situation bydeveloping beneficial habits and long lasting projects.
our results can also provide a common ground for documenting discussing and assessing refactorings and theirimpact on docker projects.
this common ground will helpeducators to disseminate multiple dimensions of refactoringsin docker projects.
further they could encourage the practiceof refactoring continuously based on the examples and dataprovided in this empirical study.c.
optimizing docker performance it is not surprising that the main rationale of refactoring docker projects is to optimize the usage of resources e.g.
memory cpu etc.
needed to execute the containers viareducing the image size removing duplication and reducingthe build time.
indeed docker projects are recently usedextensively in cyber physical systems including automotiveindustry and smart manufacturing .
the hardwareresources are typically limited thus refactoring may play abigger role in optimizing the size and performance of dockerprojects once semi automated tools are available based on thescientific foundation of this study.
vi.
t hrea ts to v alidity in this study we selected docker projects to identify refactoring types and technical debt categories but they maynot be representative to the very large number of dockerprojects on github.
to address this threat we ensured thatthe selected projects are diverse in domains sizes and realisticin terms of the evolution history and popularity.
thus weused various github metrics including the number contributor users stars commits etc.
to evaluate their popularity anddiversity.
despite java was the dominant language on appli cations hosting containers selected to facilitate the manualanalysis of the regular code refactoring around of theprojects are written in c .
indeed the refactoring types andtheir rationale in object oriented programming are almost thesame thus the impact of our selection criteria are limited tothe generalizability of the co evolution results between dockerand docker compose refactorings and regular code ones.
the manual identifications and classification of refactoring types and technical debt categories can be subjective.
to miti gate this threat four experts evaluate all the selected commitsseparately and the agreement coefficient score between allof them was high for all the identification and classificationresults as discussed in section iii.
for the few cases ofdisagreement the different experts discussed the commit s after submitting their results to avoid any bias.
our studyalso involved many hours of manual inspection and analysisto understand and categorize the docker specific refactorings.to mitigate these threats the four experts used the commitmessages pull requests descriptions and comments in the codeto better understand the context of the changes and they onlymarked the refactorings and their rationale when they are veryconfident about them.
for the regular code refactorings co evolution study refminer was used to confirm and aidthe manual inspection of the refactoring types even though allcommits were manually inspected carefully for any potentialfalse positives.
vii.
r ela ted work a. docker smells few studies investigated quality issues in docker projects and they are all limited to dockerfile.
similar to traditionalconfiguration code smells docker smells are indicatorsof certain designs flaws and weaknesses in the dockerfile.
789without being actual bugs these smells potentially affect the image in a negative way.
although docker s documentationprovides a list of best practices 1to fix different kind of smells developers are still violating these recommendations.
yiwen etal.
divided dockerfile smells into two major categories dl smells referring to the violation of the official dockerfilebest practices rules and sc smells referring to the violationof the basic shell scripts practices .
they described dockerfilesmells occurrence by proposing an empirical study in open source projects and they found that nearly of theseprojects have smells in their dockerfile code.
further theyfound that dl smells appear way more than sc smells.
some other studies focused on building automated and semi automated tools to help the detection of bad practices indockerfile.
hadolint haskell dockerfile linter is a smart dockerfile linter that can be used to help developers to buildthe best practice into the docker images.
the linter parsesthe dockerfile into an ast and performs rules on top ofthe ast in order to detect dl smells based on shellcheck to lint the bash code inside run instructions for the sc smells detection.
henkel et al.
proposed a tool similarto hadolint named binnacle which performs rule miningover dockerfiles collected from github.
however this tool mainly focused on bash related rules.
xu et al.
defined a new type of smell named tf smell which stands for temporary file smell it indicates a careless use of temporaryfile in image building process that may cause temporary fileleft in the image which increases the image size and affectsthe distribution.
all above mentioned studies focus on detecting bad practice smells on dockerfiles.
none of them worked on sug gesting possible refactorings or the technical debt categories including smells for docker compose files or the regular coderefactoring observed in docker projects.
b. refactoring and design flaws our work is mainly related to approaches identifying design flaws and recommending how to fix them and empirical studies on refactoring.
several approaches have been pro posed to automatically detect design flaws i.e.
anti patterns code smells etc.
.
we only discuss a few representative worksand refer the interested reader to the recent survey by sharmaand spinellis for a complete overview.
marinescu proposes a metric based mechanism to capture deviationsfrom good design principles and heuristics called detectionstrategies .
such strategies are based on the identification ofsymptoms characterizing a particular smell and metrics for measuring such symptoms.
moha et al.
exploit a similaridea in their decor approach proposing a domain specificlanguage dsl for specifying smells using high level ab stractions.
besides metrics exploiting structural informationextracted from the code palomba et al.
provide evidence historical data can be successfully exploited to identifycode smells.
a lot of effort has been devoted to the definition of approaches supporting refactorings.
one representative exampleis jdeodorant a tool proposed by tsantalis and chatzigeor giou et al.
able to detect and refactor the code to fix fourcode smells i.e.
state checking long method god classes and code clones .
we point the interested reader to the survey by bavota et al.
for an overview of approaches supportingcode refactoring.
empirical studies on software refactoring mainly aim to investigate software developers refactoring habits and the re lationship between refactorings and code quality.
murphy hillet al.
investigated how developers perform refactorings.examples of the exploited datasets are usage data from 41developers using the eclipse environment and information ex tracted from versioning systems.
among their several findings they show that developers often perform floss refactoring namely they interleave refactorings with other programmingactivities confirming that refactorings are rarely performedin isolation.
kim et al.
present a survey of softwarerefactoring with microsoft s engineers to investigate whenand how they refactor code and the developers perceptiontowards the benefits risks and challenges of refactoring .they show that the major risk factor perceived by developerswith regards to refactoring is the introduction of bugs and oneof the main benefits they expect is to have fewer bugs in thefuture thus indicating the usefulness of refactoring for codecomponents exhibiting high fault proneness.
to the best of our knowledge this paper presents the first study on refactoring for docker projects since most of theexisting studies focus on traditional paradigms such as object oriented programming.
several of the aforementioned studiescan be adopted to transfer the knowledge into this paradigm but a first step is to provide an empirical foundation to definerefactoring types for the docker domain.
viii.
c onclusion we proposed a study to advance the knowledge of docker refactorings and technical debts which are under exploredin the literature.
we have manually investigated and definedspecific refactoring types and technical debt categories fordocker projects.
we have also studied the co evolution be tween applying those docker specific refactorings and regularrefactorings on the code of the app hosting the containers.a taxonomy of refactorings in docker projects was proposedincluding new dockerfile related refactorings docker compose related refactorings and technical debt categories.
in the future we will use the scientific foundations of this study to build new tools for refactorings detection andrecommendation for docker projects.
r eferences c. abid v .
alizadeh m. kessentini t. do nascimento ferreira and d. dig.
years of software refactoring research a systematic literature review.
ieee transactions on software engineering .
v .
alizadeh and m. kessentini.
reducing interactive refactoring effort via clustering based multi objective search.
in proceedings of the 33rd acm ieee international conference on automated software engineering pages .
v .
alizadeh m. kessentini w. mkaouer m. ocinneide a. ouni and y .
cai.
an interactive and dynamic search based approach tosoftware refactoring recommendations.
ieee transactions on software engineering .
anonymous author s .
study appendix .
view ase21 docker refactorings.
g. bavota a. de lucia a. marcus and r. oliveto.
recommending refactoring operations in large software systems.
in m. p .
robillard w. maalej r. j. walker and t. zimmermann editors recommendation systems in software engineering pages .
springer berlinheidelberg .
n. brown y .
cai y .
guo r. kazman m. kim p .
kruchten e. lim a. maccormack r. nord i. ozkaya r. sangwan c. seaman k. sul livan and n. zazworka.
managing technical debt in software reliantsystems.
in proceedings of the fse sdp workshop on future of software engineering research foser page new y ork ny usa .
association for computing machinery.
j. cito g. schermann j. e. wittern p .
leitner s. zumberi and h. c. gall.
an empirical analysis of the docker container ecosystem on github.inproceedings of the ieee acm 14th international conference on mining software repositories msr pages .
z. codabux and b. williams.
managing technical debt an industrial case study.
in 4th international workshop on managing technical debt mtd .
b. p .
datasets .
docker .
docker compose .
dockerhub .
m. fowler.
refactoring improving the design of existing programs.
addison wesley professional edition .
f. hassan r. rodriguez and x. wang.
rudsea recommending updates of dockerfiles via software environment analysis.
in proceedings of the 33rd acm ieee international conference on automated software engineering pages .
j. henkel c. bird s. k. lahiri and t. reps. learning from understanding and supporting devops artifacts for docker.
in proceedings of the 42nd international conference on software engineering icse .
iwei xu y .
wu z. lu and t. wang.
dockerfile tf smell detection based on dynamic and static analysis methods.
in proceedings of the 43rd ieee annual computer software and applications conference compsac .
y .
jiang and b. adams.
co evolution of infrastructure and source code an empirical study.
in proceedings of the 12th working conference on mining software repositories .
m. kim t. zimmermann and n. nagappan.
an empirical study of refactoringchallenges and benefits at microsoft.
ieee transactions on software engineering july .
p .
s. kochhar and d. lo.
revisiting assert use in github projects.
in proceedings of the 21st international conference on evaluation andassessment in software engineering ease pages .
r. lovas a. farkas a. c. marosi s. cs j. kov cs .
szal ki and b. k d r. orchestrated platform for cyber physical systems.
complexity .
r. marinescu.
detection strategies metrics based rules for detecting design flaws.
in proceedings of the international conference on software maintenance icsm pages .
ieee .
w. mkaouer m. kessentini a. shaout p .
koligheu s. bechikh k. deb and a. ouni.
many objective software remodularization using nsga iii.
acm transactions on software engineering and methodology tosem .
n. moha y .
g. gu h neuc l. duchien and a. f. l. meur.
decor a method for the specification and detection of code and design smells.ieee transactions on software engineering .
e. murphy hill c. parnin and a. p .
black.
how we refactor and how we know it.
ieee transactions on software engineering .
a. d. neal r. g. sharpe p .
p .
conway and a. a. west.
smartia cyber physical intelligent container for industry .
manufacturing.
journal of manufacturing systems .
f. palomba g. bavota m. di penta r. oliveto d. poshyvanyk and a. de lucia.
mining version histories for detecting code smells.
ieee transactions on software engineering .
portworx.
annual container adoption survey huge growth in containers .
n. rachatasumrit and m. kim.
an empirical investigation into the impact of refactoring on regression testing.
in software maintenance icsm 28th ieee international conference on pages .ieee .
t. sharma m. fragkoulis and d. spinellis.
does your configuration code smell?
in proceedings of the ieee acm 13th working conference on mining software repositories msr pages .
ieee .
t. sharma and d. spinellis.
a survey on software smells.
journal of systems and software .
d. silva n. tsantalis and m. t. v alente.
why we refactor?
confessions of github contributors.
in proceedings of the 24th acm sigsoft international symposium on foundations of software engineering pages858 .
n. tsantalis and a. chatzigeorgiou.
identification of move method refactoring opportunities.
ieee transactions on software engineering .
n. tsantalis m. mansouri l. m. eshkevari d. mazinanian and d. dig.
accurate and efficient refactoring detection in commit history.
in proceedings of the 40th international conference on software engineering icse pages new y ork ny usa .
acm.
a. j. viera j. m. garrett et al.
understanding interobserver agreement the kappa statistic.
fam med .
y .
wang y .
sun z. lin and j. min.
container based performance isolation for multi tenant saas applications in micro service architecture.journal of physics conference series .
y .
wu y .
zhang t. wang and h. wang.
characterizing the occurrence of dockerfile smells in open source software an empirical study.
ieee access .
l. zhang d. tiwari b. morin b. baudry and m. monperrus.
automatic observability for dockerized java applications.
arxiv .