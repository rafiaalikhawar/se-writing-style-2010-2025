can program synthesis be used to learn merge conflict resolutions?
an empirical analysis rangeet pan vu ley nachiappan nagappany sumit gulwaniy shuvendu lahiriy mike kaufmany iowa state university ames ia usa rangeet iastate.edu ymicrosoft corporation redmond wa usa flevu sumitg shuvendu.lahiri mike.kaufman g microsoft.com nnagappan acm.com abstract forking structure is widespread in the open source repositories and that causes a significant number of merge conflicts.
in this paper we study the problem of textual merge conflicts from the perspective of microsoft edge a large highly collaborative fork of the main chromium branch with significant merge conflicts.
broadly this study is divided into two sections.
first we empirically evaluate textual merge conflicts in microsoft edge and classify them based on the type of files location of conflicts in a file and the size of conflicts.
we found that of the merge conflicts are line changes and many resolutions have frequent patterns.
second driven by these findings we explore program synthesis for the first time to learn patterns and resolve structural merge conflicts.
we propose a novel domain specific language dsl that captures many of the repetitive merge conflict resolution patterns and learn resolution strategies as programs in this dsl from example resolutions.
we found that the learned strategies can resolve .
of the conflicts of line changes that arise in the c files with .
accuracy.
index terms merge conflict program synthesis automated fixing i. i ntroduction textual merge conflicts occur when changes from independent commits over a common base cannot be resolved by a textual way differencing tool present in version control systems such as git.
merge conflicts are frequent and annoying and studies have shown they can have a significant impact on the development lifecycle of projects .
prior works have focused on predicting merge conflicts resolving them through using structured abstract syntax tree ast aware techniques or even verifying semantic correctness of merges using program verifiers .
although these approaches have paved the course for research on merge conflict prediction and resolution the problem of mergeconflicts persists in practice.
the reason can be attributed to a lack of structure aware tools for most languages apart from java and b the black box nature of these tools that rely on sophisticated matching algorithms to relate the changes make them inaccessible to mainstream developers.
in this paper we explore the problem of merge conflict resolution through a slightly different perspective.
instead of devising an algorithm to resolve any merge conflict we pose this work has been done when nachiappan nagappan was an employee at microsoft and rangeet pan was an intern at microsoft.the merge conflict resolution problem as that of learning repetitive resolution patterns from the history of a given project.
in fact ghitto et al.
observed patterns are commonplace in conflict resolution for a large project when viewed over the history of a project.
they also postulate that learning common resolution patterns in a project can be a useful aid for developers in resolving future conflicts.
with this motivation we conduct a large scale empirical study of textual merge conflicts that occur in microsoft edge a fork of the chromium browser and apply program synthesis in particular programming by example pbe to illustrate the feasibility of learning patterns for a large class of resolutions.
we chose microsoft edge as a subject due to a the collaborative nature of the project with developers and b the large number of merge conflicts that manifest as a result of merging changes from the chromium repository to this fork.
the study consists of two main parts.
first we perform an empirical study to classify the nature of merge conflicts for this project in terms of the prevalence of file types size of conflicts type of conflicts and the resolution patterns.
second we design a domain specific language dsl to capture the resolution patterns in this project and use program synthesis to automate the learning of resolution strategies as programs in this dsl.
in our rigorous empirical study of microsoft edge we found that a majority of the files with conflicts were written in c and a significant number of changes are of lines.
among these conflicts in c we find that .
are related to headers and macros.
more importantly we observe that these small conflicts usually follow a few distinct resolution patterns.
specifically we found different patterns in all of c liner changes and out of which patterns were found in include andmacro related conflicts.
we describe one such pattern in figure a where the header cursor type.mojom shared.h appears both in the forked and main branches and the developer excluded the one in the main branch and denote whether the statement has been taken into the resolved solution or not.
only the changes with operators are carried on to the resolution whereas the changes with operators are not .
figure b follows the same pattern with the only difference being the specific name of the header file.
similarly figures c d show another pattern where the developer removes base logging.h ieee acm 43rd international conference on software engineering icse .
ieee forked branch i n c l u d e u i ba s e anonymous uibase features .
h i n c l u d e u i ba s e mojom c u r s o r t y p e .
mojom s h a r e d .
h main branch i n c l u d e u i ba s e c u r s o r mojom c u r s o r t y p e .
mojom s h a r e d .
h a header location update example 1forked branch i n c l u d e u i ba s e anonymous uibase features .
h i n c l u d e u i ba s e mojom c u r s o r t y p e .
mojom b l i n k .
h main branch i n c l u d e u i ba s e c u r s o r mojom c u r s o r t y p e .
mojom b l i n k .
h b header location update example forked branch i n c l u d e ba s e l o g g i n g .
h i n c l u d e ba s e s c o p e d n a t i v e l i b r a r y .
h main branch i n c l u d e ba s e n o t r e a c h e d .
h c removal of a specific header example 1forked branch i n c l u d e ba se command line .
h i n c l u d e ba s e l o g g i n g .
h main branch i n c l u d e ba se check op .
h d removal of a specific header example fig.
examples of programming by example pbe to resolve merge conflicts in microsoft edge .
from the forked branch because microsoft edge uses a different logging system.
these examples demonstrate the existence of common resolution strategies in the history of a project and the value of learning such frequent patterns to automate future conflicts.
motivated by these patterns we propose a domain specific language dsl that contains the right set of abstractions tosuccinctly describe the patterns underlying the conflictresolution examples.
the key idea of our dsl is to describe the resolution as a guarded concatenation of fragments of the main and fork branches.
the fragments are constructed using some ordered set operators including indexing filtering and subtraction.
our dsl is able to express .
of conflict resolutions which also accounts for of line changes seen in c files for microsoft edge with .
accuracy.
expressing the resolution strategies as programs can address the limitations of fully automated tools in the hands of mainstream developers as developers can examine the program and understand the justification behind suggesting the changes and if new patterns emerge and existing patterns do not work a new program can be learned by either providing a few examples or updating the synthesized program.
our dsl which contains the right set of abstractions that allow succinct expression of conflict resolution patterns facilitates the development of a program synthesizer that can automatically learn intended patterns in this dsl from few examples.
the key idea behind our synthesizer is to leverage a top down synthesis methodology that reduces the synthesis problem to authoring efficient inverse functions for the various operators in our dsl .
contributions in summary the paper makes the following contributions a we empirically analyze textual merge conflict related data from microsoft edge to qualify various measures e.g.
which files are most prevalent to have conflicts how big these conflicts are and where the conflicts lie in a file.
finally we systematically discover and establish frequent patterns in resolving merge conflicts.
b we build a domain specific language dsl to address the include andmacro related patterns established by the empirical evaluation.
main m integration i forked f forkstabilization s a cycle of mergemain branch changestextual merge conflict fig.
the structure of the microsoft edge branch.
c we leverage a top down program synthesizer to learn the programs in this dsl to resolve the conflicts using inputoutput examples.
organization the paper is structured as follows we discuss the dataset collection steps in xii and the empirical study inxiii.
then we describe the domain specific language and the use of program synthesis for learning patterns through examples inxiv.
the results and related works are discussed inxv andxvi respectively.
finally xviii concludes.
ii.
d ataset a. main fork branch structure figure depicts the overall structure of microsoft edge where each line denotes a branch.
the main m is the chromium s master branch and fork f is the fork created by microsoft edge to pull the changes from the mto branch f. the arrow !
depicts the child parent fork main relation between two branches.
for example the arrow from the main m to fork f denotes that f is a fork of m. there are two more branches integration i andstabilization s .
these branches are intermediate checkpoints while pulling the changes from m branch.
in each cycle the changes from the mbranch are pulled to fbranch through iandsbranches.
first the conflicts are resolved at the ibranch after merging with the mbranch.
once conflicts are resolved a fresh build is performed at the sbranch and the changes in the sbranch are then pulled to the master branch of microsoft edge f branch .
a similar main fork branch structure can be found in other projects brave colibri epic samsung internet lg webos tv web engine etc.
mobile applications android fork 786table i merge related data for microsoft edge .
m main branch f forked branch merge related data week week week week week week week week total median sd merges .
.
commits in m .
.
commits in f .
.
conflicting commits .
.
conflicting files .
.
conflicting chunks .
.
database mariadb etc.
in github there are more than .
million forked projects in c alone .
b. data collection first we identify the merge commits by filtering the commits with two parents one from the main m branch and one from the forked f branch.
next we replay the merge commits for obtaining the conflicting files for each merge commit.
along with the conflicting file we store the resolved version of each conflicting files.
in table i the summary of the merge commits is shown.
we collected the merge data for eight weeks march to april and we divide the data by each week.
in the first row the total number of merge commits are shown.
these merge commits denote the number of times fbranch pulled the changes from the mbranch.
the second and third row denotes the total number of commits made by mandf branches during the period of time.
the fourth row denotes the number of merges that result in introducing conflicts in at least one file.
the fifth row shows the total number of files having at least one conflict.
finally in the sixth row we report that the number of conflicting chunks that have resulted from merging the two branches changes.
we found that on average .
of the merges and .
of all commits at f branch result in conflicts.
also on average conflicting files are generated per week.
we found that the number of merges sd .
commits in main sd .
and fork sd .
conflicting commits sd .
and conflicting files sd .
to be very consistent over the weeks.
in comparison to the java related conflicts microsoft edge mean has bigger conflicting chunks than the ones found in the prior work mean .
based on the p value and correlation value corr we found that conflicting chunk size p corr has no impact on the number of conflicts.
iii.
c lassification of merge conflicts in this section we empirically study the merge conflicts in microsoft edge and answer four questions a file type which file types are the most prevalent to have merge conflicts?
b conflict size how large are the conflicts?
c conflict location what are the different types of conflicts based on the origin of location?
d resolution pattern what are the conflict resolution patterns in microsoft edge ?
.
.
.
.
.
c headers build files dependency others python scripts data files text filesfig.
classification based on the file type.
a. which file types are the most prevalent to have merge conflicts?
here we classify the conflicts based on the type of files.
in figure we denote the percentage of the conflicts for each file type.
we found that most of the conflicts .
of the total conflicts are in the c related files and this is because the core functionality of both chromium andmicrosoft edge are written in c .
in the following paragraphs we briefly discuss the basic characteristics of each file type.
c the conflicts in these files are related to both logical and structural changes in the code.
the structural changes include the addition removal or update of the header files macros etc.
the logical changes are introduced to alter the logic of the operation.
for example addition of conditional check loop structure etc.
dependency these files are the dependency files that are needed to build microsoft edge from scratch.
very often dependencies e.g.
the version controllable parameters etc.
are updated by the main and the forked branch.
we found that various internal tools are used to automate the resolution of conflicts in this genre of files.
headers the definition and structures of the class are defined that are used in other files.
.
of the files having at least one conflicts are header related ones.
build files with each build including run time compilation a considerable number of files are auto generated.
c header build files dependency total c header build files dependency total forked branch main branch 50fig.
classification based on the conflict size.
when they are pushed along with other changes they often result in having conflicts.
since they are auto generated codes rebuilding can resolve the conflicts and they do not need any particular logical or structural changes for resolution.
python scripts .
of the conflicting files occur in the python scripts .py and .pyl files .
these files are utilized for running different scripting level codes.
data files mostly these are matrix market files .mm and grid data format .grd files and changes in the data often cause the conflicts.
however only .
of the conflicts occur in these files.
text files changes in the documentation related files such as readme files are categorized here.
others file types responsible for less than of the conflicting files are grouped in this category.
mostly commaseparated files .csv protobuf files representing the structure of the code .proto etc.
are in this group.
b. how big are the conflicts?
finding .
and .
of the conflicts in c are lines of change by the main and forked branches respectively.
overall of the conflicts are of lines for both main and forked branch.
each conflicting chunk has been divided into main and fork section based on the conflict markers.
furthermore we categorize each section based on the number of lines of changes.
we created twelve groups starting from lines to more than lines and compute the same for each type of files other than the others category.
here we refer to the conflict size as the number of lines reported by the conflict markers main fork section .
we found that the majority of the conflicts are of lines for either main .
or fork .
.
for c files where the majority of the conflicts occur we found that these numbers are .
and .
for main and fork respectively.
also we found that of the conflicts in c are of lines for both main and forked branches.
similar to what ghitto et al.
observed in java projects we found that a non trivial amount of conflicts are due to small 5othersmethodmacroloopincludeexpression statementdeclare statementconditionexpressiondeclarefig.
classification based on the location of the conflicts.
changes lines in c and for main and fork respectively .
the distribution of the conflicts is similar to the one found in java.
in java of the conflicts are of lines of code.
whereas in microsoft edge of the conflicts are of lines of code.
furthermore we computed thep value and the correlation value .
and found that lines of code has no impact on the number of conflicts.
given that smaller resolutions are more likely to be idiomatic and repetitive we focus on the lines of conflicts in both the main and forked regions.
moreover since the majority of conflicts are in c files we focus our study on the c files.
c. what are the different types of conflicts based on the origin of location?
based on the evidence that suggests the majority of the conflicts are in c files and are lines in size we move forward to classify the location of the conflicts.
we utilized gumtree to tokenize the code and use the abstract syntax tree ast to determine the changes.
we found that the conflicts mostly occur in seven locations that have been depicted in figure .
in the following paragraphs we briefly discuss each type of such location with appropriate examples.
condition in this type of change the conditional logic is updated.
for example in the code snippet below the main branch added an extra condition that resulted in a conflict during the merge.
this kind of conflict is .
of the total observed conflicts.
this is similar to the percentage of condition related conflicts found in java by the prior work .
forked branch if result !
did not handle main branch if elastic overscroll controller result !
did not handle declare in this type of change the variable declarations are altered .
of the observed conflicts .
in the following example the value of the variable ksettingsversion has been changed to from by the main branch and the data type has also been updated.
788forked branch static const uint32 t ksettingsmagic cpds static const uint32 t ksettingsversion main branch static constexpr uint32 t ksettingsmagic cpds static constexpr uint32 t ksettingsversion expression .
of the conflicts originated due to changes in expressions.
change in the parameter while calling a procedure calling a different procedure etc.
are categorized in this classification section.
finding .
of lines of conflicts in c files are due to addition deletion or updating the include section.
include these types of changes are the most prevalent ones in the observed dataset.
mostly the changes include the addition deletion and updating of the location of the headers.
for instance in the following example the main and forked branch added a new header file that caused the conflict to occur.
forked branch include chrome browser ui views accessibility hc with theme bubble view.h main branch include chrome browser ui views accessibility caption bubble controller views.h we found that .
of conflicts of size lines are related to the include statement.
this category of conflicts is higher than the observation made by ghitto et al.
where of the conflicts in java are due to the import statement similar to the include statement in c .
the prior work has analyzed all the conflict sizes whereas our analysis is based on the liner conflicts.
loop only a small amount of conflicts .
result from the change in the looping structure.
macro c programs make extensive use of macros to enable code reuse.
we found that .
of the conflicts in c that are of lines are due to changes in the macro.
one such example has been depicted in the code snippet where value corresponds to an argument has been changed by forked branch in proc browser test p v4 anonymous disabled permanent malwarewithwhitelist main branch in proc browser test f v4 the forked branch.
in microsoft edge macros are mostly used to disable the main branch s chromium tests that do not work inmicrosoft edge for various reasons e.g.
flaky test or main branch tests a feature that microsoft edge does not ship or related to debugging.
however a large majority of the macro conflicts are more precisely test disablement.
method .
of the changes that cause conflicts are related to the changes in the method declaration e.g.
the return type return value etc.
this genre of conflicts is less in c than in java .
others in this category we classify any conflicts that occur other than the previously mentioned ones.
mostly they are situated in the comment block and only .
of the conflicts under observation have been caused in these places.
d. what are the conflict resolution patterns in microsoft edge?
next we empirically evaluate every lines of changes both main and forked branch and identify the patterns based on the type of operations that the developers did to resolve the merge conflict.
in this context any resolution that removes the conflict markers is treated as a conflict resolution.
we used the open coding scheme to build the classification scheme.
first we label the of the merge conflicts and build the classification scheme.
then if needed we add the classification category and revise the labels.
furthermore the classification scheme has been verified by the third and the fifth authors who are experts in software engineering study and merge conflicts.
finally when no new classification category has been added we completed the labeling process.
a total of nine types of operations are found in our dataset.
in the following paragraphs we discuss each type of merge conflict resolving patterns and understand the root cause of such patterns with proper examples.
apply forked specific changes afsc microsoft edge has created a fork and periodically they pull the changes from the chromium to update the codebase.
we found that developers from microsoft edge update the code to reflect the forked branch specific changes e.g.
disabling tests adding forked branch specific header etc.
when this kind of change is reflected in the merge conflict the forked or microsoft edge specific changes are taken into account and the main branchspecific changes are discarded.
example .
apply fork specific changes where microsoft edge added a test disabling check.
forked branch in proc browser test f v4 anonymous disabled permanent checkunwantedsoftwareurl main branch in proc browser test f v4 checkunwantedsoftwareurl in the code snippet the forked branch introduced a check in the second parameter of the browser test case procedure which has been used to disable a portion of the test cases in microsoft edge .
in the resolution of the merge conflict the developer chose the fork branch changes discarding the main branch changes.
these kinds of operations are mostly prevalent in changes located in macro .
expression .
and include statements .
.
change in the header ch a small portion of the conflicts is due to a change caused by another change in a afscchconcat ddcfblcrdrename siothersfig.
classification based on the type of operations that developers do to resolve.
afsc apply forked specific change ch change in the header concat concatenation ddc dependency on different conflicts fb frequent behavior lc logical change rd remove duplicate and si space introduced.
different place mostly in a header file .
for instance the forked branch s change has added an extra parameter while calling the procedure.
as the forked branch had made a change in the header function onextensiondownloadfinished by adding a new parameter the same change has been reflected in the c file to be consistent.
while resolving the conflict developers chose the latest changes fork branch related .
example .
a change in the header file caused the update of the following code.
forked branch on call this onextensiondownloadfinished main branch on call this onextensiondownloadfinished concatenating changes from two branches concat finding .
of the resolution strategies involved concatenating the main and the forked branch s changes.
a vast majority of the resolution strategies are based on keeping both the changes that resulted in a conflict.
for example in case of the changes in the include statements the developers can often take both changes without any particular order if there is no commonality between the header files .
assume the main branch has made a change that involves the addition of the header header1.h and the forked branch added a header header2.h .
a developer often chooses to resolve the conflict by taking both the headers.
since these headers inmicrosoft edge usually contain independent classes the order in which the include statements are concatenated doesnot matter.
however for changes where more complex logic is involved the concatenation requires to be more aligned with semantics rather than be on the syntactic changes.
for example in the code snippet the resolution can be either the changes in the forked branch followed by the changes from the main branch or the changes from the main branch followed by the changes from the forked branch.
if the latter strategy is taken the header2 and header3 actual name of the header has been changed will be included in the conditional statement so they would only be called if the conditional check returns true.
however this would create an anomaly in the code if there is a dependency on the header files irrespective of the value of the conditional check.
example .
applying both the changes done by the forked and the main branch.
if !defined project anonymous build include header1 name forked branch endif main branch include header2 name include header3 name dependency of different conflicts ddc this type of resolution strategy accounts for a small number of scenarios .
.
if more than one conflict is present in the c file and one decision of resolution affects the resolution of another conflict we label the fixing strategies as this group.
example .
a header file has a dependency on a section of code which is also in the conflicting region.
forked branch include components project anonymous core common switches.h include components version info channel.h 790main branch the header file components version info channel.h has been referred to in a single place of the file and that section was deleted while resolving another conflict.
here the reference is denoted by the class object relation.
the header file channel.h has a class named channel declared and the object of that class has been used in the c file that includes the header statement.
since the object reference is no longer present the developer decides to remove the include statement as well.
frequent behavior fb we found that there are some repetitive patterns where developers remove a specific header file while fixing the merge conflicts.
for example .
of out of the scenarios involving the base logging.h header file the line related to the specific header file has been deleted keeping other changes intact figure c and d .
this is a project specific pattern which is due to the fact that fork is using the logging function differently than the main.
logical changes lc this genre of fixing strategies needs a logical understanding of the code.
in most cases the resolve includes a section of the main and the forked branch stitched by an appropriate logic.
remove duplicates rd these fixing strategies are mostly found in the condition .
declare .
expression .
and include related conflicts.
overall .
of the conflicts under observation are resolved by removing the duplicate content.
often the main or forked branch moves a file into a different location and updates the same in the code.
to resolve such conflicts developers tend to remove the duplicate include statement s .
for example the code snippet in figure a has the same header name cursor type.mojom shared.h in the main and the forked branch.
however the location of the file has been changed without changing the content of the header file.
in such a scenario the developer can choose any version of the cursor type.mojom shared.h file and take the rest of the changes from the main and the forked branch.
the same can happen with header files outside the conflicting region.
another scenario includes the variable declaration.
in the following scenario the variable supervised user idhas not been initialized main branch or initialized with a default value forked branch .
however in c the effect of either statement will result in the same effect.
if the string is not initialized then the default constructor will be called and it will assign a zero size character to the string which is similar to initializing with the empty string .
to resolve such conflict the developer can choose any version of the variable declaration and add that with the endif line.
forked branch endif std string supervised user id main branch std string supervised user id rename related fixes file renaming is very common in a fork structure.
in our case resolving the rename related operation accounts for .
of conflicts with lines of change and they are most prevalent in macros .
in this scenario any of the two parties involved have changed the name of the function and to make it consistent every place where the function has been called has been changed too.
this kind of change often results in conflicts and one such instance has been depicted in the following example.
example .
microsoft edge test has been renamed.
forked branch in proc browser test p v4 anonymous disabled permanent checkresourceurl main branch in proc browser test f v4 checkresourceurl the name of the test has been updated by the main to inproc browser test ffrom inproc browser test p. in such cases the developer chose the renamed version of the function name and resolved the conflict.
space removed sr introducing an extra space in the code can cause a conflict.
as the default merging strategy is based on the textual difference these scenarios are also considered as a case for merge conflict.
in such scenarios developers remove the space.
others here we labeled the conflicts that have no pattern of fixing or not enough information to conclude.
iv.
c ase study on deploying synthesis for resolving merge conflicts the empirical study has identified several patterns for resolving merge conflicts.
we used these high level patterns to guide the dsl to resolve the conflicts.
we now discuss the use of program synthesis to learn programs expressing these patterns from examples.
we first use some examples from the previous section to motivate the design of our dsl.
we then formally define the dsl and discuss the learning of programs in this dsl from examples using prose an inductive program synthesis framework .
the dsl that we propose possesses some syntactic sugar to be able to convey the high level patterns.
we did not want to break the patterns into assembly level languages.
a. motivating examples recall that in figure c and d the desired behavior is to remove the header base logging.h from the forked branch s changes then concatenate the changes in both branches.
additionally we need a guard to only execute the resolution above when the forked branch contains base logging.h .
otherwise the resolution would blindly apply to other non applicable cases.
here is a program that expresses the pattern above apply frequentpattern x base logging.h concat main x remove fork x forkbypath x base logging.h in this program apply checks if the forked branch of the inputxcontains the header base logging.h using the 791predicate frequentpattern then returns the resolved text as the concatenation of the main branch and the forked branch having the header base logging.h removed.
in figure a the header cursor type.mojom shared.h appears in both the main and forked branches hence only the header in the forked branch is selected.
although we can use a predicate to check if both main and fork contain that particular header such a predicate is very specific to that header name and cannot capture other headers.
instead we introduce a predicate duplicatemainfork to check if there are any headers that appear in both main and forked branches.
we then resolve the merge by concatenating a the forked branch and b the main branch with these duplicated headers removed note that pattern ... returns the duplicated headers .
apply duplicatemainfork x concat fork x remove main x pattern x duplicatemainfork b. dsl for resolving merge conflicts output r apply c t condition c and p c jp predicate p duplicatemainfork x jduplicatemainoutside x jduplicateforkoutside x jmainspecific x jforkspecific x jdependency x jrename x jfrequentpattern x path transformation t concat t t jremove s s js selection s main x jfork x jforkbypath x path jforkbyindex x k jmainbyindex x k jmainbypath x path jpattern x key fig.
syntax of our dsl.
xrefers to the input.
path k key denote a path constant an integer constant and a string constant respectively.
having demonstrated some program constructs in our dsl we now discuss the dsl in detail.
figure shows its syntax.
at a high level a program takes an input x a struct that contains the main and fork sections denoted by the conflict marker the location of the file the rest of the content of the file and returns the resolved text.
we take the location of the file to extract the content of the imported header files and utilize them to detect the patterns e.g.
the example depicted inx3.
where we check the rest of the content and the content of the header files along with the content between the conflict markers.
the program uses apply to check if some conditions chold then performs the merge resolution tthat transforms the common base program to a resolved program.
condition the condition cis a conjunction of one or more predicates.
our dsl has the following predicates to capture the classification discussed in section iii duplicatemainfork some content appears in both main and forked branches.
figures a b illustrate this predicate in which the header cursor type.mojomshared.h and cursor type.mojom blink.h have the same name and content in both main and fork.
duplicate outside some content appears in both the main or forked branch s conflicting region and non conflicting region.
mainspecific forkspecific the main or forked branch has some identifiers that are main or fork specific.
for instance the change in example .
is fork specific because it has the macro anonymous disabled permanent .
dependency one or more headers have dependency control dependency on other conflicting regions.
example .
illustrates this predicate where channel.h header has a dependency on another conflicting region.
frequentpattern this predicate captures a repetitive pattern when a specific header identified by the literalpath is present in the conflicting regions.
figure c and d illustrate this predicate in which path is base logging.h .
rename check whether the name of the tests in the macro has been altered or not.
example .
uses this predicate to capture rename operation.
transformation during the study we observed that the merge resolution usually involves the concatenation of some nodes selected from the main or forked branches.
the resolution also occasionally removes some nodes from a branch because they appear in both branches.
based on this observation we designed the transformation tthat allows arbitrary combination of concatenation concat and removal remove of nodes.
the key insight of designing a dsl amenable for synthesis is that the dsl should be expressive enough to cover common patterns yet it should be restrictive enough to allow for efficient learning.
in our dsl while concat allows concatenation of two other transformations t remove only allows removal of some selected nodes sfrom some other selected nodes s. restrictions like these reduce the search space for transformation significantly while still allowing for the expression of all patterns in section iii.
our dsl allows selecting the whole main or forked branch viamain andfork .
it also supports selection using index or path by .
the former selects thekthnode from a branch while the later selects a node based on path.
furthermore some patterns in our study require selecting nodes that are relevant to the predicates.
by selecting main and fork we want to identify only the main related section of the conflict marker.
the nodes are ast nodes.
however because our dsl only works with include and macros we simplify the nodes to contain only relevant information.
for instance an include statement include foo corresponds to a node that has two children one for include and another one for foo .
we allow such selection via pattern where a string 792key is used to identify the predicate name.
in the example in section iv a pattern x duplicatemainfork selects nodes related to the predicate duplicatemainfork i.e.
the nodes appearing in both the main and forked branches .
internally our program calculates a dictionary that maps each pattern to some nodes.
the dictionary is used both in evaluating the predicate and selecting the pattern nodes.
c. synthesizing programs from examples we now discuss the synthesis process to learn programs in our dsl from examples using prose .
prose framework is a meta synthesizer i.e.
a system that allows people to implement inductive synthesizers more easily by re using shared components which would otherwise have to be reimplemented in different synthesizers.
prior to prose authors of inductive synthesizers such as flashfill flashextract had to implement their synthesizers from scratch.
newer synthesizers such as refazer bluepencil leverage prose to speed up the development.
we follow the same strategy.
to create a new synthesizer in prose one needs to design the dsl and its semantics implement the witness learning functions and define a ranking scheme for programs.
all other low level details such as building the version space algebra intersection of program sets are taken care of by the prose framework.
readers may refer to for a more detailed discussion on inductive program synthesis as well as exemplar synthesizers on other domains.
the input also called specification to the inductive synthesizer is some examples in the form of f i oign i 1where iis the inputx oiis the expected resolved output n is the number of examples.
the prose methodology requires each dsl function to be accompanied with a witness function wf also called inverse function which takes the output and returns the set of all input configurations to that function that can generate that output.
notice that a wf does the inverse of its normal function which takes the inputs and returns the output.
prose uses the wfs to decompose the input specification into smaller specifications for each of the parameters effectively decomposing a complicated learning task into several smaller simpler tasks.
the divide and conquer process continues until it reaches the leaf nodes in the grammar at which point the leaf nodes are either variables or literals.
given a specification f i oign i the wf of apply c t reduces it to a f i truegn i 1for condition c where we need to learn a conjunction of predicates that returns true on inputs i and b f i oign i 1for transformation t where we need to learn a transformation that converts inputs ito outputsoi.
learning conditions the task here is to find predicates matching the patterns in the input i. we simply select all predicates whose evaluation on the input is true .
one exception is frequentpattern where we also need to synthesize all possible values for path such that applying the predicate on path returns true .
learning transformations the goal here is to learn a sequence of transformations that transforms itooifor alli.
while learning concat its wf decomposes the output oiinto all pairs oi1 oi2such that concat oi1 oi2 oi.
this yields two sub tasks with specifications f i oi1gn i 1and f i oi2gn i .
if prose finds transformations t1andt2for these sub tasks it returns concat t1 t2 as the result of learning this function.
e.g.
in figure d where the resolved output contains two includes for base command line.h and base check op.h concat s wf assigns each include to a sub task.
prose recursively finds if there is a transformation t1that produces base command line.h and t2that produces base check op.h .
the learning of remove is similar its wf decomposes the outputoiinto all pairs oi1 oi2such that remove oi1 oi2 oi.
in the above example one way to obtain the include for base command line.h oi is to select the forked branch which contains base command line.h and base logging.h oi1 and removes base logging.h oi2 from it.
the learning of by functions simply returns the index or the path of the output in the main fork input depending on whether the function is index based or path based.
for instance to produce base check op.h two possible selections are main x where we select the main branch or mainbyindex x where we select the first line of the main branch.
to learnkey forpattern we iterate over all patterns and return those whose nodes match the output.
e.g.
in figure a the pattern duplicatemainfork produces the duplicate node ui base cursor mojom cursor type.mojomshared.h hence the key duplicatemainfork is selected.
ranking scheme since there are often multiple programs that satisfy a given set of examples inductive synthesizers use a ranking scheme to select the most likely program.
for instance in figure c here are two possible choices for transformation t among many others concat mainbyindex x forkbyindex x concat main x remove fork x forkbypath x base logging.h although both programs are consistent with this scenario our ranking scheme selects the latter program which happens to be the intended one.
we defined our ranking function to be a small weighted combination of a set of features that we discovered were relevant for our domain.
for instance we prefer programs that are smaller and use fewer constants since such programs generalize better to unseen inputs hence our feature set includes the number of operators and the number of constants in the program.
another feature accounts for favoring path based programs to index based programs because the former is more general or for favoring selection from one of the branches since that is more likely.
v. r esults we now present our experimental results of using program synthesis to automate merge conflict resolution.
apart from the week dataset that is used to design our dsl and synthesizer we also collected merge conflicts for 793table ii results of using program synthesis on microsoft edge over weeks data.
pattern name pattern count user resolution concat .
afsc include .
rd .
fb .
ddc .
rename .
afsc macro .
total .
another weeks march to march to evaluate our approach.
in this section we answer the following questions rq1 what portion of the merge conflicts can be automated?
rq2 how accurately can we assist developers in resolving the merge conflicts?
rq1 what portion of the merge conflicts can be automated?
our empirical study found that of the c conflicts are of lines of changes for both the main and fork branch.
among those include andmacro related conflicts account for .
and .
respectively.
for macro related conflicts we focus on the test disabling macros by selecting the conflicts having microsoft edge specific keywords such asdisabled anonymous removed for double blind in the argument.
we found that of the macro related conflicts are of test disabling.
for include related issues cases mentioned as others in the classification had files deleted when the developers resolved the conflict.
we omitted those scenarios from our dataset because we were not able to get the resolution.
overall our approach handles .
of the total conflicts in c files.
rq2 how accurately can we assist developers while resolving the merge conflicts?
finding overall our approach handles .
of the total conflicts in c files which is .
of all the line changes in c .
table ii presents our results on various include andmacro scenarios on our week dataset.
in this table the column user resolution represents the total number of resolutions provided by our approach that match with the resolution performed by the developers.
to perform the experiment we extract the solutions after developers resolve all the conflicts in the commits and match that with our proposed resolution.
we found that overall our programs can assist the developers to resolve the merge conflict with .
accuracy.
if the conditions depicted in our dsl in xiv b do not match the type of merge conflict that appears in the new examples then our approach will not suggest.
also these programs achieve .
accuracy on the unseen week dataset that we collected after our initial study.
because the conflicts in the week dataset are not classified we did not report its detailed results by classification in table ii.
instead we reportthe frequency of patterns detected while applying programs on this dataset.
we found that concatenation is applied .
of the cases apply for fork specific both include and macro .
frequent behavior .
and remove duplicate .
.
these results indicate that program synthesis can be applied to resolve merge conflicts.
vi.
r elated work merge conflicts in this paper we studied the problem of repeated patterns in textual merge conflict resolution in large projects.
ghiotto et al.
et al.
perform a large scale study of merge conflicts over java projects and characterize the nature of merge conflicts and patterns in resolutions.
the study envisions the need for tools that can capture the patterns in such resolutions.
in addition to complementing the study by focusing on forks our work can be seen as the first realization of the vision in this paper for a large project by using program synthesis to capture the frequent patterns.
the problem of resolving merge conflicts soundly has received a lot of attention going back to the work of program integration where static analysis on the three input programs is performed to create a merge satisfying a conflict freedom property.
however such approaches were never implemented or evaluated on real world benchmarks.
more recently sousa et al.
use program verifiers to check for the semantic conflict freedom notion of correctness of a given merge but do not synthesize the merge.
structured and semi structured merge tools such as jdime resolve some class of textual conflicts by lifting the textual way differencing algorithm to the case of abstract syntax trees.
since we are analyzing c we cannot perform a direct comparison due to the lack of such tools for c .
however we believe our technique is complementary to such structured algorithms.
one can apply the structured algorithms to first soundly resolve conflicts and then turn to a synthesis guided approach to fall back on the learned resolution for the remaining.
in addition we believe that the structured techniques will not apply to most of the cases we encounter in this paper due to the asymmetric nature of the fork related changes e.g.
afsc and renaming or movement of header files.
finally the work of sung et al.
studies and proposes fixing build breaks introduced by a merge in main fork structure but does not deal with the problem of textual merge conflicts.
bug fixing recently bader et al.
applied a hierarchical clustering technique to address the fixing bugs by learning through examples.
in this study the ast based differencing technique has been used to identify the edits and clusters the edits based on the patterns.
finally these fixes are applied to the code to address different patterns in java e.g.
null pointer exception boxed primitive constructor new class instances etc.
however in our work we empirically evaluated the merge conflicts in microsoft edge and take examples for each pattern to build programs that can assist developers in resolving the include andmacro related conflicts.
program synthesis prior work applied program by examples pbe a form of program synthesis whose specification is examples to various domains .
gulwani introduced flashfill a system that synthesizes string transformation scripts from examples .
flashextract allows end users to extract hierarchical data from semi structured files by simply highlighting some examples.
anderson and lawall anderson et al.
proposed techniques to learn version update patches for linux files from input output examples.
meng et al.
developed sydit and lase to synthesize code edit scripts from examples.
our work targets a new different domain that has not been explored by pbe merge conflict resolutions.
unlike prior work which usually operates on a single snapshot of a file or program our synthesizer learns patterns and transformation from various places changes in the main branch changes in the forked branch and also file content outside the conflicting regions.
vii.
t hreats to validity construct validity replaying merges and identifying conflicts have been done using the git based system.
given the broad and extensive use of such system we believe that errors in measurement during the dataset collection are avoided.
internal validity the empirical evaluation the pattern recognition and the domain specific language built from the patterns are done as a part of a case study on microsoft edge .
also the patterns were recognized and tested on weeks of data.
though we believe that learning from the past can have a potential impact on the resolution of merge conflicts new patterns can emerge in the future and that can be addressed in two possible ways one learning the new pattern from the existing dsl.
second update the dsl to accommodate the new patterns.
a possible threat is that it is possible that some scenarios are not detected by our empirical evaluation in xiii due to the week timeline.
another possible threat can be overfitting.
to remediate the overfitting we have taken two steps.
first we built our ranking function to choose smaller and more general programs based on the occam s razor principle.
simultaneously the dsl has to be expressive enough to cover as many tasks as possible while being concise enough to be learned efficiently.
keeping both concerns in mind we consciously bias our dsl to choose the smaller programs by punishing the longer ones using the ranking function.
second the overfitting can also be removed by applying more examples for the learning process.
for this study we used examples for each pattern.
our solution can be extended to incorporate more examples to remove overfitting if needed in the future.
however since our approach and the dsl has been based on the patterns and common resolution strategies found in the empirical evaluation there can be scenarios where our approach may not work and needs re training.
for example all the fixing strategies are based on a simple fact that the line s nodes from either the main or fork section of the conflict will be removed or concatenated.
there might be scenarios where none of the strategies are applicable for instance taking both the main and fork section of theconflict and changing some parameters.
in such scenarios our approach will not be able to generate any solution.
however this situation can be tackled by extending the underlying implementation of the selection operations in our dsl.
currently bypath works for selecting an include path node.
updating these operations by adding the selection of full ast nodes can help to identify such complex patterns.
also these patterns can change in the future e.g.
the pattern illustrated in the frequent behavior an example of a project specific pattern where due to the different logging module in the main and fork the main one gets removed.
if there is a change in the logging functionality and developers prefer to remove the fork version of the logging then a new programs need to be generated with new examples.
external validity the current results are based on microsoft edge .
though microsoft edge is a widely used system drawing general conclusions from empirical studies in software engineering is difficult because any process depends to a large degree on a potentially large number of relevant context variables .
for this reason we cannot assume a priori that the results of a study generalize beyond the specific environment in which it was conducted .
researchers become more confident in a theory when similar findings emerge in different contexts .
towards this end we intend that our case study will help contribute towards building a body of knowledge in the area of using program synthesis for merge conflict resolution by replicating across different context variables and environments.
viii.
c onclusion and future impact in this paper we investigate the problem of merge conflicts on a large system.
empirically our findings identify the type of files size of conflicts location of conflicts in a file and resolution patterns.
in our case study we found that a majority of conflicts in microsoft edge occur in c files and overall of the merge conflicts are line changes.
we empirically characterize the different types of operations that developers perform while resolving merge conflicts.
we also identified that a non trivial section of these liner conflicts is due to the include andmacro related structural changes.
we propose an expressive domain specific language to identify the structural merge conflicts in microsoft edge .
the use of program synthesis provides the flexibility to learning complex patterns from a few examples examples .
our study highlights that learning project specific patterns is beneficial and we are able to address .
of merge conflicts in c files with .
accuracy.
applying program synthesis for assisting with merge conflict resolution can be beneficial for two reasons flexibility to accommodate new patterns adding explainability to the resulting suggestions.
in the future we plan to extend this study by applying our approach to other large scale projects.
we also plan to explore combining program synthesis with machine learning trained on a large dataset to understand if we can deploy within projects without sufficient history that is learn from one project and apply to another project cross project learning.
795references g. ghiotto l. murta m. barros and a. van der hoek on the nature of merge conflicts a study of open source java projects hosted by github ieee transactions on software engineering vol.
no.
pp.
.
r. p. buse and w. r. weimer automatically documenting program changes in proceedings of the ieee acm international conference on automated software engineering pp.
.
s. rastkar and g. c. murphy why did this code change?
in 35th international conference on software engineering icse .
ieee pp.
.
l. f. cort es coy m. linares v asquez j. aponte and d. poshyvanyk on automatically generating commit messages via summarization of source code changes in ieee 14th international working conference on source code analysis and manipulation .
ieee pp.
.
b. fluri m. wuersch m. pinzger and h. gall change distilling tree differencing for fine grained source code change extraction ieee transactions on software engineering vol.
no.
pp.
.
s. jiang a. armaly and c. mcmillan automatically generating commit messages from diffs using neural machine translation in 32nd ieee acm international conference on automated software engineering ase .
ieee pp.
.
m. owhadi kareshk s. nadi and j. rubin predicting merge conflicts in collaborative software development in acm ieee international symposium on empirical software engineering and measurement esem .
ieee pp.
.
s. apel j. liebig b. brandl c. lengauer and c. k astner semistructured merge rethinking merge in revision control systems pp.
.
o. le enich s. apel and c. lengauer balancing precision and performance in structured merge automated software engineering vol.
no.
pp.
.
j. matsumoto y .
higo and s. kusumoto beyond gumtree a hybrid approach to generate edit scripts in ieee acm 16th international conference on mining software repositories msr .
ieee pp.
.
s. raghavan r. rohana d. leon a. podgurski and v .
augustine dex a semantic graph differencing tool for studying changes in large code bases in 20th ieee international conference on software maintenance .
proceedings.
ieee pp.
.
d. reuling u. kelter j. b urdek and m. lochau automated n way program merging for facilitating family based analyses of variant rich software acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
m. sousa i. dillig and s. k. lahiri verified three way program merge proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
o. polozov and s. gulwani flashmeta a framework for inductive program synthesis in proceedings of the acm sigplan international conference on object oriented programming systems languages and applications pp.
.
a. miltner s. gulwani v .
le a. leung a. radhakrishna g. soares a. tiwari and a. udupa on the fly synthesis of edit suggestions proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
github github fork projects in c .
j. r. falleri f. morandat x. blanc m. martinez and m. monperrus fine grained and accurate source code differencing in proceedings of the 29th acm ieee international conference on automated software engineering pp.
.
m. prose microsoft program synthesis using examples sdk .
s. gulwani automating string processing in spreadsheets using inputoutput examples in proceedings of the 38th annual acm sigplansigact symposium on principles of programming languages pp.
.
v .
le and s. gulwani flashextract a framework for data extraction by examples in proceedings of the 35th acm sigplan conference on programming language design and implementation ser.
pldi .
new york ny usa association for computing machinery p. .
.
available r. rolim g. soares l. d antoni o. polozov s. gulwani r. gheyi r. suzuki and b. hartmann learning syntactic program transformations from examples in ieee acm 39th international conference on software engineering icse .
ieee pp.
.
s. horwitz j. prins and t. reps integrating noninterfering versions of programs acm trans.
program.
lang.
syst.
vol.
no.
pp.
.
c. sung s. k. lahiri m. kaufman p. choudhury and c. wang towards understanding and fixing upstream merge induced conflicts in divergent forks an industrial case study icse software engineering in practice icse seip .
j. bader a. scott m. pradel and s. chandra getafix learning to fix bugs automatically proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
v .
le and s. gulwani flashextract a framework for data extraction by examples in proceedings of the 35th acm sigplan conference on programming language design and implementation pp.
.
n. meng m. kim and k. s. mckinley systematic editing generating program transformations from an example acm sigplan notices vol.
no.
pp.
.
j. andersen and j. l. lawall generic patch inference automated software engineering vol.
no.
pp.
.
j. andersen a. c. nguyen d. lo j. l. lawall and s. c. khoo semantic patch inference in proceedings of the 27th ieee acm international conference on automated software engineering .
ieee pp.
.
n. meng m. kim and k. s. mckinley lase locating and applying systematic edits by learning from examples in proceedings of the international conference on software engineering ser.
icse .
ieee press p. .
v .
basili f. shull and f. lanubile building knowledge through families of experiments in ieee transactions on software engineering pp.
.