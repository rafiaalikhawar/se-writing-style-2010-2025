seamless variability management with the virtual platform wardah mahmood daniel str bery thorsten berger z ralf l mmelx and mukelabai mukelabai chalmers university of gothenburg sweden yradboud university netherlands zruhr university bochum germany xuniversity of koblenz landau germany abstract customization is a general trend in software engineering demanding systems that support variable stakeholder requirements.
two opposing strategies are commonly used to create variants software clone own and software configuration with an integrated platform.
organizations often start with the former which is cheap agile and supports quick innovation but does not scale.
the latter scales by establishing an integrated platform that shares software assets between variants but requires high up front investments or risky migration processes.
so could we have a method that allows an easy transition or even combine the benefits of both strategies?
we propose a method and tool that supports a truly incremental development of variantrich systems exploiting a spectrum between both opposing strategies.
we design formalize and prototype the variabilitymanagement framework virtual platform .
it bridges clone own and platform oriented development.
relying on programminglanguage independent conceptual structures representing software assets it offers operators for engineering and evolving a system comprising traditional asset oriented operators and novel feature oriented operators for incrementally adopting concepts of an integrated platform.
the operators record meta data that is exploited by other operators to support the transition.
among others they eliminate expensive feature location effort or the need to trace clones.
our evaluation simulates the evolution of a real world clone based system measuring its costs and benefits.
index terms software product lines variability management clone management re engineering framework i. i ntroduction software systems often need to exist in many different variants.
organizations create variants to adapt systems to varying stakeholder requirements for instance to address a variety of market segments runtime environments or different hardware.
creating variants allows organizations to experiment with new ideas and to test them on the market which easily leads to a portfolio of system variants that needs to be maintained.
two opposing strategies exist for engineering variants.
a convenient and frequent strategy is clone own where developers create one system and then clone and adapt it to the new requirements.
this strategy is wellsupported by current version control systems and tools such as git relying on their forking branching merging and pull request facilities.
the frequent adoption of clone own is usually attributed to its inexpensiveness flexibility and provided developer independence.
however clone own does not scale with the number of variants and then imposes substantial maintenance overheads.
a scalable strategy is tointegrate the cloned variants into a configurable and integrated platform by adopting platform oriented engineering methods such as software product line engineering sple .
individual variants are then derived by configuring the platform.
this strategy is typically advocated for systems with many variants such as software product lines e.g.
automotive avionics control systems and industrial automation systems or highly configurable systems e.g.
the linux kernel .
this strategy scales but is often difficult to adopt and requires substantial up front investments since variability concepts e.g.
a feature model feature to asset traceability a configuration tool need to be introduced and assets made reusable or configurable.
in practice organizations often start with clone own and later face the need to migrate to a platform in a risky and costly process recovering meta data that was never recorded during clone own such as features and their locations in software assets .
over the last decades researchers focused on heuristic techniques to recover information from legacy codebases including feature identification feature location variability mining and clone detection techniques .
unfortunately such techniques are usually not accurate enough to be applicable in practice and also require substantial effort to set them up and provide with manual input e.g.
specific program entry points for feature location techniques .as we will show existing platform migration techniques either heavily rely on such heuristics or have only been formulated as abstract frameworks so far.
moreover they tend to prescribe non iterative waterfall like migrations making it risky and expensive.
we take a different route and present a method to continuously record the relevant meta data already during clone own and to incrementally transition towards a more scalable platform oriented strategy exploiting the meta data recorded.
we design formalize and prototype a lightweight method called virtual platform generalizing clone management and product line migration frameworks.
we exploit a spectrum between the two extremes of ad hoc clone own and fully integrated platform supporting both kinds of development.
as such the virtual platform bridges clone own and platform oriented development sple .
based on the number of variants organizations can decide to use only a subset of all the variability implementation concepts that are typically ieee acm 43rd international conference on software engineering icse .
ieee required for an integrated platform.
this allows organizations to be flexible and innovative by starting with clone own and then incrementally adopting the variability implementation concepts necessary to scale the development as indicated by industrial practices for product line adoption .this realizes an incremental adoption of platforms with incremental benefits for incremental investment.
furthermore it also allows to use clone own even when a platform is already established to support a more agile development with cloning and quickly prototyping new variants.
the framework is lightweight since it avoids upfront investments and can be easily integrated with version control systems or ides where its operators can be mapped to existing activities avoiding extra effort.
this way our new feature oriented operators are cheap to invoke during development when the feature knowledge is still fresh in the developer s mind allowing to record meta data in a lightweight way.
the term virtual platform was introduced earlier in a short paper discussing an incremental migration of clone based variants into a platform.
it introduced governance levels reflecting a spectrum between the two extremes ad hoc clone own and fully integrated platform.
higher levels involve a super set of the variability concepts of lower levels.
advancing a level e.g.
when the number of variants increases supports an incremental adoption of variability concepts avoiding the costly and risky big bang migration often leading to re engineering efforts over years .
this early high level description of a strategy to incrementally scale the management of variants paved the way for this paper.
one of our core contributions are conceptual structures and formalized operators for the virtual platform which are related to ordinary code editing but also record and exploit meta data.
while we prototypically implemented the virtual platform on top of an ordinary file system our work gives rise to realize it upon a database to enhance scalability within an integrated development environment ide or as a command line tool.
the meta data could also easily be saved directly in the software assets using lightweight embedded annotations as our prototype does .
we evaluated our prototype on a reasonably sized system .4k lines of text variants where we simulated evolution activities that are typical of practical software systems.
our prototype was able to fully simulate and manage all considered activities.
from a cost benefit analysis we conclude that the virtual platform offers significant cost savings during inevitable evolution and maintenance activities.
in summary we contribute a mechanization of the so far abstract idea of operators mediating between clone own and an integrated platform defined upon conceptual language independent structures a prototype of the virtual platform in scala a comparative evaluation of the virtual platform against five related frameworks based on their ability to support common evolution scenarios a cost and benefit evaluation of the virtual platform based on a simulation study featuring the revision history of a real variant rich open source system and an online appendix with a technical report about our operators additional examples and evaluation data.
ii.
m otivation and overview we provide a core scenario of seamless variability management as a running example and an overview of the virtual platform.
while rooted in a deliberately simple application domain the example is inspired by documented real product line migration scenarios .
it includes tasks that are tedious and errorprone in practice e.g.
bugfix propagation along branches .
a. motivating running example we now discuss relevant problems of managing variants inspired by actual industrial practices also presenting our solution in the virtual platform and how a developer would use the virtual platform.
specifically developers interact with the virtual platform by invoking its provided operators either via the command line or an integration with an ide or version control system provided by a tool vendor see sec.
ii b for details .
while the traditional asset oriented operators can run transparently in the background only the feature oriented operators require an extra user interaction for invoking the operators.
the operator are described in detail in sec.
v. consider the scenario of an organization developing and evolving variants of a calculator tool.
our organization starts creating a project of a simple calculator called basiccalculator bc that supports basic arithmetics addition subtraction multiplication and division .
soon based on customer requests the organization needs to create variants of bc which have substantial commonalities but also differ in functional aspects.
figure 1illustrates the two opposing strategies cf.
sec.
i for realizing the variants.
specifically it shows two alternate realizations of a variant of basiccalculator with a small display requiring the rounding of results feature smalldisplay .
to the left the code is cloned and adapted one line changed in the branch bc smalldisplay to the right a configuration option represents the change in a common codebase integrated platform .
the changes are usually more complex e.g.
features can be highly scattered as well as the representation of variability in the integrated platform.
we also need more variability concepts among others features codelevel configuration feature to asset traceability a feature model a hierarchical structure with features and their dependencies a configurable build system and a configurator tool .
this example shows that when it becomes necessary to migrate from clone own to an integrated platform important information needs to be recovered specifically that a feature smalldisplay was implemented and where its code is located.
recovering such information in systems with many features and sizable codebases is laborious time consuming and inaccurate at best.
also migration can be invasive risky and costly especially hard to achieve under market pressure .
the virtual platform exploits a spectrum between the two extremes and supports an incremental transition as shown in 1659function divide a b var result result a b return result.tofixed function divide a b var result result a b return result function divide a b var result result a b ifdef smalldisplay return result.tofixed else return result endif main branch bc smalldisplay branchbasic advanced ad hoc clone own fully integrated platformmain branch feature model smalldisplayfig.
.
ad hoc clone own vs. fully integrated platform illustrated for two variants the basiccalculator and a variant with only a small display fig.
.
it adapts the governance levels from prior work which also explains the benefits of each transition step in detail.
let us further discuss the evolution of our calculator using ad hoc clone own .
after the basiccalculator and a variant of it for small displays bc smalldisplay is created customers request a scientificcalculator which should solve complex inputs such as expressions factorials and logarithms .
our organization decides to copy and adapt the codebase from basiccalculator since there is no need for a scientificcalculator with small display support otherwise we would already have four cloned variants.
as such cloning provides a baseline minimizing the duplication of efforts.
soon after the organization needs to create another variant called graphingcalculator for which it selects the most similar variant scientificcalculator and clones and adapts it.
it also notices that some functionality in basiccalculator had in the meantime received a bug fix which the organization also applies to graphingcalculator now realizing that also scientificcalculator needs to receive the bug fix.
problem where are my clones?
with many more variants developed using ad hoc clone own developers lose overview.
if a change e.g.
a bug fix is to be replicated developers need to recover which project was cloned from which in the worst case requiring a clone detection technique.
also the added effort in synchronizing cloned implementations is likely to surpass the initial benefit of reuse via cloning.
solution clone own with provenance fig.
1st level .
our solution is to record traceability information about the cloned variants provenance which eases tracking and synchronizing clones.
it also bypasses the inaccuracies associated with clone detection making tasks such as change propagation more effective.
the virtual platform records clone traces among assets in the background without requiring extra effort from the developer but who can query it for obtaining the clones of an asset.
to this end the developer invokes the cloneasset operator provided by the virtual platform.
as a result a trace between the original asset and its clone is stored in a trace database which can be queried at any time by the developer to retrieve clones of an asset quickly and accurately.
the developer can later propagate changes between the original asset and its clone propagatetoasset or integrate changes between the assets either manually or using a tool by exploiting the continuously recorded meta data.
problem what is in my cloned variants?
with more variants despite provenance information the problem arises that developers lose overview.
to understand what is in thevariants we need a more abstract representation of assets.
for cloning this is also necessary to select an existing variant closest to the desired one in terms of the desired features.
furthermore our organization finds the feature exponent developed in scientificcalculator to be useful for other cloned variants.
to clone it the developer needs to know which implementation assets belong to the feature.
solution clone own with features fig.
2nd level .
adding feature meta data adds perspective and allows functional decomposition.
it also allows representing assets in terms of features to reuse and clone features across projects.
lastly including feature related information allows going past the efforts and inaccuracies of feature location recovering where a feature is implemented making feature reuse and maintenance more effective.
the virtual platform offers operators to add features conveniently at the same time annotating assets .
the developer maps assets to features by using the operator mapassettofeature .
she can later query the virtual platform to find the location of the features using the operator getmappedassets and also to clone assets along with feature mappings cloneasset .
problem how to reduce redundancy?
despite features which help maintaining variants substantial redundancy exists.
solution clone own with configuration fig.
3rd level .
to reduce it our organization starts to incorporate configuration mechanisms.
these allow to enable or disable features such assmalldisplay which control variation points.
this reduces redundancy and maximizes reuse.
so the organization maintains a list of features and uses a configurator tool.
the virtual platform supports this solution with a simple operator.
over time the developer adds features by invoking the operator addfeature .
she can map the assets to features using mapassettofeature and clone features using clonefeature .
she can also make features optional by invoking makefeatureoptional .
variants can be configured by cloning the repository cloneasset with assets mapped to only the selected features getmappedassets .
problem how to keep an overview over the features?
the more features and variation points the organization incorporates the more it loses overview over the features and their relationships including feature dependencies accidentally ignoring those can lead to invalid variants .
maintaining such information would also help scoping variants.
solution clone own with a feature model fig.
4th level .
our organization introduces a feature model which captures features and their constraints also as input to the configurator.
feature models are very intuitive and simple models which provide deep insights without much additional tool support.
they also foster communication among stakeholders and validate feature configurations.
with this solution consistency between features and clones is high since developers can also exploit the clone traces and use the virtual platform for feature based change propagation.
the developer adds a feature model to the repository with the operator addfeaturemodeltoasset .
she can change the feature model to add and remove features at any 1660bc sc gctraceability features configuration feature model integrated platform fc clone own with provenanceclone own with features bc c l o n e o w nw i t hc o n f i guration optional features clone own with a feature modelsc bc scbc sc integrated platform with clone own fig.
.
spectrum between the extremes ad hoc clone own and a fully integrated platform see fig.
1for both illustrated with cloned variants basiccalculator bc scientificcalculator sc graphingcalculator gc and financialcalculator fc .
the virtual platform provides operators to transition along this spectrum e.g.
to incrementally adopt a platform .
time.
she can map assets to features from the feature model mapassettofeature clone features across projects clonefeature and propagate changes in features to their clones propagatetofeature .
problem how to keep consistency improve quality and further reduce redundancy?
our organization needs to further scale the development with an ever increasing number of variants due to rapidly changing market needs while it has problems maintaining consistency and propagating changes despite some redundancy already being reduced with solution .
it is also likely that eventually there will be some projects with a configuration mechanism and some without.
solution integrated platform with clone own fig.
5th level .
our organization integrates the projects into a consolidated platform.
luckily it can exploit meta data about clone traceability provenance and features with their locations in assets.
the virtual platform provides support for this kind of information easing the integration of cloned variants into a platform.
of course developers might have forgotten to record all that information then it is natural to recover it.
as long as some information is recorded a benefit arises in terms of saved feature identification feature location and clone detection effort.
b. virtual platform overview our goal is to combine the benefits of the two opposing strategies clone own and integrated platform exploiting a spectrum between both and allowing incremental transition as in our running example sec.
ii a .
to this end we designed a framework called virtual platform comprising conceptual structures upon which operators modifying the structures are executed by developers.
the conceptual structures abstractly represent software assets at various levels of granularity from whole repositories to blocks of code and can be adapted to specific asset languages explained shortly in sec.
iv .
in addition they maintain information about variability specifically feature information feature to asset mappings and clone traces.
the virtual platform extends other development tools specifically ides and version control systems.
on top of these which are concerned with the management of assets the virtual platform provides dedicated functionality for managing features .
operators can be either traditional meaning they are concerned with asset management or feature oriented meaningthey are devoted to features and their locations in assets.
in contrast to traditional development workflows the use of dedicated feature oriented operators incurs a certain cost but promises benefits to developers.
in sec.
vi we study this trade off.
figure 3illustrates interactions and internal workings of the virtual platform.
developers can interact with it directly or indirectly.
the former is enabled via extensions and hooks of existing tools.
specifically traditional ide commands such as create file and version control commands such as add file are linked to the traditional asset oriented operators of the virtual platform e.g.
create asset and do not impose additional effort for developers.
feature oriented operators can be implemented by new feature oriented ide commands e.g.
create feature .
direct interaction is enabled via a command line interface where developers can call feature oriented operations such as create feature directly.
iii.
m ethodology we followed a design science like strategy to iteratively define the conceptual structures the operators and to evaluate them using unit tests representing common scenarios.
specifically for the structures and operators we aimed at maximizing the support for different scenarios from the literature and our own professional experience.
the main challenge was to define adequate structures that while programming languageindependent can be mapped to many of the different asset types of real world software projects as well as to design the operators to be able to operate on the structures.
initial design.
we started by analyzing clone management and platform migration frameworks proposed in the literature from which we extracted development activities that should be supported by the virtual platform.
we also had a series of virtual platformidedeveloper asset treetraditional operatorsfeature oriented commands feature oriented operatorsversion controlsystem usesuse modifymodifyoperators traditional commandsfilesystemworking copy are synchronized usearesynchronizeduses usesoperate on fig.
.
overview dashed boxes represent optional parts 1661discussions among the authors one from industry and four from academia.
two authors have over ten years of research experience in variability management and sple.
we also created ad hoc examples in the discussion meetings.
from these sources we identified an initial set of data structures and operators and implemented them in scala.
specifically from the literature we identified five relevant works on clone management and product line migration using our expert knowledge.
rubin et al.
s product line migration framework offers operators that support the narrative that a mechanization i.e.
an operator based perspective leads to more efficient implementation and support.
fischer et al.
s framework and tool ecco relies on heuristics to identify commonalities and allows composing new product variants using reusable assets.
martinez et al.
s tool but4reuse is an extraction based technique for product line migration including support for feature model synthesis.
pfofe et al.
s tool variantsync supports clone management by easing the synchronization of assets among cloned variants.
montalvillo et al.
s operators and branching models for clone management in version control systems allow isolated variant development with change propagation but without using the notion of features as opposed to the other frameworks.
for brevity we will present the identified activities only at the end in sec.
vi a .
detailed descriptions are in our online appendix .
continuous evaluation.
once every operator was implemented we tested it with unit tests based on scenarios from the literature and our own experiences.
we ensured that the operators assured the well formedness of the conceptual structures by prohibiting illegal actions e.g.
limiting asset addition to scopes that can host an asset of the given type.
final qualitative and quantitative evaluation.
we evaluated the virtual platform qualitatively by comparing it against the existing frameworks discussed above from which we had extracted activities supported by techniques for supporting clone own or the migration of cloned variants to an integrated platform.
we evaluated the virtual platform quantitatively in a cost benefit calculation based on simulating the development of a real open source system developed using clone own.
iv.
c onceptual structures the virtual platform s conceptual structures form the basis for its operators which we formulated as functions with side effects in place transformations that modify the structures.
figure illustrates the main structures and their relationships.
we define them abstractly but also provide a concrete implementation for handling assets within a file system and special support for textual files that follow a hierarchical structure e.g.
with nested classes methods or code blocks cf.
sec.
vi .
asset tree at is our main conceptual structure and abstractly represents a hierarchy of assets such as the folder hierarchy but also the hierarchy within source files.
in fig.
the at is represented implicitly in the form of assets with their sub asset relationships.
the idea of atis inspired by feature structure trees fsts which represent source files.
in our case we define theatas a hierarchical non cyclic tree structure of nodes.
it asset name string type assettypeversion intfeature name stringoptional booleanincomplete boolean details startingline intendingline int enum assettype vproottyperepositorytypefoldertypefiletypeclasstypemethodtypeblocktype assettrace versionat intfeaturemodel version int featuretrace versionat intparent sub assetis mapped to parent sub feature depends on .. sourceclone11 .. .. .. source clone1 .. .. unassignedrootfeaturefig.
.
conceptual structures asset tree features mappings and clone traces has a synthetic root node root and then represents a hierarchy that can start with repositories as the top level nodes followed by folders and files and can then go into the nesting structure of elements of hierarchical files.
every node represents an asset related to the project such as a folder a file e.g.
image source file model or requirements document or text.
every asset has aname a type assettype and a version a simple means to identify changes .
an asset can have any number of sub assets .
it also owns a parent pointer p which should define a tree with a virtual root node asset of type vproottype denoted as root.
theassettype is used to capture the role of the asset in the project and can be one of the following vproottype repositorytype foldertype filetype classtype methodtype and blocktype .
the type vproottype is only used once in the at to specify the synthetic root node.
the main purpose of this root node is to carry a global version we explain versioning shortly .
traditional sple architectures have a feature model per project which can be difficult to maintain and evolve in large systems e.g.
linux kernel .
we provide a more flexible structure by including an optional feature model as part of every asset see composition of feature model inasset in fig.
.
well formedness criteria we define a partial order of valid containment over the types of assets in a check function containable asset asset!bthat validates the containment based on the asset types.
for instance vproottype can only be at the root and a methodtype can be contained in a filetype but not the other way around.
operators are implemented with consideration of well formedness criteria to ensure that the tree structure of atis retained.
features and feature models afeature has a name and twoboolean parameters optional andincomplete .
the field optional specifies whether the feature is mandatory or optional incomplete captures information about the completeness of thefeature s implementation.
if the feature was cloned from another feature model scope it is true if the new scope containing the feature also contains all the assets to which thefeature is mapped otherwise it is always false .
every feature has an optional parent and any number of sub features .
features can have dependencies to each other.
a feature model has a root feature and a mandatory feature called unassigned which contains all features that are added to the model as a result of asset cloning.
that is if any feature mapped to theasset is not present in the target feature model already it is mounted under unassigned and requires developer intervention to move it to the desired location in the model .
asset to feature mappings in practice can have two seman1662tics.
they can be simple mapping relationships indicating that asset realizes a feature .
they can also indicate variability where the asset is included in a concrete variant if the feature is selected interestingly if an asset is optional based on a feature then the asset also realizes it but not necessarily all assets realizing a feature are optional .
the sple community usually focused on the variability relationship and the feature location community on traceability.
for the virtual platform we unified the mechanism with which assets are mapped to features.
specifically an asset has a presence condition pc a propositional formula over features.
a pc allows conveniently mapping assets of different granularity levels assettype to entire feature expressions.
whether this relationship to the feature represents variability or traceability is solely determined by the feature s optional parameter.
versioning of assets.
assets and features have a version an integer used to recognize changes in the at andfm especially among cloned assets.
the version of the vproottype node has a special role which we call globalversion and which carries the most up to date version to recognize any change in the whole at.
for simplicity we assume that any asset outside the tree has a version of .
after addition it takes the version of the global root initialized with and incremented after any update in the at .
versions are incremented after every modification and addition or removal ofsub assets .
this simple versioning strategy is a sweet spot between two other alternatives first after every change in an asset increment the version of the asset and continue updating the ancestors up to the root.
this would make the tracking of the changes easy but change propagation expensive and redundant.
second keep two separate numbers one global version and one local version for every asset.
this solution would ease change propagation but yield a hard to understand versioning model.
clone traceability.
to maintain trace links between source assets and their clones we define an assettracedatabase essentially a list of assettraces .
an assettrace is a triplet of the source asset its clone and a version at which the source asset was cloned.
similarly feature traces are used to keep track of the feature clones and they are stored in a featuretracedatabase .
afeaturetrace is also a triplet pointing to the source feature its clone and version at the time of cloning.
these traces are a core component of our contribution and have special relevance in cloning and change propagation for both assets and features.
for brevity we refer to both assettracedatabase and featuretracedatabase as tracedatabase in the remainder of the paper.
v. v irtual platform operators we now present the traditional asset oriented and the featureoriented operators.
their underlying algorithms and further illustrations supplementary to the illustrations used here are provided in our online appendix .
the appendix also presents a number of additional convenience operators utility methods that efficiently traverse the trees at andfeature model to return data that needs to be frequently accessed such as assets mapped to a feature and clones of an asset etc .a.
traditional asset oriented operators we represent conventional activities performed by developers using asset oriented operators.
these operators allow to keep the atin sync with the working directory.
also the assets act as mappable components to the features and allow cloning and change propagation.
in what follows we introduce the asset oriented operators with their parameter types a brief description and sample scenarios inspired from our calculator running example cf.
sec.
ii a .
the notation used for visualizing various scenarios is shown in fig.
.
addasset asset asset!b description when a source asset s is added in any target asset t to a repository e.g.
a file to a folder addasset creates an asset forsand adds it to the preexisting asset t in the at.
additionally it increments the globalversion and assigns it to sandt.
this implies that the most recently changed assets are sandt.
also it adds any feature mapped tosin t s feature model typically repository feature model .
example consider the basiccalculator bc example.
the developer adds the implementation for the divide method in the file operators.js with an annotation for the feature div.
consequently the virtual platform creates and adds the asset divide s of methodtype to the asset operators.js t offiletype and div to the feature model oft.
the globalversion previously is incremented and assigned to divide andoperators.js .
figure 6illustrates the scenario.
changeasset asset!b description upon a change in an asset sin the repository changeasset increments the globalversion of the atand assigns it to s. versionable changes include renaming addition mapping to a feature and modification or removal of lines.
removeasset asset!b description if an asset is deleted from a parent asset t removeasset removes its corresponding asset sin the at along with all its sub assets.
it increments the globalversion and assigns it to t. additionally any feature mapped to s is also removed from the feature model ofsifstheonly asset mapped to it.
this enforces that if all assets mapped to afeature are deleted the feature is also deleted.
moveasset asset asset!b description if an asset is moved from one location to another moveasset clones the corresponding asset sto the new target asset t using cloneasset and removes it from the sub assets of its previous parent using removeasset .
thus far the operators we presented serve two purposes keeping the atsynchronized with the project and keeping name type version asset asset to feature mapping name type versionwith globalversion featuretrace link name type version added asset name type version modified asset name type version cloned assetname name namename name added modified clonedwith globalversion fig.
.
notations used in operator illustrations 1663feature modelroot root bc repository operators.js file divide method 4at after bc divfig.
.
illustration of addasset divide operators.js track of changes through versioning.
following the operators serve two additional purposes storing feature oriented data and recording traceability among clones.
the exploitation of these meta data are the essence of our framework.
mapassettofeature asset feature!b description upon addition of a feature mapping by a developer mapassettofeature checks if the feature exists in the feature model of the asset .
if not it creates a feature f with the name used by the developer maps it to s corresponding asset in the at and adds fto the unassigned feature in the feature model ofs.
iffalready exists it simply maps fto s. for mapping it adds fto the presencecondition ofswith a logical disjunction.
to track this change the globalversion is incremented and assigned to s. example assume that the developer adds a method multiply tobc with a feature annotation for the feature mult .
mapassettofeature creates this mapping in the at.
the presencecondition of the method becomes multjtrue .
cloneasset asset asset!b description cloneasset imitates the actual clone own strategy when an asset is cloned to another location by a developer cloneasset creates a deep clone of the source asset and adds it to the target asset in the at provided it iscontainable .
additionally if the cloned asset or its subassets is mapped to any features they are also cloned added to the target feature model and mapped to the asset clone.
the clone retains the version of the original asset however since the target asset is modified addition of sub asset the globalversion is incremented and assigned to the target.
for storing trace links it creates traces for both asset andfeature clones and adds them to the tracedatabase .
example starting from fig.
the developer copies the method divide inarithmetic.js a file in another project scientificcalculator sc .cloneasset clones divide toarithmetic.js an asset offiletype insc as well as the mapped feature div in thefeature model ofsc.
traces for both divide anddiv are added to the tracedatabase .
figure 7illustrates the scenario.
propagatetoasset asset asset!b feature modelroot root bc repository operators.js file divide method 4at after sc repository arithmetic.js file divide method 4feature model seq source clone versionat t1 divide divide t2 div div 1trace databaset1bc divsc div t2 fig.
.
illustration of cloneasset divide arithmetic.js root root bc repository operators.js file divide method 8at after sc repository arithmetic.js file divide method seq source clone versionat t3 divide divide 8trace databaset3fig.
.
illustration of propagatetoasset divide divide description propagatetoasset takes two assets checks if one is a clone of the other and propagates changes in source after cloning to its clone.
to determine if source was changed it compares the version of source to its version when it was cloned versionat from the tracedatabase .
if it is ahead of the version it was cloned at the changes are propagated to the clone.
changes performed in the clone are retained.
propagation like cloning includes added and modified subassets added mappings and renaming.
after propagation a trace with source and clone is added to the tracedatabase theversionat of which is the version of the source.
the globalversion is incremented and assigned to the clone.
example assume that the divide method during cloning did not include the check for division by zero.
after adding the check changeasset the divide method in source operators.js is ahead version of the divide method in target arithmetic.js with version .
by invoking propagatetoasset the changes are propagated automatically.
figure 8demonstrates the scenario for simplicity feature mappings are omitted.
b. feature oriented operators the feature oriented operators incorporate feature related information to the atand enable feature reuse and maintenance.
addfeature feature feature!b description when a developer adds a feature e.g.
in a text file or a database or an asset mapping to a feature which does not exist in the feature model addfeature creates a new feature and adds it to the feature model .
it also adds any assets mapped to the feature using addasset .
similar to versioning ofaddasset inat addfeature increments the globalversion version ofrootfeature and assigns it to the added feature .
example assume that the feature model forbcis a textual file where features are written as individual lines and indentation is used to represent hierarchy clafer syntax .
the developer adds a line exp exponent below the line bc root feature bc .addfeature creates a corresponding feature exp and adds it to the feature bc.
the version ofrootfeature is incremented previously after adding feature div and assigned to feature exp.
figure 9demonstrates the scenario with the resulting versions in a table on the right.
addfeaturemodeltoasset asset feature model!b description developers can add a feature model to an asset in different ways e.g.
as a file or a database.
the virtual platform upon recognizing that a feature model is added to an asset in the repository invokes addfeaturemodeltoasset .
the operator then locates the asset in the at creates afeature model fm and sets the asset s parameter feature 1664feature model bc divbc div expfeaturemodel.txt expfeature version bc div exp 2fig.
.
illustration of addfeature exp bc model tofm.
the globalversion of the atis incremented and assigned to the asset which contains fm.
example consider that the feature model ofbcis a separate text file which resides in the root folder of bc.
as a result ofaddfeaturemodeltoasset the feature model fm will be loaded from the file and assigned to bc.
all sub assets ofbccan now be mapped to features from fm.
removefeature feature!b description when a feature is removed by a developer from a repository removefeature locates the feature in the feature model un maps it from all assets it maps to and removes the feature along with all its sub features.
additionally any asset mapped to only the removed feature is also removed by the operator.
the operator increments the globalversion of the fm and assigns it to the parent feature before removal .
movefeature feature feature!b description features can be moved in the same project as a result of refactoring and also across projects when developers incorporate it into another project.
movefeature combines two operators clonefeature explained below to clone thefeature and its mapped assets to its new location and removefeature to remove it from its previous location.
makefeatureoptional feature!b description often developers want to keep a feature s implementation in the at and decide whether to include it or not at compile time instead of deleting it altogether.
makefeatureoptional sets a feature sboolean propertyoptional totrue .
by default every feature is mandatory when added to the feature model .
this operator allows to keep the feature s implementation in the atwhile allowing developers to activate or deactivate the feature.
clonefeature feature feature!b description cloning a feature manually requires developers to recollect its location in software assets.
these assets can be of different types directory document code artifact text etc .
features can be scattered and therefore harder to locate.
this is where the stored and maintained meta data pays off.clonefeature simply invokes a convenience operator getmappedassets to retrieve all assets mapped to the feature.
it then clones the feature and all its mapped assets in the target at andfm.
the operator also stores traces for the asset andfeature clones in the tracedatabase .
the globalversion of the fm is incremented and assigned to the target feature parent of the feature clone .
example after adding the feature exp using addfeature the developer added two assets in feature bc and later mapped them to feature exp.
the assets are a method exponent and a textual file exp.txt with documentation ofexponent .
the developer now wants to reuse feature exp feature model bc exproot root bc repository operators.js file exponent method 4at after exp.txt file 4sc repository operators.js file exponent method 4exp.txt file operators.js file exp.txt file 5feature model sc exp t2 t3t4 t1 versionat fig.
.
illustration of clonefeature exp sc insc.
to clone the feature she invokes clonefeature which clones the feature exp and its mapped assets to sc.
additionally traces for the feature and asset clones are added to the tracedatabase .
this example is illustrated in figure .
note that even though operators.js was not cloned the virtual platform created a clone as the method exponent could not be added directly to the repository.
this is referred to as tree slicing which the virtual platform adopts to ensure that the well formedness of the atis maintained.
propagatetofeature feature feature!b description propagatetofeature replicates the changes in the feature e.g.
renaming adding or removing subfeatures to either selected or all of its clones.
for checking if propagation is valid and necessary it checks two conditions based on the tracedatabase .
first if one of the features provided is a clone of the other.
second if the feature was modified after cloning current version versionat .
after propagating changes it creates new traces between the source and newly modified targets both feature andasset and adds them to the tracedatabase .
vi.
p rototyping and evaluation we prototyped and evaluated the virtual platform qualitatively and quantitatively i in a comparative assessment against the frameworks presented in sec.
iii ii using a simulation study based on revision histories from clone own based system.
details of our implementation and evaluation are available in the online appendix .
the prototype implemented in scala provides an api as the main interface to execute the operators.
in the production ready tool this api would be usable as a command line interface or a set of ide commands.
we used a strategic programming library kiama for efficient tree traversal and rewriting.
after implementing all operators we created test scenarios to verify the correctness.
these test scenarios were developed using domain knowledge acquired by experience and also inspired by observing scenarios from the case study of clafer web tools.
we checked correctness by comparing the result state at trace and mappings after operator invocations to the expected one.
we also simulated the illustrative example presented in sec.
ii a by automatically realizing all the discussed scenarios.
a. comparative evaluation for comparison we extracted activities supported by techniques for supporting clone own a.k.a.
clone management or the migration of cloned variants to an integrated platform a.k.a.
product line migration .
in total we extracted activities which we found to be common across most if not all existing 1665table i comparison of the virtual platform with activities supported by clone management and product line migration frameworks feature identification !abstract operator specified in the beginning specified any time in virtual platform feature location!abstract operator extracted internal tagging also internal tagging in virtual platform feature dependency management !abstract operator statically mined specified in beginning specified any time in virtual platform feature model creation !multiple abstract operators activity specified in the beginning dynamically grows in virtual platform feature to asset mapping !abstract operator extracted specified any time specified any time in virtual platform clone detection!textual diff tools feature expression comparison git clone points to source not needed in virtual platform feature cloning!supported by virtual platform change propagation !multiple abstract operators variant synchronization using git merge automated in virtual platform reusable assets creation !abstract incremental reuse existing variants reusable core assets and features in virtual platform product derivation !abstract customizing after cherry picking composition preprocessor like in virtual platform integration!abstract operator using meta data third party tool git merge manual or tool based guided by meta data in the virtual platform variant synchronization !git dif code comparison not needed in virtual platform techniques.
we evaluated the virtual platform s ability to support the scenario from sec.
iiand the activities of related frameworks.
details are in the appendix .
table ishows whether and how an activity related to either clone management or product line migration is supported by an existing framework as well as virtual platform.
the activities are feature identification features defined in a variant feature location recovering traceability between features and assets feature dependency management managing constraints among features feature model creation creating and evolving a feature model storing feature to asset mappings clone detection identifying assets which are clones of one another feature cloning ability to clone features change propagation replicating changes made in an asset to its clone creation of reusable assets which can be used to derive variants product derivation ability to derive a partial or complete product given a configuration variant integration merging assets variants by taking variability into account and variant comparison comparison of assets to find commonalities and varaibilities .
in summary among all frameworks the virtual platform is the first one fully committed to recording traceability instead of recovering it later.
it automatically maintains traces between cloned assets and encourages developers to map features to assets of all types and all granularity levels not just code blocks .
this traceability has a cost to developers however at the same time it can significantly reduce cost when complex evolution activities are performed as detailed below.
the other frameworks define their involved activities either abstractly or using heuristics e.g.
feature location .
the virtual platform includes exact specifications and implementations of operators possible since we address a broad range of evolution scenarios rather than just the big bang scenario of platform migration.
the existing methods have not been applied to real project revision histories as part of their evaluation ratherexplain that they support migration scenarios described before.
b. simulation study we used an open source system called clafer web tools cwt that was evolved using clone own in three cloned variants clafermoovisualizer claferconfigurator claferide towards an integrated platform claferuicommonplatform including many feature clonings across the variants.
we evaluated the virtual platform s efficiency by simulating the evolution of cwt retrofitting our operators to achieve the original evolution and studying the costs and benefits.
we used a dataset by ji et al.
that augments the original codebase with feature information as if it had been developed in a feature oriented way.
it comprises a full revision history for the four sub systems with source code from the original developers and feature information manually added by researchers.
feature information is contained in three types of artifacts feature models feature to asset mapping files and embedded feature annotations in code.
we provide details about the dataset in our appendix .
performing the simulation.
we retrofitted cwt s full revision history to our operators to extract a sequence of high level operator applications that accurately capture the changes previously expressed by the history of low level file based commits.
we analyzed each pair of successive commits to extract a set of operator applications that produces the delta between the commits.
replaying the operator applications in the given order creates and updates the at.
cost benefit.
as costs we measure the additional effort imposed on developers by our platform.
our traditional assetoriented operators left hand column of table ii do not lead to additional cost because these tasks are performed in traditional development as well.
cost arises from two components both related to our feature oriented operators right hand column of table ii one called cfeatfor maintaining features one called cmiss for dealing with omissions during feature maintenance.
the latter arises if the developer forgets to invoke a feature oriented operator and then later the feature information is missing for a relevant feature oriented activity.
as benefits we consider the saved cost in two dimensions feature location and clone detection.
feature location cost clocis saved on invocations of certain operators that rely on previously specified mappings.
clone detection cost cclone is saved on invocations of one certain operator for propagating changes along clones from our clone database.
we study these costs and benefits in four dedicated research questions.
rq1 and rq2 are devoted to costs while rq3 and rq4 are devoted to benefits.
we first discuss these research questions before weighing off the observed costs and benefits.
rq1.
what are the costs of maintaining features using feature oriented operators?
the overall cost cfeat arises from accumulating the cost of applying feature oriented operators.
each feature oriented operator ophas a cost cfeat op invoc op cost abs op which depends on the number of invocations of op and the absolute cost of each invocation of op.
based on table ii there are invocations of 1666table ii operator invocations in simulation study asset oriented and feature oriented operators operator freq.
operator freq.
addasset addfeature changeasset addfeaturemodeltoasset removeasset mapassettofeature moveasset removefeature cloneasset movefeature propagatetoasset clonefeature propagatetofeature feature oriented operators in total.
two operators contribute the bulk to this number namely mapassettofeature andaddfeature .
the absolute cost per invocation can be assumed to be low in the order of seconds because it mostly amounts to picking the feature name when it is fresh in the developer s mind.
an exception are situations where the developer has to deal with earlier omissions see rq2 .
rq2.
what percentage of feature maintenance operations required additional feature location effort?
the omissionrelated cost cmiss arises from the number of late invocations ofmapassettofeature representing situations where the developer missed to specify an asset to feature mapping when the asset was added.
this number is to be multiplied by the absolute cost for these invocations which is generally higher than a regular invocation.
our operators clonefeature and propagatetofeature rely on a complete mapping from a feature to its assets.
a third relevant operator is addfeature which adds feature information to source code added earlier.
in absence of a recorded mapping each operator requires an expensive manual feature location step which is not required in our approach see rq3 .
we counted the number mappings that were added before or after one of these operators was invoked which indicates that the researcher preparing the original dataset noticed an omission.
we determined relevant mappings forclonefeature relevant invocations .
of all invocations and relevant mappings for addfeature relevant invocations .
of all invocations .
we did not discover any relevant mappings for propagatetofeature yielding late invocations in total.
rq3.
to what extent can feature location costs be avoided when using feature oriented operators?
the operators clonefeature and propagatefeature rely on previously specified mappings.
conversely to rq2 we can assume that each invocation of one of these operators avoided manual feature location when it did not require any fixing of omitted annotations.
so we define clocto rely on the number of feature location steps saved by an invocation of one of our operators.
we count invocations of clonefeature and relevant invocations of propagatetofeature leading to a final value of .
this number is to be multiplied with the absolute cost of feature location which can be assumed to be high earlier work gives an estimate of minutes per feature based a strong reliance on the developers memory and an understanding of how cross cutting features are scattered.
rq4.
to what extent can clone detection costs be avoidedwhen using feature oriented operators?
since the propagation of changes along clones requires a complete specification of the clones at hand we can assume that every application ofpropagatetofeature saves one application of clone detection either manual or using a tool .
in our subject system we identified invocations of propagatetofeature .
to obtain the value of cclone this number of is to be multiple with the absolute cost for clone detection.
manual clone detection is a tedious and error prone task and known to be infeasible for larger systems .
tool based clone detection requires manual verification and postprocessing since even the most advanced clone detection tools have imperfect precision and recall .
c. discussion break even point.
we can now weigh off the costs observed in rq1 against the benefits from rq3 .
consider the following formula which specifies the total benefit of using the virtual platform btotal cfeat cmiss cloc cclone .
if this formula yields a positive value the virtual platform surpasses the break even point and leads to a net benefit.
the value of btotal depends on the absolute costs for operator invocations feature location and clone detection which are unavailable.
however we can perform an approximation based on plausible estimates .
for the cost of feature location we rely on the earlier literature estimate of minutes per instance.
.
we assume clone detection to have the same cost as feature location.
.
we assume the cost for adding an omitted annotation to be times as high as a regular operator invocation.
based on these three assumptions we break even ifinvoking a feature oriented operator takes seconds or lesson average.
in practice the benefit can be assumed to be larger since invoking a feature oriented operator mostly entails picking a feature name while the feature is still fresh in the developer s mind a matter of a few seconds.
this calculation shows promising results in terms of saved effort and time.
by simulating the development of the case study with feature oriented information we can reuse as much as features from one project clafermoovisualizer by cloning them.
we envision greater accuracy and efficiency levels when the virtual platform is used alongside development.
representativeness.
our case is representative for systems of comparable size 547k lines four variants .
many reported product line migrations are of similar size .
we argue for representativeness for larger systems qualitatively.
our case has all evolution activities observable in industrial systems supported by other frameworks.
still the virtual platform is evaluated more extensively than any of these.
threats to validity.
a threat to external validity is that our operators do not completely capture the real world scenarios developers encounter when dealing with variant rich systems.
we mitigate this threat with our evaluation based on the simulation of a real system.
there is a general lack of available systems for benchmarking on realistic revision histories with available feature information a problem that we aim to address as part of our ongoing benchmarking initiative .
1667there are two main threats to internal validity.
first our calculation of cmiss could be incomplete there might be potential omissions not fixed by a later commit.
this situation is comparable to other research that relies on potentially imperfect datasets e.g.
in software defect prediction .
while our analysis focuses on omissions that later required fixing these omissions are arguably the most relevant ones in practice.
second there could be implementation errors after retrofitting our operations to the development process given by the commit revision the atmight be in an incorrect state.
to mitigate this threat one author not involved in the simulation manually inspected a random sample of commits by comparing the gitdiffwith the atresulting from operator invocations.
the atwas always consistent.
vii.
r elated work the five most closely related works are the clone management and product line migration frameworks that we used to inform the virtual platform s design cf.
sec.
iii .
in sec.
vi a and our online appendix we provide a detailed comparison highlighting unique benefits of the virtual platform support for early traceability recording operators for the full spectrum between the extremes ad hoc clone own and integrated platform and an evaluation on a real project revision history.
we now discuss further related work on product line migration and integrated platform evolution.
the idea of automatically handling variation points as the virtual platform does is not new.
in fact going back to the 1970s researchers have built so called variation control systems which never made it into the practice of software engineering.
these systems have been realized upon different back and frontends e.g.
version control systems or a text editor but before effective and scalable concepts from sple research for managing variability have been established.
the virtual platform can be seen as a variation control system.
the large majority of product line migration techniques focuses on detecting and analyzing commonalities and variabilities of the cloned variants together with feature identification and location as shown in assuncao et al.
s recent mapping study based on papers .
case studies of manual migration also exist.
these illustrate the difficulties and huge efforts of recovering important information features and clone relationships that was never recorded during clone own supporting our approach of recording such information early.
finally many works focus on migrating a single system into a configurable product line platform typically proposing refactoring techniques.
wille et al.
use variability mining to generate transformational rules for creating delta oriented product lines.
others focus on evolving software platforms.
liebig et al.
present variability aware sound refactorings rename identifier extract function inline function for evolving a platform by preserving the variants.
rabiser et al.
present an approach for managing clones at product component and feature and define consistency levels to monitor co evolving clones.
ignaim et al.
present an extractive approach toengineer cloned variants into systematic reuse.
neves et al.
propose a set of operators for safe platform evolution.
in contrast to our operationally defined operators these operators are defined on an abstract level based on their pre and postconditions implementing them is left to the user.
incorporating safe evolution or morpheus refacting in the virtual platform is a valuable future work.
viii.
c onclusion we designed formalized and prototyped the virtual platform a framework that exploits a spectrum between the two extremes ad hoc clone own and fully integrated platform supporting both kinds of development.
based on the number of variants organizations can decide to use only a subset of all the variability concepts typically required for an integrated platform fostering flexibility and innovation starting with clone own and incrementally scaling the development.
this realizes incremental benefits for incremental investments and even allows to use clone own when a platform is already established to support a more agile development.
another core novelty is that instead of trying to expensively recover relevant meta data e.g.
features feature locations and clone traces the virtual platform fosters recording it early.
for instance developers typically know the feature they are implementing but usually do not record it.
the virtual platform records such meta data and exploits it for the transition providing operators that developers can use to handle variability.
our evaluation shows that the additional costs are low compared to the benefits.
we see several promising directions of future work.
by allowing developers to continuously record feature meta data the virtual platform paves the way for software analyses that rely on this data.
one example is support for the safe evolution of product line platforms which could be extended to support systems in our intermediate governance levels.
specifying our operators in the framework of software product line transformations would make them amenable to conflict and dependency analysis a versatile formal analysis with applications in the coordination of evolution processes.
many of the virtual platform s operators e.g.
those related to change propagation lead to non trivial changes of the codebase.
to increase developer trust and optimize accuracy an important challenge is to keep the human in the loop which we aim to address by exploring dedicated user interfaces.
by integrating the virtual platform with available annotation systems we could facilitate inspection of the available feature mappings.
offering a preview mode would allow to inspect and interact with the changes arising from a planned operator invocation.
providing a dedicated operator to integrate cloned features is another future direction.
other directions are to support configuration of variants by selecting features offering views and providing visualizations e.g.
dashboards .
finally recommender systems that learn from the metadata and support developers handling features and assets could further encourage using features in software engineering .
acknowledgment.
swedish research council vinnova sweden and the wallenberg academy.
1668references y .
dubinsky j. rubin t. berger s. duszynski m. becker and k. czarnecki an exploratory study of cloning in industrial software product lines in csmr .
s. st anciulescu s. schulze and a. w asowski forked and integrated variants in an open source firmware project in icsme .
j. businge o. moses s. nadi e. bainomugisha and t. berger clonebased variability management in the android ecosystem in icsme .
j. krueger and t. berger an empirical analysis of the costs of cloneand platform oriented software reuse in fse .
n. lodewijks analysis of a clone and own industrial automation system an exploratory study in sattose .
t. berger r. rublack d. nair j. m. atlee m. becker k. czarnecki and a. wasowski a survey of variability modeling in industrial practice invamos .
p. clements and l. northrop software product lines practices and patterns .
k. czarnecki and u. w. eisenecker generative programming methods tools and applications .
f. j. van der linden k. schmid and e. rommes software product lines in action the best industrial practice in product line engineering .
s. apel d. batory c. k stner and g. saake in feature oriented software product lines .
springer .
t. berger j. p. stegh fer t. ziadi j. robin and j. martinez the state of adoption and the challenges of systematic variability management in industry empirical software engineering vol.
no.
pp.
.
k. kang s. cohen j. hess w. nowak and s. peterson featureoriented domain analysis foda feasibility study carnegie mellon university pittsburgh pa usa tech.
rep. .
d. nesic j. krueger s. stanciulescu and t. berger principles of feature modeling in fse .
t. berger s. she r. lotufo k. czarnecki and a. wasowski featureto code mapping in two large product lines in splc extended abstract.
l. linsbauer e. r. lopez herrejon and a. egyed recovering traceability between features and code in product variants in splc .
r. bashroush m. garba r. rabiser i. groher and g. botterweck case tool support for variability management in software product lines acm computing surveys csur vol.
no.
pp.
.
f. stallinger r. neumann r. schossleitner and s. kriener migrating towards evolving software product lines challenges of an sme in a core customer driven industrial systems engineering context in please .
h. p. jepsen j. g. dall and d. beuche minimally invasive migration to software product lines in splc .
w. k. g. assun o r. e. lopez herrejon l. linsbauer s. r. vergilio and a. egyed reengineering legacy applications into software product lines a systematic mapping empirical software engineering vol.
no.
pp.
.
j. krueger and t. berger activities and costs of re engineering cloned variants into an integrated platform in vamos .
j. martinez t. ziadi t. f. bissyand j. klein and y .
l. traon name suggestions during feature identification the variclouds approach in splc .
s. zhou s. st anciulescu o. le enich y .
xiong a. wasowski and c. k stner identifying features in forks in icse .
s. b. nasr g. b can m. acher j. b. f. filho n. sannier b. baudry and j. davril automated extraction of product comparison matrices from informal product descriptions journal of systems and software vol.
pp.
.
j. rubin and m. chechik a survey of feature location techniques indomain engineering pp.
.
b. dit m. revelle m. gethers and d. poshyvanyk feature location in source code a taxonomy and survey journal of software evolution and process vol.
no.
pp.
.
g. k. michelon l. linsbauer w. k. assun o s. fischer and a. egyed a hybrid feature location technique for re engineering single systems into software product lines in vamos .
c. k stner a. dreiling and k. ostermann variability mining with leadt tec.
rep. philipps univ.
marburg .
c. k stner a. dreiling and k. ostermann variability mining consistent semi automatic detection of product line features ieee transactions on software engineering vol.
no.
pp.
.
c. k. roy and j. r. cordy a survey on software clone detection research queen s school of computing tr vol.
no.
pp.
.
d. rattan r. bhatia and m. singh software clone detection a systematic review information and software technology vol.
no.
pp.
.
j. wang x. peng z. xing and w. zhao how developers perform feature location tasks a human centric and process oriented exploratory study journal of software evolution and process vol.
no.
pp.
.
s. gr ner a. burger t. kantonen and j. r ckert incremental migration to software product line engineering in splc .
j. kr ger w. mahmood and t. berger promote pl a round trip engineering process model for adopting and evolving product lines insplc .
b. zhang m. becker t. patzke k. sierszecki and j. e. savolainen variability evolution and erosion in industrial product lines a case study insplc .
m. antkiewicz w. ji t. berger k. czarnecki t. schmorleiz r. l mmel t. st anciulescu a. wasowski and i. schaefer flexible product line engineering with a virtual platform in icse nier .
t. fogdal h. scherrebeck j. kuusela m. becker and b. zhang ten years of product line engineering at danfoss lessons learned and way ahead in splc .
virtual platform prototype projects vp .
appendix .
m. a. laguna and y .
crespo a systematic mapping study on software product line evolution from legacy system reengineering to product line refactoring science of computer programming vol.
no.
pp.
.
l. passos r. queiroz m. mukelabai t. berger s. apel k. czarnecki and j. padilla a study of feature scattering in the linux kernel ieee transactions on software engineering vol.
pp.
.
l. passos j. padilla t. berger s. apel k. czarnecki and m. t. valente feature scattering in the large a longitudinal study of linux kernel device drivers in modularity .
t. berger d. lettner j. rubin p. gr nbacher a. silva m. becker m. chechik and k. czarnecki what is a feature?
a qualitative study of features in industrial software product lines in splc .
j. kr ger w. gu h. shen m. mukelabai r. hebig and t. berger towards a better understanding of software features and their characteristics a case study of marlin in vamos .
j. kr ger m. mukelabai w. gu h. shen r. hebig and t. berger where is my feature and what is it about?
a case study on recovering feature facets journal of systems and software vol.
pp.
.
j. kr ger l. nell w. fenske g. saake and t. leich finding lost features in cloned systems in splc .
t. berger s. she r. lotufo a. wasowski and k. czarnecki a study of variability models and languages in the systems software domain ieee transactions on software engineering vol.
no.
pp.
.
j. sincero h. schirmeier w. schr der preikschat and o. spinczyk is the linux kernel a software product line?
in splc osspl .
w. a. hetrick c. w. krueger and j. g. moore incremental return on incremental investment engenio s transition to software product line practice in oopsla .
d. bilic d. sundmark w. afzal p. wallin a. causevic c. amlinger and d. barkah towards a model driven product line engineering process an industrial case study in isec .
j. rubin k. czarnecki and m. chechik managing cloned variants a framework and experience in splc .
cloned product variants from ad hoc to managed software product lines international journal on software tools for technology transfer vol.
no.
pp.
.
s. fischer l. linsbauer r. e. lopez herrejon and a. egyed enhancing clone and own with systematic reuse for developing software variants inicsme .
j. martinez t. ziadi t. f. bissyand j. klein and y .
l. traon bottomup technologies for reuse automated extractive adoption of software product lines in icse c .
t. pfofe t. th m s. schulze w. fenske and i. schaefer synchronizing software variants with variantsync in splc .
l. montalvillo and o. d az tuning github for spl development branching models repository operations for product engineers in splc .
s. apel c. k stner and c. lengauer featurehouse languageindependent automated software composition in icse .
s. she r. lotufo t. berger a. wasowski and k. czarnecki the variability model of the linux kernel.
vamos .
w. ji t. berger m. antkiewicz and k. czarnecki maintaining feature traceability with embedded annotations in splc .
d. str ber a. anjorin and t. berger variability representations in class models an empirical assessment in models .
k. b ak z. diskin m. antkiewicz k. czarnecki and a. w asowski clafer unifying class and feature modeling software systems modeling vol.
no.
pp.
.
m. antkiewicz k. bak a. murashkin r. olaechea j. hui and k. czarnecki clafer tools for product line engineering.
in splc workshops .
r. koschke survey of research on software clones in dagstuhl seminar proceedings .
schloss dagstuhl leibniz zentrum f r informatik .
h. sajnani v .
saini j. svajlenko c. k. roy and c. v .
lopes sourcerercc scaling code clone detection to big code in icse .
j. martinez w. k. g. assun o and t. ziadi espla a catalog of extractive spl adoption case studies in splc .
d. str ber m. mukelabai j. kr ger s. fischer l. linsbauer j. martinez and t. berger facing the truth benchmarking the techniques for the evolution of variant rich systems in splc .
t. berger m. chechik t. kehrer and m. wimmer software evolution in time and space unifying version and variability management dagstuhl seminar in dagstuhl reports .
schloss dagstuhl leibnizzentrum fuer informatik .
c. catal and b. diri a systematic review of software fault prediction studies expert systems with applications vol.
no.
pp.
.
s. str der m. mukelabai d. str ber and t. berger feature oriented defect prediction in splc .
l. linsbauer t. berger and p. gr nbacher a classification of variation control systems in gpce .
l. linsbauer f. schwaegerl t. berger and p. gruenbacher concepts of variation control systems journal of systems and software vol.
p. .
b. p. munch j. o. larsen b. gulla r. conradi and e. a. karlsson uniform versioning the change oriented model in scm .
a. lie r. conradi t. didriksen and e. karlsson change oriented versioning in a software engineering database in scm pp.
.
d. rabiser p. gr nbacher h. pr hofer and f. angerer a prototypebased approach for managing clones in clone and own product lines inproceedings of the 20th international systems and software product line conference pp.
.
v .
j. kruskal managing multi version programs with an editor ibm journal of research and development vol.
no.
pp.
.
w. k. g. assun o r. e. lopez herrejon l. linsbauer s. r. vergilio and a. egyed reengineering legacy applications into software product lines a systematic mapping empirical software engineering vol.
no.
pp.
.
c. k stner s. apel and d. s. batory a case study implementing features using aspectj in splc .
r. kolb d. muthig t. patzke and k. yamauchi refactoring a legacy component for reuse in a software product line a case study journal of software maintenance vol.
no.
pp.
.
s. schulze t. th m m. kuhlemann and g. saake variant preserving refactoring in feature oriented software product lines in vamos .
j. cleland huang a. agrawal m. n. a. islam e. tsai m. van speybroeck and m. vierhauser requirements driven configuration of emergency response missions with small aerial vehicles in splc .
d. wille t. runge c. seidl and s. schulze extractive software product line engineering using model based delta module generation in vamos .
j. liebig a. janker f. garbe s. apel and c. lengauer morpheus variability aware refactoring in the wild in icse .
k. ignaim j. m. fernandes a. l. ferreira and j. seidel a systematic reuse based approach for customized cloned variants in quatic .
l. neves p. borba v .
alves l. turnes l. teixeira d. sena and u. kulesza safe evolution templates for software product lines journal of systems and software vol.
pp.
.
g. taentzer r. salay d. str ber and m. chechik transformations of software product lines a generalizing framework based on category theory in models .
d. str ber s. peldszus and j. j rjens taming multi variability of software product line transformations in fase .
m. chechik m. famelis r. salay and d. str ber perspectives of model transformation reuse in ifm .
l. lambers d. str ber g. taentzer k. born and j. huebert multigranular conflict and dependency analysis in software engineering based on graph transformation in icse .
t. schwarz w. mahmood and t. berger a common notation and tool support for embedded feature annotations in splc .
s. stanciulescu t. berger e. walkingshaw and a. w asowski concepts operations and feasibility of a projection based variation control system inicsme .
b. andam a. burger t. berger and m. r. v .
chaudron florida feature location dashboard for extracting and visualizing feature traces invamos .
s. entekhabi a. solback j. p. stegh fer and t. berger visualization of feature locations with the tool featuredashboard in splc tools track .
h. abukwaik a. burger b. andam and t. berger semi automated feature traceability with embedded annotations in icsme .