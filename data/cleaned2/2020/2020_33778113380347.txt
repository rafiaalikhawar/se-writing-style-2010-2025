multiple entry testing of android applications by constructing activity launching contexts jiwei yan tech.
center of softw.
eng.
institute of software cas china univ.
of chinese academy of sciences beijing china yanjw ios.ac.cnhao liu dept.
of informatics beijing university of tech.
china beijing chinalinjie pan state key lab.
of computer science institute of software cas china univ.
of chinese academy of sciences beijing china jun yan state key lab.
of computer science institute of software cas china univ.
of chinese academy of sciences beijing chinajian zhang state key lab.
of computer science institute of software cas china univ.
of chinese academy of sciences beijing chinabin liang school of information renmin university of china beijing china abstract existing gui testing approaches of android apps usually test apps from a single entry.
in this way the marginal activities far away from the default entry are difficult to be covered.
the marginal activities may fail to be launched due to requiring a great number ofactivitytransitionsorinvolvingcomplexuseroperations leading to uneven coverage on activity components.
besides since the test spaceofguiprogramsisinfinite itisdifficulttotestactivitiesundercompletelaunchingcontextsusingsingle entrytestingapproaches.
in this paper we address these issues by constructing activity launchingcontextsandproposingamultiple entrytestingframework.
we perform an inter procedural flow context and pathsensitive analysis to build activity launching models and generate completelaunchingcontexts.byactivityexposingandstaticanaly sis wecouldlaunchactivitiesdirectlyundervariouscontextswith out performing long event sequence on gui.
besides to achieve anin depthexploration wedesignanadaptiveexplorationframework which supports the multiple entry exploration and dynamically assigns weights to entries in each turn.
our approach is implemented in a tool called fax with an activitylaunchingstrategyfax laandanexplorationstrategyfax ex.the experimentson20real worldappsshowthatfax lacancover96.
and successfully launch .
activities based on which fax exfurther achieves a relatively .
improvement on method coverage compared with the most popular tool monkey.
our tool also be haves well in revealing hidden bugs.
fax can trigger over sevenhundred unique crashes including errorsand 539warnings corresponding authors.
email yanjun ios.ac.cn zj ios.ac.cn permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn ... .
is significantly higher than those of other tools.
among the bugs reported to developers on github have been fixed up to now.
ccs concepts software and its engineering software testing and debugging keywords android app static analysis icc multiple entry testing acm reference format jiwei yan hao liu linjie pan jun yan jian zhang and bin liang.
.
multiple entrytestingofandroidapplicationsbyconstructingactivity launching contexts.
in 42nd international conference on software engineering icse may23 seoul republicofkorea.
acm newyork ny usa pages.
introduction mobile applications especially android apps have witnessed an explosive growth in recent years.
meanwhile the defects in an droidapplicationsarousedtheattentionofresearchers .due to the event based characteristic of android apps the test casesare in the form of gui events.
for gui testing a great number ofautomaticexplorationapproacheshavebeenproposed including random model based and systematic ones aiming to cover more components or transitions.
despite using different exploration strategies these approachesusually start their exploration from the default entry point i.e.
mainactivity of the target app.
in this paper we refer them as single entry testing set ones.
in set approaches some obstacles e.g.
complex gesture or logical operations make some activities unreachable.
besides each activityhasanimpliedexplorationdistancefromthesingleentry point whichisunequalandleadstounevencoverageonactivity components.
one recent work makes use of the state of the arttool monkey to test a widely used app wechat and has a similar observation monkey allocates a lopsided distribution of exploration time on each activity .
furthermore because of the ieee acm 42nd international conference on software engineering icse infinitetestspaceofguiprograms itisdifficulttolaunchactivities under complete contexts using set.
to address these issues and achieve in depth gui testing on mobile apps we take each activity as a separate entry and propose the multiple entry testing met approach.
fig.
shows the exploration paths in set and met.
under set theactivity accountcannotbelaunchedifitsdomainnode e.g.
detail failedtobevisited.inaddition accounthasdifferentbehaviors depending on its activity launching contexts alcs whichisgeneratedbypreviouseventoperationsorreceivedfrom outside e.g.
another app .
using set it is difficult to cover all alcs and measure the test adequacy involving activity launching.
ifweadoptmet accountcanobtainafairlaunchingchanceasthe default entry and can be tested completely under multiple alcs.
display detail search accountmain settingmultiple contextsmain display setting detail search accountcomplex gesture logical operation figure single and multiple entry testing usually the user can successfully launch the default entry of an app by simply clicking the icon on the launcher of the phone or sending an external command with the name of the target activity.however agreatnumberofactivitiesrequirespecificdata itemsduringlaunchinganddecidetheexecutionpathsaccording to the type and value of these data items.
that is to say without proper alcs the metprocess maybe incomplete andineffective.
in android several context related information may influence the launching result includingthe inter component communication icc message deviceconfiguration activitystack andglobaldata among which the icc message is the most important one.
to generate icc messages properly we should precisely model the name type datastructureaswellasthevalueconstraintsofeachattribute.
challenges.
thefirstchallengeliesinthemodelingofthecomplex attributes of icc messages.
existing works extract the attribute declarations by xml file analysis.
however according to our research the attribute declaration of activity isusually inconsistent with its usage.
therefore it is necessary tomodel the icc information by extracting the constraints of attributeusageondifferentexecutionpaths.accordingtotheapis providedbyandroidreference activitycanreceivetwotypes of data items basic attribute andextra parameter in which the extra parameter can be further separated into prime objectand bundle extra parameter according to the value it contains.
for a basic attribute we concentrate on the candidate values that can influencethebranches foraprimaryextraparameter weshould extract both the extra type and its key for input generation an objectextraparameterrequiresanobjectdataitem whichmeansa corresponding object must be instantiated first as test data and for abundleextraparameter whichisanestablekey valuemap we shouldreconstructitsoriginaldatastructure.togenerateproperalcs as much as possible all of these characteristics should be considered.
thesecondchallengeistheweightassignmentamongentries in met.
different from set approaches which always start testing fromthedefaultentry themetrequiresustomakedecisionson the exploration weight of each entry.
on one hand some activities failtobelaunchedbytheconstructedalcsduetounexpectedapp crashes.
thus the exploration should make more efforts to cover theseactivitiesfortesting.ontheotherhand theactivitiesthatcan lead to more activity transitions should have higher exploration weight.forexample thedefaultentryisusuallymoreimportant thantheleafactivitieswhichneverjumpout.thestaticactivity transitiongraph atg canbebuiltforhelp however itmaybe imprecise.
during testing the activity launching result changes dynamically and new transitions can be detected.
thus the weight assignment should be adaptive during the met process.
ourapproach.
inthispaper weproposethemetapproachto replacethetraditionalsetapproaches.wefirstanalyzetheiccre ceivingprocessandperformaninter procedural flow context andpath sensitive analysis to construct the activity launching models alm whichdescribestheconstraintsofrequiredattributesand parametersineachactivity.eachalcinthealmcorrespondstoa unique intent resolving related execution path.
then we calculate theweightsofalcsaccordingtoboththeactivitylaunchingstatusandthereachabilityinformationbetweenactivities.theexploration isdesignedformultiple roundtesting whichfirstlauncheseach alcandassignstheinitialweight.thenitincreasesthenumber oftotaleventsineachroundandreassignsthetestingweightdynamically.
finally we can achieve an in depth exploration by alc generation and adaptive weight assignment.
contributions.
the contributions of this work are three fold context construction.
we perform static analysis to build alms for activities and generate proper alcs for them.
explorationframework.
wedesignageneraladaptiveframework for multiple entry testing which supports two strategies the activity launching strategy fax laand the exploration strategy faxex.
tool implementation.
we implement our approach in the toolfax which is publicly available on github.
the experimental results indicate that fax has a strong bug detection ability and reaches high code coverage.
background thissectionprovidesaintroductionofthefundamentalbuilding blocks in android apps.
.
android activity activity whichprovidesagraphicaluserinterfacetousers isthe most frequently used component inthe android system.
the user performsuioperationsonactivitiesandtriggersactivitytransitionstocompletetheirdailytasks.ifausertriggersanactivitytransition thecalleractivitywillsendaniccmessageaccordingtothe intent mechanism .
then the current activity will be stopped and thenewonewillbelaunched whichismanagedbytheandroidsystem.
each icc message contains a specific invocation targetaswellasaseriesofdataitems.accordingtowhetherthetarget 458activitiescanbelaunchedbyexternalapps theycanbeseparated into internalactivity ia andexported activity ea .
theias can only be visited through a set of user operations that start from the eas whiletheeascanbetakenashiddenentriesoftheappand belauncheddirectly.tovisitoneactivitydirectly wecanmodifyit as an ea to support one step invocation by declaring the attribute android exported true or setting intent filters in the manifest file.afterexported eveninternalactivitiescanbelauncheddirectly without performing complex user event sequences.
.
activity launching context according to the activity launching process four types of subcontext may have influences on the launching result.
icc message.
an icc message is an intentobject carried with a set of data items which depends on the caller activity.
device configuration.
the device configuration denotes the user configurable status of the mobile phone e.g wifi gps status which depends on the setting of the phone.
activity stack.
the activity stack stores the history activities visited before reaching the current one which depends on the exploration trace.
globaldata.
theglobaldatacanbemodifiedanywhere which depends on the previous user operations.
to achieve effective testing of android apps we try to create alcs that can trigger as many program paths as possible using these sub contexts.
for the icc message we model their usage withthehelpofstaticanalysistoachievebackwardalcgenerationandautomatictesting.fordeviceconfiguration wescanthe corresponding apis and give reports about the used configuration itemsofanapp.forstackcontext anactivitycanbetestedunder an empty stack with fax laand under non empty stack with fax ex.
the global data is difficult to be controlled e.g.
the number of files onthe sdcard.however if theglobal datacan bemodifiedduring exploration itsvaluecanhelptotriggermoreprogrampathsinthe multiple round testing.
for example if the global setting related activities are explored in multiple rounds the operations on it will create different global data contexts for other activities in that app.
.
icc message and intent receiving icc message is one of the most important sub context which has a complex composition and is necessary for the activity launching.
table lists the required attributes in icc invocation and gives theircharacteristics inwhichcolumns locdandlocudenotethe declarationandtheusagelocationsoftheseattributes respectively.
in this table we classify icc attributes into two types basic attributeandextra parameter.
as we can see the basic attribute including action category dataandtype can be declared both in the intent filters in the manifest file as well as be used in the javafiles.
however there are mismatches between the attribute declarationanditsusage.forexample theactivity messagelist inpopularapp k9mail whichhasover4000starsongithub requeststhreeactionsinjavacode inwhichonlyoneofthemis declared in the manifest .
this activity also declares two values intheintent filterinthe manifest file butoneisinvalidandnot used in the java code.wefurtherperform theconsistencydetection betweenthedeclaration and usage of all the apps collected from f droid .
theresultsarelistedintable1 includingthestatisticresultsofthe numberofdeclaredandusedattributevalues aswellashowmanyofthemareconsistent.notethatthevalueofthebasicattribute data isaregularexpression sowedonotgivetheconsistencyofdata attribute.
as we can see there are huge inconsistencies.
the key reason is that the intent filters are designed for implicit invocation.
developers can declare multiple attribute values in intent filters to characterizeoneactivitybutdonotusetheminthe javacode.the attributethey actuallyusedmay notberelated toimplicitinvocationanddonotbedeclared.therefore onlycollectingthedeclared valuesoficc relatedattributesinthe manifest fileisnotsufficient for activity modeling.
table consistency of basic attributes of apps declaration usage consistent action category data type besidesbasic attribute icc messages also accept extra parameters.
each extra parameteris a key value pair angbracketleftk v angbracketright which can be separateditintothreesub types primaryextraparameter object extra parameter andbundle extra parameter according to the type of the value v. different from the basic attribute the extra parametersarenotdeclaredanywhere butonlyusedincode.thecaller activitycanattachan intentwithdifferenttypesofextradataitems via a series of overloaded apis.
android system provides a number of apis for thereceiver activity to get thetransferred data accordingtothegivenkey.accordingtoandroidapidocument the valueof extra parametercan be anytype of thejava primitive datatype e.g.
int boolean orothertypeslike string arrayand arraylist etc.
for example the api getintexra string city isusedtogetanintegervalueaccordingtothekey city.thevalue ofanextraparametercanalsobeobjecttype serializable and parcelable or bundle type bundle in which the object type denotesanobjectimplementingaspecificinterface andabundle typeisasetofkey valuepairsthatstoresagroupofsub itemsin types of primary object or nested bundle extra parameter.
table composition of icc message type subtype locdlocu type basicaction xmljava string category xmljava set angbracketleftstring angbracketright data xmljava string type xmljava string extraprimary java angbracketleftk v angbracketrightpair kis instringtype vis a sub item in type of java primitive data types string array arraylist etc.
object java angbracketleftk v angbracketrightpair kis instringtype vis aserializable parcelable object or a set of objects.
bundle javaset of angbracketleftk v angbracketright each of which can be a primary extra an object extra or a nest bundle extra.
motivating example inordertoshowtheprocess ofhowtheiccmessagesarereceived by activities as well as how the icc attributes parameters are used in the code we take exampleactivity as our motivating example which is shown in fig.
.
whenanactivityislaunched theandroidsystemwillcallitslifecyclemethods.inthisexample westartfromitslifecyclemethod oncreate .first theactivitygetsan intentobjectthroughthe apigetintent andcreatesan intentvariableintenttostore the information of the received icc message.
then the value of each attribute carried in the icc message will be obtained through several apis e.g.
using api getaction to get the value of basic attributeaction usingapi getintextra key togetthevalueof primary extra parameter with a specific key etc.
after that the attribute value receiving variables will be used for branch picking log recording or other purposes.
when the received value of an attribute is used in a branch picking condition through compar ison there should be candidate values of this attribute that can influencetheprogram sexecutionpath.forexample thestatement if maction.equals action view contains an attribute receiving variable maction a comparing operation equalsand a candidate value action view of the basic attribute action.
however not all of the candidate values can be obtained directly.ononehand theattributereceivingvariablemaytransfer its value to other variables and form new condition constraints.
like in line the attribute receiving variable action1 is not used inbranchpickingconditions.asshowninthefollowinglines its value is transferred to variables action2 andaction3.
the new constraintsare getaction .substring .equals act andgetaction .charat c .ontheotherhand thestringtype candidate values may not be obtained directly.
it could be manipulated by a set of string related apis come from the formal 1public class exampleactivity extends activity override 3protected void oncreate bundle savedinstancestate icc message 5intent intent getintent get intent 6string action1 intent.getaction get action 7string action2 action1.substring 8charaction3 action1.charat 9if action2.equals act if action3 c dosomething unsat path else if action1.startswith getprefix startwith bundle b1 intent.getbundleextra b1 string s1 intent.getstringextra s1 float f3 b1.getbundle b2 .getfloat f3 if f3!
null dosomething 22private string getprefix string str inti string newstr str.substring i returnnewstr string operation figure motivating exampleparameter of the current method or be the return value of another method.inline13 forinstance thecandidatevalue sta isdecidedbythereturnvalueofmethod getprefix i.e.
itdependsonboth the value of the formal parameters of method getprefix and the semantic of api getsubstring .
in addition to string analysis the received icc message may have specific structures.
as shown in line each extra parameter may belong to different datatypes andmayhavespecificstructure b1 bundle s1 string b1.b2 bundle b1.b2.f3 float whichshouldbepreciselyreconstructedinordertogeneratedummycalleractivitieswithcorrect icc message as test cases.
framework overview infig.
wegivetheframeworkoverviewoffax whichtakesan apk file as input and generates a group of test cases.
after test execution itoutputsasetofcorrespondingreports.first weinstrumenttheoriginalapktoexposeiaintoea whichonlymodifies themanifest file and does not bring extra overhead in dynamic testing.then weperformstaticanalysistogettheactivitylaunching model alm that describes the attribute usage information as wellastheactivitytransitiongraph atg thatshowstherelationshipofactivities.weusethealmtogeneratealcsofactivities andperformtestcaseexecutiononandroiddevices.becausethe generated test scripts only launch activities under various contexts without gui exploration we call this strategy as faxla.
besides we have another strategy faxex which first filters alcs using the launching results of faxla.
then it takes the activity relationships in atg and the set of activities failing to be launched to guide the weight assignment among alcs.
fax supports multiple round testing.
during the exploration it collects the execution traces for the weightcalculationinthenextround.besides theusercanadoptany explorationstrategyaccordingtotheirrequirement.therandom strategy is adopted in the current version of our implementation.
context construction for testing this section introduces the alc construction process which is based on the inter procedural flow context and path sensitive static analysis techniques.
.
string constraint extraction forbasicattributes weaimtofindtheconstraintsoftheircandidates precisely which are combined by the manipulation of thedata receiving variable receivevar the comparison operation compareop andthepre definedcandidatevalues candidateval .
and for the extra parameters extrapara we try to get the correct key and type of value.
for both kinds our method is mainly table information of string related apis setz3ret value used in api s1tstring charreceivevar comparevar extraparaappend concat tostring substring charat s2fstringcandidateval extraparatrim equalsignorecases touppercase tolowercase s3tboolean compareop !
isempty contains equals startswith endswith 460activity exposing activity launching model activity transition graphtest scriptsexecutionexecution traces exploration weight calculationstatic analysisdynamic updatefaxla faxexreports exploration sequence generation exploration strategylaunch command generationdummy apps figure overview of the multiple entry testing framework which is implemented in the tool fax based on reaching definition technique which is a commonly used data flow analysis.
it statically determines which definitions mayreachagivenpointinthecode andcanhelpustoconstruct use define chains to capture data propagation.
boththecandidatevalueofthebasicattributeandthekeyofthe extraparameterarerelatedto string.injava8 therearetotally67 stringrelatedapis including value relatedapis thatreturna new string or char compare related apis that return a boolean flag andinfo related apis such as length etc.
in our work we only concentrate on the first two types.
in table we classify stringrelatedapisintothreeclassesaccordingtotheirreturntypeand whether they are supported by string constraint solver z3 .
in the fourth column we show where these apis are used.
note thatoperator for stringwillbetransferredtotheinvocation ofappend in the intermediate representation of java.
algorithm demonstrates the process of intent receiving analysis.
it shows how the constraint set is constructed when finding an intent receiving statement.
it accepts a method mas input outputs asetofextrakey valuepairsandconstraintsofattributes.inline2 wecalculateuse definechains udcofeachstatementin m which canbeobtainedbysomematureanalysisframework e.g.
soot .
then we locate the input data obtaining instructions i according to android apis including getaction getcategories getdata getdatastring andgettype .
for each instruction insin i function et attr varsreturns a set of variables which store the received input data.
note that the value of anattributereceivingvariablecanbetransferredtoothervariables through severalvalue related apis wetrack thetainted variables throughudcand add them into the attribute receiving variable set vars.inline6 wegetagroupofstatements scowhichusethevariablevarfor comparison in a condition see s3 in table .
for each insco theinputdatawillbecomparedwithanotherstring whichis acandidatestring.inline9 wegetthevariable canvarwhichstores the candidate string and try to get its value.
if canvaris defined as aconstantstring wecanobtainthestringdirectlyinline11.otherwise werecursivelyanalyzeitsvaluewhichmaybemodifiedbythe stringoperation sees1ands2intable3 .ifthecandidatestring is obtained from the return value of other methods or from the formal parameter sent by the caller of the current method we lookinto the invoked methods with current invoking context i.e.
parametersofmethodinvocation orquerythesimulatedmethodcall stack to build the correct candidate.
in line we use the collectedinformationtoupdatetheset constraints .theextraparametersare extracted in line by function extract extras which will be introduced in the following subsection.
algorithm intent receiving analysis input methodm output attribute constraint set constraints extra set extras constraints extras udc ge use def chains m foreachinsin all i of mdo vars get attr vars ins udc forvarinvarsdo sco get compare ins var udc forinscoinscodo co get compare operation insco canvar get candidate var insco ifcanvarcan be obtained directly then canvalue get constant value canvar else canvalue get value of var canvar udc end if constraints constraints angbracketleftins var co canvalue angbracketright end for end for end for extras extract extras m udc returnconstraints extras in the example in section we can get variables vars l5intent l6 action l7 action.substring l8 action.charat and constraints constraints l9 action.substring equals act l10 action.charat c l13 action startswith sta .
.
extra parameter analysis theextrasinalgorithm1containsasetofextraparameters each of which is a key value pair.
an activity makes use of several specific system apis of the intentclass to retrieve the data with a 461specific type by a user defined key e.g.
getstringextra s1 .
our goal is to locate the invocations of these apis and obtain keys andtypesofdataitemsforeachactivity.tolocatethe extraparameterobtaininginstructions epois wecollectanapilist including29 apisofintentclass 24apisof bundleand4apisof parcelable that can be used to get extra parameters with different types accordingtotheapireference .withthislist itiseasytofind outtheepoisanddeterminethetypesofextraparameters.note that these extraparametersare usuallyusedfor providingvalues thus their data are arbitrary.
after extracting their type and key we generate a set of data according to their types.
algorithm2givestheprocessofhowtoextractextraparameters.
forexample in javafile wemayhaveastatement getstringextra s1 .intheintermediaterepresentationformat jimple shimple transformedbysoot thekey s1 willbestoredinanadditionalvariable e.g.
we may have x s1 getstringextra x .
in line the function get used var will return the variable that stores the keyvalue i.e getvariable x.togetthekeyofextraparameters we theninvokethefunction get value of var inline4togetthevalue ofthegivenvariable i.e getvalue s1 .function get type inline5 returns the type of an extra data item which can be a basic java type like stringtype forgetstringextra or an encapsulated android specific type like bundleforgetbundleextra .
the algorithm of function get type is shown in algorithm .
for basic types they can be extracted from the name of apis.
the special situation is the getbundleextra like instructions which obtain algorithm extract extras input methodm use define chain udc output extra setextras extras foreachinsin all epois of mdo var get used var ins key get value of var var udc type get type ins var udc extras.add angbracketleftkey type angbracketright end for returnextras algorithm get type input epoiins variable var chain udc output typeextratype ifinsis in basic type then extratype get basic type ins else ifinsis in bundle type then ps get propagation set var udc foreachbinsinpsdo bivar get used var bins bikey get value of var bivar udc bitype get type bins bivar udc extratype.add angbracketleftbikey bitype angbracketright end for end if returnextratypeadataitemwith bundletypethatmayconsistofmultipleextraparameters i.e.
keyandtypepairs.thusitneedstorecursetoextract thesenestedkeyandtypepairs.forthiscase themethod get type firstcalculatesthesetofinstructions psthatvarispropagatedto.
with this set we recursively get the key type pairs attached to the bundletype and return a bundle object as the type.
at last the tuple angbracketleftkey type angbracketrightwill be collected and returned.
.
activity launching model construction theactivity launching model alm can be formally defined as a tuple m angbracketleftentry nb ne e r angbracketright where entryis the root node of the alm which represents the execution entry of the activity.
nbisasetofbasicattributerelatednodes.eachnode n nb is a triple id attr constraint whereidis the identifier of the node attris an icc related basic attribute and constraint describes the constraints about attr.
neisasetofextraparameterrelatednodes.eachnode n neis atuple id para whereidistheidentifierofthenode set para containsagroupofextraparametersinthe formof key type .
eis a set of edges that link nodes on the same execution paths.
ris a tuple path res wherepathcontains a list of idsof nodes n.id path n nb ne andresgives the solving results of the constraints.
after generating test data for eachattribute parameter for one feasible path in r we can get an activity launching context alc as a test case.
fig.
uses a tree to display the alm of the motivating example inwhicheachpathcorrespondstoalistofattributesorparametersinaniccmessageandtheleafnodesdisplaytheconstraintsolvingresults.inthiscase wegetthreefeasiblepaths.onepathisdropped out because the path condition is unsatisfiable.
entry action.substrin g act action.substring !
act action.
charat c action.
charat !
c action.startswi th sta !action.startsw ith sta extras s1 b1 b1.b2 b1.b2.l2p1 unsat p2 action sact p3 action stau extras s1 b1 b1.b2 b1.b2.l2p4 action j figure alm of the motivating example in an alm each path can be transformed into a set of alcs by giving assignments of attributes parameters in the path.
for the basic attributes we generate assignments that satisfy the collected constraintsinsection5.
.consideringthateachreceivedvaluefrom icc should be checked by null checkers before used we mutate the default paths by adding nullvalue as candidate value for each attribute parameter without using an explicit null checker.
for theextraparameter wedesignasetofabnormalvaluesforextra parameters e.g.
nullvalue the boundaryof corresponding extra type extremely long string etc.
.
test script generation thealcswillbetransformedintoexecutabletestcases.theadbformcommandiswidelyadoptedowingtoitssimplicityandefficiency.
unfortunately it has several limitations.
first the adb form invocationdoesnotsupportpermissionrequirement i.e.
thecalleeactivityrestrictsitscallersbyrequiringspecificpermission.besides thetypeofparametersthatanadbcommandcancarryislimited.ifatestcasecontainsany javaobject suchas bundleorarraylist object it can not be sent through adb.
todealwiththisproblem wedesignadummyapptotransitthe launching command.
first fax detects the required permissions of the app under test.
then an empty android project will be created with the required permissions.
for each alc fax creates an exporteddummyactivitywhocanbedirectlylaunchedusingadbcommand.
for example adb shell am start n com.fax.test .dummy id .
in theoncreate method of each dummy activity we generate launchingrelatedcodethatsendsaniccmessagewithcorresponding alc.
for each parameter in an icc message we create objects accordingtoitstype.forbundletype wereconstructtheproperdata structure.
clicking on the ui of the activity in the dummy app can also launch the activity to be tested.
so that we can easily perform the test by starting the activity form test cases in dummy apps instead of the activities in the app under test.
multiple entry exploration besides launching activities with proper alcs we also want to detect hidden bugs that can be triggered during the in depth explo ration through multiple entries.
therefore we need to measure the importanceofeachentryandassignweightsamongthemduring testing.however partofactivitiescannotbesuccessfullylaunched as exploration entries and the contribution of activities vary in the whole testing approach e.g.
a leaf activity which never jumps out is likely to need fewer testing events.
furthermore both the launchingresultand thetransitioncontributionaredifficulttobe precisely obtained by pure static analysis.
in the strategy fax ex we combine the static model and the dynamic execution results to perform an adaptive exploration.
algorithm4givestheprocessoftheadaptiveexploration which starts with a coarse grained atg and adjusts the weights of alcs dynamically.
at first the atg information is constructed statically and the execution information is empty.
we use function la lc togettheactuallylaunchedactivitybyexecutingalc lc.ineach round we obtain the subview of each alc.
for crash triggering alcs theirweightsarezero.foracrash irrelevantalc werecord the subview svlcas thesub graph of thecurrent atg which contains all the reachable activities starting from activity la lc .
set sflcis the set of activities that failed to be launched in svlc.
for each alc in the launching context set lcs its weight will be recalculated in multiple rounds.
the weight of lcin theithround exploration can be calculated by formula wei ht lc i summationdisplay.1 dis la lc aj summationdisplay.
nm ak wherei lc lcs j sflc k svlc .thefunction dis la lc aj evaluatesthedistancebetweenthelaunchingtarget activityla lc andeachelementin sflc.thealcthatcanreachalgorithm adaptive exploration input application app activity launching context set lcs i execution info atg1 getsatg app whilenot timeout do atgi get atg app execution info foreachlcinlcsdo la la lc svlc subview of lainatgi sflc activities in svlcthat are failed to be launched weightlc get weight la s v lc s flc end for foreachlcinlcsdo calculate the priority and event number of lc end for perform testing in the ithround update the activity launching results into execution info update the execution traces into execution info i i end while more unvisited activities or reach unvisited activities with fewer transitionswillhaveahigherweight.weusefunction nmtocount thenumberofmethodscontainedintheactivitiesinthesubview svlc which indicates the subview size of each launching target activity.
the alc whose subview reaches more methods will have ahigherweight.inthe ith i roundexploration setsf lcand subviewsv lcareupdatedbythedynamictransitioninformationin theprevious i throunds.weuseparameter tobalancethe distance to unvisited activities as well as the contribution of the launching target.
parameter is a basic constant weight which is designedfornon leafactivitieswhosetransitionsarelostintheini tialatg.itguaranteestheweightsofallalcstobepositive.after weight calculation we use the weight ratio among all launching contextsintheset lcstogettheexplorationprioritybyformula where m lcs .
priority lc i wei ht lc i summationtext.1wei ht lcm i accordingtotheexplorationeventnumberineachturn wecan get the exploration event owned by each activity using formula .
we use function en i to denote the number of events in the ith round.
and in our tool the number of total events will increase with the refinement of exploration model in multiple rounds.
event lc i priority lc i en i for example consider the example in fig.
.
if we have three lcs see fig.
that can successfully launch activities main detail andsetting and the other activities failed to be launched.
suppose i and each activity has one method we can calculate their exploration weight as weight lc weight lc weight lc .
priority lc priority lc priority lc .ifwehave470exploration eventsinthefirstround wehaveevent lc event lc event lc rather than the assignment event lc in set.
463displaydetail searchaccountlc2 alc2 detail setting searchlc3 alc3 settingmain display setting detail search accountlc1 alc1 main figure subviews from different entries evaluation explorerweimplementourapproachintoolfax fairandroid explorer .asshowninfig.
faxcontainstwostrategies theactivity launching strategy fax laand the adaptive exploration strategy faxex.
in the preprocessing part we adopt the decompilation tool apktool and the instrumentation tool insdal for activity exposing and coverage measurement.
the static analysis part is builtontopofthedata flowframework soot andandrolic toconstructalmandatg.weuseandroid adb toinstallapks and make use of the build tool ant to build app form test cases.
wecollected20popularopen sourceappsfromgithubtoevaluate the effectiveness of our tool.
all of our analysis processes areperformedonanintelcorei7 3770cpu .40ghzmachine with16gbmemoryandwindows7operatingsystem aswellas a mobile phone samsung s7 in the version of android .
.
on our benchmark the static analysis and the test case generation modules take seconds in total.
the generated dummy apps contain launching commands.
each launching command isan exported activity that can be invoked directly by adb.
our evaluation aims to address the following four research questions rq1 context construction what is the effectiveness of the activity launching context construction?
rq2 activity launching what is the effectiveness of the activity launching ability of fax?
rq3 app exploration can the event reassignment mechanism of fax help to improve code coverage?
rq4 crash detection can fax find more real bugs by supporting multiple entry testing?
.
effectiveness of context construction we designabenchmark intentbench to evaluatethe effectiveness of the context construction.
it contains activities and involvesvariousfeatures e.g.
branch loop override inter procedure and intent receiving characteristics.
we show the self checking result in table in which the first two columns give the category nameandthenumberofactivities a .thefollowingcolumnsgive the results of icc attribute identification and alc generation.
for attributeidentification wecollectthenumberofattributevalues used in each category attr the correctly extracted attributes by fax tp the misreported ones fp e.g.
giving the wrong candidate ofaction and the lost ones fn e.g.
losing one candidate of action.foralcgeneration wecheckthecorrectnessofalcsby comparing them with all the icc related program paths.table effectiveness checking on intentbench icc attribute launching contextcategory a tp fp fn tp fp fn basic attrbute extra parameter basic and extra string null checker override lifecycle sensitivity complete total the loss of precision in the sensitivity category is due to several reasons there may be fps when an attribute variable is compared with a field static value whose assignment may be wrongly obtained whenthestringvalueisoperatedbyloopoperations or obtained from unknown library functions there will be fns.
besides the path sensitive analysis for alc generation may suffer from path explosion there will be fns when the actual number ofpathsisbeyondthethreshold.inourexperiments welimitthe number of paths to .
.
effectiveness of activity launching according to the previous works monkey is one of the most popular and effective testing tools due to its effectiveness and simplicity.
although monkey behaves well in gui testing we noticed that there is a model based testing tool ape which aimstoreplacemonkey.andintentfuzzer whichsendsintents with null value as well as serializable data aims to trigger activitylaunchingrelatedbugsspecifically.therefore wecomparewiththebaselinemonkeyandthestate of the artguiexplorationtoolape aswellasthefuzzingtoolintentfuzzer whosecharacteristicsare listedintable5.inthefollowingexperiments wesetonehourasthetestingupperlimittimeforalltoolsoneachinstance.beforetesting weloginappsmanuallyaccordingtotheirfunctionalrequirements.
table characteristics of tools name target entry strategy monkey gui exploration single random ape gui exploration single model based intentfuzzer intent fuzzing multiple none fax both multiple random fig.6givesthenumberofactivitiesofeachappinourbenchmark aswellasthecoveragereachedbyalltools.thereare391activitiesinourbenchmark.afteronehouroftesting monkeycovers147of them and ape covers .
as we can see monkey reaches high activitycoveragewhenthenumberofactivitiesinanappissmallbut becomesineffectivewhenan apphasalargenumberofactivities.
apehasasimilartendencyasmonkey butitusuallyreacheshigher coverage than monkey does.
the tool intentfuzzer only covers activities.
theperformance of intentfuzzer isnot stable when testing all activities continuously.
and fax with strategy fax ex covers377 .
whichworkswellregardlessofthesizeofthe app.
note that some activities crashed when launched e.g.
which 4640102030405060number of activitynumber of activity covered by monkey covered by ape covered by intent fuzzer covered by fax figure activity launching comparison meanstheyareineffectiveinstrategyfax ex.thus wecountthe number of successfully launched ones by detecting whether the activityondisplayisthesameasthelaunchtarget.wefindthat there are activities that can be successfully launched by fax which reaches .
.
.
effectiveness of exploration weusemethodcoveragetoshowtheexplorationeffectivenessof eachapplication.intable6 thesecondcolumngivesthetotalnum berofmethods.themethodcoverageofmonkey ape intentfuzzer if for short and fax are shown in the following four columns.
as wecansee faxoutperformsmonkeyon18of20appsandachieves thehighestcoveragein12apps whichshowsitcanexploreappseffectively.comparedwithmonkey itachievesarelatively19.
high coverage.
for some apps such as evercam andinaturalist faxcanvisitorderofmagnitudegreaternumberofmethodsthan using one hour monkey testing.
overall ape achieves the highest coverageandfaxreachesslightlylowercoverage.therootcause isthedifferencesintheirexplorationstrategy.wecanfurthertry to adopt the model based strategy to improve the code coverage of fax.
fax achieves lower coverage on antennapod andpassandroid table method coverage comparison app method monkey ape iffax 1sheeld .
.
.
.
afwall .
.
.
.
ankidroid .
.
.
.
antennapod .
.
.
.
calendula .
.
.
.
conversations .
.
.
.
csipsimple .
.
.
.
etesync .
.
.
.
evercam .
.
.
.
inaturalist .
.
.
.
k9mail .
.
.
.
lincal .
.
.
.
opengpstracker .
.
.
.
openkeychain .
.
.
.
padland .
.
.
.
passandroid .
.
.
.
simple solitaire .
.
.
.
steamgifts .
.
.
.
suntimeswidget .
.
.
.
syncthing .
.
.
.
average .
.
.
.
.51thanmonkeyandape.thereasonweinferredisthattheswitchingofentrytakesextracosts andsomealcsbringfewerbenefitsthan the default entry does while having a high weight.
.
bug detection ability during the app launching and exploration we record the runtime loginformationandcollectthetriggereduniquecrashes.totally faxdetected719uniquecrashes amongwhich655arelaunching relatedbugsbytriggering1303launchingcommands and64are detectedduringtheguiexplorationofapps.asacomparison monkey finds crashes during exploration ape finds .
intentfuzzer finds crashes by testing the original eas in apps and it finds ones by testing all activities after exposing ias into exported ones.
wecategorizethecrashesdetectedbyfaxinto errorsandwarningaccording to their triggering entries error for ea and warning for ia.
the details of these crashes are listed in table .
all the crashes triggered by ea launching and triggered by an exploration startingfromeascanbetakenasrealerrors.inthesecases anyonecanmakethetargetappcrashbysendingmalformedcommandstoea.besides wefind539crashesthatcanbecategorizedaswarnings.
these crashes are triggered on exported ias and may not harm the usage of the app actually.
a warning means the correctness of the crashpointinthecalleedependsonthequalityofthecalleractivity.
however developers suffer from the misexposure of activities which means they may misexpose activities unanticipatedly and make these warnings become attackable.
for example a bug fixing by the developer of etesyncis to turn the ea accountactivity into an ia which means there is a misexposed activity.
so wetake these crashes triggered on ias as potential bugs and warn developers earlier.
table category of crashes detected by fax.
faxlacrashes entrynormal objectfaxexsum error eas warning ias sum acts the distribution of exception types is shown in fig.
.
the classnotfoundexception isthe mostcommonone whichmeans thetargetclasscouldnotbeloaded.the badparcelableexception happenswhenanactivityreceivesanunexpectedobjectvalue.if 256numberformatexceptionillegalstateexceptionruntimeexceptionillegalargumentexceptionothernullpointerexceptionbadparcelableexceptionclassnotfoundexception error warning figure detected unique crash distribution 465table feedbacks of issues about activity launching crashes.
project starsize bugissue id status fixing revision reason ankidroid 20258m25401 fixed 2c890c1 inadequate check antennapod 24297m23304 fixed f5956bc misexpose conversations 329110m fixed 011bdd8 inadequate check etesync 964m184 fixed d1d0865 inadequate check inaturalist 5421m fixed cc4a44e inadequate check k9mail 45124m34160 fixed 4886f2f 4815a2f 16535af inadequate check padland 332m354 fixed d9709eb inadequate check passandroid 4813m4228 fixed b81f79d inadequate check suntimeswidget 686m14353 fixed 4a6d761 2efe94a inadequate check synthing 115826m fixed c762c18 inadequate check thecarriedobjectcannotberesolvedbythecallee thetargetactivity will crash.
another top exception is nullpointerexception which means the absence of input checking occurs frequently.
by analyzing the composition of the crash triggering commandsbyactivitylaunching wecountthenumberoficcswithout any attribute or parameter null and with only basic attribute basic .as wecan seeintable .
crashes aretriggered with emptyicc while8.
needspecificbasicattributeandupto81.
containextraparameters.foriccsthatcontainextraparameters we count the number of iccs with primary parameter only primary with bundleitem bundle aswellaswith serializable or parcelable objectitem object .about67.
commandscontain objects whichmeansobject carryingcommandscaneasilycrash an app.
in our experiment the longest crash triggering test case requiressixnon nullattributes includingonebasicattributeand five extra parameters.
table type of icc message that trigger crash type nullbasicprimary bundle object number ratio .
.
.
.
.
wepick46crashesthatcanbetriggeredbylaunchingeaand commit issues about them on github.
the committed bugs are picked for three reasons we only select the crashes that aretriggered by launching ea we only submit the normal typecrashes which can be triggered by test cases that do not carry complex objects to make the bug confirming easier we exclude theappsthatdidnotupdatewithinoneyear.amongthe46reported crashes 33havebeenconfirmedandfixed.theresultsareshown in table in which the issues without the developer s reply aredropped out.
for apps ankidroid andpassandroid we open pull requests for bug fixing according to developers requirements and thedevelopershaveconfirmedthesefixing.otherbugsarefixedby developers in which two bugs in app antennapod were fixed in a recently released version before our report.
the developer ofproject suntimeswidget repliedthatthe intentresolving was pretty much untestedbefore andthey decidedto addtest casesto avoid this problem.
threats to validity internal validity there are two internal threats in our approach false positive of ia related bugs and weight assignment.the first threat relates to the false positive of the bug detection on ias.
if the exported activities are taken as the testing entries all detected activities are real bugs that can be exploited by attackers i.e.
allidentified errorsaretruepositives.inourapproach todetectmorehiddenbugs weallowfaxtotakeinternalactivitiesas testingobjects.thetestingofinternalactivitiesismorelikelytobe unit testing.
without analyzing icc flows and tracking all the constraints of the input data faxsupposes that any input received by internal activities is reasonable which may contain invalid values.
forwarnings wewillconductfurtheranalysistoautomaticallyget the number of true positives e.g.
make a forward tracking of each received value to figure out the data sources and constraints.
another threat relates to the accuracy of the weight assignment.
foractivitylaunchingtesting moreentriescanexploitmorepossiblebugs butinexploration thelow qualityentrywilldecrease the total coverage.
in tool fax we evaluate the importance of each entry based on the dynamically constructed atg and use heuristic strategiestofilterouttheentrieswithlowerimportance.theexploration weight calculation depends on the accuracy of atg and the dynamicexecutiontraces.generally itisdifficulttoidentifyallthe transitions statically and judge whether the transition is available ornotbypurestaticanalysis.wecomplementthestaticatgby dynamicexploration however westillcannotguaranteethefairnessoftesting.butwemakeeffortstorecalculatetheexploration weight among alcs by multiple rounds and try to optimize the weight assigning process adaptively.
externalvalidity threatstoexternalvalidityrelatetothegeneralizability ofour experimental results.our study islimitedto theevaluatedandroidappsandourresultsmaynotgeneralizebeyond the evaluated apps.
related works in this section we will briefly introduce representative works that are related to the gui exploration icc analysis and intent fuzzing techniques in recent years.
gui exploration there are many kinds of gui testing approaches for android apps including random model based andsystematic testing techniques.
wang et al.
propose a description frameworktodemonstratethekeyissuesinautomatictest input generation .inrandomtesting thetesteventswillbegenerated randomlywithlesscareofthecurrentstateoftheappundertest.
monkey is one of the most widely used black box random testing tools.
it is a simple and fully automatic tool that can generate alot of test events within a short time.
there are works based on 466monkey for detecting gui bugs and security bugs .
several researches construct the models to guide their exploration process .
s. yang et al.
provided a model calledwindowtransitiongraph withanaccuratestaticcallback analysis.
su et al.
proposed a model based approach recently which uses both dynamic and static analysis with a weighted ui explorationstrategy.andtheyrandomlyinjectsystem levelevents like sending null intent to trigger more bugs.
however they extracteventsaccordingtothedeclarationoftagintent filterinthe manifest .systematictestingtechniques areappliedin more complicated circumstances e.g.
automatically finding event sequencesthatreachagiventargetlineintheapplicationcode.our work focuses on gui exploration but we do not limit to one exploration strategy.
we concentrate on starting the exploration frommultiple entries and with various alcs.
during the exploration any event picking strategy can be integrated.
intentfuzzing.
someresearchersadoptfuzzingtechnique tofindoutthepoorlydesignedexportedcomponents whichalso need to simulate the proper alc.
for example tool null intent fuzzer sendsintentswiththeonlyinputdata null.andtool droidfuzzer focusesonactivitiesthatprocess mimedata e.g.
video passed via an uri.
besides maji et al.
presents thefirstempiricalevaluationoftherobustnessoficcinandroid through fuzz testing methodology.
however when fuzzing explicit intents they use straightforward strategies such as semi valid actionanddata blankactionordata randomactionordata as well as random extras which may generate a large number ofredundant test cases.
in its experiment around intents will be sent to test an activity while we use less than ten test cases in our approach.toavoidtheaimlessexplorationwithinvalidparameters these works adopt the configuration directed testing approach.
they aim at the original exported components that have an xml formed declaration in manifest which is providedby the androidsystemforappconfiguration.however therearesevere mismatchesbetweentheattributedeclarationandtheiractualusageaccordingtoourstudy.someoftheiccparameterscanonly be obtained in code but not the manifest file.
another tool intentfuzzer isdevelopedusingsomestaticanalysistechniqueswith thegoaloftriggeringbugs whichissimilartoouractivitymodeling.
however they directly leverage flowdroid a static analysis tool designedforprivacyleakdetection toextractthekey typepairsofextraparameters.so theycannothandlelarge scaleandroidapps.
besides their approach has the inherent weakness from fuzzingthat the number of test cases is very large while we avoid this problem by path sensitive attribute usage analysis.
iccextraction.
someworksaimatextractingiccinformation forexample theresearch proposedcoallanguage tomodel the icc messages and apply the coal solver to infer android icc values.
in this work they implemented a practical tool called ic3.recently someresearchers conductresearchesbasedon it.
however ic3doesnot provide theattribute usageinformation oficcanditisunabletogeneratealcs.besides itobtains basic attributes frommanifest files which is not accurate enough.
in ourapproach weadoptalight weightintentanalysismethodin this paper to obtain the information needed.
string analysis.
as a widely used type in android apps the stringisalsowidelystudiedbyrecentworks.rasthofer etal.
presents a framework for automatically generating an android executioncontexttotriggermaliciousbehaviors inwhichstring informationshouldbeinferredcorrectly.toaccomplishthis they give several string value providers.
the constant value provider theyusedgathersallthestringconstantsascandidatesforruntime valueswhichcompareagainstconstants whichwillincreasethe burden oftesting whilethe dynamically computed valuesare not taken into account.
in our work to find out candidate values for icc relatedattributesprecisely wecapturethedatapropagation to obtain the actually used constant candidates and model the icc related string apis to calculate the dynamic operated ones.
symbolic execution symbolic execution is a useful program analysistechniquethatcansimultaneouslyexploremultipleprogram paths with various execution contexts.
however the analysis suffers from path divergence without simulating the behavior of androidlibraries.toverifyandroidappsprecisely merweet.al.extend jpf to jpf android .
they model core libraries in the android framework semi manually and symbolically execute apps on java virtual machine.
gao et al.
then proposed a dynamic symbolic execution engine for android apps which automatically synthesizes libraries without manual modeling.
our approach also adopts a symbolic execution like analysis and collects path con straints about icc attribute variables.
concentrating on the icc attributesmodeling wedonotperformanalysisoncompletepaths but drop the icc attributes parameters irrelevant information.
conclusion inthis paper we aimto breakthe unevenactivity coveragein the exploration of android apps and try to test each activity in variouslaunchingcontexts.wefirstinvestigatethelaunchingprocessofac tivitycomponent thenperformaninter procedural flow contextand path sensitive analysis to build activity launching models and generate complete launching contexts.
besides we proposed an adaptive explorationframework thatreassigns eventsto multiple entriestoenhancetheexplorationability.thekeychallengeslie in how to handle various icc attribute characteristics to construct proper contexts as well as how to calculate the exploration weight of each entry in each round.
we implemented our approach in atool called fax with an activity launching strategy fax laand an exploration strategy fax ex.
the experiments on real world apps showthatfaxbehaveswellbothinthein depthexplorationand the context aware activity launching testing.
in the future we will try to identify the trigger paths of ia related crashes automatically to make the bug confirmation easier.