chord towards a unified detection of blockchain transaction parallelism bugs yuanhang zhou zhen yan yuanliang chen fuchen ma ting chen and yu jiang bnrist tsinghua university beijing china university of electronic science and technology of china chengdu china abstract blockchain systems have implemented various transaction parallelism mechanisms to improve the system throughput and reduce the latency.
however they inevitably introduce bugs.
such bugs can result in severe consequences such as asset loss double spending consensus failure and ddos.
unfortunately they have been little analyzed about their symptoms and root causes leading to a lack of effective detection methods.
in this work we conduct a thorough analysis of historical transaction parallelism bugs in four commercial blockchains.
results show that most of them arise from mishandling conflicting transactions and manifest without obvious phenomena.
however given the heterogeneity of blockchains it is challenging to trigger conflict handling in a unified way.
effectively identifying these bugs is also hard.
inspired by the findings we propose chord aiming at detecting blockchain transaction parallelism bugs.
chord proposes a unified conflict transaction model to generate various conflict transactions.
chord also dynamically adjust the transaction submission and inserts proactive reverts during transaction execution to conduct thorough testing.
besides chord incorporates a local remote differential oracle and a tps oracle to capture the bugs.
our evaluation shows that chord successfully detects transaction parallelism bugs.
besides chord outperforms the existing methods by decreasing the tps by .
and increasing the latency by .
showing its effectiveness in triggering various conflict scenarios and exposing the bugs.
i. i ntroduction today the performance of traditional blockchain systems struggles to keep up with the growing throughput demands.
specifically for time sensitive applications like stock exchange the throughput and latency of blockchain systems have consistently presented a primary bottleneck.
to address this problem early in ethereum has introduced danksharding in its roadmap to enhance the tps.
however the full implementation is still years away .
hyperledger fabric parallelizes all transactions and discards conflicting ones after validation but still exhibits low performance due to many invalid transactions .
therefore recently emerged commercial blockchains have established various transaction parallelism mechanisms .
they schedule the parallel transactions based on their interdependencies to ensure safe and effective parallel execution.
for example fisco bcos conducts dag analysis to identify the conflict transactions and proposes a dmc scheduler to parallelize non conflict ones.
however these transaction parallelism mechanisms inevitably introduce bugs.
we name the bug as tpb short yuanhang zhou and zhen yan contributed equally to this work.
fuchen ma and yu jiang are the corresponding authors.fortransaction parallelism bug .
tpbs compromise the performance deviating from their design intentions.
moreover they lead to severe consequences such as asset losses ddos etc.
for example solana schedules the rent collection transactions by dividing the requested ranges into partitions and executing them in parallel.
however it did not check the conflicts between the ranges.
on jun when transactions accessed overlapping ranges the unsafe parallelism resulted in collecting rent from the same account twice leading to asset losses.
unfortunately tpbs have not been sufficiently analyzed and detected.
to better understand tpb we conducted a thorough study on historical tpbs in four widely used commercial blockchains with transaction parallelism mechanisms including fisco bcos sei solana and aptos .
we found that 1 82. of the tpbs arise in the conflict transaction handling process.
blockchains are errorprone when analyzing and scheduling trasnactions accessing composite data types.
besides unexpected transaction reverts and exceptions usually result in tpbs.
2 the tpbs bring catastrophic but inconspicuous consequences.
of them result in incorrect execution outcomes which can lead to asset losses.
the others result in an unexpected decrease in throughput triggering ddos attacks or even system crashes.
existing works cannot detect tpbs effectively.
traditional concurrency bug detectors cannot detect tpbs because they focus on scheduling threads to trigger data races.
but tpbs arise from bugs in transaction parallelism mechanisms and require parallel conflict transactions to trigger them finding 1 .
for transaction generation tools fluffy sends sequential transactions and checks the consistency among nodes.
evmfuzzer and evmlab mutate the smart contracts and generate a single transaction.
tools for front running vulnerability generate transaction sequences accessing profitable variables.
however sequential transactions or a single transaction cannot trigger conflict handling process finding 1 .
besides some tpbs hold unique triggering conditions on the transaction submission and execution stage finding 1 which are ignored in existing works.
furthermore the non determinism of parallelism introduces unique challenges for capturing tpbs so there are no well defined oracles for tpb scenarios finding 2 .
the first challenge is how to trigger the conflict handling effectively for various transaction parallelism mechanisms.
according to our finding 1 most of the tpbs arise in conflicthandling processes.
but the diversity of the blockchain structures and mechanisms make it challenging to cover various conflict scenarios in a general way.
furthermore transactions may be interrelated in different ways.
some of them access the same shared objects.
others hold indirect dependencies.
exceptions such as out of gas and runtime exceptions also lead to new conflict relations.
therefore it s challenging to generate high quality conflict transactions that can trigger various errorprone conflict handling scenarios.
the second challenge is how to effectively identify tpbs when they occur given their inconspicuous nature.
according to our finding 2 most tpbs do not manifest obvious symptoms like node crashes or panics.
in contrast they usually lead to some silent consequences such as incorrect execution results.
thus identifying such scenarios is a challenging task.
the transaction parallelism mechanisms introduce nondeterminism regarding the execution order.
besides some transactions may be forcibly reverted or discarded due to conflicts.
therefore it is hard to determine the expected results solely based on the content of the submitted transactions.
to address the aforementioned challenges we propose chord .
to resolve the first challenge chord establishes a unified conflict transaction model for triggering various conflict handling scenarios.
chord first proposes a template contract consisting of various shared resources and access operations.
based on it chord applies the conflict constructor to generate transactions with complex conflict relations.
chord dynamically adjusts the transaction submission timing to trigger conflicts more frequently.
besides chord applies the revert injector to trigger more tpb prone cases during transaction execution.
to resolve the second challenge chord adopts a local remote differential oracle to reproduce the expected results locally and identify the inconsistency of on chain results with the expected ones.
furthermore chord introduces a tps oracle to identify tpbs that lead to the abnormal throughput decrease.
in this way chord can detect tpb effectively.
we evaluated chord on four widely used commercial blockchains with different transaction parallelism mechanisms.
chord successfully detects tpbs including previously unknown ones.
in comparison equipped with chord s oracles existing tools only detect tpbs.
besides we compared chord with existing tools on the tps and latency to evaluate whether chord triggers the conflict handling processes effectively.
the decline in tps and the rise in latency imply an increase in conflicts among transactions thereby indicating a higher probability of triggering tpbs according to finding 1 .
results show that chord decreases the tps by .
.
and increases the latency by .
.
showing that chord generates high quality conflict handling scenarios and effectively triggers tpbs.
this paper makes the following contributions we studied the symptoms and root causes of historical tpbs in four commercial blockchains.
we proposed chord .chord establishes the unified conflict transaction model and two dedicated tpb oracles.
we evaluated chord on blockchains.
chord detects tpbs including previously unknown ones.
we have open sourced chord for practical usage.
ii.
b ackground blockchain is a decentralized system consisting of multiple nodes where users can deploy smart contracts containing functions that can be invoked through transactions.
transactions trigger predefined actions such as transferring funds storing data or executing logic within the smart contract.
previously transactions are executed serially by each node ensuring security and determinism but with limited performance which cannot meet the demands of high throughput applications.
to address this various transaction parallelism mechanisms have been proposed allowing transactions to be executed in parallel thereby improving throughput and reducing latency.
secure parallelism relies on identifying and scheduling conflicting transactions which occur when two or more transactions attempt to access or modify the same resource.
conflicts arise when one transaction reads and another writes to the same resource or when multiple transactions try to modify it simultaneously.
several approaches have been proposed to handle transaction conflicts.
some require users to specify all shared variables accessed by a transaction followed by static analysis to detect conflicts.
for example fisco bcos .
requires users to pre declare accessed variables and uses dag analysis to identify conflicts while solana s sealevel also asks users to specify read write relationships before submission.
other mechanisms like fisco bcos .
s dmc scheduler perform conflict analysis autonomously.
some systems such as sei employ optimistic parallelization executing all transactions in parallel and re running conflicting ones sequentially.
aptos uses blockstm to optimistically execute pre ordered transactions and resolve conflicts by rectifying memory access errors.
while transaction parallelism mechanisms significantly improve blockchain performance their implementation can introduce bugs especially when handling complex conflicting transactions leading to errors with serious consequences.
iii.
m otivating example tpb has become widespread and hard to detect.
but once occurs it can lead to severe consequences.
an example is a tpb in solana s transaction parallelism mechanism triggered in a built in module bank .
the bank tracks client accounts and the progress of on chain programs.
however this introduced a tpb.
fig.
shows the triggering process of this tpb.
when transactions interact with the bank in parallel the accounts they access may have overlaps between partitions which make them conflict.
as shown in fig.
tx1andtx2access the range of and respectively resulting in an overlap in .
performing read modify write operations to the same storage in parallel is unsafe.
unfortunately solana overlooks the check for conflicts chord at 2among these requested partitions .
in this case the actual results val 1andval 2do not match the expected results vale andvale .
therefore this tpb leads to incorrect calculation results and results in asset losses.
tx!
collect rent eagerly tx collect rent eagerly accountskey!val!key val ...key val key val key!key val ...key key val!
val val incorrectresultsaccounts conflictaccountskey!key ...key key key!key expected resultsval val!
val val val!
val incorrectresults fig.
the triggering process of the tpb in solana.
the mishandling of conflict parallel transactions leads to incorrect calculation results.
to address this tpb in solana pr developers fixed the logic of collect rent eagerly .
the code snippet is presented in listing.
.
as shown in line when the bank carries out the rent collection it first checks all the requested partitions to determine if there are overlaps between them.
if an overlap is found the signal parallel will be set to false and the conflict transactions will be executed serially in line .
if no overlap is detected the previous logic of parallel execution is maintained in line .
from this case we learn that tpbs usually lie in conflict handling processes which require conflict transactions to be triggered.
tpbs can result in incorrect execution outcomes requiring specifically designed oracles.
unfortunately there is no existing work that can detect such tpbs.
traditional concurrency bug detectors for distributed systems cannot generate transactions and trigger parallel scheduling.
fluffy evmfuzzer and evmlab generate single or sequential transactions for testing.
existing works for front running attacks generate profitable transaction sequences.
however they cannot generate various conflict transactions and frequently trigger transaction parallelism.
in this example they cannot generate conflict transactions that access the buggy function with overlapping ranges.
besides their oracles cannot deal with the non determinism of parallel execution therefore cannot identify this tpb.
to address these challenges we propose chord .chord establishes a unified conflict transaction model to generate conflict transactions.
in this case chord establishes the template contract that includes the self defined module bank and provides specialized access approaches collect rent eagerly .
then chord generates conflict transactions with overlapping ranges for rent collection.
chord controls the submission qps to frequently trigger conflicts.
besides by reproducing the expected results based on the transaction receipts chord identifies the incorrect on chain results and captures the tpb.
iv.
o verview of transaction parallelism bug to understand the features of tpbs and inspire subsequent detection we conduct an in depth study on real world tpbs.
fn collect rent eagerly self ... let thread pool ... thread pool.install ... if parallel let ranges partitions.iter ... outer for i in ..ranges.len for j in ..ranges.len if i j continue check the overlapif i.contains j.start i.contains j.end parallel false break outer if parallel collect in parallel if !parallel collect in serial ... bug here directly execute in parallel bug fix check the overlap firstlisting.
the code snippet of the tpb solana pr .
the tpb was introduced when parallelizing the execution of partitions in line .
line fixed it by checking the overlaps between partitions.
we now present our study methodology and our findings.
a. study methodology we conduct rigorous empirical analysis following the opencoding method.
our study goes through the following steps .
data collection we collect the tpbs from the widely used blockchains with various transaction parallelism mechanisms including fisco bcos sei aptos and solana.
we select tpbs from issue trackers and pull requests of the targeted blockchains.
we filter out the valuable items containing keywords parallel schedule conflict the specific name of the parallelism mechanism dmc for fisco bcos sealevel for solana optimistic parallelization for sei block stm for aptos in their titles and contents.
we refine the selection by retaining items involving assignees and tags like bug security etc.
finally we obtain items.
.
data familiarization for each collected item we extract the existing information provided in its issue or pull request description to further decide if it is a tpb.
totally we identify tpbs from fisco bcos from sei from solana from aptos .
tpbs have provided information of attack vectors.
tpbs descriptions reveal their symptoms.
this helps us determine the basic nature of each tpb laying the foundation for further analysis.
.
initial coding in this step we deeply examine the source code and fix commits to gather more detailed information.
for tpbs that have existing descriptions we study the buggy code and patches to verify the root cause.
for tpbs missing information we directly analyze the source code to investigate their root cause and potential consequences.
.
categorization we proceed to systematically classify the tpbs into distinct categories based on their observable symptoms and behaviors.
the categorization allows us to identify the patterns and commonalities among various tpbs facilitating the subsequent analysis on the common triggering conditions.
specifically we categorize the tpb symptoms into two main types those that lead to incorrect execution results and those that affect system performance .
.
hypothesis formation finally we identify and count the root causes across various tpbs.
we focus on the affected variables the components where tpbs occur and the execution stages in which they appear.
through statistical analysis we identify most common triggering conditions to guide subsequent detection.
for special cases we also conduct a detailed analysis to ensure comprehensive study.
b. symptoms to study how to capture tpbs we conduct an in depth study on their symptoms.
results show that tpbs are often inconspicuous and cannot be easily observed.
however they can lead to severe consequences.
tpbs result in incorrect execution outcomes.
after confirming the transactions the states reached by the blockchain are not consistent with the expected states.
specifically they lead to the error calculation of balances gas price certification verification and other global variable status .
for example solana pr is triggered by two conflicting transactions with overlapping ranges on the rented accounts.
solana s transaction parallelism mechanism fails to identify the conflict conditions falsely parallel the execution and finally leads to collecting rent from the same account twice.
this tpb causes double spending attacks which pose threats to the asset safety.
besides fisco bcos issue is triggered by massive parallel conflict transactions simultaneously modifying the account balance.
under high workload the blockchain fails to successfully synchronize the actual execution order and state of the conflict transactions resulting in discrepancies in user balance values across different node views.
these tpbs pose threats to the security of on chain assets resulting in asset losses double spending etc.
however these symptoms do not lead to evident phenomena such as crashes.
therefore without a dedicated oracle capturing these tpbs is challenging.
besides tpbs affect the system performance even making the blockchain unable to process transactions.
it is usually manifested by an abnormal decline in the blockchain s tps transactions per second or the abnormal increase in the latency.
some tpbs such as sei pr and solana issue29895 are caused by mishandling of plenty of parallel conflicting transactions.
the parallelism mechanisms falsely schedule the transactions leading to a large number of transactions being dropped or cannot be processed.
they ultimately cause the blockchain system to remain in an incorrect transaction execution state preventing it from processing any subsequent transactions.
besides solana issue arises because the blockchain s transaction parallelism mechanismfails to consider the resource consumption when handling parallel transactions.
overloaded transactions ultimately lead to the exhaustion of cpu or memory resources.
these tpbs destroy the liveness of blockchain and may result in ddos attacks.
c. root causes to trigger tpbs we conducted a thorough investigation on the root causes and triggering conditions of real world tpbs.
below we present our findings.
trigger most tpbs are triggered by parallel conflict transactions accessing composite data types.
based on our study tpbs require conflicting transactions to be triggered.
the blockchain s transaction parallelism mechanism requires careful design across various execution stages of conflict transactions including conflict detection transaction scheduling execution and error handling.
these complex mechanisms inevitably introduce implementation bugs that lead to tpbs.
specifically out of tpbs occur when blockchains fail to correctly identify conflicts and schedule conflict transactions.
additionally out of tpbs are caused by insufficient checks and handling of runtime exceptions during the transaction scheduling process leading to robustness issues.
furthermore out of tpbs are triggered by improper handling of reverts during the execution of conflict transactions resulting in deadlocks or incorrect updates of execution results.
furthermore we found that such tpbs are always triggered by conflicting read write on composite data types such as pre defined classes structures mappings or external contracts.
this is because they exhibit more intricate read and write operations.
for example fisco bcos issue fisco bcos pr fisco bcos pr are all triggered by conflicting read or write operations on kvtable objects which is a pre compiled class that holds specific functions.
solana pr also arises in a self defined class object bank.
access operations on these composite variables are intricate involving multi level function calls and collaborative actions.
consequently accurately identifying conflicts is more challenging for them.
some other blockchains are implemented in rust or move which have the nature to ensure thread safety.
however they are also vulnerable to complex conflicting scenarios.
for example sei pr and sei pr are triggered by the mishandling of conflicting transactions leading to unexpected non determinism in the execution results.
several tpbs require special triggering conditions.
tpbs are triggered by consensus failure resource misallocation and incorrect configuration together with the conflict transactions.
the remaining are triggered by extensive parallel transactions without the need for conflicts.
trigger most tpbs arise during conflict handling and exception handling in transaction execution process.
we studied the scenarios where tpbs occur and found that unexpected runtime exceptions and transaction rollbacks during conflict handling are highly prone to triggering tpbs.
4under these conditions blockchains need to modify the scheduling status of transactions or provide error handling approaches.
however these processes are prone to tpbs.
sei pr410 is triggered during rollbacks when sei incorrectly reverts only the execution result without reverting the version number of the related shared variable.
consequently subsequent conflicting transactions are unable to perform further operations on that variable.
similarly in fisco bcos pr data synchronization exceptions resulted in inconsistencies in block hashes.
the rest tpbs stem from conflict analysis.
some parallelism mechanisms fisco bcos solana conduct conflict analysis upon receiving transactions.
this process is complex and prone to tpbs.
for example fisco bcos pr fisco bcos pr and solana issue are all due to the inability to identify conflicting transactions and schedule them appropriately.
besides some tpbs require other special triggering conditions like consensus failure resource misallocation and incorrect configuration.
v. d esign fig.
shows the framework of chord .chord incorporates novel designs for triggering and capturing tpbs.
chord first proposes a unified conflict transaction model.
it designs a template contract which contains various types of shared resources as conflict variables and their access operations.
then chord applies the conflict constructor to generate transactions with various conflict relations.
it also employs a revert injector to trigger tpb prone exception handling situations during transaction execution.
chord proposes two dedicated oracles for tpbs a local remote differential oracle and a tps oracle which address the non determinism introduced by parallelism and effectively capture tpbs.
conflict transaction model templatecontractsharedresourcesaccessoperationstransactiongenerationconflictconstructorrevertinjectorblockchain clusternodenodenodenodetpb oracletps oracletpscalculationthresholdchecklocal remote differentiallocalreproducingresultsdifferentialparallelexecutionconfirmreceiptst!t t ... ... fig.
the overall framework of chord .chord proposes the unified conflict transaction model to trigger tpbs and establishes two dedicated oracles to detect tpbs.
a. unified conflict transaction model to trigger tpbs chord designs the unified conflict transaction model.
building upon our findings in section iv c we design the template contract incorporating various conflict resources and their corresponding accessing operations.
leveraging this template contract we generate various composite functions to create high quality conflict transactions and errorprone conflict handling scenarios effectively triggering tpbs.
template contract in blockchain transactions trigger the execution of smart contracts to interact with the blockchain system.
therefore a template contract is first required.
the contract serves as the interface for transactions to interact with the underlying blockchain transactions parallelism mechanisms.
it defines a series of functions to access on chain resources which are available for transactions to invoke.
to generate various conflicting transactions and effectively test the transaction parallelism mechanisms the template contract should encompass a range of conflict variables and essential functions for accessing them.
fig.
shows the composition of the template contract.
first it contains various shared resources including primitive data types such as integer address etc.
besides it contains composite data types that are more prone to tpbs.
specifically chord defines the mappings and arrays based on primitive data types.
chord also constructs more complex resources such as self defined structures and classes.
for blockchains containing pre compiled contracts chord initiates them to create corresponding resources.
second the template contract involves access operations for operating the shared resources including data retrieval such as read simple arithmetic calculations such as add and assignments.
for complex data types with specialized access approaches such as self held methods and external contracts chord offers functions that invoke them.
multiple access operations may access the same variables.
the template contract is generic for various blockchains.
currently chord has implemented the template contract in rust move and solidity.
therefore for blockchains supporting these contract languages the template contract can be directly applied.
for blockchains with other language contracts chord extends the template contract by instantiating it into other languages without modifying the content and structure.
template contract resources vi int vj address vp mapping vq structure vr class... ...primitive types composite types operations read i get the value of the resource add i val arithmetic calculation set p key newval new value assignment other r ... specialized access approaches...vk precompiled class template contract resources vi int vj address vp mapping vq structure vr class... ...primitive types composite typesoperations read i get the value of the resource add i val arithmetic calculation set p key newval new value assignment other r ... specialized access approaches ... vk contract test contract a resources vi int vj address vp mapping vq structure vr class... ...primitive types composite types operations read i get the value of the resource add i val arithmetic calculation set p key newval new value assignment other r ... specialized access approaches...vk contractcomposite functions func tx1... vi.add vr.set vp.read func tx2... vp.set vq.set revert vr.other func txqps... vq.set vi.read vq.add template contract generated functions tx1 contract a function func tx1transactions ... tx2 contract a function func tx2... txqps contract a function func txqps... ... ... fig.
the process of chord generating conflict transactions.
the test contract is composed of the template contract and composite functions.
chord generates transactions by calling the composite functions.
conflict transaction our findings in section iv c indicate that blockchains are prone to tpb when processing conflict transactions and when unexpected reverts occur.
therefore chord first applies the conflict constructor to generate transactions with complex conflict relations.
it then adjusts the transaction submission qps based on the runtime 5system status to increase the frequency of conflicts.
chord also proposes the revert injector to inject proactive reverts during execution.
therefore chord thoroughly examines the resilience of the transaction parallelism mechanisms.
fig shows the details of how chord generates the test transactions.
the test contract ais composed of the template contract and generated composite functions.
in a test round chord instantiates the template contract to generate a number of composite functions including func tx1 func tx2 ... func txqps.
they are constructed using the conflict constructor and the revert injector consisting of a series of access and revert operations.
the conflict constructor distributes various access operations that access the same shared variables into different composite functions thereby creating conflict relationships.
for example the vq.set infunc tx2 andfunc txqps are potentially conflict.
besides the revert injector randomly inserts proactive revert operations among the access operations to trigger the exceptions during execution.
specifically when a transaction calls func tx2and reaches the revert operation its execution will directly stop and revert triggering the exception handling process of the transaction parallelism mechanisms.
the number of the access operations within the composite function depends on the gas limit of the targeted blockchains and can be customized.
each transaction calls one of these composite functions.
for example tx1calls func tx1in test contract a thus it will executes the access operations defined in func tx1.
chord generates a bunch of transactions for a test round and controls the timing and frequency of transaction submission dynamically.
the query per second qps of chord is initially based on the actual transactions per second tps of each target blockchain.
subsequently chord gradually increases the qps until the system s tps stabilizes.
this qps value deliberately triggers the blockchain s transaction parallelism mechanisms maximizing the probability of triggering conflicts thus making it more likely to expose tpbs.
txb vc.addvd.setve.read...txf txghi ve.setvd.othervj.set...vj.setvj.addvc.read... ... txb vc.addvd.setve.read...txf txghi ve.setvd.othervj.set...vj.setvj.addvc.read... ... revert a conflict constructor b revert injector fig.
chord applies the conflict constructor to create complex conflict relations among transactions and applies revert injector to trigger error prone exception handling scenarios.
conflict constructor.
tpbs usually occur when the transaction parallelism mechanisms deal with conflict situations.
therefore chord establishes the conflict constructor to generate various forms of conflict situations in real production.
fig.
a shows the conflict relations of the transactions generated in fig.
.
tx1sets the value of vr a self defined class object.
meanwhile tx2invokes the internal functions defined in the class which also modifies vr.
therefore tx1 andtx2conflict with each other requiring the blockchain toidentify the conflicts and handle them appropriately.
similarly the set operation of vqintx2also conflicts with the set and add operations of vqintxqps.
revert injector.
the findings in iv c show that tpb usually arises when the transaction execution faces exceptions such as unexpected reverts which affect the scheduling of conflicting transactions.
therefore chord introduces a revert injector to test the robustness of the parallelism mechanisms under these exceptions.
fig.
b demonstrates the effect of revert injector.
at the point that tx2finishes vq.set chord deliberately interrupts the execution by injecting proactive reverts resulting in the rollback of tx2.
this operation disrupts the current conflict relations resolving the conflict between tx1andtx2.
meanwhile the conflict between tx2and txqps still exists.
the revert injector modifies the conflict relationships among the submitted transactions prompting the re scheduling and error handling scenarios.
therefore chord can effectively test whether the transaction parallelism mechanisms can correctly manage this situation.
b. tpb oracle according to our finding in section iv b tpb often manifests without obvious phenomena making it challenging to capture them.
besides due to the non determinism introduced by parallelism existing differential oracles cannot be used for tpbs.
therefore chord proposes two dedicated oracles a local remote differential oracle to check the execution results and a tps oracle to identify liveness tpbs.
local remote differential oracle chord establishes the local remote differential oracle to validate the correctness of the calculation results.
the transaction parallelism introduces uncertain execution order.
additionally some blockchains resolve conflicts by directly reverting the execution of certain transactions.
therefore the final result cannot be determined solely based on the submitted transactions.
the differential oracles of evmfuzzer and fluffy focus on inconsistencies among evms or ethereum clients but tpbs can produce incorrect yet consistent results.
to address this issue chord utilizes the transaction receipts after finishing the transaction confirmation to determine the actual results.
specifically chord acquires the timestamps of confirmed transactions to ascertain the exact execution sequence.
then chord sequentially reproduces these transactions locally compares the local results with on chain results and identifies tpbs.
fig.
shows how the local remote differential oracle verifies the correctness of the results.
step transactions are generated and submitted for execution.
meanwhile chord records their transaction hashes step after execution chord queries the transaction receipts using the recorded hashes.
the receipts contains the status of confirmation the block hash and the index of this transaction within the block.
step based on the receipts chord accesses the blocks where the transactions were included.
by indexing chord determines the position of the transactions within the block obtaining the timestamp of confirmation.
step leveraging these timestamps chord establishes the actual execution order 6t!t t ...paralleltransactionsblockchainclusternodenodenode t!.confirm timet .confirm time...on chain results local results t t!t executionsequence differentialcomparison1.
execute3.
obtain4.
order5.
reproduce2.
query6.
comparetransaction hashesfig.
the local remote differential oracle.
chord obtains the transaction execution sequence and reproduces the result locally for differential checking.
of transactions.
step chord sequentially executes them locally to reproduce the expected calculation results.
step finally chord compares the expected results with the on chain actual results.
the differences indicate the occurrence of tpbs.
tps oracle tps transactions per second is a metric for measuring the throughput of a blockchain.
an abnormal decrease in tps signals that the blockchain has lost its normal ability to process transactions.
according to our study in section iv b tpb can manifest as an abnormal decrease in tps.
therefore chord proposes a tps oracle to continuously check the tps in real time.
therefore chord effectively captures tpbs that harm the performance of the blockchain.
unlike traditional sequential execution some parallelism mechanisms forcely discard certain transactions to avoid conflicts when parallelizing the execution.
therefore not all transactions will be confirmed successfully.
existing methods for calculating tps require the confirmation time for all the submitted transactions and cannot be applied to chord .
therefore chord proposes the definition of tps under the parallelism execution scenarios as follows tps num maxnum i txsi.ft minnum i txsi.st chord calculates the blockchain s tps after finishing the current batch of transactions.
the numerator num represents the total number of transactions that are submitted including both successful and failed transactions.
in the denominator txsi.ftrepresents the finish time of transaction i. iftxsi is successfully confirmed the txsi.ftrefers to its confirmation.
if txsiis failed txsi.ftrefers to the timestamp in its receipts.
therefore maxnum i txsi.ft refers to the latest finished transaction.
txsi.strefers to the submission time of txsi.
since that chord needs to control the qps the test transactions are not submitted at the same time.
therefore we useminnum i txsi.st to decide the earliest submission time.
in real world production fluctuations in tps within a certain intensity and duration may be recoverable.
when some transactions are not finished properly it is hard to determine whether there is an error or a normal delay.
therefore to avoid false positives and false negatives chord establishes a threshold for the tps decrease ratio to identify tpbs.
chord records the initial tps value at the testing qps as the baseline.during the subsequent testing under the same qps if the tps decreases by over the threshold compared to the baseline and remains unrecoverable chord flags it as a tpb.
in our production environment the threshold is set to for fisco bcos for sei for solana and for aptos.
how chord finds the optimal threshold for each blockchain will be discussed in section vii a in detail.
c. implementation we implement chord on widely used commercial blockchains with transaction parallelism mechanisms including fisco bcos version .
.
sei version .
.
solana version .
.
and aptos version .
.
.
fisco bcos is developed in c supporting solidity for programming smart contracts.
sei is implemented in go supporting rust and solidity for smart contracts.
solana and aptos are both implemented in rust.
solana supports rust c and c for developing smart contracts while aptos uses move.
the implementation shows that chord is a crosslanguage and cross platform tool.
remote procedure call rpc nodesqpscontroller software development kit sdk frameworks templatecontractconflicttransactionmodeldeploytpboraclesoutput processorsubmitconfirmation seqon chainresultstransactionreceiptsworkload generatortxhashrecorder fig.
the implementation of chord .chord interacts with the blockchain through rpc nodes and sdk.
the txhash recorder records the transaction hashes and the qps controller controls the timing of submission.
the hashes are used for querying receipts and on chain results for tpb oracles.
figure outlines the implementation of chord .
for each targeted blockchain chord sets up a node local cluster.
to enhance scalability and streamline development chord encapsulates rpc operations within an sdk framework offering well defined interfaces for interaction.
chord first creates the template contracts and generates transactions based on the unified conflict transactions model.
a txhash recorder logs transaction hashes for later receipt retrieval while a qps controller manages the timing and rate of transaction submissions.
transactions are submitted through the sdk triggering parallel scheduling and execution.
after the execution chord utilizes an output processor to retrieve the execution results for oracle verification.
leveraging recorded transaction hashes chord fetches transaction receipts and on chain calculation results via sdk queries.
they are then used for local remote differential oracle and tps oracle.
7vi.
e valuation we evaluate chord on four widely used blockchains with transaction parallelism mechanisms including fisco bcos sei solana and aptos .
in section vi b we study the tpbs found by chord to show chord s capability in detecting real world tpbs.
in section vi c we assess the tps and latency of chord to show that the unified conflict transaction model contributes to triggering tpbs by generating various conflict scenarios.
in section vi d we compare chord with the existing testing methods to show that chord outperforms them in detecting tpbs.
we address the following research questions rq1 ischord effective in detecting tpbs in real world commercial blockchain systems?
rq2 how does the unified conflict transaction model of chord contributes to effectively triggering tpbs?
rq3 how does chord outperform the existing testing methods in detecting tpbs?
a. evaluation setup environment.
we set up a node local cluster for each blockchain.
for detecting new tpbs we ran fisco bcos version .
.
sei version .
.
solana version .
.
and aptos version .
.
.
for reproducing historical tpbs we ran the corresponding versions.
we conduct our experiments on an ubuntu .
.
system with the linux kernel version .
.
running on a bit physical machine.
the machine is equipped with cpu cores amd epyc core processor and tb of memory.
metrics.
we propose three metrics for evaluation.
the first is the number of tpbs detected including both historical and newly identified ones.
the second is tps a standard metric for blockchain throughput.
in parallel execution lower tps indicates reduced parallelization suggesting conflicts that trigger conflict resolution.
conflicting transactions which cannot run in parallel require extra analysis and scheduling as discussed in section iv c. since directly measuring conflicts is challenging we use tps to assess the quality of conflicting transactions.
the third metric is latency the time from transaction initiation to confirmation.
like tps latency is a key metric for user perceived performance providing a full picture of the number and complexity of conflicting transactions.
b. tpbs found by chord we evaluate the tpbs found by chord to show its effectiveness in detecting tpbs.
table.
i shows the tpbs that chord detected within hour execution.
in general chord is highly effective in detecting tpbs.
chord successfully detects tpbs across four targeted blockchains including previously unknown ones in fisco bcos in sei and in aptos .
we have reported the tpbs to developers and received their responses.
among the newly detected tpbs are fixed.
is confirmed.
are still under processing.
are assigned with cve ids cve cve cve .table i the tpbs detected by chord .
targets totalrequired conflict transaction model?required tpb oracle?
yes nolocal remote differentialtps oracle fisco bcos sei solana aptos information of detected tpbs.
as shown in table i chord successfully detects tpbs in total including in fisco bcos in sei in solana and in aptos.
.
of them require chord s unified conflict transaction model to be triggered.
these tpbs manifest during the conflict handling process requiring the execution of conflicting transactions.
the rest .
can be triggered under a large number of parallel transactions.
besides all tpbs require chord s tpb oracles to be identified.
specifically .
tpbs result in incorrect execution results which require the local remote differential oracle to be detected.
.
of them lead to the abnormal reduction in tps which require the tps oracle to be identified.
among all the studied historical tpbs cannot be detected bychord .
of them fisco bcos pr fisco bcos pr fisco bcos pr manifest as incorrect return values or system logs.
other involve insufficient parallelization fisco bcos pr and systemspecific side effects solana pr .
the phenomena of them are system specific and are currently not covered by the general oracles of chord .
the rest requires byzantine behavior from malicious nodes solana issue to trigger.
chord conducts the transaction submission from the client side thus cannot trigger this special case.
the precision and recall.
we assess the precision and recall of chord on the historical tpbs.
according to the information of detected tpbs within a hour testing chord reports true positives and false negatives.
the false positives are closely related to the threshold configuration and the detailed discussion is in section vii a. when setting the threshold to for fisco bcos for sei for solana and for aptos chord reports no false positives.
therefore chord achieves the precision and recall.
severity of detected tpbs.
the tpbs detected by chord have serious consequences.
among them tpbs affect execution correctness threatening on chain asset security cause insecure access to critical storage leading to incorrect balances and lost transaction records result in balance errors during rent collection or asset transfers causing direct asset losses lead to gas fee miscalculations causing abnormal failures or extra costs and disrupt blockchain consistency including node state mismatches and user view inconsistencies potentially breaking consensus and causing transaction failures or hard forks.
additionally chord identifies tpbs that degrade system performance and liveness preventing transaction processing.
specifically cause memory leaks or resource exhaustion 8risking system collapse result in deadlocks leaving transactions indefinitely pending and cause transaction failures or rejection of new transactions.
these issues threaten both user assets and system security.
case study.
we present two cases demonstrating how chord detects tpbs.
the first is a newly discovered tpb in fisco bcos assigned cve .
this tpb caused abnormal memory leaks and eventual node crashes.
introduced before january it remained undetected due to its reliance on complex conditions and a specialized oracle.
chord identified this bug using its unified conflict transaction model and tps oracle.
in the template contract chord incorporates an external contract as an access object and provides interfaces for external contract invocation.
the external contract then implements a callback to the template contract creating a scenario where the two contracts invoke each other.
the dmc scheduler which manages conflicting transactions by pausing some to avoid conflicts failed to handle this complex interinvocation scenario correctly.
parallel transactions created by chord triggered repeated memory allocation without release causing abnormal tps drops.
as conflicting transactions persisted the issue escalated ultimately leading to node crashes.
the second case is a tpb in sei newly discovered by chord and assigned cve .
this tpb caused incorrect execution of on chain resources threatening asset security.
chord detected it using the unified conflict transaction model and the local remote differential oracle.
the template contract includes a resource mapping address to int simulating a balance storage variable along with access operations such as addition subtraction and assignment.
chord used its conflict constructor to generate transactions with conflicting accesses to this resource.
it also employed the revert injector to randomly revert transactions altering conflict conditions.
sei s optimistic parallelization failed under these conditions leading to a tpb.
within hours chord s local remote differential oracle identified inconsistencies between the on chain mapping state and the expected results.
this tpb represents a significant threat to user asset security.
c. tps and latency of chord we evaluate the tps and latency of chord to show its effectiveness in triggering tpbs.
lower tps and higher latency indicate more complex conflict handling scenarios.
based on our prior findings conflict scenarios are more prone to triggering tpbs.
therefore this metric effectively reveals the tools capability to trigger tpbs.
we propose chord a version of chord without the unified conflict transaction model.
chord directly applies the real world contracts for transaction generation without the conflict constructor and the revert injector.
we compare the tps and latency of chord and chord under the same qps to show how the unified conflict transaction model in chord contributes to the triggering of tpbs.
we set the qps values based on the actual tps of each test blockchain on our machine.
we cover ranges of qps that are both lower and higher than the actual tps to ensure the validity of our evaluation and show the trend of variation.
200040006000800010000120001400016000180002000005101520latency a fisco bcos .
.
104tps204060801001201401601802001234latency b sei50100tps 204060801001201401601802000246latency c solana50100150tps 102030405060708090100100150200latency d aptos10152025tps 100020003000400050006000700080009000100000510latency a fisco bcos1 000tps204060801001201401601802000.
.
.5latency b sei50100tps 102030405060708090100100150200latency d aptos10152025tps20406080100120140160180200246latency c solana50100tps 1200040006000800010000120001400016000180002000005101520latency a fisco bcos .
.
104tps204060801001201401601802001234latency b sei50100tps 204060801001201401601802000246latency c solana50100150tps 102030405060708090100100150200latency d aptos10152025tps 100020003000400050006000700080009000100000510latency a fisco bcos1 000tps204060801001201401601802000.
.
.5latency b sei50100tps 102030405060708090100100150200latency d aptos10152025tps20406080100120140160180200246latency c solana50100tps 1200040006000800010000120001400016000180002000005101520latency a fisco bcos .
.
104tps204060801001201401601802001234latency b sei50100tps 20406080100120140160180200024latency c solana50100150tps 102030405060708090100100150200latency d aptos10152025tps 100020003000400050006000700080009000100000510latency a fisco bcos1 000tps204060801001201401601802000.
.
.5latency b sei50100tps 102030405060708090100100150200latency c aptos10152025tps2040608010012014016018020024latency d solana50100tps 1chordchordatps tpslatency200040006000800010000120001400016000180002000005101520latency a fisco bcos .
.
104tps204060801001201401601802001234latency b sei50100tps 20406080100120140160180200024latency c solana50100150tps 102030405060708090100100150200latency d aptos10152025tps 100020003000400050006000700080009000100000510latency a fisco bcos1 000tps204060801001201401601802000.
.
.5latency b sei50100tps 102030405060708090100100150200latency c aptos10152025tps2040608010012014016018020024latency d solana50100tps 1latency chordchordatpslatencychordchordatpslatencychordchordafig.
the tps and latency of chord andchord as qps increases.
the lines represent tps and the bars represent latency.
chord decreases the tps by .
.
.
and .
and increases the latency by .
.
.
and .
.
fig.
shows the trend of tps and latency of chord and chord as the qps increases.
the blue line and orange line show the trend of tps under chord andchord respectively.
the blue bar refers to the latency under chord while the orange bar shows the latency under chord .
for each qps value we run the targets for hour and take the average value.
compared with chord chord achieves lower tps and higher latency across all blockchains.
under the highest qps where the tps and latency stabilize chord achieves .
.
.
and .
lower tps compared with chord .
meanwhile chord increases the latency by .
.
.
and .
on four blockchains respectively.
with the unified conflict transaction model chord generates more conflicting transactions and triggers the conflict handling.
the template contract aggregates various resources and access operations to generate conflict scenarios improving chord s effectiveness to trigger tpbs.
in contrast using real world contracts directly can limit conflict patterns and produce many non conflict transactions which reduces test effectiveness.
therefore the unified conflict transaction model significantly contributes to triggering tpbs.
d. comparison with existing methods in this subsection we compare chord with existing testing methods in terms of the number of tpbs they detect and the tps and latency.
comparison on tpb detection.
existing testing methods cannot effectively detect tpbs.
first without specific oracles they are unable to capture tpbs.
previous differential oracles of evmfuzzer and fluffy focus on inconsistencies among evms or ethereum clients but tpbs can produce incorrect yet consistent results.
for example in solana pr25774 clients reach consistency on the incorrect results leading to double spending.
existing works cannot identify such tpbs.
besides existing tools such as evmfuzzer evmlab and fluffy are tightly coupled with the ethereum virtual machine and do not support parallel transaction submission thus cannot be applied to recently emerged blockchains that exhibit transaction parallelism mechanisms.
to compare chord s tpb detection ability with them we re9implemented their transaction generation strategies to adapt them for our target blockchains and equip them with chord s oracles.
results show that they can only detect tpbs with in fisco bcos in sei in solana and in aptos.
lacking the ability to trigger various conflicting handling scenarios they cannot detect most of the tpbs.
in comparison chord successfully detects all the tpbs that existing methods detected and it detects more tpbs with in fisco bcos in sei in solana and in aptos.
this reveals that chord outperforms the existing methods in detecting tpbs.
comparison on tps and latency.
to evaluate the effectiveness of chord in triggering tpbs we compare the tps and latency of chord with the test suites provided by each blockchain for testing their transaction processing mechanisms.
for fisco bcos we compare chord with its official stress testing framework which can trigger its parallelism mechanisms.
for sei solana and aptos we employ their provided test contracts for transaction generation and manually customize the parallel transaction submission framework to trigger their parallelism mechanisms.
the evaluation setup is similar to section vi c. the results show that the tps under chord is lowered by .
for fisco bcos .
for sei .
for solana and .
for aptos compared with the existing methods.
meanwhile chord increases the latency by .
for fisco bcos .
for sei .
for solana and .
for aptos.
this reveals that chord effectively triggers more conflict handling scenarios for all the blockchains.
according to our finding in section iv c chord is more effective in triggering tpbs than existing methods.
200040006000800010000120001400016000180002000005101520latency a fisco bcos .
.
104tps204060801001201401601802001234latency b sei50100tps 204060801001201401601802000246latency c solana50100150tps 102030405060708090100100150200latency d aptos10152025tps 100020003000400050006000700080009000100000510latency a fisco bcos1 000tps204060801001201401601802000.
.
.5latency b sei50100tps 102030405060708090100100150200latency d aptos10152025tps20406080100120140160180200246latency c solana50100tps 1200040006000800010000120001400016000180002000005101520latency a fisco bcos .
.
104tps204060801001201401601802001234latency b sei50100tps 20406080100120140160180200024latency c solana50100150tps 102030405060708090100100150200latency d aptos10152025tps 100020003000400050006000700080009000100000510latency a fisco bcoschordchord 000tpschordchord .
.
.5latency b seichordchord 50100tpschordchord102030405060708090100100150200latency c aptoschordchord 10152025tpschordchord 2040608010012014016018020024latency d solanachordchord 50100tpschordchord1200040006000800010000120001400016000180002000005101520latency a fisco bcos .
.
104tps204060801001201401601802001234latency b sei50100tps 20406080100120140160180200024latency c solana50100150tps 102030405060708090100100150200latency d aptos10152025tps 100020003000400050006000700080009000100000510latency a fisco bcoschordchord 000tpschordchord .
.
.5latency b seichordchord 50100tpschordchord102030405060708090100100150200latency c aptoschordchord 10152025tpschordchord 2040608010012014016018020024latency d solanachordchord 50100tpschordchord1200040006000800010000120001400016000180002000005101520latency a fisco bcos .
.
104tps204060801001201401601802001234latency b sei50100tps 20406080100120140160180200024latency c solana50100150tps 102030405060708090100100150200latency d aptos10152025tps 100020003000400050006000700080009000100000510latency a fisco bcoschordchord 000tpschordchord .
.
.5latency b seichordchord 50100tpschordchord102030405060708090100100150200latency c aptoschordchord 10152025tpschordchord 2040608010012014016018020024latency d solanachordchord 50100tpschordchord1chordother chordotherchordother chordothertpstps tpstpslatencylatencylatencylatency fig.
the tps and latency of chord and existing methods as qps increases.
chord decreases the tps by .
.
.
and .
and increases the latency by .
.
.
and .
.
fig.
shows the trend of tps and latency of chord and the existing methods as the qps increases.
the blue line and red line show the trend of tps under chord and the existing method respectively.
the blue bar refers to the latency under chord while the red bar shows the latency under the existing method.
for each qps value we run the targets for hour and take the average value.
when the qps is low the differences in tps and latency between chord and the existing methods are relatively small.
lower qps indicates fewer parallel transactions smaller load pressure and fewer conflicts.
therefore the blockchain can process the transactions faster.
as the qps increases the tps ofchord significantly falls below that of the existing method.
meanwhile the latency of chord becomes noticeably higher than the latency of the existing method.
this reveals that with more parallel transactions chord creates various conflicts among them.
this triggers the blockchain to handle conflicts thereby leading to a decrease in its performance.
in conclusion compared with existing testing methods chord successfully detects more tpbs.
under the same qps chord achieves a lower tps and higher latency.
therefore chord can more effectively generate various conflict handling scenarios deeply inspect the transaction parallelism mechanism and construct triggering conditions for tpbs.
vii.
d iscussion a. the threshold of tps oracle the tps decrease threshold configuration of chord s tps oracle impacts its identification accuracy.
in blockchain systems fluctuations in tps and latency are common and can be influenced by the system s resources and network conditions.
a too strict threshold may result in many false positives.
while a too loose threshold may impact the effectiveness of detection causing the tps oracle to miss some tpbs.
table ii the false positives and true positives of chord under various tps oracle threshold configuration.
thresholdfisco bcos sei solana aptos fp tp fp tp fp tp fp tp we collect the tpbs reported by tps oracle within hours of execution on fisco bcos sei solana and aptos.
table ii shows the false positives and true positives under various configurations of the threshold.
a threshold causes many false positives across all chains but increasing the threshold reduces them.
by setting the threshold to for fisco bcos for sei for solana and for aptos chord reports no false positives.
additionally when the threshold is set to less than and respectively these chains can reveal all tpbs with no false negatives.
therefore in our evaluation environment the optimal threshold should be for fisco bcos for sei for solana and for aptos.
the proper threshold configurations for different blockchains vary due to differences in consensus mechanisms network architecture block size etc.
they also change based on production environments such as cluster scales and network delays.
b. scalability on bug types.
currently chord has proposed two oracles for detecting tpbs.
chord has been adapted to four widely used blockchains 10and found previously unknown bugs.
however in practice there are still other types of bugs such as privacy issues which also pose threats to the security of blockchain ecosystems.
for example the leakage of critical private data such as private key information can seriously endanger user security and lead to irreversible economic losses.
if extended with privacy oracle by trying to access private data and checking its visibility through transactions chord can also find privacy issues.
however the privacy perspective in blockchain varies for personal and organizational data.
although privacy rules are applicable to personal data more stringent privacy rules apply to sensitive and organizational data.
the flexibility of blockchain privacy makes it hard to design a general privacy oracle for various blockchain systems.
more works need to be explored to address this challenge.
privacy and other types of bugs deserve our attention in the future.
viii.
r elated work a. blockchain bug detection.
many existing works focus on testing blockchains.
sfuzz contractfuzzer and v gas use fuzzing to generate inputs and trigger hidden bugs in smart contract functions.
tools such as securify mythril and oyente model the control flow graph of smart contracts through symbolic execution to discover hidden vulnerabilities in smart contracts.
loki tyr and byzzfuzz mutate consensus messages to trigger byzantine attacks and test consensus protocols.
they cannot generate transactions and cannot detect bugs in the transaction parallelism mechanisms.
evmfuzzer evmlab and fluffy generate single or sequential transactions to find bugs in evm and ethereum consensus protocols.
they cannot generate parallel conflict transactions to trigger tpbs.
they also cannot adjust the qps and trigger revert during execution which are also essential for testing tpbs.
nyx zhang et al.
and torres et al.
exploits the profitable ordering of sequential transactions to detect front running vulnerabilities.
the triggering condition of frontrunning and tpbs share some similarity.
triggering frontrunning requires generating transaction sequences accessing conflict profitable variables.
however triggering tpbs has unique challenges.
first tpbs are derived from the transaction parallelism mechanisms which require conflict and parallel transactions accessing composite data types.
additionally triggering tpbs require unique designs during the transaction submission and execution stages.
chord dynamically adjusting testing qps based on blockchain runtime tps to trigger more conflict handling scenarios and inserting proactive reverts to construct tpb prone exception handling cases.
as for oracles existing differential oracles cannot be used for tpbs.
for example evmfuzzer and fluffy focus on inconsistencies among evms or ethereum clients but tpbs can produce incorrect yet consistent results across different platforms.
therefore their oracles cannot be used for capturing tpbs.
in contrast chord proposes the local remote differential oracle using transaction confirmation receipts to reproducethe actual execution order and expected results rather than manipulating the transaction order like front running attacks for differential testing.
this addresses the non determinism introduced by parallelism and effectively captures many tpbs.
b. concurrency bugs detection.
many existing works aim at detecting concurrency bugs in various systems.
taxdc classifies concurrency bugs into local concurrency lc bugs and distributed concurrency dc bugs and discusses the triggering conditions.. chess and tsvd mine lcbugs in various concurrent programs by controlling thread scheduling or monitoring the invocation of thread unsafe methods.
these lcbugs are typically caused by concurrent read write conflicts or the concurrent execution of the same operation.
dcatch and cloudraid discover dcbugs in multiple distributed cloud systems by simulating various concurrency mechanisms and message orders.
jepsen explores concurrency bugs in distributed systems by injecting random network partition faults.
these dcbugs are caused by the nondeterministic order of distributed events such as the sending and receiving of messages node crashes restarts and timeouts.
although concurrency bugs and tpbs share similarities in their triggering conditions as both are caused by conflicting access operations on shared resources detecting tpbs presents unique challenges.
concurrency bugs are caused by locking and synchronization mechanisms while tpbs arise from the transaction parallelism mechanisms that require conflict transactions accessing composite resources to trigger.
besides existing works focus on conflict transaction relations in test case generation stage.
but chord also includes specific designs in transaction submission and execution stage to construct various tpb prone scenarios.
specifically during submission chord dynamically adjusts testing qps based on blockchain runtime tps to trigger more conflict handling scenarios.
besides chord injects proactive reverts during execution stage to construct error prone exception handling logic.
ix.
c onclusion in this work we conducted a thorough analysis of real world tpbs in four blockchains to study their symptoms and root causes.
based on our findings we propose chord aiming at detecting tpbs.
chord proposes a unified conflict transaction model to generate various conflicting transactions and trigger tpbs.
besides chord applies two oracles for identifying tpbs.
chord successfully detects tpbs including previously unknown ones showing its effectiveness in detecting tpbs.
besides evaluations on tps and latency reveal that chord outperforms the existing methods in triggering tpbs.
x. a cknowledgement this research is sponsored in part by the national key research and development project no.
2022yfb3104000 nsfc program no.
u2441238 and china postdoctoral science foundation 2024m761690 gzc20240828 .
11references salem alqahtani and murat demirbas.
bottlenecks in blockchain consensus protocols.
in ieee international conference on omnilayer intelligent systems coins pages .
ieee .
aptos.
aptos core .
.
.
aptos cli v2.
.
.
robert p. bartlett and justin mccrary.
how rigged are stock markets?
evidence from microsecond timestamps.
journal of financial markets .
andrew brook.
low latency distributed applications in finance.
commun.
acm jun .
yuanliang chen fuchen ma yuanhang zhou yu jiang ting chen and jiaguang sun.
tyr finding consensus failure bugs in blockchain system with behaviour divergent model.
in ieee symposium on security and privacy sp pages .
ieee .
ckamm.
findpacketsenderstake remove parallelism to improve performance.
.
codchen.
fix race conditions detected by race detector.
f846966df1601df4a9a6f5e6994a9615167773ab .
cyson.
fix race condition when optimisticprocessinginfo is not nil.
effa090c120ab7c3337b22e049e7393ace36bae1 .
ethereum.
danksharding.
danksharding .
accessed at june .
ethereum.
evmlab.
.
ethereum.
welcome to ethereum.
.
accessed at december .
fisco.
transaction parallelism.
readthedocs.io zh cn latest docs design parallel dag.html .
fisco.
dmc deterministic multi contract parallel.
readthedocs.io zh cn latest docs design parallel dmc.html .
fisco.
fisco bcos.
.
fisco bcos.
java sdk demo.
java sdk demo .
fisco bcos.
fisco bcos release .
.
.
fisco bcos fisco bcos tree release .
.
.
ying fu meng ren fuchen ma heyuan shi xin yang yu jiang huizhong li and xiang shi.
evmfuzzer detect evm vulnerabilities via fuzz testing.
in proceedings of the 27th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering pages .
rati gelashvili alexander spiegelman zhuolun xiang george danezis zekun li dahlia malkhi yu xia and runtian zhou.
blockstm scaling blockchain execution by turning ordering curse to a performance blessing .
godmodegalactus.
transactions dropped in sig verify stage because of improper batching.
.
ryan henry amir herzberg and aniket kate.
blockchain access privacy challenges and directions.
ieee security privacy .
hyperledger.
hyperledger caliper.
.
hyperledger.
hyperledger fabric.
fabric .
accessed at december .
imtypist.
stress test checking result failed.
fisco bcos fisco bcos issues .
jdkuangxx.
after the keypage is closed the node is pressed and it is found that the node memory keeps increasing and cannot be recycled.
.
jeffwashington.
collect rent from multiple partitions in parallel.
https github.com solana labs solana pull .
jeffwashington.
parallel rent collection avoids overlapping ranges.
https github.com solana labs solana pull .
jepsen io.
jepsen.
.
bo jiang ye liu and wing kwong chan.
contractfuzzer fuzzing smart contracts for vulnerability detection.
in proceedings of the 33rd acm ieee international conference on automated software engineering pages .
jimmyshi22.
fix parallel bugs add unitest.
https github.com fisco bcos fisco bcos pull commits 20911f6fb7d6143c1a35a0bf3a23d05cbee97047 .
jimmyshi22.
fix concurrent bug.
com fisco bcos fisco bcos pull commits 333ca26b1d6bb101da3918feb7944a7633d843e8 .
jimmyshi22.
fix dmc callback core.
com fisco bcos fisco bcos pull commits 30bb41802f4b70a3659c4f8f7e1a450c5d8e2f25 .
jimmyshi22.
fix dmc transfer bug and optimize code.
e06529eb78cfa8c612742bb915e28a3be43fcfad .
jimmyshi22.
fix executor version bug fix dmc getcode block bug add drop redundant switching requests logic in executor switch.
commits eebd83276897cd72f37d21df2ec48ee10c39155a .
jimmyshi22.
fix sharding dmc scheduler bug and optimize txpool initialize process.
commits 249f71826ef31ea4f12390d2e8bb3cf8145d4a2d .
jimmyshi22.
fix some small bugs part .
https github.com fisco bcos fisco bcos pull commits 1296467de28b76e93dd7c744d0bd532a782e0469 .
jstarry.
cross program instructions may need size restrictions.
https github.com solana labs solana issues .
kyonray.
fix kv table precompiled create parallel bug mv precompiledcodec to bcos codec wrapper.
https github.com fisco bcos fisco bcos pull commits 99446dda319c1424a70ca08ef315ede02e981618 .
aptos lab.
aptos lab.
.
lcyson.
replace bach32 with accaddress in dex module .
com sei protocol sei chain pull .
tanakorn leesatapornwongsa mingzhe hao pallavi joshi jeffrey f lukman and haryadi s gunawi.
samc semantic aware model checking for fast discovery of deep bugs in cloud systems.
in 11th usenix symposium on operating systems design and implementation osdi pages .
tanakorn leesatapornwongsa jeffrey f lukman shan lu and haryadi s gunawi.
taxdc a taxonomy of non deterministic concurrency bugs in datacenter distributed systems.
in proceedings of the twenty first international conference on architectural support for programming languages and operating systems pages .
guangpu li shan lu madanlal musuvathi suman nath and rohan padhye.
efficient scalable thread safety violation detection finding thousands of concurrency bugs during testing.
in proceedings of the 27th acm symposium on operating systems principles sosp page new york ny usa .
association for computing machinery.
huizhong li yujie chen xiang shi xingqiang bai nan mo wenlin li rui guo zhang wang and yi sun.
fisco bcos an enterprise grade permissioned blockchain system with high performance.
sc new york ny usa .
association for computing machinery.
haopeng liu guangpu li jeffrey f lukman jiaxin li shan lu haryadi s gunawi and chen tian.
dcatch automatically detecting distributed concurrency bugs in cloud systems.
acm sigarch computer architecture news .
jie lu feng li lian li and xiaobing feng.
cloudraid hunting concurrency bugs in the cloud via log mining.
in proceedings of the 26th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering esec fse page new york ny usa .
association for computing machinery.
fuchen ma yuanliang chen meng ren yuanhang zhou yu jiang ting chen huizhong li and jiaguang sun.
loki state aware fuzzing framework for the implementation of blockchain consensus protocols.
inndss .
fuchen ma meng ren fu ying wanting sun houbing song heyuan shi yu jiang and huizhong li.
v gas generating high gas consumption inputs to avoid out of gas vulnerability.
acm transactions on internet technology .
madanlal musuvathi shaz qadeer thomas ball gerard basler piramanayagam arumuga nainar and iulian neamtiu.
finding and reproducing heisenbugs in concurrent programs.
in proceedings of the 8th usenix conference on operating systems design and implementation osdi page usa .
usenix association.
mythril.
mythril is a security analysis tool for evm bytecode.
https github.com consensys mythril .
tai d nguyen long h pham jun sun yun lin and quang tran minh.
sfuzz an efficient adaptive fuzzer for solidity smart contracts.
inproceedings of the acm ieee 42nd international conference on software engineering pages .
oyente.
an analysis tool for smart contracts.
enzymefinance oyente .
pgarg66.
malicious leader can flood cluster with excessive pre processed transactions.
.
sei.
sei.
.
sei.
sei is the first parallelized evm.
.
sei.
sei v4.
.
evm devnet.
tree v4.
.
evm devnet fix .
jiri simsa randy bryant and garth gibson.
dbug systematic evaluation of distributed systems.
in 5th international workshop on systems software verification ssv .
solana.
powerful for developers.
fast for everyone.
.
solana.
solana cli .
.
.
v1.
.
christof ferreira torres ramiro camino et al.
frontrunner jones and the raiders of the dark forest an empirical study of frontrunning on the ethereum blockchain.
in 30th usenix security symposium usenix security pages .
petar tsankov andrei dan dana drachsler cohen arthur gervais florian buenzli and martin vechev.
securify practical security analysis of smart contracts.
in proceedings of the acm sigsac conference on computer and communications security pages .
vita dounai.
fix the bug that in parallel mode block hash is not consistent.
4c7671f7c66655108df392a1b0a6809d94558d68 .
levin n. winter florena buse daan de graaf klaus von gleissenthall and burcu kulahcioglu ozkan.
randomized testing of byzantine fault tolerant algorithms.
proc.
acm program.
lang.
oopsla1 apr .
lu xu wei chen zhixu li jiajie xu an liu and lei zhao.
locking mechanism for concurrency conflicts on hyperledger fabric.
in web information systems engineering wise 20th international conference hong kong china january proceedings pages .
springer .
xiaoqiong xu xiaonan wang zonghang li hongfang yu gang sun sabita maharjan and yan zhang.
mitigating conflicting transactions in hyperledger fabric permissioned blockchain for delay sensitive iot applications.
ieee internet of things journal .
anatoly yakovenko.
sealevel parallel processing thousands of smart contracts.
sealevel parallel processing thousands of smart contracts d814b378192 .
junfeng yang tisheng chen ming wu zhilei xu xuezheng liu haoxiang lin mao yang fan long lintao zhang and lidong zhou.
modist transparent model checking of unmodified distributed systems.
innsdi pages .
youngseok yang taesoo kim and byung gon chun.
finding consensus bugs in ethereum via multi transaction differential fuzzing.
in 15th usenix symposium on operating systems design and implementation osdi pages .
xinhao yuan and junfeng yang.
effective concurrency testing for distributed systems.
in proceedings of the twenty fifth international conference on architectural support for programming languages and operating systems pages .
rui zhang rui xue and ling liu.
security and privacy on blockchain.
acm computing surveys csur .
wuqi zhang lili wei shing chi cheung yepang liu shuqing li lu liu and michael r lyu.
combatting front running in smart contracts attack mining benchmark construction and vulnerability detector evaluation.
ieee transactions on software engineering .
wuqi zhang zhuo zhang qingkai shi lu liu lili wei yepang liu xiangyu zhang and shing chi cheung.
nyx detecting exploitable front running vulnerabilities in smart contracts.
in ieee symposium on security and privacy sp pages .
ieee computer society .
haider dhia zubaydi p al varga and s andor moln ar.
leveraging blockchain technology for ensuring security and privacy aspects in internet of things a systematic literature review.
sensors .