rosa finding backdoors with fuzzing dimitri kokkonis micha el marcozzi emilien decoux universit e paris saclay cea list paris saclay france first.last cea.frstefano zacchiroli ltci t el ecom paris institut polytechnique de paris palaiseau france stefano.zacchiroli telecom paris.fr abstract a code level backdoor is a hidden access programmed and concealed within the code of a program.
for instance hard coded credentials planted in the code of a file server application would enable maliciously logging into all deployed instances of this application.
confirmed software supplychain attacks have led to the injection of backdoors into popular open source projects and backdoors have been discovered in various router firmware.
manual code auditing for backdoors is challenging and existing semi automated approaches can handle only a limited scope of programs and backdoors while requiring manual reverse engineering of the audited binary program.
graybox fuzzing automated semi randomized testing has grown in popularity due to its success in discovering vulnerabilities and hence stands as a strong candidate for improved backdoor detection.
however current fuzzing knowledge does not offer any means to detect the triggering of a backdoor at runtime.
in this work we introduce r osa a novel approach and tool which combines a state of the art fuzzer afl with a new metamorphic test oracle capable of detecting runtime backdoor triggers.
to facilitate the evaluation of r osa we have created r osarum the first openly available benchmark for assessing the detection of various backdoors in diverse programs.
experimental evaluation shows that r osa has a level of robustness speed and automation similar to classical fuzzing.
it finds all authentic or synthetic backdooors from r osarum in 1h30 on average.
compared to existing detection tools it can handle a diversity of backdoors and programs and it does not rely on manual reverse engineering of the fuzzed binary code.
index terms fuzzing dynamic analysis metamorphic testing backdoors vulnerability detection i. i ntroduction context.
acode level backdoor is a hidden access programmed and concealed within the code of a program.
it enables program users aware of the backdoor to feed the program with a specific input value and thus trigger a privilege escalation within the program or gain undue access to underlying system resources.
for example hard coded credentials planted in the code base of a file server application can enable maliciously logging into all deployed instances of this application in the world.
confirmed software supply chain attacks have led to the injection of backdoors into popular open source projects like php proftpd vsftpd and xz .
backdoors have also been discovered in the binary firmware of popular network routers .
graybox fuzzing is a form of automated program testing.
it relies on a search based approach to generate test inputs automatically and on simple test oracles such as crash detection and code sanitizers to detect failures automatically at runtime.
among advanced capabilities modern fuzzing tools or fuzzers like the communitymaintained afl are now equipped for testing binaryonly programs and for efficiently exploring complex branching conditions in the tested code .
these tools are currently attracting a lot of popularity and research efforts notably because of their reported ability to discover software vulnerabilities in programs.
problem.
addressing the threat of backdoors requires proper auditing of software dependencies and binary firmware.
yet this necessitates a long and painstaking manual inspection of large amounts of code so that auditing is often not performed at all .
while there has been some progress in automating backdoor detection the state of the art still suffers from the limited scope of programs and backdoors that can be handled.
in addition current detection tools still rely on manual reverse engineering of the vetted binary code.
goal and challenges.
in this work we aim at taking advantage of the capabilities of modern graybox fuzzers to automate backdoor detection.
fuzzing has indeed the potential to enable backdoor detection for a wide variety of programs and backdoors with no manual code reverse engineering.
yet while the current body of knowledge in fuzzing enables generating test inputs for a wide range of programs it does not offer any means to detect the triggering of a backdoor at runtime.
in addition benchmarking backdoor detection capabilities over multiple programs and backdoors is difficult as backdoor reports in the literature are scarce and often point to lost samples or undocumented binary firmware running on obsolete and difficult to obtain appliances.
proposal.
we introduce r osa a novel approach and tool which combines a state of the art fuzzer afl with a new metamorphic test oracle capable of detecting backdoor triggers at runtime.
the key intuition behind r osa is that for example fuzzing a backdoored file server application with incorrect credentials should always cause similar observable reactions however among the generated wrong credentials the ones that trigger the backdoor will cause a different reaction enabling the r osa oracle to detect them.
to facilitate the experimental evaluation of r osa and its comparison with existing tools we have created and made available the novel r osarum benchmark consisting of 7arxiv .08544v1 may 2025authentic backdoors coupled with diverse synthetic backdoors inserted into a standard fuzzing benchmark .
evaluation.
we run fuzzing campaigns lasting hours each using r osa on each backdoor in the r osarum benchmark.
r osa can detect all backdoors in 1h30 on average demonstrating a level of robustness and speed similar to vanilla afl for classical bugs.
the automation level is also similar to afl but r osa may produce false positives that must then be semi automatically discarded.
yet the required manual effort is limited to vetting an average of suspicious runtime behaviors detected while fuzzing like the launching of a root shell.
this level of performance primarily qualifies r osa as a good candidate to increase automation during large scale code auditing events like before deploying router firmware or software dependencies in critical infrastructures.
we compare in depth against s tringer the only competing backdoor detection tool that is available and working.
as it relies on a simple static analysis s tringer is faster than rosa but can only detect out the r osarum backdoors and produces times more false positives.
contributions.
our main contributions are a new metamorphic oracle based on a novel metamorphic relation and a fresh heuristic approach to find pairs of related inputs which makes it possible for the first time to use graybox fuzzing as a means to detect codelevel backdoors.
r osa an efficient backdoor detection method and tool which complements a state of the art fuzzer afl with our new metamorphic oracle.
r osa significantly improves the state of the art in backdoor detection by enabling the efficient discovery of a wider range of backdoors in a wider range of programs compared to what existing approaches can do and by removing the need to manually reverse engineer the analyzed binary code which existing approaches still do require.
r osarum the first openly available benchmark for evaluating backdoor detection tools as well as largest backdoor dataset ever used as per the state of the art.
data availability statement.
rosa and r osarum are available on github and are archived on software heritage .
a result replication package is available at org records .
ii.
b ackground a. code level backdoors definition and scope a backdoor in a fortified castle is an unprotected but concealed access.
it enables those who are informed of its existence to circumvent all castle fortifications and enter without effort.
by analogy a backdoor in a computer system is a hidden mechanism built by developers able to grant undue privileges to users who are informed about it.
various instances of backdoors have been reported in diverse computer systems like hardware backdoors in processors mathematical backdoors in cryptographic algorithms and data poisoning backdoors in machine learning models .
inthis work we focus on code level backdoors in classical software programs like file server applications or commandline tools.
in a nutshell code level backdoors are hidden features programmed and concealed within the program code base.
they enable informed program users to leverage a specific key input value to trigger either a privilege escalation within the program or to get undue access to resources in the underlying system.
for example the key of a codelevel backdoor can be a set of hard coded credentials in the authentication module of a web server program or a nonstandard ftp command giving root access to a file server application s underlying operating system .
occurrence in the real world at least two types of software attacks in the real world have involved the secret injection of a code level backdoor in a program.
the first type is software supply chain attacks .
the vast majority of modern software relies on thousands of thirdparty open source or proprietary dependencies and some of them come with backdoors.
injections of code level backdoors in popular open source software such as php proftpd vsftpd and xz have been reported.
in addition dubious software developers may sell proprietary components infected by deliberate or unintentional backdoors like a forgotten debug access .
the second identified type of attacks involving backdoors relates to dubious internet of things iot manufacturers .
iot devices like network or surveillance appliances typically come with embedded proprietary software called firmware driving their operations.
injecting a code level backdoor in such firmware can enable compromising millions of devices worldwide in possibly critical infrastructures.
firmware infections with backdoors have been reported for various types of routers .
detection addressing the threat of code level backdoors requires a proper auditing of software dependencies and iot firmware to ensure that they do not contain any such backdoor.
yet in practice such auditing is difficult so that it is either not done or it requires a long and painstaking code inspection by a human expert .
in particular in the case of proprietary dependencies and iot firmware the code often comes in binary only form with no access to the source code and to the development logs which are useful information to vet such software at a large scale.
while there has been progress in automating code level backdoor detection the state of the art is still limited in terms of scope and level of automation with no significant advancements in the field for more than seven years.
b. graybox and metamorphic fuzzing graybox fuzzing fuzzing was originally introduced as a specific form of automated software testing.
it aimed at finding crashes in programs like unix utilities by feeding them with randomly generated test inputs.
nowadays fuzzing is commonly understood as a more general synonym of automated program testing.
during a fuzzing campaign the program under test put is fed with a suite of test inputs produced by an automated input generator .
in parallel theruntime behavior of the put with these inputs is analyzed for traces of possible failures by an automated test oracle .
the uncovered failures are symptoms of defects in the put to be fixed before they cause harm or get exploited in case they pose a security threat.
fuzzing tools or fuzzers mainly differ by the way their input generators and test oracles work.
in recent years there has been a surge of interest in a specific family of fuzzers called graybox fuzzers which have been shown to be successful for security vulnerability detection .
graybox input generators are typically based on the principles of search based testing where the put s input space is explored using search heuristics designed to maximize the part of the put code covered by the selected inputs.
compared to pure random input generators blackbox fuzzing and to those based on precise code analyses whitebox fuzzing a.k.a.
symbolic execution graybox generators aim at finding a sweet spot between the ease and speed at which inputs can be generated and the ability to generate inputs achieving a high coverage of the put codebase.
graybox oracles usually rely on a lightweight mechanism like crash detection possibly coupled with code assertions in the put and sanitizers .
the afl graybox fuzzer american fuzzy lop afl and its community maintained successor afl are some of the most used and forked graybox fuzzers.
they rely on a mutation loop that generates new inputs by randomly mutating i.e.
slightly modifying some of the inputs generated during the previous iterations.
more precisely as the newly generated inputs are fed to the put those that improve the coverage of neglected parts of the put code base are saved as seed inputs orseeds .
only those seeds are then considered for mutation in the next iterations possibly exploring even more the neglected parts of the put.
the loop is bootstrapped with user provided initial seeds on which the first mutations are performed.
in order to gather the code coverage data needed to guide this process afl injects additional code into the put.
this instrumentation code tracks and reports which parts of the put s original code are covered during a run.
concretely coverage is measured at the level of edges in the control flow graph cfg of the put.
each edge is represented by a corresponding byte in a dedicated coverage map.
the instrumentation code zeroes the map at the start of the put execution and each time the execution passes through a given edge it increments the corresponding byte in the map.
binary fuzzing with afl afl usually performs instrumentation while compiling the source code of the put via a special compilation pass plugged into a mainstream compiler.
this pass injects the needed instructions in each put basic block enabling the aforementioned edge coverage tracking.
yet in this work we aim at using afl for detecting backdoors which often requires vetting binary only programs.
for such situations afl now provides a slower binary fuzzing mode where the put is run in an emulator such as qemu since injecting the instrumentation directly into the binary is hard to perform robustly and accurately.
the emulator tracks the coverage data on the fly by approximating edges as jumps between the memory addresses in which it hasloaded the put code.
guessing magic bytes with afl a historical limitation of graybox fuzzers is their difficulty to generate inputs able to traverse specific types of branching conditions called magic byte comparisons .
an example of such a condition is if input 0xdeadbeef some code here where a part of the input is compared to the magic byte value 0xdeadbeef .
an old enough version of afl would struggle to find inputs getting past this ifcondition as it would have to come up with the magic byte value by a series of random mutations from the initial seed values.
this becomes highly unlikely to achieve in reasonable time for long enough magic byte sequences making the fuzzer unable to test the whole part of the put code inside the ifcondition.
this is an important problem in the context of this work as entire classes of backdoors such as hardcoded credentials may rely on a magic byte comparison e.g.
with the hard coded username or password as a trigger.
however recent techniques that involve splitting multi byte comparisons into single byte ones or matching the target bytes using lightweight taint tracking enable fuzzers to traverse magic byte comparisons much more efficiently.
these techniques have been bundled into more recent versions of afl making them credible candidates to detect backdoors.
metamorphic oracles afl relies on crash detection as its main oracle mechanism.
as well coded backdoors should not cause a crash when triggered by their key input value they cannot be detected with such an oracle.
a more sensitive oracle should thus be devised for afl to perceive their triggering and developing such an oracle is a core contribution of this work.
several families of sophisticated oracles have already been proposed to detect complex forms of bugs and vulnerabilities.
one such family is metamorphic oracles based on metamorphic relations that are expected to hold between pairs of inputs to a put.
the principle of the oracle is then that any pair of generated inputs found violating the metamorphic relation is a trace of a put failure to be further investigated.
the oracle developed in this work to detect the triggering of backdoors is a form of a metamorphic oracle.
known successful uses of metamorphic oracles in fuzzing have notably enabled detecting intricate logic bugs in various complex mature and large programs like compilers sql database management systems and smt solvers .
iii.
m otivating example a. a hard coded credentials backdoor in sudo the sudo unix command line tool enables executing a given command as a different usually more privileged user.
for example echo password sudo s u alice cmd when run by an entitled user bob allows them to run command cmd as user alice provided that password is the correct password for user bob.
if the password is indeed correct sudo issues system calls to create a child process owned by alice in which it executes cmd.
otherwise sudo issues system calls to print an error message on the screen.1int verify user const struct sudoers context ctx const char password int ret ctx verify password beginning of backdoor if strcmp password let me in ret auth success end of backdoor return ret listing .
example of a hard coded credentials backdoor in sudo.
let us now imagine that an attacker has injected the codelevel backdoor from listing in sudo.
this backdoor relies on a hard coded credentials trigger lines which overwrites the result of the password and entitlement check from line .
regardless of which user executes sudo impersonation will always succeed if they enter the password let me in .
this gives the attacker and anyone informed of the key full root access in any system containing the backdoored sudo.
b. detecting the backdoor with rosa in order to understand how r osa detects backdoors with a graybox fuzzer we need to introduce the notion of input families of a put.
intuitively the input values of a put can be classified into different families where each family is a set of input values considered as similar in the put s specification so that they result in close by execution paths being taken in the put and similar effects on the put s environment.
rosa then introduces a new metamorphic oracle relying on a new metamorphic relation whose violations will be considered signs of possible backdoor presence if two input values belong to the same input family running the put on either of them should produce a similar effect on the put environment.
let us illustrate how input families enable detecting backdoors in the sudo backdoor example.
first consider that echo password sudo s u alice cmd is run by the user bob with a fixed cmd value so that the only actual input is the value of password .
in this restricted context sudo has two input families one where password is a correct password and one where it is not leading to two different effects on the environment either cmdis executed as alice or an error message is printed .
second let us assume that the effect of a program on its environment can be observed by recording the set of system calls that it issues.
the rationale for this is that the put s interactions with the environment must be mediated by the operating system which is achieved via system calls.
we then use the metamorphic oracle to detect the backdoor as follows.
first record the system calls issued by sudo when fed an incorrect password value.
then fuzz sudo with only incorrect password values and compare the issued system calls with the recorded ones.
if a significant difference is spotted then the metamorphic relation for the family of incorrect passwords is violated and a potential backdoor is reported.
this allows to detect the let me in password as the execution of cmdin a child process will trigger different system calls than printing an error message.
recall that modern fuzzers havemechanisms to quickly discover hard coded magic values such as let me in as detailed in section ii b4.
in practice all backdoors collected to build our r osarum benchmark also result in divergent system calls when triggered because that is the only way for them to perform a meaningful task in the put s environment no matter how small it may appear.
as a consequence all of them could possibly be detected by the metamorphic oracle described above.
yet in order to enable such a detection the oracle should not only be used on a single input family but on all input families deemed important enough to be searched for backdoors.
however most puts have numerous different input families.
in the case of sudo if we do not restrict the considered inputs to the password only but also consider the impersonating and impersonated users the command to be executed and the many flags that can be activated we would end up with a combinatorial explosion of the number of families to individuate manually and then fuzz.
to solve this issue r osa does not assume any prior knowledge of the put s input families but instead relies on a heuristic method to automatically identify for whatever input generated by a fuzzer another input that should belong to the same family.
the system calls issued when running the put with the two inputs are then compared to detect the presence of a backdoor.
iv.
t herosa approach a. general overview the r osa approach to fuzzing based backdoor detection unfolds in two successive phases followed by a postprocessing step schematized in figure .
during the representative inputs collection phase we use a fuzzer on the put in order to populate a database with a wide range of inputs that are deemed representative of its input families.
then during the backdoor detection phase we fuzz the put for a much longer time.
for every input generated by the fuzzer we search the database of family representative inputs in order to heuristically identify another input that should belong to the same family as the generated input.
the system calls issued when running the put with these two inputs are then compared.
following the principle of our metamorphic oracle if a dissimilarity is spotted a possible backdoor is signaled.
the two inputs and the different system calls are then deduplicated and reported to the user for expert vetting.
in phase representative inputs collection the challenge is to guide a fuzzer towards generating as many relevant familyrepresentative inputs as possible.
while inputs in the same input family produce a similar effect on the put environment they can still trigger slightly different put behaviors.
for example wrong passwords in sudo could trigger different input sanitizing strategies but should all eventually result in similar system calls.
consequently we define a set of representative inputs of a family as any set of inputs from the family where each input triggers a different internal behavior among those encompassed by the family.
in practice the internal behavior of a program can be reasonably characterized by which edges of its cfg areprogram fuzzer final input database filter inputs covering same edgesphase representative inputs collection program fuzzer generated test input program issued system calls database of familyrepresentative inputs closest familyrepresentative input program issued system callsdissimilarity?input with closest edge coverage?phase backdoor detection backdoor report filter duplicate reports vetting of unique report by tooled expertpost processing deduplication and vettingyes fig.
.
general overview of the r osa approach to fuzzing based backdoor detection.
visited.
a set of representative inputs then becomes any set of inputs from the family where each input in the set triggers the execution of a different combination of cfg edges.
in order to build our database of family representative inputs we thus need to identify and combine sets of inputs from each family where all inputs in a set cover different cfg edges.
this can be done by generating inputs with a fuzzer identifying the corresponding family of each input and adding it to the database only if the corresponding family set in the database does not already contain an input covering the same cfg edges.
yet by the definition of input families two inputs covering exactly the same cfg edges also belong to the same family.
hence two distinct family sets in the database will never contain inputs covering exactly the same cfg edges and our procedure to populate the database can be performed without prior knowledge of what the input families are.
one can indeed just fuzz the put and retain all of the generated inputs that uncover new cfg edge combinations in the database.
during phase backdoor detection the main challenge is to try and identify which inputs from the representative inputs database are the most likely to belong to the same family as the inputs generated by the fuzzer.
we do this by searching the database for the input that covers the closest combination of cfg edges compared to each fuzzer generated input.
here again the rationale is that an input family basically defines a class of slightly different internal put behaviors each best characterized by which cfg edges are visited.
b. phase representative inputs collection during phase we fuzz the put and populate the representative input database with all of the generated inputs that have uncovered new cfg edges.
in practice we do this by taking advantage of the existing features of common graybox fuzzers that rely on edge coverage for guidance like the many fuzzers based on afl .
after fuzzing we collect the seed inputs produced by the fuzzer and filter out redundant ones as some seeds may still cover the same combination of edges.
the main stake of populating the representative inputs database in phase is to properly sample the legitimate input families that will be met at phase .
we call family subsampling the situation where only some of these families would bediscovered by the fuzzer in phase .
in this case no representative input is produced for the undiscovered families.
these representative inputs would thus be missing when searching the database in phase .
this will increase the risk of family misidentification leading to false positives being reported as the metamorphic oracle may mistakenly report some inputs as triggering a backdoor.
we call backdoor contamination the situation where the fuzzer ends up triggering a backdoor in phase despite the fact that backdoors are designed to be activated by a small fraction of inputs and are thus unlikely to trigger in phase .
in case of backdoor contamination backdoor triggering inputs may end up recorded incorrectly as representative inputs of legitimate families and used for family identification in phase .
this will increase the risk of the metamorphic oracle mistakenly classifying some inputs as legitimate.
yet backdoors can usually be triggered by inputs belonging to many different input families for example the sudo backdoor from listing can be triggered with many different combinations of command line flags and as backdoor contamination is unlikely to occur for allthese families all at once the backdoor would still be detectable with inputs from the uncontaminated families.
in practice the levels of family subsampling and backdoor contamination can be controlled by adjusting the duration of the phase fuzzing campaign.
the longer the campaign the lower the risk of family subsampling and the higher the risk of backdoor contamination.
in section vi we perform a parameter sweep study for campaign durations between seconds and minutes showing that all durations provide acceptable results on our r osarum backdoor benchmark.
c. phase backdoor detection during phase we fuzz the put again with a graybox fuzzer but this time for as long as possible i.e.
as available resources permit like in traditional fuzzing .
for each input generated by the fuzzer we retrieve the input that covers the closest combination of cfg edges from the representative inputs database.
we run the put with these two inputs and signal a backdoor if they do not trigger similar system calls.
example.
let us imagine that the graybox fuzzer has generated an input called input .
we run the put on it and record which cfg edges are covered and which typesof system calls are used among all those allowed by the operating system api like read kill open and others in linux .
the results can be stored in vectors as follows where input covers the four edges of the put and uses all three available system call types but kill input cfg edges1 system callsread kill open let us now retrieve the input that covers the closest combination of cfg edges from the representative inputs database.
let us imagine that this database contains two inputs input aand input b whose covered edges and used system call types are as follows representative inputs database input a cfg edges1 system callsread kill open input b cfg edges1 system callsread kill open to establish which of input a and input b has the closest combination of cfg edges compared to input we compute the hamming distance between the cfg edge vectors and consider the one for which the distance is the smallest.
in this case input a is retrieved as its coverage w.r.t.
input differs only by two edges against three for input b input input input a input b hamming distance for edges hamming distance for edges finally system call comparison is done by computing the hamming distance between the system call type vectors of input and the retrieved input input a read kill open input input a hamming distance for system calls we report a backdoor as soon as this distance is non zero.
in this case a backdoor is reported because input uses a read system call and input a does not.
note that if during database retrieval the hamming distance between cfg edge vectors had been the same for input a and input b we would have reported a backdoor only if the hamming distance between the system call type vectors had been non zero for both input a and input b .
d. post processing deduplication and vetting fuzzers are stochastic and thus subject to repeatedly triggering the same issues in the put.
as a consequence they often use deduplication techniques to try and avoid polluting their output with duplicated reports see donaldson et al.
for an example .
r osa follows a similar approach and reports a backdoor only if it had not previously reported anotherbackdoor involving the same system call difference with the same family representative input as these two reports are likely to describe the same backdoor.
our experiments show that this heuristic enables reducing by one order of magnitude on average the number of reports produced by r osa without impeding its ability to find backdoors.
as family identification is made heuristically r osa is capable of returning false positives.
each backdoor report of the form input is suspicious because it uses a read system call and input a does not must thus be manually vetted by an expert an understanding of the expected and actual program behaviors is indeed needed here for which there is currently no fully automatic solution .
yet vetting can still occur in a pretty systematized and semi automated way run the put under a process tracing tool like strace with both reported inputs filtering out all system calls except the ones listed in the report compare the filtered traces to determine whether one represents a privilege escalation within the program or an undue access to the underlying system.
example.
let us illustrate how vetting works on a real positive report returned by r osa on the authentic proftpd backdoor .
running the suspicious input under strace and keeping only the divergent system calls produces the following pattern clone3 ... setuid setgid execve bin sh ... which is a transparent attempt at spawning a root shell not an expected behavior for proftpd .
the suspicious input itself lines long contains the surprising help acidbitchez command which can be identified as part of the key input value of a backdoor.
v. i mplementation we have implemented the r osa tool by relying on afl version .20c for the fuzzing campaigns of both phases and .
the r osa tool needs to be provided with the put and a corpus of initial seed inputs to fuzz it.
its main parameters are the respective lengths of the two fuzzing campaigns.
at the end the tool returns a list of put inputs that trigger potential backdoors similar to how vanilla afl returns a list of crash triggering inputs.
these inputs can then be vetted as discussed above.
as backdoor detection must often be performed on puts that come in binary only form we use afl in binary only mode with qemu as backend emulator.
otherwise we configure afl by following the best practices described in its documentation.
this notably means using six synchronized instances of the fuzzer running in parallel with different seed prioritization and mutation strategies.
half of the instances only instrument the put itself while the other half also instrument the called external library functions enabling backdoor detection in dynamically loaded libraries.
all instances leverage the built in afl mechanisms to deal efficiently with magic byte comparisons as these are often used as backdoor triggers.
it should be noted that support for the configuration of afl that we have just described iscurrently limited to fuzzing x86 x64 binaries on linux.
our tool inherits thus this limitation.
finally during the fuzzing campaigns of phases and our tool records on the fly which cfg edges and system calls are triggered by the generated inputs for later use according to the r osa approach.
this is implemented through light modifications to the afl and qemu code.
for recording edge coverage data we rely on the existing edge coverage measurement mechanisms of the fuzzer.
for recording system call coverage data we implement similar mechanisms to those used for edge coverage measurement but we track system call instructions instead of jump instructions between basic blocks.
vi.
e xperimental evaluation a. general overview we aim at answering the following research questions rq1 can r osa detect backdoors in enough diverse contexts with enough robustness speed and automation to make it usable and useful in the wild?
rq2 how does r osa compare to state of the art backdoor detection tools in terms of robustness speed and automation?
to answer these we need to run r osa and competing tools over samples of backdoors in real programs.
yet there is no existing off the shelf backdoor dataset that could be leveraged to do so.
indeed previous papers introducing program analysis tools for backdoor detection use different small backdoor datasets for evaluation purposes.
in addition these papers date back years so that some samples have been lost while those that are still available can be undocumented binary firmware running only on old iot devices.
as a preliminary step to our evaluation we have thus assembled a novel backdoor benchmark dataset called rosarum .
b. constructing the rosarum benchmark collecting and porting authentic backdoors as a first step to populate r osarum we have collected authentic backdoors from three types of sources.
first we have looked into all state of the art papers for alive