are we learning the right features?
a framework for evaluating dl based software vulnerability detection solutions satyaki das syeda tasnim fabiha saad shafiq and nenad medvidovi c university of southern california satyakid fabiha sshafiq neno usc.edu abstract recent research has revealed that the reported results of an emerging body of deep learning based techniques for detecting software vulnerabilities are not reproducible either across different datasets or on unseen samples.
this paper aims to provide the foundation for properly evaluating the research in this domain.
we do so by analyzing prior work and existing vulnerability datasets for the syntactic and semantic features of code that contribute to vulnerability as well as features that falsely correlate with vulnerability.
we provide a novel uniform representation to capture both sets of features and use this representation to detect the presence of both vulnerability and spurious features in code.
to this end we design two types of code perturbations feature preserving perturbations fpp ensure that the vulnerability feature remains in a given code sample while feature eliminating perturbations fep eliminate the feature from the code sample.
these perturbations aim to measure the influence of spurious and vulnerability features on the predictions of a given vulnerability detection solution.
to evaluate how the two classes of perturbations influence predictions we conducted a large scale empirical study on five state of the art dl based vulnerability detectors.
our study shows that for vulnerability features only of fpps yield the undesirable effect of a prediction changing among the five detectors on average.
however on average of feps yield the undesirable effect of retaining the vulnerability predictions.
for spurious features we observed that fpps yielded a drop in recall up to for graph based detectors.
we present the reasons underlying these results and suggest strategies for improving dnn based vulnerability detectors.
we provide our perturbation based evaluation framework as a public resource to enable independent future evaluation of vulnerability detectors.
index terms vulnerability detection deep learning software security explainable ai i. i ntroduction identifying security vulnerabilities in software and specifically in source code has been an important focus of researchers and practitioners prompted by numerous examples of high profile security breaches .
earlier research in this area concentrated on developing deterministic approaches for vulnerability detection that relied on predefined rules and patterns .
since these approaches have suffered from a range of shortcomings researchers have more recently turned to deep learning as a vehicle for vulnerability detection because dl offers a superior capacity to learn complex patterns from data .
dl techniques have demonstrated their versatility in other software engineering tasks that involve source code datasets such as code clonedetection and authorship attribution providing additional motivation for their use in software vulnerability detection.
although the shift to dl has yielded promising results it has also introduced new challenges.
specifically these techniques operate as black boxes making it difficult to understand the reasoning behind their predictions and decisions.
they also suffer from a lack of generalizability performing poorly on unseen datasets and failing to adapt to new vulnerabilities.
it is thus important to make these techniques more explainable and this can be achieved by investigating the specific code features that influence their predictions.
by so we can uncover the underlying decision making processes expose potential biases and limitations and pinpoint areas for refinement ultimately leading to the development of more trustworthy reliable and effective vulnerability detection techniques.
on this front existing literature has recognized the presence of spurious features in dl based approaches .
these are code features that falsely correlate with the target label.
such spurious features can impact vulnerability detection tools and models and they provide a helpful starting point for our work.
however to systematically advance the state ofthe art in vulnerability detection a three pronged approach is necessary identify and disregard spurious features sf in code that can lead to inaccuracies pinpoint and leverage genuine features that contribute to vulnerabilities vf and analyze and quantify the impact of sfand vfon a proposed vulnerability detection technique.
this paper presents our implementation of the above three pronged approach.
first we conducted a rigorous analysis of the widely used sard vulnerability dataset to uncover the key features and patterns that contribute to the manifestation of the vulnerabilities in the dataset vf.
second we expanded the list of sfs by exploring the assumptions made in the literature e.g.
those that do not hold true in our dataset samples .
we have systematized the uncovered vf andsfand structured them into an expandable taxonomy of code features for vulnerability detection.
third we have developed viper a novel perturbation based approach for identifying the weaknesses in a given vulnerability detector s predictions.
viper generates both feature preserving perturbations fpp which ensure that a feature vforsf remains in a given code sample and feature elim arxiv .13291v5 may 2025inating perturbations fep which remove the feature from the code sample.
viper comprises three phases feature detection identifies the presence or absence of each feature from our taxonomy in a given source code sample.
targeted perturbation modifies the code sample in a manner that either preserves fpp or removes fep a detected feature.
solution evaluation involve analyzing a vulnerability detector s response to the targeted perturbations and inferring the extent to which a given vforsfimpacts the detector s prediction.
we have applied viper on five state of the art dl based vulnerability detectors deepwukong reveal deepdfa linevul and sysevr .
by analyzing the five detectors responses to viper s perturbations we quantified the extent to which a given feature contributes to a prediction thus providing valuable insights into the detectors decision making processes the sensitivity and robustness of their predictions and the potential biases and limitations of their vulnerability detection capabilities.
our findings indicate that in case of vfsviper s perturbations significantly impact the five detectors performance with precision decreasing by and recall by on average.
the detectors exhibit reasonable robustness to fpps with only of all fpps yielding the inappropriate outcome of changed vulnerability predictions.
however of feps result in the inappropriate outcome of retained vulnerability predictions.
additionally in the case of sfs fpps produce a decline in recall of up to .
together the latter two results mean that in an overwhelming majority of cases the state of the art vulnerability detectors original reasoning behind predictions was flawed as it was not actually based on the targeted features.
this paper makes the following contributions an extendable taxonomy of vulnerability vf and spurious sf features viper a perturbation based framework to gauge the robustness of vulnerability detectors a customizable wrapper for seamless integration of the framework in the evaluation pipeline of existing vulnerability detectors and a comprehensive empirical evaluation of five state of theart vulnerability detectors assessing the impact of both vfandsfon their predictions.
in the paper s remainder section ii introduces the novel taxonomy of code features.
section iii details our approach viper .
sections iv and v present the evaluation setup and results of our study.
section vi discusses our findings and their implications.
threats to validity are discussed in section vii related work in section viii and conclusions in section ix.
ii.
t axonomy of code features we initiated our study by examining which code features a given detector learns by analyzing the widely adopted vulnerability datasets sard ffmpeg qemu draper and bigvul .
all four datasets were instructive in our understanding of the problem and its different manifestations.
however only sard provided annotations at critical points in the source code that describe how a vulnerability manifestsitself in the vulnerable sample e.g.
see comment prefixed with flaw on line in listing and what changes one can apply to repair it in the corresponding non vulnerable sample fix on line in listing .
the absence of this information in other datasets makes it difficult both to identify vfs and to assess the accuracy of vfdetection in samples.
along with the fact that sard is the largest publicly available vulnerability dataset containing many real world security flaws e.g.
from wireshark and gimp and actively supported by the national institute of standards and technology this led us to direct our focus to the sard dataset.
we will now delve into the process of identifying vulnerability vf and spurious sf features followed by the development of the taxonomy.
1int data 2data null flaw allocate memory without using sizeof int 4data int alloca 5int source potential flaw possible buffer overflow if data was not allocated correctly in the source 7memcpy data source sizeof int 8printintline data listing vul.
sample1int data 2data null fix allocate memory using sizeof int 4data int alloca sizeof int 5int source potential flaw possible buffer overflow if data was not allocated correctly in the source 7memcpy data source sizeof int 8printintline data listing non vul.
sample a. identifying vulnerability features vf we analyzed the annotated descriptions in the sard dataset to identify properties of code that contribute to a vulnerability.
specifically we focused on the most frequent vulnerability categories referred to as cwes out of cwes present in the sard dataset.
these cwes featured in out of sard s source code files as shown in table i. we used as our cut off point the fact that no other cwes featured in at least sard files.
for each vulnerability in this set we manually analyzed its annotated descriptions comments containing prefixes flaw potential flaw or fix such as those in listings and and corresponding source code segments.
to systematically map the annotated descriptions with the corresponding features in the code we represent each code sample in a code property graph cpg .
a cpg is table i top cwes in the sard dataset cwe id description files cwe805 buffer access with incorrect length value cwe806 buffer access using size of source buffer cwe124 buffer underwrite cwe127 buffer under read cwe193 off by one error cwe126 buffer over read cwe415 double free cwe839 numeric range comparison without minimum check cwe131 incorrect calculation of buffer size cwe416 use after free 2fig.
abridged cpg constructed from sample in listing constructed from a program s abstract syntax tree ast control flow graph cfg and program dependence graph pdg combining their labeling and property functions.
this combination allows a cpg to leverage information from all three sources to conduct better vulnerability analysis .
for example fig.
depicts an abridged version of the cpg that is constructed from the sample in listing where each node represents properties that characterize the statement in the corresponding line of code and each edge represents data control and call dependencies between the nodes.
the annotated descriptions in lines and in listing describe the vulnerability present in lines and respectively.
they are encoded in the cpg by the leftmost data dependence dd edge in red for the buffer data between nodes and illustrating an overflow scenario by performing write operation sizeof int bytes on a byte buffer.
we encoded the description of each of the selected cwe vulnerability categories into a cpg.
we elaborate on these rules in section iii.
b. identifying spurious features sf sfs required a different approach since all vulnerability datasets focus on features relevant to vulnerabilities and not on those that should be avoided.
as our starting point we used several existing studies which provide valuable insights into how features such as variable and method names and formatting tokens falsely correlate with vulnerabilities.
these features are examples of sfs we aim to study and they can have an especially negative impact on the robustness and performance of token based vulnerability detectors such as sysevr and linevul .
to address this researchers have recently developed graphbased vulnerability detectors such as reveal and deepwukong which replace these sfs with symbolic names e.g.
var1 fun1 and incorporate additional information from program graphs e.g.
control and data flow call dependencies etc.
to make predictions.
this also means that the sfs observed in existing literature for token based detectors do not apply to the graph based detectors requiring further exploration of sfs that may influence the latter.
to this end we focused on the assumptions made by graph based detectors regarding features that maycontribute to a vulnerability.
for instance one common assumption is that a vulnerability is defined strictly by the set of nodes in the graph of the vulnerable sample.
however we observe that the same vulnerability would still exist if a mock node e.g.
a printf benign statement is added to the graph.
another common assumption is that the set of edges strictly defines the vulnerability in the graph of the vulnerable sample.
however a mock edge e.g.
if !
return can be added to the graph without affecting its vulnerability.
the idea of introducing changes that should not impact vulnerability to the sets of nodes and edges was inspired by the existing literature that discussed how graph neural networks learn spurious correlations between sets of nodes and edges .
our examination of the sard dataset revealed that the above two assumptions in particular do not always hold and can lead to spurious correlations that impact detectors predictions.
we demonstrate the extent of this impact in section v. c. developing the taxonomy to capture the dichotomy between vfs and sfs and to provide a comprehensive understanding of their characteristics we classified them into a taxonomy of code features .
our hierarchy based taxonomy is shown in fig.
.
the taxonomy is not intended to be comprehensive.
we expect that follow on work will add further categories to the taxonomy which will in turn be encoded as further viper rules.
we partitioned code features into two mutually exclusive sub classes vulnerability features vfs and spurious features sfs .
all identified vfs from table i are classified code features vulnerability features overflow incorrect calculation of buffer size buffer access using size of source buffer buffer access using size of destination buffer off by one error deallocated buffer use use after free double free numeric range comparison without minimum check buffer underwrite buffer under read sensitive api call read api write api spurious features token based identifier names code formatting graph based node set print instructions without variable unused variable declarations edge set unreachable conditional operation without variables dependency altering uses of variables fig.
taxonomy of code features 3cpg rules2 pattern matching a feature detection original sample fpp sample testb targeted perturbation trained detectortrained detector mapped predictionsc solution evaluation cpg extraction detected featuresfep sample original sample cpg sample annotationannotated sample fep generation1 fpp generation matched samplesardtrain measure influence satisfaction ratesfig.
high level viper workflow under the vulnerability features sub class which is subdivided into four further sub classes based on feature characteristics overflow vulnerabilities occur when a buffer is accessed outside its allocated memory.
we further categorize overflow vulnerabilities based on the nature of the out of bounds access a incorrect calculation of buffer size b buffer access using size of source buffer c buffer access using size of destination buffer and d off by one error.
deallocated buffer use vulnerabilities arise when a buffer is accessed after it has been deallocated.
we further categorize these vulnerabilities based on the type of postdeallocation use a use after free and b double free.
numeric range comparison vulnerabilities involve an array indexing operation where the index variable never gets checked for a minimum value.
based on the type of array indexing operation i.e.
read or write we subdivide these vulnerabilities into a buffer underwrite and b buffer under read.
sensitive api call vulnerabilities are characterized by the use of system apis that are well known for causing vulnerabilities .
we categorize these vulnerabilities into a read apis and b write apis.
we categorized the spurious features based on the two primary approaches for dl based vulnerability detection token based sf s comprise features of individual code tokens that may lead to spurious correlations such as a identifier names that may not be relevant to the vulnerability and b code formatting.
sfs previously identified in literature fall under this category grayed out in fig.
.
graph based sf s are features of nodes and their relationships edges that exhibit spurious correlations but do not inherently contribute to vulnerabilities.
we categorize these features into a node set and b edge set .
node set refers to the presence of one or more single line instructions that have no impact on the vulnerability.
specific instances of these sfs include i print instructions without variables i.e.
empty print statements in the code and ii unused variable declarations i.e.
variables that are not used after declaration.
edge set refers to the presence of multi line instructions defining data or control dependencies that do not affect vulnerability.
specific instances of edge set vulnerabilities are i unreachable conditional operation without variables i.e.
a conditionthat will always be false and may change the control dependency and ii dependency altering uses of variables i.e.
usage of variables that may alter dataflow or control dependency but that do not contribute to vulnerability.
note that the goal of the study reported in this paper is to observe the impact of sfcategories that require minimal change.
for this reason we exclude the sfs that are greyed out in fig.
from this study.
the transition from individual structured annotations in the sard dataset to the development of the taxonomy was carried out iteratively.
we analyzed the annotated descriptions of each sample containing vfs.
during each iteration an author suggested a category and potential sub categories which were then discussed and refined.
this process continued until all authors reached a consensus.
additionally we incorporated categories for sfs by consulting relevant literature and applying the same iterative approach.
iii.
a pproach our approach to vulnerability identification via perturbations viper comprises three phases as illustrated in fig.
feature detection uses cpg rules to identify the presence of vfs in samples and annotate them as candidates for perturbation.
since sfs are inherent properties of code this phase does not pertain to them.
targeted perturbation systematically applies fpps alterations in code with no change to a feature and feps alteration in code that eliminates the feature to the tagged samples generating a perturbed dataset for each of the vfs.
for sfs viper only generates fpps because sfs are inherent properties of code that cannot be eliminated.
we used the structured annotations in the sard dataset as ground truth for evaluating the correctness of the cpg rules to detect features.
we manually compared the cpg rule detected features in out of the files confidence with a margin of error with the annotations in sard.
when devising the fpps and feps we ensured that the perturbation targeted the property mentioned in the annotations and later manually analyzed the same files to determine if the fpps retained the vulnerability and the feps removed the vulnerability.
solution evaluation assesses the detectors responses to the perturbed datasets examining how perturbations affect the predictive performance of the detectors and their ability to react satisfactorily.
a satisfactory reaction is defined as no prediction change for fpps and a prediction change for 4feps.
with this information viper quantifies the influence of these features on the detectors predictions.
the following subsections detail each phase.
a. feature detection the goal of the feature detection phase is to systematically identify the suitable candidate samples for perturbation.
the whole process is broken down into three main steps cpg extraction pattern matching and sample annotation.
we elaborate each step next cpg extraction we use joern to construct the cpg for each sample in the dataset.
to facilitate our analysis we abridge the graph by retaining only edges that represent the most relevant relationships data dependence dd control dependence cd post dominance pd def and use.
these edge types are selected because they are widely recognized as essential relationships for vulnerability analysis .
a cpg is formally defined as a graph g v e where vis the set of all nodes and ethe set of all edges in the cpg and v e k sis a function that sets or retrieves the property of a node or edge.
kis the key that denotes which property would be retrieved or set and sis the value for propertyk.
to facilitate our implementation of viper we extended the property function s capabilities to retrieve and set additional properties of nodes and edges.
due to space limitation we list these additional property keys and values as acronyms used by property function in the online appendix .
pattern matching once the abridged cpgs are constructed from the dataset samples we iterate through each cpg to identify which ones satisfy any of our predefined cpg rules for the vfs.
if a cpg satisfies a rule we infer that the corresponding dataset sample exhibits the vfassociated with that rule and is a suitable candidate for perturbation.
the cpg rules along with their corresponding vfare given in table ii.
to assess if a cpg satisfies a rule we develop corresponding detection algorithms for each of the rules listed in table ii.
due to the page limitation we will only describe the detection algorithm for rule id .
for vf incorrect calculation of buffer size which is the cpg rule that the sample in listing satisfies.
we provide the algorithms for the remaining detection algorithms in the online appendix .
we will now discuss the algorithm used to check if a cpg satisfies the cpg rule with id .
incorrect calculation of buffer size .
the description for its rule in table ii states that for this vulnerability feature to exist in a sample the cpg constructed from the sample must have a node vrepresenting a buffer write function call that writes nnumber of bytes to a buffer dwith a defined length of len dthat is smaller than n i.e.
len d n .
to detect this feature viper checks if the constructed cpg has a node vrepresenting a buffer write function call where the number of bytes to write n is larger than the defined length of the destination buffer len d by traversing the constructed cpg to determine the static values forlen dandn.
algorithm describes how viper determines these static values and checks if the sample satisfies rule .
.algorithm incorrect calculation of buffer size input g v e representing the cpg constructed from the sample code output boolean value indicating whether the feature exists in the sample property keys for arg dest destination buffer in a wf arg count number of bytes to write in a wf type type of node or edge len length of a defined buffer var variable associated with data dependence begin 1letv v vforv vif v type wf 2fornode vinv do letd v arg dest letn v arg count letindd v v uforu vif u v eand u v type dd and u v var d foruinindd v do if u type af or u type ad then letlen d u len ifn len dthen return true 11return false in algorithm line iterates through every node vin v where v is the set of nodes representing a buffer write function wf call e.g.
a call to memcpy line .
lines and in the algorithm retrieve the destination buffer d and the number of bytes to write n in the function call respectively.
line retrieves the start nodes of all the incoming data dependence dd edges of node vwith respect to the destination buffer d i.e.
indd v .
lines iterate through the retrieved data dependence edges and check if an edge s start node urepresents an allocation function af or an array declaration ad .
if so it further checks whether the number of bytes to write n according to node vexceeds the length defined at node u line .
if true it concludes that the sample contains the vulnerability incorrect calculation of buffer size .
we do not develop separate detection algorithms forsfs because the purpose of these algorithms is to identify relevant samples for perturbation which is not necessary for sfs.
unlike vfs sfs including the ones we focused on i.e.
identifier names code formatting set of nodes and set of edges are inherent properties of every sample.
sample annotation once a feature is detected in a sample viper annotates the sample with the detected feature relevant line numbers and variable names which differ across the vfs.
for example when viper detects incorrect calculation of buffer size in a sample like in listing it first lists the name of the detected feature as incorrect calculation of buffer size and lists the line number that defines len d line in listing and the line number where the value of nis defined line in listing and the variable name used for the destination buffer d data for listing1 .
we provide the annotations used for the remaining vfs in the online appendix .
after completing the sample annotations viper creates a dataset comprising only the annotated samples.
this 5table ii cpg rules rule id vulnerability feature cpg rule condition under which vulnerability exists in a sample .1incorrect calculation of buffer size ibs cpg constructed from the sample must have a node vrepresenting a buffer write function call that writes n number of bytes to a buffer dwith a defined length of len dthat is smaller than n i.e.
len d n .
.2buffer access using size of source buffer bsb cpg constructed from the sample must have a node vrepresenting a buffer write function call that writes n number of bytes from a source buffer swith a defined length of len sequaling nto a destination buffer d with a defined length of len dthat is smaller than n i.e.
len d n n len s .
.
off by one error oe cpg constructed from the sample must have a node vrepresenting a buffer write function call that writes n number of bytes to a buffer dwith a defined length of len dthat is smaller than nby exactly one.
i.e.
n len d .
.
buffer over read bo cpg constructed from the sample must have a node vrepresenting a buffer copy function call that reads n number of bytes from a buffer swith a defined length of len sthat is smaller than n i.e.
len s n .
.
double free df cpg constructed from the sample must have two nodes uandvwho call free on the same buffer band there exists no node wbetween uandvthat uses an allocation function e.g.
malloc onb.
.
use after free uaf cpg constructed from the sample must have two nodes uandvwhere node vuses a buffer bafter node u already deallocates buffer b. .
buffer underwrite buw cpg constructed from the sample must have a node vthat writes to a buffer busing an index value idxwhere idxis never checked to ensure that it does not hold a negative value.
.
buffer under read bur cpg constructed from the sample must have a node vthat reads from a buffer busing an index value idx where idxis never checked to ensure that it is not a negative number.
.
read api ra cpg constructed from the sample must have a node vrepresenting a function call to a sensitive read api e.g.
fgets where the location lof node vis a vulnerable line in the sample.
.
write api wa cpg constructed from the sample must have a node vrepresenting a function call to a sensitive write api e.g.
memcpy where the location lof node vis a vulnerable line in the sample.
annotated dataset is utilized by the subsequent phase of viper targeted perturbation which we will describe next.
b. targeted perturbation the goal of this phase is to understand how robust the models are to changing input and whether the detectors are able to learn from the vfs instead of the sfs.
we posit that the detectors should be able to correctly predict the outcome solely based on the presence of vfin the code sample and should remain unchanged if the code sample changes without losing the vf.
to achieve this viper perturbs samples in two ways preserving the feature fpp or eliminating it fep .
the underlying principle is that if a perturbation leaves thevfintact fpp the detector s prediction should remain unchanged.
conversely if a perturbation eliminates the vf fep the detector s prediction should change accordingly.
fig.
provides a high level overview of how viper generates perturbations.
the input for this phase is the annotated dataset generated by the previous phase feature detection .
from this dataset viper extracts the three essential elements required for perturbation the original sample in the dataset where the vfwas detected the name of the detected vfand the relevant line numbers and variable names for generating perturbations.
based on the detected feature s name viper selects one of tailored perturbation generation algorithm sets.
each set involves generating one or more fpps and feps.
due to page limitations we will only elaborate on the perturbation generation algorithm set for incorrect calculation of buffer size .
the remaining nine algorithm sets are provided in the online appendix .
recall the cpg rule forvf incorrect calculation of buffer size islen d n. the algorithms used for generating fpps and feps for this cpg rule are given as follows fpp generation when generating fpps we want to make sure that the perturbation still retains the rule len d n. there are two ways this can be achieved algorithm fpp incorrect calc.
of buffer size input g cpg constructed from the sample code feat name name of the detected feature u line defining the destination buffer v line representing wf output boolean value indicating whether the feature exists in the sample begin 1letlen d u len 2letn v arg count 3letg1 v1 e1 1 g.clone 4 1 u len len d 5letg2 v2 e2 2 g.clone 6 2 v arg count n 7return g1 g2 decreasing the value of len dor increasing the value ofn.
to apply these two types of perturbations viper uses algorithm .
in lines of the algorithm it extracts the values of len dandnfrom line numbers extracted from the feature annotated samples.
in lines it creates two clones of the original sample and in the first clone applies perturbation i.e.
decreasing the value of len d see line while in the second clone it applies perturbation i.e.
increasing the value of n see line .
fep generation when generating feps we want to achieve the opposite goal and ensure that the perturbation no longer satisfies the rule len d n .
again there are two ways this can be achieved increasing the value of len dto match the value of nor decreasing the value of nto match the value of len d. to apply these two types of perturbations viper uses algorithm .
similar to the previous algorithm in lines of algorithm viper extracts the values of len d andnfrom line numbers extracted from the feature annotated samples and in lines it creates two clones of the original sample.
however unlike the previous algorithm to generate feps viper increases the value of len dto match nfor the 6algorithm fep incorrect calc.
of buffer size input g cpg constructed from the sample code feat name name of the detected feature u line defining the destination buffer v line representing wf output boolean value indicating whether the feature exists in the sample begin 1letlen d u len 2letn v arg count 3letg1 v1 e1 1 g.clone 4 1 u len n 5letg2 v2 e2 2 g.clone 6 2 v arg count len d 7return g1 g2 first clone see line and for the second clone it decreases the value of nto match len d see line .
to generate perturbations targeting spurious features sfs in vulnerable samples we employ separate approaches for token based and graph based detectors.
since viper evaluates token based approaches for sfs that are established in previous literature we use existing methods of perturbation for these sfs.
specifically we adopt the symbolization mechanism from li et al.
to perturb identifier names and leverage the auto indentation feature of the clion ide to introduce indentations into code samples.
in contrast for graph based sfs we develop new perturbations.
importantly since modifications to sfs do not impact the sample s vulnerability ground truth all generated perturbations for sfs are fpps.
the goal for sfperturbations is to modify the nodes and edges in a sample with minimal possible change without affecting the vulnerability ground truth.
therefore for node set the corresponding perturbation is inserting a printf statement at the start of each function i.e.
theprint instructions without variables sf and for edge set the corresponding perturbation is inserting if return at the start of each function i.e.
the unreachable conditional operation without variables sf .1note that these perturbations are generic and are applied to all samples in the dataset.
c. solution evaluation the goal of this phase is to measure the effect of the perturbations generated in the previous phase on the predictions of the detectors.
by analyzing the predictions of the detectors on the perturbed dataset viper measures how the vfs and sfs influence the detector s prediction.
fig.
depicts a highlevel overview of the solution evaluation phase.
first we train the detectors on the sard dataset.
next we use the dataset samples annotated in the feature detection phase and their corresponding fpps and feps generated in the targeted perturbation phase to retrieve the predictions of the detectors.
using these predictions viper analyzes the detector s response to the perturbations.
specifically it measures how satisfactory 1for better readability we are referring to the sfsprint instructions without variables andunreachable conditional operation without variables asnode setandedge set respectively for the rest of the paper.are the detectors responses.
recall that a satisfactory reaction is when a detector retains its predictions for fpp perturbations or when it changes predictions for fep perturbations.
based on this information we calculate the satisfaction rate srf of the detectors on the perturbations targeting a feature ffor a dataset xto measure the influence of fon the detector s prediction.
formally the satisfaction rate is defined as srf t fpp t fep tfpp tfep where tfpp is the total number of fpps generated from xfor f tfep is the total number of feps generated from xforf t fpp is the total number of fpps that retain the detector s prediction expected outcome t fep is the total number of feps that change the prediction of the detector expected outcome .
additionally the aim is to understand how fpps and feps individually impact the detectors.
viper measures this impact by calculating the satisfaction rate of fpps srfpp f and feps srfep f for a feature findividually as shown below srfpp f t fpp tfpp srfep f t fep tfep iv.
e valuation setup a. research questions our evaluation aims to answer three research questions.
rq1 how do the targeted perturbations affect the reported prediction accuracy of the vulnerability detectors?
rq2 what are the detectors responses to perturbations targeting different features?
rq3 to what extent do the fpps and feps influence the detectors predictions?
b. classifying evaluation results for the purpose of our analysis and discussion specifically rq3 we classify detector responses into one of four srfpp f srfep f combinations high high hh high low hl low high lh and low low ll .
we consider the satisfaction rate high if the value is within chosen value of the average satisfaction rate for a perturbation type targeting feature f. this ensures that detectors performing close to the average are still recognized as effective.2detectors in the hhcategory exhibit a desired understanding of feature fsince they retain predictions for fpps and change predictions for feps.
these detectors will not experience significant drop in precision or recall in the presence of perturbations.
a detector in the hlcategory exhibits an understanding of feature f but that understanding does not align with the ground truth characteristics of f i.e.
the relevant cpg rule .
these detectors will experience a noticeable drop in precision in the presence of perturbations.
a detector in the lhcategory changes its 2while our analysis would be carried out the same way regardless of the selected value we selected this value based on established conventions as an of0.
.03is frequently used in surveys such as the american statistical association and the american community survey s methodology for population and housing estimates .
7predictions given any perturbation involving feature f. such detectors will experience a significant drop in recall.
lastly detectors in the llcategory will exhibit a significant drop in both precision and recall in the presence of perturbations.
researchers and engineers can use viper s results to assess the vulnerability detectors and decide which option is best suited for their purpose.
ideally one would always prefer a detector falling under the hh category.
if none of the available detectors fall under that category their users will have to assess whether a detector that falls within one of the other categories is suitable for their tasks.
generally vulnerability detection tasks prioritize recall over precision i.e.
tolerating false alarms while fixing as many vulnerabilities as possible.
in such cases the engineer may prefer detectors falling under the hl category.
however there may be certain tasks where precision is preferred over recall.
an example is as a large and stable system in which vulnerable code is less prevalent and the cost of handling false alarms is significant.
in that case the lh category may be considered.
c. evaluation subjects we investigated whether five state of the art vulnerability detectors learn from vfs or sfs deepwukong reveal deepdfa linevul and sysevr .
deepwukong leverages an advanced graph neural network gnn to embed code fragments into a low dimensional representation .
reveal generates function level prediction by using gated gnns that are intended to make the model capable of understanding complex code semantics and dependencies .
deepdfa detects function level vulnerabilities by extracting abstract dataflow information from functions and applying a gated graph sequence neural network to learn vulnerabilities in the extracted dataflow .
linevul predicts software vulnerabilities at the line level leveraging the bert architecture with self attention layers.
it first predicts the vulnerable functions and then locates the specific vulnerable lines within those functions.
sysevr uses syntax based vulnerability candidates syvcs from code and semantic based candidates sevcs from control and data dependencies by representing them into vectors suitable for marking the vulnerabilities in code .
d. evaluation dataset to assess the five evaluation subjects viper uses the largest vulnerability dataset sard containing production synthetic and academic programs a.k.a.
test cases .
we utilized the curated version of sard from sysevr as it is the largest dataset used among all five vulnerability detectors .
the dataset includes c c files.
the vulnerable programs in sard provide precise locations of each vulnerability enabling effective analysis.
in total the dataset had c c functions that we used for training the five evaluation subjects.
v. r esults in this section we present the results corresponding to the three posed research questions in the previous section.a.
rq1 analysis of accuracy rq1 investigates the impact of targeted perturbations on the detectors predictive performance.
we assess the detectors performance using two widely adopted evaluation metrics precision and recall.
table iii presents the changes between the original and the perturbed dataset for each identified vfand sfin terms of predictive performance.
a negative value indicates a decline whereas a positive value indicates an increase in the corresponding metric.
for perturbations targeting vfs that belong to overflow vulnerability sub class in fig.
overall we observe that all five detectors suffer a noticeable decrease in precision.
however in case of sysevr the drop is on average higher than the other four detectors.
as for recall deepwukong shows a drop up to .
while the rest of the detectors show minimal drop with linevul retaining its original recall.
for vfs that belong to deallocated buffer use vulnerability sub class we observe that all graph based detectors deepwukong reveal and deepdfa noticeably outperform the token based detectors linevul and sysevr .
deepwukong achieves the smallest drop in precision .
on average and a slight increase in recall .
on average while deepdfa exhibits the highest drop in precision up to24 .
since both token based approaches demonstrate relatively poor performance i.e.
over drop in precision on average for linevul and similar drop in recall for sysevr this could be due to the fact that deallocated buffer use vulnerabilities are characterized mainly by the control flow of a program .
since graph based detectors by design are able to better capture context information from graphs they are expected to outperform token based approaches.
however deepdfa only focuses on the dataflow of a function which may explain its drop in precision.
for vfs that belong to numeric range comparison vulnerabilities linevul shows the highest drop in precision among the five detectors.
forsensitive api call vf s linevul and reveal show the biggest drop in precision by on average with linevul also showing the largest drop in recall .
sysevr gets the second largest drop in precision with on average.
results for vfs under this sub class are surprising since this vffocuses on calls to specific system apis token based approaches are by design expected to effectively leverage tokens containing system api names.
we elaborate on this particular aspect in section vi.
for the sf code formatting we observe that both sysevr and linevul are reasonably resilient with the drop in precision and recall never exceeding .
for the sf identifier name linevul shows a significant drop in precision with over while sysevr s precision drops only by .
.
this is likely because sysevr preprocesses raw code tokens e.g.
symbolizing code elements to prevent learning from custom naming conventions while linevul converts the raw code tokens directly into vectors thus exposing itself to this sf.
for twosfs that belong to the graph based sub class we observe that deepwukong only suffers a noticeable drop in recall for 8table iii accuracy metrics change original perturbed graph based token based feature name deepwukong reveal deepdfa linevul sysevr prec rec prec rec prec rec prec rec prec recvfibs .
.
.
.
.
.
.
.
.
.
bsb .
.
.
.
.
.
.
.
.
.
oe .
.
.
.
.
.
.
.
.
.
bo .
.
.
.
.
.
.
.
.
.
df .
.
.
.
.
.
.
.
.
.
uaf .
.
.
.
.
.
.
.
.
.
buw .
.
.
.
.
.
.
.
.
.
bur .
.
.
.
.
.
.
.
.
.
ra .
.
.
.
.
.
.
.
.
.
wa .
.
.
.
.
.
.
.
.
.95sfidentifier name .
.
.
.
code formatting .
.
.
.
node set .
.
.
.
.
.
edge set .
.
.
.
.
.
thesf edge set .
while reveal s recall drops for both sfs.
this reduction in recall in both cases suggests that graphbased approaches tend to generate false negatives whenever encountering a behavior preserving perturbation such as introducing a mock edge to the graph.
however in case of node set perturbations deepwukong is less influenced possibly due to the fact that it only considers control and data dependence edges from the cpg since node set perturbations do not introduce any of these dependencies they do not influence deepwukong s predictions.
in contrast reveal considers all the nodes from cpg and is thus inherently exposed to node setperturbations.
the precision and recall drops for deepdfa are negligible .
.
similarly to the above discussion of deepwukong this is due to the fact that deepdfa only works on dataflow information and sfperturbations introduce no changes to a program s dataflow.
at the same time it may be worth investigating whether deepdfa retains the same robustness against sfsthat impact dataflow information e.g.
the use of intermediate variables during a mathematical calculation.
b. rq2 analysis of feature satisfaction rate rq2 investigates the detectors robustness to perturbations targeting individual features using the srfmetric introduced in section iii c. fig.
presents a heatmap illustrating the srf of the detectors for feature specific perturbations the larger thesrf the more intense the color in the cell.
among the five detectors deepwukong has the highest average srffor perturbations targeting vfs that belong to overflow vulnerability sub class with while sysevr has the lowest average srfwith .
for vfs that belong to deallocated buffer use vulnerability sub class we observe an opposing scenario from rq1 where both token based detectors demonstrate a better srf higher than the graph based detectors.
forvfs that belong to numeric range comparison vulnerability sub class sysevr displays the lowest srfwith on average while rest of the detectors demonstrate higher srf i.e.
.
for sensitive api call vf s deepwukong achieves the highest srfwith on average.
it is worth noting that for the feature read api viper does notgenerate fpps since we could not find replacement for system read functions from the list of vulnerability causing system apis with matching argument list and syntax.
therefore viper only generates feps for this vf.
since all the feps targeting this feature retain predictions for reveal and linevul their srfis0.
we will discuss this particular detectors behavior in the next section vi.
for sfs that belong to the token based sub class both linevul and sysevr produce roughly the same srf.
for sfs that belong to graph based sub class deepwukong achieves a slightly higher srfthan reveal while deepdfa achieves near perfect srffor both sfs.
c. rq3 analysis of fpp and fep satisfaction rate the goal of rq3 is to determine which type of perturbations fpps or feps have the most significant impact on the detectors predictions.
table iv shows the srfpp f andsrfep f for individual vfs.
as can be seen in table iv for perturbations targeting vfs that belong to overflow vulnerability sub class the average srfpp f is99.
and since all five detectors srfpp f are around of the average we consider all their srfpp f to be high.
however the average srfep f is9.
which is lower than the recommended minimum threshold for metrics measuring the intelligence of ai systems i.e.
.
therefore if the srfep f is lower than we fig.
perturbation satisfaction rates 9consider the value to be low.
this means that all five detectors receive very low srf specifically linevul never changes its prediction for feps.
therefore all five of them fall under the category hl.
for vfs falling that belong to deallocated buffer use vulnerability sub class using the same principle as before we selected thresholds for srfpp f andsrfep f as93.
and respectively.
we observe that deepdfa deepwukong linevul and reveal remain in category hl while sysevr falls under category lh for deallocated buffer use vulnerabilities.
for vfs that belong to numeric range comparison vulnerability sub class the selected thresholds forsrfpp f andsrfep f are97.
and respectively.
therefore all five detectors fall under the category hl.
as mentioned when discussing rq2 viper does not generate fpps for read api vf therefore we only consider srfep f .
we observe that deepwukong and sysevr have a srfep f while linevul and reveal demonstrate srfep f with deepdfa achieving srfep f .
note that since we do not have any fpps for this specific vf we cannot characterize the detectors under one of the four categories.
for write api vfs the selected thresholds for srfpp f andsrfep f are99.
and respectively.
for this vfalso all five detectors fall under the category hl.
vi.
d iscussion and implications the evaluation of five detectors by viper yielded valuable insights revealing the detectors respective strengths and weaknesses.
in the case of deepwukong viper revealed that its lowest srfcomes from vfsdouble free anduseafter free which both belong to the sub class deallocated buffer use .
given that these vulnerabilities are primarily characterized by program control flow viper s findings suggest that deepwukong struggles to comprehend control dependencies and their contribution to vulnerability.
viper shows that deepwukong is also influenced by the sf edge set which may be a key factor underlying its limited understanding of control dependencies.
viper s findings indicate that reveal struggles to understand the impact of system apis on vulnerabilities as it displays the lowest srfforvf write api .
reveal also shows a drop in recall for node set andedge set sf s.viper s findings suggest that these sfs may impede reveal s ability to recognize crucial dependencies related to system api calls.
similarly to reveal deepdfa struggles to understand how system apis impact vulnerabilities evidenced by it demonstrating the lowest srffor the vf write api .
this is because deepdfa does not capture the system apis in the dataflow analysis during the learning process.
on the other hand unlike reveal deepdfa is not affected by graph based sfs.
viper shows that graph based detectors reveal and deepwukong experience a drop in recall from the sf edge set .
this may be attributed to sard s fix generation process for certain vulnerable code.
specifically we observed that sard often fixes vulnerabilities involving sensitive system apis by introducing control dependencies with unsatisfiable conditions e.g.
if !
.
we observed this in source files.
viper sfindings suggest that these control dependencies may lead graph based detectors to mistakenly associate them with fixes for the vulnerability.
there could be two possible remedies to improve the accuracy of vulnerability detection models we recommend avoiding such spurious control dependencies when generating fixes in synthetic vulnerability datasets or preventing vulnerability detectors from learning from the spurious control dependencies by eliminating them using an edge filtering algorithm during preprocessing.
since deepdfa incorporates the above mentioned remedies by only extracting dataflow information it does not get influenced by these sfs.
viper s findings also indicate that linevul achieves a srfpp f but a srfep f .
this disparity suggests that linevul severely overfits when trained on sard excelling in false positive reduction but failing to generalize effectively.
viper also shows that the sf identifier name impacts linevul s predictions by reducing its precision.
this sfis one of the contributors to linevul s overfitting to sard.
therefore linevul may benefit from using some preprocessing technique on the tokens e.g.
token symbolizing to avoid exposing itself to the sf identifier name .
for sysevr it gets lower srfcompared to the four other detectors for most of the features.
however the lowest value is from the vf write api suggesting that sysevr s token symbolization may inadvertently capture system apis hindering its ability to learn from these api names and understand their contribution to vulnerabilities.
sysevr may address this by modifying its token symbolization to include only user defined functions.
vii.
t hreats to validity external validity this threats refers to the generalizability of the experiments and viper .
we mitigated this threat by conducting a large scale study including five recent and representative vulnerability detectors following token based and graph based approaches.3although the dataset employed in this study only contains c c code samples viper s primary goal is to ensure accurate representation of vulnerabilities that should be learnt by the detectors thus it is language agnostic and dataset independent.
another threat may arise from our reliance on the sard dataset when devising sfs.
however sard is the largest available dataset that is widely used and contains many real world security flaws.
to further confirm that our results are not inadvertently impacted by sard we also examined how the graph based sfs influence reveal by utilizing the ffmpeg qemu dataset.
our findings indicate that both sfs also affect reveal s predictions on ffmpeg qemu in a manner consistent with our sard based results.
this supports the sfs broad applicability.
internal validity this threat may arise from a weak research protocol or selection bias.
we overcome this threat by strictly following the reproducible guidelines provided by the authors of the employed vulnerability detectors.
also the 3we additionally investigated the possibility of using a sixth vulnerability detector deepvd .
however we were unable to reproduce deepvd s published results and did not receive a response from its authors when we asked for clarification.
for this reason we excluded deepvd from our study.
10table iv satisfaction rates for fpp and fep graph based token based vf deepwukong reveal deepdfa linevul sysevr fpp fep fpp fep fpp fep fpp fep fpp fep ibs .
.
.
.
.
.
.
.
.
.
bsb .
.
.
.
.
.
.
.
.
.
oe .
.
.
.
.
.
.
.
.
.
bo .
.
.
.
.
.
.
.
.
.
df .
.
.
.
.
.
.
.
.
.
uaf .
.
.
.
.
.
.
.
.
.
buw .
.
.
.
.
.
.
.
.
.
bur .
.
.
.
.
.
.
.
.
.
ra .
.
.
.
.
wa .
.
.
.
.
.
.
.
.
.
decision to opt for sard dataset and specific vulnerability detectors was made based on a comprehensive literature analysis.
sard is relatively the largest dataset available and the chosen detectors are widely employed in prior work.
construct validity one of the critical design decisions made in this study is to restrict sfs for graph based approaches to two node set andedge set in the taxonomy however there might be other spurious features that the detectors could be learning from.
that said the taxonomy can be further extended as needed.
another construct validity threat may arise due to the employed evaluation metrics.
when reproducing the vulnerability tools we utilized their adopted evaluation metrics.
in contrast the metric satisfaction rate is unique to this study which is employed to measure the extent to which the vulnerability detectors deviate from the desired outcomes when fpp and fep are applied to the code samples.
conclusion validity this threat concerns with the authenticity and significance of the findings reported in this study.
we mitigated this threat by rigorously following authors guidelines while reproducing the results for their vulnerability detectors.
also due to absence of replacement for system read apis we do not generate fpps for the vf read api and hence did not include in our results.
another threat may be the use of joern to extract the cpg from each dataset sample.
joern has been observed to occasionally miss dependencies.
however its developers have actively tried to address this issue in recent updates.
in addition to using an updated version we mitigated this threat by filtering out the invalid cpgs constructed by joern.
viii.
r elated work understanding the features relevant to vulnerability prediction i.e.
vfs is critical for improving the dl based vulnerability detectors reliability and trustworthiness.
recent studies have therefore attempted to explore the vfs in dlbased vulnerability detectors.
risse et al.
studied the vulnerability detectors ability to learn fixes for vulnerable patches.
suneja et al.
probed the signal awareness of models used for vulnerability detection by reducing the input source code to the minimum tokens required to retain the prediction.
meanwhile our approach for devising vfs is primarily focused on properties related to code dependencies.it is also the first to evaluate whether vulnerability detection techniques understand these code dependencies.
another way researchers pursue explaining the predictions of dl based models is by examining the unintended pattern in the dataset that the models might learn erroneously i.e.
sfs .
on that note recent studies have explored the influence of variable names and method names in the prediction of the models of code.
risse et al.
analyzed the behavior of models of code on logic preserving transformations.
our work is the first to categorize sfs based on how they impact token based and graph based approaches and to develop sfs based on graph properties of code.
additionally this paper presents the dichotomy between vfs and sfs through an illustrative taxonomy as well as an evaluation framework that allows for the assessment of both vfs and sfs within the same platform.
ix.
c onclusion and future work previous studies have shown that existing vulnerability detectors fail to generalize well to unseen datasets suggesting they may be learning irrelevant code features.
to address this we introduce viper a framework for accurately evaluating vulnerability detectors by providing a comprehensive view of the features that truly contribute to vulnerabilities and how they impact the predictions of vulnerability detectors.
viper employs feature preserving and feature eliminating perturbations to assess a detector s performance.
our results reveal that in the case of vulnerability features approximately of feature preserving perturbations and of featureeliminating perturbations have an adverse impact on detector outcomes.
in the case of spurious features we observe that feature preserving perturbations produced a drop in recall up to for graph based detectors.
to facilitate correct evaluation and improvement of vulnerability detectors we have made viper publicly available to the research community.
for future work we plan to discover more vulnerability and spurious features and explore ways to ensure that vulnerability detectors handle them properly.
acknowledgment this work is supported in part by the national science foundation under grant ccf .
11references z. li d. zou s. xu x. ou h. jin s. wang z. deng and y .
zhong vuldeepecker a deep learning based system for vulnerability detection arxiv preprint arxiv .
.
n. bhatt a. anand v .
s. s. yadavalli and v .
kumar modeling and characterizing software vulnerabilities international journal of mathematical engineering and management sciences .
b. grobauer t. walloschek and e. stocker understanding cloud computing vulnerabilities ieee security privacy vol.
no.
pp.
.
f. piessens a taxonomy of causes of software vulnerabilities in internet software in supplementary proceedings of the 13th international symposium on software reliability engineering .
citeseer pp.
.
j. c. santos a. peruma m. mirakhorli m. galstery j. v .
vidal and a. sejfia understanding software vulnerabilities related to architectural security tactics an empirical investigation of chromium php and thunderbird in ieee international conference on software architecture icsa .
ieee pp.
.
a. sejfia s. das s. shafiq and n. medvidovi c toward improved deep learning based vulnerability detection in proceedings of the 46th ieee acm international conference on software engineering pp.
.
n. h. pham t. t. nguyen h. a. nguyen and t. n. nguyen detection of recurring software vulnerabilities in proceedings of the 25th ieee acm international conference on automated software engineering pp.
.
y .
shin a. meneely l. williams and j. a. osborne evaluating complexity code churn and developer activity metrics as indicators of software vulnerabilities ieee transactions on software engineering vol.
no.
pp.
.
z. li d. zou s. xu h. jin h. qi and j. hu vulpecker an automated vulnerability detection system based on code similarity analysis inproceedings of the 32nd annual conference on computer security applications pp.
.
s. kim s. woo h. lee and h. oh vuddy a scalable approach for vulnerable code clone discovery in ieee symposium on security and privacy sp .
ieee pp.
.
z. li d. zou s. xu h. jin y .
zhu and z. chen sysevr a framework for using deep learning to detect software vulnerabilities ieee transactions on dependable and secure computing vol.
no.
pp.
.
x. cheng h. wang j. hua g. xu and y .
sui deepwukong statically detecting software vulnerabilities using deep graph neural network acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
s. chakraborty r. krishna y .
ding and b. ray deep learning based vulnerability detection are we there yet ieee transactions on software engineering .
m. fu and c. tantithamthavorn linevul a transformer based linelevel vulnerability prediction in proceedings of the 19th international conference on mining software repositories pp.
.
j. cito i. dillig v .
murali and s. chandra counterfactual explanations for models of code in proceedings of the 44th international conference on software engineering software engineering in practice pp.
.
m. t. ribeiro s. singh and c. guestrin why should i trust you?
explaining the predictions of any classifier in proceedings of the 22nd acm sigkdd international conference on knowledge discovery and data mining pp.
.
m. m. rahman i. ceka c. mao s. chakraborty b. ray and w. le towards causal deep learning for vulnerability detection in proceedings of the ieee acm 46th international conference on software engineering pp.
.
n. risse and m. b hme limits of machine learning for automatic vulnerability detection arxiv preprint arxiv .
.
u. d. of commerce sard s website.
.
available https samate.nist.gov sard b. steenhoek h. gao and w. le dataflow analysis inspired deep learning for efficient vulnerability detection in proceedings of the 46th ieee acm international conference on software engineering pp.
.
viper s replication package.
.
available records y .
zhou s. liu j. siow x. du and y .
liu devign effective vulnerability identification by learning comprehensive program semantics via graph neural networks advances in neural information processing systems vol.
.
r. russell l. kim l. hamilton t. lazovich j. harer o. ozdemir p. ellingwood and m. mcconley automated vulnerability detection in source code using deep representation learning in 17th ieee international conference on machine learning and applications icmla .
ieee pp.
.
j. fan y .
li s. wang and t. n. nguyen ac c code vulnerability dataset with code changes and cve summaries in proceedings of the 17th international conference on mining software repositories pp.
.
u. d. of commerce nist s website.
.
available https f. yamaguchi n. golde d. arp and k. rieck modeling and discovering vulnerabilities with code property graphs in ieee symposium on security and privacy .
ieee pp.
.
s. fan x. wang c. shi p. cui and b. wang generalizing graph neural networks on out of distribution graphs ieee transactions on pattern analysis and machine intelligence .
m. usman r. britto j. b rstler and e. mendes taxonomies in software engineering a systematic mapping study and a revised taxonomy development method information and software technology vol.
pp.
.
c. cowan c. pu d. maier j. walpole p. bakke s. beattie a. grier p. wagle q. zhang and h. hinton stackguard automatic adaptive detection and prevention of buffer overflow attacks.
in usenix security symposium vol.
.
san antonio tx pp.
.
c. cowan f. wagle c. pu s. beattie and j. walpole buffer overflows attacks and defenses for the vulnerability of the decade in proceedings darpa information survivability conference and exposition.
discex vol.
.
ieee pp.
.
viper s online appendix.
.
available view viper framework jetbrains clion a cross platform ide for c and c by jetbrains.
.
available american statistical association.
.
available pol seeingthroughstats spring 2013.pdf american community survey.
.
available gov programs surveys acs j. devlin m. w. chang k. lee and k. toutanova bert pre training of deep bidirectional transformers for language understanding arxiv preprint arxiv .
.
sysevr s sard.
.
available sysevr blob master program 20data sard sard.7z d. m. powers evaluation from precision recall and f measure to roc informedness markedness and correlation arxiv preprint arxiv .
.
f. cabitza and a. campagner who wants accurate models?
arguing for a different metrics to take classification models seriously arxiv preprint arxiv .
.
w. wang t. n. nguyen s. wang y .
li j. zhang and a. yadavally deepvd toward class separation features for neural network vulnerability detection in ieee acm 45th international conference on software engineering icse .
ieee pp.
.
s. suneja y .
zheng y .
zhuang j. a. laredo and a. morari probing model signal awareness via prediction preserving input minimization inproceedings of the 29th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering pp.
.
z. yang j. shi j. he and d. lo natural attack for pre trained models of code in proceedings of the 44th international conference on software engineering pp.
.
m. v .
pour z. li l. ma and h. hemmati a search based testing framework for deep neural networks of source code embedding in 14th ieee conference on software testing verification and validation icst .
ieee pp.
.