demystifying and detecting cryptographic defects in ethereum smart contracts jiashuo zhang yiming shen jiachi chen jianzhong su yanlin wang ting chen jianbo gao zhong chen school of computer science peking university beijing china sun yat sen university zhuhai china university of electronic science and technology of china chengdu china beijing key laboratory of security and privacy in intelligent transportation beijing jiaotong university beijing china corresponding authors zhangjiashuo pku.edu.cn seuilping gmail.com chenjch86 mail.sysu.edu.cn sujzh3 mail2.sysu.edu.cn yanlin wang outlook.com brokendragon uestc.edu.cn gao bjtu.edu.cn zhongchen pku.edu.cn abstract ethereum has officially provided a set of systemlevel cryptographic apis to enhance smart contracts with cryptographic capabilities.
these apis have been utilized in over of ethereum transactions motivating developers to implement various on chain cryptographic tasks such as digital signatures.
however since developers may not always be cryptographic experts their ad hoc and potentially defective implementations could compromise the theoretical guarantees of cryptography leading to real world security issues.
to mitigate this threat we conducted the first study aimed at demystifying and detecting cryptographic defects in smart contracts.
through the analysis of real world security reports we defined nine types of cryptographic defects in smart contracts with detailed descriptions and practical detection patterns.
based on this categorization we proposed c rysol a fuzzing based tool to automate the detection of cryptographic defects in smart contracts.
it combines transaction replaying and dynamic taint analysis to extract fine grained crypto related semantics and employs crypto specific strategies to guide the test case generation process.
furthermore we collected a large scale dataset containing real world crypto related smart contracts and evaluated c rysol s effectiveness on it.
the result demonstrated that c rysolachieves an overall precision of .
and a recall of .
.
notably c rysolrevealed that .
out of smart contracts contain at least one cryptographic defect highlighting the prevalence of these defects.
index terms ethereum smart contracts defects detection cryptography i. i ntroduction cryptographic techniques with their strong capabilities in securing data and communication have demonstrated significant potential in enhancing the functionality of smart contracts .
to prompt on chain cryptographic practice ethereum has officially introduced a set of system level cryptographic apis such as ecrecover to enable basic crypto operations within smart contracts.
these apis effectively reduced the gas cost associated with complex cryptographic operations and prompted diverse on chain cryptographic tasks such as digital signature and merkle proof .
currently more than of ethereum transactions use these crypto apis highlighting the significance and prevalence of cryptographic practices in ethereum smart contracts.however since smart contract developers may not necessarily be cryptographic experts their implementation of cryptographic tasks could be error prone.
such defective implementations can compromise the theoretical security guarantees of cryptography and lead to real world security issues in practice .
for example a security team reported smart contracts that suffered signature replay attacks illustrating the prevalence and damage of on chain cryptographic defects.
unfortunately the community still lacks knowledge and tools to mitigate this threat.
a recent empirical study revealed that .
of smart contract developers face obstacles in securing their cryptographic implementations and .
of developers believe existing security tools need improvement to support their cryptographic practices.
although many studies have focused on defects in smart contracts they mainly focus on issues arising from general programming tasks such as reentrancy and integer overflow while rarely addressing defects specific to cryptographic practices.
consequently the characterization and mitigation of cryptographic defects remain an open challenge.
to bridge the gap we conducted the first study focusing on demystifying and detecting cryptographic defects in ethereum smart contracts.
to propose the definition and categorization of common cryptographic defects we conducted an empirical study on smart contract security reports from real world security teams and investigated crypto specific security issues they reported.
based on an open card sorting approach we introduced the first systematic taxonomy of cryptographic defects in smart contracts.
it includes nine categories of defects covering common on chain cryptographic tasks including digital signature merkle proof message digest and random number generation .
based on our defect definitions we proposed c rysol a fuzzing based approach to detect cryptographic defects in real world smart contracts.
to the best of our knowledge it is the first security technique targeting crypto specific defects in contracts.
it integrates offline analysis with onchain historical data to address the challenges posed byarxiv .04939v1 aug 2024complicated cryptographic operations.
specifically c rysol employs transaction replay and dynamic taint analysis to initialize the fuzzing context and extract essential cryptorelated semantic information such as data dependencies of cryptographic operations.
c rysolutilizes a set of cryptospecific strategies to effectively generate test cases and exploit defects.
these strategies guide c rysol s test case generation with fine grained semantic information and prevent it from getting stuck on trivial test cases i.e.
transactions directly reverted by cryptographic checks.
c rysolexecutes the test cases and detects defects based on a set of crypto specific oracles.
to evaluate c rysol s effectiveness we collected a dataset containing real world crypto related contracts and ran c rysolon it.
the results indicated that c rysol achieves an overall precision of .
and a recall of .
.
moreover they demonstrated the prevalence of cryptographic defects in real world contracts revealing that .
out of these contracts contain at least one defect.
we summarize our main contributions as follows we conducted the first study on cryptographic defects in smart contracts.
through the analysis of security reports we defined and categorized nine types of cryptographic defects which expands the existing categorization of smart contract defects .
we presented these defects with detailed descriptions and practical detection patterns to guide future security solutions.
we proposed c rysol the first tool to detect cryptographic defects in smart contracts.
it extracts fine grained cryptographic semantics from on chain data and employs crypto specific strategies to guide the fuzzing process.
by addressing the functional gap of existing security tools it has the potential to secure the emerging on chain cryptographic practice.
we collected a large scale dataset containing real world crypto related smart contracts and evaluated crysolon it.
c rysolrevealed that .
of these contracts contain at least one cryptographic defect with an overall precision of .
and a recall of .
.
we published the source code of c rysol all analysis results and datasets at to provide support to further studies.
ii.
b ackground a. ethereum virtual machine evm ethereum virtual machine evm is the execution environment for ethereum smart contracts .
it manages the onchain states of smart contracts and transforms these states by iteratively executing instructions known as opcodes .
the opcodes include stack memory storage operations arithmetic calculations and other functionalities required by smart contracts.
for example the sload opcode reads a value from the contract s storage to the stack and the sstore opcode writes a stack element to the storage.
beyond the opcodes ethereum introduced several precompiled contracts as low level extensions of evm .
theyare implemented as built in system level contracts to optimize the computation cost of specific functionalities such as crypto operations.
user defined contracts can use the staticcall call callcode delegatecall opcode to call precompiled contracts and execute their functionalities.
b. cryptographic apis in evm to enable cryptographic operations in smart contracts ethereum introduced nine cryptographic apis to evm .
these apis include one opcode keccak256 and eight precompiled contracts ecrecover sha256 ripemd160 modexp ecadd ecmul ecpairing blake2f .
specifically keccak256 sha256 ripemd160 and blake2f provide four hash functions in smart contracts i.e.
keccak256 sha2 ripemd and blake2b .
we collectively refer to these four apis as hash operations in the remainder of this paper.
ecrecover facilitates the on chain verification of ecdsa signatures on the secp256k1 elliptic curve .
modexp enables big integer modular exponentiation.
ecadd ecmul andecpairing provide elliptic operations of the altbn128 curve to enable the verification of paring based zero knowledge proofs such as groth16 .
these apis largely reduce the gas cost of cryptographic operations and have thus attracted widespread application.
in a recent empirical study zhang et al.
found that .
of ethereum transactions have utilized these crypto apis.
in particular keccak256 ecrecover sha256 apis are the top three commonly used apis used by .
.
.
of transactions respectively.
c. cryptographic tasks in smart contracts utilizing these crypto apis developers have implemented a variety of cryptographic tasks in smart contracts.
zhang et al.
analyzed the source codes of crypto related smart contracts and classified common cryptographic tasks in smart contracts including digital signatures used in .
of crypto related contracts vector commitments .
message digests .
and random number generators .
.
we briefly introduce these tasks as follows digital signatures .
signatures are widely used for on chain identity authentication .
by combining ecrecover with hash operations developers can implement signature verification logic for ecdsa signatures .
vector commitments .
vector commitments are widely used to enforce on chain whitelist and other access control policies.
they are typically implemented as merkle proofs .
message digest .
message digest refers to the direct use of hash operations.
it is commonly used to compute collision resistant indexes for dynamic length contents.
random number generator .
random number generator refers to generating pseudo random numbers based on crypto operations.
it is commonly used for on chain gaming and gambling.d.
defects in smart contracts a software defect is an error flaw failure or fault in a computer program or system that causes it to produce an incorrect or unexpected result or to behave in unintended ways .
several previous studies have documented defects in smart contracts from different aspects .
for example chen et al.
defined types of defects in smart contract by analyzing stackexchange posts and real world contracts.
these defects impact the security availability performance maintainability and reusability of smart contracts.
with the ongoing innovation in on chain applications such as the integration with cryptographic techniques and the everevolving security issues the understanding and definition of contract defects are also evolving and expanding .
e. security reports for smart contracts due to the prevalence of attacks integrating security evaluations into smart contract development is essential .
many third party security teams such as consensys and trails of bits offer security analysis services for smart contract projects.
they inspect the codes of smart contracts search for defects and produce detailed reports for developers.
these security reports with comprehensive descriptions of real world defects are ideal information sources for defining smart contract defects.
iii.
c ryptographic defects in smart contracts in this section we conducted an empirical study on realworld security reports to define and categorize common cryptographic defects in ethereum smart contracts.
a. data collection during this process we collected security reports from a wide range of real world security teams.
specifically etherscan provides a list of security teams that specialize in smart contract security.
by searching on their official websites and accounts on social media platforms like medium we identified that out of these security teams have publicly available security reports.
we manually collected these security reports and obtained a dataset containing reports.
b. data pre processing to filter out security reports that relate to cryptographic practices we conducted both keyword based filtering and manual filtering on the collected reports.
during the keywordbased filtering we utilized terms associated with cryptographic tasks such as signature and crypto api names like ecrecover as keywords.
as a result we filtered out reports that contained at least one keyword in their content.
however due to the multiple meanings of keywords such as hash keyword based methods are prone to inaccurate identification.
for example the term hash in several reports actually refers to the commit hash of the code being audited.
we manually checked these reports to remove those with irrelevant keywords.
finally we collected crypto related reports which are available in our online supplementary material .c.
data analysis we conducted a manual analysis on the collected reports to investigate the categories of cryptographic defects in ethereum smart contracts.
due to the exploratory nature of our study we did not introduce any pre defined categories of defects.
instead we employed the open card sorting approach a common approach in software engineering for organizing information into logical groups to define categories of defects.
in line with previous studies we created a card for each report including detailed descriptions of the defects in the report and the root causes of them.
fig.
shows an example of the card for a security report .
it describes a defect in the basevault contract that allows signature replay attacks.
the root cause of this defect is the lack of protection against reused signatures so that signatures in past transactions can be replayed multiple times.
during the card sorting procedure two authors manually analyzed these cards to define the categories of cryptographic defects.
for each card they first examined its root cause to determine if it could be categorized under an existing category.
if not they evaluated the defect s representability and reproducibility to decide whether to introduce a new category.
for example defects that were highly specific to the business logic of a particular contract were not introduced as new categories.
after that they engaged in discussions to resolve any disagreements and reached a consensus on the results.
fig.
.
an example of the cards of security reports.
d. defects definition through the analysis of security reports we identified nine types of cryptographic defects in ethereum smart contracts covering all common on chain cryptographic practices described in section ii c i.e.
digital signature vector commitment message digest and random number generator .
these defects could compromise theoretical security guarantees offered by cryptography and lead to unintended contract behaviors in practice.
table i enumerates each type of defect along with its definition.
in the following we describe these defects with detailed explanations and illustrative examples.
single contract signature replay ssr .
digital signatures are commonly used in smart contracts for on chain access control .
transactions with valid signatures can perform sensitive operations in the contracts such as transferring tokens.
in such scenarios a signature should be invalidated once it is verified to prevent attackers from replaying the same signature and re executing sensitive operations.
however with this defect the contract does not reject these valid but already used signatures.
consequently they may suffer from signaturetable i definitions of cryptographic defects in ethereum smart contracts cryptographic defect id definition single contract signature replay ssr do not prevent the same signature from being used multiple times.
cross contract signature replay csr do not distinguish signatures for this contract from those for other contracts.
signature front running sf allow signatures in pending transactions to be front run and preemptively used.
signature malleability sm lack protection against signature malleability.
insufficient signature verification isv do not properly check the result of signature verification.
merkle proof replay mr do not prevent the same merkle proof from being used multiple times.
merkle proof front running mf allow merkle proofs in pending transactions to be front run and preemptively used.
hash collisions with dynamic length arguments hc do not prevent collisions when hashing concatenated dynamic length arguments.
weak randomness from hashing chain attributes wr use the hash of chain attributes as randomness.
1function permit address owner uint256 value uint256 deadline uint8 v bytes32 r bytes32 s external bytes32 hash keccak256 abi.encode owner value deadline address signer ecrecover hash v r s require signer !
address invalid signature require owner signer invalid signer require block .timestamp deadline permit expired approve owner msg.sender value fig.
.
an example contract with ssr csr and sf defects replay attacks anyone who has observed valid signatures in past on chain transactions can replay these signatures and pass the signature verification again.
example fig.
shows a defective implementation of the erc permit function .
ideally this function should allow the msg.sender to get approved to spend tokens after submitting a valid signature from the token owner line .
however since this function does not check whether each signature has been used it always considers signatures used by past transactions as valid signatures.
consequently it enables the replaying of signatures allowing msg.sender to gain repeated approvals for token spending.
cross contract signature replay csr .
this defect arises when two different contracts have an identical signing domain i.e.
the structures of their signed messages are exactly the same.
in such cases a valid signature for contract awill also be valid for contract b enabling cross contract signature replay.
compared to the ssr defect mentioned above this defect involves a different attack vector ssr involves replaying historical signatures that previously used by the victim contract while this defect involves replaying signatures from other contracts to the victim contract.
both defects could lead to unauthorized access to sensitive operations.
example take the permit function in fig.
as an example.
suppose there are two token contracts aandb each implementing the same permit function.
the token owner holding both tokens aandb intends to sign a permit for a spender of token a. however since the signed messages required by token aandbhave exactly the same format line the signature intended solely for token aalso becomes valid for token b. consequently a malicious spender can replay thesame signature to token band successfully get approved even though this was never intended.
signature front running sf .
in ethereum pending transactions i.e.
transactions that have been submitted to the network but not yet confirmed in a block are publicly accessible .
therefore signatures within pending transactions are susceptible to being captured and preemptively used in a frontrunning attack .
this defect refers to situations where an attack transaction with front run signatures can successfully pass the verification and lead to unintended contract behaviors.
example consider the permit function in fig.
.
normally amsg.sender can obtain the approval by submitting a valid signature.
however in this case an attacker can intercept the submitted signatures from pending transactions and initiate a front running transaction to use them preemptively.
if the attack succeeds the new msg.sender i.e.
the attacker instead of the original msg.sender obtains the approval line .
signature malleability sm .
the ecdsa signatures supported by ecrecover precompiled contracts are malleable .
specifically given a valid signature v r s for message m anyone can generate another valid signature v r s for the same message m .
this defect refers to the lack of protection of signature malleability.
it is recognized to negatively impact the quality and maintainability of smart contracts and can potentially lead to security issues such as signature replay attacks.
example fig.
shows an example in which this defect can cause signature replay attacks.
in this case the hash of the signature is used to prevent signature replay attacks line .
normally after a signature is first verified it is marked as used line and any further attempts to use a used signature are rejected line .
however due to the signature malleability an attacker knowing a used signature can generate a valid but unused signature for the same message.
since the newly generated signature has not been marked as used before it can pass the check at line and make a transfer again line .
insufficient signature verification isv .
unlike standard signature verification process which takes both the public key and the signature as input and indicates the signature s validity with a true false output ecrecover employs the public key recovery process for signature verification which only takes the signature as input and outputs the onchain address of the expected signer.
as a result when1function transferwithsig address to uint256 value uint8 v bytes32 r bytes32 s public bytes32 sighash keccak256 v r s require !used address signer ecrecover keccak256 abi.
encodepacked to value address this v r s require signer owner used true transfer to value fig.
.
an example contract with the sm defect encountering an invalid signature ecrecover still returns an incorrect expected signer instead of reverting the transaction.
additionally it simply returns zero if the signature is improperly formed .
therefore when calling ecrecover contracts must check whether the returned expected signer is correct according to the business logic e.g.
by checking if it matches the token owner s address.
this defect arises when contracts do not properly verify ecrecover s return value leading to unintended contract behaviors.
example fig.
illustrates an example of this defect.
the intended behavior is to check the managers signature before permitting an operation.
however attackers can submit a nonexistent optype and an improperly formed signature to make ecrecover return zero.
since manager also defaults to zero for keys that don t exist the attacker can successfully pass the signature verification line and gain unauthorized permission line .
1function permitoperation address optype uint256 opid uint8 v bytes32 r bytes32 s public address signer ecrecover keccak256 optype opid v r s require signer manager permitted true fig.
.
an example contract with the isv defect merkle proof replay mr .
merkle proofs are commonly employed to support on chain whitelists and enable scenarios such as token airdropping .
given a large set of users to be authorized the contract owner can create a merkle tree off chain distribute its leaves to the users and upload the merkle root in the contract .
then users can submit their leaves and the corresponding merkle proofs to the contract.
the contract will verify the merkle proof before allowing users to do sensitive operations such as minting nfts.
similar to signature replay attacks lacking protection against merkle proof replay can cause repeated unauthorized access to sensitive operations.
example as illustrated in fig.
the contract allows whitelisted users to mint tokens line by submitting a valid merkle proof line .
however due to this defect users even those not in the whitelist can replay past merkle proofs submitted by whitelisted users and mint tokens.
merkle proof front running mf .
this defect is similar to the signature front running defect.
it allows attackers to capture merkle proofs in the pending transactions and use1function mint string memory leaf bytes32 calldata merkleproof external if merkleproof.verify merkleproof merkleroot keccak256 abi.encodepacked leaf mint msg.sender fig.
.
an example contract with mr and mf defects.
them preemptively which could enable unauthorized users to perform sensitive operations in the contract.
example the function in fig.
also has this defect.
specifically anyone observing a pending merkle proof can launch front running attacks and preemptively mint tokens to their accounts.
1function addusers address calldata admins address calldata regularusers bytes calldata signature external bytes32 hash keccak256 abi.encodepacked admins regularusers address signer hash.recover signature require signer owner adduser admins regularusers fig.
.
an example contract with the hc defect.
hash collisions with dynamic length arguments hc .
crypto hash operations are expected to be collisionresistant i.e.
it is computationally hard to find two input aandb s.t.
a b hash a hash b .
however nonstandard practice when hashing dynamic length arguments i.e.
dynamic arrays in solidity could lead to collisions .
example fig.
demonstrates this defect.
specifically the built in function abi.encodepacked line packs all elements in order regardless of whether they re dynamic length.
therefore keccak256 abi.encodepacked is equal to keccak256 abi.encodepacked 0xb 0xc leading to a collision.
consequently attackers can rearrange the addresses in admins and regularusers arrays without changing the hash result line .
the signature verification still passes but the content of these arrays and the contract s behavior line have been altered.
weak randomness from hashing chain attributes wr .
randomness is commonly used in scenarios such as on chain gaming and gambling .
however since there is a risk that miners could manipulate chain attributes such as block.timestamp to their advantage generating random numbers by hashing chain attributes can compromise the security of these applications.
example fig.
provides an example where this defect can be exploited to gain profits.
by choosing a block.timestamp that meets the condition line a malicious miner can win the gambling game and receive the rewards line .
defect vs. vulnerability vs. bug.
we use the term defect to collectively refer to the issues in cryptographic practices.
compared to other terms such as vulnerability and bug defect has a wider scope thus better representing these issues.
specifically vulnerability refers to defects that can be directly exploited while excluding other non standard1function gamble public payable require msg.value ether uint8 rand uint8 keccak256 block .timestamp block .number if rand msg.sender .transfer 2ether fig.
.
an example contract with the wr defect.
cryptographic implementations.
for example while signature malleability negatively impacts the quality and maintainability of the contract it does not necessarily constitute a vulnerability it can only be directly exploited in certain cases like fig.
.
furthermore bugpertains to defects caused by coding errors.
however defects like single contract signature replay are often a result of design flaws i.e.
the absence of a replay protection scheme rather than coding errors.
iv.
m ethodology our results in section iii demonstrate nine defects of onchain cryptographic practices.
to provide real world evidence of these defects in ethereum smart contracts and assist developers in detecting them in practice we built c rysol an automated testing tool for ethereum smart contracts.
a. design decisions crysolis built on fuzzing a plausible technique to detect defects in contracts .
compared to techniques like symbolic execution it can scale better to find defects with deep program paths and complex computations.
however when applying fuzzing to crypto related contracts the inherent complexity of cryptography introduces new challenges.
in the following we introduce these challenges and describe the design decisions we made to address these challenges.
properly initializing the fuzzing context.
cryptorelated functions often involve intricate execution contexts.
for example to successfully call the function in fig.
the storage variable merkleroot needs to be properly initialized and the transaction should include a valid merkle proof pertaining to that specific merkleroot .
common solutions such as randomly initiating the contracts states and transactions may result in test transactions being trivially reverted by these cryptographic checks.
to overcome this c rysolutilizes real world contracts states and transactions to initialize the execution context of the fuzzing engine.
by integrating offline analysis with onchain data c rysolprovides a fuzzing context that is closer to real world conditions thereby improving the effectiveness and efficiency of the fuzzing process.
effectively generating test cases.
generating test cases that can exploit cryptographic defects requires certain guidance.
for example to exploit the ssr defect in fig.
we need to construct two different transactions with the same signature.
however random methods could be highly inefficient to generate such test cases since they require identifying which transaction parameters are included in the signed message.
to address this c rysolreplays historical transactions of the transaction sequence generation transaction data instantiationtransaction reorderingttii 1transaction insertionttii random generationcrypto specific generation history based generationtransaction parameterstrace analysistest case execution check oracle violation defect reportdefect detection block environment transaction sendercontract abitransaction replayinitialization semantic extraction seed pool initializationttii ttii ttii ttii ttii ttii on chain statehistory txnsfig.
.
the workflow of c rysol.
contract and conducts dynamic taint analysis to extract cryptorelated semantics such as data dependencies of cryptographic operations.
utilizing these semantics c rysolemploys a suite of crypto specific strategies to effectively generate test cases that trigger potential defects.
b. overview fig.
outlines the overall workflow of c rysol.
given a contract to analyze c rysolfirst replays its historical transactions to extract crypto related semantics and initialize the seed pool section iv c .
then c rysolstarts to generate test cases for the contract to trigger potential defects section iv d .
specifically the test case generation process involves two steps i.e.
generating the transaction sequence and instantiating each transaction in the sequence with concrete parameter values.
finally c rysolexecutes the test cases and analyzes the execution traces for defect detection section iv e .
c. initialization during the initialization c rysolreplays historical onchain transactions of the contract to collect crypto related semantic information and initialize the seed pool for fuzzing.
transaction replay.
crysoloperates an ethereum archive node which retains all historical state information since the genesis block.
for each transaction c rysol leverages an off the chain execution tool designed for transaction replay to extract the contract s pre state i.e.
the contract state before the transaction execution.
then c rysol executes the transaction on this pre state using an instrumented evm and gathers execution traces for subsequent analysis.
semantic extraction.
based on the execution traces crysolcollects the following crypto related semantic information to guide the test case generation processes.
crypto related functions .
to identify potential execution paths to trigger cryptographic defects c rysolanalyzes the execution traces and filters out functions that used crypto operations.
specifically for crypto apis provided as precompiled contracts c rysolexamines the destination address of all contract call opcodes staticcall call callcode and delegatecall to determine whether the transaction calls these crypto apis.
for crypto apis provided as opcode i.e.
keccak256 c rysolanalyzes all executed opcodes and checks whether there are cryptocalls to keccak256 .
after identifying a function that uses cryptographic operations c rysolrecords all transactions traces of it for the subsequent data dependency analysis.
crypto related data dependencies .
c rysolemploys dynamic taint analysis to extract data dependencies of the cryptographic operations.
for example to determine which transaction parameters may be an ecdsa signature c rysolmarks slots of the transaction input data as sources and the arguments of ecrecover as sinks.
then it simulates taint propagation throughout the transaction s execution checking if the sinks can be reached from the sources.
for slots that can reach ecrecover it identifies to which parameters they correspond based on the contract s abi and then marks these parameters as signature related.
such information is essential for c rysolto generate valid transactions that pass the cryptographic verification.
seed pool initialization.
after that c rysolinitializes the fuzzing seed pool based on historical on chain data.
specifically it includes all historical transactions of the contract as initial seeds.
each seed contains all information required for executing the transaction the parameters and sender of the transaction the pre states of related contracts including the contract directly called by the external transaction and other contracts called by internal transactions and the block environment such as the block number and timestamp.
d. test case generation with the initialized seed pool and extracted semantic information c rysolbegins to iteratively generate test cases.
initially it selects a seed from the seed pool and sets the contracts pre states and block environment recorded in the seed as the starting state for executing the generated test cases.
based on the seed c rysolgenerates the test transaction sequence and instantiates each transaction with concrete input data.
transaction sequence generation.
crysolsupports two strategies to generate the transaction sequence i.e.
transaction insertion and transaction reordering.
when a seed is chosen c rysolincludes the historical transaction from the seed into the initial transaction sequence.
then by strategically inserting new transactions to the initial sequence and re ordering them c rysolgenerates a set of transaction sequences designed to exploit the defects.
for example to exploit the ssr defect c rysolinserts a new attack transaction after the original historical transaction calling the same function with a replayed signature.
to exploit the sf defect crysolreorders the attack transaction to appear before the original transaction enabling the front running use of the signature.
transaction data instantiation.
this process is initiated when c rysolneeds to insert a new transaction into the transaction sequence.
specifically to instantiate the new transaction c rysolneeds to generate three types of concrete data i.e.
the transaction parameters transaction sender and the block environment.
c rysolgenerates these data based on the following three complementary strategies.
crypto specific generation.
crysolemploys a set of crypto specific strategies to generate crypto related transaction parameters.
specifically c rysolanalyzes cryptorelated data dependencies and extracts crypto related parameters that are used as the input of cryptographic operations.
based on the analysis result it strategically instantiates these parameters to exploit cryptographic defects.
for example to exploit the ssr or sf defect c rysolneeds to construct a new attack transaction containing the same signature as the original seed transaction.
to do so it instantiates signaturerelated parameters by preserving their values in the original transactions i.e.
simulating the signature replay while using history based and random strategies to instantiate noncrypto related parameters.
history based generation.
given the security implications of cryptographic operations crypto related functions might operate within a more subtle context.
for example a randomly selected transaction sender might fail to call the crypto related functions due to the specific permission structure the contract initialized.
to better approximate realworld contexts c rysoloffers the ability to instantiate transaction parameters or the transaction sender using values from all historical transactions calling the same function.
random generation.
in line with previous work c rysolinfers parameter types based on the contract abi specification and supports random generation of transaction parameters.
beyond transaction input data crysolalso supports randomly generating the transaction sender and the block environment.
by determining the sequence of transactions and instantiating each transaction with concrete parameter values sender and block environment c rysolgenerates test cases that can be concretely executed to exploit potential defects.
e. defects detection in the last phase c rysolexecutes the generated test cases and analyzes the execution traces for defect detection.
for each test case c rysolinstantiates an instrumented evm with the starting states of the test case and executes the transaction sequence on it.
if the execution violates a pre defined oracle crysolreports the identified defect along with the function containing the defect.
if the transaction involves multiple contracts c rysolalso specifies the contract where the defect occurs by analyzing inter contract calls during the transaction execution.
in the following we describe the detailed oracles used by c rysolto detect each type of defects.
single contract signature replay ssr .
crysol examines the transaction sequence and checks whether it contains a successful signature replay attack.
specifically when a transaction calls ecrecover c rysolsearches for any subsequent transaction in the sequence that calls ecrecover using the same parameters i.e.
replaying the signature.
if the transaction with the replayed signature successfully executes and makes changes to the contract storage c rysolreports a ssr defect.
additionally we found that several token contracts intended to allow token minters to replay signatures and minttokens until they reach the amount limit per address.
to reduce such false positives c rysolidentifies such protective patterns by analyzing transaction execution traces.
cross contract signature replay csr .
crysol records calls to ecrecover during the test case execution and checks whether each signed message includes the address of the contract that verifies the signature.
specifically c rysol taints the return value of opcode address which retrieves the contract s address.
then c rysolmonitors if the taint flows into the hash used in ecrecover hash v r s .
if the signed message does not include the contract s address i.e.
signatures for this contract are not distinguished from those of other contracts c rysolreports a csr defect.
signature front running sf .
crysolexamines the transaction sequence and checks whether it contains signature front running attacks.
specifically c rysolidentifies cases where given an original transaction that calls ecrecover there exists a preceding attack transaction from a different sender that calls ecrecover with the same parameters.
if so c rysolconducts a differential analysis on the execution results of the original transaction and attack transaction.
it executes them based on the same start state respectively and compares the post states after execution.
if the post states differ i.e.
the attacker can make unintended changes to the contracts states c rysolreports a sf defect.
signature malleability sm .
crysolanalyzes whether there is protection against signature malleability.
specifically when encountering a call to ecrecover hash v r s crysolanalyzes the execution trace and checks whether a branching opcode jumpi is executed conditioning on the comparison between sand the constant elliptic curve order secp 256k1 .
if not i.e.
there is no protection against the signature malleability c rysolreports a sm defect.
insufficient signature verification isv .
crysol checks if there is a transaction that calls ecrecover with parameters not used in any historical transactions i.e.
the signature is randomly forged by c rysol.
if the transaction containing the forged signature successfully executes and makes changes to the storage c rysolreports an isv defect.
merkle proof replay mr .
crysolfirst identifies the verification process of merkle proofs based on their operational characteristics.
specifically c rysolchecks whether there is a sequence of hash operations during the transaction execution where the input of the i th hash is the concatenation of the result of the i th hash and a proof element provided as the transaction parameters.
then similar to the detection of ssr when encountering a transaction that verifies a merkle proof c rysolsearches for any subsequent transaction that replays that merkle proof.
if both transactions change the contract s storage c rysolreports a mr defect.
to reduce false positives c rysolidentifies the same protective pattern for token minting as in the ssr defect.
merkle proof front running mf .
the approach crysoluses to detect mf defects is analogous to the approach for sf defects.
given an original transaction that verified the merkle proofs c rysolsearches for any pre ceding attack transaction that preemptively used the same merkle proofs.
then a differential analysis is conducted on the execution results of these two transactions.
if the preceding transaction successfully executes and makes different changes to the contract storage c rysolreports a mf defect.
hash collisions with dynamic length arguments hc .
crysolconducts dynamic taint analysis on the input of each hash operation to detect hc defects.
first it determines which transaction parameters if any serve as input for these hash operations.
then it checks whether these parameters are dynamic length based on the contract s abi.
if the hash input contains the concatenation of two dynamiclength parameters c rysolreports a hc defect.
weak randomness from hashing chain attributes wr .
crysolleverages dynamic taint analysis to check whether the block attributes can affect hash operations.
it first taints the returns of opcodes that acquire block attributes e.g.
number andtimestamp and monitors whether the taints flow into hash operations.
if there is a hash operation that can be affected by chain attributes and the hash result determines a branch jumpi or storage operation sstore c rysol reports a wr defect.
v. e valuation the goal of the evaluation is two fold.
firstly we utilize a large scale dataset containing crypto related smart contracts to evaluate the effectiveness of c rysolin defect detection.
secondly by analyzing the results of this large scale experiment we demystify cryptographic defects in the wild and gain insights into their prevalence and distribution.
a. evaluation setup research questions.
specifically we focus on the following three research questions.
rq1.
what is c rysol s performance on our large scale dataset?
can c rysolfind defects with high precision?
rq2.
how effective of c rysolin finding cryptographic defects in terms of recall?
rq3.
what is the prevalence and distribution of cryptographic defects in real world smart contracts?
dataset.
to answer these research questions we collected a large scale dataset containing real world cryptorelated smart contracts.
specifically using the same method as previous studies we first replayed historical ethereum transactions from block to block from .
to .
and recorded the contracts that called crypto apis.
in total we identified crypto related contracts during the execution of historical transactions.
after that we queried etherscan to collect publicly available source codes and abi information of these contracts.
as a result we found crypto related smart contracts have available source codes and abi information.
among these contracts .
of smart contracts have more than historical transactions suggesting that the majority of smart contracts in our dataset are engaged in real world applications rather than merely being toy contracts.table ii cryptographic defects detected by crysol defect detected sampled tp fp precision ssr .
csr .
sf .
sm .
isv .
mr .
mf .
hc .
wr .
to retrieve contracts historical transactions and states crysolmaintained an ethereum archive node and recorded ethereum on chain raw states for subsequent analysis.
for each contract in the dataset c rysolfetched its historical transactions and states to initialize the fuzzing seed pool.
to ensure efficiency the maximum seed pool size is set to be transactions which is considered adequate to cover common usage patterns of the contracts .
all experiments were conducted on a machine with two intel xeon r platinum 8352v cpus gb ram and running ubuntu .
.
lts.
our datasets experiment outputs and analysis results are all available in the supplementary materials .
b. rq1 detecting defects in the large scale dataset to answer rq1 we ran c rysolon smart contracts and analyzed the results.
c rysoltook .
hours to analyze contracts resulting in an average execution time of .
seconds per contract.
in total c rysolreported that .
contracts contain at least one defect.
table ii shows a breakdown of c rysol s execution results for each defect type.
precision.
to evaluate the precision of c rysolin detecting each type of defects we manually analyzed the defects reported by c rysolduring the large scale experiment.
in line with previous studies we randomly sampled a number of defects for each defect type to make the manual analysis feasible.
the sample size for each defect type was carefully chosen to achieve a confidence level of and a confidence interval of .
the second and third columns of table ii show the detected and sampled number of contracts with each defect respectively.
then two of the authors independently labeled these contracts as true positives tps or false positives fps with the help of the third author to resolve any possible disagreements.
the fourth to sixth columns in table ii present the number of true positives false positives and the precision rate for each type of defect respectively.
we then computed crysol s overall precision as a weighted average of these precision rates with the weight being the number of each defect.
as a result the overall precision of c rysolis .
.
false positives.
after inspecting the false positives reported by c rysol we found that they are mainly caused by the following two factors.
the first is non standard protective patterns in real world contracts.
for example for signature malleability c rysolreported a defect based on whetherthere is a condition that checks if the input sforecrecover hash v r s is less than secp 256k1n .
however we found that some contracts used a non standard protective pattern against signature malleability they set the first bit of sto before using it as the actual input for ecrecover hash v r s thereby ensuring that sis less than secp 256k1n .
the second is the intended behavior of the contracts.
for example for insufficient signature verification crysolchecks whether a transaction with an invalid signature can successfully execute and make changes to the contract s storage.
however we found that some smart contracts do not revert transactions when encountering invalid signatures.
instead they intendedly record the signature verification results on chain and continue to execute.
in such cases the transaction with invalid signatures indeed results in the contract s storage changes letting crysolfalsely report an isv defect.
c. rq2 evaluating crysolon the annotated dataset to answer rq2 we built an annotated dataset and evaluated the recall of c rysolon it.
we have published the annotated dataset and analysis results in our online supplement materials .
recall.
the evaluation of the recall requires a dataset with annotations of true positives and false negatives.
to establish the ground truth we first randomly sampled a number of smart contracts from the large scale dataset and manually annotated them.
specifically in line with previous studies we randomly sampled out of contracts to achieve a confidence interval of and a confidence level of .
then we followed the same labeling process as section v b to manually analyze these sampled contracts.
in total we found defects in these contracts.
after comparing these manual labels and the results given by c rysol we found c rysol reports true positives false positive and false negatives for these contracts which yields a recall of .
.
false negatives.
in detail c rysolfailed to detect one ssr one csr and one wr defect in contracts.
after inspecting these false negatives we found that they are mainly due to the lack of information to properly initialize the fuzzing context.
for example while some smart contracts contain signature verification functionalities such functions are rarely actually called.
consequently c rysolobserved limited semantic information hindering its ability to generate valid test cases for meaningful exploration.
however automatically generating valid crypto related transactions with solely off line analysis is challenging.
in particular cryptographic operations could render common techniques such as concolic testing ineffective since analyzing them results in complex symbolic expressions that cannot be handled by the smt solver .
addressing these challenges is beyond the scope of this paper and is left as potential future work.
d. rq3 characterizing cryptographic defects in the wild while demonstrating the effectiveness of c rysol our large scale experiment also provided a first close look at cryptographic defects in real world smart contracts.table iii the statistic metrics of defective contracts type prop.
loc avg func avg eth avg txn avg ssr .
.
.
.
csr .
.
.
.
sf .
.
.
.
sm .
.
.
.
isv .
.
.
.
mr .
.
.
.
mf .
.
.
.
hc .
.
.
.
wr .
.
.
.
total .
.
.
.
prevalence and distribution of cryptographic defects.
the first column of table iii presents the proportion of defective contracts regarding each defect type.
among nine types of defects wr csr and sm are the most common occurring in .
.
and .
of the analyzed smart contracts respectively.
while the remaining six defect types are less common appearing in about or less than of contracts the total number of contracts affected by them is still considerable.
such results provide real world evidence for the findings of zhang et al.
which suggest a lack of understanding of crypto specific secure practices among smart contract developers.
note that a contract with cryptographic defects indicates deviations from best practices in cryptographic implementations.
while defects may not directly lead to security issues they can undermine the contract s maintainability and increase the risk of future security vulnerabilities.
for instance the csr defect might not initially cause security problems when only one contract verifies the authorizer s signatures.
however if the system evolves and multiple contracts start using the same authorizer s signatures for managing sensitive operations this defect can directly enable cross contract signature replay attacks.
a more detailed analysis of these cases is provided in our online supplementary materials .
contracts with cryptographic defects.
to better understand cryptographic defects in the wild we analyzed the average lines of code number of external public functions ether balances and transaction counts of defective contracts and presented them in columns three to six of table iii.
the result shows that contracts with mr and mf defects are generally more complex than others likely due to the inherent complexity of merkle proofs and their applications such as reward distribution.
furthermore contracts with ssr csr sf sm and isv defects are more frequently called by realworld transactions indicating a broader influence associated with signature related defects.
vi.
d iscussion a. mitigations for cryptographic defects during the evaluation we found that cryptographic defects are commonly caused by the direct use of low level crypto apis without necessary protection.
therefore in addition to introducing c rysol we provided possible solutions for eachtable iv possible solutions for cryptographic defects type possible solution ssr include a monotonic increasing nonce into the signed message csr include the contract address into the signed message sf prevent front run signatures from causing unintended behaviors sm add protection against ecdsa signature malleability isv check the return value of ecrecover before sensitive operations mr check if the merkle proof has been used before accepting it mf prevent front run merkle proofs from causing unintended behaviors hc use collision resistant encoding to hash dynamic length variables wr use verifiable random function vrf for randomness type of defect in table iv.
these solutions are summarized from the standard practices outlined in official ethereum improvement proposals eips and defect remediation recommendations in security reports .
for example fig.
shows a fixed version of the defective contract in fig.
.
it comes from a standard template provided by openzeppelin which employs the above solutions to prevent ssr csr and sf defects.
it integrates a nonce in the signed message to prevent ssr defects line .
it also includes a domain separator containing the contract address into the signed message to prevent the csr defects line .
furthermore to address sf defects it replaces the address to be approved line in fig.
and line in fig.
from msg.sender to the spender specified by the signature line .
it ensures that even if an attacker front runs the signature he cannot change the intended contract behavior i.e.
owner approving spender for a certain value of tokens.
in the supplementary material we provide more realworld examples to demonstrate how these solutions are applied to prevent cryptographic defects in practice.
1function permit address owner address spender uint256 value uint256 deadline uint8 v bytes32 r bytes32 s public virtual if block .timestamp deadline revert erc2612expiredsignature deadline bytes32 structhash keccak256 abi.encode permit typehash owner spender value usenonce owner deadline bytes32 hash hashtypeddatav4 structhash address signer ecdsa.recover hash v r s if signer !
owner revert erc2612invalidsigner signer owner approve owner spender value fig.
.
fixing defects in fig.
b. threats to validity and limitations threats to validity.
in the experiment we employed random sampling to evaluate the effectiveness of c rysol which might introduce potential sampling bias.
to reduce the impact we carefully selected the sampling ratio and size to achieve a confidence level of and a confidence interval of which is considered sufficient in previous studies .
additionally we manually labeled true false positives and negatives of the sampled contracts which could potentially lead to labeling mistakes.
to mitigate this threat we employed a double check process conducted by authors with more than three years of research experience in smart contract security.
limitations.
despite c rysol s strengths it might have the following potential limitations.
first c rysolrelies on pre defined oracles to detect defects which might not cover newly emerging defects beyond the existing nine categories of cryptographic defects.
however given that these defined defects are derived from up to security reports from security teams and involve all common on chain cryptographic tasks we believe c rysoleffectively captures common cryptographic defects in existing smart contracts.
its framework also allows future studies to easily incorporate new defects.
second crysolrelies on on chain information to guide the fuzzing process.
in scenarios such as analyzing undeployed smart contracts such information might not be directly accessible.
however internal testing conducted before contract deployment such as acceptance testing on local testnets typically covers the main usage patterns of the contracts.
utilizing these test transactions c rysolcan extract necessary information and detect defects before deployment.
vii.
r elated work a. defining and detecting defects in smart contracts due to the recurring security incidents a substantial body of research has been dedicated to defining and detecting defects in smart contracts .
luu et al.
took the first close look at smart contract security and proposed oyente to detect four types of defects in smart contracts.
chen et al.
defined types of contract defects through the analysis of stack exchange posts and real world smart contracts and proposed a tool to detect them .
liu et al.
studied access control bugs in smart contracts and detected them by dynamically role mining and conformance testing.
however they mainly studied general programming defects such as reentrancy rather than crypto specific defects we focused on.
for example liuet al.
focused on defective access control policies rather than cryptographic defects that compromise the access control.
ye et al.
introduced a fuzzing tool to detect state inconsistency bugs which utilizes contextual information collected from on chain transactions to guide the fuzzing process.
while there is a lack of academic research on cryptographic defects several defects we defined have attracted attention from the industry .
to our knowledge the smart contract weakness classification swc list has the most overlap with our categorization which includes only four of nine defects we defined.
specifically swc documents weaknesses caused by single contract cross contract signature replays involving ssr and csr defects.
swc133 and swc are analogous to hc and sm defects respectively.
while the swc list documents these defects it does not provide practical detect patterns or tools for their detection.b.
cryptographic defects in traditional software cryptographic defects have become a common cause of security issues in software .
lazar et al.
analyzed crypto related security incidents in the cve database and found of them were caused by cryptographic defects introduced by developers non standard practices.
egele et al.
summarized six common cryptographic defects in android applications and proposed a tool to detect them.
they found that of android applications that use cryptographic functionalities contain at least one defect.
hazhirpasand et al.
found that .
of github projects using java cryptography architecture jca apis contain at least one defect.
however these studies mainly focus on cryptographic defects in traditional software.
our results reveal differences between cryptographic defects in smart contracts and those in other well studied software i.e.
java applications in terms of both definition and detection.
firstly due to the differences in common cryptographic tasks the definition and categorization of defects in smart contracts differ inherently.
for example encryption related defects are the most common in java but smart contracts rarely implement encryption hence do not have these defects.
secondly the detection methods also differ.
in java defects often arise from direct api misuses such as passing incorrect parameters to jca apis and can be efficiently detected by static analyzers .
however detecting smart contract defects like ssr involves analyzing multiple transactions interacting with a stateful contract making existing detection techniques difficult to apply.
viii.
c onclusion in this paper we conducted the first study aimed at understanding and uncovering cryptographic defects in smart contracts.
through the analysis of security reports we proposed the first classification of cryptographic defects in smart contracts.
it encompasses nine distinct defect types and covers a wide range of cryptographic tasks in smart contracts.
to demonstrate these defects in real world applications we presented c rysol a fuzzing based tool for cryptographic defect detection.
it collects fine grained crypto related semantics based on transaction replaying and dynamic taint analysis and incorporates crypto specific fuzzing strategies for test case generation.
the evaluation results indicated that c rysolcan effectively detect real world cryptographic defects with an overall precision of .
and a recall of .
.
furthermore crysolrevealed that .
out of cryptorelated smart contracts contain at least one cryptographic defect demonstrating their prevalence in real world cryptographic practices.