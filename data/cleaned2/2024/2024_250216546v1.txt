decoding the issue resolution process in practice via issue report analysis a case study of firefox antu saha william mary williamsburg virginia usa asaha02 wm.eduoscar chaparro william mary williamsburg virginia usa oscarch wm.edu abstract effectively managing and resolving software issues is critical for maintaining and evolving software systems.
development teams often rely on issue trackers and issue reports to track and manage the work needed during issue resolution ranging from issue reproduction and analysis to solution design implementation verification and deployment.
despite the issue resolution process being generally known in the software engineering community as a sequential list of activities it is unknown how developers implement this process in practice and how they discuss it in issue reports.
this paper aims to enhance our understanding of the issue resolution process implemented in practice by analyzing the issue reports of mozilla firefox.
we qualitatively and quantitatively analyzed the discussions found in firefox issue reports to identify the sequences of stages that developers go through to address various software problems.
we analyzed the sequences to identify the overall resolution process at firefox and derived a catalog of patterns that represent instances of the process.
we analyzed the process and patterns across multiple dimensions including pattern complexity issue report types problem categories and issue resolution times resulting in various insights about mozilla s issue resolution process.
we discuss these findings and their implications for different stakeholders on how to better assess and improve the issue resolution process.
i. i ntroduction issue management is a fundamental process that aims to track and manage the code changes needed to address issues during the maintenance and evolution of a software project.
issue trackers are essential tools that provide the infrastructure to implement issue management .
such systems provide a platform for documenting software issues facilitating discussions among stakeholders and tracking the work and progress of solving the issues .
the issue management process assisted by issue trackers typically involves steps such as issue understanding triage replication and analysis as well as issue fixing a.k.a.
issue resolution .
issue resolution is a subprocess of issue management that aims to diagnose and resolve the reported problems.
according to existing literature the typical issue resolution process includes steps such as issue reproduction problem investigation solution design solution implementation and validation verification which are sequentially applied to solve issues.
however while this process is meant to be generally applied to any software issue it is unclear how developers implement it in practice for different problems and contexts and how developers discuss it in issue reports.understanding the issue resolution process implemented in practice is important for improving software maintenance and evolution processes.
by gaining insights into how developers address software problems we can identify bottlenecks and anomalous process implementations align prescribed processes with actual practices and provide developers with better guidance for issue resolution.
additionally studying issue resolution can help identify common patterns and strategies that can be applied to similar problems in the future and confirm the extent to which the implemented process deviates from the typical linear resolution process from the literature.
this paper aims to enhance our understanding of the issue resolution process implemented in practice by identifying and analyzing the sequence of steps i.e.
stages that developers perform and discuss in issue reports when solving issues.
to that end we conducted a case study on mozilla firefox a mature and widely used open source project.
combining qualitative and quantitative methods we analyzed the discussions present in a sample of firefox issue reports to identify the stages of issue resolution that firefox developers engage in the sequences of stages that issue discussions form recurrent transitions between stages present in the sequences the overall issue resolution process implemented at firefox and the recurrent instances of this process to solve a variety of problem types reported in different issue reports.
using a multi coder iterative open coding methodology we identified six issue resolution stages e.g.
issue reproduction solution design implementation and code review .
the stages appear in issue reports with varying frequencies across different issue types defects enhancements and tasks and problem categories e.g.
crashes ui issues and code improvements and form sequences that represent particular instances of the resolution process at firefox.
the stage sequences reveal frequent relationships among stages particularly between issue reproduction and analysis among solution design implementation and code review and among implementation code review and solution verification.
additionally based on analysis of consecutive stages appearing in the sequences i.e.
bi grams we identified the most common transitions between stages and derived the overall issue resolution process at firefox from them.
such a process is primarily iterative deviating from the theoretical linear process found in the literature and firefox s documentation.
in this process developers go back and forth from one 1arxiv .16546v1 feb 2025stage to another as needed to solve the issues.
finally utilizing qualitative analysis of the sequences we identified issue resolution patterns that represent recurrent instances of the overall process of solving different types of problems.
two mozilla developers assessed the usefulness of the patterns identifying potential use cases to enhance firefox s resolution process.
our study provides evidence of the iterative and diverse nature of the issue resolution process which widely deviates from the theoretical linear process from the literature.
our methodology stage sequences and patterns serve to identify potential anomalies in the way firefox developers implement the resolution process.
our pattern catalog and results can help educate future developers and train newcomers at firefox in the intricate process of issue resolution.
finally we advocate for developing advanced tooling to assist developers in recording issue resolution activities more easily as this can have great benefits for traceability process assessment code change rationale management and more.
in summary this paper makes the following contributions a model of firefox s issue resolution process implemented in practice derived from qualitative and quantitative analysis of issue report discussions.
a novel catalog of patterns of issue resolution derived from qualitative analysis of issue discussions.
the patterns represent instances of firefox s resolution process employed by firefox developers to address different types of software problems.
a comprehensive analysis of the derived process and patterns across different types of issues and problem categories showing that firefox s issue resolution is a diverse and iterative process which deviates from the prescribed linear process from the literature.
a novel dataset with annotated issues and related artifacts that enables further research in this area.
we publicly release this data and the derived catalog scripts and other artifacts useful to validate and replicate our study .
ii.
b ackground problem and motivation a. issue management during software evolution issue management aims to track and manage all the change requests of a software system including new feature developments non functional implementations defect corrections and enhancements to existing functionality .
issue trackers such as bugzilla jira and github issues are communication and social platforms that allow coordination among different stakeholders around the process of issue management .
issue reports are the main artifacts created and used during issue management and typically include an issue title a detailed issue description metadata e.g.
issue severity and priority operating platform and product versions affected by the issue and attachments e.g.
system logs and screenshots .
during the process of managing and solving the issues stakeholders change the status of the issues e.g.
from assigned toresolved and from verified toclosed and engage in discussions when needed.
these discussions are recorded inissue comments which document relevant information about the reported problems including possible circumstances in which the problem occurs potential causes how the code should be changed to address the issue and more.
b. issue resolution within the issue management process the literature has defined the different phases that compose the issue management process.
zhang et al.
report three major phases issue understanding triaging and fixing a.k.a.
issue resolution .
in the first step triagers read and understand the report to determine the issue type priority and severity.
in the second step the triagers assign the issue to an expert developer.
finally in the issue resolution phase the assigned developer locates the code that needs to be changed in response to the issue and implements the desired code change.
k. saha et al.
define similar phases including a fourth phase called issue verification in which a developer verifies that the code change indeed addresses the issue and conforms with the quality standards.
zeller includes issue reporting duplicate report identification and fix delivery as part of the issue management process.
zeller also decomposes the issue resolution phase for bug reports into multiple steps bug reproduction isolation and localization and fix implementation.
rajlich defines software change as a general process to modify and evolve software systems based on change requests.
rajlich defines seven phases of software change initiation concept location impact analysis actualization refactoring verification and conclusion.
initiation includes prioritization of change requests.
all these phases except for initiation and conclusion are part of issue resolution which aims to analyze and implement the solution to an issue.
in this paper we investigate how developers perform issue resolution a critical sub process of issue management that aims to diagnose and solve the reported problems .
this issue resolution process includes reproducing the reported bugs for bug reports understanding and analyzing the issues designing a solution to the issue implementing the solution and validating verifying the quality of the implementation.
c. the issue resolution process implemented in practice although the issue resolution process includes different activities as discussed above it is unclear how this process is implemented in practice to address different kinds of issues under various operating circumstances.
as we discuss in the related work section section vii prior work has focused on studying different aspects of issue reports and their management including the overall issue management process based on issue status transitions but no prior work has studied in detail the process that developers implement in practice to analyze and solve issues.
we fill in this knowledge gap by analyzing issue discussions and studying patterns of issue resolution .
we motivate our work by discussing two examples of issue resolution at mozilla firefox .
issue report describes a buggy behavior in the way firefox renders a web page when the user hovers over html buttons on a page firefox draws a border around the button.
the issue report 2contains rich information in the issue comments that help us understand the process followed to solve this issue.
at first developers reported multiple bug reproduction attempts asking for additional information from the reporter.
after it was successfully reproduced the developer assigned to solve the issue posted the result of his investigation describing the potential problem location and cause.
the developer then attached two fixing patches describing the root cause the solution and the potential impact of the solution on the system.
the patches were reviewed by another developer and after the original developer corrected a few problems the code reviewer inspected and approved the implementation.
the code change was then integrated into mozilla s code base the reporter verified the fix and a triager closed the issue.
another example is issue which describes a failure in firefox s cross platform component that handles ui rendering.
the issue states that some buttons in firefox s toolbar customization ui become invisible when switching to a dark theme.
the reporter is a qa member who identified a prior commit and issue that could have introduced the bug via mozilla s mozregression tool .
the developer responsible for that prior commit and issue assigned to solve the issue provided a patch with the description of the code change to correct the defect.
another developer reviewed the code change via the phabricator code review tool and a qa member then successfully verified the solution marking the issue as verified andfixed .
both examples illustrate different ways to resolve bugs related to firefox s web page and ui rendering.
in the first example we observe all the expected major steps of issue resolution however in the second example the process did not include any issue reproduction and analysis.
in both cases these issue resolution steps were performed by different stakeholders recording the activities and the relevant information obtained during the issue resolution.
while the nature of the problems might have been different it is clear that the issue resolution process that we would expect from theory can be implemented and recorded in issue reports in different ways.
our goal is to investigate these different approaches and determine if there are recurrent patterns in the process of solving different kinds of issues.
we do so by qualitatively analyzing the discussions that developers document in issue reports.
d. the issue resolution process at mozilla firefox we selected mozilla firefox as the subject of our study because it is a mature and widely used project with years of evolution and it has well documented practices for issue management and software development e.g.
patching code quality testing and debugging which allow us to understand firefox s issue resolution process in detail.
mozilla firefox is a multi language multi platform open source project that uses bmo an adapted version of the bugzilla issue tracker to manage all the changes made to firefox s source code .
all of firefox s code changes are documented in issue reports by end users community members qa members and develop ers during system usage testing and analysis .
firefox has three issue report types defects enhancements i.e.
userfacing improvements and tasks i.e.
back end improvements .
these issues are triaged differently by a rotating group of engineering managers who are owners of a firefox component and by qa members .
these members assess the issues and assign a correct issue type severity priority target release and other metadata e.g.
security flags to better prioritize and manage the problems.
qa members component owners and developers are in charge of determining the resolution state of the issues e.g.
resolved won t fix orverified fixed .
the open nature of the project makes firefox s software development and in particular issue resolution a worldwide and distributed process.
developers are assigned to issues and work on one or more patches to address the problems.
for diagnosing and solving defects firefox provides guidelines for using various debugging tools across different platforms .
once the patches are completed they are attached to the issue reports requiring a code review through the phabricator tool .
the tool posts comments on issues whenever a code review is submitted.
the code reviewer is mainly a component owner or peer a newcomer mentor and or any other developer familiar with the modified code or module .
the patch is tested in try a system for running automated tests without integrating patches into firefox s code base.
once the patches are approved they are integrated a.k.a.
landed by the code reviewer into the autoland repository where regression tests are executed .
once the tests pass and the code changes are further validated verified by the qa team they are merged by code sheriffs into mozilla central firefox s main development repository .
merging into mozilla central occurs periodically or on demand e.g.
when critical security fixes are validated .
during the resolution process the status of the reports is updated accordingly e.g.
from assigned toverified and fixed .
information relevant to the issue e.g.
failing regression test results obtained at any moment during the process may be posted as an issue comment.
for example failing regression test results are posted in the issues.
code changes in mozillacentral are integrated into mozilla beta for additional quality assurance during a four week beta cycle.
after this a release candidate build is generated tested thoroughly and made available as the next version of firefox .
iii.
s tudy methodology this study aims to investigate how the issue resolution process is implemented in practice at mozilla firefox to solve various software problems and tasks described in issue reports.
we investigate the major stages of the issue resolution process described in section ii b and how developers1follow them to solve a variety of problem categories e.g.
crashes ui issues or refactoring changes reported in various issue report types defects enhancements or tasks .
the study addresses the following research questions rqs 1we hereon use developers to refer to all stakeholders involved in issue resolution programmers reporters qa members etc.
3rq what issue resolution stages are found in issue reports?
rq how do the resolution stages interact with each other?
rq what is the overall process of issue resolution?
rq what resolution patterns are found in issue reports?
rq what are the potential use cases of the patterns?
rq 1investigates the major stages that mozilla developers go through to address reported issues and how frequently these stages are discussed in issue reports.
rq 2investigates how these stages interact with one another including how frequently these stages co occur in issue reports.
rq 3investigates the overall issue resolution process at mozilla firefox.
rq investigates recurrent instances of the resolution process expressed as sequences of stages.
rq5examines the potential applications of the derived patterns for mozilla developers.
a. issue collection mozilla s bmo is the centralized system for managing the issues of firefox desktop and mobile .
in this study we focused on the desktop version of mozilla firefox studying the issues of its two main components firefox andcore .
the firefox component a.k.a.
product in bmo implements the graphical user interface gui of the web browser while the core component includes essential functionality such as web page rendering web browsing and networking services.
our study focused on fixed andresolved issue reports for the selected components.
to obtain recent issues within a significant period of system evolution we downloaded all the issues created from january 1st to april 30th using bugzilla s api including their title summary comments which contain the issue description and relevant metadata creation time resolution time and others.
from downloaded issues .7k .5k for core firefox we randomly sampled issues for analysis.
this is a statistically significant sample at a confidence level and error margin that captures the diversity and characteristics of the entire population of core andfirefox issues.
this is evidenced by comparing our sample and the entire issue population in terms of the proportion of issue types defects .
vs .
enhancements .
vs .
and tasks vs .
the proportion of issues per product core .
vs .
and firefox .
vs .
average of comments per issue .
vs .
and average resolution time vs days .
the issues contain .
comments .
paragraphs and .
sentences on average median .
b. issue annotation goals and overview we qualitatively analyzed all the information provided in the issues annotating textual content related to issue resolution by employing an iterative open coding methodology .
the annotation process was conducted by six ph.d. students and one professor a.k.a.
annotators including the authors of this paper.
the annotators have years of research experience particularly in qualitative text analysis and five of them have years of industry experience.
the annotation targeted all the textual content written by different stakeholders in issue comments and aimed to identify themes orcodes about different activities performed to resolve the issue e.g.
reproduction attempts or a code review and the types of problems described in the issues e.g.
crashes ui issues etc.
which we call problem categories .
annotation tool and unit we used the hypothesis annotation tool to directly annotate the web pages of the issue reports.
the tool allowed us to collaboratively assign codes to text snippets in the issue threads modify the assigned codes and discuss the annotations.
we coded text snippets in the issue comments.
the minimal annotation unit was a complete sentence.
since one or more sentences may convey the same type of information i.e.
a given resolution activity the annotation included individual sentences multiple sentences paragraphs or even entire comments.
a single textual snippet was allowed to be coded with one or more codes.
code catalog and coding guidelines we maintained a code catalog via a google spreadsheet shared among the annotators.
the catalog included a list of codes code descriptions rules to apply the codes and text snippets from annotated issues used as examples.
the code catalog also included a list of problem categories with detailed definitions and examples of annotated issues.
we also maintained a shared google document with detailed guidelines of the annotation procedure coding rules and necessary resources for annotating the issues e.g.
official mozilla documentation to get familiar with firefox s resolution process and a glossary of annotation terminology .
both the catalog and guidelines were built from scratch and developed by all the annotators incrementally and collaboratively.
annotation procedure we adopted an iterative multicoder open coding methodology wherein each issue report was annotated and validated by at least two annotators.
the issues were distributed evenly among the seven annotators who iteratively examined annotated and validated the issue comments in batches of issues.
the first annotator assigned codes to text snippets in the comments and a second annotator reviewed these annotations for accuracy and completeness.
discrepancies were resolved in reconciliation sessions.
annotator roles alternated across batches with each person either annotating from scratch or reviewing the annotations by the first annotator.
to avoid fatigue and reduce potential mistakes the annotators annotated small sets of issues with breaks in between.
the overall process for a single issue involved the first annotator thoroughly reviewing the issue including attached patches linked commits and metadata e.g.
issue commentators tags and status to identify annotate relevant content and the problem category.
codes were assigned based on the content s meaning and the code catalog.
the second annotator then reviewed these annotations verifying their accuracy suggesting additional codes or flagging mistakes.
after processing a batch both annotators discussed disagreements to reach a consensus.
to establish the initial coding framework two researchers annotated the first batch of issues creating an initial set of codes and problem categories.
these were refined through discussion sessions resulting in complete definitions examples and rules for applying the codes.
this initial annotation 4informed the creation of the coding guidelines which included resources for understanding issues and general annotation rules.
before annotating the remaining issues training sessions were conducted with the other annotators to review the coding guidelines discuss examples from the initial batch and solve misunderstandings.
throughout the entire annotation process the code catalog was continuously updated with changes such as new codes code merges or renames collectively agreed upon and promptly communicated.
when the catalog was updated previously coded issues were revisited to ensure consistency.
regular communication via zoom meetings and slack discussions was essential to maintain the accuracy and uniformity of the catalog and annotated content.
annotation results and inter coder agreement during the annotation process issues that were pull requests pr automatically created by the issue tracker were discarded.
in summary we annotated textual snippets in issue comments across issue reports.
the annotation process resulted in issue resolution codes and problem categories which we further grouped into problem classes .
tables i and ii show examples of these elements our replication package contains the full catalog of codes and problems .
the annotators agreed on annotations with an agreement rate of and a cohen s kappa of .
which indicates a high overall agreement .
common sources of disagreement text snippets included misunderstandings due to ambiguous comments or unclear code definitions.
if both annotators were unable to reach an agreement a third annotator reviewed the issue to resolve the conflict.
c. inferring and analyzing issue resolution stages the codes obtained from the issue report annotation represent the information about activities performed by developers during issue resolution.
we implemented two steps for inferring the issue resolution stages from the annotation codes.
in the first step we qualitatively analyzed the code catalog and annotated issues and identified codes i.e.
actionable codes that signified specific actions performed to directly address the problems e.g.
reproducing the problem or implementing a solution as a code change .
in the second step we engaged in an analysis of issues codes and a discussion to categorize the codes for inferring issue resolution stages .
the first step was necessary because of the codes were either requests to perform an action not an action in itself or cross cutting actions which can be performed at any stage of the resolution process.
solution review request is an example of a request which represents a petition made by a developer to another one to review a proposed solution to the problem.
solved by other issue is an example of a crosscutting code that represents an issue resolved in another issue.
based on the qualitative analysis we identified six different issue resolution stages namely reproduction r anal ysis a solution design sd implementation i code review cr and verification v .
each stage is represented by one to five actionable codes each code belonging to a single stage.
examples of codes for the analysis stage a table i issue resolution stages stage description annotation codes of issues reproduction r developers attempt to reproduce the issue.rep att .
analysis a developers analyze the issue by reviewing the problem identifying the problem cause or locating the relevant code.prob loc prob rev caus ident134 .
solution design sd developers discuss how to solve the issue i.e.
propose a potential solution or review a proposed solution.pot sol des sol rev150 .
implementation i developers make the necessary code changes to resolve the issue.code impl .
code review cr developers review the implemented code changes.code rev .
verification v developers verify the solution by testing the implemented code changes.sol ver uplift aprv impl rev col prob ana col pot sol146 table ii problem categories and classes problem class problem categories examples of categ.
of issues implementation ui issue feature development crash refactoring code improvement unnecessary code removal testing test failure test update flaky tests are problem localization and cause identification .
table i shows all the stages with their description and codes.
to answer rq1 we analyze the frequency in which the six stages appear in the issue reports across different report types and problem classes and categories.
d. analysis of stages sequences and process inference when the identified stages are aggregated in the order in which codes appear in the issue report i.e.
chronologically they create a sequence of codes which we can then examine to understand the process adopted to resolve the issue.
for example issue s annotation code sequence is code implementation code review code review code review .
we created a stage sequence by utilizing the code sequence and the code stage mapping for each issue.
for example for the above code sequence of issue the derived stage sequence is i cr cr cr which we simplified as i cr by merging consecutive repeating stages.
this process was applied to all the issues.
to answer rq2 we counted the bi grams and tri grams appearing in the stage sequences as well as the number of issues where these n grams appear.
bi grams are pairs of consecutive stages while tri grams are triplets of consecutive stages in the sequences.
we also analyzed the frequency with which the stages appear at the beginning or end of the sequences.
to answer rq we constructed a graph representing the overall issue resolution process where the nodes correspond to the stages and the edges represent the transitions between stages.
this graph was constructed based on the most frequent bi grams found in the sequences and serves to validate the patterns of issue resolution we derive as part of rq see section iii e .
e. inferring issue resolution patterns to answer rq we engaged in a qualitative analysis of the stage sequences and derived issue resolution patterns by grouping similar stage sequences into coarse grained sequences.
the derived patterns correspond to instances of the derived issue resolution process in rq .
pattern notations to communicate the issue resolution patterns clearly and analyze them in different dimensions we represent the patterns as a string based on three notations a?indicates that stage a is optional a b indicates that either a or b or both stages appear a b ... z indicates that stages a b ... and z appear more than once and at least one subsequence of two or more stages a b or b z or a b z etc.
appears more than once.
deriving issue resolution patterns at first we identified the stage sequences where the 3rd notation a b ... z is applicable and created issue resolution patterns for those stage sequences applying the notation.
for example issue with the stage sequence i cr i cr i cr v i v hasi cr andvappearing more than once and the sub sequence i cr appears more than once.
hence the sequence can be collapsed to create the issue resolution pattern i cr v .
with this notation the order of the stages does not matter.
second we created groups of stage sequences that differ only by one or two stages in order and qualitatively analyzed each sequence to understand the differences among the sequences.
we aimed to represent the sequences using the first two notations i.e.
a?
and a b to form a coarse grained sequence.
for example issues and have the stage sequences sd i cr sd i cr i and sd i cr v respectively.
here all three stages sd i and cr are included in the three issues.
however the sequences only differ by the last stage iorvis present for the last two issues while it is not present in the first one.
hence we can create a common pattern for these three issues i.e.
sd i cr i v ?
which will represent all three sequences.
we meticulously created this grouping by considering several factors e.g.
the of issues per sequence the presence of unique stages per sequence and the issue resolution process of each issue in the group so that we would not lose information or create any misleading sequence that does not represent the actual resolution process.
for example we could create a group for the sequences iandi cr by making cr as an optional stage i.e.
i cr?
.
however the first sequence is found for issues and the second sequence is found for issues which implies these two sequences are already widely used and can represent two distinct ways of issue resolution.
in the first sequence no cris performed whereas in the second it is performed to resolve the issue.
hence we did not create a group from these two sequences.
in all qualitative steps one researcher qualitatively analyzed the issue and made necessary changes by documenting the rationale behind each change which was reviewed and validated by the second researcher.
both researchers continuously discussed the patterns and solved any disagreements.
pattern derivation results and pattern categorization our analysis resulted in distinct issue resolution patterns the most frequent patterns are shown in table iii.
the patterns contain stages and appear in issues .
issues on average .
the more unique stages and the more interacting stages a pattern has the more complicated a pattern is.
we arguethat the complexity of a pattern reflects the effort developers invest in resolving an issue which can be quantified by the number of stages in the sequences associated with the pattern.
therefore we categorized the patterns as simple orcomplex based on the average number of stages in their sequences.
since the distribution of these averages is not skewed see our replication package for the distribution the mean serves as a threshold for classification.
specifically the process involves calculating the average number of stages pa for each pattern determining the overall mean across the patterns t .2stages and classifying a pattern as complex if pa t or simple if pa t. in section iv d we discuss the pattern catalog and compare it with the derived process from rq 3to answer rq .
f .
investigating potential use cases of the derived patterns to answer rq we conducted semi structured interviews with two mozilla developers aimed to gather detailed feedback from them on the usefulness of the resolution patterns.
the interviews were conducted over zoom for minutes and were structured into four sections participant s background participants were asked to share their background and experience in software development and issue resolution at mozilla and other companies.
mozilla s issue resolution process participants were asked to describe mozilla s issue resolution process both prescribed by mozilla and implemented by developers as well as the specific approaches they follow.
research presentation the research team presented the study s goals methodology and findings including the identified patterns.
participants were encouraged to ask questions about the patterns and findings.
question answering participants were asked questions that prompted for feedback on the identified patterns with a focus on understanding their potential benefits for mozilla.
follow up questions were asked when additional information was needed.
the interview questionnaire protocol and anonymized responses are found in our replication package .
finding participants our target population consisted of mozilla stakeholders with experience in issue resolution.
to identify potential participants we explored the developers profiles from mozilla research s website linkedin mozilla s issue tracker mozilla s forums and matrix .
we created a shortlist of potential participants all of whom were invited to participate via email.
participants background two developers responded to our call and participated in the interview i.e.
referred to as d1 and d2 .
they are current mozilla developers with to years of experience at the company.
they have extensive issue resolution experience having resolved around .4k issues and contributed to approximately 19k issues in total.
response analysis we recorded and transcribed the interviews using zoom to facilitate response analysis.
we corrected inaccuracies in the transcripts e.g.
misspellings incorrect phrases and punctuation.
using the revised transcripts one author analyzed and grouped the participants answers to each question into themes representing use cases of the patterns.
6a second author reviewed the answers and themes for accuracy.
misinterpretations were resolved through discussion.
iv.
r esults a.rq1 issue resolution stages table i lists the six identified issue resolution stages and reveals that not all issue reports include all stages indicating that firefox developers do not go through these stages do not need to discuss them in the reports or discuss them in other systems or artifacts e.g.
instant messaging tools .
we discuss the stages starting with the most frequent ones.
implementation this stage is frequently performed and discussed in .
of the issues which is expected as firefox s issue tracker is integrated with the version control system mercurial .
among the issues not including any implementation issues were resolved in other issues two issues were resolved by updating libraries in the host operating system and the remaining issue was closed after more than four years of being open because the issue was no longer valid.
code review this stage is also frequently performed and discussed in .
of the issues which is expected as firefox s issue tracker is integrated with firefox s code review tools e.g.
phabricator .
while code review is frequently discussed it is not found in .
of the reports especially in defect reports.
we found that defects are the least discussed with code review .
compared to enhancement and task reports .
and .
.
phabricator adopted in replaced mozreview and splinter and became firefox s only code review tool.
analysis shows that of defects resolved in or before lacked code review compared to only after .
we found that post issues without code review do not include code changes as the issues were resolved in other issues.
verification this stage covering manual and automatic testing appears in only of issues.
it is less common in task reports .
than in defect and enhancement reports .
and .
.
refactoring and testing issues include verification less often .
and .
compared to implementation related issues .
.
categories like code improvement test failure code design and performance optimization have few verification discussions while crashes feature dev.
.
and ui issues .
show higher inclusion.
this indicates still low verification discussions in the issues and this is consistently found every year.
analysis and solution design the analysis and solution design stages are infrequently discussed appearing in only .
and .
of the issues respectively.
defects are analyzed more frequently i.e.
analysis in .
of defects compared to enhancements and tasks .
with crashes flaky tests incorrect page renderings and test updates being the most analyzed defects.
solution design is more common in enhancements .
and defects .
than in tasks .
.
refactoring issues are the least analyzed .
compared to implementation .
and testing related issues .
.
reproduction reproduction is the least frequent stage appearing in only .
of issues with just of defects including it.
this suggests that firefox stakeholders rarely discuss bug reproduction in issue reports.
we observed that reproduction is included when bugs are difficult to reproduce or when reproduction is necessary to identify the root cause or localize the bug.
the first scenario typically leads to more effort in solving the issues compared to defects without reproduction defects with reproduction take longer to resolve avg med .
.
vs. .
.
days and involve more commentators avg med .
vs. .
.
this is validated by a mann whitney u test with .
with p values nearly .
the second scenario is supported by the data of the issues with reproduction include analysis .
rq1findings the six stages of issue resolution found in firefox issue reports appear with varying frequency across different issue reports and problem categories.
implementa tion and code review are the most frequent stages while reproduction is the least frequent.
b.rq2 interactions between issue resolution stages we examined the stage sequences obtained in section iii d by analyzing the frequency of stage bi grams and tri grams in the sequences.
bi grams are pairs of consecutive stages s t in a sequence which represent possible stage transitions s t in the resolution process.
in our data we found all possible bi grams between stages except for cr r and five extremely rare transitions appearing only once or twice i r v r r cr and r v. all these transitions include reproduction r as the source or target stage.
of the bi grams found in the sequences nine are the most recurrent covering .
of the bi gram occurrences i cr cases cr i sd i cr v i v v i a i a sd and cr sd .
from these transitions we observe the interplay among implementation code review and verification in which implementation undergoes quality assurance activities and these also lead to additional code changes or to solution design see cr sdabove .
solution design sd can lead to code changes and analysis a can result in code changes or solution design activities.
notably while a randr aare not among the most frequent bi grams they appear in .
and .
of the issues containing both stages .
this further supports our finding that analysis and reproduction typically occur together.
the analysis of tri grams sets of three consecutive stages in a sequence s t u not only provides extra evidence of the interplay among implementation code review and verification but also the relationship among analysis solution design implementation and code review .
of tri grams found in the sequences are the most frequent covering .
of the tri grams with the following three being the most frequent i cr i occurrences in issues cr i cr occurrences in issues and sd i cr occurrences in issues .
7rq2findings firefox s developers switch among different resolution stages to solve issues.
stage bi gram and tri gram analysis reveal that developers frequently engage in three scenarios reproducing the issues r along with issue analysis a to confirm the issues and reason about them analyzing the issues a along with solution design sd and then engaging in implementation i and code reviews cr and inspecting cr and verifying the implemented solution v adapting the implementation when needed i .
c.rq3 issue resolution process figure shows the overall issue resolution process at firefox derived from the bi gram analysis we performed on the stage sequences.
the process is a directed graph in which the nodes represent the six resolution stages e.g.
implemen tation ori and the edges represent transitions between stages e.g.
implementation code review ori cr .
the nodes with green and red borders are initial and end nodes selected from the most frequent initial and end stages in the sequences.
all nodes imply a loop to itself indicating that the stage can be performed multiple times in a row.
the process includes only the most frequent bi grams s t selected based on the proportion of bi grams starting with s s that contain s t. this proportion is shown in blue boxes of the edges in figure .
for example i crhas a frequency of since from all bigrams that start with i i there are occurrences of i cr.
the frequencies of all transitions starting from a given node add up to at least .
for example all transitions coming out of iadd up to .
.
the yellow boxes of the edges represent the proportion of issues containing sandtthat contain the bigram s t. for example of .
issues with both iandcrcontain i cr.
we make two observations about the process in figure the process deviates from the theoretical linear process outlined by the existing literature and firefox s documentation see sections ii b andii d .
instead of a linear sequence of stages starting with rand going through every stage from left to right until verification and or code review are completed see the path with green transitions in figure the process is more complicated than expected as it includes iterative interactions between stages.
this means developers go back and forth from one stage to another forming different workflows of issue resolution.
some nodes have a high number of incoming and outgoing transitions indicating the level of importance of such stages in the process.
specifically solution design has four incoming and four outgoing transitions and implementation has five incoming and two outgoing transitions.
these stages are pivotal because they allow for stage switches from and to many of the other stages.
code review and verification are the second most important stages both having three incoming and three outgoing transitions while analysis and reproduction are less important with fewer transitions.
of a that contain a b of issues with a and b that contain a br sd cr v i59.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.5a .
.
t xyx y sr reproduction a anal ysis sd solution design i implement ation cr code review v verifica tionfig.
overall issue resolution process of firefox rq3findings firefox s issue resolution follows an iterative process that deviates from the theoretical linear process.
in this process developers go back and forth from one state to another as needed to solve the issues.
solution design and implementation followed by code review and verification play a key role as they are the source and target for most of the other stages.
d.rq4 issue resolution patterns figure shows that firefox s issue resolution process differs from the expected linear process from prior work.
however the figure does not show how much the process differs and the different instances of the process that developers follow.
employing the qualitative approach described in section iii e we identified distinct instances of the process which we call issue resolution patterns .
these patterns appear in the issue reports with varying frequency and complexity a pattern appears in to reports .
on avg median patterns are categorized as complex they imply high issue resolution effort and as simple they imply low resolution effort .
of all patterns patterns are the most recurrent they are found in to reports on avg.
.
median covering reports .
are simple and are complex.
table iii shows the most recurrent patterns the entire pattern catalog can be found in our replication package .
pattern examples we describe two patterns of different kinds to illustrate different workflows of issue resolution.
the pattern a sd i i cr v ?
represents the process in which developers first analyze the reported problem a .
they then design the solution sd e.g.
propose a potential solution or review a proposed solution and then implement the solution i .
developers may then review the code cr and or test the code changes to verify if they solved the issue v .
based on qa feedback more code changes may occur i .
this pattern issimple because it includes only three mandatory stages a sd i followed by three optional stages i cr v ?
.
the pattern sd i cr v suggests a process in which solution design implementation code review and or verification are performed repetitively to resolve the issue.
in the repetitive series cr v means that either one or both can appear after an sdand an i. to resolve issues developers perform four distinct stages where all stages are repetitive making this pattern complex .
8table iii top frequent issue resolution patterns pattern descriptioncomplexity of issues i cr i?implement the solution and review the code followed by another optional implementation.simple a i i cr v ?analyze the problem and implement the solution followed by another optional i or cr or v or any combination.simple i cr v implement the solution review the code and or verify the implementation i cr and or v repeat more than once.complex sd i cr i v ?design and implement the solution and review the code followed by another optional i or v or both.simple a sd i i cr v analyze the problem design and implement the solution followed by another optional i or cr or v or any combination.simple i implement the solution.
simple i cr v i?implement the solution review the code and verify the implementation followed by another optional i.simple sd i cr v design the solution implement the solution review code and or verify the implementation i cr and or v repeat more than once.complex sd i cr v design and implement the solution review the code and or verify the implementation sd i cr and or v repeat more than once.complex a i cr v analyze the problem implement the solution review code and or verify the implementation i cr and or v repeat more than once.complex r reproduction a analysis sd solution design i implementation cr code review v verification process and pattern diversity all the identified patterns represent instances of the issue resolution process.
the instances indicate a wide variety of ways to solve firefox issues.
while more generalized patterns can be formed from the patterns our qualitative approach carefully identified the patterns to accurately reflect the observed process from the issues.
we did not forcefully merge patterns into more general ones but did validate the patterns against the process from figure which was derived quantitatively .
the diversity of the patterns process is observed across problem categories.
six of the problem categories have more unique patterns to than the remaining categories to patterns .
these six categories are defective functionality unique patterns found in issues code design patterns in issues ui issue patterns in issues test failure patterns in issues crash patterns in issues and feature development patterns in issues .
issue resolution for some categories is more diverse than for other categories despite having a similar number of issues.
for example ui issues are solved with patterns and code improvement issues are solved with patterns despite both categories covering issues.
we also found that the six most frequent patterns shown in table iii were used to resolve issues of more than half of the categories of categories .
this illustrates that the same issue resolution pattern can solve problems of different kinds.
the diversity of the patterns process is also observed throughout firefox s lifespan from to .
during these years the five most frequent patterns found in of the issues were observed in to different years.
the most frequent patterns found in of the issues are found in to different years.
the patterns appearing in two or more issues were used in to years.
pattern complexity and resolution effort table iv shows that .
of the issues of are solved with the simple patterns.
these compared to issues solved with a complex pattern are solved faster avg med vs. .
.5table iv number of issues across issue types issue typepattern complexitytotalcomplex simple defect enhancement task total days require fewer stages in the process avg med .
vs. .
and include fewer commentators avg med .
vs. .
.
a mann whitney u test at .
confirmed these differences across all these factors with p value .
.
while all the problem kinds are solved with simple patterns in most of the cases .
.
.
of the issues of categories tend to have more issues solved with complex patterns of .
compared to the other categories.
these five categories are code design of issues are solved with a complex pattern defective functionality of feature development of ui issue of and crash of .
this indicates that these categories contain issues that require more effort to be solved.
despite the issues in these categories being solved with similar resolution time avg med .
vs .
days they include more stages in their process avg med .
vs. and more commentators avg med .
vs. .
with statistical significance mann whitney u test p value .
suggesting potentially higher resolution effort.
table iv also reveals that .
of the tasks are solved using a simple pattern whereas .
of the defects and .
of the enhancements are solved with a simple pattern.
as pattern complexity suggests compared to defects and enhancements tasks require less effort they are solved significantly faster avg med vs. .
and .
.
require fewer process stages avg med .
vs. .
and and include fewer commentators avg med vs. .
and .
.
these results are statistically significant according to the mann whitney u test p values .
.
and .
respectively.
rq 4findings the identified issue resolution patterns indicate that solving issues at firefox is done in a wide variety of ways.
of these patterns are recurrently found in .
of firefox issue reports.
the process of issue resolution in firefox is diverse and far from linear.
the diverse and iterative nature of the process is consistently observed throughout firefox s years of evolution.
e.rq5 use cases for the issue resolution patterns the two interviewed mozilla developers i.e.
d1 and d2 identified the following use cases for the derived patterns identifying issues with a complex resolution d1 and d2 suggested that the patterns could help detect issues with complex resolutions especially those involving repetitive stages which may signal excessive time and effort spent by developers.
d1 noted that such patterns could indicate when a bug takes an unexpectedly complex path explaining if you went through three different implementations and three different verifications 9and it still didn t work something went wrong here.
d2 also emphasized the value of a tool that identifies these complex issues saying it might be interesting to have some sort of tool that watches the bugs and when it sees this snowball effect... it could alert a product person that this bug is chewing up a lot of time.
both developers agreed on the importance of early detection of complex resolutions.
both emphasized that detecting these issues would help understand why a process is taking longer than expected allowing for timely corrections.
identifying issues not following the expected process d1 suggested that a tool could be useful for detecting issues that deviate from expected workflows especially those requiring human verification.
he explained some bugs require human verification... it requires installing third party software on a machine.
and it s up to developers to highlight when this is the case.
d1 emphasized that a tool could help by alerting developers when an issue seems to need third party support for verification stating if you had a tool that said hey this bug that you open looks like it might need some third party support for verification that might actually be a helpful thing.
identifying potentially complex code components d2 suggested that tracking the complexity of issue resolution in specific mozilla firefox code components or modules could reveal underlying quality issues such as technical debt or accumulated code complexity.
as d2 put it you could track the complexity of the issue resolution process in a given module... and get insights like hey it looks like most of the time when you touch this area of code it ends up being a slog.
d2 emphasized that such insights could signal the need for refactoring stating maybe it s time to refactor this?
maybe it s time to clean this up... this part of the code base is a tar pit and we probably want to spend some resources making it less ornery.
improving bots to detect unsolvable issues d2 suggested that the resolution patterns could help improve the heuristics of existing bots e.g.
bugbug used to process mozilla issues enabling them to better identify issues that are unsolvable or particularly challenging to solve.
as d2 explained if you could identify signs that this bug is not going to be solved or is about to fall through the cracks that would be pretty cool.
he noted that current bots already attempt to detect when issues have fallen through the cracks and need attention saying we have some bots that do that kind of work.
suggesting and decomposing meta issues both d1 and d2 suggested that issues with complex resolutions as indicated by the complex patterns might represent meta issues large issues that could be broken down into smaller more manageable issues.
they proposed that a tool capable of flagging these cases and suggesting possible decompositions would be highly beneficial.
as d1 explained we have this idea of a meta bug which is a bug which hosts a whole bunch of related bugs and suggested the tool could flag such cases and offer ideas like could this be split?
here are some topics that it sounds like you could split this down into.
training junior developers d1 and d2 both indicated that the patterns could serve as valuable training tools for junior mozilla developers offering insights into the practical aspectsof issue resolution.
d1 noted that junior developers often have high expectations and approach issues linearly seeking a perfect solution.
however d1 emphasized that the patterns show the issue resolution process is typically incremental and iterative involving multiple cycles of code review and verification.
as d1 explained you will probably have to iterate... you will probably have to go through this solution more than once.
and that s okay.
that s expected.
it s part of the job.
both developers suggested that automation is needed to realize such use cases particularly tools that identify patterns in issue discussions and classify them as simple or complex.
our future work will develop such tools to automate the identification of textual content in issue comments e.g.
issue resolution activities and use algorithms to derive sequences of stages and patterns.
this process will likely combine machine learning with heuristic based approaches.
rq5findings the interviewed mozilla developers suggested that the resolution patterns could help identify complex issues workflow deviations and low quality code components improve bots for detecting unsolvable issues decompose large issues and train junior developers.
v. d iscussion and implications firefox s issue resolution in practice.
our study highlights the iterative and diverse nature of firefox s issue resolution process which widely deviates from the theoretical linear models often assumed in the literature e.g.
rajlich s incremental change process .
instead of following a straightforward path developers address various types of issues by moving back and forth through multiple stages as needed.
this reflects the iterative and incremental approach characteristic of modern software development aligning more closely with agile methodologies than with rigid frameworks like waterfall .
patterns generalizability.
while the results only apply to firefox we conducted a small case study that annotated issue reports of different kinds from two open source projects chromium and gnucash .
the goal was to validate if these projects follow resolution patterns similar to firefox s. details of the study methodology are found in our replication package .
we identified seven distinct resolution patterns for the chromium issue reports all of which correspond to firefox s patterns.
three patterns i cr i cr v and sd i cr v appeared in two issues each aligning with firefox patterns i cr i?
i cr v i?
and sd i cr i v which appeared in and issues respectively.
notably these firefox patterns are among the top seven most recurrent patterns which strengthens pattern generalizability they are found in chromium issues .
as for gnucash we identified resolution patterns across the issues with nine of these patterns aligning with nine of the firefox patterns.
the nine firefox patterns are fairly common as they were observed in to issues.
the gnucash pattern a i does not have any corresponding firefox pattern.
10the and patterns identified for chromium and gnucash indicate that developers in these projects also employ diverse approaches to issue resolution.
this suggests that some firefox patterns may generalize across projects of varying scales and governance.
however a large scale study with a statistically significant sample is needed to confirm these observations.
vi.
t hreats to validity construct and internal validity .
relying solely on issue reports poses a validity threat.
issue discussions may not capture all of firefox s resolution activities either because certain actions do not require documentation or were discussed recorded in other artifacts or channels.
this limitation may explain why some stages e.g.
issue reproduction are absent in certain issues.
consequently the derived patterns should be interpreted with caution as they reflect the resolution process documented in issue reports which may differ from the practical process.
however according to firefox s documentation issue reports are one of the primary artifacts for tracking firefox changes and developers are encouraged to document relevant problem information within them.
moreover we are confident in the accuracy of traces for implementation code review and verification stages due to the tool integration with the issue tracker as well as the requirement for verification to mark an issue as verified.
this provides confidence that issue report discussions capture the implemented resolution process.
researcher subjectivity and potential confirmation bias introduced during issue coding resolution pattern inference and results interpretation represent key validity threats.
to address these we implemented a rigorous open coding methodology involving multiple coding phases.
each issue report was reviewed multiple times accompanied by discussion sessions between annotators.
both annotators critically annotated and verified the data at each phase resolving disagreements through consensus.
the results interpretation was thoroughly discussed and supported by data driven evidence.
external validity .
our pattern catalog and results may not generalize to all issues from firefox and to other systems as is typical in case studies.
this stems from the relatively small set of issues we coded to derive the patterns.
to strengthen generalization our study analyzed a statistically significant sample in which the distribution of coded issues resembles that of all firefox issues.
we also annotated issue reports of chromium and gnucash and found that some of the most frequent firefox patterns cover the resolution workflows found in the issues which implies that at least some of the derived patterns can be generalized to these projects.
while the results are indicative in depth studies are needed to confirm these results and establish generalizability.
vii.
r elated work researchers have proposed a variety of techniques to address issue management challenges and automate several tasks in the process .
for example researchers have proposed automated techniques to better report issues assess issue quality predict the priority and severity of theissues categorize issue types assign developers to issues suggest potential duplicate issues reproduce buggy behavior localize buggy code files and predict re opened issues .
researchers have studied issues for a variety of purposes to understand decision making and the discourse used to describe issues extract decision information understand stakeholders information needs characterize predict different kinds of issues such as won t fix issues fixed resolved issues non reproducible bugs and bug issue types predict issue severity understand workarounds and visual content in issues questions and information types in issues .
researchers have used automated mining of issue data e.g.
status changes and version control code review data to identify development processes and assess delays and inconsistencies .
they have utilized process mining techniques to integrate data from different sources e.g.
vcs issue trackers and mail archives and proposed process mining techniques to gain insight into development processes.
other work has studied the life cycle of issues by mining and analyzing issue state transitions .
these works focused more broadly on issue management and identified transitions of issue states e.g.
from assigned to in progress to closed .
however issue states are often too broad to provide detailed insights into how stakeholders resolve issues in practice.
unlike prior work our research qualitatively analyzed issue reports to identify resolution stages develop a process model and uncover detailed patterns of issue resolution at firefox.
this in depth analysis led to new insights into the issue resolution process.
to our knowledge we are the first to examine how the issue resolution process is actually implemented and discussed in practice and how it differs from the theoretical models found in the literature.
viii.
c onclusions we conducted a case study to understand the process employed by mozilla firefox developers to solve software issues.
by implementing a multi coder open coding methodology we qualitatively analyzed the issue report comments identified six issue resolution stages and derived an overall process model.
we found issue resolution patterns which are instances of the process and represent how firefox developers resolve issues in practice.
this process is iterative and deviates widely from the theoretical linear process from the literature.