smartreco detecting read only reentrancy via fine grained cross dapp analysis jingwen zhang zibin zheng yuhong nan mingxi ye kaiwen ning yu zhang and weizhe zhang sun yat sen university zhangjw273 yemx6 ningkw mail2.sysu.edu.cn zhzibin nanyh mail.sysu.edu.cn harbin institute of technology yuzhang wzzhang hit.edu.cn peng cheng laboratory guangdong engineering technology research center of blockchain abstract despite the increasing popularity of decentralized applications dapps they are suffering from various vulnerabilities that can be exploited by adversaries for profits.
among such vulnerabilities read only reentrancy called ror in this paper is an emerging type of vulnerability that arises from the complex interactions between dapps.
in the recent three years attack incidents of ror have already caused around 30m usd losses to the dapp ecosystem.
existing techniques for vulnerability detection in smart contracts can hardly detect read only reentrancy attacks due to the lack of tracking and analyzing the complex interactions between multiple dapps.
in this paper we propose smartreco a new framework for detecting read only reentrancy vulnerability in dapps through a novel combination of static and dynamic analysis i.e.
fuzzing over smart contracts.
the key design behind smartreco is threefold smartreco identifies the boundary between different dapps from the heavy coupled cross contract interactions.
smartreco performs fine grained static analysis to locate points of interest i.e.
entry functions that may lead to ror.
smartreco utilizes the on chain transaction data and performs multi function fuzzing i.e.
the entry function and victim function across different dapps to verify the existence of ror.
our evaluation of a manual labeled dataset with rors shows that smartreco achieves a precision of .
and a recall of .
.
in addition smartreco successfully detects new rors from popular dapps.
the total assets affected by such rors reach around usd.
index terms decentralize application smart contract vulnerability detection program analysis i. i ntroduction decentralized applications dapps are applications including multiple smart contracts which are code snippets that contain multiple functions to accomplish specific functionalities and can be executed on the blockchain.
due to the inherent financial property of dapps the security of dapps is extremely important.
for example in recent years the entire dapp ecosystem has suffered from various types of attacks such as front running price manipulation and access control resulting in billions of dollars in losses .
reentrancy and read only reentrancy.
as one of the most typical vulnerabilities in smart contracts the reentrancy vulnerability is leveraged to manipulate global states such as the contract s state to make the contract s behavior inconsistent with expectations .
in recent years with the yuhong nan is the corresponding author.increasing attention on smart contract security reentrancy has been addressed by many previous research .
read only reentrancy ror a new type of reentrancy vulnerability first reported in is a cross dapp attack that specifically exploits functions in different dapps contracts.
the key difference between ror and traditional reentrancy is that ror takes place between the smart contracts of independent dapps while traditional reentrancy performs within the smart contract s of a single dapp.
to exploit ror the adversary first manipulates a specific state of one dapp by invoking one of its function i.e.
the entry function .
then the adversary performs the attack by hijacking the execution control flow and invoking another dapp s function i.e.
the victim function which relies on the aforementioned state like calculating the token price with the token supply see section ii b for more details .
right now ror has already resulted in losses exceeding 30m usd and poses a threat of more than 100m usd.
due to the invisibility and potential risks of ror it has been selected as one of the top ten blockchain hacking techniques in .
challenges in detecting read only reentrancy.
despite a number of recent research focusing on detecting smart contract vulnerabilities detecting ror based on existing techniques is by no means trivial.
specifically there are three fundamental challenges as we elaborate below.
firstly identifying the boundaries between dapps is difficult.
specifically as ror is a cross dapp attack detecting ror requires analyzing complex relationships between dapps.
however the anonymity of the blockchain prevents access to smart contract identification such as which dapp a smart contract belongs to.
prior research simply look up the contract address from the dapp s official website or query third party api e.g.
dappradar and thegraph .
however this information is often incomplete as new smart contracts included by the dapp are not updated in a timely fashion.
secondly identifying the entry function the start point and the victim function the end point of ror is quite challenging given the unlimited number of dapps and their publicly accessible functions.
specifically a function within a dapp can be called by anyone and any other dapp resulting in a large search space.
moreover these two functions do notarxiv .18468v2 dec 2024share any explicit dependency e.g.
a shared state or within the same call chain.
existing methods such as icychecker and defitainter blindly consider all functions as the candidates which is not feasible for detecting ror due to the huge exploration space.
lastly even with the given entry function and victim function pairs it is still difficult to find a valid path call chain that can trigger ror.
on the one hand static analysis methods such as pluto and sailfish can not recover the call chain of ror due to the lack of concrete runtime contextual information.
on the other hand fuzzing based methods such as confuzzius and contractfuzzer randomly generate fuzzing seeds for multi function e.g.
entry function and victim function in different dapps.
however these approaches can hardly simulate the actual cross dapp context e.g.
simultaneously bypassing the internal checks in both dapps not to mention triggering the potential rors.
our work.
in this paper we propose smartreco a new framework to detect read only reentrancy vulnerabilities in smart contracts.
to address the aforementioned challenges smartreco comes with the following three unique designs cross dapp analysis to identify dapp boundaries finegrained static analysis for locating potential entry functions multi function fuzzing across different dapps for effectively verifying rors.
more specifically the cross dapp analysis aims to incorporate accurate dapp based contextual data to identify valid attack surfaces.
here the dapp based contextual data refers to records of the interactions between dapps during transaction execution such as cross dapp call and cross dapp state read and write.
to facilitate this analysis we propose an enhanced dapp boundary identification method based on dapp contract builders section iv a .
our observation is that a dapp is usually managed by a fixed group of accounts as the builders allowing us to more accurately identify dapp boundaries.
with this method we build the first dapp builder dataset dbuilder with unique builders .
to the best of our knowledge this is the first approach and dataset for accurately classifying smart contracts for dapps.
based on the collected dapp information smartreco performs fine grained static analysis to find potential entry functions.
although there is no explicit dependency between the entry points and the victim points of ror the entry points must be associated with specific cross dapp invocations along the call chain of a ror.
therefore with dapp based contextual data smartreco analyzes all cross dapp function invocations on the call chain and identifies potential ror entry points.
section iv b and section iv c .
then to verify whether the potential ror entry points can trigger ror smartreco adopts a multi function fuzzing mechanism to capture more accurate context information.
to detail smartreco generates inputs for functions in different dapps based on historical transactions as such transactions provide a more realistic scenario for finding the valid paths and contexts to invoke ror section iv d .
to evaluate the effectiveness of smartreco we constructa ror dataset with attack instances based on publicly available attack reports.
we manually check and label the contracts functions related to these attack incidents.
to the best of our knowledge the dataset covers all reported rors related to smart contracts as of mar.
see section v a for more details .
the evaluation results show that smartreco has a precision of .
and a recall of .
over this dataset.
in the meantime two state of the art frameworks ityfuzz and sailfish can not detect any rors in the dataset.
besides with the help of smartreco we perform an in the wild ror inspection over most popular dapps with smart contracts .
indeed smartreco successfully detects unreported rors.
the vulnerabilities discovered by smartreco impact approximately usd.
to promote smart contract security development we have open sourced smartreco and the datasets used in our work1.
in summary this paper makes the following contributions we propose smartreco a novel framework for detecting ror an emerging type of reentrancy vulnerabilities in smart contracts.
to the best of our knowledge smartreco is the first research to detect read only reentrancy.
we design a series of new mechanisms such as identifying dapp boundaries and collecting dapp based contextual data to facilitate fine grained cross dapp analysis.
we perform extensive experiments to verify the effectiveness of smartreco .
the results indicate that smartreco can detect new rors while maintaining lower false positives and false negatives.
we release the artifact and the datasets of smartreco .
the rest of the paper is organized as follows section ii provides the background of ror and the motivation of our research.
section iii highlights the challenges and solutions for ror detection.
section iv elaborates on the implementations ofsmartreco .
section v introduces the experimental setup and evaluation.
section vi gives more discussions about ror and the limitations of smartreco .
section vii presents related work and section viii concludes the paper.
ii.
b ackground and motivation a. smart contract and contract execution decentralized application dapp typically consists of a ui frontend and a backend that uses smart contracts to store and process data .
smart contracts are codes that can be executed on blockchain platforms such as ethereum and bsc chain and contain multiple functions to accomplish specific functionalities e.g.
transferring funds.
to execute smart contracts it is necessary to first compile the smart contract into bytecode and deploy it on the blockchain.
in blockchain there are two roles user called externally owned account eoa and smart contract and they are both distinguished by a unique identifier called address.
users and smart contracts can send external and internal transactions respectively to a contract address to invoke functions and the contract is responsible for execution.
to invoke pool the victim function 3function decrease uint amount address asset public nonreentrant require allow msg.sender wrong user!
calculate balance based on wrong price uint256 balance oracle.getprice asset amount oracle.dohardwork msg.sender return balance 11contract oracle function getprice address asset public view require exist asset wrong asset!
vault vault vaults uint balance totaltoken vault.getfunds asset return balance totaltoken function dohardwork address account public if account owner ... a the victim dapp.
1contract vault the entry function 3function exitvault public nonreentrant require allow msg.sender wrong user!
... updatetokens msg.sender control flow transfers to attacker transferbalance msg.sender updatebalances msg.sender rate balance totaltoken function swap address pool public nonreentrant uint cur rate getrate ... function setrate uint newrate public onlyowner rate newrate the manipulable function function getfunds public view return outdated values return balance totaltoken function getrate public view return rate b the entry dapp.
fig.
an example of read only reentrancy.
internal transactions the control of the execution is transferred to the relevant contract allowing the contract to execute the code and update the state.
b. reentrancy and read only reentrancy reentrancy.
in smart contracts reentrancy is a specific type of vulnerability that exploits unsynchronized updated data .
specifically due to the serialized execution mechthe victim dappthe entry dapp 1decreaseoraclegetpricepoolexitvaultvaultgetfunds totaltoken balance23456789attackercontractdappsfunctioncontrolflowfallbackcallstatefig.
the attack process of example in fig.
.
anism of smart contracts there may exist an inconsistency between the global states.
for example when one contract calls another contract the states of the calling contract do not fully update before control transfer like not updating the token supply before transferring funds.
attackers can exploit this inconsistency by reentering contracts and making a profit.
in smart contracts there are three types of functions that are closely related to reentrancy attacks as explained below entry function .
the entry function is the function where the attacker initializes reentrancy.
entry functions are publicly accessible.
victim function .
the victim function is the target function of the reentrancy attack.
for each reentrancy attack the victim function suffers the actual damage such as economic loss.
manipulable function .
manipulable functions are functions that can be controlled by the attacker to achieve a successful reentrancy attack.
for example a function that returns specific token prices as attackers expect.
read only reentrancy.
with the increasing complexity of dapp functionalities such as token swap lending and collateral different dapps may interact with each other for data access .
however such a deep integration and heavy interactions bring new attack surfaces to dapps raising significant challenges to dapp security.
for example if the state updates between dapps are not well synchronized it may lead to potential state inconsistencies in different dapps and further cause attacks such as ror.
usually in traditional reentrancy the victim function and manipulable function are in the same dapp while the victim function of ror is in another dapp.
this means that the search space for ror is broader making it more challenging to detect.
c. motivating example fig.
shows a simplified code snippet of three smart contracts in two dapps victim dapp and entry dapp.
the victim dapp in fig.
a has a contract pool.
it allows users to withdraw balances by executing the victim function decrease .
although both dapps have added checks both line in fig.
a and fig.
b to ensure security problems arise when they interact with each other.
the attack process is shown in fig.
.
an attacker can first call the entry function exitvault in the entry dapp.
during the execution the control flowblockchaindappbuilder finding algorithmdapp based contextual data collectioncontract addresscontract informationtransactionscontextual datacross dappstatic analysisdappbuilder dataset addr!
dapp read only reentrancy verificationpotential entry pointsoutputfeasible path of read only reentrancybuilderdappboundaries identificationfig.
the workflow of smartreco .
ofexitvault transfers to the attacker while states not fully update steps and in fig.
causing a temporary mismatch between token amount and balance.
then instead of reentering the entry dapp the attacker executes decrease in the victim dapp step in fig.
and the price is obtained through the manipulable function getfunds of the entry dapp step in fig.
.
however since state balance has not been updated at this point decrease will get an incorrect price.
as a result attackers can get more assets.
limitations of existing works.
existing methods both static and dynamic methods can not effectively identify ror due to the following unique challenges.
identifying dapp boundaries for contracts in ror.
current contracts dapp information collection methods are inaccurate.
for example when analyzing decrease in fig.
a contracts and functions under the same dapp such as contract oracle and function dohardwork may be introduced.
as a result the search space becomes large.
finding entry functions of ror.
existing methods for detecting reentrancy cannot trace dapp data which makes it difficult to identify potential entry functions of ror.
in our example all functions in contract vault need to be analyzed causing significant performance overhead and false positives.
verifying the presence of ror.
due to the lack of runtime contextual information existing static analysis techniques such as defitainter can hardly detect and verify rors.
in the meantime state of the art fuzzing approaches have proved effective for vulnerability detection in smart contracts.
unfortunately these approaches are still inadequate for detecting rors as their randomly generated fuzzing inputs can hardly trigger rors with high complexity.
for example it is with little chance to generate valid fuzzing inputs that can bypass line in fig.
a and line in fig.
b simultaneously.
our solution.
smartreco uses cross dapp analysis to guide the detection of rors.
turning to the example in fig.
smartreco first collects and replays the transactions of decrease .
during the replay smartreco records dapp based contextual information such as dapps of called contracts.
then smartreco finds out manipulable functions like getfunds .
such manipulable functions are the key to uncover the entry functions of ror due to the shared state dependencies with entry functions.
for example since function exitvault modifies the state balance thatgetfunds relies on smartrecoregards exitvault as a potential entry point.
smartreco then performs multi function fuzzing for exitvault anddecrease .
in detail smartreco tries to reenter decrease during the execution ofexitvault .
when smartreco finds a reachable path it reports relevant inputs and functions and explains how an attacker can initialize ror.
turning to this example smartreco will report that an attacker can hijack control flow during executing exitvault and reenter decrease .
iii.
d esign of smartreco a. technical challenges and our idea identifying dapp boundaries.
due to the anonymity of the blockchain smart contracts do not inherently contain information about the dapp it belongs to.
to identify dapp boundaries a straightforward approach is to collect the contract addresses of each dapp from the official websites or third party apis e.g.
dappradar and thegraph .
however the dapp information from these sources is mostly outdated and inaccurate as a large number of new smart contracts are created and deployed every day.
to address this smartreco identifies the dapp boundaries i.e.
dapp builders based on creators of various smart contracts.
compared to the contract dapp mapping information scattered in various sources information about dapp builders contract creators is better documented and easier to access.
therefore the dapp builder information is a more reliable source to identify the dapp boundary.
finding potential entry functions.
as mentioned earlier the entry function and the victim function of ror have no direct relationship.
for example we can not find a call chain from function decrease to function exitvault and vice versa.
to find potential entry functions the simplest approach is to traverse all functions and contracts involved in the execution path.
however this is rather impractical due to the large exploration space with a significant number of false positives.
existing tools can not detect ror due to the ignorance of these important factors.
to narrow down the search space smartreco employs a two step filtering process to locate entry functions.
the key insight here is that while the entry point of ror is not directly related to the victim function it must be associated with manipulable functions in the call chain.
for example in fig.
the entry function exitvault updates states that the manipulable function getfunds depends on.
to this end eoa1factory contract deploycreator builder a direct deployment.
eoa2factory contract invokecreatedcontract deploy eoa1builder creator b indirect deployment.
fig.
two methods for deploying smart contracts.
smartreco first points out all functions of other dapps in the call chain.
then only functions that share state dependency with those manipulable functions are considered as potential entry functions of ror.
to achieve this smartreco collects dapp based contextual data including the state changes and invoking of each dapp and comprehends the entire call chain.
these information allows smartreco to further identify all manipulable functions and the candidate ror entries.
we will give more details about this process in section iv b and iv c verifying the existence of ror.
as mentioned earlier the last challenge lies in how to provide valid fuzzing inputs that can precisely trigger the critical path of ror across two dapps.
more specifically with random input generation mechanisms as in prior works it is hard to satisfy the internal check in both dapps.
even if we bypass the check there is no guarantee that the input can trigger the ror path line in fig.
b .
to generate valid inputs for both potential entry functions and victim functions smartreco utilizes their corresponding on chain historical transactions to detect ror.
this is because on chain transaction data such as the sender timestamp or inputs provides realistic execution environments for fuzzing.
compared with randomly generating such fuzzing inputs as in prior works the on chain data allows smartreco to bypass the internal checks such as require statements in different functions.
in this way our fuzzing mechanism can trigger a more complex call chain between the entry function and the victim function.
besides the successful execution of the combined transactions indicates the existence of the vulnerable path of ror.
more details of this fuzzing process are elaborated in section iv d. b. workflow of smartreco fig.
shows the workflow of smartreco .
specifically given an unknown contract address as input smartreco outputs its corresponding ror detection results along with the valid ror paths if exist.
in dapp boundaries identification to identify which dapp the contract belongs to smartreco retrieves a set of information related to contract creation from the blockchain including the deployment transaction internal transaction listalgorithm dapp builder finding algorithm.
input contract address addrs output contract builder builder txd fetchdeploymentx addrs creator fetchcreator addrs ld fetchinternaltxlist txd while isnotempty ld contain ld addrs do addrin fetchfactorycontract addrs txd fetchdeploymentx addrin creator fetchcreator addrin ld fetchinternaltxlist txd end while builder creator return builder of deployment transaction and the transaction sender.
the above information helps smartreco to get the actual builder of the contract and further identify the dapp it actually belongs to.
we will detail this process in section iv a. in dapp based contextual data collection smartreco collects the contract s historical transactions faithfully replays them and filters dapp based contextual data by dapp boundaries.
in cross dapp static analysis smartreco uses contextual data to extract potential entry points entry functions of rors.
in read only reentrancy verification smartreco employs a multi function fuzzing strategy to verify the existence of ror in potential entry points and output feasible ror paths if exist.
iv.
a pproach details a. dapp boundaries identification smartreco uses dapp builders to identify dapp boundaries.
note that due to the unique dapp development mode the builder of a given dapp cannot simply attributed to the creator s of the smart contracts it contains.
as the examples shown in fig.
there are two ways to deploy smart contracts namely direct deployment andindirect deployment .
for direct deployment fig.
a users can deploy a new contract by directly sending a transaction to the blockchain.
in this case the builder of contract factory is its creator eoa1 .
differently a more complicated case is the scenario of indirect deployment .
as shown in fig.
b users can send a transaction to a contract i.e.
factory contract that further creates another new contract created contract .
since in smart contract a contract s creator is always recorded as the account that invokes the transaction simply using this information from transaction records can easily cause misclassification.
in this case the actual builder of created contract should be eoa1 not its creator eoa2 .
dapp builder identification.
to identify the builder of a given contract smartreco employs a heuristic based dapp builder finding dbf algorithm as shown in algorithm .
the core idea here is to exhaustively find the actual builder of the contract based on various information related to contract creation.
in detail to find the builder builder of a contract addr s smartreco first fetches its deployment transaction txd the first transaction of the contract from the blockchainand searches for the creator creator intxd.
then smartreco analyzes how txdis deployed by checking the internal transaction list ld which records all internal transactions executing in txd.
when addr sis created by indirect deployment there will be an internal creation transaction related to addr s inld.
thus if ldis empty or smartreco can not find addr s inld it means addr sis created by direct deployment and builder iscreator .
otherwise smartreco gets the internal creator addr in which means addr sis deployed by another smart contract addr inand they belong to the same dapp.
then smartreco checks txd creator and ldofaddr in iteratively until ldis empty or addr innot exists in ld.
in this way smartreco finally obtains builder ofaddr s. we use the examples in fig.
to illustrate this process.
for factory contract in fig.
a smartreco can find its creator iseoa1 .
as factory contract is directly deployed its ldis empty.
thus smartreco can verify that eoa1 is the builder offactory contract .
for created contract in fig.
b its creator iseoa2 .
as created contract is deployed indirectly itsldis not empty and smartreco can find the internal builder addr inofcreated contract isfactory contract .
in this case smartreco considers both of the two contracts to belong to the same dapp.
therefore smartreco investigates how factory contract is deployed.
since factory contract is directly deployed by eoa1 smartreco can determine that the builder of the created contract iseoa1 instead of eoa2 .
note that smartreco may fail to identify some contracts if their dapp builders are totally absent from dbuilder .
this could potentially lead to inaccuracies in boundary identification.
however this will not diminish the effectiveness of smartreco in detecting ror.
specifically smartreco employs a conservative approach to address this potential misinformation.
in smartreco all contracts whose builders are not listed indbuilder will be deemed unsafe and these contracts will then undergo further security analysis.
b. dapp based contextual data collection in this step smartreco replays transactions as in prior works to obtain dapp based contextual information such as contract address and state read and write.
the difference is that smartreco replays at transaction level while others perform based on synchronizing blockchain state.
the advantage is that smartreco does not require a significant amount of time and storage to gain the entire blockchain state and can be easily extended to other blockchain platforms like bnb chain .
more specifically during the replay of a transaction whenever smartreco needs to invoke another contractaddr s it will first identify the dapp information dapp n of this contract and record the operation executed in addr sin a three tuple addr s dapp n operation .
for example when smartreco meets opcodes related to state read and write such as sload and sstore smartreco records read and write inoperation respectively.
similarly smartreco records invocation information whenever it encounters opcodes related to method execution such as call callcode delegatecall and staticcall .
the operation here is invoke .we will demonstrate that replay at transaction level is feasible in section v c. c. cross dapp static analysis this step comprises two tasks prioritizing manipulable functions from a given call chain for efficiency and identifying the set of potential entry functions in other dapps based on the selected manipulable functions.
manipulable function prioritization.
given the huge amount of manipulable functions in cross dapp interactions smartreco needs to prioritize their order as it can significantly improve detection efficiency.
thus smartreco introduces a metric called importance to order the manipulable functions.
here importance is calculated based on the sum of contextual data i.e.
invoke read and write of each function in the call chain.
our main idea is that if a function frequently appears or performs many operations in historical transactions replay it is more likely to provide high quality contextual information i.e.
state dependency that is critical to find ror entry functions.
the calculation formula is as follows importance cinvoke cread cwrite where crepresents the count.
to this end smartreco generates the inter dapp data flow graph based on dapp based contextual data.
the graph records the operations in each manipulable function such as call read and write .
then smartreco orders these manipulable functions based on their importance in descending order.
potential entry functions determination.
based on the characteristics of real world ror attacks we have summarized four rules shown in fig.
for constructing an intradapp graph and identifying potential entry functions.
to the best of our knowledge these rules are relatively comprehensive as they sufficiently cover all known ror attacks in total .
meanwhile it is practical to incorporate new rules into smartreco should new varieties of ror attacks emerge.
below we use contracts in fig.
to show how smartreco constructs the intra dapp graph.
implicit dependency expanding.
when there are two functions in a contract where one modifies the state and the other reads the state smartreco regards these two functions have an implicit dependency and adds an edge between them.
for example in fig.
a exitvault modifies the state balance while getfunds reads balance .
smartreco will add an implicit dependency from getfunds toexitvault .
access control pruning.
based on access control smartreco performs implicit dependency pruning.
more specifically if the modification of states within functions is protected by access control like setrate in fig.
b smartreco does not consider it as an unsafe function and prunes all implicit dependency edges that depend on it likeswap in the example.
nonreentrant pruning.
although modifier nonreentrant is ineffective in defending against ror.
however within the same contract nonreentrant is feasible.decreasegetpricedohardworkpooloracleprunereadwritedependencyexitvaultgetfundsbalancevaultreadwriteprunesetrateswapratevault d cross contract pruning a implicit dependency expanding c nonreentrantpruning b access controlpruning access control access control protectprotect readwritepruneexitvaultswapratevault nonreentrantprotectprotectfig.
rules for constructing intra dapp graph.
specifically when two functions in the same contract are both protected by nonreentrant like exitvault andswap in fig.
c even if they have a relationship on the same state they are unable to cause ror.
therefore it is safe to remove the dependency edge between them.
cross contract pruning.
as mentioned before ror is a cross dapp attack.
for functions in the same dapp with sufficient access control smartreco considers them as safe functions and prunes their corresponding execution paths.
as shown in fig.
d since dohardwork in contract oracle is protected by access control line in fig.
a smartreco prunes dohardwork indecrease .
based on the above rules smartreco can construct an intra dapp control flow graph.
more specifically for any manipulable function all endpoints of implicit dependency edges have the potential to become an entry point and need further testing like exitvault in fig.
b .
d. read only reentrancy verification to verify ror smartreco generates valid inputs for entry functions and attempts to trigger ror by performing control flow hijacking.
inputs generation.
for each potential entry function fun smartreco attempts to generate its valid input during the replay of a transaction txoextracted from the detected contract.
in detail if there is no historical transaction of fun smartreco will use the same environment in txo such as the same caller to construct a transaction of fun.
more specifically smartreco will generate transaction txfunbased on the abi of fun and add it to candidate list lc.
otherwise if historical transaction txfun offun is fetched from the blockchain like ethereum smartreco pushes it into the lc.
since most normal transactions may not trigger the critical path of ror smartreco mutates txfun using the following two strategies fuzzing funds .
iffun ispayable then it can receive funds like eth and should have complete logic to handle the assets involved in the transaction.
therefore smartreco randomly changes funds values in txfun gets a new transaction and adds it to lc.
updatetokenstransferbalanceupdatebalances eoaexitv aultupdatetokenstransferbalanceupdatebalances eoaexitv ault getpricedohardworkdecreasehijack a execution path of tx.
b execution path of tx tx!
.fig.
the process of verifying potential entry function for contracts in fig.
.
fuzzing input.
iffun can accept parameters to explore unusual paths smartreco will attempt to mutate them randomly based on the original inputs in txfun get a new transaction and add it to lc.
ror verification.
for each transaction txinlc smartreco traces the execution of txand attempts to hijack its control flow.
in detail whenever txinteracts with an external parameter e.g.
an arbitrary contract address smartreco tries to invoke txo.
iftxoexecutes successfully smartreco continues to track the execution of txand monitors state modifications e.g.
updating balances.
if txupdates states that txohas read smartreco considers the presence of ror and reports it.
we use contracts in fig.
as an example.
during replaying the transaction txoofdecrease smartreco identifies exitvault as a potential entry function.
smartreco then generates the transaction txfunforexitvault mutates txfunto create candidate list lcand analyzes each transaction txinlc.
fig.
a shows the original execution path of tx.
specifically when txexecutes to line in fig.
b the execution control is handed over to eoa to perform the transfer.
smartreco then simulates an attacker hijacking the control flow and executes txo as shown in fig.
b .
since txoexecutes successfully andtxmodifies the state balance thattxodepends on after executing txo smartreco will report the presence of ror.
v. e valuation in this section we first present the dataset used in the evaluation and introduce our experimental setup of smartreco .
then we show the evaluation results of smartreco .
a. implementation and evaluation setup dataset.
we construct the following three datasets to perform our evaluation.
manual labeled ror dataset dlabeled .
this dataset contains ror vulnerabilities from contracts through a carefully designed manual labeling process.
particularly rors from contracts are collected from publicly reported attack incidents while the remaining rors from contracts all written in solidity are manually discovered by our security experts.
more details are shown in section vi b. to the best of our knowledge this is the most comprehensive and up to date ror dataset.
the manual labeling process is performed by three researchers including one professor and two senior phd candidates.
each researcher has years of experience in auditingsmart contract vulnerabilities.
to ensure the quality of the labeled dataset we first give a detailed tutorial about ror to researchers helping them better understand the nature of rors.
then we collect all the publicly reported ror attacks and extract their entry functions and manipulable functions.
we then ask researchers to independently extract the attack patterns i.e.
call chains from these rors.
meanwhile to construct a potential ror set we use a similarity matching approach to search for functions that call manipulable functions in all historical transactions.
finally we collect suspicious functions from contracts.
based on the extracted ror patterns we attempt to construct call chains from the entry functions to functions in the set with the multi function fuzzing method.
subsequently the experts independently verify these cases and align disagreements together.
note that during the whole labeling process only the vulnerabilities confirmed by all three researchers are considered as rors.
while this criterion is relatively conservative our labeled dataset provides a lower bound for evaluating the effectiveness of smartreco excluding potential fps caused by data labeling.
popular dapp dataset dunknown .
to further understand the impact of ror in real world dapps we construct an unknown dataset dunknown consisting of smart contracts from popular dapps.
more specifically this dataset is a union of public available top popular dapp data released by two prior research stefan et al.
and icychecker .
the identifications of smart contracts are determined based on the identified dapp boundaries by smartreco .
since all contracts we analyzed are from popular dapps we believe the analysis results are sufficiently representative of the smart contract ecosystem.
dapp builder dataset dbuilder .
we use all dapps indunknown to construct the builder dataset with the dbf algorithm described in section iv a. all data in dbuilder are recorded in a tuple builder dapp n consisting of each unique builder address and dapp s it belongs to.
note that for dapps belonging to the same project if these dapps share the same builder we will merge these dapps and their builder as a single item in dbuilder as they are mutually trusted.
finally ourdbuilder consists of a total number of builders and their corresponding dapps.
to this end given the builder of an unknown contact dbuilder can tell which dapp the contract exactly belongs to.
implementation.
we implement smartreco with around lines of code in python and about lines of code in rust.
smartreco replays historical transactions and verifies rors based on ityfuzz which is an online fuzzing based framework for smart contracts.
smartreco finds potential entry functions based on slither .
all experiments in our evaluation are conducted on a machine with two intel r xeon r gold 5218r cpu .10ghz 512gb ram and ubuntu .
.
os.
evaluation setup.
we inspect the latest transactions for each contract and use the top transactions of each potential entry function to test and manually analyze thetable i overall effectiveness of smartreco ondlabeled .
dlabelrecall precision tp fn rate tp fp rate attack incidents .
manual annotation .
total .
.
reported results.
if smartreco needs data during execution such as reading storage it directly fetches the corresponding storage from the blockchain and caches it locally.
besides like other transaction based frameworks e.g.
sfuzz and smartian smartreco implements a customized ethereum virtual machine evm to execute transactions monitor the opcodes and record data.
evaluation metrics.
specifically we focus on the following research questions.
rq1.
how effective is smartreco in detecting ror?
rq2.
what is the impact of each module in smartreco on detecting ror?
rq3.
issmartreco more effective in detecting ror compared to other advanced tools?
rq4.
can smartreco effectively detect unknown ror in real world smart contracts?
rq5.
what is the performance overhead of smartreco for detecting ror?
b. effectiveness of smartreco to answer rq1 we use dlabeled to test smartreco and the results are shown in table i. in detail smartreco successfully detects out of rors with a precision of .
and a recall of .
.
in addition thanks to the fine grained crossdapp analysis smartreco successfully identifies attack contracts out of the attack incidents and accurately pinpoints the specific attack paths.
false negatives.
five out of six false negatives are all written in vyper which is outside of our scope.
due to smartreco relying on slither smartreco cannot detect such contracts.
in fact there are currently no stable static analysis tools specifically for vyper .
if the state dependencies of these contracts are provided smartreco can determine the dependency relationship between functions and identify potential entry functions for analysis.
another false negative is due to the use of a modifier that has similar logic to onlyowner causing smartreco to mistakenly assume that the function does not need to be analyzed.
false positives.
after analyzing the false positive cases we identify the main reasons as follows when searching potential entry functions smartreco primarily focuses on checking modifiers because most smart contracts use modifiers for control.
however some contracts do not follow these patterns and instead perform checks within the function resulting in smartreco failing to recognize them and causing false positives.
some dapps have forwarding modules such as the gnosis multi signature wallet.
it helps users to forward and execute operations directly.
however smartreco39390005109 smartrecowithout cdawithout mffityfuzzsailfishtpfpfnfig.
result of smartreco smartreco without cross dapp analysis without cda smartreco without multi function fuzzing without mff ityfuzz and sailfish based on dlabeled .
currently considers only interactions in the same dapp as safe and thus leads to false positives.
answer to rq smartreco demonstrates its effectiveness in ror detection with a precision of .
and a recall of .
on the manually labeled dataset dlabeled .
c. effectiveness of each module in smartreco to answer rq2 we evaluate the effectiveness of dapp boundaries identification method with top dapps in dunknown .
besides we verify the effectiveness of the transaction based replay method with dunknown .
we also conduct ablation experiments on cross dapp analysis and multi function fuzzing methods based on dlabeled separately.
effectiveness of dapp boundaries identification.
to verify whether the newly created contracts will cause the dapp boundaries identification method to fail we select the top10 dapps from dunknown as top dapps provide more timely and comprehensive maintenance of contract information.
specifically we collect the latest contracts of all these dapps from their official websites totaling contracts.
then we use the dbf algorithm to find the builders of these contracts determine whether these builders are in the dbuilder and whether the corresponding builders are classified correctly.
the results show that the dapp boundary identification method accurately recognizes contracts reaching a precision of .
.
the remaining contracts are due to the contract builders not being included in dbuilder .
overall our method does not produce any misclassification.
effectiveness of transaction based replay.
to test the effectiveness of transaction based replay we compare the original execution results of all transactions currently a total of with the results obtained through replay for contracts indunknown .
finally transactions around have consistent results.
after analysis we identify the main causes of inconsistency as follows when multiple transactions in a block invoke the same contract replaying one of thesetransactions may lead to inconsistency.
for example if a user deposits tokens and then performs a transfer in two external transactions directly replaying the transfer transaction may result in a revert as the account s balance might be insufficient.
to test more transactions smartreco does not consider the gas costs.
thus smartreco may successfully execute transactions that revert due to insufficient gas.
effectiveness of cross dapp analysis.
to validate the effectiveness of cross dapp analysis we remove the cross dapp analysis module without cda .
more specifically we replace all cross dapp analysis in smartreco with traditional crosscontract analysis and smartreco will consider all the contracts encountered in the execution as unsafe.
the experimental result is shown in fig.
.
although without cda successfully reports the same amounts of true positives as smartreco does the failure to recognize the boundaries between contracts results in reporting an excessive number of false positives.
besides without cda needs to test all contracts blindly leading to more time costs section v f .
effectiveness of multi function fuzzing method.
to validate the effectiveness of the multi function fuzzing method we replace it with random fuzzing without mff .
in other words for each potential entry function smartreco attempts to generate input based on the original transaction and the function s abi to simulate a user interacting with two dapps simultaneously.
the result is shown in fig.
.
due to most users not having states in both dapps such as holding assets in both dapps most transactions revert as they cannot pass the internal check in both functions or cannot find the critical path of ror resulting in a significant amount of false negatives.
answer to rq each module of smartreco indeed helps reduce false positives and false negatives and improves detection effectiveness.
d. comparison with other tools to answer rq3 we use dlabeled to test with the two most advanced tools ityfuzz and sailfish as they are currently the most effective dynamic analysis tool and static analysis tool for detecting reentrancy vulnerabilities.
we obtain the publicly released artifacts of these two tools from their respective publications.
note that we do not compare smartreco with other popular tools such as icychecker which can only detect reentrancy within dapps and is not aligned with our scope.
besides mythril oyente and vandal have been proven less effective than sailfish in detecting reentrancy .
we conduct the tests using the default configurations of these tools with a time limit of five minutes and one hour for sailfish and ityfuzz respectively and manually identify the results as smartreco does.
after manual inspection the results are presented in fig.
.
we can observe that ityfuzz and sailfish are unable to detect any rors.
our further investigation finds that although ityfuzz has made optimizations in the fuzzing process such as usingon chain states to emulate the real environment and using waypoints to improve input quality it is not effective when it comes to ror as ror requires generating multiple function inputs simultaneously.
besides sailfish is a static analysis tool that lacks information about the execution context such as the specific address called by opcode call.
consequently its call chain is incomplete and cannot detect rors.
additionally both tools randomly select functions for testing which results in lower efficiency compared to smartreco .
answer to rq compared to advanced tools smartreco detects ror with higher precision and recall.
table ii overall effectiveness of smartreco ondunknown .
total smart contracts reported rorsdetection results tp fp precision .
e. large scale analysis for finding unknown rors to answer rq4 we evaluate smartreco based on dunknown and table ii shows the detailed results.
from table ii we can find smartreco reports rors.
to validate the results detected by smartreco our three domain experts independently verified the detection results and out of the vulnerabilities are confirmed by the experts and the overall precision is .
.
in addition out of these rors we discover that rors have not been publicly reported before and we find new functions that are suffered with rors.
the total asset affected by these rors is around usd.
we will analyze a case in section v g that can only be detected by the smartreco but not by other advanced tools.
answer to rq smartreco is effective in rors under complex dapp interactions in real world scenarios.
table iii performance of smartreco and without cda on dlabeled .
avg.
time seconds execution countper execution finding ror smartreco .
.
without cda .
.
f .
efficiency of smartreco to answer rq5 we use dlabeled to compare the efficiency ofsmartreco and without cda in terms of average time per execution the average time to detect ror and number of executions.
the results are shown in table iii.
note that we do not compare with without mff ityfuzz and sailfish because they do not detect any ror.
due to the caching mechanism although smartreco fetches on chain data thereis no need to repeatedly retrieve after the initial acquisition.
therefore the average execution time of smartreco is not high.
although the average time per execution of without cda andsmartreco are similar without cda has a larger search space and needs to execute more times resulting in lower efficiency in detecting ror compared to smartreco .
to this end the performance of smartreco will not be affected by the size of the dataset.
specifically since the cross dapp analysis can effectively filter the search space a larger dataset only leads to at most a linear growth in the number of functions and transactions that need to be analyzed.
answer to rq smartreco is rather efficient in detecting ror with large scale analysis.
g. case study fig.
is a real case detected by smartreco .
in detail joinpool is the entry point for becoming a member of entry dapp.
normally users need to synchronously transfer a certain amount of funds like eth as collateral.
besides joinpool provides a protection mechanism line in fig.
b to ensure that users do not transfer funds than expected.
to exploit ror in fig.
the first step is to trigger line and invoke line in fig.
b .
after obtaining control of the transaction attackers can obtain more funds through removeliquity in fig.
a .
however normal transactions are unlikely to trigger this path as this will incur higher costs.
we analyze all the transactions ofjoinpool in contract vault and find that none of them trigger this mechanism.
therefore solely relying on transactions for testing can result in potential false negatives.
smartreco can discover that joinpool is payable and will try to mutate the funds carried by joinpool ultimately triggering the protection mechanism and finding the ror.
vi.
d iscussion a. detection on deployed contracts smartreco primarily targets the deployed on chain contracts as simulating real dapp interactions such as obtaining a user s balance or a token price in an off chain environment is difficult.
in the meantime we would like to note that for dapps and their smart contracts before deployment smartreco can utilize existing united test suites or fuzzers to generate transactions and perform detection similar to existing research .
additionally detecting deployed contracts is with high value as it can help the dapp owners find risks in advance and take measures to reduce losses.
for example deploying a new contract and transferring the funds from the old contract to the new one.
b. threats to validity internal threats.
the internal threats of smartreco mainly come from its dependence on clear dapp boundaries.
the effectiveness of smartreco could be affected if it fails to accurately recognize the boundary of a given dapp.
however 1contract periphery 2function removeliquity public nonreentrant ... get outdated balance uint balance vault.getbalance iasset asset converterc20toassets balance withdrawtokens assets a the victim dapp contract.
1contract vault 2function joinpool address pool public payable nonreentrant ... processjoinpooltransfers if balancetotal balanceused root entry point of ror handleremainingbalance updatepoolbalance ... the manipulable function function getbalance view return balance b the entry dapp contract.
fig.
simplified real world smart contracts with ror.
for contracts with unclear boundaries smartreco will perform analysis on all unknown contracts.
as the results are shown in section v c although smartreco may miss some contract dapp information there will be no misclassification ensuring the effectiveness.
another major internal threat comes from the evaluation over a limited number of dapps i.e.
popular dapps .
since smartreco needs to test multiple functions simultaneously the time overhead is larger than traditional single contract fuzzing tools which has limited our ability to conduct larger scale evaluations.
however compared to randomly selected dapps the dapps in our dataset are representative as they are top popular dapps.
external threats.
the external threats of smartreco mainly come from the inability to analyze non solidity languages such as vyper and contracts without source code.
this is because smartreco relies on slither which is based on solidity source code for analysis although the latest version of slither claims to cover vyper it currently only supports version .
.
.
we consider this to have a relatively small impact on the effectiveness of smartreco .
on the one hand solidity is currently the most mainstream smart contract development language .
on the other hand most dapps tend to open source code as users are more willing to invest in open source dapps.
to this end smartreco only misses a small portion of contracts.vii.
r elated work vulnerability detection in smart contract.
at present most research uses static and dynamic analysis to detect vulnerabilities in smart contracts.
static analysis detects vulnerabilities by analyzing the source code or bytecode of contracts.
for example defitainter uses decompiled bytecode to detect price manipulation.
slither translates source code into an intermediate representation called slitherir and performs analysis on it.
due to their inability to obtain execution context information they miss critical information and cannot fully recover the call graph when detecting ror.
on the other hand dynamic analysis technologies try to generate inputs that satisfy specific requirements such as covering more branches.
then by executing the inputs they can monitor the runtime status of the program and detect vulnerabilities .
however the lack of effective input generation methods in existing tools leads to a significant number of false negatives in ror as it is difficult for them to bypass the internal check in functions of several dapps.
reentrancy in smart contract.
reentrancy is one of the most common vulnerabilities in smart contracts and in recent years many studies have focused on reentrancy .
for example revuldl uses deep learning methods to detect reentrancy.
ityfuzz employs online fuzzing methods to provide realistic testing.
clairvoyance uses pathprotective techniques to identify potential paths for detecting reentrancy.
icychecker uses replay to find out potentially vulnerable functions.
however existing works on reentrancy appear to have very limited capability as they overlook the potential correlations between contracts such as using dapp information to detect vulnerabilities.
unlike existing approaches smartreco incorporates cross dapp analysis to obtain more fine grained information and uses a multi function fuzzing method to effectively detect ror a novel type of reentrancy vulnerability.
viii.
c onlucsion in this paper we focus on the detection of ror based on fine grained cross dapp analysis.
we introduce smartreco a novel detection framework to detect rors.
specifically we propose a new dapp identification method to identify dapp boundaries from smart contracts.
additionally smartreco collects dapp based contextual data based on replay and uses this information to find potential entry functions.
then smartreco employs a multi function fuzzing method to detect rors.
experimental results show that smartreco achieves good effectiveness outperforming existing advanced tools.
besides smartreco successfully detects rors that have never been reported in real world smart contracts.
acknowledgment this research is supported by the national key research and development program of china 2023yfb2704801 nsfc rgc collaborative research crs hkust602 the major key project of pcl grant no.
pcl2023a05 .