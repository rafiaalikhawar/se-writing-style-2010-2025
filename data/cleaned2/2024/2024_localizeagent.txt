an llm based agent oriented approach for automated code design issue localization fraol batole computer science department tulane university new orleans la usa fbatole tulane.edudavid obrien computer science department iowa state university ames ia usa davidob iastate.edutien n. nguyen computer science department the university of texas at dallas dallas tx usa tien.n.nguyen utdallas.edu robert dyer computer science department university of nebraska lincoln lincoln ne usa rdyer unl.eduhridesh rajan computer science department tulane university new orleans la usa hrajan tulane.edu abstract maintaining software design quality is crucial for the long term maintainability and evolution of systems.
however design issues such as poor modularity and excessive complexity often emerge as codebases grow.
developers rely on external tools such as program analysis techniques to identify such issues.
this work leverages large language models llms to develop an automated approach for analyzing and localizing design issues.
large language models have demonstrated significant performance on coding tasks but directly leveraging them for design issue localization is challenging.
large codebases exceed typical llm context windows and program analysis tool outputs in non textual modalities e.g.
graphs or interactive visualizations are incompatible with llms natural language inputs.
to address these challenges we propose l ocalize agent a novel multi agent framework for effective design issue localization.
l ocalize agent integrates the specialized agents that analyze code to identify potential code design issues transform program analysis outputs into abstraction aware llm friendly natural language summaries generate context aware prompts tailored to specific refactoring types and leverage llms to locate and rank the localized issues based on their relevance.
our evaluation using diverse real world codebases demonstrates significant improvements over the baseline approaches with l ocalize agent achieving and relative improvements in exact match accuracy for localizing information hiding complexity and modularity issues respectively.
index terms large language models llms multi agent static program analysis code design issue localization i. i ntroduction software design quality is crucial for the long term maintainability extensibility and evolution of systems.
as a project evolves design issues such as poor modularity tight coupling and excessive complexity often emerge hindering developer productivity and system quality.
these issues if left unaddressed lead to the accumulation of technical debt resulting in increased development costs and decreased software reliability .
thus an approach that automatically addresses these design issues could be widely beneficial and adopted toreduce development costs and promote developer productivity.
with recent advancements in code intelligence tasks since these prior works the next logical step towards automated refactoring is design issue localization.
large language models llms have demonstrated significant capabilities in code related tasks .
however their potential for recognizing software design issues remains largely unexplored.
our rationale of leveraging llms is based on the fact that llms have been trained on a vast amount of source code and demonstrated strong capabilities in several codesemantics reasoning tasks involving intricate relationships in a codebase.
we hypothesize that they can identify flawed relationships among components such as misplaced methods or other irregular code structures and suggest refactoring changes e.g.
moving methods to more appropriate locations without using thresholds or hard coded rules.
however llm based approaches face key limitations in this domain.
first source code is complex and its inherent structure makes it difficult for llms to correctly parse and leverage effectively .
these struggles arise from the misalignment between the structured nature of programming languages and the non structured natural language nl texts that llms are primarily trained on.
second our preliminary experiments indicate that llms tend to generate incorrect results when dealing with program semantics across abstractions.
thus a more appropriate representation for llms should be both natural language friendly andabstraction aware .
this paper presents l ocalize agent a novel agent based framework that bridges this gap and explore llms capabilities in improving software design.
inspired by recent works on llm based frameworks for other tasks l ocal izeagent focuses on design issues identifiable within a single class e.g.
god classes and feature envy .
it leverages the results of program analysis tasks to synthesize nl summaries of system designs fitting for llms.
our key insight is that by combining multi agent design context aware prompting andllm friendly code representations we can overcome the limitations of current llm based approaches and enable more effective design issue localization.
we design l ocal izeagent with the following major ideas first multi agent collaborative framework recent works have started to investigate llm based agents that prepare task specific data for llms .
motivated by such works we introduce a novel multi agent system consisting of llm based and program analysis based agents responsible for collaborative tasks to predict future refactoring activity.
this framework comprises of a design issue analysis agent that leverages program analysis tools to identify potential design anomalies a program analysis agent that extracts relevant context from the codebase using established and lightweight program analysis techniques a context aware prompt building agent that dynamically constructs prompts based on previous analysis results and an llm based ranking agent that prioritizes localized design issues based on their impact and relevance.
this ranking agent is inspired by the work on llm based software activity ranking .
second llm friendly code context representation inspired by next on representing execution traces in a natural language we propose a novel representation of program analysis outputs tailored for llms.
traditional program analysis output often comprises of massive amounts of program dependency graphs pdgs or full abstract syntax trees asts which are difficult or infeasible representations for llms to effectively process .
our approach addresses this by summarizing complex source code data into concise nl descriptions and preserving code structure through nl contextual summaries.
in brief program analysis can effectively summarize the heavily involved abstractions into a natural language format more suitable for llms .
third context aware prompt generation local izeagent introduces a prompt generation module that dynamically synthesizes prompts based on the specific refactoring context and code analysis summaries.
since our approach is designed as a framework it is extensible to accommodate additional refactoring scenarios and program analysis tasks.
to evaluate l ocalize agent we conduct an experiment on a diverse set of real world codebases from a refactoring dataset .
our results demonstrate that our approach achieves a relative improvement in accuracy for localizing design issues a improvement for complexity issues and a improvement for information hiding issues compared to the baseline llm based techniques.
moreover our approach demonstrates significant gains across different refactoring types with the best models outperforming the baselines by an average of to in exach match .
in brief the main contributions of this paper are as follows to our knowledge l ocalize agent is the first work proposing to leverage program analysis tasks to synthesize natural language summaries of relationships between system abstractions to facilitate design issue localization.
we introduce a multi agent llm agnostic framework localize agent that is adaptable for future llms refactoring activities and program analysis tasks.
a natural language based representation of program analysis output that enhances llms abilities to handle software design input more effectively than traditional static analysis based representations.
experiments on a real world dataset of refactorings resolving design issues demonstrate our tool s effectiveness and provide an evaluation benchmark for future research.
ii.
b ackground large language models llms have emerged as powerful tools for various code intelligence tasks demonstrating remarkable capabilities in code understanding and generation .
the application of llms has expanded rapidly across the software engineering domain encompassing tasks such as code translation automated program repair code review and fuzzing .
pomian et al.
generates and ranks extracted method refactorings.
recent advances in large language models introduce the concept of agents which are components that enhance the llm s capabilities by providing the additional contexts for specific tasks.
these interconnected agents enable llms to interact with external tools effectively expanding their problemsolving abilities beyond the confines of their initial training data.
for instance researchers have developed agents that allow llms to explore codebases execute and validate patches and formulate plans for complex tasks .
iii.
m otivation a. motivating example let us use a real world example to motivate our solution.
consider the example in fig.
.
we have a real world java class that violates the separation of concerns design principle.
the class handles multiple responsibilities such as error handling and progress monitoring leading to increased complexity and reduced maintainability.
as a result a software quality evaluation tool named pmd reports a high cyclomatic complexity score for the code before refactoring listing .
note that such a traditional software design evaluation tool like pmd is primarily used to detect high level code smells using code metrics and rules e.g.
god classes .
it cannot provide actionable suggestions on methods and classes such as code refactoring including splitting a god class or moving a method to another class etc.
one of our primary objectives is to bridge the critical gap between high level issue detection and actionable feedback.
in our work actionable feedback for fixing design issues and refactoring changes are treated as distinct tasks.
because refactoring may include changes that do not directly address design issues some of them may also remain unresolved through refactoring which falls beyond our scope .
in brief our focus is specifically on design issues that can be effectively resolved through refactoring.
localizing and fixing such design issues can be challenging for developers as it requires identifying the specific parts of the code that need to be changed.
we hypothesize that1... 2static void initialiseandinstallrepository iconfigurationelement remoterepositoryelem repositoryplugin localrepo multistatus status iprogressmonitor monitor submonitor progress submonitor.convert monitor string implicitstr remoterepositoryelem.getattribute implicit string reponame remoterepositoryelem.getattribute name if reponame null reponame unknown if true .equalsignorecase implicitstr try remoterepository repo remoterepository remoterepositoryelem.createexecutableextension class repo.initialise progress.newchild installrepository repo localrepo status progress.newchild catch coreexception e string message messageformat.format failed to initialise remote repository .
reponame if status !
null status.add new status istatus.error plugin.plugin id message e plugin.logerror message e else progress.worked ... listing code before refactoring ... 2static void initialiseandinstallrepository remoterepository repo string reponame repositoryplugin localrepo multistatus status iprogressmonitor monitor function body omitted for brevity ... listing code after refactoring fig.
a real world refactoring instance demonstrating variable parameterization note in listing red lines indicate code removed after refactoring.
yellow highlighting in listing shows the parameters that were removed and the green highlighting in listing shows the parameterized variables.
the large language models llms are able to identify flawed relations among software components and program elements such as misplaced methods and other irregular code structures and suggest refactoring changes to fix those issues.
however our preliminary experiment with llms e.g.
gpt4o using naive prompts reveals their limitations in effectively identifying and localizing design issues in listing .
observation .
llms ability to recognize and fix design issues is limited.
naive prompting techniques often fail to capture the nuances of design principles leading to ineffective localization of design issues in existing codebases .
observation challenges in processing complex code representations .
llms require global contextual information to understand and analyze design issues in codebases effectively.
however the use of complex code representations such as call graphs and program dependency graphs can pose challenges for llms due to their limited understanding of programming languages and the potential for inconsistent output due to unfamiliar input structure .
these limitations hinder llms ability to make informed decisions based on the complex relations and dependencies in source code.
b. key ideas from the observations we have the following key ideas when designing l ocalize agent key idea multi agent collaborative design issue detection and fixing suggestions recognizing design issues and deciding refactoring fixes is a complex task that requires analyzing various aspects of the codebase.
thus we introducea multi agent learning framework in which specialized agents collaborate to achieve the tasks.
we break down the problem into different subtasks each handled by specialized agents designed to process information to identify and fix the issues.
key idea to enable llms to analyze design issues effectively we introduce a novel code context representation that is tailored to their strengths.
based on observation traditional code representations such as program dependence graphs pdgs are complex and can exceed the context window of llms hindering their ability to process and understand the entire codebase.
thus we propose a lightweight analysis technique that generates the concise natural language summaries of code metrics and dependencies.
these summaries capture key project s structure making it understandable for llms.
key idea the effectiveness of llms heavily relies on the quality and relevance of the prompts .
generic or poorly constructed prompts often lead to suboptimal results as they fail to capture the specific nuances and requirements of different scenarios.
to address this limitation we introduce a context aware prompt generation technique that dynamically adapts the prompts based on the unique characteristics of each refactoring context.
by leveraging the information obtained from our agents we generate prompts that are tailored to the specific design issues and refactoring opportunities present within the codebase.
for instance as the above example requires a parameterizing variable refactoring the llm is prompted to identify both the variable and functions that need to be changed.
key idea while localizing design issues is crucial prioritizing and ranking these suggestions is equally important.
without a proper ranking mechanism developers may waste valuable time and resources addressing irrelevant or low impact suggestions.
we introduce an llm based ranking agent that leverages the collective knowledge and analyzing capabilities of llms and static analysis tools to prioritize the localized design issues.
c. problem formulation we formulate the design issue localization using llms as follows.
given a codebase cbwith potential design issues we aim to leverage llms to identify the specific functions or methods that should undergo refactoring to resolve these issues.
by localizing the design issues at the function level we aim to provide developers with actionable insights into which parts of the code require attention and improvement.
formally let cbbe a codebase having a set of functions f f1 f2 .
.
.
f n .
the goal is to identify a subset of functions f fthat exhibit design issues that can be fixed via refactoring.
the llms are tasked with analyzing the codebase cband generating a set of locations l l1 l2 .
.
.
l m where each location lirefers to a function fj f to be refactored.
iv.
l ocalize agent approach a. overview figure illustrates our approach for localizing design issues in source code.
it uses a cooperative communication paradigm where agents work together towards the shared goal of identifying design issues.
the communication structure is centered around the planning agent serving as the central authority that manages the information flow and delegates tasks to the other agents.
as seen in fig.
the planning agent begins by invoking the design issue analysis agent to run a static analysis tool on the input code identifying potential design issues.
using this information the planning agent then gets theprogram analysis agents to extract relevant code context by using lightweight analysis tools.
these tools are used to create short summaries in natural language that capture important details about the code s structure dependencies metrics and design attributes.
next the context aware prompt building agent creates customized prompts based on these summaries and types of refactoring identified by the planning agent.
these prompts are given to an llm to find specific design issues in the codebase and suggest refactorings.
finally llmbased ranking agent reviews the code its context and suggestions to prioritize the important issues.
b. design issues design issues in software systems manifest as structural problems that impede maintainability extensibility and code quality typically emerging when code violates fundamental principles such as separation of concerns information hiding and modularity .
the design issues in our study is grounded in the seminal work of hans van vliet .
for design issue analysis agent planning agent run a static analysis tool to identify the design issues source code program analysis agents check design issue extract relevant context to localize the design issues get the refactoring type needed context aware prompt building agent design issue localization source code parse the code abstract syntax tree extract relevant information .
fan in fan out run ml based predictive tool to identify the refactoring needed to fix the issues prompt query tailored based on code snippet input source code context based on select relevant information from s analysis output design issue localization prompt .
variable usage analysis .
class coupling metrics .
method call dependency natural language outputs design issues identification localization report ranking agent ranked suggestion a b c llm llm b c b input source code input source code c fig.
l ocalize agent architecture overview these issues we employ pmd a widely recognized static analysis tool to detect potential design issues in source code.
a comprehensive review of pmd rules was conducted to ensure alignment with the design categories listed in .
multiple authors engaged in rigorous discussions to categorize the pmd s rules based on their descriptions.
a specific evaluation scheme was implemented to ensure objectivity and reliability in the categorization process.
our criteria are the rule s primary focus its impact on reuse and maintenance and its relation to the design principles.
this process yielded eleven pmd rules corresponding to the design categories.
however the abstraction and system structure issues were not addressed via refactoring.
thus our analysis does not focus on three categories resulting in a final set of eight pmd rules.
these eight rules address three crucial aspects of software design modularity information hiding and complexity .
modularity which promotes the separation of concerns is assessed through rules detecting god class coupling between objects and data class .
information hiding essential for encapsulation and reducing dependencies is evaluated using rules for law of demeter and excessive parameter list .
complexity which significantly impacts understandability and maintainability is measured using rules for too many methods excessive public count and cyclomatic complexity .
c. refactoring types developers address the design issues through various mechanisms e.g.
architectural restructuring design pattern solutions or code refactoring.
in our study we focus on the historical refactoring changes that specifically address design issues.
we combine refactoring with static analysis to ensure we study the cases where refactoring demonstrably resolved design issues rather than considering all refactoring instances.
our filtering on design issues in section viii a2 resulted in the identification of four refactoring types that resolved those issues.
that also ensures the ground truth for our experiments parameterize variable pv ref this refactoring extracts a variable as a parameter reducing coupling and increasing flexibility in design.
inline method im ref inline method replaces a method call with the method s contents eliminating the need for a separate method and potentially reducing complexity.
inline variable iv ref this refactoring replaces variable