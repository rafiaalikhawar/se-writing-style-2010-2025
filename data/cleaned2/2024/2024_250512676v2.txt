arxiv .12676v2 may 2025understanding and detecting peer dependency resolving loop in npm ecosystem xingyu wang zhejiang university hangzhou china wangxingyu zju.edu.cnmingsen wang zhejiang university hangzhou china udehbsmw zju.edu.cnwenbo shen zhejiang university hangzhou china shenwenbo zju.edu.cnrui chang zhejiang university hangzhou china crix1021 zju.edu.cn abstract as the default package manager for node.js npm has become one of the largest package management systems in the world.
to facilitate dependency management for developers npm supports a special type of dependency peer dependency whose installation and usage differ from regular dependencies.
however conflicts between peer dependencies can trap the npm client into infinite loops leading to resource exhaustion and system crashes.
we name this problem peerspin .
although peerspin poses a severe risk to ecosystems it was overlooked by previous studies and its impacts have not been explored.
to bridge this gap this paper conducts the first in depth study to understand and detect peerspin in the npm ecosystem.
first by systematically analyzing the npm dependency resolution we identify the root cause of peerspin and characterize two peer dependency patterns to guide detection.
second we propose a novel technique called node replacement conflict based peerspin detection which leverages the state of the directory tree during dependency resolution to achieve accurate and efficient peerspin detection.
based on this technique we developed a tool called peerchecker to detect peerspin.
finally we apply peerchecker to the entire npm ecosystem and find that packages totaling versions suffer from peerspin.
until now we have selected problematic packages to report and received confirmations.
we also open source all peerspin analysis implementations tools and data sets to the public to help the community detect peerspin issues and enhance the reliability of the npm ecosystem.
i. i ntroduction with the widespread adoption of javascript and node.js npm the default package management system for node.js has emerged as one of the largest and most influential open source software ecosystems.
by october the npm ecosystem had indexed over .
million packages and over million package versions providing comprehensive metadata that includes version information and dependencies on other packages.
this extensive repository supports various applications and services enabling developers to share discover and manage code efficiently.
in npm besides the regular dependency it also introduced peer dependency for a package to specify that it relies on a specific version of another package which is expected to be installed higher in the dependency tree .
peer dependencies are usually used when a package is meant to be used alongside one specific package.
specifically peerdependencies are used to express the relationship between a plugin package and corresponding author.its host packages.
one example is react dom a plugin package of the host package react .
while react dom itself does not depend on react developers must ensure that the runtime environment has a compatible version of react before using react dom properly.
as a result react is specified as a peer dependency of react dom .
peer dependency is critical to npm.
our analysis shows that among the .
million packages in npm .
use peer dependencies and over of newly released packages have contained peer dependencies in the last four years.
though peer dependency is widely used in npm its resolution is a mess due to historical reasons.
early versions of npm v3 to v6 don t resolve peer dependencies automatically.
when detecting a peer dependency requirement they only give warnings to remind developers to install these peer dependencies manually.
since npm v7 the npm client has started to resolve peer dependencies automatically.
however specific peer dependencies can trap the npm client in an infinite loop which blocks and crashes the host pc system causing dozens of reported issues .
most discussions on these issues focus on walking around the problems rather than addressing their root causes.
as a result the underlying reasons for infinite loops remain unexplored.
we named this infinite looping problem caused by peer dependency resolution as peerspin .
peerspin can propagate through dependency chains.
if a package with peerspin issue is relied upon by downstream packages the resolution of the downstream package may also be blocked or crashed by peerspin.
even worse peerspin is very hard to debug as the npm client gets stuck without giving any information on stuck points or stuck reasons.
given the complexity of dependencies of npm projects peerspin poses a significant risk to the usability of the npm ecosystem.
previous studies on the npm ecosystem have primarily focused on regular dependencies such as vulnerability propagation .
however these studies do not consider the peer dependencies.
specifically abate et al.
highlight the complexity of dependency resolution but do not analyze the additional complexity introduced by different types of dependencies.
duan et al.
provide a matrix of common security risks in package management systems for interpreted languages and conduct an ecosystem analysis.
wyss et al.
propose a privilege management system to counter installation1time attacks propagating through software dependency chains.
however these studies do not address peerspin or methods to detect peerspin.
to the best of our knowledge peerspin has not been systematically studied so far.
to bridge this gap this paper conducts the first in depth study to understand and detect peerspin in the whole npm ecosystem.
we begin by systematically investigating the dependency resolution process to uncover the root cause of peerspin and propose two dependency patterns that could lead to it.
following that we design and implement an accurate and efficient detector allowing us to quantify the peerspin impacts on an ecosystem scale.
though conceptually simple we face two major challenges to achieving the analysis.
first peerspin issues are inherently complex to identify and understand.
it is caused by a logical flaw in the dependency resolution algorithm associated with the directory tree state during installation.
the dynamic complexity of the directory tree state may prevent detection through static analysis and peerspin might not manifest until the dependency resolution process is executed making it difficult to predict or identify in advance.
meanwhile peerspin is highly related to the directory tree and the tracking state of the tree further complicates detection efforts.
in addition peerspin causes the npm client to hang without providing helpful information.
even with all the installation logs the complex dependencies make it difficult for developers or users to identify the stuck point.
second detecting peerspin on an ecosystem scale is efficiently and accurately challenging.
although long installation times may indicate peerspin relying solely on installation time metrics for detection is inaccurate.
the npm ecosystem is characterized by complex dependency trees with each package typically depending on an average of other packages .
this extensive dependency means the installation process can be time consuming even without peerspin.
additionally long installation times can result from various benign factors such as large package sizes network latency or the processing of numerous dependencies.
consequently using installation time as an indicator for detecting peerspin can result in inefficiencies and inaccuracies.
to address these challenges we examine the resolution algorithm and find that peerspin occurs due to node replacement in the directory tree forming a duplicate sequence of nodes placed in the tree during installation.
we further propose a novel technique named node replacement conflict based peerspin detection for detecting peerspin automatically.
we design and implement a tool peerchecker which effectively addresses dependency resolution and integrates with detection methods to detect peerspin for the entire npm ecosystem.
we conduct extensive evaluations to examine the accuracy and performance of peerchecker.
for accuracy we compare the results of peerchecker of more than packages with the behaviors of actual installation using the npm client finding that the number of false positives and false negatives is zero which illustrates the accuracy of our detection method.
regarding performance with randomly selected package versions peerchecker is times faster than the npm fig.
peer dependencies of an npm package.
client in dependency resolution which allows us to extend our detection to the entire ecosystem scale.
to quantitatively analyze the impact of peerspin issues we ran peerchecker on the npm ecosystem analyzing data up to october .
peerchecker detected versions of packages that could cause the peerspin.
we reported the problematic versions of of these packages to their developers and received confirmations.
in summary our work makes four major contributions.
new study.
we conducted the first study of peerspin issues in the npm ecosystem.
our findings help stakeholders understand the characteristics of peerspin issues and provide guidance to fix these issues.
new technique and tool.
we propose a novel technique node replacement conflict based peerspin detection to achieve accurate peerspin detection.
we also design and implement a tool peerchecker to detect peerspin for the entire npm ecosystem.
ecosystem analysis.
we conduct the first ecosystemscale analysis to reveal the peerspin impacts.
our analysis shows that versions of packages suffer from peerspin.
we selected problematic packages and reported them to their developers and eventually received confirmations.
community contributions.
we open all peerspin analysis tools and data sets to the public at om zju sec peerchecker.
ii.
b ackground and motivation example in this section we first give preliminary knowledge of this paper.
then we present a real world example of peerspin to show the motivation of this paper.
a. background peer dependencies peer dependencies specify that a package requires a particular version of another package to be provided by the consuming project ensuring compatibility and preventing multiple instances of the dependency.
in figure the developer introduces a third party package as a regular dependency.
this third party package specifies its peer dependency.
consequently for proper functionality the developer must ensure that this peer dependency is satisfied in the local environment.
2before npm v7 the npm client did not automatically install sibling dependencies.
the installation of peer dependencies relied on manual installation by developers.
since npm v7 the npm client has automatically installed peer dependencies.
however due to the large number of dependencies in npm packages and the complexity of peer dependency rules the npm client struggles to handle peer dependencies in certain dependency patterns.
there is some terminology that needs to be clarified.
peerset for a given package the set of its direct and indirect peer dependencies forms its peerset .
for example in figure antd and its peer dependencies react dom andreact form a peerset .
peersource and peerentry if a peerset is introduced by a regular dependency for all packages in the set the source package of this regular dependency is called peersource and the target package is called peerentry .
for example in figure xydesign is a peersource forreact dom and react and antd is their peerentry .
dependency loading in node.js the require function is used to load dependencies.
when executing require the function searches the installation directory structure.
it traverses the parent level directories containing the current directory from the lowest to the highest level up to the root directory attempting to find the target dependencies under node modules in each parent directory.
based on the search rules npm s dependency management is essentially the organization of the installation directory tree which is structured according to the dependency relationships between packages.
by the definition of peer dependency in the node tree all packages in a peerset should be able to be found by their peersource according to the loading rules.
dependency model to ensure dependencies are loaded correctly npm considers both the tree structure of installation directories and the graph structure of dependencies.
as a result the npm dependency model combines both tree and graph structures clearly distinguishing the relationships between nodes in these two structures.
the key concepts of the npm dependency model are outlined below node and edge each node represents a specific package version denoted as nv and the edge represents the dependency relationship between packages denoted as nfrom nto req s which means the package nfrom depends on package nto reqrepresents the version requirement from nfrom tontoandsindicates the status of the edge.
during the package installation process the status of an edge can be classified as either valid orinvalid .
an edge is valid only ifntohas at least one version that satisfies nfrom .
node graph a graph composed of nodes and edges.
the node graph represents the dependencies described in the package meta information but does not represent the software installation directory structure.
fig.
motivating examples of a peerspin issue in installing xydesign .
node tree when npm installs a package it creates a directory structure to manage dependencies and facilitate efficient installation updating and usage of packages.
this directory structure is referred to as a node tree.
the root represents the current package installation directory and the tree represents the directory structure relationship of each package under the current installation directory.
the relative hierarchies of packages in the node tree and node graph may differ.
as shown in figure react is dependent on react dom and draft js .
when installing xydesign the npm client can place react at the same directory level as react dom anddraft js to reduce redundancy.
b. motivation example figure gives a real world example of peerspin.
the node graph indicates the dependency requirement between packages in which react is introduced as a peer dependency through draft js directly and antd indirectly .
when installing xydesign the npm client creates a directory tree called node tree .
the structure of the node tree is optimized to reduce redundant installation of dependencies.
in this example all dependency packages are attempted to be installed at the same directory level.
however draft js andantd have different and incompatible version requirements for react and they specify it as peerdependencies which prevents react from being installed in a subdirectory under draft js orantd .
the npm client will try to determine the exact version ofreact but whichever version is chosen will inevitably fail to meet the version requirements of either react dom ordraft js .
the npm client falls into an infinite loop where the two versions of react keep replacing each other resulting in an interminable installation process which we named peerspin.
the npm client can no longer respond to any user requests and the resources it consumes continue to increase eventually leading to a device crash.
3note that peerspin is distinct from dependency conflicts.
ifreact is a regular dependency the resolving algorithm can place the conflicting version within the react dom or draft js directory to remediate the conflict .
however in this case according to the peer dependency rules react must be placed at the same level as its downstream packages react dom anddraft js .
iii.
p eerspin infinite loop in peer dependency resolving to conduct peerspin impact study on the npm ecosystem we first need to understand how peerspin occurs.
therefore we present the systematic study of the peerspin issues in this section.
we explored the following two research questions rq1 root cause what is the root cause that the leading installation process cannot be terminated?
rq2 dependency patterns what are the common peer dependency patterns that can cause peerspin issues?
a. rq1 root cause in earlier versions of npm v3 to v6 peer dependencies were not automatically installed the developer only received a warning that the peer dependencies were not installed.
since npm v7 the npm client has introduced the arborist module npmcli arborist for dependency management.
the arborist module automatically installs peer dependencies leading to the emergence of peerspin issues.
nodes and edges node tree node graph and other elements of the npm dependency model are constructed and processed within the arborist module.
as the npm client has undergone numerous updates and feature additions the specification document has become incomplete and outdated.
it does not accurately reflect the dependency resolution.
this paper examines the dependency resolution process by modeling and debugging the source code of the arborist module.
we then uncover that the dependency resolution algorithm of the arborist module still has logical flaws and inadequate handling of special cases leading to the peerspin problem in peer dependency resolution identified in this paper.
our analysis shows that the npm dependency resolution algorithm uses breadth first traversal.
the algorithm maintains a tree and a queue of pending nodes.
nodes in the queue are already in the tree but their dependencies may not be satisfied.
the algorithm removes these nodes from the queue adds new nodes to the tree to satisfy dependencies and places the new nodes back in the queue.
eventually the edges of each node in the tree are valid.
the core resolving process involves three sub steps node loading node placing and queue update .
node loading the purpose of node loading is to determine which nodes and their versions will be added to the node tree.
as described in the background a node and all its peer dependencies need to be visible to its parent node.
therefore the node loading process needs to load not only the current target node but also all its peer dependencies.
a necessary condition for the emergence of peerspin is the occurrence of dependency version conflicts which result in the a node adding.
b node replacing.
fig.
the state of the node tree changes due to the add or replace node.
replacement of one version with another.
during node loading two types of conflicts may occur.
the peer dependencies in the set can conflict either with each other or with a common direct dependency of the parent node.
however the dependency resolution algorithm does not terminate due to these conflicts but instead marks the conflicting dependencies as invalid and handles them in the subsequent node placing process.
these illegitimate edges can affect the state of the node tree during node placing potentially causing the resolution algorithm to fall into an infinite loop and lead to peerspin.
insight two types of conflicts peer to regular andpeer to peer may occur during node loading.
by default the resolution algorithm takes a loose approach to avoid conflicts involving peer dependencies thereby leaving the risk of peerspin to subsequent processes.
node placing adding a node and its peerset to a node tree as children of another node is called node placing.
according to the rules mentioned in ii a2 a node is more likely to be reused if it is placed at a shallow depth in the node tree.
therefore the core algorithm for node placement is to place the node as shallowly as possible in the node tree while ensuring it can be found by its peersource.
when placing a node in the node tree depending on whether a child node with the same name as the node to be placed already exists at the intended location it can be classified into the following four scenarios add the current location doesn t have a child node with the same name as the node to be placed so the node can be placed directly at the current position.
keep the current location already has a child node with the same name as the node to be placed and its version satisfies the dependency requirements.
replace the current location has a child node with the same name but a different version than the node to be placed so the new node replaces the existing one.
conflict placing a node at this position disrupts a currently satisfied dependency in the node tree.
4algorithm node placing.
require n the node to be placed 1pos getstartpos 2type conflict 3while ndo t canplace n pos ift conflict then break end type t lastpos pos pos pos.updirectory 11end 12iftype conflict then exit 14else iftype keep then return end 18end 19iftype replace then lastpos.replace n 21else lastpos.place n type add 23end 24treeprune in the four scenarios above the keep type will not change the status of the node tree.
if conflict occurs the node placement process will continue searching for another position.
however add and replace may change the status of the node tree potentially invalidating valid edges.
these invalid edges need to be reprocessed later to restore their validity.
for example in figure introducing b2deeper into the tree than b1 or replacing b1withb2 will cause ato fail to load the correct dependency version according to npm s dependency loading rules.
the pseudo code for the node placing algorithm is shown in algorithm.
.
the node placement process begins at the deepest possible position where the node can be placed.
for peer dependencies this is at the same level as the peerentry.
the process then iterates upward through the directory levels of the node tree finding the last position where no conflict occurs lines 10 .
if no suitable position is found the resolution algorithm reports an error and terminates line .
the algorithm does nothing if the placing type is keep line 17 .
in other cases the node is replaced or added atlastpos lines 22 .
finally any nodes in the node tree affected by the add or replace must be deleted line .
taking figure as an example when node antd is placed its peerset which includes react dom andreact is also placed.
since no package with the same name exists in the installation directory react is placed in the root directory.
the algorithm then attempts to place draft.js and its peerset which includes incompatible versions of react .
node replacing is performed.
after the replacement since react dom s dependency on react is not satisfied react dom is removed.
additionally antd s dependency on react dom is marked invalid.
during the subsequent reprocessing of react dom a similar replacement occurs causing the resolution algorithm to enter an infinite loop.
insight during the node placement process the status of the node tree may change as nodes are added or replaced.
however since the algorithm relies solely on the current status of the node tree the process of changing the node tree can enter a loop leading to peerspin.
queue updating the npm dependency resolution relies on a breadth first traversal algorithm that uses a queue of nodes to manage the processing and determines termination based on whether the queue is empty.
therefore the queue must be properly updated.
the queue update process involves adding two main types of nodes those placed in the node tree during the current round of node placement and those in the tree with invalidated edges due to node additions or replacements.
in the subsequent out queue processing the edges of these nodes are resolved and new nodes are loaded and placed in the node tree to validate these edges.
if a sequence of nodes continuously cycles in and out of the queue as they are processed by the algorithm generating an infinite loop of enqueue and dequeue operations the queue will never be empty.
consequently the algorithm will get stuck in repeated processing of that sequence of nodes resulting in peerspin.
if the nodes and their dependency satisfaction remain constant in the node tree they should not re enter the queue.
however peerspin involves the same nodes being enqueued repeatedly and the edges of these nodes being processed repeatedly.
this means that the status of these edges must change from valid toinvalid during node placing.
therefore between two instances of the same node being enqueued there must be a replacement of either that node or its dependencies.
replacing the node itself may invalidate the edge pointing to this node causing the source node of the edge to be added back to the queue.
this node is then re placed and re queued.
if a dependency of this node is replaced the edge pointing to this dependency may become invalid causing this node to be added back to the queue and its dependency to be placed again.
additionally to create a looping replacement the node replacements leading to the loop must be bidirectional.
this means that the replacing node and the replaced node must interchangeably replace each other during their respective node placement processes.
therefore these two nodes must have the same name indicating that they represent the same package.
a pattern a b pattern a example c pattern b d pattern b example fig.
two patterns and examples for peer dependency resolving loop.
means regular dependency.
99kmeans peer dependency.
99kmeans node replacement.
insight two nodes responsible for peerspin must be peer dependency nodes with the same name but different versions.
as these two nodes replace each other their associated dependencies become unsatisfied causing the nodes to be re queued and waiting to be placed again thus creating a cyclic sequence.
b. rq2 dependency patterns insights to reveal that two types of conflicts peerto regular and peer to peer are not adequately managed during node loading.
these conflicts result in node replacement during the subsequent node placing process invalidating previously satisfied dependencies in the node tree and causing repeated entries of related nodes into the queue leading to peerspin.
based on these insights we categorize two peer dependency patterns that can lead to peerspin.
pattern a peer dependencies conflict with the common dependencies of their peersource.
this conflict results in node replacements causing the dependency of peersource on peerentry to fail.
consequently peersource repeatedly enters and exits the queue and the conflicting dependency is processed again leading to a peerspin.
in figure 4a adirectly has a regular dependency b1 b1indirectly has a peer dependency which points to itself but with a different version b2.
since the two versions are incompatible they will be stuck in a loop of replacing each other.
for example in figure 4b a .
.
has a regular dependency b .
.
while b .
.
depends on b .
.
through c .
.
as peer dependency.
when b .
.
is out of the queue to be processed the node loading process will load peerset of b .
.
which are b .
.
andc .
.
b .
.
can not be loaded due to b .
.
already existing .
after b .
.
andc .
.
are placed in the node tree the algorithm needs to handle the dependency of c .
.0onb .
.
.
it will replace b .
.
tob .
.
to make the dependency of c .
.
onbvalid but it simultaneously makes the dependency of a .
.
onbinvalid causing the peersource a .
.
to enter the queue again.
then a .
.
will be processed again and replaced with b .
.
tob .
.
which makes the dependency of c .
.
onb invalid again and c .
.
into the queue again.
the algorithm falls into an infinite loop.
pattern b conflicts between peer dependencies within a peerset result in node replacements causing the dependency of peerentry on the node within the peerset to fail.
as a result peerentry repeatedly enters and exits the queue leading to the conflicting dependency being processed again which in turn leads to a peerspin.
in figure 4c ahas a regular dependency b bhas two peer dependencies on different dependency paths pointing to two incompatible versions of c. these two version of cwill fall into a loop of replacing each other.
in figure 4d a .
.
regular dependency on b .
.
b .
.
has two peer dependencies on c .
.
and d .
.
.
when b .
.
is out of the queue to be processed the node loading process will load peerset of b .
.
which are b .
.
c .
.
and d .
.
c .
.
can not be loaded due to c .
.
already existing .
after the nodes of peerset are placed in the node tree the algorithm needs to handle the dependency of d .
.
onc .
.
.
it will replace c .
.
toc .
.
to make the dependency ofd .
.
oncvalid but it simultaneously makes the dependency of b .
.
oncinvalid causing the peerentry b .
.
to enter the queue again.
then b .
.
will be processed again and replaced c .
.
with c .
.
which makes the dependency of d .
.
oncinvalid again and d .
.
into the queue again.
the algorithm falls into an infinite loop.
notably the patterns include only the minimal node sets required to produce peerspin.
these patterns are not mutually exclusive but have the potential to occur simultaneously and multiple times in one dependency graph.
even when adding intermediate nodes to the dependency graph as long as no conflicts are introduced and the type of dependency of the inserted node matches the type of the inserted edge the peerspin problem remains.
that also brings the challenge of peerspin detection.
iv.
p eerspindetection to quantify the impact of peerspin on the entire npm ecosystem we need to detect it accurately and efficiently.
in this section we introduce peerchecker a tool designed to investigate the impacts of peerspin in the npm ecosystem.
figure provides an overview of peerchecker.
peerchecker intercepts the state of the node tree performs status checks and records the position of the node to detect peerspin.
6fig.
overview of peerchecker .
a. design in rq1 we find that the direct cause of peerspin is the node replacement cycle.
this cycle arises when the replacement of nodes leads to dependency conflicts causing some nodes to re enter the queue repeatedly.
therefore we propose a novel detection technique node replacement conflict based peerspin detection that identifies nodes that may trigger peerspin by detecting dependency version conflicts due to node replacement.
the basic idea of this detection approach is to mark nodes that may cause subsequent loops based on the current state of the node tree after node replacement and to monitor the behavior of these nodes during subsequent dependency resolution.
first we monitor the behavior of each node replacement during dependency resolution intercepting and collecting the current state of the node tree.
after a node in the tree is replaced the dependency satisfaction of its peersource and peerentry may be broken as shown in the examples of pattern a and pattern b .
this causes the peersource or peerentry to re enter the queue.
subsequent peersource and peerentry being processed again may result in node placement of another version of the target node leading to node replacement.
thus we consider the replaced nodes which cause the dependency satisfaction of peersource or peerentry to break as risky nodes .
second for each node in the node tree its position determines how it is found according to the dependency loading rules.
therefore the position information must be unique.
we record and count the position information for all risky nodes .
if a node is replaced multiple times at the same location it indicates that the node has generated a loop replacement.
algorithm presents the pseudo code of the detection algorithm.
when node replacement occurs we calculate the peersource and peerentry lines .
then we first check the dependency edge of peersource onpeerentry .
if the edge is invalid it indicates that the dependency satisfaction is broken lines and .
peersource needs to re enter the queue which may result in n being replaced by nin subsequent processing.
if peersource is not affected we proceedalgorithm peerspin detection.
require n node.
require t node tree.
1t.replace n n 2risky flase 3source n.getsource 4entry n.geentry 5foredge source.edges do ifedge.to entry edge.isv alid then potentialrisk true goto pc end 10end 11foredge entry.edges do ifedge.to n edge.isv alid then risky true goto pc end 16end 17pc 18ifrisky then pos getposition n t poscount ifposcount 1then return peerspin end 24end to check peerentry .
if the dependency of peerentry on the replaced node n is broken peerentry needs to reenter the queue.
in both scenarios we need to mark node n as a risky node lines and .
if there is a risk node the algorithm performs position counting pc starting at line .
we use the path from the root node of the node tree to the target node as the location information and use the pair of the node and its position as the key to count the occurrences.
take figure 4b as an example when b .
.
replaces b .
.
the detection algorithm first checks the peersource ofb.
the algorithm recognizes that this node replacement makes the regular dependency from peersource a .
.
onbinvalid.
it then marks b .
.
as a risky node and the position is counted.
in subsequent dependency resolution b .
.
andb .
.
continue to substitute for each other and repeat.
the second time b .
.
replaces b .
.
the detection algorithm performs similar checks as above then the position of b .
.
is counted again the algorithm detects that the same node is placed in the same position multiple times and reports peerspin.
b. implementation leveraging the node replacement conflict based peerspin detection technique we developed a tool called peerchecker to detect issues across the entire ecosystem.
figure provides an overview of peerchecker.
the major challenge is scaling 7table i detection accuracy.
npm clientpeercheckerpositive negative peerspin non peerspin this detection approach to the vast number of packages in the npm ecosystem.
the npm client is implemented entirely in javascript and the database backend it uses is not a high speed database but often slower with lower throughput.
these factors contribute to reducing the speed of dependency resolution for npm clients.
as a result we cannot use the npm client to conduct dependency analysis and detect peerspin at the ecosystem scale.
additionally existing dependency resolution tools don t consider peer dependencies so we can t reuse them.
to overcome this challenge peerchecker implements an efficient dependency resolution algorithm that simulates the node loading node placing and queue update processes.
during the simulation peerchecker monitors the state of the node tree performs status checks and counts positions to detect peerspin.
to achieve higher performance peerchecker is implemented entirely in c with data structures and algorithm steps optimized for accuracy and adapted to faster storage databases e.g.
redis and data formats.
c. evaluation our experiments run on ubuntu .
lts with amd epyc core processor .
ghz.
the npm client version is .
.
.
to ensure that the meta information used for dependency resolving is consistent and avoids network latency both the npm client and peerchecker use a local mirror database in this test.
detection accuracy to assess the accuracy of peerspin detection we used the npm client to verify the results obtained by peerchecker.
the test dataset sampling rules are as follows the testing dataset consists of positive andnegative samples.
positive .
we randomly selected of the package versions detected by peerchecker as peerspin package versions in total.
negative .
we denote the number of peerspin package versions detected by peerchecker as xand the number not detected as y. the rate of occurrence of peerspin is p y x y .
we then randomly selected undetected package versions according to this occurrence rate resulting in a total of package versions.
we used the npm client to install the sampled package versions in an empty directory and developed an automated installation log analyzer.
peerspin was considered to have occurred if the analyzer detected a loop log sequence created by node placement in the log.
as shown in table i for all positive samples the npm client occurs peerspin.
for all negative samples the npmtable ii performance testing results.
execution time average time speed ratio npm client 1m19.142s .142ms 1x peerchecker 0m5.573s .573ms .201x client completes the installation successfully.
the accuracy of peerchecker designed based on two basic patterns is confirmed.
performance the performance evaluation focuses on the time efficiency of the dependency analysis and peerspin detection tools discussed in this paper.
the tests were performed on a random sample of all package versions with a sample size of versions.
for testing peerchecker was run in daemon mode using a local cached database as a data source in the data collection section of npm with the thread pool size set to .
for comparison the npm client also uses the same local cached database and installs the same package versions in dry run mode.
it only runs the resolution algorithm without performing any real dependency installation.
it also maintained npm client processes in parallel.
the results of the performance tests are presented in table ii peerchecker is approximately times faster than the npm client at resolving dependencies even though the npm client does not perform any real dependency installation.
when performing dependency analysis on over million package versions in the entire npm open source ecosystem peerchecker can reduce the overall time consumed from approximately one month with the npm client to about three days which is acceptable.
v. e cosystem scale study we conducted a large scale analysis to understand peer dependency usage and the impact of peerspin on npm ecosystems.
our source data is derived from the official npm registry snapshot taken on october .
this dataset includes metadata and information on package versions including package names version numbers dependencies and release dates.
to drive our study we raise two research questions rqs .
rq3 usage .
how many npm packages use peer dependency?
rq4 impact .
how does peerspin affect the npm ecosystem?
a. rq3 usage of peer dependency to analyze the scale and preference of peer dependencies in the npm ecosystem we examine peer dependencies from two perspectives how many packages use peer dependencies and how many are used as peer dependencies?
peer dependencies are prevalent in the npm open source ecosystem.
approximately .
of packages used peer dependencies.
additionally to further analyze the use trend of peer dependencies we categorized new package versions 8fig.
proportion of dependency by type.
table iii the most influential package versions.
name version peer dependentreleased year react .
.
supports color .
.
react .
.
babel core .
.
react dom .
.
each year by dependency type and tracked their proportions.
there are three categories no dependencies only regular dependencies and peer dependencies.
the results are presented in figure .
the proportion of new package versions with peer dependencies .
added each year surpassed those without peer dependencies .
in .
this trend has continued to grow faster reaching .
in .
the temporal evolution of these proportions indicates that peer dependencies are gaining widespread popularity.
our analysis also found that only a very small subset of packages are used as peer dependencies.
in all the package versions that are used as dependencies in other packages only .
are used as peer dependencies.
this suggests that the widespread use of peer dependencies makes the stability of this subset critical.
since the influence of dependencies in the npm open source ecosystem is highly concentrated we identified the most influential package versions as shown in table iii.
the two incompatible versions of react are heavily relied upon by downstream packages which can result in the same downstream package directly or indirectly depending on the peer dependencies of both incompatible versions as shown in figure .
fig.
the number of problematic package versions of time evolution.
b. rq4 impact of peerspin we detect peerspin issues for the entire npm ecosystem and find versions of packages that suffer from peerspin.
we provided detailed logs to package maintainers encouraging them to update their dependency configurations and release new versions compatible with the affected versions.
we identified and reported problematic packages to corresponding developers at the time of writing receiving confirmations.
among these maintainers appreciated our reports and committed to adjusting their dependency configurations in future versions.
additionally packages have been migrated to new projects and we find that the new projects are unaffected by the peerspin.
for the remaining four packages maintainers suggested alternative approaches such as switching to yarn or reverting to an older version of the npm client as a temporary workaround.
figure shows the number of package versions in each year that are currently affected by peerspin.
there are minimal effects for packages released in and earlier.
since the number of problematic releases has grown growing rapidly at an average rate of .
peaking in before dropping slightly and remaining high over package versions per year .
the turnaround for the number of affected package versions occurred in and .
the npm client discontinued the automatic installation of peer dependencies in v3.
this feature was reinstated in v7.
the first official versions of npm v3 and npm v7 are released in june and oct respectively.
due to the lag of new versions of the npm being used on a large scale it can be assumed that the timing of the update and popularization of the npm client version coincides with the timing of the temporal evolution of peerspin issues.
before npm v3 the number of problems with released package versions was minimal due to the simplicity of applying peer dependencies and the small size of the npm 9table iv top critical packages that caused peerspin.
pkg weekly downloads affected pkgs affected vers react 23m angular core 3m eslint plugin flow type 4m typescript 55m rxjs 41m webpack 25m react dom 21m eslint 38m angular compiler 3m graphql 12m ecosystem.
since npm v3 stopped the automatic installation of peer dependencies peer dependency installation relied more on manual installation by developers and the number of peerspin issues increased rapidly along with the size of the npm ecosystem.
npm v7 resumed the automatic installation of peer dependencies which led to a more standardized installation of peer dependencies in the following years.
peerspin remains an issue due to historical legacy issues.
in addition the increasing complexity of dependencies due to the rapid development of the npm ecosystem is one of the main reasons for the increasing number of problematic versions as the main factor in peerspin is the conflicting versions of dependencies.
the average dependency update lag in the npm ecosystem is to months .
to see the potential risk posed by the dependency update lag we analyze the time gap between the problematic version and the latest version of these packages.
among these affected versions approximately .
are the latest versions of their packages and .
of these versions have a gap of less than days.
this suggests that prolonged non updating results in a certain number of packages not being able to install the latest version as well as more than half of the versions being in the update lag window posing a threat to downstream packages and npm clients.
we have also analyzed the reasons why these packages appear peerspin the critical packages are shown in table iv.
in the rq3 we analyzed the dependency relationships within thereact package.
our findings indicated that react has the highest number of peer dependents which is reflected in the fact that the packages affected by react are also the most numerous.
the main reason these packages cause a looping problem is updates to their major version numbers.
suppose a package has multiple requirements for its dependency packages with different semantic version ranges when the dependency packages are updated.
in that case the npm client is more likely to have conflicting version selections for the dependency packages which can result in two patternsdescribed in rq2 leading to problems.
vi.
l imitation peerchecker detects peerspin based on dependency resolution and has promising results but it still faces the following limitations.
first while the local environment can affect the result of dependency resolution peerchecker cannot collect relevant data from developers due to privacy concerns.
therefore peerchecker assumes dependency resolution from scratch.
the process constructs the node tree and node graph independently of the local environment.
peerchecker also assumes the resolution does not use files like package lock.json .
this means the process includes dependency resolution and version selection as usual rather than directly using the dependency directory tree specified in these files.
however since local environments can complicate dependency resolution we recommend that developers maintain an environment as clean as possible.
second the parameters for dependency resolution are set using the default parameters of the npm client during dependency installation.
this means that parameters such as global workspace prefer dedupe omit or any others that could change the resolution logic dependency type or installation result are neither used nor modified.
these operations may walk around the peerspin issue but may introduce another dependency issue i.e.
dependency incompatibility semantic inconsistencies runtime errors or other consequences in npm projects.
vii.
d iscussion we discuss how to reduce the occurrence and impact of peerspin from two perspectives npm maintainers and developers.
maintainers of npm .
the npm client allows the installation of different package versions in separate subdirectories to address dependency conflicts.
however this approach fails to address peerspin caused by conflicts in peer dependencies.
to avoid peerspin npm clients should audit peer dependencies and explicitly warn developers of version conflicts before installing.
additionally we suggest that the npm client implements a maximum iteration limit during peer dependency resolution akin to the resolutiontoodeep exceptions in pip python to prevent infinite loops.
for scenarios involving incompatible peer dependencies we suggest the npm client adopt a strategy similar to name mangling in cargo rust which distinguishes multiple dependency versions by unique names and version numbers to promote greater flexibility and system stability.
developers .
for developers when declaring peer dependencies it is important to be aware of the potential peerspin with other dependencies.
in addition it is not recommended that developers use fixed versions of peer dependencies but instead use loosely range versions.
due to the dynamic of the npm ecosystem developers should check for peer dependency compatibility regularly.
developers should keep not only peer 10dependencies but also regular dependencies as simple as possible.
the one reason for peerspin arises is the complex dependency relationship.
removing the redundant dependencies can facilitate the resolving process and reduce the risk of compatibility issues.
to further assist developers our tool peerchecker can help identify the presence of peerspin in peer dependency configurations.
additionally by analyzing detailed dependency chains peerchecker identifies which peer dependencies require modification.
using this information developers can resolve peerspin by adjusting conflicting version limits or migrating problematic peer dependencies into regular dependencies ensuring successful dependency installation.
viii.
r elated works dependency analysis .
dependencies are fundamental to modern software development and have received significant research attention.
latendresse et al.
investigate the impact of production released project dependencies on security and management.
abdalka reem et al.
analyze trivial dependency packages in npm and javascript applications.
decan and mens focus on the usage and compatibility issues of semantic versioning.
wang et al.
and li et al.
studied dependency conflicts across ecosystems and developed detection tools though similar research in the npm ecosystem is lacking.
wittern et al.
performed the first large scale analysis of the npm ecosystem revealing its evolution through direct dependencies.
decan et al.
compared dependency graph evolution in various programming ecosystems.
jens et al.
reviewed dependency declarations across ecosystems and categorized version classifications.
however most previous studies focus only on regular dependencies overlooking the different types of dependencies that have different implications for projects and ecosystems.
in contrast our work is the first to uncover a critical issue peerspin in the npm ecosystem arising specifically from peer dependencies a previously unstudied dependency type.
package manager analysis .
different package managers have different dependency management strategies.
existing works focus on comparing dependency management strategies across different ecosystems.
pietro et al.
systematically compared resolvers in various dimensions including conflict solutions range modifiers etc.
stringer et al.
analyzed package managers and demonstrated that technical lag which can lead to security vulnerabilities and make the software more vulnerable is common.
hanus et al.
designed a semantic version checker for verifying version semantics in package managers and integrated it into the package manager to fully automate the checking process.
jacobs et al.
analyzed the security properties of package managers and uncovered several design level vulnerabilities.
pereira et al.
reviewed the use of package manager and repository metrics to assess the security of npm packages.
however these works ignore the analysis of specific implementations of package manager policies.
specific features and limitations of a package manager are often tied to its internal implementation.
without a detailedexamination researchers may not fully understand why certain features are present or absent or why specific limitations or issues exist.
our study provides a detailed analysis of how the package manager handles peer dependencies within the npm ecosystem.
we believe this work offers valuable insights that can assist both developers and researchers in achieving a deeper understanding of npm dependency management.
dependency driven vulnerability propagation analysis .
the security implications of package dependencies particularly the vulnerabilities they introduce have been extensively studied in prior research.
zerouali et al.
analyzed version lag between package dependencies using the npm dataset from libraries.io .
chinthanet et al.
examined version lag and constraints on downstream packages.
decan et al.
assessed the impact of security vulnerabilities across package versions.
zimmermann et al.
analyzed npm security risks through dependencies and vulnerabilities using direct dependencies.
zerouali et al.
studied the impact of vulnerable dependencies on both npm and rubygems ecosystems.
liu et al.
proposed a knowledge graph based dependency solution studying the security threats posed by dependency tree vulnerabilities on a large scale.
alfadel et al.
examined the impact of vulnerabilities at various stages of disclosure.
wang et al.
analyzed blocked updates in critical dependency chains.
however these works predominantly address the security risks associated with vulnerable code introduced by third party dependencies.
in contrast our study highlights a novel concern even when the dependency code is non vulnerable the intricate relationships among dependencies can still result in severe issues ultimately affecting the stability and security of the ecosystem.
ix.
c onclusion in this paper we conduct the first in depth study to analyze the cause of peerspin and its impacts on the npm ecosystem.
we are modeling the npm client dependency resolution process to uncover the root cause of peerspin and two peer dependency patterns are also proposed to guide the following detection.
for peerspin detection we propose a novel technique nodereplacement conflict based peerspin detection for efficient and accurate detection of peerspin.
we also designed and implemented a tool called peerchecker to expand detection to ecosystem scale.
we identified package versions suffering from peerspin issues.
we report problems and get feedback.
all experimental data in this paper are available at x. a cknowledgment the authors would like to thank all reviewers sincerely for their valuable comments.
this work is partially supported by the national key r d program of china 2022yfb3103900 .