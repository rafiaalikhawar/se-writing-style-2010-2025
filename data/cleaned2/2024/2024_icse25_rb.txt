an empirical study on reproducible packaging in open source ecosystems giacomo benedetti oreofe solarin courtney miller greg tystahl william enck christian k stner alexandros kapravelos alessio merlo and luca verderame university of genoa case western reserve university carnegie mellon university north carolina state university casd school of advanced defense studies abstract the integrity of software builds is fundamental to the security of the software supply chain.
while thompson first raised the potential for attacks on build infrastructure in limited attention has been given to build integrity in the past years enabling recent attacks on solarwinds event stream and xz.
the best known defense against build system attacks is creating reproducible builds however achieving them can be complex for both technical and social reasons and thus is often viewed as impractical to obtain.
in this paper we analyze reproducibility of builds in a novel context reusable components distributed as packages in six popular software ecosystems npm maven pypi go rubygems and cargo .
our quantitative study on a representative sample of packages in each ecosystem raises concerns rates of reproducible builds vary widely between ecosystems with some ecosystems having all packages reproducible whereas others have reproducibility issues in nearly every package.
however upon deeper investigation we identified that with relatively straightforward infrastructure configuration and patching of build tools we can achieve very high rates of reproducible builds in all studied ecosystems.
we conclude that if the ecosystems adopt our suggestions the build process of published packages can be independently confirmed for nearly all packages without individual developer actions and so will prevent significant future software supply chain attacks.
i. i ntroduction reproducible builds to secure build integrity.
while the world runs on open source software software is rarely consumed as source.
the software build process that transforms source code to its consumed artifact is a long standing security risk.
in his turing award lecture thompson described a process to create an undetectable backdoor in software by modifying the compiler that compiles a compiler leaving no trace of the backdoor in source code.
nearly years later the attack on solarwinds subverted the build system to produce binary artifacts signed with solarwinds s official code signing keys and the event stream and xzsupply chain attacks try to inject malicious code into deployed components that are not visible in the source code .
the best known defense against build system attacks is creating reproducible builds a build is reproducible if executing the build on two or more different machines e.g.
by different organizations produces a bitwise identical artifact when given the same source code build environment and build instructions.
a reproducible build provides strong evidence that the build process was not tampered with and that the resulting artifact corresponds to the source code which is particularly important for high profile projects e.g.
tor and bitcoin and essential digital infrastructure.
approaches such as c hainiac build on top of reproducible builds to create collectively verified builds.
for example it is unlikely that google microsoft and amazon s build processes will be simultaneously compromised especially when the compromise of any subset of the parties is easy to identify.
achieving reproducible builds is widely viewed as very hard and currently only a few developers invest effort into reproducible builds.
there are many intricate reasons why a build may not be reproducible in practice for example time environment variables and build location may be embedded in binary executables and archive files that package artifacts.
in addition there are many more potential sources of system differences and non determinism in builds such as different system locales pseudorandom number generators used during compilation or code generation and process scheduling.
while the debian project has spent a decade removing sources of unreproducibility and has achieved over reproducible builds on amd64 reproducible builds remain a hard challenge a recent interview study of practitioners invested in reproducible builds highlighted many technical and social challenges of resolving build unreproducibility .
reproducible component builds to secure package ecosystems.
in this paper we consider reproducible builds in a novel context the reusable components distributed as packages with package managers in popular software ecosystems including npm javascript maven java pypi python go rubygems ruby and cargo rust .1today most applications are built with reusable open source components and build processes usually rely on the archives distributed with package managers rather retrieving the original source code from repositories.
attackers are actively exploiting the gap between the source code in a repository and the release of a package.
in the account controlling the popular pypi package ssh decorate was hijacked to upload a version that collected users ssh credentials to send them to a remote server an independent build of the package would have identified that the hash 1we use the terminology of components andapplications common in the discourse of software supply chains.
a component here can be any reusable software artifact including libraries frameworks infrastructure tools and noncode artifacts.
components are typically but not necessarily distributed as packages with a package manager .of the version in pypi differed from the one built from the source.
the xzattack also exploited this gap while the malicious code was obfuscated in the source code repository as a malformed compressed archive used as a negative test case it was only enabled by an autoconf file that was not in the repository.
the released dist tarball of xz included build instructions generated by the malicious autoconf file.
interestingly the debian reproducible builds project did not detect the xzattack because they used the released dist tarball as their source.
even though we do not study reproducibility of c c dist tarballs this is exactly the kind of scenario of manipulated distributed packages source or binary we address in this paper.
although the primary focus of the discourse on reproducible builds is on applications rather than components the limited prior research on component reproducibility paints a gloomy picture reporting severe reproducibility issues for most components studied in npm and pypi.
specifically vu et al.
attempted to match the code in over popular pypi packages with their original source code without actually building the packages and found a wide range of differences most benign.
furthermore goswami et al.
studied the build reproducibility of over versions popular npm packages and found significant challenges resulting from version drift of build tools.
in our work we explicitly adopt a much broader scope comparing practices in multiple ecosystems and analyzing the role of package managers tooling open source infrastructure has formed distinct communities interdependent ecosystems often around languages frameworks and platforms often with distinct practices and tools .
among others practices and tools for packaging and indexing artifacts differ widely between a compiled languages that share binaries and b interpreted languages that share archives of source code sometimes transpiled sometimes including some binary code extensions sometimes including code in multiple languages for instance the package managers npm and pypi have adopted entirely distinct toolchains.
different practices and tools may lead to widely different outcomes for reproducibility.
hence we specifically study the difference of component reproducibility across ecosystems and the influence of tooling choices in package managers.
research overview.
for the purposes of this study we consider reproducible packaging as producing a bitwise identical artifact from the same source code build environment and build instructions.
this analysis of reproducible packaging is distinct from but a necessary foundation for comparing a locally created artifact to a published artifact see section iii c .
we perform a quantitative study applying reprotest to a representative large random sample of packages in each of six packaging ecosystems npm maven pypi go rubygems and cargo and investigate the reasons for reproducibility issues .
specifically we answer the following research questions rq1 reproducible package builds how many pack ages are reproducible as is in each ecosystem?
we find that almost all packages in cargo and npm are reproducible but only very few to none are in rubygems pypi and maven.
go packages simply include a reference to a source code repository and do not include any artifacts therefore component builds are not relevant for go.
this highlights the substantial differences between ecosystems and also seems to initially confirm the gloomy reports of vast reproducibility problems from previous research.
rq2 causes of unreproducibility to what extent are unreproducible package builds caused by the toolchain and fixable through toolchain changes?
analyzing the causes of unreproducibility we find that nearly all unreproducible package builds were caused by nondeterminism in the build process e.g.
paths time file permissions locale that can be controlled by the package manager s tooling either through configuration or through small changes to the tools.
with configuration or tooling changes in rubygems pypi and maven almost all packages become reproducible in these ecosystems.
this result paints a much more optimistic picture than prior reports and our initial findings our results highlight that small changes to ecosystem wide tooling have a substantial lever to improve package reproducibility to the point that almost all packages are reproducible in each studied ecosystem without having to convince every single package maintainer to take actions to ensure reproducibility.
rq3 native code extensions to what extent does the presence of native code inside of packages influence build reproducibility?
ruby python and even javascript packages can include native code extensions.
analyzing specifically packages that contain native code extensions even though the package managers in these ecosystems incorporate native code differently e.g.
compiling it into the package vs. including source code our study shows that native code extensions rarely negatively influence reproducibility with reproducibility rates in each ecosystem almost identical to that of packages without native code extensions.
this is another positive finding highlighting that native code extensions do not pose additional barriers in practice.
rq4 reproducible builds and compilation to what extent does compilation of package dependencies into distributable artifacts of application affect the build reproducibility?
as components in ecosystems are usually used to build applications we explore the downstream effects of component reproducibility or a lack thereof for applications relying on components in the ecosystem.
we find that application builds using the studied packages are reproducible for of the go packages and greater than of the maven packages.
the results for cargo were more nuanced due to timestamps used as part of cryptographic signatures potentially all packages can cause downstream build reproducibility problems 2for simplicity we use the term reproducible when the package manager tooling does not insert any reproducibility issue.
3as noted in section iv b1 maven independently added timestamp related build reproducibility fixes too their tooling during the preparation of the camera ready version of this paper.however in practice these cryptographic signatures will not change and greater than of the studied packages had reproducible builds.
this is a final supporting piece that also points toward the message that package reproducibility may be a smaller obstacle than originally expected.
recommendations.
overall our results largely paint a positive picture for the studied software ecosystems.
our results indicate that package managers can take advantage of reproducible builds to protect against build system or account compromise by the following first the identified toolchain issues must be addressed by providing more options to control nondeterminism during the build process.
second package manager tooling should adopt default configurations that create reproducible builds without having each maintainer configure their build.
finally package managers must make buildinfo files available.
while our study did not consider build tool version drift prior work identified this as a significant challenge for npm without buildinfo files it is very challenging to compare our independent build with the packages distributed by package managers.
contributions.
in summary we contribute a large scale quantitative analysis of the state of reproducible builds across six software ecosystems contrasting the prevalence of reproducible package builds and infrastructure changes that can support increased reproducibility for each of the ecosystems respectively.
our results have implications for understanding how to improve the state of reproducibility on a macroecosystem level as well as concrete changes to support individual package users and developers.
source code data and additional material for this paper are available in our replication package .
ii.
b ackground a. packaging ecosystems software applications are routinely developed by reusing existing often open source components.
the application and its dependencies on components which again may depend on other components form a software supply chain .
components are usually distributed as packages with a package manager and corresponding package repository such as npm andpypi .
groups of packages their developers and their users often form an interdependent ecosystem .
software ecosystems are frequently underpinned by a common technological platform or market .
a software ecosystem can be defined as a packaging ecosystem when it revolves around package managers for a specific programming language .
a package within an ecosystem contains the files necessary for other software to use its functionality.
these may include source code and binary files as well as tests and documentation.
among those files there is usually a specification file containing information on how the package manager must build the package and other metadata.
there are two kinds of specification files static and dynamic.
a static specification file contains metadata that the package manager uses during the build process.
a dynamic file maycontain arbitrary code or elements that are executed by the package manager during the build process.
in the npm pypi and rubygems package ecosystems packages include primarily source code but may also include native code extensions .
native code extensions provide an api for compiled code usually written in c typically to optimize for resource intensive activities.
a packaging ecosystem typically comes with tooling to create and publish components as packages such as pipfor pypi and mvnfor maven.
most ecosystems have widely used standard tools but there may be competing tools such as npmand yarn in the npm ecosystem which provide different command line tools to interact with the same package repository.
in addition most tools are highly configurable for example pipuses a frontend backend approach where pip delegates the actual packaging to a configurable build backend in addition pipworks on two interfaces using two different specification files an interface legacy based on the setup.py file and another interface based on the pyproject.toml file.
similarly mvn is plugin based ingesting a pom.xml specification file to control the actions of various plugins.
b. distribution model figure shows a typical distribution model for packaging ecosystems.
it consists of two processes package and upload components as packages to repositories and installation and build of packages for applications.
components are usually developed and tested locally on a developer s machine or with some public build and continuous integration infrastructure.
the source code of open source components is publicly available and anybody can suggest modifications.
the package manager s toolchain can then be used to release the package as a distributable artifact.
at this stage the package manager takes the source code and the specification files collects dependencies collects and possibly compiles code and generates a package.
this process is controlled by the various configuration files in the repository and potentially additional command line arguments.
during the packaging stage information about the build environment can be captured as metadata e.g.
timestamps and release version .
the resulting package file is then uploaded in the ecosystem s package repository.
consumers of a component such as other components and applications usually use the packaged version in the package repository downloading and installing it through the package manager assuming that the distributed package corresponds to the component s source code in its public repository .
the dependencies of an application can be integrated during the build phase and included in the final artifact or they might be gathered and installed on the end user s system separately.
the resulting application can then be distributed to end users internally or publicly through various channels including direct downloads application stores and as packages in package ecosystems e.g.
common for developer applications like static analysis tools or test runners .start releasingbuild package source code specification filesupload package to registry e.g.
pypi tarball zip file packaging happens on the developer systemget package as a dependency for an applicationrelease the application may include code compilationbuild and publish the applicationinstall the application published on public private stores packaging and upload application build and installationa a b a compromise build process b upload modified packagec c compromise package registrye e use compromised packaged d use compromised dependencybuild thr eats dependency thr eatsfig.
.
workflow from source code to distribution.
various threats can affect the distribution model see figure .
according to ladisa et al.
these threats can be implemented through multiple attacks.
the build process can be compromised a due to weak configurations vulnerabilities or malicious components.
a modified package may be uploaded to the registry b by compromising the host or maintainer systems or by hijacking a legitimate account.
similarly a package registry can be compromised c .
once distributed compromised packages affect other packages or applications that use them d .
both package and application build processes may use compromised packages e .
reproducible builds are one countermeasure to ensure build integrity ensuring packages are built from current unmodified sources and dependencies.
c. challenges of reproducible builds in oss supply chains the idea of reproducible builds has been broadly promoted to ensure an independently verifiable path from source to published artifacts where verifiably no additional4vulnerabilities or malicious code has been introduced.
identical results for every build of a given source allow multiple parties to come to a consensus and highlight any deviations from the expected build result.
reproducible builds have two requirements that can be difficult to ensure the build process must be deterministic.
the build environment must be either recorded or pre defined.
build tools and programming languages were not originally designed for reproducibility and contain many causes of nondeterminism that affect build reproducibility.
lamb and zacchiroli provide an overview of common sources of nondeterminism during the build process build timestamps are the main source of unreproducible builds.
many tools embed timestamps inside build artifacts even though they may have limited practical value.
the reproducible builds project proposed the source date epoch environment variable as a way to communicate a fixed timestamp to build systems .
4malicious code already hidden in the original source or tools used in the build may be built reproducibly.
file ordering for the readdir system call is not specified in the posix unix standard and differently ordered file lists may affect build artifacts.
to avoid these issues build systems should impose a deterministic order on any directory iteration encoded in its artifacts e.g.
via an explicit sort .
archive metadata ofziparchives and tarballs i.e.
tar archives may contain timestamps and permissions for each file.
randomness intentional or accidental of any compilation or code generation step in the build may influence resulting binaries.
the reproducible builds.org project provides educational materials resources and tools to support developers and software projects in making their build processes reproducible including reprotest to automate the process of building a package multiple times in diverse environments and diffoscope to help find the differences between binary packages and directories.
beyond technical challenges recent research has studied the perceptions of reproducible builds and the social challenges to their adoption .
fourn et al.
analyzed enablers and blockers for adopting reproducible builds in the open source community.
they report that most industry practitioners considers reproducible builds to be out of reach reproducible builds are seen as valuable but not essential.
other studies confirm that many developers are not aware of reproducible builds when developing their software .
butler et al.
identified the need for reproducible builds from a security point of view and the reasons for their limited adoption minimal business impact and limited awareness and perceived challenges.
overall adoption of reproducible builds is uneven with dedicated efforts in debian achieving substantial success but minimal attention to reproducible builds in other areas.
with regards to reproducibility at the package level goswami et al.
examined the reproducibility of npm packages by comparing the build output of upstream repository code against artifacts stored on the npm registry.
vu et al.
did not directly focus on reproducible builds butthey argued for reproducible builds as a security solution to phantom artifacts highlighting how difficult it is to achieve reproducible builds.
in parallel with our study kenshani et al.
investigated the feasibility of automatically generating .buildspec files from metadata available in maven packages.
the build obtained by the automatically generated .buildspec file is then compared to the build hosted in reproducible central which keeps trace of reproducibility for part of the packages in the maven ecosystem.
as additional result of their study they conducted an explorative analysis trying to find common causes of reproducibility issues.
they conclude that reproducibility of maven packages can be achieved by trivial adjustments to the pom.xml file.
we confirm this speculation in section iv b1.
in another line of work randrianaina et al.
studied the impact of configuration options on reproducible builds in highly configurable systems i.e.
linux toybox and busybox.
by fixing the build environment they were able to understand how such options affect the build reproducibility.
we use a similar technical approach in this study to focus on reproducibility issues related to the package manager.
automatic approaches to support reproducible builds were proposed by ren et al.
with three tools reploc reptrace and repfix which localize and fix sources of nonreproducibility for debian applications.
here we focus more broadly on builds challenges across package ecosystems including different practices and policies adopted by communities and different evolution of dependency networks in different ecosystems .
iii.
r esearch design in this paper we conduct an in depth empirical study of reproducible builds in six packaging ecosystems to answer the four research questions we outline in the introduction rq1 how many packages are reproducible as is in each ecosystem?
rq2 to what extent are unreproducible package builds caused by the toolchain and fixable through toolchain changes?
rq3 to what extent does the presence of native code inside of packages influence build reproducibility?
rq4 to what extent does compilation of package dependencies into distributable artifacts of application affect the build reproducibility?
we use the following high level research design for each packaging ecosystem we randomly generate a large representative sample of packages and attempt to build them under varying environmental conditions from source code in their open source repositories.
this allows us to quantitatively study reproducibility rates across ecosystems.
based on our findings we then explore sources of unreproducibility and corresponding interventions in package manager toolchains to quantify how tooling changes affect reproducibility rates.
npm pypi rubygemscargo go maven stars log scale packagesfig.
.
the samples used in our analysis allow us to obtain the practices of the average developer dealing with reproducible builds.
thus most of packages in the samples have a very low popularity however our samples also contain some very popular packages.
a. analyzed packaging ecosystems we focus on ecosystems that revolve around package managers for specific programming languages.
to select the package ecosystems used in our analysis we searched for ecosystems representing a large community with over packages each we then used an informationoriented selection strategy maximum variation cases following case study research logic to identify a set of ecosystems with different characteristics e.g.
native code extensions dynamic specification files and with different strategies in their distribution model e.g.
compilation output binary bytecode plugin based build package indexing.
this process yielded the following six ecosystems cargo go maven npm pypi and rubygems.
we argue that this set of ecosystems represents the current software landscape.
their position regarding reproducible builds is critical for global software supply chain security posturing.
b. sample of packages given the size of the ecosystems and the prohibitively high cost of repeatedly building packages it is infeasible to analyze all to million packages in each ecosystem.
instead we analyze a large representative random sample from each and make statistical generalizations.
a packages rq1 rq2 to generate our sample of packages for each ecosystem we begin with a list of all packages in the packaging ecosystem indexed by ecosyste.ms.
in order to minimize the chance of build issues during the analysis we filter packages by checking for the presence of ecosystems specification files e.g.
package.json for npm and setup.py pyproject.toml for pypi discarding packages without them.
we then generate a random sample of packages from this pool.
we intentionally did not select only the most popular projects so that we can generalize our findings to the entire population of packages in the ecosystem rather than merely reporting numbers about the most popular packages.
as a representative sample it is expected that many of the analyzed packages have few stars5 but some are very 5stars are collected from ecosyste.ms apipopular in terms of stars as shown in figure .
having such a distribution of popularity allows us to obtain practices of average developer.
with the relatively large sample size results derived from this sample afford high generalizability with less than .
margin of error at confidence levels by standard sample size calculations.
the precise margin of error varies slightly between ecosystems due to their different population sizes and population proportion of reproducibility but the differences are negligible.
b packages with native code extensions rq3 to concentrate on the effect of native code on reproducible builds we generated a sample of packages with native code extensions and a second sample of packages without native code extensions.
to generate these samples we first started by dividing the packages from our rq1 sample according to whether native code extensions were present and designated them to the appropriate sample.
this resulted in a sample of pypi rubygems and npm packages with native code extensions and a sample of complementary cardinality without native code extensions.
however because we wanted these samples to contain packages so they were comparable to the rq1 sample we continued to draw fresh random samples from the whole package population until we found packages for each of the samples.
the detection of native code extensions in packages is ecosystemdependent it is based on the presence of specific files e.g.
the extconf.rb file for rubygems or configurations e.g.
the ext modules in the setup.py file for pypi .
the margin of error is again less than .
with confidence.
the complete list of criteria can be found in the replication package .
c compilation process impact rq4 similarly to rq3 to explore the impact of the complication process on reproducible builds we generate a sample of packages with packages that can be compiled.
for cargo go and maven we collected large random samples of packages each by applying the following filters 6for cargo the cargo.toml file must contain a binary target to allow the package manager to compile the project.
for go an entry point function i.e.
the main function must be present among the project files.
for maven the maven compiler plugin must be listed in the pom.xml specification file.
c. reproducibility analysis for packages rq1 for each package in our samples we identify the corresponding github repository and clone the most recent version of the code.
we then use the ecosystem s default command to build the package e.g.
pip wheel .
.
the list of package managers and commands that we used is available in our replication package .
when the open source repository is missing or the build fails the package is reported as missing and discarded from the analysis since it does not offer information on its build reproducibility.
in those cases a new package matching the same criteria is randomly selected from 6the other ecosystems i.e.
npm pypi and rubygems do not have a standard process to generate a compiled artifact.the whole package population to replace the discarded one.
we discarded about packages for each ecosystems before reaching the required number of .
the build failures were caused by missing system libraries and mistakes in specification files.
the package build reproducibility of all packages is tested using reprotest on the same machine.
fixing the build infrastructure specifications e.g.
toolchain versions dependencies operating system makes it possible to focus on the impact of reproducibility issues related to the package manager.
the tool is set up with a build command and a build output for each ecosystem.
for example reprotest variations time pip wheel w dist package path dist .whl the time variation is applied to the build of packages for pypi and the resulting wheel files are tested for differences.
reprotest runs one time for each variation.
our replication package contains the full catalog of the used variations.
we consider a build as reproducible when reprotest does not report reproducibility issues for any of the tested variations.
failing variations are recorded to subsequently investigate the causes.
we explicitly do not compare the compiled artifact with the artifact uploaded to the package manager for two reasons.
first identifying which specific revision of the source code repository was used to produce the released package is nontrivial and the subject of extensive research but entirely orthogonal to our exploration of whether a package can be reproduced from the same source code.
second environmental dependencies such as compiler versions system libraries and operating system configurations can vary significantly across different build environments leading to potential discrepancies in the compiled artifacts which is again orthogonal to our research on whether the package manager build process influences a package build reproducibility.
for example a recent comparison of an independent build of packages on ftp.debian.org found that only around of the published packages could be reproduced despite the fact that over of packages can be built reproducibly using reprotest .
hence we only compare build outcomes under different environments from the latest revision of the source code in the package s repository.
the results of the tests show which reproducibility issues have the biggest impact on build reproducibility.
we look for the reasons for unreproducibility behind the package manager implementations.
the majority of the analysis is done manually by looking at particular portions of code that appeared to be the cause of an unreproducibility problem.
we created several automated scripts to search for possible unreproducibility causes when reproducibility issues were not triggered by the package manager directly.
for example one such script looked for dynamic dates in specification files.
d. reproducibility analysis for compilation rq4 we examined cargo go and maven since they offer a proper compilation method.
the first two ecosystems yield binary files while the last one generates an archive with compiled java bytecode.
we employed the same methodologyas for the other research questions to examine the influence of compilation.
the configuration of the reprotest tool uses the same variations used for rq1 but it receives different build commands and builds outputs such as cargo build .
we use the assumption that the compiler requirements are known and that reproducibility problems are not the result of the compiler since we are interested in examining how package manager operations affect reproducible builds.
e. limitations and threats to validity evaluating build reproducibility includes technical details varying by the level of abstraction taken into consideration.
for the purpose of this study package manager impact on reproducible builds we designed our methods to identify reproducibility issues at the build infrastructure level.
by excluding reproducibility issues originated by the system level e.g.
architecture specifications we may miss unreproducible builds caused by the package manager because of platformspecific causes.
while build reproducibility has a binary result reproducible or not identifying causes of reproducibility issues is not as straightforward.
we used a specific tool reprotest in an attempt to identify the causes of reproducibility issues however reprotest may be subject to unexpected bugs and design issues that have the potential to impact our results.
to mitigate this risk we carefully reviewed the reprotest implementation and currently open issues on the code repository identifying a minor potential source of false positive unreproducible builds.
the tool may cause failure in the handshake with the package registry because of widely varying system time.
we reduced the range of this variation.
after patching this potential implementation issue we assume that the tool s results can be considered scientifically accurate.
we can statistically generalize our results to report trends for reproducible builds for the entire ecosystems with tight error margins.
this method analyzes the general representative behavior of package builds but we may miss the behaviors of individual developers for example the behaviors of a few developers of high impact packages may differ from those of the general population.
iv.
r esults we present results of our experiments by research question.
a. rq1 reproducible package builds as is attempts to reproduce packages as is without any changes to package manager toolchains yields wildly different results across ecosystems as shown in figure a first group of ecosystems achieves reproducible builds for nearly all the sampled packages.
specifically cargo and npm have reproducible package builds.
a second group of ecosystems achieves very low percentages of reproducible package builds.
specifically maven pypi and rubygems have .
.
and of reproducible package builds respectively.
cargomavennpmpypirubygems buildsecosystem reproducible as is reproducible w infr.
conf.
reproducible w patched pkg.
man.
non reproducible ext.
causesfig.
.
this figure shows the reproducibility of package builds across different ecosystems categorized as i reproducible as is ii reproducible with infrastructure configuration as requested by the package manager iii reproducible with a patched package manager and iv unreproducible due to external issues not related to the package manager.
localestimezonetimeumaskexec pathkernelfileorderingenvironment buildsvariations rubygems pypi maven fig.
.
percentage of builds per ecosystem that were unreproducible because of different variations.
takeaway rates of reproducible builds vary widely between ecosystems with some ecosystems having all reproducible packages whereas others have reproducibility issues in nearly every package.
b. rq2 tooling sources of reproducibility issues and fixes fortunately the situation is not as bleak as it might seem when analyzing the sources of reproducibility issues.
in figure we report that even in package ecosystems with low package reproducibility as as is most packages are reproducible if considering package manager toolchain configurations or small patches to package manager tooling.
for example just by changing the configuration options of the package manager toolchain maven and rubygems increase from .
to .
and from to .
reproducible package builds respectively.
as we discuss in section iv b2 our analysis led us to discover small changes that can be made to pypi s package manager that increase reproducible package builds from .
to .
thus what might be perceived as very low package build reproducibility is in fact quite promising.
in section iv b1 section iv b2 and section iv b3 we detail how changing the build configuration and tooling drastically increases the reproducibility of package builds and how some causes of unreproducibility cannot be easily solved contributing to answer rq2.
reproducible with infrastructure configuration we applied solutions proposed by the selected ecosystems to studyhow infrastructure configuration affects the build reproducibility.
by reviewing the reprotest logs we found that timestamps and permission masks are the largest contributing factors see figure .
in particular timestamp metadata leads to unreproducible builds for .
of maven .
of pypi and .
of rubygems packages.
all five studied ecosystems use archives to distribute package artifacts.
however cargo and npm drastically reduces actually removes in our sample the presence of reproducibility issues caused by hard coding fixed values in their package managers code.
the other three ecosystems use a different approach because they use the current time or file timestamps unless developers set a specific build time by configuring the package manager using the package manager as is makes builds unreproducible.
the packaging infrastructure can be configured to help remove sensitivity to timestamp metadata.
for example the pypi and rubygems packaging infrastructure can set the build time using the source date epoch environment variable.
however the variable value must be communicated along with the package e.g.
via a .buildinfo file .
in contrast maven allows the developer to use the outputtimestamp pom specification file property to set a fixed timestamp in the package metadata.
unfortunately this solution suffers from two major limitations the developer has to set it in the pom.xml file it is not by default 7and maven plugins have to implement this feature to make it effective.
in general the studied package managers do not require or suggest that configuration of the build infrastructure is necessary.
among the three ecosystems only maven s documentation clearly explains how to achieve build reproducibility.
this lack of information for other ecosystems combined with the challenges of communicating build parameters e.g.
source date epoch is likely a large factor for unreproducible package builds.
finally pypi package build reproducibility is largely impacted by both timestamp and umask values.
umask values cannot be addressed via packaging infrastructure configuration and are discussed in section iv b2.
that said different package manager tools operate differently.
recall section ii pipis a frontend to deal with multiple building backends.
it refers to the specification file to invoke the right backends.
we found that the flit and hatch building backends fix the archive metadata similar to cargo and npm.
since of pypi builds use either flit orhatch they are reproducible as is.
however most of the remainder of the pypi ecosystem suffers from archive metadata reproducibility issues.
7during the preparation of the camera ready version of this paper an automation was proposed and implemented in maven .
.
beta issues.a pache.org jira browse mng that sets a default timestamp.
packages that only have this timestamp reproducibility issue should build reproducibly in the future.takeaway configuring packaging infrastructure to control timestamp metadata makes over of maven and of rubygems package builds reproducible.
reproducible with patched tooling while controlling timestamp metadata via infrastructure configuration has a significant impact on package build reproducibility it does not address all issues.
in this subsection we investigate how patching the packaging tools can address umask and other contributing factors.
as shown in figure umask is also a large contributing factor for pypi.
as for timestamp reproducibility issues most of the issues caused by umask affect the archive metadata.
the source of much of the remaining unreproducibility are dynamic metadata.
recall from section ii that dynamic metadata allows rubygems and pypi developers to define a metadata value in the specification file programmatically.
developers define dynamic metadata using the ecosystem s language or specific properties offered by package managers.
the value is then interpolated within the build environment.
we identify five root causes in the pypi and rubygems package managers file ordering locales umask time and timezone.
examples of these causes can be found in our replication package.
the code creating dynamic metadata is defined in packages.
contacting package maintainers to modify their code to produce reproducible package builds would be very timeconsuming and may not result in changes to the build specifications.
for example a recent interview study of practitioners working on reproducible builds found that project maintainers are not always receptive to making changes simply to make a build reproducible .
we propose patching packaging tools to enable reproducible package builds.
the patched tools can be found in the replication package.
our key insight is that packaging tools can set default environments and post process dynamic metadata to ensure build determinism .
as shown in figure these patches have a drastic impact on the package build reproducibility of pypi increasing the percentage of reproducible builds from to .
as suggested by the reprotest variation data shown in figure most of this increase was the result of addressing umask determinism.
rubygems also received a meaningful impact increasing the percentage of reproducible builds from to .
.
while this increase is small the ability to achieve almost reproducible package builds is extremely valuable for the ecosystem.
takeaway package managers can set default environments and post process dynamic metadata to provide reproducible package builds without changing code in individual packages.
unreproducible packages as shown in figure not all package builds could be made reproducible by configuring package infrastructure or patching the package managers.
we randomly sampled some of these packages to investigatecauses of reproducibility issues.
recall that pypi has multiple backends to produce a package and these backends use either a setup.py or a pyproject.toml specification file to interface with the build process.
developers using setup.py can run arbitrary code during the build.
reproducibility issues caused by this code are not easily addressable.
for example statements using the os.path.expanduser function make the build unreproducible because of the home variable.
this kind of actions can hardly be managed by the build infrastructure because i the infrastructure cannot alter external libraries such as the oslibrary in our case and ii the package s developer set up an ad hoc approach interfering with it can easily break the build process.
in contrast using pyproject.toml should address many of the problems caused by dynamic metadata.
however some build backends e.g.
poetry allow developers to call pre build scripts declaring them inside of the specification file.
these scripts may cause unreproducible builds and cannot be easily patched at the tooling level.
we found that .
of the builds for pypi in our results are affected by these kinds of issues.
rubygems is subject to similar issues.
the cause of unreproducible builds is the run of arbitrary commands launched through the specification file.
for example the package version tag can be programmatically set in the specification file by using ruby time functions e.g.
version .
.
time.now.to i .
the ruby time library does not use the source date epoch variable making time a reproducibility issue.
this event shows how this kind of behavior can be dangerous for reproducibility and how it can hardly be addressed through the build infrastructure.
maven s challenges are different.
section iv b1 discussed that plugins need to support the outputtimestamp property declared in the pom.xml specification file.
older plugin versions and custom plugins may not use it.
this requires a developer to carefully inspect the plugin used in the package build pipeline since depending on the pipeline design a single plugin can impact the build reproducibility .
we found that of the builds for maven are affected by these kinds of issues.
c. rq3 native code extensions as discussed in section ii pypi npm and rubygems allow packages to include native code.
this subsection studies how the inclusion of native code impacts the reproducibility of package builds rq2 .
considering the original dataset where packages are not distinguished based on native code extensions the incidence of native code extensions is .
for pypi .
for rubygems and just .
for npm.
due to the low relative infrequency of native code in these package ecosystems as discussed in section iii b we created an additional dataset that exclusively contain packages with native code.
our comparison uses infrastructure configuration section iv b1 and our packaging tool patches section iv b2 to isolate the impact of native code extensions.
pypi npm rubygemsw nces w o nces w nces w o nces w nces w o nces0 builds reproducible non reproduciblefig.
.
reproducible package builds that take into account extensions for native code extensions nces .
in order to concentrate on reproducibility issues caused by native code extensions these findings are obtained using patched package managers.
overall we find that although native code extensions are a more or less common feature in interpreted languages reproducible builds appear to be unaffected by them.
quantitative results comparing the reproducibility of package builds of the dataset without native code extensions to the dataset with native code extensions in figure we find that the difference between the two datasets negligible pypi has .
reproducible builds with native code and .
without npm has with native code and without and rubygems has .
with native code and .
without.
unreproducible builds are caused by the same reproducibility issues discussed in section iv b3.
in the end npm pypi and rubygems show the same reproducibility issues independent of the presence of native code extensions.
using patched package managers solves those issues as we saw in the previous section.
we hence conclude that native code extensions do not impact the build s reproducibility.
causes of unreproducibility since c code has multiple reproducibility issues that can affect the build process we originally expected native code extensions to affect the reproducibility of the package build.
since we do not have any specific pointer to the causes of reproducibility in the analyzed ecosystems we systematically searched for common reproducibility issues in the c code in packages randomly picked in the sample e.g.
time dependent macros.
we did not find any occurrence of such issues from this search.
note that our analysis used the same build configuration and tools.
if no assumptions are made regarding system configurations such as compiler specs there will be fewer reproducible builds.
build specification files e.g.
.buildinfo files are not incorporated into the build processes of any of these three ecosystems.
in pypi the meson backend is largely adopted to compile native code extensions.
meson states to achieve reproducible builds8by addressing multiple issues e.g.
rpaths.
in npm the gyp module is similarly utilized for managing native code.
this additional layer in compilation can be the reason behind the high number of reproducible builds.
however it does buildsecosystem reproducible as is reproducible w infr.
conf.
non reproducible ext.
causesfig.
.
reproducible builds obtained by compilation.
we used unpatched package managers since the compilation process requires different configurations w.r.t.
packaging.
not justify the almost complete reproducibility of builds.
in rubygems the system default compiler is directly invoked to compile extensions.
even without additional layer there is a high number of reproducible builds.
it is difficult to completely understand the reasons why native code extensions in builds rarely affect reproducibility.
however it is possible to connect it to two main factors.
first native code extensions usually deal with specific tasks with a limited amount of code reducing the chances of an reproducibility issue.
second native code extensions require more expertise to be set up and properly work than regular code.
developers with higher skills in programming are possibly more aware of and invested in reproducible builds .
takeaway reproducible builds are not affected by the presence of native code extensions in the package.
this means that reproducible builds could be easily achieved by solving issues related to the system configurations such as the compiler specs.
d. rq4 reproducible builds and compilation some packaging ecosystems allow for packaging dependencies together with the developed code in a binary the dependencies are inserted into the build artifact during the build process.
we limited this analysis to cargo go and maven as they are the only ecosystems implementing compilation in their official package managers.
quantitative results we find as shown in figure that cargo go and maven builds are still reproducible after the dependencies have been inserted into a reproducible application.
that is compiling dependencies into the binary in the build process does not introduce reproducibility issues.
cargo go and maven builds are almost completely reproducible with and .
respectively.
for maven the results were obtained using the package manager with the outputtimestamp property configured.
causes of unreproducibility for cargo and go we randomly sampled packages to understand which are the causes of unreproducible builds and searched for common reproducibility issues in those packages code.
for maven we checked whether packages with unreproducible builds werealso unreproducible against packaging to understand if any specific reproducibility issue is caused by the compilation process.
all three ecosystems have initiatives working towards reproducible builds that can explain the high rates of reproducibility we find.
cargo developers explicitly label reproducibility issues in their github repository9and have addressed several issues in the past such as stripping absolute paths a well known issue for compilation.
this deliberate effort towards reproducibility made rustc the rust compiler used by cargo almost deterministic apart from system specifications such as the linker and compiler versions.
also go takes care to remove potential causes of reproducibility issues during compilation for example by trimming absolute paths and by removing build identifiers.
the many issues and community discussions on reproducible builds within go highlight the interest of this community.10moreover in order to facilitate reproducible builds across different systems go strives to establish reproducible builds for the toolchain .
javac the java compiler used in maven is known to be deterministic .
our results confirm this.
the reproducibility issues in maven packages are caused by archive metadata since the compiled java classes are inserted into a jar archive as happens for packaging.
maven builds are affected by the same reproducibility issues discussed in section iv b1 affecting archive metadata and not the compiled artifacts.
as for packaging configuring the build infrastructure addresses most of the unreproducible builds.
the remaining unreproducible builds are caused by the same reproducibility issues discussed in section iv b3.
takeaway build reproducibility is unaffected by compilation.
build infrastructures do not introduce reproducibility issues thanks to the community efforts working on them.
v. d iscussion and recommendations reproducible builds are a notoriously hard problem.
few developers pay active attention to reproducible builds and those that do usually face a laborious tedious and incremental process .
with software being usually constructed using many reusable components ensuring reproducible builds for components is an important building block for the community to move toward reproducible builds for applications and infrastructure.
our results can be interpreted in two ways on the negative side given that components in many ecosystems are distributed as archives of source code often with little build time processing it is shocking frustrating how few components are packaged in a repro9 builds ducible way.
almost no rubygems pypi and maven packages are reproducible.
on the positive side most reproducibility issues are rooted in the packaging tools of the ecosystem and can be addressed with small changes to the default settings of those tools.
in contrast to usual discussions of reproducible builds for applications only very few components in our study had reproducibility issues that cannot easily be addressed even for components with native code extensions.
this signals that reproducible builds for components are within easy reach.
recommendations to practitioners.
after patching packaging tools the remaining unreproducible builds in our study were caused by ad hoc solutions applied by developers.
we recommend that developers avoid extending specification files with custom scripts even if the ecosystem permits such behavior.
relying on custom configurations can easily compromise reproducibility as we have seen section iv b3 .
recommendations to maintainers of packaging tools.
we make three recommendations secure defaults build information and warning when unreproducible.
first in line with past work on usable security we emphasize the importance of secure defaults in this case defaults that eliminate common reproducibility issues.
reaching every single developer is inefficient and hopeless but with simple changes to the packaging infrastructures most components will be packaged reproducibly without any manual effort from developers.
second packaging tools should automatically record information that enables build reproducibility.
this includes the used compiler and version the exact versions of build dependencies and build options.
third packaging tools should issue warnings if packaging steps rely on undeclared infrastructure e.g.
javascript transpilers installed on the local computer but not declared as a dependency and nondeterminism in builds e.g.
by explicitly running reprotestlike experiments during the build .
recommendations to researchers.
most of the findings of this paper enable further research.
our aim was to provide a comprehensive study of reproducible builds in different ecosystems.
while easily achievable reproducible builds can be compromised by additional issues that require more examination.
further research may also consider developing methods that recreate build information for published packages as a stop gap solution until package maintainers include this information by default.
recently aroma proposed such an approach for java packages in maven.
vi.
c onclusion overall our study results make us optimistic about the future of reproducible builds.
for software components reproducible builds are much closer than we expected and a few small changes to infrastructure tools have a large lever to get the community to a future where most packages are fully reproducible.
barriers to ensuring that nearly all published components are exactly reproducible from the public source codeare minimal.
we can focus our attention more on other lastmile issues such as linking published components on package managers to specific commits of their publicly available source code ensuring the provenance of code changes to the public source code and ensuring that packages are consumed in a reproducible manner when building applications e.g.
locking floating dependencies .