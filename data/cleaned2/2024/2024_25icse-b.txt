no harness no problem oracle guided harnessing for auto generating c api fuzzing harnesses gabriel sherman university of utahstefan nagy university of utah abstract library apis are used by virtually every modern application and system making them among today s most securitycritical software.
in recent years library bug finding efforts have overwhelmingly adopted the powerful testing strategy of coverage guided fuzzing.
at its core api fuzzing operates on harnesses wrapper programs that initialize an api before feeding random inputs to its functions.
successful fuzzing demands correct and thorough harnesses making manual harnessing challenging without sufficient domain expertise.
to overcome this recent strategies propose learning libraries intended usage to automatically generate their fuzzing harnesses.
yet despite their high code coverage resulting harnesses frequently miss key api semantics bringing with them invalid unrealistic or otherwiseimpossible data and call sequences derailing fuzzing with falsepositive crashes.
thus without a precise semantically correct harnessing many critical apis will remain beyond fuzzing s reach leaving their hidden vulnerabilities ripe for attackers.
this paper introduces oracle guided harnessing a technique for fully automatic semantics aware api fuzzing harness synthesis.
at a high level oracle guided harnessing mimics the trial and error process of manual harness creation yet automates it via fuzzing.
specifically we leverage information from api headers to mutationally stitch together candidate harnesses and evaluate their validity via a set of correctness oracles compilation execution and changes in coverage.
by keeping and further mutating only correct candidates our approach produces a diverse set of semantically correct harnesses for complex real world libraries in as little as one hour.
we integrate oracle guided harnessing as a prototype ogh arn and evaluate it alongside today s leading fullyautomatic harnessing approach hopper and a plethora of developer written harnesses from oss fuzz.
across realworld apis ogh arn outperforms developer written harnesses by a median code coverage while uncovering and more vulnerabilities than both hopper and developer written harnesses respectively with zero false positive crashes.
of the 41new vulnerabilities found by ogh arn all are confirmed by developers of which are since fixed with many found in apis that until now lacked harnesses whatsoever.
i. i ntroduction coverage guided fuzzing remains one of today s most successful approaches for software vulnerability discovery.
much of real world fuzzing targets library apis as they form the fundamental building blocks of today s critical applications and systems.
today thousands of apis are fuzzed continuously via google s oss fuzz the largest api fuzzing effort ever undertaken.
in recent years academic and industrial enhancements continue to improve api fuzzing speed practicality and effectiveness .
fuzzing apis requires harnesses or drivers wrapper applications that instantiate the library and its objects beforefeeding fuzzer generated inputs to its targeted function s .
yet writing harnesses is no easy task.
subtle mistakes in library initialization data and arguments and call sequences often derail fuzzing with hundreds of false positive crashes.
preventing such errors demands intimate knowledge of a library s semantics often possessed by its developers alone making manual harnessing unscalable for generalpurpose library fuzzing.
to this end recent automated fuzzing harness generators are extending fuzzing s reach across the broader api ecosystem .
at a high level automated harness generators aim to learn a library s semantics to ensure their resulting harnesses are correct.
previous generation harnessers infer api semantics by statically analyzing available reference code unit tests applications and even other harnesses .
however reference based harnessing falls short when reference code is absent low quality or minimal in its use of api functionality.
to remedy this chen et al.
propose hopper a strategy for dynamic harness generation.
rather than rely on reference code hopper performs on the fly harnessing by mutating api function calls and data.
yet despite hopper s ability to harness many api functions its harnesses frequently violate key library semantics valid argument ranges call ordering and data initialization creating numerous false positive bugs solely from apis misuse .
thus without a correct semanticsaware harnessing strategy critical api vulnerabilities will remain undiscovered by today s state of the art fuzzers leaving dangerous opportunities for attacker exploitation.
to overcome this challenge we propose oracle guided harnessing an automated strategy for generating semanticallyvalid library fuzzing harnesses entirely from scratch.
at its core oracle guided harnessing operates like a fuzzer iteratively mutating harnesses while filtering out semanticallyinvalid ones via a suite of correctness oracles harness compilation execution and code coverage.
unlike prior harnessers that require extensive reference code oracleguided harnessing needs only a library s headers to begin synthesizing valid harnesses and unlike current on the fly harnessing it upholds critical api semantics whose violations derail fuzzing with false positive crashes.
when paired with a fuzzer oracle guided harnessing enables greater coverage and bug discovery while extending fuzzing s reach to many more libraries than previously possible.
we implement oracle guided harnessing as a prototype ogh arn and evaluate it on real world libraries alongside today s state of the art harnesser hopper and33 developer written oss fuzz harnesses.
across five hour fuzzing campaigns per benchmark ogh arn outperforms manually written harnesses by a median code coverage while uncovering 31and30more security bugs than both respectively.
we further show oracle guided harnessing is unsurpassed in correctness compared to hopper s falsepositive rate of allof ogh arn s41newlyfound bugs are semantically valid per their apis intended usage.
moreover our approach makes effective fuzzing possible where prior approaches fall short with bugs found in four libraries that until now lacked any fuzzing harnesses.
through the following contributions we enable correct and thorough generation of library fuzzing harnesses allowing state of the art bug finding to be more broadly deployed across today s countless security critical software apis we introduce oracle guided harnessing a technique for fully automatic semantically correct synthesis of library fuzzing harnesses.
with only the minimal information found in library headers oracle guided harnessing leverages fuzzing style mutation to construct and refine candidate harnesses ensuring they uphold apis intended function arguments data dependencies and call sequences.
we implement oracle guided harnessing as a prototype implementation ogh arn and evaluate it on diverse real world libraries alongside the leading automated harness generation approach hopper as well as a suite of developer written oss fuzz fuzzing harnesses.
we show oracle guided harnessing upholds correctness across our real world library benchmarks ogh arn s generated harnesses achieve a false positive rate compared to hopper s false positive bug rate.
we demonstrate oracle guided harnessing s effectiveness across five hour fuzzing campaigns ogh arn generated harnesses outperform developer written harnesses by a median code coverage.
moreover while hopper and developers harnesses both find 10and 11new security vulnerabilities respectively ogh arn reveals with of these since fixed by their respective api maintainers.
to enable future research in library harnessing we release our prototype implementation ogh arn and all of our evaluation benchmarks and artifacts at the following url ii.
b ackground related work and motivation this section provides an overview of the topics fundamental tooracle guided harnessing library apis coverage guided fuzzing and automated harness generation.
a. software library apis application programming interfaces apis make up the fundamental building blocks of today s applications and systems.1often maintained as special purpose code for distinct computing tasks e.g.
decoding a specific file format software libraries rank among the largest shares of the modern 1we hereafter refer to libraries andapis interchangeably.software ecosystem with an estimated of developers using third party apis in their own code .
today hundreds of thousands of libraries exist for a multitude of domains like multimedia document processing scientific computing and handling niche data formats .
parser.h obj parse ... void init int size ... source files headers api users applications unit tests parser.cimage.c external functions int size object obj parse filename internal functions char parsebody file fig.
high level visualization of a typical software library s components.
figure offers a high level overview of a typical c based api s core components.
to use the api developers must first import its header files which contain declarations namely argument and return types of the library s interface functions the entrypoints to invoking the library on userprovided data.
these interfaces are themselves abstractions of the library s internal subroutines like file i o data processing and memory allocation.
though liu et al.
show the feasibility of fuzzing libraries internal functions this broadly remains outside the scope of current large scale library fuzzing initiatives which concentrate on libraries interfaces.
b. fuzzing library apis via harnesses with their ever increasing prevalence software libraries remain a high value target for attackers.
modern os kernels web browsers and other security critical software are a veritable spaghetti of api dependencies creating significant risk for trickle down vulnerabilities stemming from insecure thirdparty code .
moreover high profile attempts to backdoor commodity apis further underscores their risk to today s software ecosystem .
to this end library developers and maintainers have overwhelmingly turned to a proactive vulnerability finding strategy known as fuzzing .
l00 int harness const uint8 t buf size t size l01 initgeos geos msg handler geos msg handler l02 l03 geosgeometry g1 geosgeomfromwkt buf l04 l05 if g1 !
null l06 geosgeometry g2 geosgeomfromwkb buf buf size l07 if g2 !
null l08 geosgeometry g3 geosintersection g1 g2 l09 geosgeom destroy g3 l10 geosgeom destroy g2 l11 l12 char r geosgeomtowkt g1 l13 free r l14 geosgeom destroy g1 l15 l16 return l17 object cleanup after final use.
checks on api returned data.
library initialization routine.
error handler initialization.
fig.
a visualization of an expert written library fuzzing harness right and its corresponding api usage governing library semantics left .
having found thousands of defects across the software ecosystem fuzzing remains by far today s most successful testing approach for bug and vulnerability discovery.
modern fuzzers e.g.
afl test software by feeding it massive amounts of random inputs and measuring the code coverage e.g.
basic blocks executed of each.
by saving and mutating only inputs that reveal newcoverage fuzzers gradually explore more and more of the software under test thereby revealing bugs and vulnerabilities hidden throughout its components.
fuzzing libraries requires harnesses wrapper programs that feed fuzzer provided data to apis functions.
figure shows an example harness for libgeos .
akin to thirdparty api using applications harnesses form the backbone of library fuzzing.
google s oss fuzz the largest api fuzzing initiative continuously fuzzes harnesses for over apis.
popular library fuzzers include afl honggfuzz and the now retired libfuzzer .
yet writing harnesses by hand is no easy task .
correctly calling an api s functions demands intimate knowledge of its semantics the developer created rules governing its intended usage e.g.
figure .
for example many apis expose initialization routines e.g.
initgeos in figure which if skipped cause subsequent operations to crash from accessing uninitialized memory.
while such crashes are possible they are seldom realistic triggered solely by api misuse leaving them overwhelmingly unlikely in real world software that uses the same library.
for this reason semantically invalid crashes are virtually always dismissed by developers as falsepositive bugs e.g.
.
moreover many types of api misuse missing handlers unchecked data premature cleanup and invalid arguments lead many inputs to immediately fail or error out leaving fuzzers unable to cover more than a small fraction of the target library.
thus manual harnessing remains unscalable as often only a library s maintainers are best equipped to write correct thorough harnesses.
c. automated library harnessing to fuzz libraries in the absence of expert harnesses many techniques have emerged for synthesizing harnesses automatically .
shown in table i these broadly fall under two high level categories static analysis based harnessing and dynamic on the fly harness generation.
we weigh their trade offs below.
nameharnessing approachreference agnosticspecification agnostic fudge static check fuzzgen static check utopia static check rubick static check graphfuzz dynamic check hopper dynamic check check table i current automated api harnessers by style static or dynamic and reliance on pre written reference code and or human defined specifications.
static harnessers most harnessers today leverage static analysis extracting api semantics from various sources of reference code before transforming them into concrete harnesses.
fudge analyzes third party api usage among different libraries fuzzgen and rubick instead focus on api using applications bundled with libraries e.g.
thegeosop program provided by libgeos and utopia searches for api usage in libraries unit tests.
yet while static harnessing works well for some libraries it isseldom usable in large scale harnessing.
for many apis available reference code only covers a minimal set of functions limiting the overall coverage of any derived harnesses.
worse yet such approaches cannot be used on libraries that lack reference applications or unit tests.
moreover these techniques are not immune to typical static analysis roadblocks e.g.
indirect branches and as recent work shows they thus cannot harness the vast majority of apis in practice .
to this end recent work instead proposes on the fly harnessing by leveraging dynamic program analysis.
dynamic harnessers unlike static reference code based harnessing dynamic harnessers instead leverage api runtime feedback.
at a high level they mutationally stitchtogether candidate api calls and data flow saving only those deemed valid following their execution.
graphfuzz performs harnessing during fuzzing using fuzzers existing code coverage feedback to guide its mutation.
yet while graphfuzz eliminates need for reference code it requires predefined library schema specifications for virtually all api semantics e.g.
types argument ranges .
unfortunately as graphfuzz cannot synthesize these schemas itself forcing users to instead write them by hand it suffers the same burden of human expertise as manual harnessing.
d. motivation challenges of reference and specificationfree dynamic harness generation to overcome graphfuzz s limitations chen et al.
introduce hopper a reference andspecification agnostic dynamic harnesser.
hopper also harnesses functions during fuzzing adding additional heuristics to infer semantics like argument constraints call sequences and other usage rules typically found in user defined specifications.
yet while hopper extends fuzzing s reach far beyond specification restricted graphfuzz itmisses many critical api semantics resulting in a selfreported false positive crash rate upwards of .
to understand hopper s limitations in dynamic harnessing we examine its performance on libgeos a popular and large computational geometry library.
our analysis of hoppergenerated harnesses reveals three high level shortcomings spanning libraries initialization data and arguments and call sequences .
we discuss these in detail below.
1void handler const char fmt ... exit exit failure 4int main contexthandle hs c geos init r context seterrorhandler r c handler orientpolygons r c ... crash!
fig.
crash due to hopper s failure to initialize error handler l1 l3 l6 .
errors in initialization besides calling explicit library setup routines e.g.
initgeos valid library initialization must also uphold expected error handling semantics.
for example in libgeos many errors both logical and memory corruptions are correctly caught by its underthe hood error checking and intentionally exposed to userdefinable handler functions to facilitate graceful exiting.yet as figure shows many hopper found crashes are only triggered due to it missing defining l1 l3 and initializing l6 handler functions.
upon incorporating the expected error handling we see these crashes disappear.
thus preventing false positive crashes demands a harnessing approach that upholds libraries required initialization semantics .
1contexthandle hs c geos init r 2geom t x geom createemptypoint r c 3geom t y geom createcollection r c x 4if y null return 5normalize r c x crash!
fig.
crash due to hopper s omission of the non null check on l4.
errors in data and arguments libraries often require that returned objects validity be checked before continuing execution.
for example libgeos states that thecreatecollection function family returns a newlyallocated geometry and on exception null .
correctly exiting onnull is thus key to preventing crashes from future accesses of now corrupted objects.
yet as figure shows hopper misses such checks l4 leading to false positive crashes that are otherwise avoidable by upholding the api s intended data checking semantics.
avoiding data and argumentrelated false positives thus requires that expected validity checks be included for all api returned objects.
1contexthandle hs c geos init r 2wkbreader t r wkbreader create r c 3wkbreader destroy r 4wkbreader destroy r c r crash!
fig.
crash from hopper s erroneous deallocation of deallocated data l4 .
errors in call sequences beyond initialization and data checking successful harnessing must also preserve libraries intended call sequences .
often inter function dependencies are seldom explicit outside of apis documentation making inferring them without reference code or specifications a compelling challenge.
for example figure highlights hopper s inability to recognize a key restriction of libgeos s cleanup routines namely that already deallocated objects cannot be targeted by other cleanup functions triggering false positive double free crashes on its second cleanup call l4 .
we further observe similar use after frees caused by premature cleanup of objects passed as arguments to other functions.
thus evading these and other false positives demands that api harnessing pinpoint and uphold critical inter function semantics .
impetus effective library fuzzing requires harnesses that uphold apis key semantics initialization valid data and function arguments and intended call sequences.
unfortunately current harnessers struggle scaling to today s large and complex libraries static analysis based approaches cannot recover api semantics without detailed reference code like unit tests or full fledged applications while dynamic ones similarly rely on expert written reference specifications or worse are derailed by false positive crashes in their absence .
without correct semantics aware automated harnessing software apis will remain indefinitely difficult to fuzz leaving a countless number of their vulnerabilities ripe for exploitation .iii.
o racle guided automated harnessing though hopper s reference and specification agnostic harnessing extends fuzzing s reach far beyond prior restrictive strategies its frequent api misuse spanning library initialization data and call ordering leaves it facing over a false positive crash rate .
correct and thorough api fuzzing thus demands a harnessing approach that upholds api semantics without relying on seldom available reference code or painstakingly written specifications.
this section introduces oracle guided harnessing our approach for automatically generating semantics preserving fuzzing harnesses for library apis.
at its core oracle guided harnessing combines the trial and error process by which harnesses are written by hand with fuzzing.
beginning with only the minimal information exposed in library headers harness candidates are mutationally stitched together and evaluated via a set of correctness oracles compilation execution and coverage.
by closely monitoring these side effects oracleguided harnessing s trial and error mutation culls invalid semantics breaking mutations converging on a final corpora of valid harnesses in as little as one hour for many real world libraries.
in the following sections we detail oracle guided harnessing s three fundamental phases figure preprocessing synthesis and post processing .
a. phase library header pre processing to extend harnessing to as many apis as possible oracleguided harnessing aims to be reference and specification agnostic table i .
key to this is its pre processing phase which parses library headers to pinpoint functions types and other api relevant objects.
we discuss these steps below.
header file parsing by consuming only library headers oracle guided harnessing evades the need for error prone static code analysis or cumbersome human written specifications.
using off the shelf c parsing apis we analyze all available headers to recover key fields such as the types names and values of header defined macros enums typedefs functions and function pointers table ii .
category fields representative example macros name define type bits enumstype valuesenum geomtypes geos point geos linestring typedefstype aliastypedef geometry geom functionsrettype name argtypes keywordsint coordseq getsize const coordseq s unsigned int size function pointersrettype alias argtypes keywordstypedef void messagehandler const char fmt ... table ii relevant artifacts recovered from api headers.
function classification with recovered functions in hand we perform a heuristic classification spanning four key types initializers.
as many apis require initialization routines we flag functions whose names contain substring init as likely library initializers .
for example as table iii shows func defs macrostypedefsapi datap2 oracle guided synthesis p1 pre processing parseimgfunction classi ficationp3 post processing successful harnesses minimized corpus initiate fuzzing call sequence mutation int main ... char path argv initializeapi img i makeimg parseimg ?
?
?
?
rotateimg i initializer entrypointauxiliarypotential functions compilation coverage executionargument mutation existing objects random objects processorparseimg path i correctness oraclesmakeimg char img initializer entrypointauxiliary processorharness corpus.hheader parsing enumscandidate call sequences fig.
oracle guided harnessing s key steps pre processing synthesis and post processing.
our heuristic catches libgeos initializers initgeos and geos init r .
while apis may use differently named initializers e.g.
setup our heuristic is easily extended to support them however our survey of oss fuzz s c apis vi shows the vast majority of those requiring initializers .
maintain init naming patterns.
function type representative examples initializersvoid init geos ... contexthandle t geos init r ... data entrypointsgeometry wktreader read wktreader reader const char wkt geometry geojsonreader read geojsonreader reader const char geojson data processorsgeometry intersection const geometry g1 const geometry g2 geometry singlesidedbuffer const geometry g double width int qsegs int jstyle double mlim int lside auxiliarywktreader wktreader create void geojsonreader geojsonreader create void table iii example pre processing function classification.
data entrypoints.
following initializers we scan for possible data entrypoints functions that transform fuzzerpopulated buffers e.g.
filepaths or streamed data the common case data source among .
of today s ossfuzz c libraries vi into the final api specific objects used by the library.
table iii shows two such entrypoints wktreader read andgeojsonreader read which consume buffers wkt andgeojson respectively and return pointers to new libgeos geometry objects.
at a high level different entrypoints represent the unique ways an api accepts user provided data laying the foundation forhow andwhere harnesses must inject fuzzers inputs.
data processors.
while minimal harnesses only target data entrypoints e.g.
hdf5 s thorough fuzzing requires extended harnesses probing an api s other data consumers e.g.
libical s .
thus after entrypoint identification we further scan for data processors functions that perform operations on the api specific objects returned by entrypoints.
for example in table iii intersection andsinglesidedbuffer are marked as processors due to their consuming of entrypoint populated geometry objects.
by including data processors our harnessing discoversa wider range of input dependent behavior and hard tofind vulnerabilities than entrypoint only harnessing alone.
auxiliary functions.
often api functions expect specific arguments i o contexts error message handlers or to be populated data containers that must be initialized via special routines provided by the library which we refer to as auxiliary functions.
unlike entrypoints and processors we enforce that auxiliary functions consume noapi specific objects or buffered data in other words their sole purpose is to resolve other functions arguments rather than be fuzzed themselves.
for example in table iii auxiliary functions wktreader create andgeojsonreader create instantiate the wktreader andgeojsonreader handles required by aforementioned entrypoints wktreader read and geojsonreader read respectively.
our library function classification aims to uphold the highlevel structure of real world fuzzing harnesses library invocation data injection and data transformation.
by explicitly modeling these key semantics via initializer entrypoint processor and auxiliary functions oracle guided harnessing avoids common harnessing pitfalls that plague prior harnessers with crash triggering api misuse ii d .
b. phase oracle guided synthesis following header and function analysis oracle guided harnessing is ready to begin synthesizing functional harnesses.
critical to successful harnessing is pruning invalid harnesses that if fuzzed will trigger false positive crashes ii d .
to validate harness mutations we leverage a set of three correctness oracles compilation execution and code coverage and like a typical fuzzer we save and further mutate only those deemed valid by our oracles.
in the following we discuss our key harness call sequence andargument mutators and how correctness oracles facilitate oracleguided harnessing s synthesis of thorough valid harnesses.
mutating call sequences with function classification from pre processing iii a our harness mutation begins constructing harnesses from scratch beginning with initializers then entrypoints and lastly data processors.
our call sequence manipulation employs the following mutators initializer insertion.
should any initialization routines be identified in the library we insert at most one initializer function at the beginning of the harness.
selecting a data entrypoint.
we select a preliminary entrypoint by identifying functions consuming string like arguments i.e.
buffers character pointers .
should none be found we relax this constraint and further consider functions that take in void pointers as they are commonly used in real world harnessed libraries.
fuzzer to harness input loading.
after entrypoint selection we incorporate necessary handling for how data should be loaded into derived harnesses.
for filepath consuming entrypoints we adjust its relevant argument to argv where the path to fuzzer generated inputs will be swappedin at runtime.
for stream consuming entrypoints we inject standard file i o code e.g.
fread to populate its argument buffer from fuzzer emitted files and if applicable we resolve the corresponding size argument.
in our prototype ogh arn iv we relegate it to the user to select their desired input loading approach per library.
calling data processors.
following data entrypoints we begin inserting processor functions that consume entrypoint returned data objects e.g.
the geometry pointers in table iii .
after a processor function is added we restart mutation to attempt integrating additional processors toward fuzzing even more library functionality.
while users may configure oracle guided harnessing to generate increasingly large harnesses we observe that processor functions per harness offers a balanced trade off between generation time and coverage depth.
final status check insertion.
specifications often proscribe status checks on api returned data for example that a return code is non negative e.g.
for geosnormalize or a returned pointer is non null e.g.
figure .
as omitting such logic frequently causes spurious false positive crashes ii d we add the following status checks to validate all api returned data for booleans that they aretrue for pointers that they are non null and for numerical values that they exceed the library s common error indicating value e.g.
.
should any checks fail we gracefully exit the harness ensuring that only correct data proceeds through to later api calls within the harness.
mutating arguments following every candidate function call insertion oracle guided harnessing initiates argument mutation aimed at resolving harnesses data dependencies.
we perform data resolution by leveraging all collected api artifacts alongside the following argument level mutators function pointers.
for resolving function pointers like error handlers e.g.
context seterrorhandler in figure we introduce dummy stubs that merely exit once called e.g.
the handler function in figure .
data objects.
we attempt injecting existing api returned objects e.g.
geometry from table iii newly initialized ones e.g.
from an auxiliary function or newly declared struct ornull .
should nocompatible auxiliary functions exist we re perform call sequence mutation to search forpossible processors that return the expected type.
string like objects.
our mutation iterates through plausible filenames for reading writing e.g.
tmp abc123 plausible i o permissions e.g.
r w or if the argument is a plausible data destination e.g.
a buffer that is non const a newly initialized object of the same type.
numerical values.
we insert known magic numbers e.g.
macro or enum defined values e.g.
type bits andgeos point from table ii or sizeof for buffer adjacent integer arguments.
validating mutations via correctness oracles manual harness development is seldom a one shot task.
often successful harnessing requires iterative refinement through trial anderror testing .
typically semantically incorrect harnesses manifest themselves by being un compilable or when fuzzed soon crashing or reaching premature coverage plateaus .
while some prior approaches validate their full fledged harnesses post generation we see these three critical signals compilation execution and coverage as an opportunity to automatically validate every incremental mutation during the harness synthesis process .
to validate mutation correctness we introduce the concept ofcorrectness oracles figure .
given a small pre selected set of seed inputs for the target library on par with those used in conventional fuzzing campaigns i.e.
spanning both correct andmalformed files we evaluate the validity of each call sequence and argument mutation by performing the following three oracle guided validity tests compilation.
we attempt to compile every candidate harness mutation and subsequently discard those that fail from compiler reported errors.
for many libraries compilation failures catch the overwhelming majority of incorrect harness mutations containing semantic errors like undefined behavior type errors or language level misuse.
execution.
should compilation succeed we attempt executing each candidate on the pre selected corpus of correct and malformed library inputs.
to ensure subtle ordinarilynon crashing api misuses are caught we further leverage off the shelf sanitizers e.g.
addresssanitizer undefinedbehaviorsanitizer .
should any input crash we discard it as a probable semantically invalid harness.
for correct inputs that should otherwise pass through harnesses error free we further enforce that stderr remain clear as libraries built in error handling often detects and reports api misuse e.g.
figure .
as with manual harnessing crashing on a limited set of test cases likely indicates api misuse enabling oracle guided harnessing to quickly filter out many broken harness mutations.
code coverage.
lastly we profile candidates runtime code coverage to detect likely plateaus stemming from non crashing api misuse.
our analysis compares coverage on correct vs malformed inputs and correct vscorrect ones.
intuitively apis perform many validity checks to throw out inputs that are malformed and leveraging this we enforce that correct inputs yield higher overall coverage of the library than malformed ones.
moreover coverage dis crepancies between multiple well formed inputs typically indicate interesting input dependent behavior and thus we further mandate that coverage changes between at least one correct input relative to its peers.
as time goes on and more candidates are culled oracle guided harnessing gradually converges on valid high coverage harnesses.
learning call and data dependencies when mutations are discarded for failing one or more oracles oracle guided harnessing revisits mutation to find better call and or argument candidates.
by keeping only those mutations that pass all correctness oracles our approach eventually learns critical api semantics related to initialization data and arguments and call sequences ii d resulting in zero false positives across our evaluation experiments v .
though oracle guided harnessing needs some manual effort to find the initial correct and malformed seed inputs for the target api we observe this is usually trivial as most libraries make such samples publicly available in their code repositories.
nonetheless oracle guided harnessing succeeds even with few seeds across our evaluation experiments our per api seed corpora range between just files in size .
c. phase final post processing and fuzzing with synthesis complete oracle guided harnessing s final harness corpora is minimized to reduce fuzzing resource burden.
we mimic the minimization process of most fuzzers collecting the corpus global coverage and keeping the fewest samples necessary to cover its entirety.
specifically we use conventional coverage tracing tools to replay all generated harnesses on the same per library seed files used in correctness oracle validation.
we then calculate each harness s unique coverage and discard those whose coverage are strict subsets of others .
following minimization the final reduced corpus of harnesses is ready for fuzzing.
iv.
i mplementation ogh arn we integrate oracle guided harnessing as a prototype ogh arn spanning .27k lines of python modules for parsing mutation and validation.
we detail these below.
parsing implementation we parse library headers using the python cxxheaderparser library returning a finaljson dump containing all relevant functions objects and other artifacts e.g.
table ii .
we further implement various python classes to map these individual artifacts to their respective functions arguments and call sequences that are mutated throughout harness synthesis.
mutation implementation our harnessing operates on an internal graph based intermediate representation ir facilitating easy integration of new function or argument mutators.
at present we cap mutations per each harnessed api function to though this is adjustable if desired.
validation implementation following mutation we perform validation via correctness oracles.
ogh arn uses python library cfile to translate harness ir into c code.
we compile harnesses with the state of the art fuzzer afl s own compiler injecting both sanitizers i.e.
asan and ubsan and coverage tracing instrumentation into the apis and harnesses.
for compilation and execution oracles we monitor harnesses process signals and outputs e.g.
stderr .
for code coverage we trace and process coverage using afl s afl showmap utility.
supported libraries while our prototype targets c based apis we expect future enhancements will extend oracleguided harnessing to c and other languages.
we discuss the technical trade offs of supporting new languages in vi.
v. e valuation our evaluation of oracle guided harnessing is guided by the following high level research questions q1 are oracle guided harnessing s correctness oracles effective at preventing api misuse?
q2 do oracle guided harnessing s generated harnesses cover considerable library functionality?
q3 how does oracle guided harnessing enhance library fuzzing s vulnerability discovery?
a. experiment setup to evaluate oracle guided harnessing s strengths at dynamic harness synthesis we compare our prototype ogh arn to the current state of the art dynamic harnessing tool hopper .
we further compare oracle guided harnessing to the available developer written oss fuzz harnesses per library selecting those targeting the same header files as ogh arn e.g.
geos c.h forlibgeos .
following the standard set by klees et.
al we run all fuzzing campaigns for five trials per competing harnessing approach.
we use the state of the art fuzzer afl as libfuzzer is no longer maintained since and accordingly modify all ogh arn and developer written harnesses to accept afl file based input.
we seed ogh arn s synthesis with publicly sourced files per api and reuse these corpora as seeds for all harness fuzzing campaigns.
we perform all tests and data analysis across three core ubuntu .
workstations each with 64g ram and an intel i912900k cpu.
all means are calculated as geometric means.
benchmark selection to ensure rigorous evaluation of ogh arn we follow the standard of prior work and select popular and actively maintained real world libraries of varying size and type e.g.
mathematical web and multimedia software shown in table iv.
for each library we deploy its available developer written oss fuzz harnesses per the header files considered.
to assess how oracle guided harnessing extends fuzzing s reach to yet unharnessed libraries we incorporate four benchmarks without existing harnesses libfyaml raylib faup andstormlib .
b. q1 semantic correctness as iii b details excessive crashes or premature coverage plateaus are key signs that a harness is semantically invalidlibrary header file s funcs manual oss fuzz harnesses libgeos geos c.h 525fuzz geo2 hdf5 hdf5.h 114extended fuzzer read fuzzer libical ical.h 256fuzzer extended fuzzer openexr imfcrgbafile.h 86exrcheck fuzzer exrcorecheck fuzzer lexbor html.h 331document parse libucl ucl.h 123add string fuzzer msgpack fuzzer cgltf cgltf.h 38fuzz main gpac isomedia dev.h constants.h343fuzz parse c ares ares.h 77parse reply fuzzer create query fuzzer cjson cjson.h 78cjson read fuzzer lcms lcms2.h 290it8 load fuzzer overwrite transform fuzzer transform fuzzer libmagic file.h magic.h93magic fuzzer libpcap pcap.h 79fuzz both fuzz filter fuzz pcap pcre2 pcre2.h 120pcre2 fuzzsupport sqlite sqlite3.h 287oss fuzz zlib zlib.h 81checksum fuzzer compress fuzzer example dict fuzzer example flush fuzzer example large fuzzer example small fuzzer minigzip fuzzer uncompress fuzzer uncompress2 fuzzer libfyaml libfyaml.h none available.
raylib raylib.h none available.
faup decode.h features.h faup.h options.h45 none available.
stormlib stormlib.h none available.
table iv our real world library benchmarks their targeted header files and the total functions they contain and available expert written harnesses.
and misusing its targeted api.
to examine whether oracleguided harnessing is successful generating valid harnesses we perform a smoke test evaluation on up to ogh arngenerated harnesses per library and fuzz them each for 1hour trials.2we flag any harnesses where at least of all inputs crash or where coverage does not increase in either the first or second half of the campaign.
referencing apis documentation we then manually analyze all flagged harnesses to make a final diagnosis as to whether api misuse occurs.
table v lists our observed potential misuses stemming from abnormal crash rates or coverage.
we see 38suspicious instances out of the total harnesses generated across all apis.
our manual assessment of each is as follows libgeos .we observe ogh arn s three code coverage plateaus in harnesses calling functions differenceprec relatepattern andsinglesidedbuffer .
in all three ogh arn uses a single object to fill twomatchingtype arguments which while valid api use limits their runtime coverage.
interestingly ogh arn triggers a crash when supplying large buffers to function relatepatternmatch which expects two de9imcompliant i.e.
nine length buffers as arguments.
however this crash occurs when the firstof these two buffers exceeds nine in size as libgeos ultimately performs a size check only on the second buffer and misses the first.
we thus conclude that ogh arn s harness is not api misuse but 2because ogharn performs coverage based minimization on its final harness corpora iii c some apis attain fewer than harnesses in total.
harnesses with symptoms of api misuselibrary ogh arn harnesses frequent crashes coverage plateaufinal libgeos hdf5 libical openexr lexbor libucl cgltf gpac c ares cjson lcms libmagic libpcap pcre2 sqlite zlib libfyaml raylib faup stormlib ogh arn s confirmed api misuses table v ogh arn s signs of possible api misuse seen in hour fuzzing trials.
we investigate all by hand and confirm all of these harnesses indeed uphold valid api semantics.
we cap ogh arn s synthesis at harnesses per api for smaller apis our synthesis results in fewer overall harnesses.
rather an exposure of a missed yet intended internal data check.
upon reporting this bug was subsequently patched.
hdf5 .as withlibgeos threehdf5 harnesses exhibit coverage plateaus from benign data two when calling h5fis accessible and the third from h5fis hdf5 .
in manually inspecting their source code we see that these functions all serve as basic input checking routines that lack any substantial input dependent logic hence causing plateaus from early coverage saturation.
we also catch one crash on function h5fget name and find it is merely an error handling signal from ogh arn s correctly initialized random string being detected as an invalid file path.
lexbor .in examining one code coverage plateau revealed in lexbor s html parsing function html document css customs id we determine ogh arn s harness as valid from cross referencing identical calls in the api s source.
as with hdf5 we observe few input dependent paths in it and its callees indicating plateaus are likely caused by saturated coverage.
pcre2 .we observe seven pcre2 coverage plateaus due to functions with low input dependent behavior e.g.
pcre2 get match data size and an eighth resulting from ogh arn s injection of parameters which while valid constrain string parsing for example though pcre2 compile parses input strings of any size ogh arn sets a size of one.
ultimately this plateauing harness is appropriately de ranked by ogh arn s coveragebased minimization iii c with ogh arn converging on fullstring sizes in its other higher ranked pcre2 harnesses.
sqlite .we see of sqlite s coverage plateaus stem from functions with low input dependent behavior e.g.
sqlite3 changes64 .
like with pcre2 we see three others caused by arguments that while valid limit coverage for example calling sqlite3 db filename with a filename non existent in the sql database causing premature exit.
lastly one plateau occurs a valid yet unproductive call sequence where ogh arn callssqlite3 db cacheflush right after sqlite3 open as no operations occur in between to modify the database coverage quickly stalls in the latter function.
though sqlite faces the most plateaus none result from true api misuse and as in all other apis ogh arn successfully converges on more interesting arguments and call sequences in its higher ranked harnesses.
thus as these symptoms are ultimately benign and unrelated to api misuse we conclude that oracle guided harnessing does produce valid harnesses.
while api misuse may manifest later in fuzzing our hour campaigns with ogh arn s harnesses v d reveal zero false positive crashes further underscoring oracle guided harnessing s effectiveness.
ogh arn mutations discarded mutations by correctness oraclelibrary success discard compilation execution coverage libgeos .
.
.
hdf5 .
.
.
libical .
.
.
openexr .
.
.
lexbor .
.
.
libucl .
.
.
cgltf .
.
.
gpac .
.
.
c ares .
.
.
cjson .
.
.
lcms .
.
.
libmagic .
.
.
libpcap .
.
.
pcre2 .
.
.
sqlite .
.
.
zlib .
.
.
libfyaml .
.
.
raylib .
.
.
faup .
.
.
stormlib .
.
.
mean proportion of discards .
.
.
table vi statistics on ogh arn s mutations over hours of synthesis.
to understand how oracle guided harnessing s synthesis is influenced by our correctness oracles iii b we instrument ogh arn to log key harnessing statistics shown in table vi.
though we expect execution to catch the majority of invalid harnesses across all target libraries we observe that oracle distribution is largely target dependent for example as table vi shows execution makes up .
of oracle violations for libucl while coverage represents .
for stormlib .
thus given ogh arn s accuracy we conclude that oracleguided harnessing s reliance on multiple oracles is a critical filter for invalid mutations preventing the api misuse that hinders competing dynamic harnessers e.g.
ii d .
q1 oracle guided harnessing s three oracles compilation execution and coverage are key to preventing api misuse with zero false positive crashes found across our entire evaluation.
c. q2 depth in library coverage to understand whether oracle guided harnessing succeeds in harnessing more api functions we enumerate the unique calls contained in ogh arn s valid synthesized harnesses versus those in manually written ones table vii .
overall we see that ogh arn improves function coverage by a median over manually written oss fuzz harnesses .librarytotal functionsmanually harnessedogh arn harnessed libgeos .
hdf5 .
libical .
openexr .
lexbor .
libucl .
cgltf .
gpac .
c ares .
cjson .
lcms .
libmagic .
libpcap .
pcre2 .
sqlite .
zlib .
libfyaml n a raylib n a faup n a stormlib n a ogh arn s median relative total functions harnessed .
table vii total api vs. manually and ogh arn harnessed functions max hr synthesis time .
n a no available manually written harnesses.
yet harnessing more functions does not guarantee higher runtime coverage.
to validate ogh arn s runtime coverage we fuzz ogh arn s harnesses alongside all manual harnesses and state of the art dynamic harnesser hopper and collect all harnesses per api basic block coverage by replaying their fuzzer generated inputs via afl qemu cov .
for hopper we use its provided translator to convert its interpreter harnesses to compilable c harnesses with minor patching to correct syntax errors before tracing the coverage of each.
as fuzzing ogh arn s entire harnesses corpus is computationally overwhelming we limit fuzzing to only its top highestcoverage harnesses per api.
table viii reports ogh arn s mean relative coverage across five trials per benchmark.
following klees et al.
we assess statistical significance via the mann whitney u test at the p .
significance level.
ogh arn s coverage vs. hopper ogh arn s coverage vs. manuallibrarytotal mwupunique mwuptotal mwupunique mwup libgeos .
.
.
.
.
.
.
.
hdf5 .
.
.
.
.
.
.
.
libical .
.
.
.
.
.
.
.
openexr .
.
.
.
.
.
.
.
lexbor .
.
.
.
.
.
.
.
libucl .
.
.
.
.
.
.
.
cgltf .
.
.
.
.
.
.
.
gpac n a n a .
.
.
.
c ares .
.
.
.
.
.
.
.
cjson .
.
.
.
.
.
.
.
lcms .
.
.
.
.
.
.
.
libmagic .
.
.
.
.
.
.
.
libpcap .
.
.
.
.
.
.
.
pcre2 .
.
.
.
.
.
.
.
sqlite .
.
.
.
.
.
.
.
zlib .
.
.
.
.
.
.
.
libfyaml .
.
.
.008n a n a raylib .
.
.
.548n a n a faup .
.
.
.205n a n a stormlib .
.
.
.008n a n a ogh arn s median relative coverage .
.
.
.
table viii ogh arn stotal andunique coverage over hopper and manual harnesses in hr campaigns.
statistically significant changes i.e.
mannwhitney u test p .
are bold .n a api unsupported by that approach.
as table viii shows ogh arn sees median total coverage .
and1.
that of hopper and developers harnesses respectively.
to assess these approaches coverage we further compute and report their total unique basic blocks covered.
overall ogh arn s median unique coverage is .
and .
that of hopper and developer harnesses respectively.we see ogh arn generally attains higher coverage on larger apis with more functions like libgeos andlexbor table vii .
for smaller apis like c ares andzlib with and functions respectively ogh arn sees lower relative increases in functions harnessed .
and .
respectively suggesting these smaller apis oss fuzz harnesses are already robust.
nonetheless ogh arn sees coverage improvements on of oss fuzz apis.
though hopper sees higher coverage on many benchmarks its harnessing limitations leave it with overwhelmingly poor performance on several e.g.
cgltf andlexbor .
in analyzing these cases by hand we find that hopper s internal synthesis cannot properly recover key constraints in both apis leaving it incapable of generating any valid harnesses despite ogh arn having successfully harnessed them .
moreover we observe that hopper is unsuccessful at harnessing gpac causing it to crash immediately from runtime errors.
thus we conclude that oracle guided harnessing trades off some level of coverage for a higher overall harnessing accuracy.
q2 oracle guided harnessing surpasses developer written harnesses in function and runtime coverage extending correct and thorough harnessing to apis where other approaches fall short.
d. q3 vulnerability discovery lastly we assess whether oracle guided harnessing s generated harnesses improve api fuzzing bug finding.
we follow our procedure from v c for each library we run 24hour fuzzing campaigns per hopper its oss fuzz harnesses and the top highest coverage ogh arn harnesses.
after fuzzing we perform an initial deduplication of all fuzzerfound crashes using the casr crash triage framework on asan and ubsan error reports and perform additional manual deduplication and analysis of potential false positives before reporting all bugs to their developers .
manual bugs hopper bugs ogh arn bugslibrarytrue false unique true false unique true false unique libgeos hdf5 libical openexr lexbor libucl cgltf gpac 0n an an a c ares cjson lcms libmagic libpcap pcre2 sqlite zlib libfyaml n an an a raylib n an an a faup n an an a stormlib n an an a total table ix ogh arn s total uncovered true positive bugs false positive bugs and uniquely found true positive bugs vs. hopper and manually written harnesses in hour campaigns.
n a api unsupported by that approach.
table ix shows the true and false positive bugs found by all competitors.
overall ogh arn sees the highest bug discovery with 41new true positive bugs and the most uniquebugs across apis.
comparatively developers harnesses and hopper reveal only and bugs each respectively.
we also observe hopper s false positive rate between within the range reported by its authors suggesting it faces significant challenges in harnessing realworld apis.
in examining hopper s false positives we see many of the same pitfalls as discussed in ii d broken initialization total invalid data or arguments total and improper call sequences total .
developer responses on hopper found crashes highlight clear instances of api misuse for example several cases in stormlib involve operations on a single buffer yet hopper erroneously provides different corresponding buffer sizes to each while others center on hopper s injection of garbage values that violates their apis data initialization semantics.
thus while hopper gains higher coverage on many benchmarks table viii its semanticallyincorrect harnessing frequently breaks down on real world libraries leading to significant false positive crashes in fuzzing.
library error type location manual hopper ogharn status libgeos stack bof coordinate.h check illegal read polygon.cpp check illegal read cgalgorithmsdd.cpp check check thumbs up illegal read centroid.cpp check heap bof lineintersector.h check hdf5 heap bof h5hlcache.c check check large alloc h5mm.c check check heap bof h5mm.c check check stack bof vasprintf.c check check illegal read h5oint.c check heap bof h5fio.c check large alloc h5centry.c check check libical illegal read icalcomponent.c check check illegal read icalcomponent.c check lexbor illegal read element.c check illegal read avl.c check heap bof str.c check libucl illegal read ucl parser.c check illegal write ucl parser.c check check illegal read ucl hash.c check heap bof ucl hash.c check check illegal read ucl util.c check stack bof glob.c check libfyaml illegal read fy list.h check illegal read fy utf8.h check pcre2 heap bof pcre2 compile.c check heap bof pcre2 compile.c check heap bof pcre2 compile.c check raylib illegal read rtextures.c check stormlib heap bof sbasefiletable.cpp check stack bof sbasefiletable.cpp check large alloc sbasefiletable.cpp check heap bof sbasefiletable.cpp check heap bof sbasefiletable.cpp check heap bof sbasefiletable.cpp check heap bof filestream.cpp check divide by filestream.cpp check divide by sbasecommon.cpp check heap bof huff.cpp check heap bof sparse.cpp check heap bof sbasecommon.cpp check ogh arn s total fixed and unfixed yet confirmed vulnerabilities table x ogh arn s newly found vulnerabilities in hour campaigns.
bugs fixed after our disclosure thumbs up bugs confirmed and awaiting fixes.
table x lists ogh arn s newly found vulnerabilities by type source location and reporting status.
so far of these are now fixed with an additional confirmed and awaiting fixes by its developers.
overall oracle guided harnessing s semantically valid thorough harnesses demonstrably enhance fuzzing s reach to find many more vulnerabilities across a wider range of complex software libraries.
q3 oracle guided harnessing s synergy of iterative harness mutation and validation synthesizes correct high coverage library fuzzing harnesses that greatly improve library bug discovery .vi.
t hreats to validity below we weigh several limitations of oracle guided harnessing and our prototype implementation ogh arn.
mitigation of confirmation bias and overfitting to mitigate risk of bias and overfitting we evaluate ogh arn on diverse real world apis spanning varied software domains file formats and complexity.
notably our corpus includes four apis that lack any pre existing developer written harnesses allowing us to test ogh arn s robustness and adaptability in scenarios with zero prior guidance.
to ensure a rigorous comparison with state of the art dynamic harnessing approach hopper we integrate seven libraries from hopper s original benchmark suite c ares cjson lcms libmagic libpcap sqlite andzlib .
this inclusion not only benchmarks ogh arn on well documented baselines but also highlights its performance relative to today s leading autoharnessing approach underscoring ogh arn s low falsepositive rate and improved library bug finding capabilities.
generality of function classification correctly upholding apis semantics necessitates obeying their unique functions distinct purposes.
to this end oracle guided harnessing preprocesses library headers iii a to conservatively classify functions into four semantic types table iii initializers data entrypoints and processors and auxiliary.
our classification is based on common case conventions seen in oss fuzz s 281c libraries of the initializer requiring apis .
follow init naming patterns while of all apis .
support filename or buffer based data entry.
handling less common conventions e.g.
file descriptorbased data entry non init initializers requires minimal extension to our prototype which we leave to future work.
generality of data status checks as iii b details oracle guided harnessing avoids api misuse via aggressive status checks for example enforcing a returned pointer as non null prevents false positive dereference crashes in future functions accessing it.
while pointers booleans and strings are trivial to check for validity api returned numerical values may indicate different status codes.
yet in examining our benchmark libraries total functions we see that negative return values form the most common numerical value for indicating errors i.e.
.
of all .
thus while our current prototype checks only that returned numerical values are non negative we expect that recovering function specific error values is achievable within oracle guided harnessing s iterative harnessing namely by intentionally injecting invalid arguments and monitoring their effects on returned values.
we anticipate such approach will also be effective for other cases of unexpected return semantics such as swapped true andfalse roles in boolean status checks.
interestingly we see that many validity checks are irrelevant because their functions are inconsequential to library state or data for example as geosgeomtypeid consumes only const data later functions on this same data will be unaffected by trickledown errors.
we leave exploring this to future work.
supporting struct based data injection while oracleguided harnessing covers many more functions than expert written harnesses table vii it does not harness of library functions.
unlike hopper which supports direct population of struct members ogh arn strictly populates struct s via available api routines e.g.
ucl parser new and consequently it cannot harness functions that consume struct s with noavailable initializers for example cgltf lacks any routine returning a cgltf node pointer causing functions dependent on them e.g.
cgltf node index to go unharnessed.
similarly libraries requiring struct based entrypoints e.g.
libaom libpng libvpx are unsupported at this time.
we anticipate handling struct objects requires future extensions to ogh arn s data resolution iii b which already supports random initialization of common c data types offering a means to directly populate individual struct members.
supporting server client libraries like hopper ogh arn also does not support most server client libraries as they often rely on complex multi function setup routines.
for example nginx s oss fuzz harness http request fuzzer invokes ten distinct initializer functions.
while server client libraries are less common only .
of oss fuzz s c apis according per our survey we expect supporting them requires substantial re engineering of ogh arn such as enabling handling of multiple initializers as well as determining their correct initializer sequence ordering.
we leave exploring support for server client libraries to future work.
supporting other languages our preliminary c support targets class methods as candidate functions during harness synthesis but needs further engineering to cover more c constructs such as overloaded functions.while we believe other statically typed languages such as java will be easier to accommodate than dynamically typed ones we see an opportunity to use python s type checker as a correctness oracle analogous to our use of compilation success for c harnesses.
though we expect that oracle guided harnessing is amenable to these and other languages we leave the requisite engineering and re evaluation to future work.
vii.
c onclusion oracle guided harnessing extends practical semanticspreserving harnessing to today s many libraries that until now remained outside fuzzing s reach from being unharnessed.
by eliminating need for reference code or user defined specifications without sacrificing accuracy oracle guided harnessing brings greater flexibility in harnessing toward improved api bug discovery.
we demonstrate its potential on real world apis revealing new bugs zero false positives and far higher code coverage than manual harnesses alone.
through lightweight heuristics and iterative trial and error mutation we show that harnessing can be automated with relatively high precision.
we envision a new era in which traditionally manual fuzzing tasks will become fully automated allowing maintainers to shift efforts away from endeavouring to find bugs and toward fixing them.