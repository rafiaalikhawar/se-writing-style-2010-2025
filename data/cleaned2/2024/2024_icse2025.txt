interactive cross language pointer analysis for resolving native code in java programs chenxi zhang yufei liang tian tan chang xu shuangxiang kan yulei sui yue li state key laboratory for novel software technology nanjing university china university of new south wales australia dz1733024 smail.nju.edu.cn tiantan changxu nju.edu.cn shuangxiang.kan y.sui unsw.edu.au yueli nju.edu.cn abstract java offers the java native interface jni which allows programs running in the java virtual machine to invoke and be manipulated by native applications and libraries written in other languages typically c. while jni mechanism significantly enhances the java platform s capabilities it also presents challenges for static analysis of java programs due to the complex behaviors introduced by native code.
therefore effectively resolving the interactions between java and native code is crucial for static analysis.
in this paper we introduce jnifer the first interactive cross language pointer analysis for resolving native code in java programs.
jnifer integrates both java and c pointer analyses equipped with advanced native call and jni function analyses enabling the simultaneous analysis of both java and native code.
during the analysis of crosslanguage interactions the two analyzers interact with each other constructing cross language points to relations and call graphs thereby approximating the runtime behavior at the interaction sites.
our evaluation shows that jnifer outperforms state ofthe art approaches in terms of soundness while maintaining high precision and comparable efficiency as evidenced by extensive experiments on openjdk and real world java applications.
index terms java native interface native code pointer analysis cross language analysis i. i ntroduction in java development native method calls play a crucial role in leveraging existing native libraries facilitating direct interaction with the underlying operating system optimizing application performance etc.
unlike ordinary java methods which are declared and implemented in java native methods are declared in java but implemented in other languages primarily c code referred to as native code .
the execution of native methods involves not only intra language communication within java and c but also complex cross language interactions.
these interactions can be categorized into two types first invoking c functions from java via native method calls denoted java c second using java native interface jni functions in c to call java methods create java objects access java fields and more denoted c java .
while native code is highly useful in development it poses significant challenges for static analysis .
the key to resolving native code lies in inferring behaviors at crosslanguage interaction sites which involves identifying the target native function of a native method call for j c interactions corresponding authors.and analyzing the behaviors of various jni function calls for c j interactions.
these tasks are complex due to the intricate nature of cross language interactions and language differences between java and c code .
despite these challenges resolving native code is valuable for static analysis providing more complete information about program behaviors and benefiting client analyses such as security analysis and bug detection .
to comprehensively and precisely resolve native code in java one of the most straightforward and effective approaches is to utilize pointer analysis a fundamental technique underlying virtually all other analyses .
despite the development of numerous pointer analysis methods over the past years for c and java individually no interactive pointer analysis exists to analyze java and c simultaneously.
the significant syntax and semantic differences between the languages along with their distinct pointer analysis algorithms complicate this approach and make it highly challenging.
consequently existing state of the art works jn sum and native scanner circumvent cross language pointer analysis to resolve native code in java.
specifically jnsum focuses on a limited subset of c language constructs transforming them into java code and then analyzing the java code.
however by focusing on only partial c behaviors this method fails to resolve many interactions between c and java missing numerous native code behaviors.
additionally the language transformation process is complex significantly affecting the analysis s robustness and making it difficult to adopt in practice.
conversely native scanner extracts string constants from c code and when matched with signatures in java code conservatively assumes those java methods are reachable to mimic the side effects of native code.
this highly conservative approach results in significant imprecision.
in this paper we tackle the above challenge directly by introducing jnifer the first interactive cross language pointer analysis to effectively resolve java native code.
a method jnifer integrates both java and c pointer analyses allowing the results of one to be recognized and incorporated into the other.
this facilitates the resolution of native calls java c and jni function calls c java simultaneously.
to achieve this we propose a cross language model that uniformly represents the results of both java and ieee acm 47th international conference on software engineering icse .
ieee pointer analyses.
based on this model we introduce two analyzers to on the fly resolve the cross language interactions of java c and c java respectively by utilizing pointer analysis while adhering strictly to the jni specification.
to maximally unleash the power of pointer analysis jnifer instantiates its methodology by incorporating tai e and svf two state of the art pointer analysis frameworks as its pointer analysis components for java and c respectively.
b results we conducted extensive experiments to compare jnifer with state of the art tools jn sum and nativescanner to examine its effectiveness.
these tools were used to analyze openjdk which extensively uses native code as well as all real world java applications used in recent research .
the results indicate that jnifer significantly outperforms existing state of the art methods soundness we measured soundness by comparing how many dynamic cross language interactions in our experiments could be recalled by the analyzers.
jnifer achieved an average recall of .
significantly higher than jn sum .
and native scanner .
.
precision we randomly selected various interaction sites and examined the analysis results of the tools.
jnifer maintained excellent precision at .
whereas nativescanner s precision was only .
.
although jn sum reached a precision of it failed to resolve a significant number of cross language interaction sites.
efficiency jnifer proved to be the fastest in our experiments achieving a speedup of .4x over jn sum and .2x over native scanner.
we will release jnifer as an open source tool and submit an artifact to aec for reproducing all experimental results.
ii.
m otivating example in this section we use an example simplified from realworld native code in openjdk to motivate our methodology.
first we introduce the basic concepts of native code and the example section ii a .
next we use the example to illustrate the limitations of existing works section ii b .
finally we present our insight section ii c .
a. introduction to native code and the example to use native code a developer must declare a native method using the native keyword.
when this method is invoked the jvm resolves the target native function written in c through name matching or runtime registration details of which are omitted here and enters the function.
this type of interaction where a native method call in java leads to a native function is termed a j c interaction.
within a native function a developer can invoke jni functions provided by the jvm to call java methods access java fields and interact with java objects.
this type of interaction where a jni function call in c operates on java elements is termed a c j interaction.
fig.
presents an example simplified from real world native code in openjdk where starting characters j and c denote the line numbers for java and c code respectively.
the exampleincludes seven cross language interactions marked by circled numbers ordered by their occurrence at runtime.
specifically 1 2 4 are j c interactions while 3 5 6 7 are c j interactions.
due to the diversity of c j interactions their side effects are explained in comments above the jni function calls to aid understanding.
in this example the java code consists of two classes image andcolormodel .image declares three native methods j13 j15 and calls them in initimage .
the right half of fig.
shows the corresponding native functions.
note that according to the first argument of a native function must be jnienv which is omitted here for simplicity.
to fully understand such a program it is essential to resolve all cross language interactions to obtain complete program behaviors including control and data flows.
for example at 3 the native function java image initnative calls setintfield to update the java field image.rgb with the value of rgb.
this indicates a data flow from rgb in c to image.rgb in java .
however if the c code retrieves an untrusted value and sets it to a security sensitive field in java via setfield it could introduce a security vulnerability.
if the static analyzer fails to resolve the crosslanguage interaction such a vulnerability may be missed.
b. limitations of existing works since the control and data flows of java programs with native code span both java and c sides a natural approach to analyzing such programs is to perform cross language analysis.
however this is challenging due to the intricate nature of cross language interactions and the differences between java and c. existing works attempt to circumvent this difficulty in resolving native code but they introduce their own limitations.
native scanner resolves native code in a highly conservative manner resulting in significant imprecision.
it extracts string constants from native code to construct partial java method signatures assuming that any java method matching these partial signatures will be called from c. for example for line c22 of fig.
native scanner would extract partial signature init v and consider all noargument methods with a return type of void to be potential targets invoked by native code.
additionally it does not support field access analysis in native code thus missing the data flow from 3 toimage.rgb .
even if it were to handle field accesses its methodology would likely introduce a substantial number of false positives.
jn sum adopts a different approach to analyzing java programs with native code by transforming c code related to jni function calls into java code and feeding it to the java analysis.
while this approach avoids the challenges of interactive cross language analysis it introduces the complexity of code transformation between c and java requiring comprehensive handling of both languages significant workload and potentially leading to soundness and robustness issues.
as a compromise jn sum handles only a subset of c features and performs cursory code transformation resulting in 1090j1 class image j2 int rgb j3 colormodel colormodel j4 initialization of an image object j5 static void initimage j6 image.initids j7 image image new image j8 image.initnative j9 ... j10 image.colormodel image.initcolormodel j11 j12 native method declaration j13 static native void initids j14 native void initnative j15 native colormodel initcolormodel j16 j17 class colormodel j18 colormodel ... j19 void setrgb int rgb ... j20 c1 jfieldid fid null c2 jniexport void jnicall c3 java image initids jclass image c4 fid getfieldid image rgb i c5 c6 jniexport void jnicall c7 java image initnative jobject image c8 jint rgb ... c9 set java field image.rgb c10 setintfield image fid rgb c11 c12 jniexport jobject jnicall c13 java image initcolormodel jobject image c14 get java field image.rgb c15 jint rgb getintfield image fid c16 jobject colormodel createcolormodel rgb c17 return colormodel c18 c19 jobject createcolormodel jint rgb c20 create a java colormodel object c21 jclass cm findclass colormodel c22 jmethodid mid getmethodid clz init v c23 jobject colormodel newobject clz mid c24 call java method colormodel.setrgb int c25 jmethodid setrgb getmethodid cm setrgb i v c26 callvoidmethod colormodel setrgb rgb c27 return colormodel c28 java language boundary cross language interaction1 7cfig.
.
the motivating example showing interactions between java and native code.
the function names colored in red are jni functions.
various errors in the transformed java code.
for example jnsum transforms the native function java image initids into a static method and the function call at c4 to getfieldid this rgb i .
however the generated java code is erroneous because there is no this variable in a java static method.
this error further prevents jn sum from resolving interactions 3 and 5 both of which rely on the field id obtained from c4.
in summary current state of the art methods have limitations and fail to effectively resolve cross language interactions including those in the example shown in fig.
.
c. our insight although performing interactive cross language pointer analysis is challenging we believe it is an effective approach for resolving native code and cross language interactions.
this method can adequately collect program information from each cross language interaction site in both java and c code accurately propagate this information to the other language and achieve effective results.
therefore we propose jnifer the first interactive crosslanguage pointer analysis to resolve native code.
jnifer integrates java pointer analysis and c pointer analysis equipped with an innovative cross language model enabling the two analyses to interact and collectively resolve cross language interactions.
jnifer can avoid the imprecision issues of nativescanner as well as the complexity and subsequent soundness and robustness issues of jn sum making it more effective at resolving native code compared to existing approaches.
for instance when analyzing 3 in fig.
jnifer collects information about image fid and rgb via c pointer analysis resolves its target java field and propagates it to java pointer analysis resulting in an accurate analysis of this interaction site.iii.
m ethodology of jnifer we present an overview of jnifer and its key components.
a. overview fig.
provides an overview of jnifer which takes a program containing both java and native c code as input and outputs the resolved cross language interactions within the program.
the key innovation of jnifer is its interactive cross language pointer analysis.
jnifer consists of a java pointer analysis and a c pointer analysis which collect program information from both java and c code.
building on these analyses we introduce a new jni analysis divided into java and c parts.
both parts run simultaneously with the pointer analyses and interact with each other by exchanging requests and replies to resolve the behaviors at cross language interaction sites.
as shown in fig.
jni analysis is the core of jnifer consisting of three components.
native call analysis resolves native method calls from java code j c interactions while jni function analysis resolves jni function calls from c code c j interactions .
both analyses are divided into a java part and a c part each communicating with their respective pointer analysis.
to enable interaction between these two parts they must be aware of relevant program information e.g.
objects and pointers from their counterpart.
therefore we propose a cross language model to support this communication.
below we introduce these components in detail.
b. cross language model to enable interactive cross language pointer analysis we designed a novel model for exchanging program information between the java and c parts of jnifer.
the core idea of our model is that the java and c parts convert program elements into numerical ids or strings and then transmit them 1091java pointer analysis pointer analysis core native callreachable methodpoints to relationpointer analysis core jni function callreachable functionpoints to relationc pointer analysisjnifer resolved cross language interactionsjava jni analysis c jni analysis native call analysis native function resolution jni function analysis method handler object handler field handlerjni function analysis java code native code cross language model cross language model request native call analysis reply request replyfig.
.
overview of jnifer to each other via inter process communication ipc .
each part maintains mappings between the program elements and the exchanged information.
we carefully designed this model to minimize the amount of program information that needs to be exchanged resulting in a simple yet effective cross language model.
overall our model exchanges three types of program elements java objects java classes methods fields and call sites in both java and c as explained below.
a java objects the java part and the c part need to exchange java objects manipulated by native code.
instead of directly exchanging java objects jnifer exchanges the java pointers that point to the objects.
this design reduces the amount of information exchanged as a single pointer can point to multiple objects.
to exchange a java pointer the java part assigns a unique id to the pointer and the c part maps this id to a mock object of type jobject which represents java