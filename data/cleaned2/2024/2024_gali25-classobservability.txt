increasing the effectiveness of automatically generated tests by improving class observability geraldine galindo gutierrez juan pablo sandoval alcocer nicolas jimenez fuentes alexandre bergel gordon fraser department of computer science school of engineering faculty of engineering pontificia universidad cat lica de chile chile centro de investigaci n en ciencias exactas e ingenier as universidad cat lica boliviana bolivia relationalai switzerland university of passau germany abstract automated unit test generation consists of two complementary challenges finding sequences of api calls that exercise the code of a class under test and finding assertion statements that validate the behavior of the class during execution.
the former challenge is often addressed using meta heuristic search algorithms optimising tests for code coverage which are then annotated with regression assertions to address the latter challenge i.e.
assertions that capture the states observed during test generation.
while the resulting tests tend to achieve high coverage their fault finding potential is often inhibited by poor or difficult observability of the codebase.
that is relevant attributes and properties may either not be exposed adequately at all or only in ways that the test generator is unable to handle.
in this paper we investigate the influence of observability in the context of the evosuite search based java test generator which we extend in two complementary ways to study and improve observability first we apply a transformation to code under test to expose encapsulated attributes to the test generator second we address evosuite s limited capability of asserting the state of complex objects.
our evaluation demonstrates that together these observability improvements lead to significantly increased mutation scores underscoring the importance of considering the class observability in the test generation process.
index terms observability automatic test generation mutation analysis i. i ntroduction testing is a key aspect of the software development cycle but it is also considered one of the most time consuming tasks for developers .
to support developers in writing unit tests to verify the behavior of their code research has therefore proposed different approaches and tools to automatically generate unit tests .
these tools produce tests consisting of sequences of statements that satisfy predefined testing goals such as maximizing the code coverage.
while studies have demonstrated that automatically generated tests succeed in achieving high code coverage they also showed that these tests are limited in their effectiveness at revealing faults .
one factor influencing this is a poor choice of test assertions which often fail to establish a relationship between the methods being tested and what they check .
an important reason contributing to this issue is the observability of the class under test i.e.
the ability to access and check the internal state of an object.
for example consider the dbconnectionbroker class listing which ispublic class dbconnectionbroker private int maxconnections ... public void release dbconnectionattributes attrs if attrs.getindex this.attributesarray !
null if attrs.getindex this.min this.attributesarray .free this.maxconnections else this.disconnect attrs else this.disconnect attrs listing .
the dbconnectionbroker class does not allow verifying if the release method works as expected.
public class htmlviewerpanel extends jpanel private url currenturl ... public synchronized void goforward if historyindex historyindex history.size displayurl history.get historyindex private void displayurl url url ... currenturl url ... public url geturl return currenturl listing .
the internal state of htmlviewerpanel objects is accessible but current test generators cannot make use of that information.
responsible for handling database connections in the biblestudy open source project.
when testing the release method a test generator will struggle to create an appropriate assertion as the method neither has a return value to check nor is the private maxconnections attribute publicly accessible for use in an assertion.
a recent study revealed that in most cases when automatically generated tests fail to produce appropriate assertions the class under test lacks methods to verify the effects of the behavior being tested.
even if the class under test allows inspecting the internal state test generators may be unable to make use of that infor mation.
for example consider the htmlviewerpanel class in listing taken from the open source project squirrel sql the method goforwards moves the content of an html viewer forward to the next url which is stored in the attribute currenturl .
while the method again does not provide a return value on which an assertion can be generated in this example there actually is a means to access the internal state as the geturl method allows retrieving the currently stored url.
however the popular evosuite unit test generator like other tools will nevertheless fail to produce an appropriate assertion as it only considers getter functions that return primitive datatypes e.g.
integers or booleans .
without appropriate assertions tests may miss faults .
the urgency of this problem has been demonstrated by a recent study that found that low observability led to inconsistent results in evosuite as measured by the mutation score i.e.
a proxy metric estimating the fault finding potential of tests .
additionally although various studies have shown that observability is an aspect that makes test creation difficult little is known about the extent to which limited observability negatively impacts test generation algorithms.
in this paper we therefore aim to assess the impact of class observability on the effectiveness of evosuite s automatically generated tests the central research question consequently is to what extent does the observability of the class under test impact the effectiveness of the generated tests?
in order to answer this research question we designed a study where we automatically increased class observability through two evosuite extensions addressing two types of observability problems.
the first extension increases the visibility of class attributes by automatically injecting public accessors into private and protected attributes.
the second extension improves evosuite s ability to inspect the states of composed objects i.e.
non primitive types by generating assertions that recursively check their states.
we then conducted an extensive experiment in which we generated tests for a well known set of complex classes from the sf dataset using evosuite both with and without our extensions separately and together.
this study seeks to contribute to the literature on how test generation tools can produce more effective tests by increasing class observability.
in detail this paper makes the following contributions we propose an observability transformation that exposes internal object states to automated test generators.
we propose an extension of existing assertion generation techniques for asserting on states of complex objects.
we empirically evaluate the effects of observability on a sample of open source java classes.
our study reveals that increasing the visibility of class attributes alone significantly increased the mutation scores of the generated tests for out of the classes.
when we both increased visibility and enabled evosuite to recursively assert composed objects the mutation score improved significantly for classes.
these results demonstrate that observability has a substantial and significant impact on the effectiveness of assert generation and the mutation score.
however werecommend further research on techniques that improve the observability and testability of classes to determine when and how to apply such strategies effectively.
ii.
o bservability challenges in testgeneration software testability defined as the ease of testing a software artifact plays an important role for testing.
high testability simplifies test creation whereas low testability can significantly increase the time and effort required in the development of unit tests .
various factors have been shown to induce negative testability such as controllability complexity cohesion coupling understandability and inheritance with observability being particularly important and subject of extensive research .
observability is the ability to monitor a program s behavior through its outputs therefore it represents an important aspect in verifying correct input processing .
in classes with limited observability creating unit tests and especially their assertions becomes a challenge specifically for test generation tools.
a previous study showed that limited observability of class attributes may lead to inconsistencies in automatically generated tests particularly inconsistencies between the test target goals and the generated assertions .
for example resulting assertions may not be related to the intended behavior being tested.
in the following paragraphs we describe two root causes of these inconsistencies.
a. limited object state visibility listing showed that if the class under test lacks mechanisms to verify that an object reaches the expected state it becomes difficult to create effective assertions even manually.
this issue arises because without access to the internal state it is challenging to confirm whether the methods have performed as intended.
for instance consider the scriptorfnscope class shown in listing and the two resulting tests automatically generated by evosuite for it shown in listing .
class scriptorfnscope private int bracenesting private scriptorfnscope parentscope private arraylist subscopes private hashtable identifiers new hashtable private hashtable hints new hashtable private boolean markedformunging true private int varcount ... void preventmunging if parentscope !
null markedformunging false void munge if !markedformunging return ... for int i i subscopes.size i scriptorfnscope scope scriptorfnscope subscopes.get i scope.munge listing .
excerpt of scriptorfnscope class.public void test09 throws throwable scriptorfnscope scope0 new scriptorfnscope scriptorfnscope null scriptorfnscope scope1 new scriptorfnscope scope0 scriptorfnscope1.preventmunging scriptorfnscope1.munge assertfalse scope0.equals object scope1 public void test10 throws throwable scriptorfnscope scope0 new scriptorfnscope scriptorfnscope null scope0.preventmunging listing .
generated tests for scriptorfnscope class.
evosuite generates regression assertions for a given test by tracing its execution and then elaborating all possible assertions using basic heuristics.
for example for each primitive return value it will add an assertion that compares the return value to the one observed during the execution and for all nonprimitive objects contained in the test it will create assertions comparing the values returned by all getter functions with the observed values.
thereby a getter is simply identified as a parameterless method that returns a primitive value and has no side effects.
in a second step evosuite will then iteratively insert mutations into the code under test and filter out those assertions that can successfully reveal a difference between the executions on the original code and the mutated code.
the result is a minimized set of assertions supposed to check only attributes relevant to the execution .
as the scriptorfnscope class provides no public accessors or other means to check the state of variables used by the methods under test specifically the preventmunging and munge attributes none of the assertions generated using this approach can reveal a difference in behavior induced by the mutants.
this may result in a test without any assertions at all like test10 .
to avoid filtering allassertions evosuite implements some heuristics that try to select arbitrary but plausible assertions such as assertions at the end of the test case like the assertion in test09 .
this assertion attempts to compare the states of two objects but this comparison is ineffective because the class scriptorfnscope does not override the equals method.
consequently the equals method only checks if the two variables reference the same object which is not the case.
as a result unless an exception is thrown during execution the test will always pass independently of the presence of faults and it provides no meaningful validation.
b. asserting composed object states even when a class contains methods that provide visibility of its internal state the complexity escalates when creating assertions for non primitive objects which are objects that have other objects as attributes.
currently evosuite generates five types of assertions primitive assertions comparison assertions inspector assertions field assertions and string assertions.
some of these assertions such as inspector and field assertions help to assert the final state of an object after test execution.
for instance they can inspect a private primitiveattribute through an inspector method e.g.
an accessor or directly access the primitive field if it is public.
however these types of assertions do not check the state of non primitive objects other than comparing against null such as objects that have other objects as attributes.
as a result it is not possible to detect bugs related to the attributes of inner objects.
for example consider the class htmlviewerpanel in listing and its method goforwards which helps users navigate in the html viewer by moving forward to the next url.
during the mutation testing step of assertion generation evosuite injects bugs into the if condition within the method goforwards .
when the if condition is met the urlobject is updated through the method displayurl .
although the class has a public accessor for the attribute currenturl evosuite s assertions are unable to validate if the urlto which the html viewer moves forward is correct.
to do so would require checking if the state of the url object is correct.
however since the url object is an attribute of htmlviewerpanel it is necessary to assert the state of the inner objects.
c. motivation automatically generating tests for classes with restricted observability presents a formidable challenge.
most test generation tools focus on achieving high code coverage often overlooking the testability of the class under test.
especially observability greatly influences the formulation of effective assertions and is directly reflected in the low mutation scores.
our examples illustrate that even during manual test creation it may be challenging to generate feasible assertions in some scenarios.
moreover recent research highlights a disconnection between the assertions and the branches targeted in tests due to limited observability .
our research is motivated by the goal of understanding how observability impacts the effectiveness of generated tests and to what extent.
therefore we hypothesized that increasing the observability of the class under tests can lead to a better performance of the generation tool mainly on mutation analysis.
iii.
s tudying and increasing observability to assess the impact of class observability on evosuite s effectiveness we implemented two complementary extensions.
this section provides a detailed description of each extension.
a. open object state visibility extension this extension increases the observability of the class under test by automatically injecting public accessors for all private or protected attributes that do not already have an accessor.
we inject these accessors at the bytecode level.
the injected accessors simply put the attribute on the stack and include a return instruction.
the method names of the accessors are a concatenation of the string get the attribute name and the keyword injected at the end.
this keyword helps us to differentiate between the accessors that already exist and those that we injected.
to detect whether an attribute already has an accessor we search its class for a public method containing only one statement that returns the attribute.when this extension is activated evosuite runs a preprocessing algorithm before starting the generation.
this algorithm iterates over all classes in the system and injects public accessors.
our goal is to open object state visibility allowing evosuite direct access to all attributes in the system.
since these accessors are part of the bytecode evosuite would consider them when computing target goals or during mutation testing.
we modify evosuite so it considers these injected accessors only during the assertion generation algorithm which is a post processing step.
however the injected accessors are not considered for mutation injection or as part of the coverage goals.
listing shows a generated test for the class scriptorfnscope using this extension.
the generated test uses an injected getter getmarkedformunging injected in the assertion generation in bold .
this helps to increase the mutation score of the class scriptorfnscope by .
.
public void test10 throws throwable scriptorfnscope scope0 new scriptorfnscope scriptorfnscope null scriptorfnscope scope1 new scriptorfnscope scope0 scope1.preventmunging scope1.munge assertfalse scope1.
getmarkedformunging injected assertnotsame scope1 scope0 listing .
example of generated test that use an injected getter in bold .
note that this evosuite extension is not intended as a solution for the observability problem but as a means to assess its impact.
encapsulation is important in object oriented programming as it reduces dependencies on internal object data.
we further discuss this point in section vi.
b. recursive inspector assertion extension this extension adds a new assertion type to evosuite called a recursive inspector assertion .
it builds on the existing inspector assertion in evosuite.
inspector assertions create an assertion for each inspector method found in the object under analysis.
evosuite considers an inspector method as one that takes no parameters has no side effects and returns a primitive data type.
this excludes methods that return an object.
in our case we extend this functionality to also consider inspector methods that return an object.
we focus on methods that take no parameters and consist only of functionality of returning a class attribute that is not primitive.
our extension generates assertions that contain a chain of inspector methods that are executed over the object under analysis.
the recursion stops either when an inspector method is found that returns a primitive value for which an assertion is added or when a configurable threshold of the recursion depth is reached.
the algorithm inspects all attributes that have a public accessor and if the attribute is an object the algorithm will inspect their attributes too recursively.
listing shows a test for the htmlviewerpanel class listing that uses this extension.
note that the generated test has three recursive inspector assertions.
for instance the second assertion evaluates the url protocol using two accessors geturl and getprotocol in a chain.public void test15 throws throwable ... htmlviewerpanel panel0 new htmlviewerpanel url1 panel0.gotourl url0 panel0.goback panel0.goforward assertequals file some fake but wellformed url panel0.
geturl .toexternalform assertequals file panel0.
geturl .getprotocol assertequals some panel0.
geturl .gethost listing .
example of recursive inspector assertions in bold note that after assertion generation evosuite performs a mutation based assertion minimization which removes assertions not relevant to the mutation testing analysis.
as a consequence evosuite will only keep recursive inspector assertions that are considered useful for detecting mutants.
iv.
e xperimental setup this section details the empirical study for evaluating the impact of class observability on evosuite effectiveness.
a. research questions our main research question is to what extent does the observability of the class under test impact the effectiveness of the generated tests?
as we have shown in section ii the limited access to private protected class attributes and mutants that affect composed objects can hinder test generation algorithms.
to assess the impact of these limitations we aim to answer the following research questions empirically rq1 encapsulation to what extent does the limited access to private protected attributes in the system impact evosuite s effectiveness?
rq2 composed objects to what extent does checking the state of composed objects impact evosuite s effectiveness?
rq3 combined effectiveness to what extent does the combination of the two evosuite extensions impact evosuite s effectiveness?
rq1 investigates how encapsulation affects evosuite s effectiveness.
to address this question we compare evosuite s performance in terms of code coverage and mutation score before and after modifying the visibility of all class attributes in the system.
rq2 and rq3 examine the impact of the ability to inspect the state of composed objects on evosuite s effectiveness.
specifically these questions evaluate recursive object assertions with and without restricted access to nonpublic attributes.
rq3 specifically aims to determine the extent to which encapsulation limits our proposed recursive assertion generation technique.
b. subject java classes our evaluation uses classes from the sf110 dataset widely used in unit test generating tool evaluations .
the complete dataset contains over 23k classes from projects.
however studies have shown that the dataset contains many trivial classes .
therefore we decided to use a subset of classes previously used in other studies .
thissubset was filtered using a cyclomatic complexity threshold of to ensure that the generated tests are not solely composed of accessors.
this filtering guarantees a wider variety of explored branches and generated mutants while keeping the time required to run our experiments manageable.
c. baseline for comparison as in previous studies we use the dynamosa algorithm as a baseline for comparison .
dynamosa uses a multi objective technique known as the many objective sorting algorithm mosa with dynamic selection this technique has proven to generate tests with higher coverage.
we generate unit tests for our subjects following the recommended hyperparameters of previous studies.
we also extended the time of the search budget to seconds and the assertion timeout to seconds as suggested by panichella et al.
.
d. treatments to answer our research questions we compare the baseline results with three treatments based on the observability extensions described in section iii.
injected getters the first treatment involves a preprocessing step before generating tests which injects public accessors for attributes that are protected or private.
recursive assertions the second treatment allows evosuite to generate assertions that recursively check the state of composed objects using only accessors already defined in the original source code.
combined extensions the third treatment combines both extensions injecting public accessors which can later be used for generating recursive inspector assertions.
note that in all cases the injected code is not considered when computing the test goals and mutation score.
our goal is to generate tests with the same test goals and analyze how many additional mutants the treatments help to kill using the same set of mutants from the baseline.
for recursive assertions in the second and third treatments we use a threshold of n .
this means that the generated assertion checks recursively all the primitive attributes of the composed object up to a maximum depth of three levels.
e. experimental protocol to answer our research questions we compare a baseline of generated tests with the treatments previously defined.
we consider the following aspects of the conducted experiment for comparing test suites generated for the same class.
collected metrics for coverage metrics we compare thestatement branch and resulting test suite s coverage with the latter being a summary of the eight coverage metrics considered during evosuite s generation.
by construction our evosuite extensions should not impact coverage but we compute these metrics only to support this claim.
however our primary focus is on mutation analysis metrics.
we analyze the mutation score i.e.
the percentage of mutants detected by a test suite to compare if the use of a treatment yields a higher percentage of mutants detected.
to determine if a detectedmutant is related to the extensions used we manually examine the details of killed mutants .
for mutation analysis we use the evosuite mutation engine and their default mutation operators delete call delete field insert unary operator replace arithmetic operator replace bitwise operator replace comparison operator replace constant and replace variable this allowed us to control the use of our extensions for mutation analysis in a single workflow.
in total all classes under analysis contain mutants varying between and for each class.
data collection we generated tests for each of the treatments and the baseline using randomly generated 13digit seeds to ensure reliable detection of statistical differences.
in consequence we had to generate tests for each class using four different configurations times each making a total of generated test suites for each class and thousand test suites overall.
we stored all the data outputs and metrics in text files for each configuration and statistically analyzed them.
each treatment generation of seeds per class took around a day and a half to complete.
all experiments were executed on a computer with an m1 processor with cores and gb ram.
in total the experiment took days of computation time.
statistical analysis after applying all treatments to the studied subjects we compared the generated tests from each treatment against the baseline generated tests in terms of coverage and mutation score.
as the shapiro wilk test suggested that the data is not normal we used a one tailed wilcoxon test to identify statistically significant differences between the baseline and the treatments.
specifically we compared the mutation scores and coverage metrics of the generated test suites for each class with each test suite generated using a different seed.
we aim to conclude if the collected metrics of the treatments were significantly higher than the baseline using a threshold value of .
.
after comparison for each class that shows a statistically significant difference we manually analyze the source code of the generated tests to confirm if they use an injected accessor or a recursive inspection assertion and if the mutation score increment is directly related to our evosuite extensions.
finally we measure the impact of each treatment using the vargha delaney a12 statistic to gauge the effect size.
we interpret the a12statistic taking as reference the value .
.
if the value is .
we conclude that the treatment used does not affect the generated tests.
however a value greater than .
suggests that in further generations the use of the strategy has a greater probability of obtaining better metrics.
consequently a value lower than .
indicates the opposite.
f .
threats to validity threats to construct validity concern the relationship between theory and experimentation.
the evaluation of the proposed extensions is based on effectiveness metrics commonly used in the literature coverage metrics and mutation score .
coverage metrics represent the quantity of code executed by the tests and mutation scorecreates artificial bugs and measures how many are detected by the test suite.
although these artificial bugs do not necessarily represent all possible bugs in the code mutation score is considered as a reasonable estimation of effectiveness to evaluate a test suite .
threats to internal validity arise from factors that might influence the obtained results.
to reduce the randomness and to ensure the sufficiency of data for statistical tests we generated tests times per class using different seeds.
for generation we used parameters suggested in previous studies that have proven to generate tests with higher coverage.
another threat comes from the additions caused by our extensions.
when using injected getters we modified evosuite to ignore the injected methods in the mutation analysis i.e.
to not create mutants for these methods and from the generation goals.
this avoids variations in the number of mutations or tests.
in consequence the results in each treatment are comparable as they are analyzed using the same set of mutants.
threats to external validity are related to the generalization of our results.
because of the high number of test generations needed for the experiment we limited the studied classes to java classes from the sf dataset.
although reduced this dataset contains classes from a variety of projects and several domains.
the use of these classes is also comparable with previous studies that use the same selection to study evosuite improvements and test quality .
while the injected getters implementation is applicable to different test generation tools the recursive assertions implementation aligns with the functionality and limitations of evosuite.
asserting the state of composed objects remains a relatively unexplored field in test generation which we aim to expand on in future work.
threats to conclusion validity arise from the relationship between treatment and results.
for analyzing the effectiveness of our extensions using the mutation score of the generated test suites we use appropriate statistical tests and repetitions to ensure enough data to use these tests.
for each comparison we performed a wilcoxon test using alpha .05and used the vargha delaney effect size.
we concluded only from statistically significant results.
v. r esults this section summarizes the results after generating tests for the selected subjects using the three defined treatments and the baseline times using different seeds.
a replication package containing the results in detail is available online.
a. code coverage it is important to note that our proposed evosuite extensions are designed to enhance the visibility of the classes under test thereby mitigating observability limitations during assertion generation.
this enhancement is directly correlated with the mutation score.
consequently by construction the coverage of the tests generated by both the baseline and the treatments mutation scorebaselineinjected gettersrecursive assertionscombined extensionsfig.
.
mutation score of the classes in the different treatments compared to the baseline .
.
.
.
.
.
vargha delaney effect sizeinjected gettersrecursive assertionscombined extensions fig.
.
vargha delaney size effect of the classes in the different treatments remains unchanged.
our results confirm this assumption as the treatments do not exert a direct impact on the coverage metrics and there are no significant differences between the treatments.
the average resulting test suite s coverage for the classes is .
where the elgamalkeyparameters class has the highest resulting coverage on the set .
classes were not covered by any test generated filenodemodel openpreviousdialog previewdialog and classes of the set reached full branch coverage.
b. baseline mutation score we generated tests for the classes under analysis using the dynamosa evosuite algorithm to take these results as baseline for comparison.
evosuite produced test suites per class.
on average the generated test suites reached an average mutation score of .
.
for classes the generated test suites did not detect any mutants in any of their generations and for only one class the generated test suites killed all the injected mutants.
c. object state visibility to answer our first research question rq1 we employed our first extension which introduces public accessors to private and protected attributes that previously lacked such accessors.upon analyzing the classes under study we observed that only classes were augmented with at least one injected public accessor.
therefore the remaining classes either did not contain any private or protected attributes or their attributes were already equipped with public accessors.
consequently the bytecode of these classes remained unchanged.
on average the generated test suites with the injected accessors contained more assertions than the baseline.
we conducted a manual analysis and observed that the generated tests for classes did not contain any assertions using an injected getter.
consequently their mutation scores did not experience any variation.
no tests were generated for three classes with injected accessors and consequently these classes were not further considered in the analysis.
the remaining classes contain injected getters in the assertions of their generated tests.
through statistical analysis we found that of these classes have a significant increase in their average mutation score when using injected getters.
table i summarizes these classes and the difference between the mutation score and the number of mutants killed.
by using the injected accessors the classes improved their mutation score from .
to with one class killing additional mutants.
therefore .
of the classes that used injected accessors significantly increased their mutation score and detected more mutants.
figure illustrates the variation of the effect size for the classes studied.
we found that classes have an a12 value greater than .
but only of these classes show a statistically significant increase in the mutation score.
the a12values for these classes range from .
to .
for classes although they have a positive effect size a12 .
the difference in mutation scores is not significant with a12 values ranging from .
to .
.
the remaining classes do not present a significant improvement and have a a12of .
or close to it indicating that the treatment used does not impact the mutation score.
we conducted a manual review of these classes with a significant increment in the mutation score and confirm that the mutation score increment is due to the use of injected getters in the assertions.
in total new mutants were detected with an average of additional mutants per class.
we were able to confirm that on each of the classes the injected accessors helped detect mutants related to class initialization variable value changes and conditionals.
the classes contained injected getters.
we found that only helped detect at least one new mutant.
on average each of the classes used only of their injected getters.
in most cases no test in the suite covers the lines where the field linked to an injected accessor is modified.
however if we consider all the injected getters in the selected classes only of injected getters were helpful.table i results for significant classes p val .
using injected getters considering mutation score ms and number of killed detected mutants km .
classbaseline injected getters ms a12 ms km ms km alphabetictokenizer .
.
.
axisservlet .
azmessagedecoder .
.
.
azotherinstanceimpl .
.
.
.
caleventmodelimpl .
.
.
.
dbconnectionbroker .
.
.
dhtrouternodeimpl .
.
.
direntry .
.
.
.
dlfileentrymodelimpl .
.
.
.
engineimpl .
.
.
.
getrevision .
.
.
.
hl7checkerimpl .
.
.
.
htmlviewerpanel .
.
.
.
joomlaoutput .
.
.
.
noenformatter .
.
.
.
notificationeventcomparator .
.
.
.
organizationmodelimpl .
.
.
.
parser .
.
.
.
pdfprocessorimpl .
.
.
.
pollschoicemodelimpl .
.
.
portalexecutorfactoryimpl .
.
.
prelaunchhelperimpl .
.
.
.
rdresumehandler .
.
.
sacpluginactivator .
.
.
.
scriptorfnscope .
.
.
.
testjava .
finding .
increasing the visibility of class attributes improved evosuite s mutation score between .
and in the tests generated for classes.
a manual review confirmed that these additional mutants killed were directly associated with assertions utilizing the injected accessors.
this underscores the importance of considering observability in the test generation process.
the generated tests for classes show no variation in the mutation scores despite containing injected public accessors.
in classes despite having between and injected public accessors evosuite did not use them in the assertion generation process.
we analyzed these classes and found that for of them evosuite generated only test methods that ended in exceptions resulting in no assertions being used.
for classes evosuite deleted the assertions that used the injected accessors during the mutant based minimization process because they were unrelated to any mutants.
in the remaining classes of the without changes in mutation score we found that the generated tests included injected getters in the assertions.
however they showed no changes in their mutation scores as the generated assertions killed the same mutants as the baseline showing no improvements.
for instance in the class connectionconsumer the detected mutants in the baseline remained after applying the treatment.
it is likely that in these cases the injected getters are related to attributes that are not associated with the undetected mutants the generated tests do not even execute the undetected mutants due to low coverage or the mutants related to thesetable ii results for significant classes p val .
using recursive assertions considering mutation score ms and number of killed detected mutants km classbaseline rec assertions ms a12 ms km ms km azotherinstanceimpl .
.
.
.
htmlviewerpanel .
.
.
.
isc stmt handle impl .
.
.
shoppingcategorywrapper .
.
.
attributes are already killed by other assertions.
these observations on the use of the injected getters can be seen in the vargha delaney distribution where some classes with a higher effect size have few instance variables while others show no effect despite numerous injected accessors for example noenformatter class is injected with only one getter and reports an a12value of .
while the macawstateeditor class contained injected getters but only reaches a a12value of .
suggesting further research is needed to determine the conditions under which a getter is beneficial.
finding .
the increment in the mutation score is not directly related to the number of injected getters as not all injected getters may provide benefits.
this identifies an area for further research to develop strategies for determining which attributes require accessors.
d. asserting composed objects to understand to what extent the lack of observability is due to evosuite s inability to assert on composed objects rq2 we now consider our second evosuite extension which recursively checks the states of composed objects using a threshold.
note that treatment two only assesses the impact of recursive assertions without injecting getters to the code under tests.
after generating tests for the classes we manually checked the test suites generated for each class one for each seed and found that of the checked classes at least one generated test suite used a recursive inspection assertion.
on average the generated test suites that allowed asserting composed objects contained more assertions than the baseline.
therefore we manually analyzed the assertions in these cases of which were included in the classes that were injected with getters in the previous treatment.
we compared mutation scores and found that only in four cases the difference in mutation score is statistically significant.
this represents .
out of the classes that use recursive inspection assertions.
the increment of mutation score ranges from .
to .
and a maximum of new mutants are detected.
we manually reviewed the newly detected mutants for each class and found a direct relation between recursive assertions and mutants changing the values of internal objects or the initialization of a composed object this means that asserting the composed object was related to mutants injected to change the internal value of an element.table ii summarizes the mutation scores the number of killed mutants and the effect size of these four classes.
figure shows the comparison between the mutation scores on the baseline and using recursive assertions.
the tendency between the boxplots does not reveal a significant impact of the recursive assertions on the mutation score for most classes the effect size remained at .
implying the same performance as the baseline.
this low impact is also observed in figure compared to the previous treatment.
for the classes under analysis only classes had a a12value slightly higher than .
varying between .
and .
.
of these classes only show a statistically significant increase in the mutation score.
the remaining classes do not experience increases in their mutation scores and their vargha delaney values are .
or close to it.
finding .
the generation of recursive inspection assertions had a slight impact on mutation scores improving them between .
and .
for only four classes.
our manual review confirms that this increment is directly related to the generated recursive assertions.
this shows that asserting complex objects can impact mutation scores in specific cases but further research is needed on alternative assertion generation methods as a considerable portion of mutants remain undetected.
e. open state visibility and asserting composed objects our findings show that encapsulation impacts the effectiveness of generated tests particularly the generated assertions.
our proposed assert generation technique is not exempt from this.
to understand the degree to which encapsulation limits recursive assertion generation we evaluate the effectiveness of asserting recursively composed objects when all attributes of the code under test are visible which we can simulate by using both extensions at the same time.
after generating tests for the classes using a combination of our previously implemented extensions we observe that of them use one or both extensions use only injected getters in their test suites use only recursive assertions and use both extensions use the extensions combined in their assertions and separately.
therefore we focus on the assertions generated for these classes using different seeds.
on average the generated test suites resulting from the use of the combined extensions contained more assertions than the baseline.
statistical analysis shows that in of these cases the mutation score increased significantly.
of these classes only use injected getters no class uses recursive assertions without using injected getters of the composed objects and use both extensions in their assertions classes combine the extensions in the assertions and use them separately.
table iii details the mutation score number of killed mutants and the effect size of each one of these classes.
we conducted a manual review to determine the relation between the assertions generated for the significantly improved classes and the new detected mutants.
we foundtable iii results for significant classes p val .
using combined extensions considering mutation score ms and number of killed detected mutants km classbaseline combined extensions ms a12 ms km ms km alphabetictokenizer .
.
.
axisservlet azotherinstanceimpl .
.
.
.
caleventmodelimpl .
.
.
dbconnectionbroker .
.
dhtrouternodeimpl .
direntry .
.
.
.
dlfileentrymodelimpl .
.
.
.
engineimpl .
.
.
.
hl7checkerimpl .
.
.
.
htmlviewerpanel .
.
.
.
joomlaoutput .
.
.
.
newscheduler .
.
.
.
.
noenformatter .
.
notificationeventcomparator .
.
.
.
organizationmodelimpl .
.
.
.
parser .
.
.
.
pdfprocessorimpl .
.
.
pollschoicemodelimpl .
.
.
.
portalexecutorfactoryimpl .
prelaunchhelperimpl .
.
.
rdresumehandler .
.
.
sacpluginactivator .
.
.
scriptorfnscope .
.
.
testjava version .
.
.
.
a direct relation between the assertions generated and the mutants detected in most cases the generated tests contained in the same test assertions generated using both extensions instead of only one.
for instance consider the generated test for azotherinstanceimpl on listing where different assertions on the same test use both extensions.
for example the assertion that contains the get udp non data portkeyinjected is related to mutants created to simulate bugs during object construction.
the two last assertions are related to test the internal state of the composed object of the class internaladdress .
this check is useful because of mutants dedicated to change the assignment of the attribute.
the classes with significant improvement found for combined extensions correspond to the classes found with the use of only injected getters excepting two azmessagedecoder and getrevision where their generated tests contained unstable assertions.
however two new classes had significant improvement in their mutation score newscheduler andversion .
the increment on mutation score in these classes ranges from .
to and a maximum of new mutants were detected.
figure shows the comparison between the mutation score of the generated test suites using both extensions using only one and not using any.
note that in all cases the extensions do not lower the mutation score of the classes under test.
the figure also reveals a notable impact of the extensions used.
compared to the exclusive use of injected getters the addition of recursive assertions raised the mutation score by a maximum of .
in the notificationeventcomparator class.
however this addition did not increase the mutationscore of the other classes which has an average increase of .
on the mutation score.
the combination of both extensions improved the mutation score across classes with classes using both recursive assertions and injected getters.
however classes showed similar improvements with only injected getters indicating a minimal additional benefit from asserting complex objects.
these findings suggest that while recursive assertions are beneficial they do not fully address the limitations of assertion generation.
further research is required to explore alternative methods to enhance assertion generation.
finding .
the combination of both extensions improved the mutation score from .
to in classes with classes using both recursive assertions and injected getters.
while recursive getters are beneficial they do not fully address the limitations of assertion generation.
further research is required to explore alternative methods to enhance assertion generation.
for the vargha delaney a12statistic of these classes showed a value greater than .
suggesting a .
chance of higher mutation scores as a result of using the combined extensions.
figure shows the comparison of a12between treatments.
the figure shows a higher concentration of classes surpassing the .
value.
the classes that used the extensions have on average a .
a12value a higher effect than the average of the significative classes of separate extensions.
however no clear relation between the use of the injected getters and the effect size is found.
finding .
although the number of significant classes has increased using extensions combined rather than separately the recursive assertions do not demonstrate a higher effect on the mutation score.
the results using injected getters remark the importance of class attributes observability for generating more effective test suites.
public void test00 throws throwable ... azotherinstanceimpl azotherinstanceimpl0 new azotherinstanceimpl yyl u kvr bfd inetaddress0 inetaddress0 hashmap0 assertequals azotherinstanceimpl0.getudp port assertequals azotherinstanceimpl0.
getudp non data port injected ... assertequals .
.
.
azotherinstanceimpl0.
getinternaladdress .gethostaddress assertfalse azotherinstanceimpl0.
getinternaladdress .ismcsitelocal listing .
test with injected getters and recursive assertions.vi.
d iscussion a. encapsulation our results show that injecting public accessors enhances the observability of internal states thereby improving mutation testing effectiveness by exposing class attributes for verification.
however manual analysis revealed that not all injected accessors were beneficial.
among the classes with significant improvements in the mutation score accessors were injected but only were used by evosuite to detect additional mutants.
this highlights that while increased accessibility can be advantageous its use in production code must be carefully managed to avoid violating encapsulation principles which could compromise modularity and security.
maintaining a delicate balance requires strategic decisions regarding public accessors.
developers should selectively implement public accessors to maximize testing coverage without compromising class structure.
future research should focus on developing techniques that guide developers in identifying attributes that need accessibility helping them make informed decisions on injecting public accessors.
this approach would optimize the trade off between enhanced testability and preserving encapsulation principles.
b. recursive assertions to assert the state of composite objects we proposed a direct variation of the evosuite inspector assertion that assesses the states of these objects through consecutive method accessor calls.
this strategy complements our extension which facilitates the automatic introduction of accessors.
nevertheless it is important to acknowledge that alternative methods such as incorporating functions like equals orhashcode could further enhance class observability.
a significant advantage of employing recursive inspector assertions is their ability to simplify the debugging process if a test fails the problematic attribute with an unexpected value is easily identified.
our results show that recursive inspector assertions may be useful in certain cases where the effects of artificially injected mutants have side effects on composed objects.
we also observed that the use of these assertions did not lead to a noticeable variation in performance e.g.
test generation time .
however further work is needed to evaluate the potential of recursive inspector assertions particularly with real bugs and a wider range of classes.
this could help identify the cases in which these types of assertions are most useful.
an alternative approach is to understand how manually created tests kill mutants similar to the ones that remain undetected and learn from them to create new strategies for generating assertions.
c. observability vs. propagation our experiments demonstrated that the observability of internal states has a significant effect on the effectiveness of generated unit tests but we also found that this is not simply due to a lack of the ability to assert on complex object states.
besides guiding developers in improving the observability of their code and revisiting assertion generation techniques there is an orthogonal aspect to consider the process of howfaults lead to software failures has been studied intensively.
in particular the rip model describes that faults need to be reached i.e.
executed cause a state infection which then needs to propagate to an observable output the pie model execution infection and propagation describes the same process.
a recent extension of the rip model includes a final requirement revealability .
our investigation of assertion generation targets this last step of revealability .
we based our experiments on the common practice of automatically generating unit tests for code coverage therein lies a potential problem related to observability optimizing tests for code coverage only ensures that reachability is satisfied but whether or not infection happens is coincidental and generated tests may require further calls to ensure propagation of infected internal states to allow generating adequate assertions.
consequently it will be important for future work to also consider optimization goals for test generation that go beyond code coverage .
we did not find a clear relation between code coverage and the improvement in mutation score in any of our experiments.
in the first treatment the average coverage achieved by the classes with mutation coverage improvement ranges between .
and where only classes had an average coverage and only classes exceeded coverage.
however classes such as sacpluginactivator andjoomlaoutput report a high mutation score increase reaching .
and .
average coverage respectively.
in contrast classes with an average coverage had a mutation score improvement .
in the second treatment all the classes with significative increase had an average coverage with similar mutation score improvement.
finally the third treatment presented similar results as the first one without directly relating the coverage with the improvement in mutation score.
d. assertion minimization the recursive inspector assertion strategy may lead to a large number of assertions for each composed object and even more for each generated test.
furthermore it may introduce indirect testing a well known test smell as these assertions may end up testing methods that do not belong to the class under test.
in such cases the evosuite mutation based assertion minimization algorithm plays an important role by reducing the number of generated assertions using mutation analysis retaining only those directly related to a mutant.
consequently the remaining assertions are considered useful for detecting mutants injected into the class under test.
however as previous studies have shown evosuite generated tests even without our extensions may contain indirect testing smells among other types of test smells .
therefore further research is needed to assess whether recursive assertions or increased observability might decrease the quality of the generated tests particularly by increasing the number of test smells present in the generated code.vii.
r elated work controllability and observability are widely studied factors in research on testability.
controllability involves the ease with which testers can manipulate state and input to achieve specific test conditions and control execution flow.
on the other hand observability involves the ability to observe and verify the outputs and behaviors of the unit under test.
this section summarizes related work aimed at improving testability.
diverse approaches have been proposed to improve the testability of the code under test.
a common method involves performing automatic transformations on the program components to enhance their testability.
these transformations target various source code patterns that are known to affect testability and reduce the effectiveness of test generator tools.
for instance they address boolean flags that may be present in conditionals or loops as well as nested conditionals and unstructured control flows .
additionally these transformations can also be performed at the bytecode level .
refactorings can significantly enhance the testability of program components.
previous studies indicate that class design and code quality impact testability.
cinn ide et al.
used a search based refactoring tool to perform various refactorings on the class under test.
practitioners developed tests before and after refactoring suggesting improved testability though the results were not definitive.
reich et al.
analyzed pull requests aimed at improving testability identifying ten beneficial refactoring patterns.
common patterns included method extraction for overriding or invocation widening method access and class extraction for invocation.
improving observability is another method to enhance testability.
several studies focus on tracking execution to inject assertions for checking constraints pre post conditions or class invariants .
for instance kansomkeat et al.
proposed injecting observability probes to track variable states and insert assertions to verify them.
mao uses aspectoriented programming aop to verify component invariants by introducing a tracing aspect to gather preconditions of method executions aiding in regression testing.
schuler and zeller use dynamic slicing to determine checked coverage the statements with an actual contribution to the test oracles .
finally zhu et al.
proposed code observability metrics with a strong correlation with the mutation score .
in contrast to previous work our study evaluates the impact of observability on test generation algorithms.
we conducted an experiment that exposed encapsulated attributes and enabled state assertions of complex objects.
our results show that improved observability significantly increases mutation scores.
this highlights the need for further research to understand how observability affects the effectiveness of test generation.
viii.
c onclusion this paper introduces two complementary evosuite extensions designed to enhance class observability by publiclyexposing all class attributes and enabling evosuite to assert the states of composite objects.
we implemented these extensions to evaluate their impact on test generation tools particularly evosuite.
our empirical study conducted using a well known set of complex java classes from the sf110 dataset demonstrated that increased observability through our extensions led to a significant improvement in the mutation score for generated tests for classes.
this underscores the importance of class observability in the test generation process.
in future work we plan to study the effects not only in a mutation testing scenario but also on real faults to explore heuristics to identify variables that significantly benefit from being accessed by generated tests as well as further improved assertion generation techniques.
we also aim to extend our study using other mutation engines e.g.
pit with varied mutation operators and study the mutants detected vs. the mutants reached by the test suite.
acknowledgment juan pablo sandoval alcocer thanks anid fondecyt iniciaci n folio for supporting this research.
we also thank the programa de inserci n acad mica vicerrector a acad mica y prorrector a at the pontificia universidad cat lica de chile.