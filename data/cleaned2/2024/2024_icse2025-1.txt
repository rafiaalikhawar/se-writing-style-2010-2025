pacdroid a pointer analysis centric framework for security vulnerabilities in android apps menglong chen tian tan minxue pan yue li state key laboratory for novel software technology nanjing university china smail.nju.edu.cn tiantan mxp yueli nju.edu.cn abstract general frameworks such as flowdroid iccta p taint amandroid and droidsafe have significantly advanced the development of static analysis tools for android security by providing fundamental facilities for them.
however while these frameworks have been instrumental in fostering progress they often operate with inherent inefficiencies such as redundant computations reliance on separate tools and unnecessary complexity which are rarely scrutinized by the analysis tools that depend on them.
this paper introduces pacdroid a new static analysis framework for detecting security vulnerabilities in android apps.
pacdroid employs a simple yet effective pointeranalysis centric approach that naturally manages alias information interprocedural value propagation and all android features it supports including icc lifecycles and miscs in a unified manner.
our extensive evaluation reveals that pacdroid not only outperforms state of the art frameworks in achieving a superior trade off between soundness and precision f measure but also surpasses them in both analysis speed and robustness moreover pacdroid successfully identifies real security vulnerability flows across real world android apps that were missed by all other frameworks.
with its ease of extension and provision of essential facilities pacdroid is expected to serve as a foundational framework for various future analysis applications for android.
i. i ntroduction android launched over a decade ago has evolved into one of the most widely adopted operating systems globally.
as of now billions of people use smartphones worldwide with .
of these users running the android os .
this vast user base highlights the importance of maintaining the security of the apps available on this platform.
however the lack of thorough verification of android apps has led to numerous security issues including data leaks and various vulnerabilities .
to enhance android security static analysis has proven to be a valuable method by detecting potential vulnerabilities before they can be exploited .
to enable effective static security analysis it is essential to provide a set of fundamental facilities tailored to the android ecosystem.
representative frameworks in this domain include flowdroid iccta p taint amandroid and droidsafe which address critical android features such as lifecycle management entry points callbacks layouts etc.
inter component communication icc and android specific data structures intents bundles shared preferences etc.
.
these few general frameworks have greatly fostered the development of numerous effective android security tools by corresponding authors.providing essential facilities for android static analysis however these security tools often focus on utilizing the functionalities provided by the frameworks without questioning their design rationale.
despite their success these popular frameworks possess potential design flaws.
for instances iccta and droidsafe rely on separate tools like ic3 and jsa respectively to resolve intents and other potential features beforehand.
this reliance not only introduces extra time but also ties the framework s reliability to these preanalysis tools.
flowdroid and iccta reanalyze the program after each iteration of detecting new callbacks to extend the call graph until no new edges are added.
this approach results in redundant computations and can slow down the analysis.
frameworks like p taint and flowdroid itself adopt a highly conservative approach when constructing icc taint flows leading to imprecise results while amandroid employs multiple types of graphs such as icfg dfg and ddg increasing the overall complexity of the analysis.
in this work we aim to achieve the following goals through a simple yet effective approach a to overcome the issues of existing frameworks mentioned earlier by offering a faster analysis with better trade off between precision and soundness a more sound analysis means resolving more real program behaviors b to build comprehensive value flows needed for taint analysis in android.
this requires handling alias information interprocedural value propagation and all android features such as icc lifecycles and miscs in a unified manner.
we thus present pacdroid where we propose to analyze all android features utilizing a pointer analysis centric pac approach first demonstrating that all such features can be effectively analyzed through pointer analysis and built upon the plugin system of tai e a state of the art static analysis framework which offers an effective pointer analysis system for pure java without any support for android analysis.
in pac each android feature handling is treated as a plugin that interacts with the pac engine centered on pointer analysis via several straightforward interfaces.
all android feature handlers along with alias computation and interprocedural value flow operate on and propagate along the same graph the pointer flow graph pfg which underpins the taint analysis.
the pac approach eliminates the need to reanalyze the program after each iteration since the call graph and all features are resolved on the fly.
it also removes the need for separate tools as all features are handled and values are propagated by the pointer analysis.
such unified approach ieee acm 47th international conference on software engineering icse .
ieee several benefits when a new android feature is added it can be easily integrated as a new plugin that cooperates with the pointer analysis.
improvements in the resolution of any feature making it more sound or precise will be propagated to other feature handlings via pointer analysis while the enhancements to the pointer analysis will also automatically benefit all feature handlings.
the simple design philosophy of pac will ease both implementation and extensibility.
to thoroughly evaluate pacdroid we compared it with stateof the art general android analysis frameworks flowdroid iccta p taint and amandroid.
given that the latest version of flowdroid has integrated iccta for analyzing icc and iccta relies on flowdroid as its foundation with iccta now maintained by flowdroid we refer to their combination as flowiccta throughout this paper.
droidsafe is excluded from the evaluation as it does not support android versions higher than the latest version is and it fails to analyze all the programs in icc bench and has thus also been omitted from recent works .
our evaluation utilized an extensive set of benchmarks including droidbench iccbench and the recent ubcbench with additional features incorporated.
experimental results show that pacdroid outperforms the other frameworks in terms of f measure a higher f measure value indicates a better trade off between soundness and precision analysis speed and robustness analysis crash rate .
specifically pacdroid achieved an f measure of compared to for flowiccta for p taint and for amandroid.
it is also .6x .8x and .4x faster than flowiccta p taint and amandroid respectively and has the lowest crash rate of compared to for flowiccta for p taint and for amandroid.
moreover out of real taint flows across real world android apps pacdroid successfully detected taint flows compared to for flowiccta for p taint and for amandroid notably pacdroid detected real taint flows across apps that were missed by all other frameworks demonstrating its superior capability in detecting vulnerabilities in the real world.
in summary this work makes the following contributions.
we introduce pacdroid a new static analysis framework for detecting security vulnerabilities in android apps.
pacdroid employs a principled pointer analysis centric pac approach to handle various android features in a unified manner which enables pacdroid to incorporate distinctive designs for android feature handling such as integrated icc and intent analysis.
we conduct a comprehensive evaluation showing that pacdroid not only outperforms state of the art frameworks in achieving a superior soundness precision tradeoffs f measure but also surpasses them in both analysis speed and robustness.
moreover pacdroid successfully detects real vulnerability flows across real world android apps where all other frameworks fail.
we offer a fully open source implementation of pacdroid and an artifact to reproduce all the experimental results at security team of a fortune global software company has developed android vulnerability analyses based on pacdroid implemented as handlers of pacdroid .
these analyses have been integrated into the company s regular devsecops security scans.
over the past two months to android apps are analyzed daily identifying over potential vulnerabilities on average each day.
this further demonstrates pacdroid s potential in real world android security analysis.
ii.
a m otivating example inter component communication icc is a critical feature in android with intents serving as the medium for communication among components.
figure depicts a simplified real code involving explicit and implicit intents in icc.
in this section we use this example to illustrate the benefits of pacdroid s pointer analysis centric pac approach in effectively integrating icc and intent analysis and how it addresses complexities that previous frameworks fail short of handling.
first let s understand this example.
it involves three components two activities line and line and a receiver line .
in line an explicit intent object o1 pointed to by i1 is created with its target component explicitly specified as activity2.class .
this means the target component sent by calling startactivity i1 in line isactivity2 and the intent received by getintent in line pointed to by r1 iso1.
in line an implicit intent object o2is created with its target component implicitly specified by the string value of its constructor s argument action .
the value of action is retrieved in line and stored in line through the map like extra information of intent o1 which is xxx.action .
to determine the target component of o2sent by sendbroadcast i2 line android uses the xxx.action value to match the component in the androidmanifest.xml file which is receiver1 in this case line .
as a result intent o2should be passed to r2in line forming an icc flow from i2in line to r2in line and making i2in line an alias of r2in line .
this establishes a taint flow from line to line through the icc flow between components activity2 andreceiver1 .
a previous work previous frameworks like flowiccta amandroid and droidsafe handle features like icc and intents separately and cannot resolve the icc flow in figure .
take flowiccta as an example.
before applying icc analysis it uses a separate intent resolution tool called ic3 to resolve intent related string values.
in figure ic3 correctly resolves that the target component of intent o1in line is activity2 and identifies the extra information of o1in line .
however it fails to resolve the string value of action in line because it does not know what r1 line points to at that moment as icc analysis has not yet been applied.
consequently it cannot resolve the target component of the implicit intent o2in line .
this leads to missing the icc flow from i2in line to r2in line and thus the taint flow from line to .
on the other hand p taint like the original flowdroid handles icc conservatively by treating any getintent e.g.
the one in line as a source and any startactivity class activity2 extends activity protected void oncreate bundle b ... intent r1 getintent string action r1.getstringextra act if action !
null string s source source so intent i2 new intent action o2 i2.putextra tainted s sendbroadcast i2 ... class receiver1 extends broadcastreceiver public void onreceive context c intent r2 string tainted r2.getstringextra tainted sink tainted sink update r1 s pts with o1 i.e.
let r1 point to o1 based on the icc relation between activity1 and activity2 resolved in obtain r1 s pts i.e.
o1 thanks to the pts update in resolve action s value based on intent o1 s extra info resolved in and update action s pts with xxx.action as a string constant object obtain i2 s pts i.e.
o2 and action s pts i.e.
xxx.action resolve o2 s intent info as o2 xxx.action obtain i2 s pts i.e.
o2 and s s pts i.e.
source object so resolve intent o2 s extra info as o2 tainted so obtain i2 s pts i.e.
o2 determine the target component of activity2 is receiver1 based on o2 s intent info xxx.action resolved in along with the info in lines and update r2 s pts with o2 i.e.
let r2 point to o2 based on the icc relation between activity2 and receiver1 resolved in obtain r2 s pts i.e.
o2 resolve tainted s value based on intent o2 s extra info resolved in and update tainted s pts with the source object so1 1class activity1 extends activity 2protected void oncreate bundle b ... intent i1 new intent this activity2.
class o1 i1.putextra act xxx.action startactivity i1 10intentinfo analysissendicc analysisintentextra analysis engineupdate notify write read androidmanifest.xml receiver android name receiver1 intent filter action android name xxx.action intent filter receiver obtain i1 s points to set pts i.e.
o1 resolve o1 s intent info as o1 activity2.class means o1 s target component is activity2 obtain i1 s pts i.e.
o1 resolve intent o1 s extra info as o1 act xxx.action extra info serves like a map like field of intent object obtain i1 s pts i.e.
o1 determine the target component of activity1 is activity2 based on o1 s intent info resolved in 1fig.
.
a simplified real code illustrating integrated icc and intent analysis in pointer analysis centric approach pac e.g.
the one in line as a sink without resolving the intent information which can result in many false icc flows.
b our work pacdroid adopts a pointer analysis centric approach pac to manage various android features in a unified manner.
in pac each feature handler obtains points to set information for any variable via the pac engine and reflects the side effects of feature handling by updating the points to set of related variables.
consequently the side effects of one feature handler are propagated by pointer analysis meaning any side effect of any feature handler can be notified by the engine to all other feature handlers through the wholeprogram points to information.
now we invite readers to follow the ten self explanatory steps in figure to grasp the workings of pac and understand how pacdroid detects the taint flow from lines to by resolving the icc flow from lines to .
for the case of figure the pac approach involves three analyses intentinfo intentextra and sendicc all interacting with the pac engine which manages the whole program points to information.
to facilitate understanding these ten steps we illustrate step 1 here with readers encouraged to follow the subsequent nine steps similarly.
step 1 highlighted in yellow is part of the intentinfo analysis and corresponds to handling the statement in line as identified by the step number.
from a java semantics perspective this is a typical new statement so the pointer analysis will create an object o1of type intent invoke its constructor with two arguments and let i1point to o1.
consequently intentinfo analysis can directly obtain the points to set information of i1 i.e.
which objects i1points to from the engine.
the yellow arrow on theright side of the step rectangle signifies obtaining points to information from the engine.
note that the engine actually proactively notifies the points to information whenever related variables are updated which we will explain in section iii.
for now you can consider it a read operation from the engine for simplicity.
according to the semantics of intent s constructor with a meta class object activity.class as the second argument line intentinfo analysis can resolve that the target component of intent object o1isactivity2 and record it as o1 activity2.class for future use.
this result is a global intermediate analysis result accessible by any feature handler.
since it does not modify the pointsto set of any variable no update operation to the engine is required unlike the blue arrow in step 4 .
after understanding these ten steps we now provide key summarizations to enhance comprehension.
in this case intentinfo analysis relies on intentextra analysis to resolve the target component e.g.
intent o2in line needs to resolve action whose value is extra information from another intent o1 .
intentextra analysis further depends on sendicc analysis to identify which intent objects the extra information belongs to e.g.
the intent object pointed to by r1in line should be resolved first by sendicc analysis before identifying the xxx.action value of the key act stored in line .
this interdependence of feature handling is managed by pac which enables on the fly resolution of all feature handlers in conjunction with pointer analysis in a decoupled manner.
pac naturally resolves scenarios involving multiple features fundamentally differing from existing frameworks where feature handling is separate as previously described.
2805iii.
d esign of pacdroid first we present an overview of pacdroid detailing its basic components including the pac engine and various android feature handlers and outlining the high level idea of how the pac approach enables them to work collaboratively.
subsequently we delve into the detailed pac approach providing an explanation of the pac engine algorithm and a template for the android feature handlers algorithms.
a. overview of pacdroid pacdroid contains two key parts the pac engine and various android feature handlers that interact with it figure .
a the pac engine it is based on the plugin system of tai e a state of the art static analysis framework for java that does not support android analysis at all.
the core of the pac engine is a whole program pointer analysis that maintains the points to information of all variables in a program by manipulating the traditional pointer flow graph pfg details on pfg are omitted as they are not essential for understanding pacdroid .
as shown in figure the pac engine acts as a delegation agent providing facilities that enable feature handlers to read and write whole program points to information expressed in pfg in a decoupled manner.
this design allows handlers to remain independent of the complex pointer analysis algorithm.
any changes to a variable s points to set in a handler are notified to all other handlers by the engine and any side effects from handlers on variables are updated through the engine to the wholeprogram points to information the detailed algorithms will be explained in section iii b .
consequently the effects of each handler reinforce one another as illustrated in the case of figure .
moreover any improvements in handler or pointer analysis e.g.
precision will benefit all handlers.
pacdroid supports four categories of android feature handlers as shown in figure icc lifecycle misc and other feature analyses.
below is a brief introduction to each category.
b icc analysis a simple usage scenario of sendicc and intentinfo analyses has been presented in section ii.
the replyicc analysis complements the sendicc analysis while the message analysis handles another communication scheme among various components and the service component.
the message analysis is more complex than intent analysis as it relies on the results of the latter.
unlike existing frameworks that handle features like intents and icc separately our pac approach integrates them into one.
as shown in section ii pacdroid handles complex implicit intents to further resolve implicit icc by using several handlers the intentextra handler in misc analysis to parse extra information from intent objects the intentinfo handler to process the strings used in implicit icc and the sendicc handler to match these strings with configuration items in the androidmanifest.xml to identify target components and resolve the data flows of implicit intents.
in contrast frameworks like flowiccta droidsafe and amandroid resolve these features including the implicit data flows of intents and icc separately making it difficult to leverage one feature analysis to on the fly improve whole programpoints toinformation read write lifecycle analysiscallback analysis entrypoint analysis callback analysis dyregister analysis layout analysis misc analysiscallback analysis intentextra analysis sharedpref analysis asynctask analysis othermisc analysiscallback analysis intentinfo analysiscallback analysis message analysiscallback analysis sendicc analysiscallback analysis replyicc analysis icc analysis callback analysis reflection analysiscallback analysis lambda analysiscallback analysis native code analysiscallback analysis android x feature analysis other feature analysesthe update notifypace g nn i e fig.
.
overview of pacdroid.
another as explained in section ii.
specifically flowiccta and droidsafe first use ic3 and jsa to preprocess the strings involved in icc and then use the results to apply icc analysis in later stages which cannot handle implicit icc cases like those in figure .
similarly amandroid also fails to handle such cases effectively.
it first preprocesses icc related strings then extract the strings to resolve icc using data flow analysis.
when icc cannot be resolved it conservatively matches all other components like what p taint does as described in section ii leading to many false icc flows.
c lifecycle analysis it adds to the analysis the methods that are registered by calling android s apis in the code or configured in files.
specifically entrypoint analysis resolves and adds the event methods of android components specified inandroidmanifest.xml while layout analysis identifies and incorporates the callback methods for activity components configured in layout.xml .
callback analysis resolves callback methods e.g.
onclick registered in the code e.g.
through a system call setonclicklistener c and incorporates callback methods into the analysis.
to handle callbacks frameworks like flowiccta and amandroid create a dummy main method as the analysis entry.
when they resolve a callback method cbm they add cbm tomain and reanalyze the program starting from main to exploit more reachable callback methods possibly invoked from cbm.
this process repeats until no new call graph edges are added.
to avoid the redundant computations caused by reanalyzing a program constrained by the dummy main strategy pacdroid adopts an on the fly scheme for callback analysis enabled by pac whenever a new callback method is resolved it is added to the set of methods to analyze.
the pac engine s pointer analysis solver then treats this callback method like any other newly reachable method found after resolving a normal callsite thereby avoiding a full program reanalysis.
2806d misc analysis it encompasses a set of android analyses that are important but not included in the icc and lifecycle analyses.
for example we have seen the intentextra analysis in section ii.
sharedpref analysis resolves another crucial data structure in android which involves two nested maps with value dependency inside making it more complex than intentextra.
asynctask analysis resolves asynchronous methods invoked from android apps and adds them to the set of reachable methods to analyze.
othermisc analysis includes the analyses to address or partially address other android features like webview textview hint and handler.
e other feature analyses as android apps are encoded in java to deliver an effective analysis we must also handle java features that may affect the analysis such as reflection lambda expressions and native code.
the handling of these features in pacdroid is similar to p taint which offers more advanced analyses for certain features than other frameworks.
thanks to the pac approach we can also integrate these java feature analyses as feature handlers like other analyses in pacdroid as shown in figure .
the android x feature analysis shown in the figure indicates that any new feature introduced by android in the future can be addressed as an additional handler of pacdroid.
note that pacdroid currently does not support implicit control flow analysis which involves correlating path conditions.
this decision is based on king s study which found that such analysis can significantly overwhelm the results with many false positives .
b. the pointer analysis centric pac approach we detail the two algorithms underpinning the pac approach.
specifically algorithm outlines the operation of the pac engine which builds upon the plugin system of tai e but includes enhancements by pacdroid for android analysis.
algorithm shows the core template for pacdroid s android feature handlers outlining how each handler functions and interacts with the engine.
currently all android feature handlers of pacdroid were developed following this template.
for conciseness algorithm shows the core of the pac engine excluding the pointer analysis handling which is relatively standard .
it is assumed that pointer analysis runs on the fly within the current engine processing each normal statement such as new assign load and store updating the related points to sets for the involved variables and adding them to the worklist.
the key structure of the algorithm comprises two nested while loops as shown from lines to .
the outer loop and the o nphase finish call in line introduced by pacdroid are designed to optimize specific android analyses which will be explained later.
now let us examine these two algorithms.
functions o nstart and o nfinish called in lines and of algorithm and defined in lines and of algorithm manage the steps before and after a feature analysis implemented by its handler registered in pacdroid.
specifically o nstart adds the entry point specifying the methods of the app where the analysis begins to the set of methods to analyze by calling addnewmethod .
o nfinish reports analysis results.algorithm pac engine 1worklist handlers registered handlers 2allhandlers .onstart 3while worklist is not empty do while worklist is not empty do p newpts worklist .pop process call p newpts handlers .onnewpoints toset p newpts handlers .onphase finish 9handlers .onfinish 10process call p newpts foreach callsite c p.m ... do callee resolve call c newpts add newmethod callee handlers .onnewmethod callee 15add points to p newpts worklist worklist p newpts algorithm pac handler for android feature x 1initialize resolvedinfos androidvars 2onstart entrypoints components in androidmanifest.xml foreach entrypoint entrypoints do add newmethod entrypoint 6onnewmethod callee foreach callsite c r p.m a ... in callee do ifc is related to android feature x then androidvars androidvars r p a1... 10onnewpoints toset p newpts ifp androidvars then resolvedinfo v1 newpts ... resolve feature x p newpts foreach v newpts v1 newpts ... do add points to v newpts resolvedinfos resolvedinfos resolvedinfo 16onphase finish v1 pts ... delayed resolve feature x foreach v pts v1 pts ... do add points to v pts 20onfinish report analysis result if the popped variable p and its points to set newpts line serves as the receiver variable of a callsite c line the target callee ofcwill be resolved according to the objects pointed to by p by calling r esolve call line and then adds the callee to the set of methods to analyze line .
then the newly added method will be notified to all handlers by calling o nnewmethod line .
now let us look into o nnewmethod defined in line of algorithm .
2807from the perspective of a handler for android feature x e.g.
icc intentinfo and others as in figure whenever a method callee is added it checks whether a callsite cwithin callee is related to x and adds the involved variables of cinto the set of x related variables androidvars line maintained as a kind of global variable among all handlers line .
now we can move to line of algorithm which calls onnewpoints toset p newpts to notify all handlers that the points to set of variable phas possibly changed.
all feature handlers should be aware of such changes to perform any necessary actions affected by the new points to set as defined in line of algorithm .
let us take an example to illustrate this function.
assuming that feature x is intentinfo and pin line refers to i1in line of figure then pis an android related variable.
so the method resolve feature intent info is called in line of the algorithm to handle the new intent statement in line of figure and resolve the intent information.
in this case o1 activity2.class is returned as the resolvedinfo in line of the algorithm indicating that intent o1 s target component is activity2 which can then be used by other handlers.
for another example let x be sendicc corresponding to the case in line of figure .
here pin line of the algorithm represents the hidden this variable invoking getintent .
the analysis then searches through the previously resolved information resolvedinfos to identify which intent object s target component matches this s type i.e.
activity2 .
as a result intent o1is identified and the points to information for r1in line of figure is added accordingly.
this operation is reflected in line of the algorithm where v1 newpts corresponds to r1 o1 .
then r1 o1 is updated in the pac engine by calling addpoints to see line of algorithm .
as shown in line of algorithm a ddpoints toadds r1 o1 to the worklist which further triggers the while loop in line to continue processing.
the pac engine incorporates an additional outer loop lines to beyond the typical worklist algorithm loop lines to .
this extra layer serves as an optimization for android analysis.
when analyzing certain android features like intent extras and sharedpreferences there are often numerous store and load operations associated with key structures that influence app behaviors.
for instance consider the methods putextra key val andgetstringextra key in figure which we abbreviate as put k v andget k .
as the worklist s pop order is often unpredictable we cannot guarantee that all get k callsites are handled after their corresponding put k v callsites.
thus for soundness the single layer worklist algorithm needs to check all get k instances whenever a put k v callsite is processed including previously handled get k callsites that may not have found a matching put k v at the time.
the complexity increases with the presence of multiple points to objects associated with kand the receiver variables of put k v andget k .
the two layer loop approach addresses this by delaying the propagation of handling put k v and the resolutionofr get k .
specifically it defers the propagation of objects from vtoruntil most put k v callsites have been resolved but not yet propagated before handling the majority ofget k callsites.
this strategy offers two main advantages it removes the need to search for get k during each put k v callsite and enables consolidated propagation for anyget k all corresponding put k v1 put k v2 etc.
can be identified and the objects pointed to by v1 v2 and others can be propagated to rin a single efficient operation reducing the original separate propagation cost.
now we can understand the two layer loops of algorithm with the above example.
after the inner loop from lines to a fixpoint is reached meaning all statements have been resolved and the points to sets of variables have been propagated and updated except for any unresolved get k callsites and resolved put k v callsites that have not yet been propagated.
this means that by the end of the inner loop there is a high likelihood that all put k v are resolved and all corresponding put k v values are available when handling a get k .
the o nphase finish function called in line of algorithm and defined in line of algorithm performs the delayed resolution of all get k callsites and the propagation of all corresponding put k v values by invoking d elayed resolve feature x line .
in our example this results in a set of pairs like r o where o is pointed to by v being added to the worklist by calling addpoints to in line .
consequently the worklist is not empty and the outer loop in line of algorithm continues to propagate the effects of updating r o in the pac engine potentially influencing other handlers.
we conducted experiments on a set of real world android apps collected in rq2 of section iv c .
this two layer worklist optimization shows negligible advantage for simple apps.
however it notably accelerates the original one layer worklist algorithm for complex apps e.g.
those taking over seconds achieving an average speedup of .2x with the largest average speedup for three apps being .3x.
iv.
e valuation in this section we investigate the following research questions to evaluate pacdroid s effectiveness.
rq1 how does pacdroid perform compared to other state of the art frameworks in terms of the trade off between soundness and precision?
rq2 is pacdroid robust analysis crash rate and fast analysis speed in analyzing real world android apps?
rq3 can pacdroid successfully detect real vulnerabilities in real world android apps?
a. experimental settings all experiments were conducted on an intel r xeon r e2488 .2ghz machine with 20gb of memory.
a state of the art frameworks as pacdroid is a general static analysis framework that offers fundamental facilities for building taint analysis for android apps we consider wellrecognized comparative frameworks including flowdroid 2808table i summary of benchmark results .
these benchmarks consist of different suites each containing multiple test apps and each test app may include zero or more malicious flows .
w e categorize the results as follows a correctly identified malicious flow is a true positive tp an incorrectly identified flow is a false positive fp and a missed malicious flow is a false negative fn .
suitemalicious flowsflowiccta p taint amandroid pacdroid tp fp fn tp fp fn tp fp fn tp fp fn alias androidspecific arraysandlists callbacks emulator fieldandobject generaljava iac icc lifecycle reflection threading unreachablecode ubcbench sum recall and precision sum recall r tp tp fn precision p tp tp fp f measure 2rp r p iccta p taint and amandroid.
droidsafe is excluded as it does not support android versions higher than the latest version is and it fails to analyze all programs in iccbench and has thus also been omitted from works .
for all the compared frameworks we use their latest stable versions.
b benchmarks to thoroughly evaluate the capabilities of various frameworks we consider droidbench and iccbench commonly used in existing literature .
we use their latest versions to benefit from the additional android features they support.
besides we include the recently developed ubcbench version which covers a broader range of usage scenarios for android features.
we also incorporate eight cases involving icc features or their practically adopted combinations that may lead to leaks which are missed by the above benchmarks.
note that thirty out of malicious flows involving hard features such as dynamic class loading which no frameworks can handle or aspects like implicit flows that most frameworks do not address due to their focus on explicit flow analysis have been excluded.
b. rq1 soundness and precision trade off the f measure calculated as the harmonic mean of recall and precision effectively balances soundness and precision into a single value.
it is commonly used as the primary metric to evaluate the soundness precision trade off in the literature on static analysis for android .
table i details the results of different frameworks on the benchmarks given in section iv a. overall pacdroid achieves an f measure of surpassing all other frameworks with the next best flowiccta at .
below we delve into soundness and precision with soundness validated through a recall experiment.
a soundness recall a recall experiment measures the proportion of real malicious flows detected by a static analysis among all real flows higher recall values signify bettersoundness.
as shown in table i the recall of pacdroid reaches significantly outperforming all other frameworks with flowiccta at p taint at and amandroid at .
apart from the enhanced handling of certain android features the recall advantage of pacdroid primarily stems from its pac design.
as explained in section iii pac allows the analysis results of one feature to influence the resolution of another.
for example in an icc case from our benchmark communication among activity and service components involves more complex features including messages messengers and intents than those depicted in figure .
as pacdroid supports message analysis messenger analysis and intent analysis and incorporates their results into the icc analysis via pac it is able to detect taint flows through such complex icc scenarios where other frameworks fail.
a similar explanation applies to the sharedpreferences example from the lifecycle suite in our benchmark.
sharedpreferences is an important android structure that involves two nested maps with the outer map s value correlated with the inner map.
building the flow for sharedpreferences requires modeling both maps and tracking the value dependencies between them.
among all evaluated frameworks only pacdroid can build such flow in analysis as pacdroid s pac design allows the effects of all feature analyses including map modeling which involves string analysis to be automatically propagated via pointer analysis enabling it to identify taint flows through sharedpreferences effectively.
b precision soundness and precision often come at the cost of each other with more conservative handling improving soundness but potentially reducing precision.
we believe that pacdroid has made a better sweet spot between these two aspects for android analysis as evidenced by its highest fmeasure of compared to the next best flowiccta at .
in terms of precision alone pacdroid achieves a precision of which is slightly lower than flowiccta s but 2809table ii results of handling certain challenging features category flowsflowiccta p taint amandroid pacdroid tp fp fn tp fp fn tp fp fn tp fp fn implicit hybrid sharepref rpc significantly higher than p taint s and amandroid s .
the main reason why flowiccta is slightly more precise than pacdroid is that flowiccta is based on ifds making it inherently context and flow sensitive and unable to provide an insensitivity option.
in contrast pacdroid is context sensitive and partially flow sensitive utilizing flowinsensitivity with ssa form to enhance its flow sensitivity .
since pacdroid is based on pointer analysis it can choose context insensitivity as its default option balancing efficiency with its ability to achieve precision even in a context insensitive mode.
for a fair evaluation we ran pacdroid with its default context insensitive option throughout the evaluation.
however it is important to note that pacdroid s precision can be directly improved to surpass flowiccta simply by selecting any context sensitivity option available in tai e without requiring any changes to the approach.
despite this we must acknowledge that pacdroid cannot achieve the necessary precision for few cases where full flow sensitivity is needed.
to validate pacdroid s ability to handle challenging features compared to other frameworks we conduct an empirical study and the results are shown in table ii.
the study includes four categories implicit hybrid sharepref and rpc all of which involve implicit data flows in the sense that implicit and hybrid include various complex cases involving implicit intents iccs while the other categories address cases that cannot be resolved directly without first handling other features.
for example hybrid includes cases that require resolving explicit implicit and replied intents together to identify the final icc target.
rpc contains cases dealing with remote calls to service components which require resolving intents first followed by the ibinder features.
in summary pacdroid outperforms other frameworks in soundness with a recall of compared to flowiccta s p taint s and amandroid s .
in addition pacdroid exhibits excellent precision as flowiccta in this experiment consistent to the precision results of table i. c. rq2 analysis robustness and speed the benchmarks in rq1 cover a wide range of diverse usage cases for android apps examining each framework s basic capabilities in handling android features.
however these benchmarks are typically simple allowing all frameworks to analyze them without crashes and most complete the analysis within seconds.
to better assess the robustness and analysis speed we randomly selected real world apps from androzoo dated between and with an average about million bytecode instructions .
each framework was run under its default settings with three runs conducted to calculate average analysis time.
the analysis time was cappedtable iii average analysis time and rate of crash of each framework .
toolaverage analysis time s rate of crashnon intersect intersect flowicctaic3 .
n a flowiccta .
.
p taint .
.
amandroid .
.
pacdroid .
.
at minutes for all frameworks.
only p taint exceeded this limit for half of the apps with these instances recorded as minutes.
below we discuss the analysis robustness and speed in detail as summarized in table iii.
a analysis robustness as a practical tool the ability to analyze a real world app without crashes is a basic requirement indicating the tool s robustness.
since flowiccta requires the use of the separate tool ic3 for icc analysis its evaluation consists of two parts i.e.
ic3 and flowiccta .
in our evaluation pacdroid demonstrated the lowest crash rate at followed by amandroid and p taint with crash rates of and respectively.
flowiccta and ic3 exhibited significantly higher crash rates of and .
the crashes in pacdroid were primarily due to issues in parsing the apks specifically during the dex to ir transfer process as well as a memory overflow in one program.
amandroid s crashes also stemmed from apk parsing issues along with exceptions such as null pointer or array out of bounds errors and memory overflow.
p taint s crashes occurred when generating datalog fact files.
due to lack of maintenance the newest ic3 still relies on an outdated version of flowdroid to analyze strings inside android apps and replacing it with the new version of flowdroid causes ic3 to fail to compile.
because flowiccta relies on ic3 to resolve intents in advance its reliability heavily depends on the reliability of this separate tool which is not ideal in design.
flowiccta s crashes were mainly caused by memory overflow and many null pointer exceptions that occurred while building the call graph in its callback analysis.
b analysis speed different frameworks may crash on different real world apps.
to fairly examine the efficiency of each framework we had them analyze the same set of apps thatallframeworks could analyze without crashes and within the time limit referred to as the intersect group.
the nonintersect group includes apps that each framework could analyze successfully within the time limit.
since ic3 crashed in of the programs we excluded it when collecting the intersect group resulting in out of the apps being included.
table iii shows the average analysis times for these two groups.
pacdroid demonstrated superior performance in both the non intersect and intersect groups.
in the nonintersect group pacdroid is about .6x faster than flowiccta .4x faster than amandroid and .8x faster than p taint.
in the intersect group pacdroid is about .5x faster than flowiccta .5x faster than amandroid and .3x faster than p taint.
it is challenging to pinpoint all causes of inefficiency 2810but we can highlight some factors likely to slow down an analysis.
for example flowiccta reanalyzes the program after each iteration of detecting new callbacks to extend the call graph until no new edges are added resulting in redundant computations which are time consuming.
amandroid on the other hand constructs multiple graph structures e.g.
icfg dfg ddg summary table and employs algorithms based on them adding complexity that can increase analysis time.
p taint built on datalog has to generate a large number of datalog facts to execute with its efficiency heavily dependent on the opaque datalog engine which may make it much slower than other frameworks.
to further evaluate the scalability stress of pacdroid concerning app size we analyzed an additional large and complex apps from androzoo.
each app exceeds million bytecode instructions averaging .
million making them significantly larger than the previous dataset.
amandroid failed on apps with cases attributed to timeouts resulting in a scalability stress of .
million bytecode instructions.
scalability stress is calculated as the average size of the apps a framework cannot analyze scalably.
flowiccta failed on apps all due to memory shortages with a scalability stress of .
million.
however these results should be interpreted with caution as flowiccta often yields unreliable outcomes in this experiment by resolving very few call graph edges in many instances.
for example for three apps in the million range it completed analyses in just seconds but resolved only around call graph edges on average.
notably pacdroid does not exhibit these robustness issues and only failed to analyze apps mainly due to memory limitations with a scalability stress of .
million.
this larger app set exceeds p taint s scalability capabilities leading to failures in applications mostly due to timeouts so we do not compute its scalability stress.
while pacdroid shows better efficiency and robustness than other frameworks there is still room for scalability improvement.
considerable work has been done to optimize analysis efficiency such as using heap snapshots to enhance scalability .
we plan to explore further improvements in this area going forward.
d. rq3 real world vulnerability detection let s evaluate the ability of each framework to detect real vulnerabilities in real world android apps.
fortunately the recent works taintbench and ubcbench provide a collection of various real vulnerabilities found in real world apps.
we consider all apps from taintbench and out of apps from ubcbench that involve privacy information leakage.
the remaining apps in ubcbench are excluded because they focus on detecting login encryption scenarios and do not provide precise ground truth through taint flows.
in total we have labeled real taint flows across realworld apps.
note that this does not necessarily mean there are no other real taint flows in those apps the labeled ones are simply those verified by the studies .
consequently these labeled taint flows cannot serve as a definitive metric for assessing the precision of different frameworks in real world scenarios.
therefore in this section we focus solely on soundness specifically whether the frameworks can detect these real taint flows which is the most critical aspect of taint analysis.
as for frameworks we observed that the number of taint flows reported by amandroid varied across different runs on the same machine with the same app and under the same configuration settings.
this inconsistency has also been noted by other works .
thus to maintain fairness despite this bug in amandroid we consider the highest number of taint flows reported by amandroid from three runs for each app.
the results of pacdroid are highly promising as detailed in table iv where it successfully detects out of real taint flows.
this performance is significantly better than that of amandroid which detects flows flowiccta with flows and p taint with flows showcasing pacdroid s high potential in identifying real world vulnerabilities.
notably pacdroid detects taint flows that all other frameworks miss.
of the taint flows that pacdroid fails to detect only are detected by other frameworks while the remaining go undetected by any framework.
given the complexity and timeconsuming nature of enumerating reasons for a framework s success or failure in detecting real vulnerabilities in real world apps we discuss below some representative scenarios where pacdroid succeeds while others fail and where pacdroid fails but other frameworks partially detect.
for the former two factors may contribute to pacdroid s better performance.
first pacdroid s pac approach uniformly handles various android features and their complex combinations enhanced by the propagation of pointer analysis.
for instance the program chulia involves four taint flows with complex feature combinations including lifecycle icc intent extras collections appendtostring and others.
pacdroid effectively manages these combinations and identifies all taint flows in this scenario whereas other frameworks fail to detect them all.
second pacdroid supports some more android features than others.
for example the taint flow in program xbot involves the webview feature of android which pacdroid partially supports while other frameworks do not.
before discussing why pacdroid fails to detect some taint flows that other frameworks can we first provide some background.
each framework including pacdroid models important methods in the java jdk and android standard library android.jar to enhance analysis effectiveness.
however in addition to the standard library frameworks like amandroid handle other library methods conservatively.
for instance they assume the values of a specified library method s parameters will flow to all its fields such as f and further to the fields of f. similarly flowiccta adopts conservative handling in the opposite direction.
for example for a store operation o.f g ifgis tainted not only will o.f be tainted but owill also be tainted with the nesting level of flow expansion limited to a predefined number such as five.
in contrast pacdroid does not apply such expansions to maintain precision relying instead on real flow based on statements or apis semantics to propagate values.
this approach while precise may cause pacdroid to miss some taint flows.
for example in the 2811table iv number of real taint flows detected by each framework in real world android apps .
crash analysis terminated with exceptions .
timeout analysis didn t finish within .
hours .
app name exp.flows flowiccta p taint amandroid pacdroid flashlight crash timeout phonemonitor win7imulator crash win7launcher flappybird crash hzpermispro crash backflash beita crash cajino chat chulia death crash dsencrypt exprespam fakeappstore fakebank fakedaum fakemart fakeplay faketaobao godwon hummingbad jollyserv overlay crash overlay2 phospy proxy remote crash repane roidsec samsapo save crash scipiex slocker sms google sms send smssend smssilience crash smsstealer stels tetus the threatjapan vibleaker crash xbot sum program cajino flowiccta and amandroid detect out of taint flows each sinking to calls of putobject in the com.baidu package while pacdroid misses these flows due to its lack of conservative modeling.
note that flowiccta can resolve intents on its own though it can be further enhanced by ic3.
due to ic3 s exceptionally high crash rate shown in table iii we ran flowiccta independently to analyze real world apps.
however as shown in table iv flowiccta still exhibited a relatively high crash rate compared to other frameworks consistent with the results in table iii.
additionally as previously mentioned amandroid reports different results for the same real world app under identical settings in different runs.
these phenomena underscore the need for reliable research tools in practice.
e. discussion based on the experimental results pacdroid exhibits notable advantages over established and widely used frameworks including flowiccta p taint and amandroid both in extensive benchmarks and real world applications.
this highlights pacdroid s potential as a promising research tool with capabilities for identifying real taint flows in practical scenarios.
nevertheless as a framework aimed at more comprehensive android application analyses pacdroid still has room for further improvement.
firstly there are challenging or emerging android features such as dynamic class loading jetpack compose and webview which are either not yet supported or inadequately addressed by pacdroid.
fortunately pacdroid s pac method facilitates the flexible addition or enhancement of these features through plugin handlers allowing for extensibility.
secondly recent research suggests that integrating large language models llms could enhance security issue detection .
given that pacdroid s pac approach organizes its handling of android features in a modular fashion certain features can be further decomposed or recombined into new handlers.
this approach may facilitate fine tuning interactions with llms to possibly generate more effective prompts.
lastly pacdroid is inherently a versatile static analysis framework.
its pac approach enables taint analysis implemented as a handler to collaborate with android feature handlers and pointer analysis.
this design not only supports the current security analysis but also paves the way for future extensions.
by developing new pac handlers pacdroid can be adapted to perform other client analyses of android apps such as bug detection and program comprehension .
v. r elated work we review related works in the following three categories.
a static analysis frameworks for android we have discussed various static analysis frameworks for android throughout the paper including flowdroid iccta p taint amandroid and droidsafe.
below we clarify the key differences between frameworks that use pointer analysis i.e.
p taint and droidsafe to underscore pacdroid s advantages.
unlike pacdroid which uniformly resolves all android features through pointer analysis and successfully demonstrates its feasibility p taint either omits handling certain android features e.g.
sharedpreferences or uses non pointer analysis approaches to resolve them e.g.
conservative icc resolution resulting in worse soundness and precision than pacdroid.
moreover as p taint is declarative and built using datalog optimizing feature analysis in p taint is hard because it utilizes an opaque datalog engine to interpret rules lacking the capability to manipulate specific data structures and execution strategies .
this makes it significant slower than pacdroid.
as for droidsafe it only partially employs pointer analysis for feature handling.
like flowiccta and amandroid droidsafe relies on a separate tool for extracting strings before resolving critical android features such as intents and icc.
as illustrated in sections ii and iv this design not only incurs extra time but also ties the framework s reliability to these pre analysis tools.
moreover droidsafe lacks pacdroid s capability to leverage results from one feature analysis to 2812enhance another for resolving more program behaviors as droidsafe does not handle all features under the same on thefly pointer analysis algorithm as pacdroid.
additionally unlike pacdroid which uses pointer analysis for modeling critical library methods droidsafe simplifies these methods by manually rewriting their internal code.
finally none of these frameworks like pacdroid presents the pac approach to showcase how to imperatively and cohesively utilize pointer analysis to manage various android features uniformly achieving both extensibility and performance.
chex employs an app splitting approach to model the execution of multiple entry points facilitating global data flow analysis.
but it focuses solely on the analysis of android entry points and does not support more complex android features.
horndroid utilizes horn clause based static analysis for android applications but it complicates the process by needing security attributes to be converted into horn clauses.
the framework only addresses apps with activities and handles icc solely for explicit intents.
some frameworks despite having their own methods for analyzing android still rely on more fundamental frameworks for tasks like identifying entry points building control flow graphs and call graphs and conducting data flow analysis .
for example didfail depends on epicc for resolving intent information and on flowdroid for data flow analysis.
r droid employs a slicing based analysis to generate data dependent statements for arbitrary points of interest within an android app.
it follows flowdroid and amandroid to analyze lifecycle and utilizes droidsafe s lightweight framework model to analyze apps.
b static analysis for specific android features for intent analysis iccbot models ui relationships from fragments to activities during the resolution process.
aria uses a two pass method first it applies data flow analysis to resolve intents and labels those that cannot be resolved initially.
it then performs a new analysis to resolve icc leveraging its results to resolve previously unresolved intents.
in contrast pacdroid integrates features such as intents icc fragments and more resolving them on the fly with pointer analysis in a single analysis thus deriving enhanced intent information from the aggregated results of all analyzed features.
raicc analyzes atypical intents e.g.
pendingintent by parsing them into standard icc methods e.g.
startactivity through instrumentation resulting in a new apk that serves as a preprocessor for other static analyses.
pacdroid can also utilize the generated apk to handle atypical intents.
several studies focus on inter app communication iac extending icc analysis across multiple apps .
for instance iafdroid identifies iac related entry and exit points within an app and then performs taint analysis between apps using flowdroid.
no general frameworks including flowiccta p taint amandroid droidsafe and pacdroid offer comprehensive iac analysis.
to address this pacdroid currently employs apkcombiner to merge multiple apps into a single app for iac analysis.c static analysis for android security numerous studies employ static analysis to identify and address various security issues including intent based attack surfaces permission problems performance concerns and others .
these studies typically use or extend existing general android analysis frameworks e.g.
flowdroid to better tackle security challenges.
for example sealant addresses issues like intent spoofing and unauthorized intent reception helping users block potential attacks by automatically identifying vulnerable icc paths between applications.
permission tracer tainter focuses on the opacity of custom permission management which can pose privacy and security risks.
imgdroid analyzes improper practices in image loading and processing considering both performance and quality aspects.
in the future pacdroid can be extended by conveniently adding handlers to develop and enhance research on these security issues.
vi.
c onclusions we present pacdroid a new static analysis framework for vulnerability detection in android apps.
its core novelty lies in adopting a pointer analysis centric approach a simple yet effective method for cohesively handling various android features in a unified way.
extensive experiments demonstrate that pacdroid not only achieves a superior trade off between soundness and precision f measure compared to state ofthe art frameworks but also surpasses them in analysis speed and robustness achieving all of these simultaneously is a big challenge for a fundamental static analysis framework.
moreover pacdroid successfully detects dozens of real vulnerability flows in real world android apps where all other frameworks fall indicating its potential for practical use.
although our primary focus in this paper is on security pacdroid actually offers a set of fundamental facilities such as alias and points to information for every variable and the call graph of an android app which serve as the basis for various analysis clients.
we hope these capabilities will help establish pacdroid as a foundational framework for developing a range of applications such as bug detection program understanding and optimization tools for android in the future.
vii.
a cknowledgments we thank the reviewers for their helpful comments.
this work is supported in part by national key r d program of china under grant no.
2023yfb4503804 national natural science foundation of china under grant nos.
the leading edge technology program of jiangsu natural science foundation under grant no.
bk20202001 and the collaborative innovation center of novel software technology and industrialization jiangsu china.
tian tan the co corresponding author is also supported by xiaomi foundation.
we thank zidong han and his security team from meituan for choosing pacdroid as the basis for developing their security tools and for offering their helpful feedback.
2813references statcounter mobile operating system market share worldwide https gs.statcounter.com os market share mobile worldwide.
statista number of smartphone users worldwide com statistics number of smartphone users worldwide .
m. talal a. zaidan b. zaidan m. alsalem f. jumaah and m. alaa comprehensive review and analysis of anti malware apps for smartphones telecommunication systems vol.
pp.
.
s. arzt s. rasthofer c. fritz e. bodden a. bartel j. klein y .
le traon d. octeau and p. mcdaniel flowdroid precise context flow field object sensitive and lifecycle aware taint analysis for android apps acm sigplan notices vol.
no.
pp.
.
l. li a. bartel t. f. bissyand e j. klein y .
le traon s. arzt s. rasthofer e. bodden d. octeau and p. mcdaniel iccta detecting inter component privacy leaks in android apps in ieee acm 37th ieee international conference on software engineering vol.
.
ieee pp.
.
n. grech and y .
smaragdakis p taint unified points to and taint analysis proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
f. wei s. roy x. ou and robby amandroid a precise and general inter component data flow analysis framework for security vetting of android apps acm transactions on privacy and security tops vol.
no.
pp.
.
m. i. gordon d. kim j. h. perkins l. gilham n. nguyen and m. c. rinard information flow analysis of android applications in droidsafe.
inndss vol.
no.
p. .
l. lu z. li z. wu w. lee and g. jiang chex statically vetting android apps for component hijacking vulnerabilities in proceedings of the acm conference on computer and communications security pp.
.
h. bagheri a. sadeghi j. garcia and s. malek covert compositional analysis of android inter app permission leakage ieee transactions on software engineering vol.
no.
pp.
.
a. bosu f. liu d. yao and g. wang collusive data leak and more large scale threat analysis of inter app communications in proceedings of the acm on asia conference on computer and communications security pp.
.
y .
k. lee j. y .
bang g. safi a. shahbazian y .
zhao and n. medvidovic a sealant for inter app security holes in android.
in ieee acm 39th international conference on software engineering icse ieee s323 .
b. wang c. yang and j. ma iafdroid demystifying collusion attacks in android ecosystem via precise inter app analysis ieee transactions on information forensics and security vol.
pp.
.
d. octeau d. luchaup m. dering s. jha and p. mcdaniel composite constant propagation application to android inter component communication analysis in ieee acm 37th ieee international conference on software engineering vol.
.
ieee pp.
.
a. s. christensen a. m ller and m. i. schwartzbach precise analysis of string expressions in international static analysis symposium .
springer pp.
.
t. tan and y .
li tai e a developer friendly static analysis framework for java by harnessing the good designs of classics in proceedings of the 32nd acm sigsoft international symposium on software testing and analysis pp.
.
y .
li t. tan a. m ller and y .
smaragdakis precision guided context sensitivity for pointer analysis proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
l. luo f. pauck g. piskachev m. benz i. pashchenko m. mory e. bodden b. hermann and f. massacci taintbench automatic real world malware benchmarking of android taint analyses empirical software engineering vol.
pp.
.
develop.
j. zhang y .
wang l. qiu and j. rubin analyzing android taint analysis tools flowdroid amandroid and droidsafe ieee transactions on software engineering vol.
no.
pp.
.
y .
li t. tan and j. xue understanding and analyzing java reflection acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
d. king b. hicks m. hicks and t. jaeger implicit flows can t live with em can t live without em in information systems security 4th international conference iciss hyderabad india december .
proceedings .
springer pp.
.
y .
smaragdakis g. balatsouras et al.
pointer analysis foundations and trends in programming languages vol.
no.
pp.
.
t. reps s. horwitz and m. sagiv precise interprocedural dataflow analysis via graph reachability in proceedings of the 22nd acm sigplan sigact symposium on principles of programming languages pp.
.
m. sagiv t. reps and s. horwitz precise interprocedural dataflow analysis with applications to constant propagation theoretical computer science vol.
no.
pp.
.
k. allix t. f. bissyand e j. klein and y .
le traon androzoo collecting millions of android apps for the research community in proceedings of the 13th international conference on mining software repositories ser.
msr .
new york ny usa association for computing machinery p. .
.
available m. alecci p. j. r. jim enez k. allix t. f. bissyand e and j. klein androzoo a retrospective with a glimpse into the future in ieee acm 21st international conference on mining software repositories msr .
ieee pp.
.
s. banerjee s. cui m. emmi a. filieri l. hadarean p. li l. luo g. piskachev n. rosner a. sengupta o. tripp and j. wang compositional taint analysis for enforcing security policies at scale in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering ser.
esec fse .
new york ny usa association for computing machinery p. .
.
available m. benz e. k. kristensen l. luo n. p. borges e. bodden and a. zeller heaps n leaks how heap snapshots improve android taint analysis in proceedings of the acm ieee 42nd international conference on software engineering ser.
icse .
new york ny usa association for computing machinery p. .
.
available j. wang y .
wu g. zhou y .
yu z. guo and y .
xiong scaling static taint analysis to industrial soa applications a case study at alibaba in proceedings of the 28th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering ser.
esec fse .
new york ny usa association for computing machinery p. .
.
available n. grech g. fourtounis a. francalanza and y .
smaragdakis shooting from the heap ultra scalable static analysis with heap snapshots ser.
issta .
new york ny usa association for computing machinery p. .
.
available y .
gui d. he and j. xue merge replay efficient ifds based taint analysis by consolidating equivalent value flows in 38th ieee acm international conference on automated software engineering ase pp.
.
d. he h. li l. wang h. meng h. zheng j. liu s. hu l. li and j. xue performance boosting sparsification of the ifds algorithm with applications to taint analysis in 34th ieee acm international conference on automated software engineering ase pp.
.
w. ma s. yang t. tan x. ma c. xu and y .
li context sensitivity without contexts a cut shortcut approach to fast and precise pointer analysis proceedings of the acm on programming languages vol.
no.
pldi pp.
.
y .
li t. tan a. m ller and y .
smaragdakis scalability first pointer analysis with self tuning context sensitivity in proceedings of the 26th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering pp.
.
t. tan y .
li and j. xue efficient and precise points to analysis modeling the heap by merging equivalent automata in proceedings of the 38th acm sigplan conference on programming language design and implementation pp.
.
j. hu l. wei y .
liu and s. c. cheung test webview oriented testing for android applications in proceedings of the 32nd acm 2814sigsoft international symposium on software testing and analysis pp.
.
h. li y .
hao y .
zhai and z. qian enhancing static analysis for practical bug detection an llm integrated approach proceedings of the acm on programming languages vol.
no.
oopsla1 pp.
.
l. fan t. su s. chen g. meng y .
liu l. xu g. pu and z. su large scale analysis of framework specific exceptions in android apps inproceedings of the 40th international conference on software engineering pp.
.
e. aghajani g. bavota m. linares v asquez and m. lanza automated documentation of android apps ieee transactions on software engineering vol.
no.
pp.
.
d. helm f. k ubler m. reif m. eichberg and m. mezini modular collaborative program analysis in opal in proceedings of the 28th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering pp.
.
s. calzavara i. grishchenko and m. maffei horndroid practical and sound static analysis of android applications by smt solving in ieee european symposium on security and privacy euros p .
ieee pp.
.
w. klieber l. flynn a. bhosale l. jia and l. bauer android taint flow analysis for app sets in proceedings of the 3rd acm sigplan international workshop on the state of the art in java program analysis pp.
.
j. zhang c. tian and z. duan an efficient approach for taint analysis of android applications computers security vol.
p. .
a. tiwari s. gro and c. hammer iifa modular inter app intent information flow analysis of android applications in security and privacy in communication networks 15th eai international conference securecomm orlando fl usa october proceedings part ii .
springer pp.
.
m. backes s. bugiel e. derr s. gerling and c. hammer r droid leveraging android app analysis with static slice optimization in proceedings of the 11th acm on asia conference on computer and communications security pp.
.
l. luo g. piskachev r. krishnamurthy j. dolby e. bodden and m. sch af model generation for java frameworks in ieee conference on software testing verification and validation icst .
ieee pp.
.
d. octeau p. mcdaniel s. jha a. bartel e. bodden j. klein and y .
le traon effective inter component communication mapping in android an essential step towards holistic security analysis in 22nd usenix security symposium usenix security pp.
.
j. yan s. zhang y .
liu j. yan and j. zhang iccbot fragmentaware and context sensitive icc resolution for android applications inproceedings of the acm ieee 44th international conference on software engineering companion proceedings pp.
.
n. abolhassani and w. g. halfond a component sensitive static analysis based approach for modeling intents in android apps in ieee international conference on software maintenance and evolution icsme .
ieee pp.
.
j. samhi a. bartel t. f. bissyand e and j. klein raicc revealing atypical inter component communication in android apps in ieee acm 43rd international conference on software engineering icse .
ieee pp.
.
e. chin a. p. felt k. greenwood and d. wagner analyzing interapplication communication in android in proceedings of the 9th international conference on mobile systems applications and services pp.
.
l. li a. bartel t. f. bissyand e j. klein and y .
l. traon apkcombiner combining multiple android apps to support inter app analysis inict systems security and privacy protection 30th ifip tc international conference sec hamburg germany may proceedings .
springer pp.
.
b. f. demissie m. ceccato and l. k. shar security analysis of permission re delegation vulnerabilities in android apps empirical software engineering vol.
no.
pp.
.
j. gamba a. feal e. blazquez v .
bandara a. razaghpanah j. tapiador and n. vallina rodriguez mules and permission laundering in android dissecting custom permissions in the wild ieee transactions on dependable and secure computing .
s. wang y .
wang x. zhan y .
wang y .
liu x. luo and s. c. cheung aper evolution aware runtime permission misuse detection for android apps in proceedings of the 44th international conference on software engineering pp.
.
m. jalili and f. faghih static dynamic analysis of android applications to improve energy efficiency in cpssi 4th international symposium on real time and embedded systems and technologies rtest .
ieee pp.
.
w. song m. han and j. huang imgdroid detecting image loading defects in android applications in ieee acm 43rd international conference on software engineering icse .
ieee pp.
.
m. egele d. brumley y .
fratantonio and c. kruegel an empirical study of cryptographic misuse in android applications in proceedings of the acm sigsac conference on computer communications security pp.
.
z. meng y .
xiong w. huang l. qin x. jin and h. yan appscalpel combining static analysis and outlier detection to identify and prune undesirable usage of sensitive data in android applications neurocomputing vol.
pp.
.
m. tileria and j. blasco watch over your tv a security and privacy analysis of the android tv ecosystem proceedings on privacy enhancing technologies .
s. fahl m. harbach t. muders l. baumg artner b. freisleben and m. smith why eve and mallory love android an analysis of android ssl in security in proceedings of the acm conference on computer and communications security pp.
.
j. samhi l. li t. f. bissyand e and j. klein difuzer uncovering suspicious hidden sensitive operations in android apps in proceedings of the 44th international conference on software engineering pp.
.
d. lai and j. rubin goal driven exploration for android applications in2019 34th ieee acm international conference on automated software engineering ase .
ieee pp.
.
z. chen j. liu y .
hu l. wu y .
zhou y .
he x. liao k. wang j. li and z. qin deuedroid detecting underground economy apps based on utg similarity in proceedings of the 32nd acm sigsoft international symposium on software testing and analysis pp.
.