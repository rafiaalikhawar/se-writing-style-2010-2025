challenges and opportunities in model checkinglarge scale distributed systemsrupak majumdarmax planck institute for software systems mpi sws germanyamazon web servicesusarupak mpi sws.orgabstractthe goal of themustproject is to provide design and veri!cationsupport for industrial scale distributed systems.
we provide anoverview of the project its design goals its technical features as well as some lessons we learnt in the process of transferringacademic research to an industrial tool.acm reference format rupak majumdar.
.
challenges and opportunities in model checkinglarge scale distributed systems.
in2024 ieee acm 46th international con ference on software engineering icse april lisbon portugal.acm new york ny usa pages.
overviewthe goal of themustproject is to enable programmers to design andimplement high con!dence distributed applications.
we started themustproject with two desired goals.
first the ultimate goal ofmustis to provide fullunboundedveri!cation at the implementation level.second we require that all artefacts related to formal reasoning beowned and maintained by the development teams in the course oftheir usual work ows not by additional teams of formal methodsexperts or consultants working in parallel.the!rst goal is a point of departure from many projects on large scale testing.
while we are far from achieving this goal at the scaleof industrial distributed systems keeping an eye towards full veri !cation helped in our design decisions along the way.
i will arguethat the goal of soundness pushed us to design better algorithms inthe short run that while not providing full and unbounded formalveri!cation already outperform more naive approaches in terms ofcoverage.the second point led us to modeling systems directly at the levelof programming languages already used by the developer teams asopposed to modeling in domain speci!c and more abstract modelinglanguages.
an additional language for formal work adds friction inthe development process our prior experience has been that formalartefacts not in the developer pipelines can quickly become stale.
inaddition it should not come as a surprise to the software engineer ing community that maintaining a language and a developmentpermission to make digital or hard copies of part or all of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor pro!t or commercial advantage and that copies bear this notice and the full citationon the!rst page.
copyrights for third party components of this work must be honored.for all other uses contact the owner author s .icse april lisbon portugal copyright held by the owner author s .acm isbn is hard.
domain speci!c languages grow over time and ensuring a smooth developer experience including providingall the software engineering sca olding we take for granted isdi cult and expensive.instead mustembeds an api for concurrent message passing distributed systems directly within the rust programming lan guage.
the api provides an abstract and parameterized interface formessage passing as well as core constructs for process creation andnondeterminism.
sequential computation is written directly in rust the type and module system of the rust programming language pro vides mechanisms for compositionality and information hiding forfree.
additional rust apis are simulated by internally translatingtheir semantics to the coremustapi.our initial focus is on systematic exploration of concurrency rather than data nondeterminism.
thus we focused on model check ing as a!rst deliverable because of its relatively easy integrationinto developer work ows and as a gateway to more expressivebut more expensive formal methods involving user annotationsand proofs.
we have found that systematic exploration of concur rency together with judicious symbolic analysis can already be apowerful tool for distributed systems development.
the must model checkerthe technical core ofmustis an api for process creation and formessage passing communication.
process creation is fairly straight forward and mimics thread creation apis in rust.
the messagepassing primitivessend tid l candrecv mn o cprovide mes sage send and predicated message receipts respectively.
the prim itives are parameterized by acommunication modelc di erentcommunication models are used to de!ne di erent message passingsemantics such as peer to peer causal delivery or full asynchronythat are used often in combination in distributed applications.
thepredicatemn oexpresses a predicate that must hold for the receiveto succeed predicated receives are a fairly powerful modeling andimplementation primitive for many protocols.
additional communi cation apis in rust are simulated by translating their semantics tothe core api.
for example we can transparently support standardrust apis for network communication and rpc communication.at the theoretical level we provide a novelpartial orderseman tics tomustprograms parameterized by the communication model.the semantics de!nes a set ofexecution graphsfor a given program.in practice the partial order view leads to a large reduction in thestate space and the model checker can systematically explore manyprotocols to completion.
ieee acm 46th international conference on software engineering icse icse april lisbon portugalrupak majumdarthemustmodel checker implements a noveloptimaldynamicpartial order reduction odpor algorithm to explore executiongraphs.
optimality means that the model checker explores exactlyone execution for each possible execution graph allowed by thesemantics and does not perform futile explorations.
the modelchecker only has a polynomial memory overhead on the execution in practice this means that the model checker has very predictablememory usage and can be run for several days on many coreswithout memory issues.while themustproject is in a relatively early stage we are en couraged by our progress and early signs of adoption.
we have usedmustas a model checker on top of existing distributed systems pro tocols such as replicated logs leader election and paxos and data base transaction systems.
our initial experiments are encouraging both in terms of developer engagement and in terms of scalingmodel checking.
along the way we implemented various usabilityrequirements including integration into build systems replayabil ity and debugging automated collection and analysis of metrics and others that are crucial to deploying formal tools in a develop ment pipeline.
finally the adoption and use of formal techniquesis also a social process we saw the importance of formal methodsevangelism in achieving broad success of veri!cation techniques insoftware development.acknowledgmentsmustis a collaborative e ort with many researchers and engineers.
iwould like to thank my close collaborators constantin enea dimitragiannakopoulou and michalis kokologiannakis on the project aswell as byron cook ankush das ankush desai murat demirbas cezara dragoi ferhat erata anjali joshi rajeev joshi mohammadkhoshechin paul tillotson mark tuttle and many others for theiradvice and support.
2so!ware engineering research in a world with generativeartificial intelligencemartin rinarddepartment of electrical engineering and computer sciencecomputer science and arti!cial intelligence laboratorymassachusetts institute of technologycambridge massachusetts usarinard csail.mit.eduabstractgenerative arti!cial intelligence systems such as large languagemodels llms exhibit powerful capabilities that many see as thekind of exible and adaptive intelligence that previously only hu mans could exhibit.
i address directions and implications of llmsfor software engineering research.ccs concepts software and its engineering computing methodologies arti!cial intelligence keywordssoftware engineering generative arti!cial intelligence large lan guage modelsacm reference format martin rinard.
.
software engineering research in a world with gener ative arti!cial intelligence.
in2024 ieee acm 46th international conferenceon software engineering icse april lisbon portugal.acm new york ny usa pages.
introductionsoftware engineering and arti!cial intelligence have largely com prised disjoint sub!elds of computer science since the inceptionof the!eld in the middle of the 20th century.
the focus of soft ware engineering research has been and continues to be on issuesrelevant to software systems that are deployed or intended to bedeployed .
the focus of arti!cial intelligence research has been onunderstanding how to obtain systems that exhibit aspects of humanintelligence a goal that has been so far from delivering recognizablyintelligent systems that deployability concerns have traditionallyhad little or no relevance to the!eld.11i acknowledge here that the!eld of arti!cial intelligence has produced many usefuldeployed systems and techniques.
but these systems have traditionally been seen asspino s that do not themselves meaninfully exhibit any aspect of human intelligence.for much of the history of the!eld as soon as a system developed to the point whereit could be deployed people largely understood the system and its behavior and thesystem was no longer considered to exhibit arti!cial intelligence.permission to make digital or hard copies of part or all of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor pro!t or commercial advantage and that copies bear this notice and the full citationon the!rst page.
copyrights for third party components of this work must be honored.for all other uses contact the owner author s .icse april lisbon portugal copyright held by the owner author s .acm isbn .
the recent advent of generative arti!cial intelligence inthe form of large language models llms things have changed.these systems exhibit capabilities that many recognize as the kindof exible and adaptive intelligence that previously only humanscould exhibit.
these capabilities include the ability to operate exi bly at di erent levels of abstraction and formalism in ambiguoussituations with varying amounts of information about both thesituation and the overall goal.
this development surprised essen tially every expert in the!eld.
moreover these capabilities haveproved to be immediately useful across a range of human endeavors.arti!cial intelligence systems are now widely used and promise toplay a central role in many human endeavors moving forward.
thissituation places arti!cial intelligence systems and more broadlysystems that leverage arti!cial intelligence within a broader sys tem context squarely within the purview of software engineering.i ll consider some recent research that involves modern arti!cialintelligence using these systems as a springboard for a broaderdiscussion of how the combination of arti!cial intelligence andsoftware engineering research may play out over time.
large language models andtraditional software engineeringproblemstraditional software systems have been the focus of software engi neering for the last several decades.
these systems store retrieve transmit copy manipulate and analyze digital data at scale.
whiledevelopment processes vary the basic idea is to obtain a systemwhose goals and behavior are understood and engineered by humandevelopers.
it is worth noting that this philosophy and approach hasbeen enormously successful and the resulting systems have had atransformational e ect on our society.
over the last several decadesthe!eld of software engineering has become familiar with the prob lems that arise in this context and has delivered and continuesto deliver a large body of research motivated by these problems with our ability to successfully design and implement this class ofsystems proceeding apace.
i consider several systems that bringgenerative arti!cial intelligence into this basic framework.
.
program inference and regenerationprogram inference and regeneration uses active learning to build amodel of a software system or component then uses the model to re generate a new version of the system or component rinard et al.
vasilakis et al.
shen and rinard .
the technique has32024 ieee acm 46th international conference on software engineering icse icse april lisbon portugalmartin rinardenormous promise for a range of software engineering tasks includ ing software maintenance and retargeting functionality extractionfrom legacy systems and the elimination of software supply chainsecurity vulnerabilities.
our!rst approach to this problem involvedthe deployment of fairly heavyweight programming language tech nology paired combinations of domain speci!c languages andcorresponding active learning algorithms.
while this approach de livers guarantees and bene!ts unavailable with any other currentlyavailable approach its practical scope has been limited by the factthat each new domain requires the development of a new domainspeci!c language and learning algorithm.llms provide an immediate lightweight alternative approach.the basic idea is straightforward component give the llm a component for example froma popular software ecosystem such as npm.
input generation ask the llm to generate a set of inputsfor the component.
output generation run the component on the inputs toget corresponding outputs.
regeneration ask the llm to generate a program thatimplements the input output examples.
ideally the llm willproduce a better implementation for example because anyvulnerabilities in the original component are discarded in theregenerated version or because theregenerated version is written in a more desirable languageor can execute in a new environment .it is instructive to consider how little e ort is required to performthis set of steps to obtain a regenerated version of a broad rangeof components.
it is also instructive to apply this idea to range ofcomponents and observe how much more e ort can be invested tomaximize the bene!ts available via this approach.
one takeawayis that current llms can produce large amounts of software veryquickly but getting software you actually want may require moretime and e ort.
one theme is that the exercise does not resembletraditional engineering but instead is more like interacting witha cheerful bureaucracy where you have to know what to ask andsay to get what you want typically by exploring alternatives untilyou succeed or give up and try other options .
and it is never fullyclear what you can hope to get until you get it.
nevertheless theability of llms to automatically generate software at scale givenrelatively little explicit guidance may fundamentally change thetechnical economic landscape by dramatically reducing the costof probable software especially if the anticipated rapid increasesin the capabilties of llms materialize .
but improbable i.e.
trulynew software may be a very di erent story.
.
acceptable survivabilityone perceived drawback of code generated by llms is that it comeswith no guarantees.
here i focus on one important but often un derrated and underexplored property speci!cally survivability inthe form of continued meaningful execution in the face of errorsor anomalies and advocate a survivable by construction approach.one key insight behind this approach is that most survivable soft ware conforms to a reactive model in which either explicitly orimplicitly the execution can be decomposed into a sequence ofcomputation units each of which consumes an input unit executesa computation that processes the input then returns back to pro cess the next input unit.
such software often exhibitsshort errorpropagation distances as long as the computation preserves basicconsistency properties errors in one computation unit typicallydo not propagate to successive units as long as the errors are notfatal rinard et al.
long et al.
shen and rinard .this property endows large software systems with surprising re silience when measures are taken to replace language implementa tion mechanisms such as throwing exceptions for null dereferencesor out of bounds accesses that preemptively terminate computa tions in the face of execution integrity errors with failure obliviousmechanisms that preserve basic consistency while enabling contin ued execution .filtered iterators which atomically discard computation unitsthat encounter errors or consistency violations so that the com putation executes as if the corresponding input unit never existed provide a model of computation that ensures continued executionin the face of otherwise fatal errors .
incombination with language implementation mechanisms cyclicmemory allocation and in!nite looptermination that!nitize each computation unit by eliminating all sources of unbounded resource consumption !ltered iterators can guarantee survival via continued execution.embedding llm generated code inside a!ltered iterator or forc ing the llm to generate!ltered iterators can ensure survivability.filtered iterators are therefore an example of a general class ofbehavioral regulationmechanisms that integrate unreliable or un predictable components into a larger predictable reliable system.it is worth noting that llms themselves like many other ma chine learning models implement an inherently survivable modelof computation.
because the llm model of computation is so sim ple llms are not susceptible to many of the errors that traditionalsoftware may encounter.
mechanisms that bound the computation for example by bounding the number of generated tokens canguarantee survivability.
in part because of this desirable property we may see systems that use behavioral regulation mechanisms toacceptably embed machine learning models such as llms withinlarger software contexts with llms implementing core processingcomputations .an intriguing property is that llm outputs are essentially sam ples from a probabilistic model of the data on which they weretrained.
a query can be seen as eliciting one or more samples fromthe probabilistic model conditioned on the query prompt.
one no table and useful aspect that llms share with other probabilisiticmodels is the ability to generate multiple samples.
this fact enablesstrategies that repeatedly sample to!nd a response that has de sirable properties for example automatically generated code thatproduces corrent outputs on a given input set or an automaticallygenerated image that elicits positive emotions in a human observer .current llms produce samples one token at a time enabling strate gies that e ciently steer the response by resampling tokens thatdo not conform to some property that the response must satisfy for example conforming to a syntactic requirement speci!ed by agrammar .here we can see the!eld transitioning away from an engineer ing approach into a hybrid approach that includes components4so!ware engineering research in a world with generative artificial intelligence icse april lisbon portugalwhose behavior may be poorly understood or unpredictable.
onemajor theme is applying techniques that place enough contextaround these components to recover guarantees and or predictabil ity for the system as a whole.
here past research on integratingunreliable components into acceptable software systems may beparticularly relevant .
keys to success include asymmetrical engineering identifying and directing engineeringresources to parts of the system that must execute predictably andreliably and behavioral regulation sur rounding components with mechanisms such as!ltered iteratorsor acceptability oriented computing that regulatetheir interaction with the rest of the system to deliver predictableand reliable behavior guardrails is often another name for this con cept .
these techniques appropriately deployed can deliver a fullrange of acceptability properties and not just continued execution.
.
security and trustbecause software generated by llms comes with no guarantees security and trust are likely to play a prominent role.
there area variety of techniques for addressing potential issues includingtechniques such as those described in the previous subsection that place generated code in a context that enforces acceptabilityproperties such as security or trust.here i highlight a potential threat model speci!cally using com promised training data to subvert the llm to generate code con taining security vulnerabilities.
it is important to realize that themost likely attack scenario would not involve compromising theenormous amount of pretraining data but instead the relativelymuch smaller amount of!ne tuning data which is a much morefeasible proposition .
trust is an important but much less preciselyde!ned property.
obtaining trust is an instance of the much broaderlarge language model alignment problem which is still in its veryearly stages of exploration and development.
.
probable vs. improbable softwarellms can be seen as powerful probabilistic models of their trainingdata that generate outputs by sampling from the trained distributionconditioned on the prompt.
as such they can be deployed to executeprioritized searches of complex search spaces to ideally quicklytarget desirable points in the space.
many problems in traditionalsoftware engineering as in computer science more generally canbe framed as search problems .
promi nent examples include automatic software repair monperrus zhang et al.
perkins et al.
le goues et al.
software fault local ization and test input generation .
given their ability to model data match pat terns at scale and generate probable responses to complex queries the!eld has already delivered an enormous amount of researchthat deploys llms to more precisely and e ciently target desirablepoints in the search spaces that underly many traditional softwareengineering problems.
this is a classic case of deploying new tech nology to better solve existing problems and given the remarkable exibility and scale of llms i expect this trend to only acceleratein the near future.there is the widespread expectation that we are still in the veryearly stages of llm development and given the progress to date may see very rapid improvements in the capabilities of large lan guage models to generate probable software.
if so the cost anddi culty of obtaining probable software will only decrease.
i alsonote that any such development may not necessarily always pro duce positive outcomes for example the ability to cheaply ande ciently generate enormous amounts of probable software mayincrease the ability of attackers to much more rapidly cheaply ande ciently explore the space of potential security exploits.the implications of llms for the creation of truly new and there fore presumably improbable software are unclear if only becausethe!eld currently has no good understanding of how improbabletruly new software really is.
i anticipate a spectrum of possibilities from software that mostly combines existing patterns and compo nents in new and creative ways and is therefore mostly probable tosoftware that is improbable from the ground up.
to my knowledgethe!eld currently has no good understanding of where along thisspectrum systems are likely to fall how probable existing softwaresystems are how di erent existing software systems are from eachother or where any probability improbability is concentrated inexisting or envisioned software systems.
developing meaningfulmetrics and methodologies to understand these distinctions is apotentially very interesting direction for the!eld.3inverting the software engineeringprocessperhaps the most surprising aspect of llms is their ability to ab sorb information at scale then engage with that information atall levels of abstraction to convert the information into exiblyaccessible knowledge.
this ability hints at the promise of invertingthe software engineering process by enabling llms to perform or play major roles in many activities previously understood tobe the domain of humans alone.
at the extreme end of the spec trum instead of developers telling the computer what to do thecomputer tells the developers what system to build and perhapseven builds the system itself .
i have been exploring this idea in thecontext of using llms in an undergraduate compiler developmentclass.
compilers have been extensively studied for decades now with much of the resulting knowledge available in papers and text books that one would expect to see in the training data for modernllms.
perhaps because of this reason our very early experience ispromising although it is far from clear what the!nal result willbe a tra b tra c .
.
requirements gatheringrequirements gathering has traditionally been seen as a humanactivity focusing on interacting with stakeholders to understandtheir needs.
llms may transform this activity in at least the follow ing ways guiding the requirements gathering process to ensureall relevant stakeholders are identi!ed ensuring that all impor tant aspects of the envisioned system are addressed suggestingfunctionality that the system should include for well under stood classes of systems automatically generating requirements as opposed to gathering requirements from human stakeholders and writing portions or even all of the requirements documents.5icse april lisbon portugalmartin rinardfor many systems we may eventually see requirements gatheringshifting from a human activity to an activity largely driven by inter actions with an llm.
relevant research problems here include un derstanding how to best interact with the llm to elicit meaningfulrequirements how to achieve the best balance between gatheringrequirements from humans and llms and which domains are bestsuited for this approach.
.
speci!cation and designmuch like requirements gathering these activities have tradition ally been seen as primarily human activities.
because llms candraw on a huge collection of software speci!cation and designinformation they hold out the promise of similarly automatingaspects of the speci!cation and design process for traditional soft ware systems.
because llms can interact so exibly at multiplelevels of abstraction and precision interacting with them can helpdevelopers conceptualize explore and evaluate ideas throughoutthe design process to the extent that developers remain involvedin these processes .
drawing on the enormous amount of designknowledge present in the training data we anticipate that llmsmay prove to be particularly useful in identifying particularly pro ductive or problematic aspects of human generated designs.
understanding generativeartificial intelligence systemsthe behavior of modern generative arti!cial intelligence systemsarises because of poorly understood interactions between the struc ture training data and training process that created the system.the resulting systems exhibit surprising capabilities well beyondwhat experts thought was possible even several years ago and un predictable sometimes desirable sometimes undesirable behavior.this fact motivates research into understanding the reasons behindthese phenomena.here i focus on recent research investigating whether llmsdevelop any meaningful understanding of the domain in whichthey operate or whether their behavior is due only to leveragingstatistical correlations at scale .
to make theinvestigation more concrete the research focuses on the semanticsof programs that control agents in a simulated world.
an advantageof this approach is its foundation in a precise formalized contextdevoid of ambiguity.the experiment trains an llm to given an input and output gridworld with a robot synthesize a robot program that transformsthe input world to the output world.
this program is written in alanguage that includes operations that move and rotate the robotand enable the robot to act on the world in various ways.
thequestion is whether the internal state of the llm works with anysemantic representation of the robot or world state as it synthesizesthe sequence of operations in the program essentially does thellm understand any aspect of the robot or world as it generatesthe program?one complication is that any such semantic state may be presentbut encoded so that it is not immediately apparent.
one solution isto train a probe to extract the state if present.
it turns out that it isindeed possible to train a probe to extract semantically meaningfulaspects of the robot state such as the facing direction of the robot it is also possible to probe for these aspects of the robot stateafter one or two as yet ungenerated operations into the future raising the possibility that the llm may be predicting future statesto guide the synthesis during training the ability of the probe toextract these aspects of the robot state exhibits a phase transitionfrom not being able to extract the state to being able to do so and4 the phase transition is correlated with a corresponding phasetransition in the ability of the llm to synthesize a robot programthat correctly transforms the input grid world to the output gridworld.a!nal question is whether the probe is simply learning to pro cess syntactic information about the program generated to date for example the probe may be learning to execute a record of theprogram generated to date so that the semantics is in the probeand not in the llm.
an experiment that attempts to train a probeto map the same llm states to di erent robot states based on analternate semantics of the robot operations fails to produce a probeas accurate as the probe that works with the original semanticson which the llm was trained supporting the hypothesis that thellm state includes some semantic state and not just some surfacesyntactic representation without meaning .given the scale and complexity of modern generative arti!cialintelligence systems and the prominent role that such systems arelikely to play in our future society i expect to see research that isdesigned to better understand these systems including how theyoperate and the reasons for their behavior to play a prominent rolein the!eld moving forward.5new software with large languagemodelsnew technologies are often!rst deployed in existing contexts tobetter solve existing problems.
but if the technology is su cientlytransformational the ultimate role it plays is almost always verydi erent from its initial motivation and deployment.
generativearti!cial intelligence appears to o er capabilities that are qualita tively di erent from previous software systems most prominentlythe ability to operate exibly and seamlessly at an abstract con ceptual level at a detailed formal level and all levels in between.particularly impressive is the ability to coherently integrate in formation from very di erent domains try asking an llm whatthe relationship is between software development and sur!ng inportugal .current llms are trained on enormous amounts of data bysome accounts a substantial fraction of all of the human producedtext currently extant and feature an enormous number of trainingparameters.
the resulting complexity of these models places themoutside traditional approaches for understanding and predictingsystem behavior here i refer to understanding the design docu mentation and source code of a software system .
instead of beingimplemented to satisfy a set of requirements or meet a speci!cation the behavior of the system emerges through the training process.a resulting new strength is the ability to operate in situations withambiguous vague goals pursued in the presence of incomplete andvarying amounts of information.
presented with such situations llms have the ability to internally generate a precise goal !ll inmissing information and produce a fully realized response.6so!ware engineering research in a world with generative artificial intelligence icse april lisbon portugalbut many generative arti!cial intelligence uses and arguablythe most potentially transformative uses involve situations wherean unambiguous speci!cation is not a goal and it is not realisticallypossible to ever state a complete range of correctness or accept ability properties.
such use cases often involve subjective humaninteractions with desirable acceptable behavior varying acrosspeople organizations and cultures.
there is also the hope thatgenerative arti!cial intelligence systems will eventually becomecreative entities that generate new knowledge new problems andsolutions and ultimately new culture.
ensuring that the resultingbehavior is consistent with the goals of the people organizations and societies using the system is the arti!cial intelligence alignmentproblem.
this is an emerging area of research that will only growin importance over time.judging by the published software engineering literature to date the!eld remains largely focused on applying this new technologyto traditional software engineering problems and has yet to startexploring the truly revolutionary potential that this technology mayo er.
to fully realize this opportunity the software engineeringcommunity will need to pivot to embrace more ambiguous andsubjective system goals than have been the traditional focus ofthe!eld while also developing techniques to ensure conformanceto objective requirements and speci!cations when available andappropriate .acknowledgmentsi thank daniel jackson logan engstrom and sam park for usefulfeedback on earlier versions of this paper.
tarushii goel providedthe lexer and parser interaction sessions.
i acknowledge supportfrom darpa and boeing.