selecting initial seeds for better jvm fuzzing tianchang gao college of intelligence and computing tianjin university tianjin china gaotc090 tju.edu.cnjunjie chen college of intelligence and computing tianjin university tianjin china junjiechen tju.edu.cndong wang college of intelligence and computing tianjin university tianjin china dong w tju.edu.cn yile guo college of intelligence and computing tianjin university tianjin china gyl 666 tju.edu.cnyingquan zhao college of intelligence and computing tianjin university tianjin china zhaoyingquan tju.edu.cnzan wang college of intelligence and computing tianjin university tianjin china wangzan tju.edu.cn abstract jvm fuzzing techniques serve as a cornerstone for guaranteeing the quality of implementations.
in typical fuzzing workflows initial seeds are crucial as they form the basis of the process.
literature in traditional program fuzzing has confirmed that effectiveness is largely impacted by redundancy among initial seeds thereby proposing a series of seed selection methods.
jvm fuzzing compared to traditional ones presents unique characteristics including large scale and intricate code and programs with both syntactic and semantic features.
however it remains unclear whether the existing initial seed selection methods are suitable for jvm fuzzing and whether utilizing program features can enhance effectiveness.
to address this we devise a total of initial seed selection methods comprising coverage based prefuzz based and program feature based methods.
we then conduct an empirical study on three jvm implementations to extensively evaluate the performance of the initial seed selection methods within two state of the art fuzzing techniques javatailor and vect .
specifically we examine performance from three aspects i effectiveness and efficiency using widely studied initial seeds ii effectiveness using the programs in the wild and iii the ability to detect new bugs.
evaluation results first show that the program feature based method that utilizes the control flow graph not only has a significantly lower time overhead i.e.
30s but also outperforms other methods achieving to improvement compared to the full set of initial seeds.
second results reveal that the initial seed selection greatly improves the quality of wild programs and exhibits complementary effectiveness by detecting new behaviors.
third results demonstrate that given the same testing period initial seed selection improves the jvm fuzzing techniques by detecting more unknown bugs.
particularly out of the detected bugs have been confirmed or fixed by developers.
this work takes the first look at initial seed selection in jvm fuzzing confirming its importance in fuzzing effectiveness and efficiency.
index terms java virtual machine jvm fuzzing initial seed selection empirical study i. i ntroduction the java virtual machine jvm serves as a critical infrastructure for the java platform providing a consistent runtime environment that allows developers to create and deploy java junjie chen is the corresponding author.applications across diverse hardware and operating systems without needing modification.
given its foundational role numerous jvm fuzzing techniques have been developed to ensure the quality of jvm implementations .
these techniques typically follow a general workflow which involves preparing a set of initial seeds generating test programs through mutations or code synthesis applied to these seeds and testing jvms with the generated test programs and providing feedback for subsequent iterations.
among these steps the initial seeds form the basis of the entire fuzzing process and thus play a critical role in determining the overall effectiveness of the fuzzing campaign.
in practice fuzzing budgets are often constrained and redundancy among initial seeds concerning the behaviors they induce during the fuzzing process is a common occurrence .
this redundancy necessitates spending a significant amount of time on initial seeds with overlapping behaviors for fuzzing consequently limiting overall effectiveness within the allocated time budget .
several studies have been conducted to confirm such an influence on fuzzing traditional programs and proposed some methods of selecting a subset of initial seeds for improving the fuzzing effectiveness such as coverage based and prefuzz based methods.
jvm fuzzing presents unique characteristics distinct from traditional program fuzzing.
on the one hand jvm code tends to be large scale and intricate resulting in significant overhead in collecting coverage and executing test programs.
therefore both coverage based and prefuzz based methods suffer from cost issues.
on the other hand jvm fuzzing operates on programs containing rich syntactic and semantic features and several existing works have highlighted the correlation between test program features and jvm fuzzing effectiveness .
given these unique characteristics it remains uncertain whether existing initial seed selection methods are suitable for jvm fuzzing and whether incorporating test program features can enhance initial seed selection effectiveness .
to address these open questions we conducted an empirical study to investigate the influence of initial seedarxiv .08515v1 aug 2024selection in the context of jvm fuzzing with the aim of further improving the effectiveness of jvm fuzzing within limited time budgets.
in this study we investigated a total of initial seed selection methods which comprised two coverage based methods ciss one prefuzz based method piss and seven program feature based methods fiss .
the coveragebased and prefuzz based methods were originally proposed in the context of traditional program fuzzing and we adopted them for jvm fuzzing.
specifically they utilize test coverage and short time fuzzing results as metrics to assess the fuzzing capability of each initial seed for selection respectively.
the remaining seven methods were particularly designed by us for jvm fuzzing considering different ways of utilizing program features.
specifically these methods utilize textual features abstract syntax tree ast features control flow graph cfg features and code semantics obtained from various code representation models to measure the diversity of initial seeds for selection respectively.
further details of these studied methods will be presented in section iii.
based on the set of methods we performed an experiment to address the following three research questions.
rq1 how dothese initialseed selection meth odsperform injvm fuzzing?
we first seek to investigate the performance of the studied initial seed selection methods in terms of effectiveness and efficiency.
in particular we used three widelyused jvm implementations i.e.
hotspot openj9 and bisheng jdk as subjects two widely used sets of initial seeds as the ones for selection and two state of the art jvm fuzzing techniques i.e.
javatailor and vect for evaluating each selected subset of initial seeds.
to make our conclusions have statistical significance we used the historical versions of these jvm implementations as the studied jvm fuzzing techniques can detect more bugs in them.
results the program feature based method that utilizes cfg features fiss cfg not only has a significantly lower time overhead i.e.
30s but also outperforms other methods achieving to improvement compared to the full set of initial seeds.
specifically we recommend using fiss cfgwith a budget for initial seed selection which can optimize performance and resource utilization in jvm fuzzing.
rq2 how does initialseed selection perform onprograms inthewild forimprovingjvm fuzzing?
intuitively any java programs in the wild can be used as initial seeds for jvm fuzzing.
it is plausible that some of these programs may introduce new behaviors compared to widely studied initial seeds thereby potentially improving jvm fuzzing.
however there is also a substantial number of programs that may not introduce new aspects for jvm fuzzing.
randomly collecting a large number of programs in the wild as initial seeds is unlikely to significantly enhance the effectiveness of jvm fuzzing within limited time budgets.
this may be a primary reason why existing jvm fuzzing techniques do not use them as initial seeds.
however the existence of initial seed selection methods presents an opportunity to strategically incorporate programs in the wild.
this may help leverage the benefitsof such programs effectively and thus improve jvm testing.
therefore we designed rq2 in our study which not only investigates the generalizability of our conclusions but also explores the feasibility of a new aspect to enhance the effectiveness of jvm fuzzing.
specifically we collected a set of programs in the wild as a new corpus and then repeated the first experiment on it.
results programs in the wild complement the widely studied initial seeds by detecting new jvm behaviors.
the subset of wild programs selected by fiss cfgboosts detection capability achieving an improvement of .
to compared to the full set of initial seeds.
moreover results underscore the crucial role of initial seed selection in enhancing the effectiveness of wild programs and also reinforce the generalizability of the top performing method fiss cfg.
rq3 caninitialseed selectionsurvive existingjvm fuzzing techniques fordetectingnew bugs?
based on rq1 and rq2 results it is evident that initial seed selection is helpful in enhancing the effectiveness of jvm fuzzing by allocating more time to diverse selected seeds and enabling the effective incorporation of programs in the wild.
however the ultimate aim of fuzzing is to find bugs in jvm thus we further investigated whether initial seed selection also helps improve studied fuzzing techniques in detecting previously unknown bugs.
specifically we applied each subset of initial seeds selected by different seed selection methods on vect to test the latest versions of three jvm implementations.
we then compared the number of unknown bugs detected by each method including the full set within the same testing period.
results initial seed selection fiss cfg improves the jvm fuzzing techniques by detecting more previously unknown bugs within the same testing period.
of the submitted bugs the developers have confirmed and fixed bugs and can only be detected using initial seeds from wild programs.
to sum up our major contributions are four fold design of seven initial seed selection methods specifically tailored for jvm fuzzing leveraging various features in test programs.
implementation of all studied initial seed selection methods as an open source toolkit facilitating practical use and future research in the field.
conducting an extensive study to investigate the impact of initial seed selection on the effectiveness of jvm fuzzing addressing three research questions rqs .
obtaining a series of findings and implications for improving jvm fuzzing.
ii.
b ackground and related work a. jvm fuzzing fuzzing is one of the most popular and effective methods to find bugs and vulnerabilities in software .
in the context of jvm diverse fuzzing techniques have been proposed to ensure the quality of jvm implementations.
the majority of them are seed driven such as the state of the art javatailor andvect that are experimented in this study.
javatailor adopts a history driven approach for synthesizing test programs.
it designs five types of ingredients extracted from bug revealing test programs.
these ingredients are then inserted into seed programs and syntactic and semantic constraints within the constituents are automatically rectified to produce valid synthesized programs for differential testing.
vect streamlines the extensive ingredient space by vectorizing program ingredients through advanced code representation.
it then employs a feedback based ingredient selection strategy to enhance the effectiveness of test program generation.
furthermore vect incorporates an enhanced test oracle to broaden the bug detection capability of current jvm testing.
additionally there are other techniques that are also seeddriven.
for example chen et al.
introduced classfuzz and classming which mutate bytecode and control flow to generate test programs with broader coverage respectively.
wu et al.
proposed jitfuzz which designs mutation operators related to jit defects to generate test programs.
sjfuzz optimizes the scheduling of seed programs and mutation operators to enhance the effectiveness of classming.
apart from the seed driven techniques some efforts target generating test programs by starting from an empty program or a program with holes .
for instance zhang et al.
proposed jattack which fills holes in template classes with randomly generated expressions and values to generate test programs.
hwang et al.
introduced justgen which uses jni specifications to identify unspecified scenarios for generating corner cases.
our work is applicable to various jvm fuzzing techniques that require initial seeds.
we devised a set of methods for selecting initial seeds in order to extensively study their effect on fuzzing capability.
b. initial seed selection in seed driven fuzzing workflows the selection of initial seeds is typically one of the first steps and plays a significant role in the overall effectiveness of fuzzing.
several studies have highlighted the importance of high quality seeds on fuzzers performance.
for instance klees et al.
asserted that fuzzer s performance can greatly vary on the same program depending on the seed used.
herrera et al.
evaluated how seed selection affects a fuzzer s ability and their findings suggest that seed selection is a critical step that must be considered prior to launching any fuzzing campaign.
remarkably practitioners such as the developers of the mozilla firefox browser also recognized the importance of seed selection.
several methods have been proposed to select a subset of initial seeds with the aim of improving the quality of initial seeds and reducing the budget of fuzzing.
specifically a common method in traditional software testing is the corpus minimization technique which selects the smallest subset of the corpus that maintains the equivalent coverage to the entire corpus.
this technique involves widely adopted coverage based methods such as peachset minset andoptimin .
for example minset an unweighted greedyreduced minimization sorts seed files based on their coveragetable i studied initial seed selection methods type method input strategy white boxcissp coverage greedy cissm coverage greedy black boxpiss fuzzing result greedy fiss ts token fps fiss ast ast fps fiss cfg cfg fps fiss cb token fps fiss ic ast fps fiss pb token fps fiss ct token fps increments and chooses the one with the maximum increase.
the prior work reported that peachset found the highest number of bugs and minset performed the best in terms of the minimization ability .
the prefuzz based method hotset executes each seed file for an equal amount of time and sorts them based on the number of known defects each file uncovers.
despite extensive study of initial seed selection in traditional software its role in jvm fuzzing remains largely unexplored.
to address this we conducted the first study to investigate the effect of various selection methods on jvm fuzzing performance.
different from those methods aiming to minimize the initial seeds as the initial step our focus is to understand the effect of selecting subsets of the seeds.
furthermore certain existing methods such as hotset are unable to achieve minimization.
hence to make a fair comparison among these methods we opted to establish a selected subset of initial seeds.
current selection methods may cause considerable overhead.
the code space of jvm is vast and collecting coverage for each seed program takes about seconds.
the time required to apply existing coverage based methods to a large corpus is substantial.
similarly techniques based on known bugs require individual fuzzing for each seed program which further consumes significant time resources.
to mitigate this challenge we novelly designed several program featurebased methods and evaluated their performance.
iii.
s tudied initial seed selection methods drawing inspiration from existing works in the realm of traditional software we devised a set of initial seed selection methods tailored for jvm testing.
table i presents a summary of the studied ten methods including their types names inputs and search strategies.
these methods are categorized into three groups coverage based prefuzz based and program featurebased methods.
for simplicity we will use the term corpus to refer to the entire set of initial seeds in the following sections.
a. coverage based method two white box initial seed selection methods based on coverage metrics are introduced ciss pand ciss m. like peachset and minset ciss psorts seed programs based on coverage metrics then selects the top k percent as the corpus 3subset.
on the other hand ciss msorts these programs based on coverage increments and stops the selection process once all candidate seed programs show zero coverage increments.
to accommodate our experiment implementation when the selection process stops ciss mtransitions into a mode the same as ciss p. in this mode candidate seed programs are sorted based on coverage metrics.
likewise the top k percent of these programs is selected as the corpus subset.
note that when several seed programs have the same coverage we randomly select one of them to break the tie following the existing work .
b. prefuzz based method piss is a black box method adapted from hotset.
specifically piss performs fuzzing on each seed program for t seconds recording the number of bugs each seed program uncovers.
it then selects the top k percent with the highest number of bugs to form the corpus subset.
following the existing work we conduct fuzzing on each seed program for minutes t to compute the subset of initial seeds selected by piss in our experiments.
c. program feature based method previous work has emphasized the correlation between test program features and jvm fuzzing effectiveness .
specifically similar program features may possess the ability to trigger similar bugs or the absence of bugs.
moreover the triggering of bugs is frequently associated with specific program features rather than common ones.
hence we further propose a program feature based initial seed selection method fiss by extracting program features for evaluation.
based on whether we extract program features using statistical models or pre trained models we categorize them into traditional features and code semantics.
below we describe the process for extracting program features including traditional features and code semantics as well as the corpus subset selection.
traditional feature extraction.
three commonly utilized types of information in program analysis are selected textual information syntactic information and semantic information .
specifically we analyze the token sequence ts abstract syntax tree ast and control flow graph cfg of programs to extract traditional features respectively.
ts features each token in the corpus is treated as a dimension in the feature vector and the tf idf is used to compute the score of each token in the seed program.
tokens that are absent receive a value of .
ast features the java syntax analysis tool jdt is utilized to obtain the ast of each seed program and extract tree based n gram chains.
existing work has shown that setting n to yields better representation performance so we also extract gram chains for our method.
each gram chain in the corpus is regarded as a dimension in the feature vector and the frequency of occurrence of each gram chain in the seed program is counted.
chains that do not exist receive a value of .
cfg features the java bytecode analysis tool soot is used to obtain the cfg and extract graph based gram chains.
each node in the cfg represents a jimple instruction since soot analyzes bytecode using the intermediate language jimple.
similar to ast features we count the frequency of each gram chain in the seed program as a dimension in the feature vector.
as shown in table i the methods for initial seed selection using the above three features are referred to as fiss ts fiss ast and fiss cfg.
code semantic extraction.
recent studies have demonstrated the efficacy of leveraging pre trained code representation models in various software engineering tasks .
therefore employing pre trained models to obtain program feature vectors is intuitive.
particularly in the study of jvm testing the code representation models codebert infercode codet5 and plbart play a pivotal role in semantic vectorization.
encouraged by this we also adopt these four pre trained models aiming to explore their effectiveness in code representation for initial seed selection tasks.
to do so we use open source pre trained models directly for zero shot inference of the code representation vectors from each seed program.
if the seed program is too long it is then divided into slices and the code representation vectors for each slice are averaged.
as shown in table i the methods for initial seed selection using features extracted from these four pre trained models are referred to as fiss cb fiss ic fiss ct and fiss pb.
corpus subset selection.
after feature extraction fiss sorts all seed programs and selects the top k percent to form the corpus subset.
the greedy algorithm is applicable to sortable data e.g.
coverage information used by ciss and the number of detected bugs used by piss.
however fiss represents program features as vectors for selection which are unsortable so the greedy strategy is not applicable.
some techniques built on the concept of adaptive random testing art argue that uniformly distributed test cases are more likely to detect bugs with fewer test cases than ordinary random testing.
furthest point sampling fps is widely used in existing work to select uniformly distributed test cases .
following this we employ fps to sort the seed programs in the corpus by measuring distance between vectors as seed programs with similar program features may reveal similar bugs.
the central concept of fps is to prioritize selecting points that are farthest away from the centroid of the already selected points.
this strategy ensures that the selected points exhibit distinct features enabling the prioritization of more unique points in the process.
give a set of initial seeds denoted as s s1 s2 .. s n n refers to the number of seeds and the budget of initial seed selection denoted as k the target of fiss is to select kpercent of the seed programs from sas a corpus subset.
specifically fiss first needs to extract the feature vectors for each seed program denoted as v v1 v2 ... v n andvi f si where frefers to the feature extraction method and f si refers to the feature vector of si.
then fiss sorts the seed 4programs using fps.
to ensure stability we first compute the feature centroid of all seed programs as shown in formula .
c c1 c2 ... c m nnx i 1f si where cirefers to one dimension of a feature vector mrefers to the number of dimensions.
then fiss selects the point farthest from the centroid as the first seed program shown as in formula .
t1 arg max si sdist f si c where t1refers to the first selected point and dist vi c calculates the euclidean distance between feature vectors.
we usetto represent the set of seeds that have been selected.
for each seed si s t we need to compute its minimum distance from the selected seeds in the set tand select the seed with the maximum distance shown as formula .
tnext arg max si s tmin tj tdist f si f tj this iterative process continues until all seed programs are included in t indicating the completion of sorting.
lastly we exclusively select the top k percent of seed programs from tto compose the corpus subset.
iv.
e valuation design a. studied jvms in line with existing research focusing on jvm testing we studied three popular jvms hotspot openj9 and bisheng jdk.
table ii shows the summary of studied jvms with their versions.
unlike existing work we did not use openjdk12 as they are no longer maintained.
alternatively we added openjdk17 as a subject.
note that for openjdk each jvm includes both an older build and the latest build.
this is because relatively older jvm builds often contain more bugs which allows for a better evaluation of the fuzzer s effectiveness.
by comparing the outputs of older jvm builds to those of the latest builds we can calculate the evaluation metric of unique inconsistencies.
similarly by examining the outputs of the latest builds we can calculate the evaluation metric of unknown bugs.
further details regarding these evaluation metrics are provided in section iv d. b. studied corpus two types of corpus are studied benchmark corpus and open source corpus.
table iii provides basic information about these corpus where size represents the number of seed programs and inst represents the number of jimple instructions.
benchmark corpus.
to ensure fair evaluation we used the same corpus as the prior works focusing on jvm testing .
specifically we filtered out those corpus that contained only one seed program as they did not require seed selection.
finally we obtained two corpus that contained multiple seed programs i.e.
p1 and p2 for this study.
the studied two corpus consist of historical bug revealing test programs collectedtable ii studied jvm versions openjdk versionjvm implementationversion openjdk8hotspotbuild .
b70 build .
b06 openj9build openj9 .
.
build openj9 .
.
bisheng jdkbuild .
b13 build .
b12 openjdk11hotspot build .
.
openj9 build openj9 .
.
bisheng jdk build .
.
openjdk17hotspot build .
.
openj9 build openj9 .
.
bisheng jdk build .
.
shadow represents the used old build of the corresponding jvm.
table iii studied corpus id projectname size inst source p1 hotspot tests hotspot p2 openj9 tests openj9 p3 collectproject github from the hotspot and openj9 repositories containing and test programs respectively.
open source corpus.
to enhance the corpus diversity for jvm testing we propose a novel corpus sourced from the open source community on github containing a larger set of test programs.
figure provides an overview of the corpus collection process.
the process consists of three phases search compilation and differential testing.
1during the search phase we collected urls of projects from github using the following criteria the projects are written in java they have more than stars and the project structure is maven.
specifically we utilized the github api as our search tool and set the aforementioned criteria to retrieve repository urls.
because the github api limits the return to fewer than repositories we segmented the star counts to ensure that the number of repositories returned each time stays within this limit.
after the search phase we obtained a total of repository urls.
2during the compilation phase we first filtered out those repositories that either do not contain a pom.xml file or lack a main entry.
the presence of a pom.xml file facilitates the automation of the compilation process while the main entry point is essential for obtaining seed programs.
we successfully cloned of the surviving repositories locally for 5execute differential t esting phaseinconsistency consistencyseed programfailing program 3jvmsreport reportclonecompilation phase local repositoriescandidate programs 2compilesearch phase repository urlsgithub api 1crawl discard keepfigure automated collection of open source corpus compilation.
specifically we used the mvn package command to compile however if repositories lacked dependencies and could not execute the command we resorted to using javac to compile the main entry in the repository.
this approach ensures that we fully utilize each repository maximizing the potential for successful compilation.
after the compilation phase we filtered out repositories that either could not be compiled or did not have a successfully complied main entry.
finally repositories and main entries remained.
3during the differential testing phase we employed older jvm builds for testing.
the specific versions of them can be found in our replication package.
one issue with older jvms is that certain seed programs may directly trigger inconsistencies which could potentially interfere with the effectiveness of evaluations.
to mitigate this issue we performed an interference on the main entry in each repository to verify whether any of the seed programs were executing properly.
this extra step aids in ensuring that the seed programs are functioning as expected enabling us to identify and address any discrepancies before evaluations.
after the differential testing phase we filtered out repositories that did not obtain any consistent main entry leaving us with repositories.
in particular we filtered out inconsistent main entry classes.
as shown in table iii our proposed corpus referred to as p3 finally consists of seed programs and jimple instructions.
c. experimented fuzzers in this study two seed driven jvm fuzzers are selected javatailor and vect .
these two fuzzers construct a test program by synthesizing various code snippets i.e.
putting various ingredients extracted from historical bug revealing test programs into a new context provided by a given seed program.
they are state of the art and have outperformed other widely studied jvm testing techniques as demonstrated by prior work .
the detailed descriptions of these two fuzzers are presented in section ii.
note that we opted not to use the enhanced test oracle featured in vect.
this choice was made because we did not manually filter or modify the open source seed programs.
certain variables like randomness and timestamps can introduce non determinism.
therefore the correcting commit usedfor inconsistency deduplication may potentially introduce false positives which could impact our results.
therefore this study employed the same test oracle as javatailor in the evaluation.
considering the effectiveness of vect we adopted plbart as recommended in vect for semantic vectorization.
d. measurement time overhead to compare the time overheads of each initial seed selection method we recorded the time required for three key phases data collection data processing and corpus subset selection.
specifically during the data collection phase ciss needs to collect coverage data from the jvm and piss gathers the fuzzing results of each seed program.
on the other hand fiss directly utilizes program features thus eliminating the need for data collection.
during the data processing phase ciss constructs bitmaps to facilitate subsequent operations piss performs deduplication and counts the number of inconsistencies detected and fiss extracts program features and represents them as vectors for further analysis.
during the corpus subset selection phase either greedy strategies or farthest point sampling fps are employed for sorting and the top k percent of seed programs are selected.
number of unique inconsistencies in the differential testing experiments conducted on relatively older jvm builds each studied method is likely to detect some inconsistencies i.e.
potential real bugs false positives and duplicates during the same testing time.
therefore we executed another round of differential testing employing the latest jvm builds to verify whether the inconsistencies remain.
if the inconsistency disappears it suggests that a known bug has been fixed otherwise we performed manual analysis to determine whether the inconsistency is due to a potential bug.
additionally some inconsistencies may be duplicated due to the same bug hence we further de duplicated them based on the crash messages which is the most commonly used automatic method in existing work .
we used the number of inconsistencies after de duplication as the number of unique inconsistencies.
number of previously unknown bugs in the differentialtesting experiments conducted on newer jvm builds each studied technique is likely to detect some inconsistencies.
in rq3 we chose the more efficient vect to conduct differential testing experiments on the latest versions of jvm.
existing research demonstrates that while vect and javatailor share the same exploration space vect exhibits comparatively greater exploration efficiency .
to verify the authenticity of unknown bugs we manually analyzed each inconsistency to determine whether a discrepancy is a real bug.
then we created bug reports for test programs and submitted them to the corresponding repositories.
the number of unknown bugs is measured based on feedback from developers.
e. implementation and environment we implemented all initial seed selection methods in java.
the extraction and analysis of ast and cfg relied on apis provided by jdt and soot.
we utilized the pre trained code representation models from existing work using their 6table iv comparison results of different methods in terms of the number of unique inconsistencies javatailor vect p1fullset .
.
randomset .
.
.
.
.
.
cissm .
.
.
.
.
.
cissp .
.
.
.
.
.
piss .
.
.
.
.
.
fiss ts .
.
.
.
.
.
fiss ast .
.
.
.
.
.
fiss cfg .
.
.
.
.
.
fiss cb .
.
.
.
.
.
fiss ic .
.
.
.
.
.
fiss pb .
.
.
.
.
.
fiss ct .
.
.
.
.
.
p2fullset .
.
randomset .
.
.
.
.
.
cissm .
.
.
.
.
.
cissp .
.
.
.
.
.
piss .
.
.
.
.
.
fiss ts .
.
.
.
.
.
fiss ast .
.
.
.
.
.
fiss cfg .
.
.
.
.
.
fiss cb .
.
.
.
.
.
fiss ic .
.
.
.
.
.
fiss pb .
.
.
.
.
.
fiss ct .
.
.
.
.
.
the top performing methods are shaded.
darker shades indicating better performance.
default parameters without any fine tuning.
extraction of code representation and corpus collection is implemented in python.
to mitigate the effect of randomness all experimental results related to inconsistencies were averaged over five repetitions of experiments with each experiment set to run for hours.
experiments were conducted on a server with two dodecacore cpus intel r xe on r silver cpu .20ghz and 251gb ram running ubuntu .
.
lts bit .
v. r esult analysis a. rq1 performance of initial seed selection effectiveness of initial seed selection methods.
the budget of existing corpus minimization methods i.e.
peachset minset and optimin applied to p1 and p2 is mainly between and .
inspired by this to reduce the fuzzing budgets we initially selected subsets with budgets set at and .
then we applied each studied initial seed selection method with three budgets on benchmark corpus p1 and p2.
javatailor and vect conducted hours of fuzzing on each subset counting the number of detected unique inconsistencies.
table iv shows the comparison results of each method in terms of unique inconsistencies in the differential testing.
the fullset and randomset in the second column represent theuse of the entire set of initial seeds and the subset selected by random selection serving as baselines for comparison.
results highlighted in bold indicate superior performance compared to the fullset.
the top three performing methods are shaded with darker shades indicating better performance.
results.
from table iv we can observe that when compared to the full set fullset all three types of initial seed selection methods can outperform the full set within the given fuzzing time.
this finding confirms the necessity of performing initial seed selection in jvm fuzzing.
when compared to random selection randomset evaluation results suggest that randomly selecting a subset could have a negative impact which underlines the importance of carefully designing selection strategies.
when compared across the studied selection methods fiss cfgis the best performing method.
it outperforms fullset in all results yielding between .
and .
times higher performance and ranks in the top three in all column comparisons.
for example in javatailor and p2 the number of unique inconsistencies for the three budgets is .
.
and .
respectively compared to .
when using fullset.
the possible reason is that semantic information effectively represents the feature of the program thereby enhancing the effectiveness of sorting in fps.
fiss astfollows behind fiss cfg as it extracts features using ast which is likely to have a coarser granularity compared to cfg.
the pretrained model methods such as fiss cband fiss ic tend to exhibit relatively unstable and inferior performance.
this could potentially be attributed to these models not being fine tuned specifically for initial seed selection tasks.
meanwhile we noted that while coverage based methods excel in traditional program fuzzing the extensive code space within the jvm poses a challenge.
ciss pand ciss mare likely unable to effectively leverage coverage for assessing the quality of seed programs suggesting that a significant portion of the coverage may not be relevant for inconsistency detection.
finding i the initial seed selection that utilizes control flow graph fiss cfg outperforms all other studied methods yielding between .
and .
times the results of fullset within the same test time with an average improvement of .
effectiveness of budget selection.
it is unknown whether the established budget sizes from the existing corpus minimization are the most effective for jvm fuzzing.
particularly we study a variety of initial seed selection methods and certain strategies may perform better given a specific budget.
hence we extend our investigation to include a wider budget range spanning from to .
for our exploratory analysis we specifically evaluated the effectiveness of these budgets on the p1 corpus and the vect fuzzer.
table v shows the average results of five repeated experiments with shadows representing the best performers in each row.
results.
from table v we can observe that regardless of the budget size the studied initial seed selection methods 7table v the number of inconsistencies with different budgets method cissm .
.
.
.
.
.
.
cissp .
.
.
.
.
.
.
piss .
.
.
.
.
.
.
fiss ts .
.
.
.
.
.
.
fiss ast .
.
.
.
.
.
fiss cfg .
.
.
.
.
.
.
fiss cb .
.
.
.
.
.
.
fiss ic .
.
.
.
.
.
.
fiss pb .
.
.
.
.
.
.
fiss ct .
.
.
.
.
.
.
relatively achieve superior performance when compared to the full set and the random selection.
most coverage based hotset based and traditional feature based methods tend to perform better with smaller budgets.
for instance the number of inconsistencies for ciss mand fiss cfgranges from .
to .
and .
to .
respectively when the budgets are between and while the number of inconsistencies ranges from .
to .
and .
to .
respectively when the budgets are between and .
conversely the four pre trained model methods are likely to achieve better performance with relatively large budgets.
for example fiss ic fiss pb and fiss ctachieve the best performance when the budget is with the number of inconsistencies being .
and respectively.
the potential reason is that these models were not specifically optimized for tasks related to selecting initial seeds.
fiss cfgconsistently delivers the best performance across most except budget ranges demonstrating its effectiveness in jvm fuzzing.
when the budget for fiss cfg is set between and the top three results can be achieved further confirming the initial budget setting choice in prior experiment.
we suggest setting the fiss cfgbudget to as it provides the best outcomes across various budgets.
finding ii fiss cfg continuously achieves the top performance across a wider range of budget settings.
specifically we recommend using fiss cfg with a budget set of for initial seed selection which has been found to achieve optimal performance.
efficiency of initial seed selection methods.
table vi presents the time overhead of each initial seed selection method on corpus p1 including three phases data collection data processing and initial seed selection.
as similar trends are observed across different corpus we only provided the results on p1.
note that the budget setting and fuzzing techniques do not affect the time overhead as we sort the seed program first.
results.
as shown in the table the total time overhead of all the traditional feature based methods requires no more than seconds to select corpus subsets i.e.
26s 4s and 30s for fiss ts fiss ast and fiss cfg respectively whichtable vi time overhead of each method in p1 methoddata collectiondata processingseed selectionsum cissm s s s s cissp s s s s piss s s s s fiss ts s s s s fiss ast s s s s fiss cfg s s s s fiss cb s s s s fiss ic s s s s fiss pb s s s s fiss ct s s s s is significantly faster than the other methods.
for the methods based on pre trained models results show that most of the time is spent on data processing when compared to traditional ones.
for the prefuzz based method piss a considerable amount of time i.e.
700s is taken to collect data as it necessitates fuzzing each seed program for five minutes.
coverage based methods ciss exhibit the highest time overhead across all three phases taking over hours in total as it collects the coverage of each seed program for more than seconds.
finding iii traditional feature based methods have a significantly smaller time overhead compared to other methods.
more specifically fiss cfg not only enhances the effectiveness of jvm fuzzing but also demonstrates its efficiency.
b. rq2 initial seed selection on programs in the wild to evaluate the effectiveness of initial seed selection on programs in the wild we first confirm the importance of the collected open source corpus p3 by analyzing the overlap of unique inconsistencies detected across the studied corpus i.e.
p1 p2 and p3 .
then we validate the generalizability of initial seed selection by repeating the experiments of rq1 on the p3 corpus.
for the first analysis we conducted fuzzing on fullset by employing the same experimental settings from rq1.
for each corpus we collated all inconsistencies detected by two fuzzers over five repeated runs and then eliminated duplicates based on crash messages.
for the second analysis we applied each studied initial seed selection method on p3 with a wider budget range i.e.
spanning from to .
we also performed an overlap analysis for the best performing method.
the venn diagrams in figure show the results of the inconsistency overlap analysis while table vii records the results of the performance at various budgets.
results.
from figure 2a we found that each studied corpus can detect some unique inconsistencies with the full set i.e.
for p1 p2 and p3 respectively.
this finding suggests that the open source corpus and the existing benchmark corpus complement each other.
in addition the results show that p3 detected a total of unique inconsistencies while p1 and p1 p2 p3 a fullset p1 p2 p3 b fiss cfgwith budget figure inconsistency overlap p2 were able to detect and inconsistencies separately.
this indicates that the open source corpus is less effective in detecting unique inconsistencies and the quality of its seed program is relatively lower.
from table vii we observed that on the open source corpus fiss cfg still emerges as the best selection method consistently ranking in the top three with an improvement of .
to compared to the full set.
for example when the budget is set at the number of detected unique inconsistencies with fiss cfgreaches .
for javatailor and .
for vect.
besides selection methods relying on pretrained models show substantial performance enhancements.
a possible reason is that similar to p3 pre trained models also use github as a data source which could potentially enhance the representation of code semantics.
this further illustrates that the lack of fine tuning leads to the poor performance of pre trained model based methods on p1 and p2.
from figure 2b we noticed that the most effective seed selection method fiss cfgwith a budget allows p3 to identify a comparable number of unique inconsistencies as p1 and p2.
for instance the number of unique inconsistencies detected with p1 p2 and p3 is and respectively.
moreover the number of unique inconsistencies detected by p3 improves significantly when compared to the full set i.e.
and for fiss cfgand fullset respectively.
the above results suggest that the initial seed selection can enhance the effectiveness of programs in the wild and further improve the fuzzing capability.
finding iv programs in the wild complement widelystudied initial seeds by detecting new jvm behaviors.
selection methods relying on pre trained models achieve substantial performance improvements in the open source corpus.
nonetheless fiss cfgremains the best performing method with an improvement of .
to and enhances the effectiveness of the opensource corpus.
c. rq3 detection of previously unknown bugs we further investigated whether the initial seed selection helps enhance jvm fuzzing techniques in detecting previously unknown bugs through the differential testing experiments on the latest builds.
specifically we applied vect on all studied corpus as it has been proven to be state of the art .
for a uni00000037 uni0000004c uni00000050 uni00000048 uni0000000b uni0000004b uni0000000c0246810 uni00000031 uni00000058 uni00000050 uni00000045 uni00000048 uni00000055 uni00000003 uni00000052 uni00000049 uni00000003 uni00000058 uni00000051 uni0000004e uni00000051 uni00000052 uni0000005a uni00000051 uni00000003 uni00000045 uni00000058 uni0000004a uni00000056 fullset fisscfgfigure trend of bugs detected by fiss cfgand fullset fair comparison we ran vect hours on both the fullset and the subsets selected by each method with a budget.
we then submitted the detected inconsistencies on the latest builds to the corresponding developers to check whether it was a real bug.
table ix shows the total number of bugs discovered by each initial seed subset across the three studied corpus within the same testing period and figure shows the trend of bugs for fullset and fiss cfg.
results.
as shown in talbe ix fiss cfg is the bestperforming method across all the studied selection methods yielding between .
and .
times higher performance.
figure further shows the trend of the number of bugs detected by fullset and fiss cfgover time where the x axis represents the testing time while the y axis represents the number of unknown bugs detected by fullset and fiss cfg within the corresponding testing time.
as shown in figure fiss cfg detected more unknown bugs than fullset during the entire testing process specifically and bugs respectively.
in the first hours of fuzzing fiss cfgwas able to detect unknown bugs more quickly.
this is anticipated as fiss cfg selects a subset with higher quality for the corpus resulting in enhanced bug discovery capabilities.
notably all five bugs detected by fullset were also detected by fiss cfg further emphasizing the superiority of initial seed selection.
we also conducted a large scale fuzzing experiment by applying fullset and fiss cfg for each corpus to vect with a total of over hours which aimed to evaluate the time overhead required by fullset to detect the same number of unknown bugs as fiss cfg.
we found that fullset detecting all the bugs detected by fiss cfgrequired over hours in total.
this further demonstrates that the initial seed selection method fiss cfgsignificantly improves jvm fuzzing performance.
in total previously unknown bugs were detected by our initial seed selection methods in our experiments of which have been confirmed and fixed by developers.
table viii shows the information about these bugs.
among these were bugs that could only be detected by p3 further highlighting the significance of the open source corpus in enhancing jvm fuzzing techniques.
we then used a previously unknown bug detected by p3 as an example to illustrate the effectiveness of open source corpus.
figure shows a simplified synthesized test program that triggers a runtime check bug in openj9 9table vii comparison results on programs in the wild in terms of the number of unique inconsistencies javatailor vect p3fullset .
.
randomset .
.
.
.
.
.
.
.
.
.
.
.
.
.
cissm .
.
.
.
.
.
.
.
.
.
.
.
.
.
cissp .
.
.
.
.
.
.
.
.
.
.
.
.
.
piss .
.
.
.
.
.
.
.
.
.
.
.
.
.
fiss ts .
.
.
.
.
.
.
.
.
.
.
.
.
.
fiss ast .
.
.
.
.
.
.
.
.
.
.
.
.
.
fiss cfg .
.
.
.
.
.
.
.
.
.
.
.
.
.
fiss cb .
.
.
.
.
.
.
.
.
.
.
.
.
.
fiss ic .
.
.
.
.
.
.
.
.
.
.
.
.
.
fiss pb .
.
.
.
.
.
.
.
.
.
.
.
.
.
fiss ct .
.
.
.
.
.
.
.
.
.
.
.
.
.
table viii confirmed or fixed unknown bugs bug id jvmaffected openjdkstatus corpus openj9 fixed p1 openj9 fixed p1 openj9 fixed p1 p2 p3 openj9 fixed p1 openj9 fixed p2 openj9 fixed p3 openj9 confirmed p1 openj9 confirmed p1 p2 p3 openj9 fixed p1 p2 openj9 confirmed p1 openj9 fixed p3 openj9 confirmed p1 openj9 fixed p1 openj9 confirmed p1 jdk hotspot confirmed p3 jdk hotspot confirmed p3 jdk hotspot confirmed p1 p2 jdk hotspot confirmed p3 i98gap bisheng jdk confirmed p1 p2 i98gco bisheng jdk confirmed p3 i98gd8 bisheng jdk confirmed p3 as detected by p3.
in this example lines shaded green lines represent the ingredient that was inserted while lines shaded blue lines represent the root cause of the bug.
the original seed program code does not throw any exception so the failed s value is false which causes the branch containing the bug not to be executed.
vect inserts an ingredient containing a nullpointerexception which causes the value of failed to be changed to true line .
in the branch the synthetical program first news an anonymous inner class i.e.
testcase and tries to get its enclosing class line .
if testcase is a normal inner class openj9 needs to check whether the inner class and its enclosing class have the same innerclass attribute.
however openj9 incorrectly applies this check to anonymous inner classes and throws anincompatibleclasschangeerror .
the developers public static bool failed false public static void main string var0 try ... int var0 null.test ... catch throwable e failed true if failed class var1 new testcase .getclass class var2 var1.getenclosingclass ... 15figure openj9 bug of openj9 have confirmed and fixed this bug.
note that this bug only can be detected by p3 since this bug requires the seed program to new an anonymous inner class and call the getenclosingclass function.
finding v initial seed selection enhances jvm techniques for detecting more previously unknown bugs given the same testing period with being already confirmed and fixed by developers.
seven of them can only be found by the open source corpus.
vi.
i mplications and future work designing a task specific initial seed selection method is crucial.
as shown in rq1 and rq2 methods widely evaluated in traditional software testing are not suitable for jvm testing due to the characteristics of large scale and intricate code in jvm.
inspired by existing work we propose program featurebased selection methods and demonstrate their superiority.
these findings suggest a need to design task specific seed selection methods as different test subjects often exhibit unique characteristics.
for efficiency and effectiveness we recommend using the fiss cfg method which demonstrated the most practical in our jvm testing experiments.
10table ix comparison results of different methods in terms of the number of previously unknown bugs method fullset ciss m cissp piss fiss ts fiss ast fiss cfg fiss cb fiss ic fiss pb fiss ct unknown bugs5 selecting an optimal corpus budget is significant.
the results shown in table v indicate that different initial seed selection methods tend to achieve the best performance at varying corpus budgets.
specifically we recommend using fiss cfgwith a budget for initial seed selection which has been found to optimize performance and resource utilization in jvm fuzzing.
future work could focus on refining and implementing an adaptive budget selection algorithm for fiss cfg in order to determine the minimum corpus budget required for the best performance.
exploring open source corpus for improving jvm fuzzing is beneficial.
existing work often used the same corpus as older works for fuzzing even when proposing new techniques thus neglecting the significance of the diverse corpus.
our rq2 results confirmed that different corpus exhibit complementary effectiveness by detecting new behaviors and bugs.
significantly the findings reveal that the initial seed selection can improve the quality of the open source corpus.
hence future work could further mix all corpus for further selection and integrate their diverse testing capability to enhance overall effectiveness.
fine tuning the pre trained model for initial seed selection shows promise.
as shown in table iv pre trained modelbased fiss achieves substantial performance enhancements on the open source corpus compared to the benchmark corpus.
this is because the open source corpus data is collected from github which enhances the learning of code semantics.
to further improve effectiveness future work will involve fine tuning the pre trained code representation models across various programming languages and compilers to better fit the downstream task of initial seed selection.
vii.
t hreats to validity external threats to validity primarily lie in the corpus and fuzzers used in our study.
firstly we eliminated seed programs that can directly identify inconsistencies to prevent interference with fuzzing results.
in the future we plan to incorporate additional corpus to further mitigate the threat.
secondly although these initial seed selection methods can be generalized to any jvm fuzzer that takes seeds as input we only evaluated the impact of initial seed selection on javatailor and vect.
we selected them as the representatives due to their state of the art effectiveness and general testing purposes e.g.
jitfuzz targets the jit component only .
construct threats to validity mainly stem from the duration of each fuzzing process and its randomness.
despite our best efforts to assess the impact of initial seed selection and opensource corpus on jvm fuzzing effectiveness the fuzzing time we have set is considerably shorter than that in industrial fuzzing.
due to resource constraints we are unable to extendthe fuzzing time for each iteration.
besides the execution of the fuzzer and breaking ties involve randomness.
to reduce the impact of this randomness we performed each experiment five times using different random seeds.
internal threat to validity mostly lies in the implementations of each technique.
to mitigate this threat we relied on the available apis to extract ast and cfg and utilized the pretrained code representation models with their default settings.
viii.
c onclusion this work designed a total of initial seed selection methods i.e.
coverage based prefuzz based and program featurebased in order to enhance the jvm fuzzing effectiveness.
we conducted an empirical study on three jvm implementations with javatailor and vect to comprehensively evaluate the performance of initial seed selection methods.
the results highlight that the subset selected by initial seed selection outperforms the entire set of initial seeds.
in particular the method utilizing control flow graphs performs the best.
furthermore the study emphasizes the benefits of incorporating programs in the wild demonstrating the complementary effectiveness with the existing benchmark corpus.
in addition given the same testing period initial seed selection can enhance fuzzing techniques by detecting more previously unknown bugs with bugs having been confirmed or fixed by developers.
our work also opens up several promising future directions including determining the minimum corpus budget fine tuning pre trained code representation models for better fitting the downstream task and mixing diverse corpus for selection.
data availability.
the replication package that supports the findings of this study is available publicly .
acknowledgment we thank all the icse anonymous reviewers for their valuable comments.
we also thank all the jvm developers for analyzing and replying to our reported bugs.
the work has been supported by the national natural science foundation of china grant nos.
ccf young elite scientists sponsorship program by cast and huawei fund.