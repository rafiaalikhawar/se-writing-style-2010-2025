ztd ja v a mitigating software supply chain vulnerabilities via zero trust dependencies paschal c. amusuo purdue universitykyle a. robinson purdue universitytanmay singla purdue universityhuiyun peng mount holyoke college aravind machiry purdue universitysantiago torres arias purdue universitylaurent simon googlejames c. davis purdue university abstract third party libraries like log4j accelerate software application development but introduce substantial risk.
vulnerabilities in these libraries have led to software supply chain ssc attacks that compromised resources within the host system.
these attacks benefit from current application permissions approaches third party libraries are implicitly trusted in the application runtime.
an application runtime designed with zerotrust architecture zta principles secure access to resources continuous monitoring and least privilege enforcement could mitigate ssc attacks as it would give zero implicit trust to these libraries.
however no individual security defense incorporates these principles at a low runtime cost.
this paper proposes zero trust dependencies to mitigate ssc vulnerabilities we apply the nist zta to software applications.
first we assess the expected effectiveness and configuration cost of zero trust dependencies using a study of third party software libraries and their vulnerabilities.
then we present a system design ztd sys that enables the application of zero trust dependencies to software applications and a prototype ztd ja v a for java applications.
finally with evaluations on recreated vulnerabilities and realistic applications we show that ztd ja v a can defend against prevalent vulnerability classes introduces negligible cost and is easy to configure and use.
i. i ntroduction integrating third party libraries tpls such as log4j as dependencies accelerates software application development but introduces risks .
dependencies are implicitly trusted by default and execute with the application s permissions.
vulnerabilities in dependencies termed software supply chain ssc vulnerabilities may cause undesirable application behavior .
they result in ssc attacks .
to mitigate analogous risks from assets in cloud systems and corporate networks the us national institute of standards and technology nist has recommended and industry and academia have adopted the zero trust architecture zta to place zero implicit trust in system actors.
we propose applying zta within a software application to mitigate the risk of ssc vulnerabilities figure .
many security defenses reduce the risks of using tpls within an application.
however none sufficiently mitigates ssc vulnerabilities as they do not enable the zta principles of secure resource access continuous monitoring and least privileges for the application s dependencies and at low runtime cost ii c .
application level sandboxes do not operate on dependencies.
import restriction based and debloating based approaches do not validate some work performed as a student researcher at google.
fig.
the zero trust dependencies ztd concept.
to mitigate attacks exploiting vulnerable dependencies a ztd system provides secure access via runtime authorization makes authorization decisions using a least privileges access policy and facilitates continuous monitoring of unexpected accesses.
when dependencies access resources.
existing isolation based techniques do not enable discovery of dependencies least privileges and they introduce high runtime costs.
this paper proposes zero trust dependencies figure a concept that applies nist s zero trust architecture to an application s dependencies to prevent software supply chain attacks.
we begin with a feasibility study of the zero trust architecture idea clarifying its suitability and design considerations through a study of software supply chain vulnerabilities and application dependency chains iii .
motivated by our findings we state the threat model iv a propose zerotrust dependencies as a mitigation iv b and design a ztd system ztd systo enable secure resource access iv d discover least privileges iv e and continuously monitor dependency behaviors iv f .
we implement a prototype ztd ja v a for java applications v .
we evaluate its effectiveness on recreated vulnerabilities micro and macro performance costs and the effort to audit policies of real applications.
our results show that fine grained enforcement of a library s observed behavior representing its least privileges prevents all reproduced vulnerability exploits.
ztd ja v a introduces much lower overhead than the state of art for java.
additionally only an average of five dependencies in each application require explicit policy specification.
in summary we contribute a feasibility study of applying zero trust architecturearxiv .14117v3 dec 2024principles within a software application iii .
the zero trust dependencies concept and our ztd sys design for mitigating ssc vulnerabilities iv .
a prototype for java ztd ja v a v and an evaluation of its cost and effectiveness on realistic java applications vi .
significance operationalizing a recommended security architecture will enable its adoption in software engineering leading to more secure applications.
our feasibility study design and evaluation will inform engineers of the utility and cost of adopting this security architecture in their applications.
ii.
b ackground here we define software supply chains and vulnerabilities ii a introduce zero trust architecture as a mitigation ii b and discuss limitations of existing defenses ii c .
a. software supply chains ssc and vulnerabilities from a technical standpoint software supply chains encompass the systems and devices involved in producing a final software product .
this includes the application s source code build tools final packaged artifact and thirdparty libraries used as dependencies .
the use of thirdparty libraries introduces new attack surfaces.
they can be deliberately or unintentionally e.g.
listing introduced.
these vulnerabilities are software supply chain ssc vulnerabilities and they enable ssc attacks that compromise the host system and lead to consequences such as execution of arbitrary code file manipulation and exfiltration of sensitive data.
ssc attacks typically succeed because vulnerable dependencies inherit the application s permissions obtaining more privileges than they need in typical use .
ssc vulnerabilities can be mitigated by securing the structure and use of a software supply chain.
per okafor et al.
secure supply chains need transparency where dependencies come from and what risks they contain validation reliability of dependencies and separation dependency isolation to avoid domino effects .
transparency can be improved through techniques such as software bills of materials sboms and the open source vulnerabilities project .
validity is promoted through software signing to verify the provenance of third party libraries and the end to end security model that prevents unauthorized alteration of source code.
our zero trust dependencies concept inspired by nist s zero trust architecture improves separation between dependencies.
b. zero trust architecture as a conceptual framework ii a suggests that ssc vulnerability exploits succeed because dependencies are granted permission to access more resources than they typically need.
the zero trust architecture zta protects access to resources in the context of a network and may analogously effectively mitigate ssc vulnerabilities.
as defined by the usa s national institute of standards and technology nist in sp zerotrust architecture is a set of cybersecurity concepts focused on protecting services resources within a system grants no1public void exploittarget string command exploit command httpurlconnection con new url url .openconnection con.setrequestmethod post con.setrequestproperty spring.cloud.function.routing expression t java.lang.runtime .getruntime .exec command int response con.getresponsecode listing an exploit for a code injection vulnerability cve in spring cloud function scf .
on lines an attacker executes a malicious command by using scf s routingexpression functionality.
executing shell commands is not a privilege scf needs and thus would be blocked by a zero trust architecture.
implicit trust to any user or assets subjects and requires subjects to gain explicit authorization to access any resource.
following google we summarize zta in principles secure and context based access every access to a resource should be authorized.
continous monitoring organizations should monitor the state and activities of the subjects and use the insights gained to improve the creation and enforcement of policies.
least privilege policy enforcement access policies should grant minimum access rights to subjects.
the zero trust architecture has been applied to securitysensitive domains including network infrastructure and cloud systems .
when applied to software applications zta can mitigate ssc vulnerability exploits as it authorizes only legitimate access to operating system resources based on a dependency s minimum privileges set.
c. limitations of existing application security defenses existing security defenses reduce some risks from thirdparty libraries but do not prevent ssc vulnerability exploits as they do not enforce zero trust principles on all dependencies.
we summarize these techniques in table i. application level defenses enforce security policies on the application or its logical units .
however as dependencies inherit the application s permissions vulnerable dependencies may compromise sensitive system resources by leveraging permissions provided to the application.
in addition specifying security policies that enforce least privileges in modern applications is difficult and error prone .
the java security manager jsm an application level defense for java applications allows specifying fine grained policies for secure resource access in java applications.
it was deprecated in due to lack of use ascribed to its brittle permission model difficult programming model and poor performance .
dependency level defenses operate on dependencies and can constrain their behaviors at runtime.
we distinguish three kinds.
import restriction based defenses intercept dependencies as they are imported into an application andtable i analysis of existing security defenses by zta principles.
columns indicate if each technique family provides secure resource access supports least priv.
discovery and enforcement enables continuous monitoring for dependencies and has low runtime costs.
family design res.
accesslstprv.
enf.dep.
mon.low cost access control app decomp.
import restrict.
debloating isolation ztd ja v a access control remove unauthorized functions.
meanwhile debloating based defenses remove unused or vulnerable functions from a library s source code.
these designs prevent malicious code introduction in dependencies and introduce lower run time costs.
however they do not validate dependency resource accesses and cannot prevent exploits of accidental vulnerabilities where the attacker only controls data in the app.
isolation based defenses execute dependencies in isolated compartments and can enable secure access to resources.
however they face low adoption rates in part due to their high performance overhead and the effort required to discover the least privileges of a compartment.
iii.
z ero trust architecture feasibility analysis previous works have demonstrated the feasibility of secure context based access zta principle and dependency monitoring zta principle .
however no relevant security defense ii c has assessed the feasibility of least privilege definitions for dependencies.
this section measures two distinct aspects of applying the principle of least privilege policy on dependencies.
first zta requires that ssc vulnerability exploits on a dependency involve resources not needed by that dependency so that a least privilege policy would mitigate these vulnerabilities without impacting the application.
second zta requires that the cost of correctly configuring least privilege policies be reasonable e.g.
that only a few dependencies need privileges and require policy specification.
thus we ask rq1 what proportion of java ssc vulnerabilities could be mitigated by enforcing least privilege policies?
rq2 what proportion of dependencies will need explicit policy authorization in an application?
to answer these questions we measure ssc vulnerabilities and third party libraries in the java ecosystem.
why java?
we situate this feasibility study and our subsequent embodiment of ztd within java.
java is a popular programming language and ssc attacks have been the most impactful in the java ecosystem.
for example thelog4j vulnerability affected millions of java applications with estimated costs in the billions .
while there have been ssc attacks in other ecosystems like javascript and python their impact has been smaller due to their smaller server side industry footprints.
novelty prior works have studied the life cycle and dependency tree propagation behaviors of ssc vulnerabilities.
this study instead describes how ssc vulnerabilities access resources in third party libraries.
a. methodology rq1 we evaluated rq1 by assessing the proportion of java ssc vulnerabilities that involved access to operating system resources and examining whether they can be mitigated by coarse or fine grained least privilege policy enforcement.
we study recent and high severity vulnerabilities in popular maven central libraries as they represent prevalent and high impact threats to applications.
we obtained the vulnerabilities from the open source vulnerabilities osv database .
we filtered for vulnerabilities that were published within the last years had a cvssv3 rating of high or critical and affected the top depended upon maven central libraries from the ecosystems database .
this yielded vulnerabilities in unique libraries.
to answer rq1 we randomly analyzed of the vulnerabilities .
this number is comparable to the number of vulnerabilities prior works studied.
first we classified them using the taxonomy of web security vulnerabilities and their exploitation impact .
we report the proportion of vulnerabilities whose impact enables malicious access to resources.
for these vulnerabilities we identified the resources they expose and the api that the vulnerable code uses to access the resource.
we also compiled a list of apis that vulnerable libraries used to access each resource type.
next we used codeql and the compiled list of apis to search for api calls that access the exposed resource in the affected library.
if no calls were found a coarse least privilege policy that denies access to the specific resource type would prevent an exploit.
however if api calls were found a finegrained policy would be needed that only authorizes access to legitimately needed resource objects.
rq2 rq2 estimates the proportion of dependencies that access sensitive resources and would need policy authorization.
from a library perspective we measured the proportion of popular maven central libraries with direct access to os resources.
from an application perspective we measured the proportion of dependencies in real applications that access os resources during runtime.
the results provide an upper bound and a common estimate of the number of dependencies that would require explicit policies.
high values would threaten the feasibility of zta when applied to software dependencies.
for the upper bound we obtained maven central libraries sorted by their number of dependents from the ecosystems database for our analysis.
libraries could this represents an confidence interval at a confidence level.table ii vulnerability classes in java third party libraries.
the table shows the consequences of exploitation the required access to the operating system and the count.
we also cite common weakness enumerations cwes associated with each vulnerability class.
vuln.
class consequence os resource perc deserialization remote code exec.
shell fs21 access control unauth.
app access n a resource exhaust.
denial of service n a code injection remote code exec.
shell path traversal file read write fs xss csrf unauth.
web access n a xxe data exfiltration fs net command injec.
remote code exec.
shell impl.
flaw varies n a others varies n a total not be cloned and failed to build due to missing dependencies.
similar to rq1 we used codeql to analyze the remaining libraries identify sensitive api calls and report the percentage of libraries that access each type of resource.
for the common estimate we used the dacapo benchmark suite for java consisting of applications including a web server tomcat web application framework spring ide eclipse database cassandra and message bus kafka and workloads that imitate industry needs .
four applications did not build or run and we could not get the list of dependencies for nine applications.
we analyzed the dependencies of the remaining nine applications using our codeql scheme.
we instrumented the nine applications to record the resources each dependency accessed executed the applications and compared the resources that the dependencies accessed at runtime with the resources that the dependencies can access as indicated in their codeql results.
b. results rq1 will least priv policies mitigate ssc vulns?
finding rq1 of java ssc vulnerabilities can compromise an operating system resource.
of can be mitigated using a coarse grained least privilege policy.
require finer grained least privilege policies that can control the resource objects they access.
table ii shows the different vulnerability classes in java third party libraries and the operating system resources they expose.
five vulnerability classes comprising of vulnerabilities provide access to the file system network and shell.
they enable a malicious actor to manipulate files exfiltrate data and execute commands remotely.
from a study of malicious libraries ohm et al.
found that these objectives represented of the analyzed attackers goals.
table iii second section shows the number of vulnerabilities that expose different resource types and the proportiontable iii operating system resources exposed by vulnerabilities.
rq1 vulns shows the vuln.
count and indicates whether the vuln.
library can access the resource.
rq2 maven first column shows the proportion of analyzed maven central libraries that can access these resources directly.
rq2 maven second column a b shows the number of dependencies out of that can access a resource a and that accessed the resource within a dacapo application b .
rq1 vulns rq2 maven os resourcevuln countno accessaccess totalcaps usage file read file write network connection7 shell execution36 of vulnerable libraries that need access.
some vulnerabilities expose multiple resources.
in of cases the shell is exposed when not needed.
a coarse grained policy can prevent these accesses.
in contrast in the instances where file i o or network access is exposed the vulnerable component did not need the respective resource in only instances .
for cases where the affected library needs the exposed resource a more fine grained notion of privilege would be needed e.g.
permitting access to some files or remote hosts but not others.
these observations guide our policy definition in iv c2.
rq2 how many deps.
need explicit least priv.
policies?
finding rq2 in our upper bound estimate and of maven central libraries would require permissions to directly access file network and shell resources respectively.
however only of the dependencies in applications required explicit least privilege policies.
our library focused result is shown in table iii last two columns .
first less than of the popular third party libraries of the maven central ecosystem directly access any particular resource.
for example while vulnerabilities provide access to the shell only of the vulnerable libraries and of popular maven central libraries require shell permissions.
from an application perspective in the studied applications comprising dependencies while up to dependencies could access the file system only dependencies and dependency read or wrote to a file within the application.
similarly while dependencies could execute shell commands none of the dependencies executed a shell command while executed by the application.
c. discussion zta effectiveness per table ii of ssc vulnerabilities allow resource compromise and can be mitigated by a secure access control system.
of these could be addressed with a coarse grained least privilege policy based on resource type access while require finer grained policies based on specific resource objects.
recall that existing ssc se curity defenses support only coarse grained privileges ii c and thus are ineffective against of ssc vulnerabilities.
zta configuration cost to effectively apply zta one must specify policies for application dependencies defaulting to no trust .
hence the configuration cost depends on the number of dependencies that require policy specification.
a high configuration cost would make zta impracticable in this context.
table iii shows that most dependencies do not require access to sensitive resources.
when they might the access is typically not used by their dependents.
study limitations we note two cases in which our codeql measurement will fail.
first a resource might be accessed with an api not covered by our queries which we mitigated by building queries based on real exploits.
second a resource might be accessed through indirection e.g.
callbacks or java reflection .
this threat is a consequence of using static analysis which we chose for its scalability.
iv.
z ero trust dependencies concept and design this section introduces zero trust dependencies ztd as a security architecture that mitigates ssc vulnerabilities.
we outline the threat model in iv a define zero trust dependencies in iv b and discuss design considerations for different ztd syscomponents iv c iv f .
a. system and threat model system model an application depends on a vulnerable thirdparty library that can access system resources using untrusted i.e.
user controlled application data shown in iii .
the resource access operation can be initiated by the vulnerable dependency but executed directly using function calls or callbacks or asynchronously in independent or child threads by other dependencies or the application itself .
threat model we include some threats and exclude others.
in scope the attacker controls either the source code of the vulnerable dependencies or the data that the application passes to the vulnerable dependency.
hence they can compromise the confidentiality and integrity of the host system by exploiting the vulnerabilities in the dependency.
out of scope we do not consider threats from the ssc vulnerabilities that cause denial of service or unauthorized application access shown in table ii.
denial of service attacks can compromise the application s availability but they can be easily detected by monitoring the application .
sensitive application functions should require additional authorization and should not be accessible from code injection attacks.
this threat model is stronger than the import restriction and debloating based models ii c as it also prevents exploits that only control data passed into the dependency.
b. the zero trust dependencies concept nist s zero trust architecture protects resources within a network ii b .
in this paper we define resources in the software application context as data and computing services provided by the operating system os that an application can operate on.
data services include the file and network system which enable access to confidential information that the os or its applications produce or use.
computing services include the shell execution system that executes shell commands in the os.
operations refer to read write and execute rwx operations that can be performed on these resources.
to mitigate the use of ssc vulnerabilities to compromise system resources we introduce zero trust dependencies as an adaptation of the nist zero trust architecture ii b to the context of software applications.
zero trust dependencies is a software engineering paradigm that grants noimplicit trust to dependencies in an application.
it requires that dependencies possess explicit authorization to create or operate on resources within the application s operating system.
zero trust dependencies involves three principles ztd p secure access the access of dependencies to resources should be authorized using the configured access policies and the application s execution context.
ztd p least privileges enforcement the access policies should reflect the least privilege set that dependencies require to operate within the application.
ztd p continous monitoring the software engineers should be able to continuously monitor the resource access of dependencies and use the insights gained to improve threat intelligence and policy specification.
the ztd paradigm s security guarantee is an application s dependencies cannot compromise the confidentiality orintegrity of the operating system s resources.
consequently ztd reduces the risks that applications face from using thirdparty libraries.
dependency level security defenses in ii c do not enforce the three ztd principles in an application.
hence we also introduce the ztd system or ztd sysfor short .
aztd system is the set of access control policy designs algorithms and tools that enable software engineers to apply the ztd paradigm in their applications.
c. ztd policy design zero trust dependencies require policies that specify the least privileges of dependencies.
we propose ztd permission model the ztd permission model is designed to protect resources within the operating system that vulnerability exploitation may expose.
we use the access matrix terminology from sandhu et al.
to describe the ztd permission model.
permissions are given to dependencies to perform operations on resource objects.
table iv shows the three resource types supported and the operations that can be performed.
we focus on high risk resource types to simplify policy files and reduce permission verification frequency.
these resource types are high risk because they enable code execution data exfiltration and file manipulation attacks i.e.
the major targets of supply chain attacks .
coarse grained policy com.app.bar fs.read true fs.read.denied ... fine grained policy com.foo.baz fs.write true fs.write.allowed runtime.exec true runtime.exec.transitive ... listing policy specification file.
it supports coarse grained e.g.
fs.read and fine grained e.g.
fs.read.allowed permissions.
table iv resource types supported by the ztd permission model.
resource type operation resource objects file system read write files network system connect network urls shell system execution shell commands permission specification granularity similar to the java security manager s permission design ztd sysallows specifying coarse and fine grained permissions.
listing shows samples of a policy file.
coarse grained permissions authorize a dependency to access any object of the specified resource type.
for example a coarse file read permission fs.read in listing allows the com.app.bar dependency to read any file in the os except files specified in fs.read.denied .
fine grained permissions authorize a dependency to access explicitly authorized resources.
ztd sysprovides direct and transitive permissions that specify if an object can be accessed directly or through another dependency.
for example listing grants the com.foo.baz dependency the permission to write files but only allows writing to those in fs.write.allowed .
the dependency is also granted the transitive runtime execution permission so it can transitively execute commands specified in runtime.exec.transitive .
hence while com.foo.baz cannot execute the whomai command directly it can use another dependency that has direct permission to execute the command.
d. ztd p secure and context sensitive access control the system model in iv a shows that multiple dependencies in an application can interact to perform a given task using direct or asynchronous calls.
ztd sysrelies on a context sensitive access control system that considers this set of interacting dependencies when making access decisions and prevents malicious dependencies from leveraging permissions granted to other dependencies.
this section and listing shows how ztd syshandles components that interact directly and asynchronously.
handling direct dependency interactions a dependency can call functions from another dependency to access operating system resources.
these dependencies will be contained in the executing thread s call stack.
hence ztd sys grants access to a resource if all dependencies on the call stack have the necessary direct or transitive permissions to access the resource listing lines .
this approach ensures that no dependency has permission to access any resource on its own and prevents malicious dependencies from exploiting privileged dependencies to access unauthorized resources.
handling indirect dependency interactions in multithreaded applications a dependency can delegate a resource access operation to another dependency or the application delegates .
in a simpler case the delegate may create a child thread to access the resource .
then the call stack will not contain the dependency that initiated the operation.
ztd sys handles this interthread delegation scenario by using the permissions of dependencies in the parent and child thread s call stack to authorize access listing lines .
when a child thread is created its parent s dependency policies are saved.
the saved policies are retrieved and verified whenever the child thread accesses any resource.
as reported in v b this design does not handle more complex delegations involving two independent threads or processes.
enforcing ztd policies when access to a resource is denied ztd sys provides two enforcement options that balance the reliability needs of an application against the risk appetite of the engineering team a fatal enforcement mode this option raises an exception to block the unauthorized action.
software engineers working on security sensitive applications with low risk tolerance may prefer this mode.
they can implement exceptionhandling routines to prevent disruption to their applications.
b non fatal enforcement mode this option does not interfere with the application.
instead ztd syssends an unauthorized access alert to the application maintainers who will investigate the incident and begin any necessary remedial actions.
software engineers maintaining applications with high availability needs or in low security sensitivity environments may prefer this mode.
e. ztd p discovery of least privileges the huge number of dependencies in modern applications makes it infeasible to manually specify the least privilege policies for an application s dependencies.
ztd sysinfers the dependencies least privileges from their observed execution behavior.
this approach is motivated by findings from iii that vulnerabilities commonly expose resources that are not needed by the vulnerable dependencies during legitimate executions.
listing shows the algorithm employed by ztd sys for discovering and generating the least privilege policies for an application s dependencies.
ztd sys maintains a policy object for each dependency in the application.
at runtime it intercepts invocations of sensitive apis that can access an operating system resource.
it retrieves the classes and dependencies in the call stack and updates the policy of each1 in resource type specific item and operation out true if access is approved else false 3def authorizeaccess restype resitem resop callstackclasses getclassesfromcallstack depspolicies getpoliciesfordeps callstackclasses this part handles thread based delegation ifrestype thread child thread is created propagate parent s policy to child thread savethreadparentpolicies resitem depspolicies return true for access from child threads we check its contextpolicy and that of its parent parentcontextpolicy getparentpoliciesforthread ifparentcontextpolicy !
null depspolicies.extend parentcontextpolicy having obtained the appropriate policy check it for policy indepspolicies ifpolicy.checkaccess restype resitem resop continue policy does not grant access iffatal enforcement mode raiseexception else sendalert listing context sensitive permission verification and permission inheritance.
a dependency without defined permissions is authorized if its caller is authorized.
an operation is authorized if all dependencies on the call stack are authorized.
function called when a resource access is requested in resource type specific item and operation 3def onpermissionrequested restype resop resitem we get the classes in the call stack classes getclassesfromcallstack for each class we get its parent dependency deppolicies getpoliciesfordeps classes the first dependency is the direct caller.
deppolicies .addcoarseperm restype resop deppolicies .addfineperm restype resop resitem we assign transitive permissions to other deps for i i deppolicies.length i deppolicies .addfineperm restype resop resitem listing pseudocode for discovering and generating the least privilege policy from the observed execution behavior.
dependency with the necessary permission and the name of the specific resource object that is being accessed.
at intervals it writes the dependencies policies to a policy specification file.
we also considered inferring a dependency s least privileges by analyzing the library s source code and identifying invocations of function calls that access different resources.
a similar approach was applied by the dependency level security defenses .
however this approach does not enable finegrained policy generation for dependencies as it is difficult to statically determine the specific resource objects that a dependency may dynamically access.
furthermore the use of indirection in many languages e.g.
c c function pointers java reflection will lead to an imprecise identification of the sensitive apis that a dependency can access.table v java classes and instrumented methods that provide operating system resource access.
operation class instrumented method file read fileinputstream constructor file write fileoutputstream constructor network connect socket connect runtime executionprocessbuilder start f .
ztd p risk awareness through continuous monitoring as noted in iv b ztd requires engineers to continuously monitor their dependencies resource access.
ztd syssupports continuous monitoring using the approaches for least privilege discovery and policy enforcement given above.
when run throughout the application s lifetime the least privilege discovery framework continuously informs software engineers of all resources their dependencies accessed.
this improves engineers risk awareness as they can audit any dependency that accessed a sensitive resource to ensure malicious actors cannot hijack such access.
in addition when non fatal enforcement mode is enabled ztd informs software engineers of any unexpected resource access by a dependency facilitating an investigation.
further investigations that show the access was benign and necessary can lead to improvements of the provided policy.
v. ztd java a ztd sysimpl.for java applications fig.
the ztd sysdesign has five components.
the application transformer instruments the application.
the runtime monitor tracks dependencies access to resources.
the policy generator generates the least privilege policies for dependencies.
the policy context loads the generated policies.
the policy enforcer authorizes access.
we implemented a prototype of ztd sysfor java applications ztd ja v a. java applications comprise classes containing the application s business logic classes from dependencies and core classes provided by the java development kit jdk .
the jdk core classes allow the application and its dependencies to access operating system resources and use other features provided by the language.
table v shows the core classes for accessing the file network and shell system.mapping dependency policies to java classes at runtime in java applications the classes in the call stack do not indicate their parent dependency.
however ztd sysrequires that the policies specified for dependencies apply to all classes within the dependency.
hence we need to map the classes in the call stack to the specified dependency policy.
ztd ja v a uses the heuristic that java class names are formed from the directory tree structure containing the class.
classes in the same dependency share a common root directory path and their names share a common prefix representing their shared directory path.
we refer to this common prefix as the dependency s namespace as it contains all classes in the dependency.
for dependencies from the maven central registry this common prefix is usually obtained by combining the unique group id and artifact id of the library in the registry.
hence the com.app.bar policy in listing will apply to all classes with names beginning with com.app.bar .
a. implementation details of ztd java s components ztd ja v a is implemented in lines of java code.
as shown in figure ztd ja v a comprises five components.
we discuss the implementation of each component below.
application transformer at the application transformer modifies the bytecodes of an application at runtime.
it is supplied as a command line argument for the java command used to execute the application.
it takes in a list of classes and methods to modify.
it uses the java instrumentation api to intercept the specified target classes as they are loaded into the java virtual machine and uses the asm bytecode modification library to insert a direct call to the runtime monitor at the start of the specified method.
by default the at instruments the methods in table v but it can be configured to transform fewer or more methods depending on the application s security needs.
runtime monitor the runtime monitor is called whenever the application or a dependency attempts to access a protected resource using an instrumented method.
depending on ztd ja v a s configuration the runtime monitor invokes the policy generator and or the policy enforcer.
policy generator the policy generator generates a least privilege policy for each dependency using the algorithm in listing .
when a resource is accessed it adds the required permission to the policy objects of the dependencies on the call stack.
the policy objects are written to the leastprivilege policy file at specified intervals or during application shutdown.
in addition the generated policy file also informs software engineers of the resources their dependencies access and the potential risks they pose.
policy context the policy context stores the specified policies for each dependency.
it is implemented using a patricia tree where the nodes contain the dot separated components of the dependency name and the policies are contained in the leaf nodes.
as classes do not contain unique identifiers of their parent dependencies the context store is designed to get the policy of a class parent dependency using only the class name.
hence the policy for classes fromthecom.foo.baz dependency can be obtained by using the first three dot separated components of their class name to transverse the com foo and baz nodes in the tree.
when the application is started ztd ja v a creates the policy context from the provided policy file.
at runtime the policy enforcer uses the context to retrieve the policies that should be applied to each class on the call stack.
policy enforcer the policy enforcer uses the contextbased authorization algorithm in listing to validate and authorize access to os resources.
first we get the set of dependencies for the classes on the call stack retrieve the policies for these dependencies and verify that all policies have permission to access the resource.
b. limitations of ztd java asynchronous delegation ztd sys s handling of indirect dependency interactions iv d does not cover delegations between independent threads or processes created by different dependencies.
this can occur if a dependency sends user controlled data to a different thread where the data will influence resource access.
a taint tracking based technique can associate permissions with communications between threads and processes which will incur high runtime costs .
alternatively the permission model in ztd iv c1 could be expanded to recognize threads and processes as resources that require explicit access permissions.
use of native execution an attacker can use native libraries to bypass ztd s policy authorization.
our application transformer could protect the api that allows the use of native libraries e.g.
system.loadlibrary in java .
alternative designs execute native libraries in sandboxes but this introduces significant performance overhead.
false positives from incomplete generated policies we generate least privilege policies for each dependency based on their observed execution behaviors similar to sandbox mining techniques .
these policies will block any unexplored behaviors.
to address this ztd sysprovides a non fatal enforcement mode that alerts engineers rather than disrupting the application.
namespace pollution while rare multiple dependencies can share the same namespace in a java application.
a malicious actor can create a dependency whose class names share the same namespace as another dependency to inherit the legitimate dependency s privileges.
however enforcing fine grained policies will limit the attacker to only resources that the legitimate dependency can access.
vi.
ztd java evaluation this section evaluates ztd ja v a s effectiveness runtime costs and policy configuration costs with the following questions.
rq1 effectiveness does ztd ja v a prevent ssc vulnerability exploits that access operating system resources?
rq2 performance cost what is the performance cost of ztd ja v a on realistic applications?rq3 configuration effort how much effort is required to audit policies generated for realistic applications?
a. setup vulnerability selection we use the vulnerabilities from iii a. we selected three vulnerabilities from each vulnerability class table ii prioritizing vulnerabilities with a publicly available exploit proof of concept poc .
application selection we used the dacapo benchmark applications from iii a. to obtain least privilege policies for each application s dependencies we used ztd ja v a s policy generator and the dacapo benchmark suite s test cases.
these tests ran under ztd ja v a without issue.
baseline selection we use the java security manager jsm as a performance evaluation baseline as it shares similar requirements with ztd ja v a authenticating access to os resources for java applications.
we could not quantitatively compare to extant dependency level security defenses table i as none target the java ecosystem.
b. methodology rq1 defense against exploits leveraging os resources to evaluate rq1 we took two steps.
first we tested ztd ja v a s ability to mitigate ssc vulnerabilities.
for each vulnerability we created a sample application that depended on the vulnerable library and could be exploited using the available poc.
we ran each application with ztd ja v ato check if the exploits were blocked.
our results are in table vi.
secondly we assessed whether the least privilege policy generated by ztd ja v a could prevent exploits in real applications.
we injected vulnerabilities into applications biojava fop graphchi and zxing.
we selected applications built with maven so that we could easily add vulnerable libraries as dependencies.
we could not exploit vulnerabilities within biojava because the exploits required java and biojava required a minimum of java to run.
we used ztd ja v aand the provided workload to generate least privilege policies for each application and evaluated the effectiveness of the generated policies in blocking exploits of the injected vulnerabilities.
while we injected only nine vulnerabilities in this step we expect the generated policies to also prevent exploits of remaining vulnerabilities as the vulnerabilities access resources not allowed by the policies.
in addition unlike previous security defenses that are only evaluated on vulnerabilities recreated in simple applications we demonstrated ztd ja v a s ability to generate and enforce policies for real applications.
we note that our evaluation uses only vulnerabilities analyzed in iii and therefore the result may not generalize to new vulnerabilities.
however the design of ztd ja v a is based on the general zta framework.
this should help mitigate all vulnerabilities covered by the threat model in iv a. rq2 ztd java s performance impact first we measured the cost of each instrumented operation with and without ztd ja v a s instrumentation.
we used the java microbenchmarking harness jmh library maintained by openjdk to avoid microbenchmarking pitfalls .table vi ztd ja v a s performance in preventing host systemcompromising exploits.
it successfully blocks selected exploits.
we injected vulns.
in applications and vulnerabilities in only applications.
their exploits were blocked.
a means we did not inject this vulnerability.
cve id vuln.
class impact s. apps d. apps cve des.
code ex.
cve des.
code ex.
cve des.
file man.
cve code inj.
code ex.
cve code inj.
code ex.
cve code inj.
code ex.
cve comm.
inj.
code ex.
cve comm.
inj.
code ex.
cve comm.
inj.
code ex.
cve xxe data exf.
cve xxe data exf.
cve xxe data exf.
cve path trav.
file man.
cve path trav.
file man.
cve path trav.
file exf.
second we measured performance while increasing the number of dependencies expected constant and the number of classes from different dependencies in the call stack during a method s invocation expected linear .
third we profiled the applications.
we measured the execution time of each application without sandboxing with ztd ja v a configured in four modes and with jsm.
we used theconverge feature of the dacapo benchmark harness .
rq3 ztd java s policy configuration effort we measured the effort to audit the least privilege policies generated by ztd ja v a for dacapo benchmark applications.
as default policies are automatically generated engineers should not need to master a new policy language.
therefore the configuration effort will be spent mainly to audit and refine the generated policies.
to the best of our knowledge there is no existing metric for configuration effort in this context.
we therefore estimate that the configuration effort depends on two factors the number of dependencies for which ztd ja v a generated a non empty policy and the number of permissions provided in each such policy.
the first metric captures the number of policies that engineers would need to study.
the engineer may also need to assess if each provided permission is valid so the second metric captures the level of analysis that they must perform for each dependency.
for each application we report the number of dependency policies generated and the average number of permissions per policy.
c. results rq1 defense against exploits leveraging os resources table vi shows details of the vulnerabilities we recreated.
as shown ztd ja v a blocked the exploits of vulnerabilities in the sample applications when applied to real applications we find that the least privilege policies of all applications were sufficient to prevent the vulnerability exploits.
an application is executed until three executions have times within then the next iteration s time is kept.
we repeated the average of trials.table vii microbenchmark of security sensitive operations.
uncertainty is reported after the measurements converge.
operation vanilla s ztd ja v a s file read .
.
.
.
.
file write .
.
.
.
.
socket connect .
.
.
.
.
shell execution .
.
.
.
.
table viii execution time overheads and ztd ja v a configuration effort on the dacapo applications.
the table shows dependency and authorization call counts the overhead of ztd ja v a and jsm and the configuration effort for each app x y means x dependencies need policies and each policy provides an average of y permissions .
data unavailable because column application is not built with maven gradle or column jsm could not execute.
app namedeps countauth callsvanilla ztd ja v a jsm config effort avrora .
.
batik .
.
biojava .
.
eclipse 23k .
.
fop .
.
.
graphchi .
.
h2 .
.
luindex .
.
lusearch 6k .
.
pmd .
.
spring .
.
tomcat 1k .
.
.
tradebeans .
.
tradesoap .
xalan 9k .
.
zxing .5k .
.
.
medians .
.
fig.
microbenchmarking results for the policy authorization operation varying the number of dependencies in the application and the call stack sizes.
as predicted the execution time is constant with the dependency count and linear to the call stack lengths.
rq2 ztd java performance impact table vii shows the results of microbenchmarks for operations file read file write socket connection and shell execution.
ztd ja v a introduces modest overhead in file write socket and shell operations.
for scaling figure shows that ztd ja v a s performance does not depend on the number of dependencies and is marginally affected by call stack depth.table viii shows the profile results on applications from the dacapo benchmark suite.
ztd ja v a introduces no noticeable overhead on applications with overhead on of the applications.
the jsm despite operating at a higher abstraction level introduces overhead on four of sixteen applications with overhead in eclipse.
we attribute ztd ja v a s minimal overhead compared to the jsm to two factors.
first ztd ja v a performs policy authorization checks at the dependency granularity i.e.
once per dependency in the call stack listing .
in contrast the jsm checks permissions at the class granularity in the call stack.
second ztd ja v a performs less frequent policy authorization checks.
the default implementation enforces only permissions while the jsm enforces permissions and protects methods .
rq3 ztd java s configuration effort the last column of table viii shows the number of dependency policies generated for each application and the average number of permissions provided in each policy.
of the applications have less than dependencies that require policy specification.
policies provide only permissions to the dependency.
all policies were generated by ztd ja v awithout manual effort and executed on applications without failure.
note that the count of policies and permissions in table viii includes both direct and transitive permissions.
hence compared to the data in table viii only fewer dependencies directly accessed any operating system resources.
vii.
d iscussion this section discusses ztd ja v a s application to software applications vii a and other future directions vii b .
a. applying ztd javato software applications potential usage scenarios of ztd java ztd aims to protect software applications from ssc vulnerabilities.
we foresee three potential usage scenarios for ztd sysbased on the risk tolerance and reliability needs of an application.
proactive security applications run in fatal enforcement mode iv d3 .
the engineering team observes dependency resource access generates policies and enforces them to block abnormal resource access.
this mode provides high security but enforcing incomplete policies can lead to false positives and disrupt the application.
this mode would have prevented the equifax breach cve and attacks due to the log4j vulnerability cve .
reactive security applications generate policies and enforce them nonfatally iv d3 .
this alerts engineers to unauthorized access without disrupting the application.
this mode would have detected the equifax breach earlier preventing the reported day dwell time and limited its impact.
emergency security applications have policy discovery enabled iv e but no enforcement.
when new vulnerabilities are reported in a dependency the policies discovered for that dependency can be modified and enforced to mitigate the vulnerability by blocking access to any exposed resource.
thismode can act as emergency first aid and would have prevented software engineers from shutting down applications after the discovery of cve .
test cases for generating least privilege policies in the usage scenarios described the engineering team responsible for the application is tasked with selecting the test cases for policy generation.
they can use available workloads for endto end tests or use fuzzing to generate new high coverage test cases .
alternatively they can run their application in ztd sys s policy discovery mode until they feel confident that the necessary functionalities have been exercised.
this process is performed once for the entire application and needs only to be repeated when new functionalities or dependencies are introduced.
furthermore discovered least privilege policies are unlikely to be affected by dependency version updates as such updates rarely introduce new permission requirements .
in the future we intend to implement lightweight coverage metrics that help engineers decide when sufficient behaviors have been covered.
barriers to ztd javaadoption while ztd ja v aaddresses ssc vulnerabilities we foresee two barriers to adoption.
a engineers may fear that runtime modifications might introduce errors .
ztd ja v a mitigates this concern by modifying only a few classes.
all are in jdk core.
b false positives may occur if ztd ja v aencounters legitimate resource accesses that were not previously observed.
we mitigate this by adding the non fatal enforcement mode where any false positives will not disrupt the application.
a possible ztd ja v a utility would be a code coverage metric to assess if sufficient program behavior has been covered.
ztd java vs. the java security manager jsm both ztd ja v a and the deprecated jsm address java application vulnerabilities via resource access authorization.
as noted in ii c jsm had high runtime costs up to as well as high policy complexity jsm protected operations with different permission types .
based on common ssc vulnerabilities ztd ja v a protects sensitive resources by default allowing lower performance costs and policy complexity.
however ztd ja v a s application transformer v can also be configured to protect a different set of resources according to the security and performance needs of the application.
furthermore ztd ja v a overcomes the usability flaws that led to the lack of use of jsm and subsequent deprecation .
it features a flexible permission model iv c that allows coarse grained policies for easy to develop policies and finegrained policies for stronger security easier programming with automated policy discovery iv e and low performance cost vi c2 .
while ztd ja v a is designed to address vulnerabilities in an application s dependencies it can also be extended to mitigate the application s own vulnerabilities serving as an effective replacement for the deprecated jsm.
design choice protect resources or operations in line with zta ztd sys protects functions that access resources.
this approach differs from jsm and some other dependency level defenses which protect functions performing sensitive operations.
protecting sensitiveoperations provides finer control over dependencies behavior.
however the size complexity and diversity of applications and programming languages mean there are many sensitive operations each requiring a different permission.
as seen with jsm vii a4 this leads to increased policy complexity and runtime performance overhead.
to provide a balance ztd sys offers a customizable application transformer for adding or disabling permissions.
b. future directions improving the visibility of third party library capabilities recent supply chain vulnerabilities like log4j log4shell highlight the need for third party library engineers to communicate the functionalities and resource usage of third party libraries.
this practice would help application engineers assess their risks and discourage the provision of unnecessary os resource capabilities to these libraries.
initiatives like software bill of materials and open source insights could make this task machinecheckable if these approaches were extended to document the capabilities of third party libraries.
ztd ja v a s policy generation component can assist engineers in documenting their libraries capabilities and permissions.
application to other ecosystems and programming langs supply chain attacks in the java ecosystem exploited accidental vulnerabilities unlike attacks in the javascript and python ecosystems which are often caused by malicious vulnerabilities .
this emphasizes the need for runtime defenses that protect apps from vulnerable dependencies in addition to preventing the use of malicious libraries.
the zero trust dependencies concept is language agnostic and protects applications relying on third party libraries iv .
ztd ja v a instrument functions in a language s core libraries that interact with the operating system s resources iv .
with minimal adjustments the tool can be used with other jvm based languages such as kotlin and groovy .
application to other languages is future work.
viii.
c onclusion software supply chain vulnerabilities and attacks are increasing.
using nist s zero trust architecture as a framework we show that existing security defenses are incomplete.
we propose design implement and evaluate the zero trust dependencies approach.
zero trust dependencies places zero implicit trust in third party software libraries and can mitigate risks and protect operating system resources without impeding the application s normal behavior.
we design a low cost loweffort system ztd sys enabling zero trust dependencies s application to software.
our prototype for java applications ztd ja v a effectively mitigates supply chain vulnerabilities with minimal runtime cost and ease of configuration.
in summary zero trust dependencies provides a robust defense against risks from vulnerable dependencies.
data availability our artifact is at it has vulnerability data ztd ja v a source and experiments.