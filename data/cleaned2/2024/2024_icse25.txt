datalog based language agnostic change impact analysis for microservices qingkai shi1 xiaoheng xie2 xianjin fu2 peng di2 huawei li3 ang zhou2 gang fan2 1the state key laboratory for novel software technology nanjing university nanjing china 2ant group hangzhou china3alibaba inc. hangzhou china qingkaishi nju.edu.cn xiexie fuxianjin.fxj dipeng.dp zhouang.za fangang antgroup.com huawei.lihw alibaba inc.com abstract the shift left principle in the industry requires us to test a software application as early as possible.
in particular when code changes in a microservice application are committed to the code repository we have to efficiently identify all public microservice interfaces affected by the changes so that the impacted interfaces can be tested as soon as possible.
however developing an efficient change impact analysis is extremely challenging in microservices due to the multilingual problem microservice applications are often implemented using varying programming languages and involve diverse frameworks and configuration files.
to address this issue this paper presents microscope a language agnostic change impact analysis that uniformly represents code configuration files frameworks and code changes by relational datalog rules.
m icroscope then benefits from an efficient datalog solver to identify impacted interfaces.
experiments based on the use of m icroscope in ant group a leading software vendor demonstrate that m icroscope is both effective and fast as it successfully identifies interfaces affected by code commits with moderate time overhead and could reduce of interfaces to test and save of testing time after code changes.
index terms change impact analysis datalog based analysis microservices i. i ntroduction the microservice architecture has experienced a steady increase in popularity in recent years.
in a real world production environment multiple microservices interact as a cohesive system each responsible for a specific and well defined functionality.
this development model enables software developers to focus on realizing the requirements of individual microservices independently from each other.
however the increased complexity of the interaction among microservices has concurrently escalated the potential for the introduction of bugs.
the inherent dynamism of microservices based systems which are continuously modified and deployed to adapt to evolving business requirements or to address bugs creates an environment prone to significant disruptions.
recent reports indicate that changes are a major cause of incidents with approximately at china guangfa bank at baidu and at google being change related.
further evidence from indicates that of online incidents were due to code changes underscoring the impact of system modifications.
this work was partially supported by ant group.
peng di and gang fan are the corresponding authors.to deal with the dynamism of microservices and avoid bugs introduced by code changes change impact analysis cia is widely used throughout the software industry to assess the potential impact of code changes.
however a few significant challenges affect the deployment of cia for microservice applications.
on the one hand the first major challenge is the multilingual problem challenge .
specifically microservices are often implemented in diverse programming and configuration languages and on top of varying programming frameworks which are hard to describe uniformly.
while there have been a few existing works on cia e.g.
they often work for a single programming language or framework thus falling short of addressing the multilingual problem.
on the other hand an additional complication is presented by the shift left principle in the industry which induces performance related issues challenge .
that is the shiftleft principle in the industry requires us to test a software application as early as possible.
as such we have to identify the impact of code changes early so that the impacted software components can be tested as soon as the changes are made.
the substantial program size of microservices in the industry poses significant challenges for the cia complicating the task of conducting analyses within a reasonable time frame while upholding the shift left strategy.
this paper presents a datalog based cia for microservice applications in response to these challenges.
our key insight is that code elements such as classes interfaces functions expressions and their relationships can be uniformly represented via relational data models regardless of what specific programming or configuration languages are used.
as such our approach agnostic to specific languages via a layer of relational data abstraction is devised based on datalog techniques to adeptly maneuver the complexities of identifying changeimpacted microservice interfaces.
particularly our approach has two promising features.
first we suggest a uniform datalog based representation that standardizes how different languages or frameworks are interpreted thereby mitigating challenge .
second the datalog based representation allows us to benefit from modern datalog solvers to deal with industrial sized microservices exhibiting a high efficiency to identify change impacts and alleviating challenge .our approach to cia has been implemented as a tool named microscope which currently supports microservices written innine programming or configuration languages including java xml javascript typescript go c c python swift sql and properties.
this tool automatically parses microservices source code and configuration files into uniform datalog representations.
when a developer commits code changes into the code repository m icroscope automatically identifies the changes and translates the changes into datalog representations too.
m icroscope then invokes a datalog solver namely souffle to identify the interfaces impacted by code changes.
we evaluated m icroscope using realworld code changes from both the open source community and ant group a leading software vendor.
for each commit microscope can identify the impacted interfaces using only of the time for building or compiling a microservice project.
among examined commits m icroscope confirmed the code changes influenced out of interfaces used in upstream or downstream applications with manageable false positive and negative rates and .
in contrast we may miss impacted interfaces even if we remove the support for only one language.
these results underscore m icroscope s effectiveness and the importance of addressing the multi lingual problem in real world scenarios.
in conclusion this paper makes the following contributions we introduce a datalog based cia approach that is language agnostic and adaptable to the evolving needs of different projects.
we implement the datalog based approach as a tool namely m icroscope which supports nine languages and has been made publicly available.
we extensively evaluate our approach in a real and industry setting demonstrating the efficiency and effectiveness of the tool m icroscope .
ii.
m otivation and overview this section presents the background of microservices motivates the problem of identifying change impacts and provides an overview of our approach with an example simplified from a real and severe change related vulnerability.
a. necessity of cia in industry recent reports indicate that code changes are a major cause of incidents with approximately at china guangfa bank at baidu and at google being change related causing security issues such as broken object level authorization and excessive data exposure two owasp top api security issues .
these statistics underscore the importance of cia in industrial settings but we often encounter difficulties managing large complex systems that constantly change.
the difficulties are even amplified within microservices which feature a high degree of interservice communication and dependency.
ensure software quality after code changes running the entire test suite after every code change is inefficient let alone when the changes are frequent.
cia allows us to determine the interfaces impacted by code changes allowing software engineers to selectively execute tests covering these interfaces.
undoubtedly such a selective test execution will save considerable time and resources.
according to our evaluation as change related interfaces only account for of the total interfaces we can save of testing efforts in terms of reducing the number of interfaces to test and save of testing time on average every time code changes happen.
b. motivating example microservice is a software architecture that decomposes an application into small and self contained services.
each microservice is developed deployed and maintained independently.
in practice microservices are typically deployed in separate containers with communication occurring through lightweight mechanisms such as remote procedural calls.
such communications can be viewed as a series of invocations between the caller and callee services where the caller service relies on the functionality offered by the callee to achieve certain objectives.
in this paper we formulate microservices and service interfaces as follows.
definition microservice a microservice is denoted by v e where vis a set of functions in the service and e contains the caller callee relationship over v. definition service interface an interface of a microservice v e is a function f vpublished to and invoked by clients or other microservices.
given the distributed and interconnected nature of microservice applications changes within one service can ripple across the entire system causing significant consequences as evidenced by a recent report .
for example the oneline code change discussed below leads to the inconsistency between the front end client and the back end server of alipay a mobile app from ant group.
the inconsistency has caused alipay to crash and affect over million users.
basically this microservice application manages the information of clients and bills from an e commerce website.
figure shows a few source code files including four programming or configuration languages i.e.
java xml javascript and typescript.
the green and boxed line in figure a indicates the one line code change that adds a phone number field into the java class clientinfo .
the code snippets can be segregated into two sections the back and the front ends.
the back end comprises clientinfo billinfo billfacade and service.xml .
they manage server side operations including client data management bill data management and system configuration.
on the other side the front end i.e.
the client app includes proxy.js andgenericorder.ts .
the former facilitates the communication between the front end and the back end components.
the latter implements client side business logic.
let us discuss a bit more about what the six files do.
the java classes clientinfo and billinfo in figures a and b encapsulate a customer s profile data id name and phone number and the billing details.
the java interface billfacade in figure c is a public interface that allows clients to retrieve billinfo via a method namely load .
the configuration file service.xml in figure d publishes the interface com.store.billfacade i.e.
the java interface in c to clients such that a client can invoke its methods via a remote procedure call.
the javascript proxy.js in figure e is a client side configuration file.
line declares a remote object named billfacade which is of the type com.store.billfacade and can be used in the application named ordercenter .
the typescript order.ts in figure f implements a front end function in the application ordercenter .
line invokes a remote method load via the remote object billfacade .
when upgrading the microservice developers implement the one line change in figure a which restructures the client information.
however developers fail to recognize that this change will affect the front end i.e.
the function invocation in figure f which queries a client s order information but does not provide the phone number as a query condition.
consequently this inconsistency crashes the microservice app and affects million users.
it is challenging to identify such inconsistencies in microservices manually.
dependencies among functions are often implicitly encoded e.g.
via configuration files and involve multiple languages.
overlooking any single dependency may cause significant issues such as in the case of the motivating example.
unfortunately few existing techniques can automatically analyze such implicit and cross language change impacts which is the problem this paper aims to address.
in short we state the problem to address as below.
given a code change in microservices identify the service interfaces see definition impacted by the change.
c. microscope in a nutshell our key idea is to provide a language agnostic layer over programs in different languages such that we have a uniform representation to ease program analysis.
as shown in figure the first step is to build such a layer using a datalogstyle representation which we refer to as the code facts and the change facts.
we then define datalog rules to establish relationships among these facts.
finally a datalog engine infers service interfaces impacted by changes.
notations we use a predicate in the form of predicate x y .
.
.
where black letters in the times new roman font x and y are formal parameters to describe a dataset satisfying the relationship named predicate.
datalog facts are instantiated predicates e.g.
predicate a b .
.
.
where red letters in the typewriter font aand b are string or numeric constants .public class clientinfo .
private integer id .
private string name .
private string phonenumber .
a clientinfo.java .public class billinfo .
private clientinfo clientinfo .
private billdata billdata .
... .
b billinfo.java .
interface billfacade .
billinfo load billrequest request .
c billfacade.java .
sofa service .
interface com.store.billfacade .
sofa service d service.xml .
appname quotesingle.ts1ordercenter quotesingle.ts1 .
api .
billfacade quotesingle.ts1com.store.billfacade quotesingle.ts1 .
.
e proxy.js .
function queryorder orderid any .
context any any .
return billfacade.load .
context.userid orderid .
f order.ts fig.
motivating example.
representing a concrete entry in the dataset.
for instance we can use parent x y and grandparent x y to describe the parent child and grandparent grandchild relationships between x and y respectively.
the fact parent alice bob says that alice is a parent of bob.
datalog rules state how we deduce new facts from known facts.
for example a datalog rule in the form of grandparent x y parent x z parent z y means that if x is a parent of z and z is a parent of y then x is a grandparent of y. given all parent child facts this rule returns all x y satisfying the grandparent grandchild relationship.
for instance if we have two facts parent alice bob and parent bob charlie this rule deduces a new fact grandparent alice charlie to describe their grandparent grandchild relationship.
code facts as the first step m icroscope translates all source files in figure into datalog facts.
the code in figure a is translated into three facts field integer id clientinfo a field string name clientinfo a field string phonenumber clientinfo a .
each of facts describes a class field including its type and name as well as the class where the field is declared.
the last argument of these facts is the location where a field is declared including the source file the start line number and the end line number.
similarly we can translate the java code in figures b c and d into the following facts.
facts are similar to facts .
fact describes a function named load in the class billfacade .
its return type is billinfo .
we omit the function parameters to ease the explanation.
fact is extracted from the xml file which states the elements and attributes in the xml file field clientinfo clientinfo billinfo b field billdata billdata billinfo b function billinfo load billfacade c xml attr interface billfacade sofa service aaaaaaa d .
while facts are extracted from the back end code the following are from the front end i.e.
e and f in figure .
fact is from figure e describing the keyvalue pairs in the js file i.e.
the remote object billfacadetable i relationship rules for the motivating example.
imp field fname cname change loc field fname cname floc in floc loc imp class cname imp field fname cname imp class cname imp class fclass field fclass fname cname imp function fname cname imp class fclass function fclass fname cname pub function fname cname xml attr interface cname sofa service function fname cname reffunction callee refclass loc call ref callee caller loc function caller app api ref refclass app ciaresult callee refclass loc imp function callee refclass pub function callee refclass ref function callee refclass loc and its class billfacade that can be used in the front end app ordercenter .
facts are extracted from f .
fact says that there is a function named queryorder returning a billinfo in the app ordercenter .
fact describes a call expression invoked by the remote object billfacade .
api billfacade billfacade ordercenter e function billinfo queryorder ordercenter aaaaaaa f call billfacade load queryorder f .
change facts the fact of code changes is straightforward describing which line in a file is changed i.e.
change a line in figure a is changed.
the next section will discuss more details about change facts.
note that we focus on code changes in both source code and configuration files.
changes not in the code are out of the scope of this paper.
relationship rules we establish the datalog rules in table i to build the relationships among these facts.
the rules are general for different microservices and are not changed once defined.
they can be divided into four parts identifying functions impacted by code changes identifying functions published to clients identifying functions referenced by clients and finding the final solution of cia.
i identifying impacted functions.
the first four rules in table i find the fields classes and functions impacted by the code change.
the first rule identifies a field impacted by code changes.
it says that given a code change like change a if a field is in the same location the code change impacts the field.
in the rules the underscore symbol is an argument that a rule does not care about and in loc loc is an auxiliary predicate that checks if two locations overlap.
the 2nd rule states that a class is impacted by code changes if the class contains an impacted field.
the 3rd rule recursively finds classes impacted by code changes.
for example since the class billinfo in figure b contains a field of class clientinfo which contains a change impacted field the class billinfo is also impacted by the changes.
the 4th rule identifies change impacted functions which use an impacted class as the return type.
the predicate imp function fname cname includes the function name i.e.
fname and the class where the function is declared i.e.
cname.
ii identifying published functions.
the motivating example uses sofastack as the microservice framework which publishes a function to clients via an xml file likefigure d .
the fifth rule in table i defines the published functions.
it states that a published function is in a java class declared in the xml attribute interface of the xml element named sofa service .
due to fact this rule yields that all functions in the class billfacade are published and can be invoked by clients.
since fact indicates that the function load is in the class billfacade it is a published function.
iii identifying referenced functions.
as discussed figure e defines a remote object billfacade of class billfacade .
the client app ordercenter can use it to invoke a remote function.
figure f is a function in the client app that uses the remote object billfacade and invokes the remote function named load .
as such we identify functions referenced by the client app via the sixth rule.
the left hand side of this rule returns a function i.e.
callee the class where it is declared i.e.
refclass and the location where the function is invoked i.e.
loc .
the right hand side states that such a function should be invoked by a remote object declared in figure e .
iv putting the facts and rules together.
finally we use the final rule in table i to get a set of functions that are impacted by code changes published to the external world and meanwhile used by clients.
the result includes the function name the class where the function is declared and the location where the function is invoked.
iii.
a pproach microscope supports nine programming or configuration languages to address the multi lingual problem in microservices.
however we cannot discuss all of them due to the page limits.
instead we discuss the design using a widely used microservice framework sofastack and assume both the back end server and the front end client of a microservice application are written in java and xml.
in this section after introducing the basic concepts in sofastack iii a we discuss the technical design following the workflow in figure including the extraction of datalog facts iii b as well as the definition of datalog rules for change impact analysis iii c .
a. sofastack for microservices sofastack extends spring boot and provides a flexible framework for developing microservices in different languages such as in the motivating example discussed.
on the server side an xml file declares implicit dependenciesmicroservices code facts built incrementally when change happens change facts code changes change impactedinterfaces relationshiprules datalogengine they are not changed once defined fig.
workflow of m icroscope .
in the java code and publishes functions that a remote client can invoke.
as shown in figure a the server side xml file often includes a list of beans and sofa services to publish.
for each bean the underlying sofa framework creates a java object of the specified java class at runtime.
we can also declare dependencies among these beans.
for instance the class billinfo has a field named clientinfo .
line in the xml file states that this field is initialized with the object whose bean id is clientinfo .
that is in line the attribute name specifies the field name the attribute refspecifies the id of the bean to initialize the field.
line declares a bean of java class billfacadeimpl which as shown in figure b implements the java interface billfacade .
the java class implements the function load .
line in the xml file declares that all functions in the java interface billfacade are published to the clients.
the object of java class billfacadeimpl will be used to invoke these functions from a remote client because the attribute refrefers to the bean id defined at line .
we assume that the client side is also implemented in java and xml.
the xml element sofa reference at line states that it uses a remote object namely billfacade due to the attribute id of the class billfacade to invoke remote functions.
as shown by lines in figure a and the java code in figure b a client java class named ordercenter is initialized by assigning the remote object billfacade to its field billfacade .
the underlying sofa framework automatically performs this initialization.
as such in the function queryorder we can invoke the remote function load using the remote object.
b. extracting facts we extract facts from code changes as well as code in java and xml.
at a high level facts from code changes directly reflect where the changes occur facts from code are extracted during the code parsing procedure via syntax directed translation combined with lightweight dependency analysis.
workflow revisit code changes may not simply add a line of code as the motivating example.
however any code changes can be decomposed into code deletion and code addition.
for example figure shows that a code change .
!
server side server service.xml .
beanid clientinfo class com.store.clientinfo bean .
beanid billinfo class com.store.billinfo .
propertyname clientinfo ref clientinfo property .
bean .
beanid billfacade class com.store.billfacadeimpl bean .
sofa serviceref billfacade interface com.store.billfacade .
!
client side in java client service.xml .
sofa referenceid billfacade interface com.store.billfacade .
beanid ordercenter class com.store.ordercenter .
propertyname billfacade ref billfacade property .
bean a service.xml on the server and the client sides.
server side publicclassbillfacadeimplimplementsbillfacade billinfoload billrequestreq ... return... client side publicclassordercenter billfacadebillfacade billinfoqueryorder mgro ... o.f this.billfacade returno.f.load ... a remote procedure call b additional java source code.
fig.
illustration of sofastack.
.
a b c .
d a .
e d a original code .
a b c .
d a .
e d b code deletion .
a b c .
d a .
d d .
e d c code addition fig.
dealing with code changes.
that replaces the second line in a with lines in c can be decomposed into two steps code deletion which removes the second line as shown in b and code addition which adds two new lines as shown in c .
m icroscope separately deals with code deletion and code addition in two steps i.e.
performing the workflow in figure twice.
first m icroscope finds service interfaces impacted by the code deletion.
use the example in figure as an example.
in this step we specify change a which says that line in the original code will be changed and input the code facts extracted from the original code.
in practice if we have stored the code facts in a database we do not re extract facts from the original code.
this step then outputs all interfaces impacted by the deletion of line .
second m icroscope finds service interfaces impacted by the newly added code.
use the example in figure as an example.
in this step we specify change c which says that lines in c are changed and input the code facts extracted from the new code in c .
in practice we do not reextract code facts from all files but only re extract code facts from files containing additional code.
this step then outputs all interfaces impacted by the newly added code.
next we discuss the datalog facts extracted from the code and the changes in detail.
facts from code changes we elaborate a bit more on the facts extracted from code changes.
previously a codechange fact is specified in the form of change loc where loc is a string in the form path startline endline which reflects what lines of code are changed.
we predefined an auxiliary predicate in loc loc to check if the two locations overlap.table ii translating xml into datalog facts by syntax directed translation.
id xml grammar action for translating xml to datalog facts xml elmt 0elmt .
.
.
xml.facts elmt .facts elmt .facts 2elmt name elmt.id id attr i.parent elmt.id elmt attr 0attr1.
.
.
elmt.facts xml elmt elmt.id name elmt.parent elmt.loc attr0.facts attr1.facts elmt name elmt.id id attr i.parent elmt.id elmt i.parent elmt.id elmt attr 0attr1.
.
.
elmt 0elmt .
.
.
elmt.facts xml elmt elmt.id name elmt.parent elmt.loc elmt name attr0.facts attr1.facts elmt .facts elmt .facts attr key value attr.facts xml attr key value attr.parent attr.loc to specify code changes more precisely the location string can be easily extended to include both line and column numbers.
in what follows all datalog facts are ended with a location which may be omitted to keep the text clean.
facts from xml files facts extracted from an xml file describe xml elements attributes and their containment relationship.
table ii formally defines how an xml file is translated into datalog facts.
the second column is the xml grammar and the third defines the actions to take when a production rule in the grammar is applied for parsing.
the grammar contains three non terminal symbols xml elmt and attr.
the non terminal xml represents the whole xml file.
the non terminals elmt and attr mean xml elements and xml attributes being parsed.
the first production rule in the grammar states that an xml file is a list of xml elements.
the second and the third state that an element has a name and may contain attributes and sub elements.
the fourth production states that each attribute is a key value pair.
to translate an xml file into datalog facts we associate each non terminal symbol with some fields.
each non terminal has a field e.g.
xml.facts representing the string of datalog facts generated after using the corresponding production rules for parsing.
for example after the first production rule is used to parse the xml file we have already parsed each elmt i and elmti.facts have been generated.
as such the facts we generate for the whole xml file i.e.
xml.facts is the concatenation of all elmt i.facts see the 2nd row and 3rd column of table ii .
each non terminal elmt or attr is associated with a field e.g.
elmt.parent initialized as .
each non terminal elmt is also associated with a field e.g.
elmt.id to distinguish different xml elements with the same name.
as shown in table ii whenever the second or the third production rules are applied to parse an xml element and after the parser visits the element s name we create a unique and positive id for the xml element and assign the id to the attributes and subelements parent field meaning that their parent is the current xml element.
after the parser parses all xml attributes and subelements the facts of an xml element are generated including the fact xml elmt which contains the id name parent and the element s location and the facts of its attributes and subelements.
the final row of table ii explains how we translate an xml attribute into the fact xml attr after the final production rule is applied we create the fact xml attr for the xml attribute being parsed including the key and value of the attribute its parent xml element and the attribute s location.example xml facts the client s xml configuration file in figure can be translated into the three xml elmt facts where ... means an omitted location.
the third arguments of the first two facts are 0because they do not belong to any parent xml elements.
the third argument of the third fact is 2because it is in the xml element of fact .
xml elmt sofa reference .
.
.
xml elmt bean .
.
.
xml elmt property .
.
.
the facts for attributes are like xml attr id billfacade .
.
.
.
the first two arguments form a key value pair and the third is 1because it belongs to the element of fact .
we can then use the following datalog rules where underscore means a don t care argument to define beans and properties in the xml files.
each bean includes its id class name and location.
each property includes an id its name the bean it