repository level graph representation learning for enhanced security patch detection xin cheng wen1 zirui lin1 cuiyun gao1 hongyu zhang3 yong wang4 qing liao1 1harbin institute of technology shenzhen china 2peng cheng laboratory shenzhen china 3chongqing university chongqing china 4anhui polytechnic university anhui china xiamenwxc foxmail.com stu.hit.edu.cn gaocuiyun hit.edu.cn hyzhang cqu.edu.cn yongwang ahpu.edu.cn liaoqing hit.edu.cn abstract software vendors often silently release security patches without providing sufficient advisories e.g.
common vulnerabilities and exposures or delayed updates via resources e.g.
national vulnerability database .
therefore it has become crucial to detect these security patches to ensure secure software maintenance.
however existing methods face the following challenges they primarily focus on the information within the patches themselves overlooking the complex dependencies in the repository.
security patches typically involve multiple functions and files increasing the difficulty in well learning the representations.
to alleviate the above challenges this paper proposes a repo sitory level security patch detection framework named repospd which comprises three key components a repository level graph construction repocpg which represents software patches by merging pre patch and post patch source code at the repository level a structure aware patch representation which fuses the graph and sequence branch and aims at comprehending the relationship among multiple code changes progressive learning which facilitates the model in balancing semantic and structural information.
to evaluate repospd we employ two widely used datasets in security patch detection spi db and patchdb.
we further extend these datasets to the repository level incorporating a total of and versions of repository in c c programming languages respectively denoted as spi db and patchdb .
we compare repospd with six existing security patch detection methods and five static tools.
our experimental results demonstrate that repospd outperforms the state of the art baseline with improvements of .
and .
in terms of accuracy on the two datasets respectively.
these results underscore the effectiveness of repospd in detecting security patches.
furthermore repospd can detect security patches which outperforms the best performing baseline by .
with respect to accuracy.
i. i ntroduction in recent years the increasing number and diversity of vulnerabilities in open source software oss have presented significant challenges to software security posing substantial risks to society .
according to the synopsys report in of codebases contain at least one open source vulnerability and of these codebases include components that are outdated by ten or more versions .
there is a critical need for the timely detection of software corresponding author.security patches to mitigate attacks .
however the management of security patches is often subjective by managers leading software vendors to release security updates without sufficient publicity .
this practice of silently releasing patches complicates the identification and remediation processes as users or administrators are frequently overwhelmed by the growing number of patches which often results in delayed software updates and vulnerability reports.
the existing study has revealed that over of user submitted software vulnerability reports are filed more than days after the initial detection .
for example cve an information disclosure vulnerability was first disclosed on may 24th .
however threat actors had begun exploiting this vulnerability as early as april 30th targeting over ip addresses .
consequently more than a hundred thousand users including those in banks federal agencies and large enterprises faced significant exposure risks.
therefore it is imperative for both users and developers to automatically distinguish security patches from other updates and prioritize those that directly address security vulnerabilities.
deep learning dl based methods have achieved great success in identifying security patches as they can reduce the dependence on the quality of commit messages in patches and offer a broader spectrum of capabilities in detecting various security patches .
current methods can be categorized into sequence based and graph based approaches.
sequence based methods process the sequential inputs of all code changes in a patch and then utilize dl models to determine whether a code commit fixes a vulnerability.
for example patchrnn uses both commit messages and code changes as input and then employs the recurrent neural network rnn to deal with the input sequentially.
graphbased methods convert the code changes from a code commit into a graph structure incorporating control flow or data flow dependencies and then use graph neural networks gnns or serialize the graph structure to identify security patches.
for example graphspd proposes a patchcpg and employs a graph convolutional network gcn to detect security patches.
however existing methods face the following challenges arxiv .08068v1 dec 2024diff git a kernel futex.c b kernel futex.c index 6a3a5fa1526d8..e328f574c97c0 a kernel futex.c b kernel futex.c static inline struct futex hash bucket queue lock struct futex q q struct futex hash bucket hb get futex key refs q key .
hb hash futex q key q lock ptr hb lock static inline void queue unlock struct futex q q struct futex hash bucket hb spin unlock hb lock drop futex key refs q key .
static int futex wait u32 user uaddr int fshared ret erestart restartblock out put key .
put futex key fshared q.key .
out if to hrtimer cancel to timer static int futex wait u32 user uaddr int fshared ret unqueue me drops q.key ref .
if !unqueue me q goto out put key .
goto out .
ret etimedout if to !to task goto out put key .
goto out .
if !signal pending current .
put futex key fshared q.key .
if !signal pending current .
goto retry .
ret erestartsys if !abs time goto out put key .
goto out .
restart current thread info restart block restart fn futex wait restart a code change b code change c code change d code change 7fig.
the part of security patch that fixes a buffer overflow vulnerability i.e.
cwe .
the red and green lines represent the before fixed code pre patch and after fixed post patch respectively.
lack of consideration of the comprehensive contexts at the repository level.
the previous methods primarily focus on the information within the security patches overlooking the complex dependencies in the repository.
however patches typically have complex dependencies in the repository such as the call function to invoke functions in the patches which are necessary for identifying a security patch.
for instance as shown in fig.
the patch addresses a buffer overflow vulnerability identified as cve2014 .
the function futex wait shaded in orange in fig.
c and d fails to properly manage a specific reference count during requeue operations which may lead to trigger the use after free or system crash via thequeue lock andqueue unlock functions in fig.
a and b respectively .
moreover the provided patch does not include repository level dependency about theget futex key refs line in fig.
a and put futex key line in fig.
b respectively .
therefore we cannot determine if this patch is a valid security patch due to insufficient contextual information.
hard to learn the patch representation due to the complex relationships among multiple code changes.
security patches generally encompass multiple functions and files increasing the difficulty in learning the representations.
for instance the given commit involves five functions and seven code changes fig.
shows three functions and four code changes .
these code changes do not represent a sequential relationship i.e.
they are not linearly related such as fig.
c and fig.
d simultaneously modifying futex wait function shaded in orange .
this complexity can limit the existing models capability to learnrepresentations among multiple code changes.
our work.
to alleviate the above challenges we propose a repo sitory level security patch detection framework named repospd which comprises three key components a novel graph structure called repocpg aims at extracting comprehensive contexts at the repository level by merging prepatch and post patch source code and retaining code changes semantics within the patches a structure aware patch representation which fuses the graph based and sequence based representations aiming at comprehending the relationship among multiple code changes from the structure and semantics perspective respectively progressive learning which aims at facilitating the model in balancing structural and semantic information.
additionally we extend the spi db and patchdb datasets to incorporate a total of and versions of repositories respectively denoted as spidb and patchdb .
to evaluate repospd we compare repospd with five existing security patch detection baselines and five static vulnerability detection methods.
the experimental results show that repospd outperforms the state of the art security patch detection approaches with improvements of .
and .
in terms of accuracy and f1 score respectively.
furthermore repospd detects security patches with an accuracy of .
which achieves a substantial improvement of .
over the static analysis based baselines.
these results demonstrate the effectiveness of repospd in identifying security patches.
contributions.
the major contributions of this paper are summarized as follows to the best of our knowledge we are the first to propose the repository level patch cpg which integrates the repository level information and retains code change semantics within the security patches.
we propose repospd a repository level security patch detection framework for capturing patch patterns from both structure and semantics perspectives by fusing the graph based and sequence based representations.
we curate the spi db and patchdb datasets and perform an extensive evaluation.
the results demonstrate the effectiveness of repospd in security patch detection.
ii.
b ackground a. code property graph code property graphs cpgs are widely used in software vulnerability related tasks .
they merge abstract syntax trees asts control flow graphs cfgs and program dependence graphs pdgs to obtain a joint graph.
the pdg is divided into the control dependency graph cdg and data dependency graph ddg which represent control and data dependencies respectively.
for example ample explored graph simplification on cpgs and used multi edge based gnns for vulnerability detection.
graphspd introduced patchgpg applying cpgs to software security patch detection.
although cpg encompasses comprehensive structural and semantic information about the source code the current approaches are limited in their ability to extract repositorylevel dependencies focusing primarily on files corresponding to patches.
in this paper we extend cpgs to the repository level incorporating more semantic and structural information to comprehend multiple code changes.
b. repository context in code related tasks incorporating repository level context for code related tasks has been a significant challenge.
these tasks introduce numerous reasoning challenges based on real software engineering subtasks such as identifying relevant code recognizing cross file dependencies and understanding repositoryspecific symbols and conventions.
for example liu et al.
present repobench a benchmark specifically designed for evaluating repository level code completion.
similarly wen et al.
propose vuleval which integrates repositorylevel context for vulnerability detection.
however previous studies on identifying security patches have still relied on file and patch level contexts.
this limitation presents challenges in real world software production as it is crucial for developers to be aware of other files within the repository during programming.
in this paper we further enrich the widely used spi db and patchdb datasets at the repository level which highlights the future directions at the repository level security patch detection.
iii.
p roposed framework we provide an overview of repospd workflow in fig.
.
repospd mainly consists of three components a repocpgalgorithm repocpg construction input precode code pre post code code post repo function repo func output repocpg repocpg 1function repocpg construction generating the pre patch and post patch cpgs precpg npre e pre code pre post cpg npost e post code post fuse the pre cpg and post cpg to obtain the mergecpg.
forv npre n post e pre e post do ifv vpreandv vpost then v.type fuse else ifv vpre then v.type pre end ifv vpost then v.type post end end end merge cpg construct mergecpg precpg post cpg integrating the repository level dependency.
ifnode .type call graph then adopt static tool to extract function name in the repository iffunction name repo func then call func repo func construct the call cpg ofcall func call cpg construct call cpg call func find the root node ofcall cpg add edge node root node and mark the root node asr update merge cpg repocpg update merge cpg call cpg r end end slicing code changes in repository level.
ifr code change then deleted based repository slicing repocpg deleted delete slice repocpg added based repository slicing repocpg added add slice repocpg end repocpg repocpg deleted repocpg added return repocpg construction b structure aware patch representation and c progressive learning.
a. repocpg construction the purpose of the repository level cpg repocpg construction is to extract comprehensive contexts at the repository level and retain code change semantics within the patches which consists of the following three steps generating mergecpg it aims to establish connections before pre patch and after post patch the patch.
however when multiple code changes occur within a single file they often lack structural connection to each other due to the patch only containing three lines of code within the code changes .
therefore we initially employ the commit id in conjunction with the git reset command to precisely revert to the specific versions of the repository thereby retrieving the entire files both pre patch and post patch rather than merely using the code changes.
as shown in the algorithm lines we generate the cpg for each version of the file to construct pre patch and post patch cpgs respectively.
fg fs graph branch sequence branchsequence representationgraph representation b structure aware patch representation precpgpost patch repository source codedependency setpre patch mergecpg slicing code changes a repocpg construction lce pg lce ps c progressive learning security patch predictionpostcpg repocpg generating mergecpg integrating repository dependency cflowrepository tree sitter fig.
the overview of repospd.
pre patch node edgeb.hb hash futex q key g.hb f.hash futex q key a.queue lock struct futex q q c.get futex key refs q key m.if !key borh.ptrj.return hba.queue lock struct futex q q i.get futex key refs union futex key key d.hb hash futex q key k.q lock ptr hb lock post patch node edge common node edge repository node edge a mergecpg b repocpge.q lock ptr k.q lock ptr hb lock j.return hb h.q lock ptr hb lock i.return hbc.get futex key refs q key d.hb hash futex q key fig.
an example of mergecpg and repocpg construction for the code change in fig.
a .
due to the large size of the repocpg we ignore some nodes and edges here.
subsequently we integrate the pre patch and post patch cpgs to establish a unified graph designated as mergecpg lines .
during the integration process we retain common nodes that are common across both the pre patch and post patch versions such as nodes a e f and g as shown in fig.
a .
nodes that exist exclusively either before or after the patch termed changed nodes are also merged for example node cin fig.
a appears only in the pre patch version.
we then identify and label nodes that are connected to the changed nodes .
for instance nodes d j and k which connect with the changed node c are labeled as pre patch nodes .
correspondingly nodes b h and i which exist in the post patch version are labeled as post patch nodes .
bymerging the pre patch nodes post patch nodes and common nodes we construct the mergecpg which effectively preserves the semantics of the original source code and builds the relationship between the pre patch and post patch.
integrating the repository level dependency we then integrate the repository level dependency lines in algorithm to obtain more contextual information.
we utilize thecommit id to collect the corresponding specific versions of the repository.
we employ the tree sitter to traverse the repository and extract the call graph line .
we annotate all function level call dependencies i.e.
identified as related dependencies and construct the repository set repo func for each patch.
subsequently we select the change code in mergecpg and utilize the cflow to extract dependency elements and further construct the repocpg lines .
specifically since each node in the mergecpg contains detailed node information we identify potential call relationships call func mark the target nodes and retrieves within the repository set repo func.
for example as shown in fig.
b if a dependency is identified in repository such as node c we build an edge from the target node cto the root node iof the function.
we then generate the repocpg and mark node types node iand m according to its affiliation with the node version pre patch nodes post patch nodes or common nodes .
we integrate mergecpg with repository level dependencies to construct repocpg.
slicing code changes in repository level repospd further generates a slicing repocpg from the original repocpg which includes two steps deleted based repository slicing and added based repository slicing.
deletedbased repository slicing targets the statements deleted in the pre patch cpg.
for instance line in fig.
a is a deleted statement in the pre patch which calls the get futex key refs function.
we retain the context retrieved from the repository and incorporate it with the prepatch statement into repocpg as discussed in section iiia step .
other context lines that have no dependency on 4the deleted statement are excluded.
added based repository slicing focuses on the statements added in the post patch cpg.
for example in fig.
d line is an added statement in the post patch which calls the signal pending function.
we retain the context and incorporate it with the post patch statement into repospd.
both deleted based and added based repository slicing are conducted according to the types of edges within the cdg and ddg where each node represents a statement.
all retained nodes in repocpg are directly dependent on the code changes in the patch.
fig.
b shows an example of repocpg after code change slicing at the repository level.
b. structure aware patch representation in this component we elaborate on the proposed structureaware patch representation which involves the graph branch for capturing the structural information of repocpg and combines the sequence branch for further enhancing the security patch representations.
graph branch the graph branch learns vulnerability patterns from semantic and structural information.
the semantic information is exhibited by each node embedding in the repocpg while the structural information is achieved by the graph structure by diverse relationships between node and edges.
the content of each node in repocpg can be a statement node in cdg ddg or token node in ast.
we use unixcoder to initialize the representations of each node in the repocpg.
we generate the node vector h ifor each node iin the repocpg which is calculated as follows h i h0 ni hl ni where h0andhldenote the first and last layer embedding of unixcoder respectively.
we then use the graph attention networks gat which aims at capturing the local structural information of the repocpg.
specifically two types of edge roles and four bit vectors are defined version pre patch post patch or common and functional cfg ddg orast .
it is noteworthy that repository level edges are not listed separately instead they encompass both version information and functional relationships.
owing to the distinct roles it is impractical to apply a uniform set of weights across the entire model for learning the graph representation.
consequently we construct four subgraphs i.e.
four gat layers to cater to four bit vectors.
within this framework a gat layer computes a new set of node embedding by leveraging the input node features along with the attention coefficients that have been learned.
for each subgraph the normalized attention coefficients between nodes iandjare calculated using the following formula l ij softmax leakyrelu a l h wh l i wh l ji where a l andwdenote the learnable vector and weight matrix respectively.
softmax and leakyrelu denote the concatenation operation softmax function and activation function respectively.
kis the index of the subgraph.
thenode embedding h l of subgraph kin layer lis computed as follows h l i x j n i l ij w h l j where n i and denote the set of neighboring nodes of node iand the activation function respectively.
the different roles of edges and the structure level information in the repocpg will be aggregated to the whole graph feature h l i which can be formulated as h l i k k 1h l i where krepresents the total number of subgraphs.
since the graph feature h l ionly provides individual attention for each subgraph we further employ another gat layer to learn the structural information from the whole repocpg.
finally we calculate the representation h l ithrough a pooling layer to obtain the graph branch representation fg.
sequence branch we also integrate a sequence branch specifically designed to analyze the code changes within a patch.
a typical patch includes several lines of contextual code but it also often encompasses a substantial amount of extraneous data such as line numbers and diff markers e.g.
string1 .
such information can potentially mislead the model during the learning process.
to mitigate this issue the sequence branch is configured to selectively retain only the lines of code changes along with the version information either pre patch or post patch to enhance semantic learning.
we exclude non critical elements such as index lines filenames and location indicators.
specifically we fine tune the unixcoder and obtain the sequential representation fsfor the sequence branch.
c. progressive learning as shown in fig.
c we introduce progressive learning that systematically alternates focus between the graph and sequence branches by modulating the respective model weights.
this approach is necessitated by the inherent differences in modalities and input characteristic between the graph and sequence branches.
due to these differences the learning rates and shared parameters between the branches vary substantially posing challenges for capturing patch related patterns.
therefore we propose a method to progressively learn the graph branch and sequence branch by selectively freezing the model weights of branches during the training process.
more concretely the feature vectors fgandfswill be sent into the classifiers wgandwsrespectively and the outputs will be integrated together.
the predicted output is formulated as p w gfg w sfs then progressive learning is to initially train the sequence model leveraging the domain knowledge provided by the pretrained model.
subsequently the focus shifts to the more complex graph structure ensuring comprehensive learning 5table i statistics of the spi db and patchdb datasets.
dataset set patch file version of repo spi db train valid test all patchdb train valid test all across different data representations.
the progressive learning loss of repospd is illustrated as l tlce pg y t lce ps y t 0ife emax 1ife emax where lceandydenote the cross entropy loss function and the label of data respectively.
pg w gfgand pg w sfs are the predicted output of graph and sequence branch respectively.
tdenotes the shifting parameter and edenotes the current training epoch.
iv.
e xperimental setup a. research questions in this section we evaluate the effectiveness of repospd by comparing it with the state of the art security patch detection approaches and focus on the following four research questions rqs rq1 how effective is repospd compared with existing security patch detection approaches?
rq2 how effective is repospd in security patch detection compared with the static analysis based approaches?
rq3 how effective is repospd over patches with different vulnerability types?
rq4 what is the influence of different components of repospd on the performance for identifying security patches?
b. datasets data source to address the proposed rqs we select two widely used datasets as the raw data spi db and patchdb .
specifically spi db collects patches from two major c c datasets ffmpeg and qemu encompassing 25k patches of which 10k have been classified as security related.
patchdb compiles data from open source repositories containing over 36k code snippets approximately 12k identified as security patches.
data process to evaluate the security patches at the repository level we further collect the versions of the repository source code and extract the dependency at the repository level via three steps we initially select repositories fromwhich complete source code and commit logs can be retrieved via github.
this process resulted in the selection of patches from spi db and from patchdb as detailed in table i. for each identified patch we use the corresponding commit id to collect specific code versions at the repository level.
this effort has led to the collection of versions from repositories i.e.
version of repo in table i in spi db and from patchdb.
finally we traverse the entire repository by tree sitter tool to parse the function level dependencies.
subsequently we employ the cflow to further extract dependency elements.
as detailed in table i we extract the repository dependencies from and files to construct the spi db and patchdb respectively.
data split following the previous work we split the datasets into disjoint training validation and test sets in a ratio of as shown in the table i. we use the training set to train the models use the validation set for selecting bestperformance models and evaluate the performance in the test set.
c. baselines comparison on security patch detection approaches to address rq1 we evaluate the effectiveness of repospd by comparing the following six security patch detection approaches.
we categorize these baselines into three groups supervised based methods we utilize patchrnn and graphspd for this category.
patchrnn employs an rnn based model that processes only source code as input while graphspd introduces patchcpg and leverages a gnn to learn structural information.
these methods are widely recognized and frequently adopted as baselines in recent studies.
pretrained model based methods we select three prominent pre trained models codebert codet5 and unixcoder .
these models use code changes i.e.
patches as input and are further fine tuned for the downstream task of security patch detection.
llm based methods due to resource constraints we construct the prompt and utilize llama3 70b to assess the performance of llms in security patch detection.
comparison on static analysis approaches in rq2 beyond directly identifying security patches a common approach involves utilizing static analysis tools to detect security patches .
this method entails detecting vulnerabilities in pre patch code snippets and verifying their absence in postpatch code snippets.
in this paper we select five widely used baselines cppcheck rats semgrep flawfinder and vuddy .
these methods employ predefined rules and patterns to identify potential vulnerabilities in source code at the repository level.
therefore they can detect vulnerabilities in the vulnerable version i.e.
pre patch and should not identify such vulnerabilities if they have been successfully patched i.e.
post patch .
d. evaluation metrics we choose the following three metrics to evaluate the performance of repospd.
accuracy accuracy tp tn tp tn fn fp.
it reflects the percentage of the samples which are correctly classified among samples.
tp andtn denote the counts of true positive and true negative samples respectively.
tp tn fn fprepresents the total number of samples.
f1 score f1 precision recall precision recall.
f1 is the harmonic mean of precision and recall.
false positive rate fpr fpr fp fp tn.
it measures the proportion of negative samples that are erroneously classified as positive.
e. implementation details for all the baselines except llama3 70b we directly use the publicly available source code and hyper parameters released by the paper.
for llama3 70b we use the ollama framework and evaluate them on our server.
to ensure the fairness of all experiments we consistently apply the same data across all approaches.
we utilize joern to generate distinct cpgs for both pre patch and post patch code.
additionally scala is employed to construct the mergecpg.
then we use the tree sitter and cflow to analyze and construct the repocpg.
tree sitter is utilized to extract function level source code by traversing the repository thereby facilitating subsequent analysis.
it is a static analysis tool which can quickly parse and analyze code structures across repositories .
cflow is employed to extract dependencies at the repository level focusing on the flow of function calls .
for the graph node embedding we leverage the pre trained model unixcoder utilizing its tokenization and model weight to obtain initial node vectors.
in the sequence branch we fine tune the unixcoder model with a learning rate of .
for the graph branch we use a learning rate of and set the gat with heads.
the training process spans epochs with a batch size of .
we conduct experiments to determine the suitable hyper parameters.
due to space limitations the experimental results of patchdb are shown in github.
all experiments are conducted on a server equipped with nvidia geforce rtx gpu and cuda .
.
v. e xperimental results a. rq1 repospd vs. security patch detection approaches to answer rq1 we compare the three types of security patch detection approaches including supervised based pretrained model based and llm based methods.
table ii shows the experimental results of each baseline of accuracy f1 score and fp rate metrics.
overall results the experimental results presented in table ii demonstrate that repospd consistently outperforms all baseline methods on the spi db and patchdb datasets across all evaluated metrics.
specifically repospd achieves an accuracy of up to .
and an f1 score of .
on the spi db dataset.
furthermore repospd exhibits a higher accuracy of .
and a reduced fp rate of .
on the patchdb dataset.
this enhanced performance in patchdb table ii experimental results of repospd and the security patch detection baselines on the spidb and patchdb datasets.
texts in bold represent the best performance of the best methods in each metric.
dataset method accuracy f1 score fp rate graphspd .
.
.
patchrnn .
.
.
codebert .
.
.
codet5 .
.
.
unixcoder .
.
.
llama3 70b .
.
.38spidb repospd .
.
.
graphspd .
.
.
patchrnn .
.
.
codebert .
.
.
codet5 .
.
.
unixcoder .
.
.
llama3 70b .
.
.43patchdb repospd .
.
.
may be attributed to the larger training data compared to spidb .
repospd vs. supervised based methods the results summarized in table ii indicate that repospd enhances performance metrics across both datasets when compared to all other supervised based methods.
specifically repospd achieves average improvements of .
in accuracy and .
in f1 score.
graphspd outperforms twinrnn primarily because graphspd integrates the dependency within the patch to provide structural information.
furthermore repospd incorporates repository level information to construct repocpg which contributes to its superior performance.
repospd vs. pre trained model based methods table ii reveals that pre trained model based methods generally surpass those supervised based methods.
specifically codebert codet5 and unixcoder achieve an average performance of .
and .
in terms of the accuracy and f1 score on the spi db dataset.
despite these results these methods still behave worse than repospd across all metrics.
particularly repospd outperforms the state of theart baseline with relative improvements of .
of accuracy and .
of f1 score on average across the spidb and patchdb datasets.
the primary factor contributing to this performance gap is that pre trained model based methods focus on semantic information within code changes.
however they do not adequately address the lack of structural information at the repository level which is crucial for comprehensive analysis.
in contrast repospd effectively integrates both semantic and structural information thereby enhancing its overall performance in security patch detection.
furthermore we also conduct the statistical significance tests between repospd and the best performing methods codet5.
repospd surpasses codet5 in both patchdb and spi db at the .
significance level with p values of .15e and .46e respectively.
these results show that the repospd significantly outperforms other baselines.
7table iii the experimental results of repospd and the static vulnerability detection baselines on the patchdb dataset.
texts in bold represent the best performance of the best methods in each metric.
method vul pre patch vul post patch security patch accuarcy cppcheck .
rats .
semgrep .
flawfinder .
vuddy .
repospd .
repospd vs. llm based methods due to resource constraints we only select llama3 70b for evaluating the performance of llms in security patch detection.
as indicated in table ii repospd surpasses the performance of llama370b in all datasets and metrics despite the generally robust capabilities of llm based methods across various domains.
there are two primary reasons that may lead llama3 70b to failing to identify security patches.
firstly the single prompt may result in a lack of domain specific knowledge in security patch detection thereby rendering the detection of complex vulnerability types particularly challenging.
secondly the model struggles with the lack of repository level dependencies between code changes at the repository level which often leads to an inability to make definitive judgments.
answer to rq1 in comparison with the security patch detection approaches repospd achieves the best performance across all evaluated performance metrics with improvements of .
of accuracy and .
of f1 score on average across the spi db and patchdb datasets.
b. rq2 repospd vs. static analysis approaches to evaluate the effectiveness of repospd in identifying security patches we also compare with widely used static analysis based approaches.
in this paper we select five static analysis tools and utilize a dataset comprising security patches.
specifically to maintain consistency with graphspd the criteria of the selection include the patches without associated cves are removed since they are hard to be verified.
the non security patches are excluded from the dataset.
the patches are selected only from the test set to prevent data leakage between the training and valid sets.
based on the selection criteria the patch db comprises only patches.
table iii presents the number of vulnerabilities detected by static analysis based techniques in both pre patch and postpatch code.
as demonstrated in table iii the results show that repospd surpasses all baselines detecting an additional security patches and achieving a .
improvement in terms of accuracy.
the static analysis tools such as cppcheck rats and semgrep fail to detect any security patches indicating their potential limitation in accurately identifyingidentify security patches.
for instance cppcheck identifies vulnerabilities in the pre patch versions of the code.
however it also identifies the same vulnerabilities in the post patch versions indicating that it fails to recognize any of the applied security patches.
among the static analysis based approaches vuddy exhibits superior detection performance identifying vulnerabilities in pre patch code and in post patch code.
among the vulnerabilities detected in the post patch code are not associated with the same patches as the vulnerabilities identified in the pre patch code.
this discrepancy highlights the challenges in accurately classifying patches with vuddy correctly identifying patches as secure patches.
in summary despite the widespread use of existing static analysis based methods in practice they exhibit a notable deficiency in detecting security patches.
this limitation underscores the value of repospd which demonstrates a robust capability to identify security patches in the repository level thereby enhancing its practical utility.
answer to rq2 in comparison with the static analysisbased approaches repospd surpasses all baselines detecting an additional security patches and achieving a .
improvement in terms of accuracy.
c. rq3 effectiveness of different types of patches in repospd to evaluate the effectiveness of repospd in identifying different types of security patches we utilize the same dataset as in rq2.
this dataset encompasses types of common weakness enumerations cwe across projects.
the proportion and type of vulnerability are presented in table iv.
it is important to note that this dataset exclusively contains security patches and does not include non security patches.
overall we observe that repospd is effective across all ten types of vulnerabilities analyzed achieving an average accuracy of .
.
we can observe the following findings the repospd shows excellent performance at identifying vulnerabilities associated with a higher number of security patches such as buffer overflow resource leakage and numeric error with accuracy performance of .
.
and .
respectively.
in addition it also reveals that repospd with a relatively low number of security patches can perform well in some cases such as untrusted data and race conditions.
the security patches that are frequently misclassified typically pertain to vulnerabilities stemming from inadequate verification processes such as improper input validation and improper access control.
these cases often do not present overt errors but rather require the understanding of multiple dependencies to identify vulnerabilities.
8table iv the security patch detection performance of repospd over different vulnerability types.
vulnerability type cwe id ratio acc buffer overflow .
.
double free use after free .
.
injection .
.
improper input validation .
.
resource leakage .
.
numeric error .
.
null pointer dereference .
.
improper access control .
.
untrusted data .
.
race condition .
.
other vulnerabilities16 .
.
answer to rq3 repospd shows excellent performance in identifying vulnerabilities especially with a higher number of security patches.
the security patches that are frequently misclassified typically pertain to vulnerabilities stemming from inadequate verification processes.
d. rq4 effectiveness of different components in repospd in this section we explore the impact of different components of repospd including the repocpg construction i.e.
w o repocpg the structure aware patch representation i.e.
w o sequence and w o graph and progressive learning i.e.
w o progressive .
the experimental results are shown in table v. repocpg construction to explore the effect of the repocpg we deploy one variant i.e.
w o repocpg by only using the patchcpg proposed by graphspd.
as shown in table v the repocpg can improve the performance of repospd on all datasets.
specifically incorporating the repository level information to construct the repocpg leads to the average drop of .
in accuracy and .
f1 score on two datasets.
especially on the spi db dataset repocpg boosts the performance by .
for accuracy and .
for f1 score respectively.
in addition we attribute the relatively small improvement on the patchdb dataset to the higher number of dependencies which is approximately twice that of spi db .
the complex inter dependencies may hinder the model s learning process to some extent.
structure aware patch representation to investigate the impact of the structure aware patch representation we construct two experimental variants for comparative analysis a variant exclusively utilizes the graph based branch i.e.
w o sequence and another solely employs the sequencebased branch i.e.
w o graph which verify the effectiveness of capturing semantic and structural information for detecting security patches respectively.
our findings indicate a consistent performance decline across two datasets when the variants operate independently.
specifically the variant using only the graph branch exhibits a decrease of .
while the variant relying solely on thetable v the experimental results of repospd in patchdb and spidb datasets when removing the repocpg i.e.
w o repocpg removing the sequence branch i.e.
w o sequence removing the graph branch i.e.
w o graph and removing the progressive learning i.e.
w o progressive in three metrics.
dataset variant accuracy f1 score fp rate w o repocpg .
.
.
w o sequence .
.
.
w o graph .
.
.
w o progressive .
.
.
w o change order .
.
.92spidb repospd .
.
.
w o repocpg .
.
.
w o sequence .
.
.
w o graph .
.
.
w o progressive .
.
.
w o change order .
.
.62patchdb repospd .
.
.
sequence branch shows a decrease of .
in terms of accuracy.
this demonstrates that the sequence branch exerts more influence on repospd.
furthermore the graph branch notably reduces the fp rate with the decrease of .
and .
in the spi db and patchdb datasets respectively.
this underscores the importance of structural information to increase the performance of security patch detection.
we can achieve that both the graph and sequence branches contribute to the overall performance of repospd each playing a crucial role in security patch detection.
progressive learning to understand the effect of progressive learning we also implement two variants for comparative analysis a variant of repospd without the progressive learning component i.e.
w o progressive thereby requiring the model to learn weights simultaneously across all components.
another variant first trains the graph representation and then refines it into a sequence representation i.e.
changes order .
specifically the performance consistently shows an average decrease of .
in accuracy and .
in f1 score across spi db and patchdb datasets without a progressive learning component.
it also demonstrate that repospd performs well across two datasets with an average improvement of .
in accuracy and .
in f1 score while reducing the fpr by .
.
these results underscore the different branches have different learning strategies across various branches of the repospd with each branch learning unique discriminative representations.
it allows for staged optimization and more targeted learning of different branches which in turn enhances the overall capabilities of detecting security patches.
answer to rq4 all components including repocpg construction structure aware patch representation and progressive learning enhance the performance of repospd.
9table vi the experimental results between repospd and codet5 on false negativese.
dataset baseline precision recall f1 score patchdb codet5 .
.
.
repospd .
.
.
spi db codet5 .
.
.
repospd .
.
.
vi.
d iscussion a. why does repospd work?
we identify the advantages of repospd which can explain its effectiveness in security patch detection.
incorporating repository level information to help the security patch detection.
we propose repocpg to integrate repository level dependencies which enhances the performance of security patch detection.
as illustrated in fig.
a the example is drawn from a resource leakage vulnerability in the linux kernel i.e.
cve .
specifically the function tipc nl compat link dump in net tipc netlink compat.c fails to copy a particular string line thereby allowing local users to access sensitive data from the kernel stack memory.
this issue is addressed in lines through the use of nla strlcp .
however nla strlcp is not defined within the patch itself.
repospd effectively incorporates nla strlcp as a dependency into repocpg and accurately identifies the security patch.
effectively capturing both structural and sequential information among multiple code changes.
we propose the structure aware patch representation to comprehend the relationships among multiple code changes.
as illustrated in fig.
c the tiffmalloc call at line of the pre patch code implicitly assumes successful memory allocation which effectively acts as an implicit assertion check.
this assumption may lead to buffer overflows in release mode particularly when handling atypical tile sizes.
furthermore the patch includes a total of code changes.
repospd can extract the structural dependency between line and line which collaboratively changes the function fpdiff .
additionally repospd captures the semantic information revealing that line and line utilize identical statements to address the vulnerabilities.
based on the structural and semantic information repospd effectively detects the security patch.
b. impact of repository level context on false negatives we also perform experiments on the impact of repositorylevel context on false negatives and the results are listed in table vi.
the experimental results demonstrate that repospd outperforms the current state of the art baseline codet5 in out of cases.
specifically repospd achieves improvements of .
in precision and .
in recall on the patchdb dataset.
the sole exception is in the recall metric in spidb where codet5 surpasses repospd by .
.
it may be attributed to the additional context which in some cases has a minor impact on the rate of false negatives.table vii time cost between repospd and codet5 per epoch training and inference time.
baseline time dataset patchdb spi db codet5train time s .
.
inference time s .
.
repospdtrain time s .
.
inference time s .
.
c. training and inference time we have conducted a detailed analysis of the training and inference time costs per epoch for both repospd and codet5 as presented in table vii.
the results indicate that repospd requires only .
seconds for training per epoch and .
seconds for inference in the test set.
in comparison the bestperforming baseline codet5 requires .
seconds for training and .
seconds for inference.
the reason is that the graph branch is more efficient than the sequence branch pre trained model .
d. threats and limitations we have identified the following major threats and limitations constraints of data collection.
to facilitate the identification of security patches at the repository level we meticulously extracted and versions of repositories from platforms such as github to reconstruct spi db and patchdb .
despite our extensive efforts to crawl the largest known repositories some repositories listed in the national vulnerability database nvd remained inaccessible.
in our future work we aim to expand our collection of security patches.
generalizability on other programming languages.
in this paper we construct the repocpg using joern tree sitter and cflow specifically tailored for c c .
while our experimental evaluations are focused on c c the repospd can be extended to support other programming languages by integrating code analyzers that accommodate the respective syntax and structural paradigms.
in future work we plan to explore the applicability and effectiveness of repospd across wider programming languages such as java and python thereby broadening its applicability for security patch detection.
restrictions of dependency extraction in repository.
we do not use the entire dependency graph in the repository due to the size of the repocpg and the limitations inherent in static analysis techniques.
while this approach is generally sufficient it fails to encompass all scenarios such as multilevel function calls within the repository.
a potential solution to enhance the coverage could involve the development of additional rules and the application of more sophisticated slicing methods to construct the repocpg.
vii.
r elated work security patch detection is crucial for enabling users to identify and apply updates addressing vulnerabilities on a libtiff tif predict.c b libtiff tif predict.c fpacc ... tmsize t cc return tmp uint8 tiffmalloc cc .
if !tmp return fpdiff ... tmsize t cc tmsize t wc cc bps tmsize t count uint8 cp uint8 cp0 uint8 tmp uint8 tiffmalloc cc .
uint8 tmp .
fpdiff ... tmsize t cc s cc bps stride !
return .
tmp uint8 tiffmalloc cc .
if !tmp return predictorencodetile ... tifferrorext tif tif clientdata ... tifffree working copy .
return a net tipc netlink compat.c b net tipc netlink compat.c static int tipc nl compat link dump struct tipc nl compat msg msg link info.dest nla get flag link link info.up htonl nla get flag link strcpy link info.str nla data link .
nla strlcpy link info.str nla data link tipc max link name .
return tipc add tlv msg rep tipc tlv link info link info sizeof link info size t nla strlcpy char dst const struct nlattr nla size t dstsize size t srclen nla len nla char src nla data nla if srclen src srclen if dstsize size t len srclen dstsize ?
dstsize srclen memset dst dstsize memcpy dst src len return srclen a an example of security patch cve .
b a dependency extracted from cve .
c an example of security patch cve .
15fig.
a and c represent the security patch for resource leakage vulnerability cve and buffer overflow vulnerability cve respectively.
fig.
b is the dependency i.e.
repository information extracted from cve2016 to construct repocpg.
time .
it is important in oss where it is recommended to address vulnerabilities silently until they are publicly disclosed .
initially security patch detection primarily employed rule based and traditional machine learning techniques .
for example li et al.
conducted an empirical study on security patches.
wu et al.
developed symbolic rules to characterize security patches.
vccfinder utilizes svm to identify potential vulnerabilities in open source projects.
subsequent research has incorporated dl based methods for security patch detection .
zuo et al.
highlighted the role of commit messages in detecting security patches and introduced a transformerbased approach.
patchrnn integrates both source code and commit messages to improve performance for identifying security patches.
graphspd proposes the patchcpg and employs a graph based approach for security detection.
vulfixminer extracts added and removed code from commits utilizing codebert to identify security patches in java and python.
despite these advancements existing methods do not consider the repository level dependency and struggle to comprehend the relationship among multiple code changes within a patch.
to address these challenges we propose a repositorylevel security patch detection framework repospd.
we also extend both spi db and patchdb to the repository level.
viii.
c onclusion in this paper we propose a repository level security patch detection framework named repospd which comprises therepocpg construction to incorporate repository level dependency a structure aware patch representation for comprehending the relationship among multiple code changes and progressive learning to facilitate the model in balancing semantic and structural information.
we further extend two widelyused datasets spi db and patchdb to the repository level incorporating a total of and versions of repository in c c programming languages respectively denoted as spi db and patchdb .
compared with the state ofthe art approaches the experimental results underscore the effectiveness of repospd for security patch detection.
our source code and detailed experimental results are available at .