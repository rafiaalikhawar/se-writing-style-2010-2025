module aware context sensitive pointer analysis haofeng li chenghang shi jie lu lian li and zixuan zhao sklp institute of computing technology cas china university of chinese academy of sciences china zhongguancun laboratory china huawei technologies co. ltd china lihaofeng shichenghang21s lujie lianli ict.ac.cn abstract the java platform module system jpms has found widespread applications since introduced in java .
however existing pointer analyses fail to leverage the semantics of jpms.
this paper presents a novel module aware approach to improving the performance of pointer analysis.
we model the semantics of keywords provides anduses injpms to recover missing points to relations.
we design a module aware context sensitive analysis which can propagate and apply critical contexts by exploiting modularity to balance precision and efficiency better.
we have implemented our module aware pointer analysis named mpa in tai eand conducted extensive experiments to compare it with standard object sensitivity.
the evaluation results demonstrate that mpa finds more reachable methods and enhances existing context sensitive approaches striking a good balance between efficiency and precision.
mpa can increase the number of reachable methods up to .
lombok under the same analysis.
performance wise mpa is nearly as fast as contextinsensitivity for most benchmarks while its precision is superior to that of object sensitivity on average.
index terms pointer analysis context sensitivity jpms i. i ntroduction pointer analysis statically determines the points to set of a pointer variable p i.e.
the set of abstract memory locations p may point to at runtime.
such pointer information serves as a foundation for an array of applications such as information flow analysis program understanding bug detection and program optimization to name just a few.
the ability of a pointer analysis to find more reachable methods precisely is crucial for the effectiveness of its client applications.
for example a taint analysis may fail to capture information leaks if the underlying pointer analysis fails to find enough methods.
in contrast the imprecision of a pointer analysis can lead to over tainting issues causing poor performance and overwhelming false positive reports which makes the taint analysis less practical.
a prevalent approach to enhancing the precision of pointer analysis is to employ context sensitivity .
contextsensitive pointer analysis decorates a pointer with different calling contexts representing distinct runtime paths where a context is represented as a sequence of context elements .
according to context elements there are three mainstream variants of context sensitivity call site sensitivity e i is call site object sensitivity e iis receiver object and typesensitivity e iis the type of receiver object or type that con corresponding author.tains the method which allocates receiver object .
for objectoriented programs object sensitivity is believed to be a better choice than call site sensitivity and type sensitivity is regarded as a more efficient but less precise alternative to object sensitivity .
besides choosing a proper set of context elements can also boost the performance and precision of a pointer analysis .
to ease software development and maintenance modern software systems are organized into multiple modules and commonly implemented based on other projects such as standard libraries which are also organized by modules.
the concept of module system has gained popularity such as the java platform module system jpms introduced in java .
the module system provides stronger encapsulation for code and imposes stricter constraints on access which are critical semantic information for pointer analysis.
unfortunately existing pointer analyses are unaware of the module system behind the program code.
specifically if part of the program semantics is encoded in the jpms specification a pointer analysis would miss certain pointsto relations if the specification is overlooked.
for example in one of the benchmarks we evaluated lombok a standard implementation of pointer analysis only discovered application methods.
moreover the internal implementation logic of a module can be quite intricate which often confuses pointer analysis.
particularly a standard k limiting pointer analysis always chooses the most recent kcontext elements making it ineffective in choosing appropriate context elements when analyzing a complex module.
as a result existing techniques often waste a lot of time for context sensitivity with little precision gain.
this paper aims to improve the preformance of pointer analysis for jpms based java programs.
our observation is two fold missing points to relations.
a pointer analysis can find the originally missed points to relations when equipped with the semantics extracted from the jpms specification.
precision.
the module system can guide a pointer analysis to select critical context elements to exploit the tradeoff between precision and efficiency.
based on the above insight we propose the first moduleaware pointer analysis to improve the precision of pointer analysis for jpms and recover missing points to relations.
we have implemented our analysis on top of t ai e a recent ieee acm 47th international conference on software engineering icse .
ieee ieee acm 47th international conference on software engineering icse .
ieee .
icse55347.
.
authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
static analysis framework for java and performed extensive experiments on the d acapo benchmarks and seven popular real world programs.
the empirical results demonstrate a drastic improvement in precision and missing reachable methods by our approach.
to sum up this paper makes the following contributions we propose to model the semantics of keywords provides anduses injpms to recover missing points to relations.
we present a module aware context sensitive approach which employs critical context elements to exploit a sweet spot between precision and efficiency.
to this end we introduce module depth graph definition iii.
an extension of object allocation graph with an efficient on the fly construction algorithm.
we realize our module aware approach as mpa and perform extensive experiments on our benchmarks.
empirical results show that mpa finds more reachable methods and runs as fast as context insensitivity for most benchmarks while obtaining better precision than object sensitivity.
the rest of the paper is organized as follows.
section ii motivates our approach with an example.
section iii formally describes how to model the semantics of keywords provides anduses injpms and apply module aware context sensitivity.
we evaluate the effectiveness and efficiency of module aware pointer analysis in section iv.
section v reviews related work and section vi concludes this paper.
ii.
m otivation in this section we first briefly introduce the module system.
then we use two examples to illustrate how to improve the performance of pointer analysis by utilizing the semantics of the module system.
a. module system the module system is gradually being introduced as a firstclass citizen in programming languages.
for instance the module system was introduced in java named java platform module system jpms whose main purpose is to organize java applications into modules for encapsulation.
to define a module jpms introduces a specific file called moduleinfo which uniquely defines the name and constraints of the module.
the file begins with a module definition of the module name using the keyword module.
following the module definition five principal directives namely requires exports provides uses and opens are employed to manage dependencies encapsulate module internals facilitate service providers and consumers and reflective access and openness.
the details can be found on the official website of oracle .
we will introduce these directives with code examples in the following sections.
in addition c also introduced module system.
b. service provider interface spi in this section we will introduce two directives provides uses and demonstrate their impact on points to relations.thespi is an api that defines a set of plugin style services or drivers allowing applications to discover and load implementations of specific services at runtime.
the idea behind the spi is to separate the definitions interfaces or abstract classes of services from their implementations.
since java jpms introduces the two keywords provides and uses to define the mappings from service definitions to implementations.
the spi scheme with its features of loose coupling extensibility and dynamic loading is friendly to software development but brings a lot of inconvenience to static program analysis.
due to the separation of interface and implementation the implementation classes are not explicitly initialized in the code making it impossible for existing pointer analyses to determine the specific points to relationship of interface variables leading to unsound results.
let us study spi since java with an example in figure .
there are two modules m1andm2 in the example.
in m2module there are two classes dog lines and cat lines both of which implement the animal interface lines .
the module info file of m2 lines defines the mappings from the animal interface to its implementations dog andcat using the provides keyword.
them1module depends on m2module and uses the animal interface according to the keywords requires and uses in lines .
the main method demonstrates the use of the javaserviceloader mechanism to dynamically load and instantiate classes that implement the animal interface.
the serviceloader is a utility provided by the java platform that enables the discovery and loading of service providers at runtime.
at line the serviceloader.load method is invoked with the animal interface as its argument indicating that we are seeking implementations of this interface.
at line an iterator containing implementations corresponding to the animal interface is obtained by invoking the iterator method of the serviceloader.
this iterator allows us to iterate and dynamically instantiate all available implementations of the animal interface.
according to the module info files of m1andm2 dog andcat are the implementations of the animal interface.
so the target method at line should be the run method of dog andcat.
to construct a complete call graph the spi should be modeled precisely to maintain the mappings from interfaces to implementations.
firstly we need to parse the module info files of m1andm2 to extract mappings from animal todog andcat.
then we need to bind the mappings to variable loader at service loading points line and maintain it across the iterator lines .
finally we retrieve implementations from the iterator create dog andcat objects assign them to the variable a and restore missing points to relations and call graphs.
c. precision in java the jdk is divided into modules with the java.base module being the most fundamental and core module.
it contains essential packages such as java.lang java.util java.io etc.
next we will illustrate how to enhance the performance of context sensitive pointer analysis authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
1void main serviceloader animal loader serviceloader.load animal.class iterator animal iter loader.iterator while iter.hasnext animal a iter.next a.run 9module m1 requires m2 uses animal 13interface animal public void run 16class dog implements animal public void run 19class cat implements animal public void run 22module m2 provides animal with dog cat fig.
an example of spi with two keywords uses and provides injpms.
by leveraging the semantics of the module system using a simplified code example of java.util.hashmap from the java.base module.
as shown in figure the simplified code snippet of hashmap is given in lines to .
in this module the java.util package is exported line allowing types in this package to be accessed by modules that require this module.
the hashmap stores data in table an array of node objects line .
the put method creates a node object and stores it in table lines .
the get method retrieves the corresponding node object from table then returns its value via the getvalue method lines .
there are two modules m3andm4 where the methods foo andbar are defined respectively.
both modules depend on the java.base module according to their module info files lines and lines .
it should be noted that the java.base module is always implicitly required by all other modules meaning that developers do not need to explicitly declare a dependency on java.base.
in the foo andbar methods there are hashmap objects o1 line and o2 line respectively.
object oais created and put into o1at line then retrieved back via the get method at line .
similarly object obis created and put into o2at line then retrieved back at line .
as a result the two cast operations lines and will never fail.
in a object sensitive analysis abbreviated as 1obj the receiver objects for the calls to the put get methods at line and line are o1ando2 respectively.
hence the call to put get methods at different call sites can be distinguished using contexts and .
in put lines with 1obj analysis we get pts n o4 andpts n o4 .
then in the constructor of node lines since o4is the only receiver object we get1void foo hashmap map1 new hashmap o map1.put a new a o a object v1 map1.get a a a a v1 cast may fail?
7module m3 requires java.base 10void bar hashmap map2 new hashmap o map2.put b new b o b object v2 map2.get b b b b v2 cast may fail?
16module m4 requires java.base 19class java.util.hashmap ... node table new node o3 public void put k k v v node n new node k v o table n public final v get k k node n table return n.getvalue class node ... k key v value node k p v q key p value q public final v getvalue return value 39module java.base exports java.util to m3 m4 fig.
simplified code example of java.util.hashmap injava.base module.
pts value oa ob .
as a result call to o1.get ando2.get will return a value pointing to both oaandob leading to cast may fail false alarms at line and line .
this example can only be precisely analyzed when the context depth is set to more than .
in put with 2obj analysis we get pts n o4 andpts n o4 where object o4is qualified with a heap context.
hence the constructor of class node lines is analyzed twice with distinct contexts and .
thus we can precisely compute the pointer values of value as pts value oa and pts value ob .
finally we can correctly analyze that pts v1 oa andpts v2 ob avoiding false cast may fail alarms.
it is noteworthy that o1ando2are critical context elements when analyzing the codes of hashmap andnode.
we can also observe that o1ando2are the receiver objects for the put andget methods at lines and which are module frontiers whose call site and target method locate in distinct modules.
for instance the call site at line is in m3 module and the put method is in the java.base module.
authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
hence we can use the receiver objects module frontiers as key context elements and propagate them when analyzing the target module.
in that sense o1ando2are critical context elements when analyzing put get method at line and line and they are propagated when analyzing the code in the target module java.base.
hence the constructor of class node lines is analyzed twice with distinct contexts and .
thus we can precisely compute the pointer values of value aspts value oa and pts value ob .
iii.
m ethodology this section formally illustrates module aware pointer analysis including the modeling of spi and module aware context sensitivity according to the semantics of jpms.
a. preliminaries this section presents the notations and functions illustrated in figure which will be used in our formalism.
before integrating the semantics of the module system into the pointer analysis we need to extract the semantics from a given module info file.
due to space constraints the details are omitted.
we use the following symbols to represent the semantic information of a module.
r m7 m maintains the modules a given module depends on.
e m m n keeps the packages that can be exported from mmodule to m module.
p m t t provides the mappings from interfaces to implementations.
u m7 t declares the interfaces of spi used by a module.
let us revisit the examples in figure and figure .
for figure the results of parsing module constraints are r m1 m2 u m1 animal p m2 animal dog cat .
for figure the results are e java.base m3 java.util e java.base m4 java.util r m3 java.base r m4 java.base .
for forward compatibility jpms introduced the concept of an automatic module to migrate pre existing non modular libraries regular jar files .
a regular jar file in the classpath of an application is regarded as an automatic module which implicitly requires all other modules including jdk modules and all user defined modules of the application.
moreover an automatic module exports all its packages making them accessible to other modules of the application.
it is worth pointing out that our approach works identically for both normal modules and automatic modules.
b. module aware context sensitivity in this section we formalize how to utilize the constraints of the module system to balance the efficiency and precision of context sensitive pointer analysis.
section iii b1 presents the rules for the respective five kinds of statements.
in new and call we use module frontier section iii b2 as the critical context element.
to apply such the critical contextelement module frontier to the internal code of a module section iii b3 introduces several subroutines in algorithm and algorithm used in the rules of section iii b1 to construct mdg on the fly.
rules of module aware context sensitivity figure illustrates our formalism to pointer analysis.
fundamentally this approach aligns with the methodologies presented in previous works as they all describe andersen style pointer analysis for java.
without loss of generality we use the five rules and to handle the respective five kinds of statements which can represent a simplified subset of java.
it should be noted that we omit the details found in previous works.
to integrate with module aware analysis the traditional context c1 receiver objects call sites etc.
is extended with module aware elements c2 module frontiers denoted as c1 c2 .
given context c1with a sequence of elements c1 and a new element e we use the notation c1 efor andc1kfor where k n. we introduce modulectx to select a particular module aware context with additional constraints to model the semantics of the module system highlighted in blue .
for the rules and we have not made any modifications we merely extracted the pointsto set of the right hand side of the statement and incorporated it into the points to set of the left hand side.
innew the declaring method of the statement l lis m. for m we can utilize the classof function to resolve its declaring class which is then used to identify its containing module musing the moduleof function.
meanwhile an abstract heap object ol hof type cis created.
similarly the module m containing type cis found using the moduleof function.
according to the semantics of jpms the module m needs to depend on the module m m r m or both mandm have to be the same m m .
incall similar to new we sequentially invoke the functions methodof classof and moduleof resulting in the identification of the declaring module mof the statement l. we can resolve the target method m using the dispatch function with signature fand receiver object o0as arguments.
then we can determine the module m in which the type t the containing class of m is declared.
both modules m andm need to satisfy the constraints of jpms which have been discussed in the explanation of new.
in addition the package pof type t should be accessible for module m p e m m .
the function modulectx is used to select the module aware context.
a detailed demonstration will be provided in the subsequent sections.
modulectx o c depthof o g mdg c20 depthof o g mdg d otherwise module frontier as mentioned in section ii c the receiver object of a method invoked in another module is a critical context element.
we define the term module frontier in definition iii.
to represent this kind of receiver object.
we select module authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
modules m m moduleof t7 m gives the containing module of a type packages p n methodof l7 w gives the containing method of a statement types t t classof w7 tgives the declaring class of a method methods m w packageof t7 n extracts the package of a type fields f f constof v7 sresolves the constant class literal of a variable allocation sites oi h typeof s7 treturns the declared type of a constant class literal local variables x y v gen l t7 h generates object according to a type statement labels l l service h7 tmaps from object to service implementation constant class literal s s methodctx w c maintains the contexts used for analyzing a method contexts c1 c2 c dispatch w h7 w resolves a call to a target method actual parameters ai pts vsh f c h c records the points to for a variable or field formal parameters pm i retmreturn variables fig.
notations and auxiliary functions used in formalism.
l x new c m methodof l ctx c1 c2 methodctx m hctx c1k c2 m moduleof classof m m moduleof c m m m r m ol hctx pts x ctx solvecaller m o l l x y m methodof l ctx methodctx m pts y ctx pts x ctx l x y.f m methodof l ctx methodctx m o hctx pts y ctx pts o .f hctx pts x ctx l x.f y m methodof l ctx methodctx m o hctx pts x ctx pts y ctx pts o.f hctx l x a0.f a1 m methodof l ctx methodctx m o0 hctx pts a ctx hctx c1 c2 c modulectx o c2 ctx c1 o0 c m dispatch f o t classof m m moduleof t t classof m m moduleof t p packageof t m m m r m p e m m ctx methodctx m o0 hctx pts thism ctx pts a ctx pts pm ctx pts retm ctx pts x ctx solvecallee o m fig.
rules for module aware context sensitive pointer analysis.
frontiers as contexts and propagate them into the target modules serving as contexts for the methods within those modules.
however the number of contexts will increase significantly if the propagation of module frontiers is not limited.
in our insights methods closer to the module frontiers are more significantly affected.
therefore we designed an efficient approach to limit the propagation depth of module frontiers.
the details are provided in the following section.
definition iii.
.
the module frontier is a set of receiver objects mf where ol mf is a receiver object of a target method m at a call statement l x a0.f ... whose declaring method is m. if the corresponding modules of methods mandm are different olis considered a module frontier.
we can define the module frontier more formally using the following rule.
l x a0.f ... m methodof l o0 pts a m dispatc h f o t classof m m moduleof t t classof m m moduleof t m m o0 mf module depth graph themodule frontier can help us select critical context when solving context sensitive pointer analysis.
however when processing the code within a module the information of the module frontier will be missed.
so we need to propagate the module frontier into the internal code of a module.
to achieve this goal we propose a module depth graph mdg .we can propagate the module frontier along the mdg.
in the meantime we can limit the propagation depth based on mdg.
before presenting mdg we first introduce the object allocation graph which is the foundation of mdg.
as definition iii.
shows the oag proposed by tan et al.
is used to describe the relationship of object allocation.
a path with knodes in an oag such as ok ok ... o2 o1 is exactly matched with a context of a method mfork object sensitivity where o1is the receiver object of mando2is the receiver object of the method that created object o1 etc.
definition iii.
.
theobject allocation graph oag is a directed graph g n e where nis the set of nodes and erepresents the set of edges.
a node o nrepresents an allocation site which is also the context element in objectsensitivity.
an edge o2 o1 erepresents an object allocation relation where o1is allocated in a method with o2being the receiver object of this method.
in order to construct oag it is necessary to aggregate all objects along with their respective receiver objects.
previous work relies on a pre analysis which is considerably slower to calculate such relationships.
to improve the overall performance we design an on the fly algorithm to build the oag.
it is worth noting that the on the fly algorithm leverages context sensitive points to information making it more precise than the original algorithm.
algorithm introduces two authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
subroutines solvecallee andsolvecaller to build oag on the fly.
in procedure solvecallee each object o allocated in method m computed by the pre analysis is collected.
the procedure addedge is then invoked to add the edge o o into oag signifying that ois the receiver object of the method allocating o .
the solvecaller introduces an edge o o between o and each receiver object oof the method mallocating o .
according to the definition of the oag definition iii.
receiver objects of a method mand objects allocated in the method mare two kinds of primary elements to build an oag.
we focus on two kinds of statements the new statement which creates objects within a method and the call statement which identifies the receiver objects of a method.
as figure shows we extends the rules of newandcall.
in the newrule when an object olis created the solvecaller function is invoked with mandolas arguments.
in the call rule when the receiver object o0ofm is resolved the solvecallee function is invoked with o0andm as arguments.
this way all object allocation relations can be efficiently computed by extending rules newandcall highlighted in cyan thereby avoiding a time consuming pre analysis.
algorithm building object allocation graph 1global object allocation graph g n e 2procedure solvecallee o m foreach object o allocated in method mdo addedge o o 5procedure solvecaller m o foreach receiver object oof method mdo addedge o o 8procedure addedge o o ad add o inton addo o intoe buildmdg o buildmdg o theorem .
correctness .
both the original oag algorithm and the on the fly oag algorithm can construct the same oag.
proof sketch.
theworklist algorithm is usually used to solve andersen style pointer analysis.
the algorithm iteratively processes statements in a program by applying the rules in figure .
when applying the n ewrule there will be edges from all discovered receiver objects of the declaring method of the n ewstatement to the object created at this statement.
similarly when applying the call rule there will be edges from all discovered receiver objects of the target method to the known objects allocated in the target method.
therefore regardless of whether a receiver object oof a method mor an object o allocated in mis discovered firstly there will always be an edge o o added to oag.
let us apply the on the fly algorithm to build the oag of the program in figure .
figure shows the resulting oag where the object orrepresents a unique fake entry object.or ob oa o1 o2 o3 o4 fig.
the oag of the program in figure because the receiver objects of methods foo andbar are unknown in the code snippet we use the dashed arrow 99k originating orto represent these unknown edges.
suppose the foo method is solved first we can obtain the points to set of variable map1 which is o1 at line and the receiver object of the constructor of hashmap and the put method is o1.
when solving these two methods objects o3ando4are created and the function solvecaller is applied.
in other words edges o1 o3ando1 o4are added into the oag.
when solving the bar method object o2is generated.
when handling the c all statements whose target methods are the constructor of hashmap and the put method respectively the function solvecallee is applied.
because objects o3 ando4which are allocated in the two methods have been resolved according to previous steps the edges o2 o3and o2 o4are added into the oag.
leveraging oag we can efficiently construct mdg in a timely manner.
the formal definition of mdg is provided in definition iii.
.
definition iii.
.
the module depth graph mdg is a directed graph g n d e where nandeare the same as that in the oag drepresents the length of the shortest path from a module frontier node to the current node.
for n d n d ifnis a module frontier the dwill be set to zero.
the mdg is built by annotating the oag with module depth.
as defined in definition iii.
a node in the mdg is a pair n d where nis an object in the oag and drepresents the propagation depth.
without sacrificing consistency we incorporate dintonas a field in our implementation.
by default dis initialized to the unknown depth .
algorithm augments the oag algorithm algorithm to build mdg on the fly when an object ois added into the oag line in algorithm gather apply scatter gas model is performed in lines to compute its propagation depth.
if object ois a module frontier we use the scatter procedure to propagate it to its successor nodes whenever its depth changes.
otherwise we gather its predecessors and calculate the minimum propagation depth lines .
then the minimum value will be increased by and applied to object ousing the apply procedure lines during which the depth of owill be updated if the target value is less than the original depth.
the updated depth will be scattered to the successor nodes lines .
in the scatter procedure lines if the depth of an object changes it will be recursively scattered to its successor nodes.
figure illustrates the mdg of the program shown in figure constructed using algorithm .
as described in section iii b3 object o1is discovered first identified as a module frontier according to definition iii.
.
therefore its authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
algorithm building module depth graph 1global module depth graph gmdg nmdg d emdg 2procedure buildmdg o ifo mf then ifapply o then scatter o else preddepth gather o ifpreddepth then ifapply o preddepth then scatter o 11procedure gather o preddepth foreach predecessor node o d of o d in gmdg do preddepth min d preddepth return preddepth 16procedure apply o target let o d ingmdg iftarget d then d target return true return false 22procedure scatter o foreach successor node o d of o d ingmdg do ifapply o d then scatter o or ob oa o1 o2 o3 o4 fig.
the mdg of the program in figure depth is set to zero.
at this stage the successors of o1are unknown therefore the procedure scatter does nothing.
when objects o3ando4are generated the depth of their unique predecessor o1 calculated by the gather procedure is determined to be zero.
consequently the depths of o3and o4are each set to one.
another module frontier o2 also has its depth set to zero upon creation.
when the scatter procedure is applied the depths of o3ando4 which are successors of o2 remain unchanged.
let us revisit the rule.
before introducing modulectx we use the function depthof to retrieve the module depth of object oin the mdg gmdg.
if the depth equals zero which means the receiver object ois a module frontier o mf is regarded as the context in analyzing a method call with obeing a receiver object.
when the module depth is greater than zero and less than d the heap context hctx is used as the context of the method.
in other words the module frontier is selected as critical context and propagated along the mdg until the depth reaches d. finally the module context and standard context are combined to form the context ctx of the target method m .
revisiting the motivating example let us apply our module aware context sensitivity to perform pointer analysis on the example in figure .
in foo object o1is created at line and assigned to variable map1 which is the receiver variable of method put.
since o1is a module frontier the context of the method is at line .
similarly o2is created at line and used as the receiver object of the put method with its context at line being .
consequently we can differentiate the two invokes of put based on their distinct contexts.
this also allows us to distinguish the points to information of the variable vacross different contexts.
in put o4is generated with two different heap contexts and .
since the receiver object of the constructor of node iso4 with a module depth of the heap contexts and are used as the contexts of the constructor.
notably o1ando2are module frontiers propagated to o4along the mdg.
therefore the pointsto information of the variable qcan be distinguished under different contexts in line .
similarly the methods get andgetvalue can be distinguished based on the contexts and .
ultimately this analysis allows us to correctly determine that pts v oa andpts v ob thereby avoiding false cast may fail alarms.
c. modeling spi java s spi mechanism is now widely used in various frameworks and libraries to enhance modularity and flexibility including jdbc dubbo jndi spring slf4j etc.
however for pointer analysis without handling spi we may miss objects that are created dynamically according to spi configuration.
to model spi we separate it into three parts loading a service according to an interface iterating each implementation of the service and applying each implementation.
we use the following three sets to define these parts.
loader a set of pairs m i where mrepresents the method that is used to load service according to a constant class literal which is the i th parameter of method m. transfer a set of methods that propagate services from the receiver variable of the call site to its lhs variable such as the iterator method of collection.
retrieve a set of methods that are used to retrieve the implementations of service.
figure shows the formalization of modeling spi by the following three rules.
.
for an invoke statement if its target method m is a l oader method whose i th parameter is the service interface we can get the constant class literal according authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
l x y .f ... s constof a k o pts x o0 pts y m dispatch f o0 m k loader m methodof l m moduleof classof m m moduleof classof m t typeof s t u m t p m t m m m r m t ser vice o l x y.f ... o0 pts y o pts x m dispatch f o0 m transfer t service o t service o l x y.f ... ctx methodctx methodof l o0 pts y ctx m dispatch f o m retrieve t service o o gen l t o ctx pts x ctx fig.
rules for modeling spi.
to the actual parameter aiand resolve its type tby the function typeof.
it should be noted that when the service interface type is not directly given as a class literal we query its points to sets to obtain the set of class literals propagated to it.
the only case that cannot be handled is when the propagated value is from user input.
however this is an extremely rare case and we did not encounter such a case in our evaluated applications.
then we will check whether current module musestbyuand get the implementation t of the interface taccording to p. then these implementations will be bound to the object pointed to by the lhs variable of this invoke statement by theservice function.
it should be noted that the points to set of the lhs variable may be unknown when processing this invoke statement we will bind the implementations to thelhs variable and rebind them to the objects pointed to bylhs variable once the points to set has been resolved.
.
for an invoke statement whose target is a t rans fer method the implementations are propagated from the object pointed to by the receiver variable of this call site to the object pointed to by the lhs variable.
.
the r etrieve methods apply an spi service.
for an invoke statement whose target is a r etrieve method we use the service function to retrieve implementations corresponding to the receiver object of this invoke and then create objects according to these implementations by the gen function and then add these objects into the pointsto set of the lhs variable to maintain complete points to relations.
let us apply the three rules above to perform pointer analysis on the example in figure .
at line there is a loader method serviceloader.load with a service interface animal.
according to the module info files of modules m1andm2 the m1module usesanimal interface and the m2module provides two implementations dog and cat.
so we bind dog andcat to the objects pointed to by variable loader which can be represented to service o dog cat .
at line the serviceloader.iterator method is a t ransfer method so we just propagate implementations from objects pointed to by variable loader to objects pointed to by variable iter which means that service o dog cat .
at line the iterator.next method is a r etrieve method so we retrieve implementa tions dog andcat from service o and create two objects odogandocatwhose types are dog andcat respectively.
then the points to set of variable ais odog ocat .
finally we can resolve the target methods to the run methods of dog andcat at line .
without modeling spi the points to set of variable ais empty and the run methods of dog andcat will be unreachable.
therefore more methods can be analyzed by modeling the spi.
iv.
e valuation to evaluate the impact of our research we focused on the following research questions in our assessment of contextinsensitivity k object sensitivity and mpa which applies our module aware approach to pointer analysis rq1.
does mpa find more reachable methods?
rq2.
can mpa improve performance?
rq3.
is on the fly algorithm of the mdg efficient?
rq4.
how is the precision and efficiency of mpa under different depths of mdg?
experimental settings when analyzing a program we set the timeout budget to .
hours consistent with previous works .
all experiments were conducted on an intel xeon .0ghz machine with tb of ram running clear linux os.
since jpms was introduced in jdk9 differing from previous works that relied on experiments with jdk1.
we analyze programs on jdk17.
this long term support version is also recommended by t ai e .
the maximum heap size of the jvm is set to 500gb with xmx .
implementation we implemented our module aware approach on top of t ai e a recent popular static analysis framework for java.
we implemented the on the fly algorithms algorithm and algorithm to build the oag and the mdg based on the original algorithm in t ai e. the default depth of mdg is set to d .
we use mpa as module aware context insensitive andersen s analysis .
the notation mpa kobj represents the mpa scheme applied to k object sensitive analysis.
benchmarks similar to previous works we evaluated mpa using the d acapo suite where each jar file is treated as automatic modules by jpms to ensure forward compatibility as these benchmarks were developed before jpms.
the automatic modules require all other modules implicitly.
in d acapo jython is excluded because context insensitivity fails to scale for it.
in addition we select three widely used programs ant antlr4 checkstyle that were migrated from earlier versions of jdk before jdk9 to jdk9 or later versions and the three programs are also treated as automatic modules in our moduleaware analysis.
at last we also evaluate against four popular programs jboss logback questdb and lombok with .9k .5k and .6k stars on github respectively that were developed based on jdk9 or later and fully utilize the features of jpms.
the diversity selection of both traditional applications d acapo ant antlr4 and checkstyle and modularized applications jboss logback questdb authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
table i comparing the metrics of three programs with or without modeling spi spi or non spi for contextinsensitive analysis.
for all numbers larger is better.
programs analysesmetrics f ail cast reach mtd call edge poly call logbacknon spi spi lomboknon spi spi questdbnon spi spi andlombok demonstrate that our approach is applicable to all kinds of java programs.
precision metrics following previous works we assess the precision of pointer analyses utilizing four essential metrics the number of casts that may fail failcast the number of reachable methods reach mtd the number of call graph edges call edge and the number of polymorphic calls discovered poly call .
same as previous work we collect the four metrics in the application code which is the part that developers are most concerned about.
a. rq1 discovering more reachable methods excluding the d acapo suite and three programs migrated from early versions of the jdk that did not utilize the spi scheme we use the remaining four programs to evaluate the ability to find more reachable methods.
for jboss mpa cannot find more reachable methods because it does not use provides.
table i gives the number of four metrics with or without modeling spi when analyzing the other benchmarks under context insensitivity.
for lombok only application methods are analyzed without modeling spi while methods are discovered after modeling spi.
for questdb after modeling spi methods were newly discovered compared to the original approach.
for logback only methods are newly handled.
a similar conclusion can be drawn for the other three precision metrics.
the following code snippet illustrates the reason for the significant improvement in reachable methods for lombok.
in the entry method lombok loads the service of lombokapp and then invokes the runapp method lines .
without modeling spi objects of lombokapp implementations will be excluded from the points to set of the variable app resulting in the inability to analyze runapp methods of these implementations.
1void main iterable apps spiloadutil.findservices lombokapp.
class for lombokapp app apps app.runapp the three benchmarks logback lombok and questdb invoke spi interfaces once times and once respectively.
as described in section iii c traditional pointer analyses here we use context insensitive analysis cannot determine the target methods of those spi interface invocations often resulting in a large number of unreachable methods.
nevertheless our approach precisely resolves the target methods ofspi invocations by faithfully modeling the semantics of spi.
we manually examined each resolved spi invocation target and confirmed that there were no false positives.
those newly discovered spi invocation targets are then analyzed using the same context insensitive analysis making more methods invoked by those targets reachable.
as a result we observe a significant increase across all four metrics in table i. b. rq2 performance in this section we investigate the efficiency and precision of the module aware approach by applying mpa to standard context insensitive ci object sensitive 1obj objectsensitive 2obj and selective sensitive z ippere pointer analyses.
the spi modeling is integrated into all tools to ensure a fair comparison.
efficiency table ii gives the time and precision metrics of all tools for our benchmarks.
the times represent the total time for each analysis.
compared to ci mpa runs as fast as cifor most benchmarks such as antlr eclipse hsqldb luindex lusearch etc.
on average mpa is .
slower thancifor all benchmarks.
compared to 1obj and2obj mpa kobj can achieve slight speedup .
and0.
respectively on average with precision improvements for all benchmarks.
precision as table ii shows mpa is noticeably more precise than cifor all precision metrics across all benchmarks.
for fail cast reach mtd call edge and poly call the ratio of the number reported by mpa against that reported by ciis .
.
.
and .
respectively.
especially for fail cast mpa can reduce almost half of the false positives reported by cion average.
compared to 1obj mpa is significantly more precise on fail cast metric and slightly more precise on the other three metrics on average.
for fail cast reach mtd call edge and poly call the ratio of the number reported by mpa against that reported by 1obj is .
.
.
and .
respectively.
in addition mpa kobj is always more precise thankobj for all benchmarks.
compared to zippere the last two columns in table ii compare precision and efficiency of 1obj and mpa 1obj with or without applying z ippere the state of the art selective context sensitivity approach on our benchmarks.
consistent with the conclusion in z ipperecan achieve substantial speedup with a slight loss of precision than standard k object sensitivity.
compared to 1obj zippere mdg 1obj zippereoffers higher precision reduces reports on the metric fail cast by and is only .
slower.
compared to 1obj mdg 1obj zippereachieves .
speedup with similar precision.
c. rq3 efficiency of mdg builder unlike the original algorithm for oag construction depending on a pre analysis mpa constructs oag and mdg on the fly.
to illustrate the efficiency of our on the fly algorithm we run the standard context insensitive analysis ci equipped with or without the mdg builder and use the time difference authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
table ii efficiency and precision results for tools on our benchmarks.
for all numbers smaller is better.
inde x program metrics ci m pa 1obj m pa 1obj 2obj m pa 2obj 1obj zipperemdg 1obj zippere antlrt ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call bloatt ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call chartt ime s .
.
.
.
.
.
f ail cast reach mtd call edge poly call eclipset ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call fopt ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call hsqldbt ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call luindext ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call lusearcht ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call pmdt ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call xalant ime s .
.
.
.
.
.
f ail cast reach mtd call edge poly call antt ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call antlr4t ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call checkstylet ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call jbosst ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call logbackt ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call lombokt ime s .
.
.
.
.
.
f ail cast reach mtd call edge poly call questdbt ime s .
.
.
.
.
.
.
.
f ail cast reach mtd call edge poly call authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.
between the two analyses as the time for building the mdg.
figure shows the percentage of time spent by mdg against standard context insensitive analysis.
the percentage of the time for building mdg against the time for ciranges from .
antlr4 to .
xalan with an average of .
.
compared to building an mdg using a context insensitive preanalysis our on the fly approach is more efficient.
fig.
the percentage of time spent by mdg against contextinsensitive analysis.
the dashed line represents the average.
d. rq4 performance under different depths as described in section iii b1 as dincreases the number of contexts increases and the precision of analyses also improves.
to select suitable dto balance the precision and efficiency we evaluate mpa under different d d .
hereafter we use mpa ito denote mpa under depth i. in this experiment performance wise mpa 4outperforms all other variants.
in detail the ratio of the time spent by mpa mpa mpa mpa 5against that of mpa 4is .
.
.
and .
respectively.
importantly mpa 4achieves the same precision as mpa 5in all evaluated metrics.
specifically the ratio of the number of fail cast reported by mpa mpa mpa mpa 5against that of mpa 4is .
.
.
and respectively.
for reach mtd the ratio is .
.
and .
for calledge the ratio is .
.
and .
for poly call the ratio is .
.
and .
asdincreases the improvement in the precision of mpa slows down.
compared to mpa mpa 4only achieves slight improvement on fail cast and maintains the same precision on the other three precision metrics.
so we use as the default value of d. v. r elated work in this section we review the previous works that are closely related to this research.
a. context representation according to the representation of context there are three mainstream variants of context sensitivity k object sensitivity k type sensitivity and k call site sensitivity.
in addition to the above three variants the work proposed a hybrid approach that applies object sensitivity to instance method invocations and call site sensitivity to static method invocations.
the value contexts approach used the data flow values of parameters to represent contexts.
generic sensitivity utilized the generic instantiation sites as contexts.
our moduleaware approach can be adapted to the above context sensitive variants by selecting the corresponding kind of context at module frontiers.b.
selective context sensitivity selective context sensitivity allows applying context to partial methods or variables to provide a better trade off between precision and efficiency.
s caler assesses whether a method should be analyzed with context sensitivity based on an estimate of its potential memory usage.
z ipper introduces three types of value flow patterns for pinpointing methods that are critical for precision these patterns are determined by solving a graph reachability problem on a precision flow graph.
consequently this allows for substantial speedup while maintaining most of the precision.
the extended version of z ipper zipper e significantly enhances z ipper s speed while maintaining similar precision.
e agle conducts a pre analysis based on cfl reachability to enable selective context sensitivity in k obj ensuring precision is maintained.
t urner strikes an optimal balance between zipper and e agle facilitating k obj analysis to operate much faster than e agle while achieving higher precision than z ipper.
conch identifies objects that depend on context preventing the excessive growth of contexts.
b aton introduces a unit relay framework by integrating various context selectors collectively.
rather than choosing which methods should undergo context sensitive analysis b ean enhances the precision of k obj sensitive analysis by omitting irrelevant context elements propose a context tunneling approach that offers an elegant and general data driven method for selecting critical context elements and introduce generic sensitivity which always preserves generic instantiation sites as key context elements.
in this paper we provide an alternative that specifically targets module systems we leverage the semantics of module systems to select module frontiers which commonly suggest encapsulation boundaries as critical context elements.
moreover our approach also discovers more reachable methods by modeling spi.
in addition some manually selected metrics and heuristics or learning based approaches have been imposed to selectively analyze a subset of methods with context sensitivity.
vi.
c onclusion we proposed a module aware pointer analysis including modeling spi and module aware context sensitivity based on an on the fly mdg.
we implemented a pointer analysis tool named mpa based on our module aware approach.
mpa can increase reachable methods up to .
.
meanwhile the mpa can run as fast as context insensitivity for most evaluated programs while obtaining better precision than 1object sensitivity.
vii.
a cknowledgment we thank all reviewers for their valuable feedback.
this work is supported by the national key r d program of china 2022yfb3103900 the national natural science foundation of china and and the china postdoctoral science foundation 2024m753295 .
authorized licensed use limited to shanghaitech university.
downloaded on june at utc from ieee xplore.
restrictions apply.