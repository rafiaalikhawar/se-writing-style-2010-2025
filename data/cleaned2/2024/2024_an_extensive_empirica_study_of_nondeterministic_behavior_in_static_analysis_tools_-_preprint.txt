an extensive empirical study of nondeterministic behavior in static analysis tools miao miao university of texas at dallas richardson tx usa mmiao utdallas.eduaustin mordahl university of texas at dallas richardson tx usa austin.mordahl utdallas.edudakota soles university of texas at dallas richardson tx usa dakota.soles.j gmail.com alice beideck university of texas at dallas richardson tx usa alice.beideck utdallas.edushiyi wei university of texas at dallas richardson tx usa swei utdallas.edu abstract recent research has studied the importance and identified causes of nondeterminism in software.
static analysis tools exhibit many risk factors for nondeterministic behavior but no work has analyzed the occurrence of such behavior in these tools.
to bridge this gap we perform an extensive empirical study aiming to understand past and ongoing nondeterminism in popular open source static analysis tools that target types of projects.
we first conduct a qualitative study to understand the extent to which nondeterministic behavior has been found and addressed within the tools under study and find results in tool repositories.
after classifying the issues and commits by root cause we find that the majority of nondeterminisms are caused by concurrency issues incorrect analysis logic or assumed orderings of unordered data structures which have shared patterns.
we also perform a quantitative analysis where we use two strategies and diverse input programs and configurations to detect yet unknown nondeterministic behaviors.
we discover such behavior in out of the tools including which had no results from the qualitative analysis.
we find that nondeterminism often appears in multiple configurations on a variety of input programs.
we communicated all identified nondeterminism to the developers and received confirmation of five tools.
finally we detail a case study of fixing flowdroid s nondeterministic behavior.
index terms nondeterminism staic analysis software testing.
i. i ntroduction static analyses are powerful complex algorithms with many important applications including bug finding and software optimization.
it is critical that these analyses are implemented correctly and produce reliable results in order for them to live up to their potential utility as important development aides.
in recent years there has been a push in the research literature to better ensure the quality and reliability of static analysis tools.
various approaches have been proposed to help tool developers and users test and debug static analysis .
however one significant issue that these works do not touch on is that of nondeterminism .
nondeterministic behavior has been observed in many different types of software often in the context of flaky tests .
past research has found common causes of nondeterminism include concurrency issues caching and test order dependency .static analysis tools exhibit many of these risk factors.
while the analysis algorithms themselves are deterministic there are implementation details such as thread synchronization usage of ordered non ordered data structures and memorization that have previously been associated with nondeterministic behavior.
despite these risk factors there has not been a thorough exploration of the extent to which static analyzers exhibit nondeterministic behavior.
we hypothesize that there is yetundiscovered nondeterminism in static analysis tools that may seriously impede their reliability.
to test this hypothesis we performed the first systematic empirical study to detect analyze and understand nondeterministic behavior in static analysis tools.
we selected popular static analysis tools as subjects of this study wala soot doop and opal for java tajs and wala for javascript pycg and code2flow for python flowdroid amandroid and droidsafe for android and infer for c. these tools represent some of the most popular static analysis tools for these types of projects.
note that we consider wala java and walajs as two distinct tools because there exist different analysis logic and options in wala s codebase for analyzing java and javascript programs.
we designed two separate evaluations to understand the occurrence of nondeterminism in these tools one qualitative study and one quantitative evaluation.
our qualitative study aims to understand the extent to which tool users and maintainers are aware of nondeterminism.
we aim to extract common characteristics of this behavior as well as common fixes.
we analyzed the repositories of each tool in order to find issues and commits that identify nondeterministic behavior.
we extracted issues and commits in total by searching for keywords relevant to nondeterminism.
then we manually analyzed these issues and commits to identify distinct results that report or fix nondeterminism.
we categorized these results based on the root cause of nondeterminism into categories concurrency ordering of data structure analysis logic system dependent or random value early termination anddependency .
we also summarized distinct patterns ofnondeterminism and their solutions that may help future static analysis developers to avoid common pitfalls that lead to nondeterminism.
our quantitative study aims to discover previously unknown nondeterminism in the tools we evaluated.
we ran each tool multiple times across diverse input programs and configurations to detect nondeterministic behavior.
for each target platform java javascript python android and c we selected input program datasets including microbenchmarks and real world programs.
we sampled configurations of these tools and ran them on the input programs in order to discover nondeterminism that may only occur under certain combination of options.
we additionally applied a second strategy adapting an existing tool that modifies standard libraries in order to detect more nondeterminism to four compatible tools.
overall we detected nondeterminism in out of tools specifically total analyzer configurations on input programs.
these results indicate widespread previously unreported nondeterminism in the current versions of popular static analysis tools.
we analyzed the characteristics of the nondeterministic behavior and communicated all identified nondeterminism to the developers of each tool.
the developers of flowdroid soot doop opal and infer confirmed the reported nondeterminism and provided useful insights and or bug fixes.
we additional conducted and report a case study of flowdroid s bug fixes to demonstrate the prevalence and complexity of nondeterminism in this tool.
this work makes the following contributions the first systematic empirical study of the nondeterministic behavior in static analysis tools revealing widespread previously unknown nondeterministic issues in these tools.
a qualitative analysis of the tool repositories that shows common patterns of fixes for nondeterministic issues and categorizes their root causes.
a quantitative analysis identifying extant nondeterminism in out of studied static analysis tools.
an in depth analysis of the detected nondeterministic behavior useful for future development and research of static analysis tools to increase their reliability.
ii.
s tudy goal and scope to demonstrate the importance and the complex nature of studying nondeterminism in static analysis tools we use a flowdroid bug detected by our study and reported fixed described in section iv d as a motivating example.
flowdroid performs taint analysis on android applications to detect security leaks.
it produces a set of flows each made up of a source method that produces sensitive data and a sink that writes sends data outside of the application .
it is expected that when flowdroid successfully terminates and does not timeout the set of flows it produces for a given configuration and input program will always be the same.
figure shows part of a program on which flowdroid exhibits nondeterministic behavior.
this program anonymousclass1 is from droidbench a popular microbenchmark used to evaluate android taint analysis tools.
in this program the locationlistener line 1public class annonymousclass1 extends activity ... private static double latitude private static double longitude private locationmanager locationmanager locationlistener locationlistener new locationlistener ... override public void onlocationchanged location location longitude location.getlongitude latitude location.getlatitude ... override protected void onresume ... log.i log latitude latitude longitude longitude fig.
anonymousclass1 from droidbench.
listens for location updates.
when the location changes the method onlocationchanged is called and the variables longitude andlatitude are updated on lines and .
these lines contain tainted data as they are initialized bygetlongitude andgetlatitude which are sources defined in flowdroid.
finally the method onresume is called and sends the sensitive location data to a log line which is a sink.
this program contains two leaks i.e.
both sources on lines and to the sink on line .
when we ran flowdroid on this program times using the same configuration that runs a flow insensitive analysis it produced three different results sometimes reporting either leak and sometimes reporting both.
such nondeterministic behavior can lead to users missing real leaks in their applications.
nondeterministic issues are often complex to detect and to debug one reason is because of the probabilistic nature of nondeterminism.
this is further exacerbated by the complexity of static analysis tools.
flowdroid has configuration options that can each individually affect the expected result of the analysis.
in addition this particular bug was only observed running anonymousclass1 and not any of the other droidbench programs.
furthermore debugging nondeterminism in static analysis can be a daunting task.
we reported this detected nondeterminism bug to the developers of flowdroid .
ultimately this bug was fixed in a commit by changing hundreds of lines of code detailed in section iv d .
a. research questions the goal of this study is to fill the knowledge gap that exists in understanding the existence and significance of nondeterministic behavior in static analysis tools which is critical for tool development and maintenance.
we answer two important research questions in pursuit of this goal rq1 are there existing nondeterminism issues in static analysis repositories and how are they usually addressed?
rq2 are there unknown nondeterministic behaviors in static analysis tools what are the characteristics and how do tool developers respond to the nondeterminism?
rq1 aims to understand how nondeterminism plays into the development history of static analysis tools.
it is answered through a qualitative study that analyzes tool repositoriestable i information of subject tools.
of analysis tool options loc target result soot java call graph wala java java call graph doop java call graph opal java call graph flowdroid android alarm amandroid android alarm droidsafe android alarm tajs javascript call graph wala js javascript call graph pycg python call graph code2flow python call graph infer c alarm looking for issues and commits that address nondeterministic behavior.
we extract such commits and issues and categorize them to understand how tool developers and users find and fix nondeterminism.
rq2 looks for yet undiscovered nondeterminism in the current versions of popular static analysis tools.
we answer it through a quantitative empirical evaluation which runs tools multiple times across various input programs and configurations to detect nondeterminism.
b. subject tools we aim to study a wide variety of static analysis tools covering multiple target languages and analysis types.
this helps lend generality to our results.
our methodology is to search for tools that are popular frequently used in existing evaluations and open source so that we could investigate the code of each tool as well as inspect its issues and commit history.
we ultimately select frameworks that perform call graph construction for java javascript and python because these analyses provide fundamental information for developing many inter procedural dataflow analyses.
we target taint analysis tools for android because most android analysis research has focused on the security issues in android apps and the most popular analyses are those that perform taint analysis to find software flaws.
for c we use one of the most widely adopted bug detection tools.
in the end we target analysis tools.
table i shows the details of the selected tools.
column shows the number of configuration options in each tool tool options usually allow the user to tune the analysis algorithms e.g.
context sensitivity and reflection handling .
these configurations present tradeoffs between performance soundness and precision.
the large numbers of options existing in most tools demonstrate the complexity of the selected tools.
note that in table i we list wala java and wala js as two tools while they share the same repository thus the same count of lines of code in column .
this is because there exists different analysis logic and options in wala s codebase for analyzing java and javascript programs we consider the difference large enough to call them separate tools.
among these tools infer is implemented in ocaml opal and amandroid are implemented in scala while the rest are implemented in java.iii.
rq1 e xisting reports and fixes of nondeterministic behavior the goal of our qualitative study is to understand the extent to which tool users and developers are aware of nondeterminism in static analysis tools.
furthermore we aim to learn how tool developers address nondeterminism when it arises.
towards these goals we performed a manual study of the tool repositories we selected.
all the repositories were hosted on github except for doop which was on bitbucket .
we first extracted all the issues and commits from each repository resulting in issues and commits in total.
repositories had between tajs and opal commits and between droidsafe and soot issues.
next we aimed to find those commits and issues that affect nondeterministic behavior.
we performed a keyword search through the commit messages and the issue texts using six keywords deterministic determinism flaky flakiness concurrent and concurrency .
we originally considered the following additional keywords but removed them because they resulted in a large number of false positives consistent different parallel and thread .
this keyword search returned issues and commits.
the number of results containing concurrent orconcurrency was significantly higher than others.
after a manual investigation we noticed that many of these issues and commits only contain these keywords as part of a code package name e.g.
java.util.concurrent .
we automatically excluded any issue or commit that included concurrency orconcurrent only within a code snippet this allowed us to remove issues and commits.
this methodology resulted in issues and commits representing and .
of all the retrieved issues and commits respectively.
for each result one author inspected all of its text commit messages and or issue comments including the code diff for commits.
in this process the author also deduplicated issues and commits that discuss the same problem.
if an issue commit explicitly