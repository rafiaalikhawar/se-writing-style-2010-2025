repairing order dependent flaky tests via test generation chengpeng li the university of texas at austin austin tx usa chengpengli utexas.educhenguang zhu the university of texas at austin austin tx usa cgzhu utexas.edu wenxi wang the university of texas at austin austin tx usa wenxiw utexas.eduaugust shi the university of texas at austin austin tx usa august utexas.edu abstract flaky tests are tests that pass or fail nondeterministically on the same version of code.
these tests can mislead developers concerningthequalityoftheircodechangesduringregressiontesting.a common kind of flaky tests are order dependent tests whose pass fail outcomes depend on the test order in which they are run.
such testshavedifferentoutcomesbecauseothertestsrunningbefore thempollutesharedstate.priorworkhasproposedrepairingorderdependenttestsbysearchingforexistingtests knownas cleaners thatresetthesharedstate allowingtheorder dependenttesttopass whenrunafterapollutedsharedstate.thecodewithinacleaner representsapatchtorepairtheorder dependenttest.however this technique requires cleaners to already exist in the test suite.
we propose odrepair an automated technique to repair orderdependent tests even without existing cleaners.
the idea is to first determine the exact polluted shared state that results in the orderdependenttest tofail andthen generatecodethat canmodify and resetthesharedstatesothattheorder dependenttestcanpass.we focus on shared state through internal heap memory in particular sharedstatereachablefromstaticfields.onceweknowwhichstaticfieldleadstothepollution wesearchforreset methodsinthecodebase that can potentially access and modify state reachable from thatstaticfield.wethenapplyanautomatictest generationtooltogeneratemethod callsequences targetingthesereset methods.our evaluationon327order dependenttestsfromapubliclyavailable dataset shows that odrepair automatically identifies the polluted staticfieldfor181tests anditcangeneratepatchesfor141ofthese tests.
compared against state of the art ifixflakies odrepair can generate patches for tests that ifixflakies cannot.
ccs concepts softwareanditsengineering softwaretestinganddebugging.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
flaky test order dependent test test generation automated repair acm reference format chengpeng li chenguang zhu wenxi wang and august shi.
.
repairing order dependent flaky tests via test generation.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa 12pages.
.
introduction regression testing is an important part of the software development process but it suffers from the presence of flaky tests.
flaky tests are tests that nondeterministically pass or fail when run on the same version of code .
a flaky test failure can mislead a developer about their recent code changes leading them to debug theirchangeswhentheproblemsareelsewhere.previousstudies have identified a number of root causes for flakiness with test order dependence as a common cause.
test order dependence results in order dependent tests whose pass fail outcomes depend on the test order in which they are run.
anorder dependenttestalwayspassesinonetestorder its passing test order but fails when run in another order its failing test order.
unfortunately the testorderisnot guaranteed.forexample java developersusingjunitforunittestingfoundtheirtestsfailingafter a change from java to java .
after the java upgrade junitstartedrunningtestsindifferenttestorders exposingexisting test order dependence in the test suite that only now manifests after the java version change and not due to code changes .
there hasalsobeenmuchpriorresearchondevelopingtechniquesthat can automatically detect order dependent tests .
shietal.previouslyproposedifixflakies toautomatically repairorder dependenttests.theycategorizeorder dependenttests into two types a brittleis a test that fails when run on its own butpasseswhensomeothertestsrunbefore theseteststhatrun beforesetupthestateforthebrittletopass.
a victimisatest that passes when run on its own but fails when some other tests runbefore theseteststhatrunbeforeare polluting thestatethey share with the victim leading to the victim s failure.
ifixflakies insight is that these tests that set the state when run before thebrittle contain code that can be made into a patch to repair thebrittle.
for victims ifixflakies can look for cleaners which are teststhat whenrunbetweenapollutingtestandthevictim canreset the shared state to allow the victim to pass.
ifixflakies can createapatchoutofthesecleanersastorepairthevictim.however ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa chengpeng li chenguang zhu wenxi wang and august shi ifixflakies relies on developers having already written cleaners if they do not exist ifixflakies cannot generate patches.
we propose odrepair a technique to repair order dependent tests without requiring the existing test suite to contain cleaners.
odrepair first identifies the polluted state in between tests.
odrepairthengeneratesmethod callsequencesthatmodifythe polluted state resetting it for the order dependent test.
in other words odrepair aims to automatically generate the cleaners that ifixflakiesneedstogeneratepatchesfortheorder dependenttests.
odrepairfindsthepollutedstatebetweentestsbycapturingthe state between the polluter and the victim order dependent test we only focus on victims because brittles are guaranteed to have tests thatsetthestatebefore .wefocusonin memoryheap stateshared between tests as prior work found test order dependence to come from shared heap state specifically reachable from static fields .
the goal is to determine which static field is polluted i.e.
the heap state reachable from that field right before the orderdependent test runs differs between the passing and failing test orders andthe differenceresults ina failing order dependenttest.
giventhepollutedstaticfield odrepairgeneratesamethod call sequence that can modify the heap state reachable from that static field to reset the shared state.
odrepair first searches through the codebaseforreset methodsthatcanaccessthepollutedstaticfieldandeitherchangethestaticfieldvaluedirectlyormodifystatethatthestaticfieldreaches.foreachreset method odrepairconfiguresrandoop an automatic test generation tool to test the resetmethod by generating method call sequences that utilize the resetmethod in various ways.
our goal of using the test generationtool is not the standard goal of covering code and finding bugs butrathertohaveitgenerateteststhatarecleanersfortheorderdependenttest.odrepairsendsthesegeneratedteststoifixflakiestocheckifanyofthemareactuallycleaners whichifixflakiesthen uses to generate patches for order dependent tests.
weevaluateodrepairon327order dependenttestsobtained from idoft a public dataset of flaky tests.
odrepair automatically identifies the polluted static field for of these tests.furthermore odrepair automatically generates a patch for 141order dependent tests.
compared against ifixflakies ifixflakiescan generate a patch for of those order dependent tests.
we find tests .
where odrepair generates a patch but ifixflakiescannot.ontheotherhand ifixflakiesgeneratesapatch for tests that odrepair cannot .
.
based on our findings we recommend that odrepair and ifixflakies be used together in a complementary way.
a developer can first apply ifixflakiesto check whether the existing tests already contain cleaners.
if ifixflakies is unsuccessful the developer can then apply odrepair to generate a cleaner for repairing the order dependent test.
this paper makes the following contributions automated pollution detection.
odrepair automatically identifies the polluted state by comparing heap state between different test orders and loading state captured from the passing test order as to isolate the actual polluted state.
generatingpatchesviatestgeneration.
odrepairguides the use of a test generation tool to create method call se quences that invoke reset methods for the polluted state creatingteststhatcontainpatchesfororder dependenttests.
evaluation.
weevaluateodrepairon327order dependent tests wherewesuccessfullyidentifythepollutedstatefor and could generate a patch for of those tests.
background and example anorder dependent test is a flaky test whose pass fail outcome depends on the test order in which it runs.
in other words there exists a test order where the order dependent test passes we refer toitasapassingtestorder andanotherdifferenttestorder where the order dependent test fails we refer to it as a failing test order .
furthermore to be qualified as an order dependent test the testorder is the only determining factor for whether the test passesor fails when run on the same code i.e.
running the same test ordermultipletimes alwaysresultsinthe samepass failoutcome otherwise whilethetestisstillflaky itwouldbeanon order dependent test .
shi et al.
previously categorized order dependent tests into two types brittles and victims.
a brittlehas a failing test order where the test runs by itself and it hasa passing test order where someothertestsrunbeforeit.conceptually theseothertestswhen run before are setting up the correct initial state for the brittle test shi et al.
referred to such tests as state setters .
on the other hand avictimhas a passing test order where the test runs by itself and it has a failing test order where some other tests run before it.
conceptually these othertests when run before are polluting some shared state between the tests leading the victim test to run in a polluted state that results in a test failure shi et al.
referred to such tests as polluters .
shi et al.
further developed a technique ifixflakies that automatically repairs order dependent tests.
first ifixflakies mini mizer component finds the state setters and polluters per brittle andvictim respectively byusingdelta debugging onthegiven passing test order or failing test order for the order dependent test.
next for brittles the insight is that state setters must exist by definition and these tests contain code that would set up the statefor the brittle to pass.
for victims the insight is that there existother tests which shi et al.
termed cleaners that when run in between a polluter and its corresponding victim would result in the victim passing.
unfortunately unlike brittles such cleaners are notguaranteedtoexist.essentially ifixflakiesreliesondevelopers to have already written such tests that contain the needed logicfor cleaning the polluted state.
once the state setter cleaner has been identified ifixflakies patcher componentgenerates a patch per order dependent test by minimizing the statements within the identified state setter cleaner also through delta debugging re sulting in the minimal set of statements that can be added to the order dependent test so it passes even in the failing test order.
giventhatbrittlesareguaranteedtohavestate setters wefocus solely on generating patches for victims.
moreover shi et al.
found that victims constitute a much larger proportion of order dependenttestscomparedagainstbrittles soitismorereasonable to focus on repairing these types of order dependent tests.
for the restofthispaper theorder dependenttestswerefertoaremore precisely victims unless otherwise noted.
example.considertheexamplecodeandtestsillustratedinfigure1 taken from open source project elasticjob elastic job lite authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
repairing order dependent flaky tests via test generation icse may pittsburgh pa usa polluter vic tim test class 2public final class shutdownlistenermanagertest mock private schedulerfacade sf 4private shutdownlistenermanager slm before 7public void setup 8jobregistry.getinstance .addjobinstance test job ... 10slm newshutdownlistenermanager ... test job 12reflectionutils .setfieldvalue slm schedulerfacade s f polluter test public void assertremovelocalinstancepath 18jobregistry.getinstance .registerjob test job ... 20slm.newlistener .datachanged ... 21verify sf .shutdowninstance victim test public void assertisshutdownalready 26slm.newlistener .datachanged ... 27verify sf times .shutdowninstance public final class shutdownlistenermanager 32private final string jobname 33private final schedulerfacade schedulerfacade classlistener 36protected voiddatachanged ... if !jobregistry.getinstance .isshutdown jobname schedulerfacade.shutdowninstance class with polluted state 46public final class jobregistry 47private static volatile jobregistry instance 48private final map ... schedulermap public static jobregistry getinstance 51return instance 53public void registerjob finalstring jobname ... 54schedulermap.put jobname ... 56public void shutdown finalstring jobname ... schedulermap.remove jobname 59public boolean isshutdown finalstring jobname 60return !schedulermap.containskey jobname figure example order dependent test from elasticjob elastic job lite.whichweuseinourevaluation.theorder dependenttestinthis example is shutdownlistenermanagertest.assertisshutdownalready.
this test is a victim that passes when run on its own butfailswhenrunafterthepolluter shutdownlistenermanagertest.assertremovelocalinstancepath.
thepolluterinvokesthe registerjob method line which adds a new entry to the schedulermap line54 contained within theshared jobregistry.instance staticfield obtainedusing jobregistry.getinstance .thisnewentryismappedtothestring key test job usedasinputto registerjob bythepolluter.
thepolluterinvokes datachanged line20 whichinturnchecks whetherthejobname setto test job inthesetup method thatrunsbefore line isshutdownalready.thejobnameisconsideredshutdownifthe schedulermap doesnotcontainanentry for the job name line .
since the schedulermap indeed containsanentryfor test job themethod shutdowninstance is invoked on the schedulerfacade field line .
whenthevictimrunsafterwards italsoinvokes datachanged line26 .
however the victim expects that the method shutdowninstance is not invoked on the mock object schedulerfacade line27 .
since the victim did not register any job for test job the execution shouldnot result in shutdowninstance being invoked.
however because the polluter ran beforehand and registered test job without removing it from the schedulermap in the shared jobregistry.instance the check for the presence of test job in the map returns true and shutdowninstance is still invoked once resulting in the victim failing.
torepairthevictiminthisexample wewouldneedtoremove the test job entry from the shared schedulermap after the polluter finishes and before the victim starts.
fortunately there is a method shutdown that can be invoked to remove the entry line57 .
in fact just adding the statement jobregistry.getinstance .shutdown test job to run after the polluter can ensure the victim passes regardless of its order relative to the polluter.
it is interesting to note that schedulerfacade.shutdowninstance normally does remove the entry from the shared map but because schedulerfacade is a mock object it actually does not do that.
odrepair we propose odrepair to automatically repair order dependent tests.odrepairhastwomaincomponents.thefirstcomponent debugger takesanidentifiedorder dependenttestanditsidentified polluter and it automatically detects the polluted state that causes theorder dependenttesttofail.thesecondcomponent generator uses the polluted state identified by the debugger to generate a patchthatwillresetthatpollutedstate.thegoalisthatapplying thepatchwillmaketheorder dependenttestalsopasswhenrun in its original failing test order.
.
debugger thedebuggertakesasinputaknownorder dependenttest tand its corresponding polluter p. figure 2shows the overallalgorithm for debugger.
the polluter pcan be obtained using the minimizer component of ifixflakies section .
note that odrepair is meant toonlyhandlevictimorder dependenttests sotheremustexista authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa chengpeng li chenguang zhu wenxi wang and august shi input order dependent test t polluter p output polluted field 4defifixplus t p capture state of t in failing test order using p 6xmls f state capture capture state of t in passing test order 9test result run tests 10iftest result pass xmls p state capture 12else xmls state capture xmls p state capture eager xmls.keys find fields where xmls differ 17diff fields diffing xmls f xmls p try to set each diff field in the failing order 20forfieldindiff fields test result run and set field field xmls p iftest result pass return field return notfound figure algorithm for the debugger.
i fodvvordghu i i i i 2em 2em 2em 2em 2em figure object graph rooted at static field c0.f.
polluter.
the goal of the debugger is then to identify the shared state that the polluter modifies in such a way that the order dependent test fails in the failing test order.
while there can be many types of shared state such as heap state file system databases etc.
heap state was found to be one of the most common shared statethatleadstotest orderdependencies .furthermore much priorworkhasfocusedonorder dependenttestsduetopolluted heap state .assuch wefocusonpollutedheap state particularly pollution reachable from static fields in java whichprior work found to be the main means for junit tests to share heap state with each other .first we capture the heap state right before the order dependent test tin a failing test order line .
we use the minimal failing test order that consists of just the polluter prunning before t i.e.
.
to capture the heap state we use the same logic from poldet .
poldet is a technique that captures and saves heap stateatpointsduringtestexecutiontolatercomparewhether the execution modified the heap state.
poldet captures heap state in java by first finding all the classes loaded at the capture point.
poldetthenfindsallthestaticfieldscontainedwithintheseclasses.
thesestaticfieldsformtherootsofanobjectgraphrepresenting thecurrentheap state.figure 3illustratesanobjectgraphrootedat staticfield c0.f where nodesareobjectsand theedgesrepresent instance fields that point to other objects the edges are labeled bytheirfieldname includingtheclassname .forexample ifwe follow fields c0.f c1.f3 we would reach the object obj4.
poldetefficientlycreatesarepresentationofthisobjectgraph by serializing the objects the static fields reference into an xml format.
we use the same approach for our state capture function where we put the capture point right before the running of the last test in the test order namely the order dependent test.
we store the serialized forms of the object states in the failing test order into xmls f which is a map from the static field name to its corresponding object s xml representation.
we also capture the heap state right before the order dependent test in a passing test order.
while there can be many possible passingtestorders wewanttoavoidrunningtoomanyothertests before the order dependent test because these other tests may not be using anyclasses or static fieldsthat are shared withthe orderdependenttest.assuch thereisnopointincapturingheap state rooted from these static fields because they should not have an effectontheorder dependenttestoutcome.anotheroptionisto use the minimal passing test order i.e.
running just the order dependent test by itself.
however we cannot use this test ordereither due to java s lazy classloading .
in lazy classloading classesarenotloadeduntiltheyareusedforthefirsttime.assuch whentrunswithoutanytestsbeforeit noclasseswouldbeloaded right before it runs meaning there would also be no static fields from which to capture heap state.
to overcome this challenge we instead use a different passing test order consisting of running the order dependenttesttwiceinarow i.e.
.afterrunning t thefirsttime alltheclassesituseswouldbeloaded.wecanthen capturethestateafterthefirst trunsbutbeforethesecond tstarts.
however we needto check whetherthe order dependenttest still passes after running it twice line .
there is the risk that the order dependent test tis also a polluter for itself meaning the order dependent test fails when run the second time wei et al.
termed these tests as non idempotent outcome tests .
the state after a non idempotent outcome test run would not be the correct state forithas polluted itself.forthesenon idempotent outcometests westillcapturethestateatthesamepoint butweonlyrecord the static fields available at that capture point the keys in the returned map from field to xml representation line .
we then use those fields as reference and do a form of eager classloading similar to as proposed in poldet to overcome challenges from lazy classloading .
namely werecord the classes that areused and forcefullyloadthematthecapturepointduringtheminimalpassingtestorder line14 .eagerclassloadingdoesnotadheretohow authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
repairing order dependent flaky tests via test generation icse may pittsburgh pa usa javabydefaultloadsclasses whichcancauseunexpectedbehavior e.g.
aclassmayhavestaticstatewhoseinitializationdependson the order in which the classes are loaded.
as such we only rely on thisapproachwhenwecannotsimplyrunthetesttwicewithout it polluting itself.
fortunately we did not encounter many nonidempotent outcome tests in our evaluation with only out of order dependent tests being non idempotent outcome tests.
with both the static fields and serialized heap state from the failing test order and passing test order we proceed to diff the xml serialized form of the objects rooted at each field shared in commonbetweenthethetwotestorders line .however not allstaticfieldswithdifferentobjectstatesnecessarilyleadtothefailing order dependent test.
to isolate the true static field thatreferencesthe polluted heap state weiterateover eachdiffering field and deserialize the xml representation corresponding to that static field from the passing test order back into an object.
we thenloadthisdeserializedobjectintoitscorrespondingstaticfieldwhen runninginthefailingtestorder loadingitinrightbefore the order dependent test runs line .
if the test passes now in thefailingtestorderaftersettingthestaticfieldstatetoitsoriginal value from the passing test order we identify that field to be the rootofthepollution whichwerefertoasthe pollutedstaticfield.if we cannot use any of the static fields to make the order dependent testpass wesimplyreturn notfound line26 andcannotproceed further with repairing this order dependent test.
.
.
reusing state for deserialization.
deserializing xml back intoobjectspresentsadditionalchallenges.theobjectgraphrooted at a static field can eventually reach objects unique to the run ning jvm at the capture point e.g.
reaching the classloader or dynamically generated proxy objects.
while the entire state can be serialized into an xml format that same xml cannot be deserializedbackintoaviableobjectinadifferentrunningjvm.aslong asanypartofthexmlrepresentingheap staterootedatastatic field cannot be deserialized we fail to deserialize that entire object graph for the static field.
toovercomethischallenge weintroduceameanstoreuseheapstate from the currently running jvm.
the insight is that we aretrying to deserialize xml representing an object graph that isthe same structure as the object graph currently loaded in mem ory.
for example in figure the object referenced by following fields c0.f c1.f3 c2.classloader is actually an instance of aclassloader .
while this object can be serialized into xml that same xml representation cannot be safely deserialized into anotherrunningjvm.whenweencountersuchanobjectduring deserialization weinsteadnavigatethroughtheobjectgraphinthecurrentlyrunningjvm duringthefailingtestorder andfollowthesamefieldstructure i.e.
byfollowingthehighlightedredarrowsin figure3.weeventuallyreachwhatobjectiscurrentlyreferenced bythatchainoffields i.e.
obj5.wethenusethatcurrentobjectin place of what objectthe deserialization process was planning on creating essentially allowing that object to be loaded back in place.
note that while we can use this process to avoid issues where wecannotsafelydeserializepartsofthecapturedheap statefrom a previous jvm run there is the risk that the actual pollution in theheap stateisexactlyinthepartwearereusing.however given the typical types of objects we cannot deserialize namely internaljava classes it is unlikely that changes to these objects result in pollutionthatmakesanorder dependenttesttofail.furthermore we wouldnot have beenable todeserialize them anywaywithout this additional recovery attempt.
.
generator the generator takes as input the order dependent test and its pollutedstaticfieldasidentifiedbythepreviousdebugger.thegoalofthegeneratoristogenerateapatchthat whenappliedrightbefore the order dependent test can make the order dependent testpass when run after the polluter in the failing test order.
the generator itself consists of three sub components resetmethod finder test generator and patch generator.
.
.
reset method finder.
giventhethepollutedstaticfield resetmethod finder scans the bytecode of the code under test plus any additional third party libraries to find potential methods that can reset the state forthat polluted static field.
we refer tosuch methods asreset methods.
reset method finder determines potential reset methods based on the following heuristics.
first ifamethodusesthe putstatic bytecodeinstructionwhere theoperandisthepollutedstaticfield thenreset methodfinder considersthe methodas apotential reset method.the reasoningis thatthemethodisdirectlysettingthevalueofthepollutedstatic field.assuch themethodmayeitherdirectlyresetthefieldbackto a default state or sets that state based on some input arguments.
second fromourinitialinspectionoforder dependenttestsin our dataset we found a substantial ratio of them out of tests from projects involve pollution of fields of a java collection data structure type e.g.
type map.
for example the polluter would add entries to a shared mapwhile the order dependent test expects that map to be empty when it starts to run similar to the example illustrated in figure .
the way to reset these data structures is to use its api methods that modify the data structure state e.g.
clear put putall putifabsent andremove for a map.wethereforelookformethodsthatinvokethesepredetermined data structure modifyingmethodswhileoperatingonfields which can now be instance fields defined within the type of the polluted static field.
the reasoning is that these methods can be invokedin ways such that they can eventually modify the polluted data structures back to the correct state.
.
.
test generator.
given the set of potential reset methods the test generator aims to generate tests that invoke the reset methods in ways that can potentially reset the state referenced bythepollutedstaticfieldwhenrunafterthepolluterandbefore the order dependent test.
for this task we leverage automatic testgenerationtools.anautomatictest generationtoolwouldgeneratemethod call sequences focused on a specific part of the code being tested with thegoaltocover thecodeunder testandfindbugs in thecode.forourimplementationoftestgenerator wespecifically use randoop a tool that generates unit tests effectively and efficiently by randomly constructing method call sequences.
randoop needs as input the method it should focus on testing.
we therefore pass each reset method found from the reset methodfinder as an input method to randoop.
randoop then generates authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa chengpeng li chenguang zhu wenxi wang and august shi a test class per each reset method where individual tests within invoke the reset method in various ways.
however weneedtoconfigurerandoopinadditionalwaysso it can effectively generate useful method call sequences.
mining literals from the code under test.
a reset method may needtobeinvokedwithinputarguments.randoophasadefault constants pool it uses to provide the input arguments but often thesedefaultsareinsufficientforthereset methodtoactuallyreset thepollutedstaticfield.tohelpprovidemoremeaningfulinputs test generator mines literals such as string constants from the bytecode of the code under test.
the insight is that these literals arelikelyalreadyusedbythepollutertomodifythesharedstate.
consider the example code in figure where the polluter calls registerjob with the literal string test job which is used as a key to a mapin the backend.
a reset method that we found shutdown takesastringinput whichinthiscasehastomatch withthesameliteralthepolluterusedtomodifythesharedstate re using that literal as a key for resetting the map.
we limit the scope of this literal mining to the code in the orderdependent test class and the class that contains the polluted static fieldastorestrictthesearchspaceofpossibleinputsrandoopwould use when creating method call sequences.
we pass these literals to theconstantspoolofrandoop whichareutilizedtogenerateinput values of method call sequences through its literals file .
additional helper methods.
besides reset methods needing specific literal inputs to reset the polluted static field they may also need more complex inputs.
forexample if the reset method is an instancemethod thereset methodwouldneedacalleeinstanceon whichitcanbeinvoked.assuch randoopneedstoinvokeother methods that return the callee instances on which to invoke the reset method.however lettingrandooptryallpossiblemethodsin the project isnot a good idea as itbecomesless likely for randoop to generate the right method call sequence to reset the state.
foreachreset methodprovidedbythereset methodfinder test generatorconfiguresrandooptouseonlythatreset methodalong withotherhelpermethodsthatreturnrelevantvaluesthatrandoop should use along with the reset method.
these helper methods includethosethatreturnthecalleetypeofthereset methodandanymethodsthatuse getstatic ofthepollutedstaticfield.theselatter methods are potentially getter methods that return the polluted static field which the reset method may need access to as to reset statereachablefromthatsamepollutedstaticfield.theoutputis a test class for each reset method containing test methods that invoke the reset method along with the helper methods.
coarse grained test generation.
randoop can also receive as input entire classes for testing where it would then generate tests thatinvokecombinationsofmethodsfromtheprovidedclasses.we thereforealsotryusingrandooptogeneratetestsbasedonlikely relevantclasses.theintuitionisthatwemaystillmissimportant methods through the more fine grained search on reset methodand helper methods so letting randoop use all methods in relevantclassesmaybeenoughtocoverallimportantmethods.this alternateapproachprovidestorandoopalltheclassesreferenced within the class that contains the polluted static field and all the classes that are transitively referenced by the class type of the pollutedstaticfield.theapproachthenfocusesonthetop kclasses3whvwbmre 5dqgrrs l l odnlhvvkxwgrzq re5hjlvwu jhw qvwdqfh jhqhudwhg whvwkhoshu jhqhudwhg sdwfkhvolwhudov hq7hvw re5hjlvwu m re5hjlvwu jhw qvwdqfh m vkxwgrzq whvwbmre dvvhuw v6kxwgrzq ouhdg ylfwlp dvvhuw5hpryh rfdo qvwdqfh3dwk srooxwhuuhvhw phwkrg figure overview of generator.
among this set of classes where the classes are ranked by their distance from the polluted static field type i.e.
the classes directly referenced by the polluted static field type are ranked first and otherclassesthattheseclassesinturnreferencearerankedsecond and so on.
heuristically we choose as the value of k restricting the search space as to avoid generating tests that use too manydifferent methods especially as the ones further away are less likely to have an effect on the pollution.
randoop takes as input all these classes for which to generate tests.
ultimately test generator outputs a separate test class for each reset method along with an additional test class generated by randoop using the classes relevant to the polluted static field.
.
.
patch generator.
finally patch generator aims to check whether any of the generated tests from test generator contain codethat actuallyresets theshared state essentially consistingof a patch for the order dependent test.
patch generator leverages ifixflakies to do the check and generate the patch.
patch generatorsetsupifixflakiestorunjusttheorder dependenttest its polluter and the set of generated tests to determine if any of those generatedtestsareactuallycleanersfortheorder dependenttest and polluter pair.
for each generated test class we run ifixflakies withthetestmethodswithinthatgeneratedtestclassalongwith the polluter and order dependent test to see whether any of those generated test methods can reset the shared state and make theorder dependent test pass when run after the polluter.
if one of them does turn out to reset the shared state then ifixflakies minimizes the statements within the test producing a patch that when appliedatthebeginningoftheorder dependenttest allowsitto pass even when run after the polluter.
figure4illustratestheoverallgeneratorprocess usingprovided reset methods onceagainfollowingtheexamplefromsection figure1.theinputsarethereset method inthiscase shutdown literals mined from the code including string test job and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
repairing order dependent flaky tests via test generation icse may pittsburgh pa usa alistofhelpermethods including jobregistry.getinstance that returns the relevant polluted static field .
these inputs are passed to randoop which in turn generates a test class gentest .
this test class is passed as input to ifixflakies to try and generate a patch out of the test methods from that test class finally producing a patch that repairs the order dependent test using both jobregistry.getinstance andshutdown .
evaluation setup we evaluate odrepair on a large set of order dependent tests.
we start with the flaky tests contained within idoft a publicly availabledatasetofflakytestsfoundinopen sourcegithubjava projects detectedusingautomatedflaky testdetectiontoolssuch asidflakies ornondex .weareonlyinterestedinthe598 flaky tests marked as order dependent tests in this dataset.
we ran idflakies atooltodetectorder dependenttestsbyrerunning testsindifferenttestorders toobtainthepassingandfailingtest orders per order dependent test we configured idflakies to run random test orders as lam et al.
did in prior work .
we found one test s project to no longer exist and we found tests to be non order dependent i.e.
their flaky pass fail outcome is not completelyduetotestorder orwecouldnotobtainbothpassing and failing test orders we exclude these tests from our evaluation.
we ran each order dependent test in isolation to determine brittles and victims section .
we found that of these tests are brittlesand327arevictims inlinewithshietal.
spriorfindings thatthemajorityoforder dependenttestsarevictims .given thatifixflakiescanrepairbrittlesbutnotalwaysvictims weuse for our evaluation only the victims spread across projects.
forthedebuggercomponentofodrepair weusexstream toserializeobjectsintoxmlformanddeserializethembackinto objects.wefurthermodifyxstreamtoimplementourtechnique of reusing existing state when we are unable to deserialize objects from a previous jvm run section .
.
.
to compare the xml representationsofobjects weusexmlunit .weincorporate thestatecapturelogicintoidflakiesastoensurewecancontrol thetestorderandtocapturestateattherightpoint rightbeforethe order dependent test.
we also set a timeout of hours per order dependent test for identifying the polluted static field.
for the generator component of odrepair we use apache bcel to analyze the java bytecode both for finding resetmethods and to mine the literals from the project code.
when configuringtheautomatictest generationtoolrandoop welimit the maximum number of test methods per test class to and we limitthemaximumlinesofcodepertestmethodtobe100.wealso allocate at most seconds for randoop to generate tests.
we use amuchsmallertimeoutforrandoop becausewefoundrandoop would actually terminate much earlier on average seconds per use meaning seconds is typically more than enough.
evaluation toevaluateodrepair weaddressthefollowingresearchquestions rq1 howeffectiveisodrepairatautomaticallyidentifying the polluted static field for order dependent tests?
rq2 howeffectiveisodrepairatgeneratingpatchesfor repairing order dependent tests?
.
identifying polluted static fields table1shows the results of running the debugger component on the327order dependenttestsfromourdataset.thetableshowsper project the number of order dependent tests average number of staticfieldsatthecapturepoint theaveragenumberofstaticfields referencing state that differed between the passing and failing test ordersatthecapturepoint andthenumberoforder dependenttests for which we could successfully identify the polluted static field.
the table also shows the average time for the debugger per orderdependent test successful or not .
while order dependent tests access a large number of static fields average .
not many of them reference differing state between the passing and failing test orders average30.
.overall odrepaircanautomaticallyidentify the polluted static field for order dependent tests.
the overall average timeto runis .9seconds median33.
seconds .this large time is mostly from projects with a large number of static fields per order dependent test e.g.
spring projects spring boot or vmware admiral.furthermore thereareseveraloutliertestswhose overalltimeismuchhigherthantheothers morethan1.5timesthe interquartilerangehigherthanthethirdquartile .
ifweexclude these outlier tests the average time drops down to .
seconds.
thereare146order dependenttestswhereodrepairdoesnot identifythepollutedstaticfield.fromourinspection thereasons thatodrepairdoesnotidentifythepollutedstaticfieldforthese tests can be broken down into three main categories.
out of resources.
odrepairhadout of memoryerrorsfor46 tests and timed out for tests.
we note that all these tests are from thesameproject apache hadoop oneofthelargestprojectsfrom our dataset.
while apache hadoop does not have the most number ofstaticfieldsperorder dependenttest thereachablestatefrom each of the static fields is very large and our approach to serialize all that state in xml form results in the numerous out of memory errors.
the timeouts also occur due to having to process this large state notethatodrepairdoesnottimeoutforanyotherproject suggesting our preset timeout value is reasonable .
serialization deserialzationerrors.for46tests odrepairdoes not identify the polluted static field but also encounters errorsfrom using xstream and cannot proceed with serializing deseri alizing the state.
the polluted static field could be among these fields where xstream cannot serialize deserialize properly but we cannot identify it automatically due to those errors.
we encounter serialization errors for tests and deserialization errors for 33tests.
in the case of serialization errors we find the serialization would interact poorly with the underlying test running process preventing the process to exit properly.
note that a serializationerrorwouldactuallypreventodrepairfromproceedingtodese rialization there is no captured state to deserialize .
concerning deserialization errors some examples include trying to deserialize instances of anonymous lambda classes or proxy classes where these types are dynamically generated during the execution of the passingtestorder.assuch wecannotdeserializeinstancesofthese classes in a new jvm execution and we also cannot re use anyobject state from the current running jvm for these parts of the heap state section .
.
.
miscellaneous.
the remaining tests are such that there are no errors from serializing deserializing but still odrepair cannot authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa chengpeng li chenguang zhu wenxi wang and august shi table breakdown of debugging polluted state on order dependent tests.
project od tests avg avg avg successfully static fields static fields w diff time s debugged tests activiti activiti .
.
.
alibaba fastjson .
.
.
alibaba sentinel .
.
.
apache cayenne .
.
.
apache geronimo batchee .
.
.
apache hadoop .
.
.
apache hbase .
.
.
apache incubator dubbo .
.
.
apache incubator ratis .
.
.
apache jackrabbit oak .
.
.
apache karaf .
.
.
apache shardingsphere elasticjob .
.
.
apache skywalking .
.
.
c2mon c2mon .
.
.
cloudslang cloud slang .
.
.
consensys tessera .
.
.
ctco cukes .
.
.
danfickle openhtmltopdf .
.
.
dropwizard dropwizard .
.
.
elasticjob elastic job lite .
.
.
google java monitoring client library .
.
.
jenkinsci remoting .
.
.
jitsi jicofo .
.
.
jnr jnr posix .
.
.
kevinsawicki http request .
.
.
ktuukkan marine api .
.
.
networknt light 4j .
.
.
openpojo openpojo .
.
.
rest assured rest assured .
.
.
spring projects spring boot .
.
.
spring projects spring data envers .
.
.
spring projects spring ws .
.
.
tbsalling aismessages .
.
.
thomas s b visualee .
.
.
tools4j unix4j .
.
.
undertow io undertow .
.
.
vaadin flow .
.
.
vmware admiral .
.
.
wikidata wikidata toolkit .
.
.
wildfly wildfly .
.
.
winder universal g code sender .
.
.
yangfuhai jboot .
.
.
sum mean x3 sum .
.
.
automatically identify the static field where using its value from thepassingtestordercanmaketheorder dependenttestpassinthe failing test order.
from our inspection first two tests access files outside the heap state and changes to these shared files result in failed order dependent tests.
we currently do not track state outside the heap.
second tests initialize variables that reference servicesthattheystartup.forexample order dependenttestsin projectwildfly wildflyallrelyontheunderlyingjndiservice .
tests interact with these services and their own shared state not throughstaticfieldsbutratherthroughspecificapicalls.currently weonlytrackchangestoheap stateaccessiblethroughstaticfields.
third one test from danfickle openhtmltopdf changes the warning level of global logging by modifying environment variables that wedonottrack.finally foronetestindropwizard dropwizard the polluter changes a static field to reference a new output stream instead of the default system.out .
the later order dependent test specifically checks if that static field