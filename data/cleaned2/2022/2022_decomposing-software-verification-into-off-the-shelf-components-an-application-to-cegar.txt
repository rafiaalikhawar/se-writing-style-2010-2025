decomposing software verification into off the shelf components an application to cegar dirk beyer dirk.beyer sosy lab.org lmu munich munich germanyjan haltermann jan.haltermann uol.de university of oldenburg oldenburg germany thomas lemberger thomas.lemberger sosy.ifi.lmu.de lmu munich munich germanyheike wehrheim heike.wehrheim uol.de university of oldenburg oldenburg germany abstract techniques for software verification are typically realized as cohesive units of software with tightly coupled components.
this makes it difficult to re use components and the potential for workload distribution is limited.
innovations in software verification might find their way into practice faster if provided in smaller more specialized components.
in this paper we propose to strictly decompose software verification the verification task is split into independent subtasks implemented by only loosely coupled components communicating via clearly defined interfaces.
we apply this decomposition concept to one of the most frequently employed techniques in software verification counterexample guided abstraction refinement cegar .
cegar is a technique to iteratively compute an abstract model of the system.
we develop a decomposition of cegar into independent components with clearly defined interfaces that are based on existing standardized exchange formats.
its realization component based cegar c cegar concerns the three core tasks of cegar abstract model exploration feasibility check and precision refinement.
we experimentally show that despite the necessity of exchanging complex data via interfaces the efficiency thereby only reduces by a small constant factor while the precision in solving verification tasks even increases.
we furthermore illustrate the advantages of c cegar by experimenting with different implementations of components thereby further increasing the overall effectiveness and testing that substitution of components works well.
ccs concepts software and its engineering formal software verification abstraction modeling and modularity theory of computation logic and verification.
both authors contributed equally to this research.
this work is licensed under a creative commons attribution international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
software engineering software verification abstraction refinement cegar decomposition cooperative verification acm reference format dirk beyer jan haltermann thomas lemberger and heike wehrheim.
.
decomposing software verification into off the shelf components an application to cegar.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa 13pages.
introduction potential counterexample infeasible counter exampleprecision incrementabstract model exploration feasibility checkprecision refinementp taskprogram correct program incorrect figure workflow of classic cegar over the past decades software verification has emerged as an area with continuous research innovations and also with increasing tool development.
competitions on software verification sv comp verifythis showcase and conserve the rapid process of tool building and application and have also observed an interest in standardization of verification artifacts e.g.
of verification witnesses .
the general task of automatic verification tools is to compute a proof or counterexample for specified requirements.
today the majority of existing verification tools whether configurable or not are strongly cohesive software units.
though software verification as a task clearly consists of individual subtasks verifiers are typically made up of tightly coupled stateful components ieee acm 44th international conference on software engineering icse icse may pittsburgh pa usa d. beyer j. haltermann t. lemberger and h. wehrheim violation witness path witnessinvariant witnessabstract model explorer feasibility checkerprecision refinerp taskprogram correct program incorrect figure workflow of component based cegar that operate on shared data structures.
this architecture complicates reuse of components impacts scalability e.g.
parallelization and hampers exchange and integration of new components.
in consequence it often requires major implementation effort to integrate innovations in verification technology into existing tools or is even prohibitive because the strong cohesion between existing components can not be broken easily.
to avoid this issue we propose to employ decomposition concepts in the construction of verifiers.
instead of having all components integrated into a single tool we opt for cooperative verification where independent executable units cooperate on a verification task.
every such unit is only responsible for one well defined subtask and the units communicate via clearly defined interfaces.
to investigate the feasibility of such ideas we have realized this strict decomposition into components for one of the most frequently employed techniques in software verification counterexampleguided abstraction refinement cegar .
cegar is a technique for automatically finding an abstract model of the software to be verified which is as abstract as possible but as precise as necessary to successfully construct a proof of correctness or a refutation.
many tools for software verification include this cegar principle e.g.
.
cegar is also successfully employed in other areas like probabilistic or timed automata model checking .
cegar readily lends itself to a decomposition which we realize here as componentbased cegar c cegar .
figure first of all illustrates the iterative procedure of classic cegar for a given level of abstraction the exploration of an abstract model of the software top either proves the program correct and terminates the procedure or finds a potential counterexample.
the feasibility check right analyzes the counterexample.
it either proves the counterexample feasible and terminates the procedure or passes an infeasible counterexample to the next phase.
the precision refinement left analyzes the infeasible counterexample and extracts from it a precision increment refining the abstract model which the abstract model exploration employs in the next iteration.
this cycle continues until either a correctness or a violation proof is found.
but while this general concept of cegar has overall proven successful witnessed by cegar based tools scoring high at sv comp research into specialized techniques for the three subtasks is stillongoing.
this can best be illustrated by proposals of and discussions on precision refiners .
precision refinement techniques rely on heuristics and hence their effectiveness can only be evaluated through experiments.
due to the tight coupling of components in verifiers new precision refiners can however neither be evaluated in isolation nor can they be integrated into existing tools without reimplementation.
the past has thus unfortunately already seen multiple reimplementations of precision refiners a vast amount of tools contain implementations of a refiner based on craig interpolation and at least three tools contain re implementations of so called newton refinement.
c cegar overcomes these disadvantages of classic cegar by a consequent decomposition implementing each of the three conceptual units as a stand alone component and defining clear cut interfaces between components.
figure illustrates the workflow ofc cegar .
for the interfaces we employ existing standards for verification artifacts namely violation path and invariant witnesses but also new formats.
witnesses are already produced by many verifiers which allows us to partially reuse tools.
we have implemented c cegar as a particular form of cooperative verification and implemented it using the framework coveriteam .
with this implementation at hand we have then investigated the effects of decomposition into components on the overall effectiveness and efficiency.
our experiments show that while efficiency is slightly impacted by the necessity of data exchange via external interfaces the overall effectiveness can even be increased.
we have moreover performed the now possible independent evaluation of precision refiners comparing craig and newton refinement.
novelty.
we provide the following contributions we develop the concept of c cegar as a composition of three independent software units with clearly defined interfaces based on verification witnesses and invariant maps.
we implement c cegar for c programs using the framework coveriteam .
we show the feasibility and effectiveness of c cegar through asound experimental evaluation on an extensive benchmark set with verification tasks written in c .
we use offthe shelf verification tools for the three base units.
we experimentally demonstrate that c cegar makes it possible to independently evaluate components like precision refiners which was not possible before.
our results are verifiable all data and software are publicly available for inspection and reproduction sect.
.
significance and potential impact.
evaluations in the research literature and competitions show that different approaches have different strengths to solve the problem of software verification.
it is therefore imperative to leverage the possibility of substituting components by alternatives instead of re implementing whole tools.
exchangeability is a key feature in component based design and our approach can lead to components that are tuned to excel in their specific task.
sat and smt solvers are a success story because there already is such a clearly defined interface sat queries smtlib exchange format many applications build 537decomposing software verification into off the shelf components an application to cegar icse may pittsburgh pa usa on sat and smt solvers as components and many tools implement these component interfaces .
software verification needs to be integrated into the continuousintegration process and therefore it is important to reduce its response time.
most of the currently available software verifiers are not constructed in a way that supports massively parallel execution but the decomposition of verification techniques into stand alone components would enable this.
with c cegar we try to improve the state of the art in this respect.
we see our work as a catalyst for further research in the domain of cegar and as a first step towards a microservice architecture for software verification.
.
related work there is a large body of literature on decomposition interfaces and cooperative verification.
we restrict ourselves here to provide a few pointers to literature that directly inspired our work.
compositionality and decomposition.
decomposition is a central general problem solving approach in computer science and in particular in software engineering .
the goal is to divide and conquer that is split the problem into easier to solve sub problems and solve them as independently as possible.
compositionality means that a system can be composed from components.
cooperative verification.
the electronic tools integration platform eti was an effort to collect and conserve tools from the formal methods community.
wide and public availability of tools is the precondition to any kind of cooperation.
the evidential tool bus arose also in the formal methods community and tries to integrate tools that cooperate in particular to compose assurance claims.
conditional model checking cmc is an approach in which several tools exchange information about the progress of the verification.
cmc introduced a condition as artifact that describes which parts of the system are successfully verified so far.
conditional testing applies the same idea to software testing.
sets of test goals are used as artifact to describe what has been tested so far.
conditions are also used to test what could not be verified .codidroid is a broker that delegates queries to the tools that are best suited to answer them.
this way several tools cooperate to achieve the goal.
composition in software verification.
there are several approaches to compose new tools from existing binary components.
reducers can be composed from off the shelf verifiers to construct conditional verifiers and the artifact that is passed from the reducer to the verifier is a residual program.
metaval is an approach to construct a witness based result validator from a program transformer and an off the shelf verifier.
if the specification is large it could be promising to decompose the specification .
interfaces.
components are connected via interfaces.
the interface specifies what the outside should know about the component and what types of data or more general artifacts are expected as input and output.
signatures of functions are often used in programming languages to document how a function can be used and abstract classes in java interfaces are used to document a cohesive component or subsystem by a set of functions with their signatures which describe the service that the component or subsystem delivers.
behavioral interfaces were found to be useful for concurrentsystems for timed systems for resources for web services and for program apis and their behavior .
verification artifacts and exchange formats.
artifacts and formats that are relevant for cooperative verification were discussed recently .
to give some examples artifacts for cooperative verification can be a programs exchange format c b specifications exchange format c results exchange format and d conditions exchange format .
libraries and components.
many verification approaches are based on formulas in a certain logic and theorem provers or smt solvers are used to reason about the programs or systems.
smt solvers support a standard exchange format and there are even api frameworks that make smt solvers exchangeable.
there was already an idea to make reachability queries via a defined interface because several verification approaches can be solved with the help of reachability queries such as termination analysis test case generation impact and pdr .
cegar.
the full concrete system implementation is often complex and abstraction can help to ignore details that are not important for proving correctness or for finding bugs.
cegar is an approach that can be used to compute an abstraction of the system.
there are many verification tools that use cegar as a component for example the most recent sv comp report mentions the following brick cpa bam bnb cpalockator cpachecker gazer theta jayhorn pesco uautomizer ukojak utaipan and veriabs .
cegar is a research topic itself because of its importance .
this paper stands on the shoulders of the fine works described above we use cegar decompose it into components use verification witnesses as interfaces and reuse existing components for the construction of the components.
background we start by explaining some basic notations and concepts.
programs.
for a simplified presentation we assume that each program contains at most one program statement on each sourcecode line and that the only variable type is integer z .
figures 3a and 3b show two programs.
for a program p we define the set lof all program locations uniquely identifiable by source code line the program counter pc l the setxof all program variables the setopof all program operations over integer variables and the program states c x z pc l .
a program state c c assigns a value to each program variable and a line number to pc.
a program path c0op0 ...opn cnis a sequence of program states wherec0is an initial state with arbitrary value assignments for program variables opiis the program statement at program location ci pc andci 1is a possible successor state of ciafter executing opi.
acontrol flow automaton cfa l l0 g for a program pconsists of the locations l the program entry l0and transitions g l op l modeling the execution of a statement when moving the program counter from one location to a successor location.
when controlflow branches conditionally e.g.
because of an if else orwhile 538icse may pittsburgh pa usa d. beyer j. haltermann t. lemberger and h. wehrheim 1int main 2unsigned int y 3while y y 2u nondet if y !
else error a craig interpolation finds the more meaningful precision ymod newtonfinds the equivalent but more complex precision y y 1int main void 2unsigned int x 3unsigned short n nondet 4while x n x 7if x 8else error b newton refinement finds the more meaningful precision x x craig interpolation enumerates all valid assignments for xexplicitlyl1 l2 l3 l4 l7 l5 l9 l10x n nondet x n x x n x x error c cfa for program fig.
3b figure code examples for craig interpolation and newton refinement the two corresponding edges of a cfa are labeled with the condition e.g.
for the if branch and the negated condition e.g.
for the else branch .
figure 3c gives the cfa of the program in fig.
3b.
software verification aims at analyzing the correctness of software.
in this work we suppose the verifier to check c programs for the reachability of calls to the specific error function error which represents a specification violation1.
a program piscorrect if there is no program path that contains the statement opi error .
a state condition is a logical expression over program variables e.g.
y used to express state space restrictions.
a program state cfulfills a state condition whenc .
we define the type of state conditions.
witnesses.
the interfaces in our component based cegar approach all come in the form of witnesses .
an invariant witness describes a set of potential invariants for a program using the formal definition of the common exchange format of correctness witness .
intuitively an invariant witness automaton is a cfa equipped with invariants explaining why a property is not violated on a path or in a program.
an example of an invariant witness is given in fig.
.
more formally the invariant witness automaton consists of a set of states q an initial state q0and a transfer relation .
a stateq qmay summarize several concrete states of a cfa.
in the example the state q2 represents the cfa nodel3 q3summarizes l4andl5andq4summarizesl7 l9andl10.
in addition states can contain invariants e.g.
state q2contains the invariant x x .
a transition between two states is labeled with the line number of a program location.
if the location is a branch or a loop head the transition is in addition either 1we do not lose generality as any safety property can be reduced to the call to an arbitrary function.
2we use the term invariant witness as a correctness witness contains correct invariants only in contrast to the invariant witness.q0 q1 q2 x x q4 q3line line cond true line cond falseline cond true line 5o w o w o w o w o w figure invariant witness automaton for fig.
3bq0 q1 q2 qerrline y line cond true line cond falseo w o w o w figure invalid violationwitness automaton for fig.
3a labeled with cond true orcond false indicating whether the condition is assumed to be true or false.
each state has an additional self loop labeled o w otherwise that can be taken if no other transition is applicable when a state summarizes several cfa nodes .
thereby the invariant witness covers all paths present in a cfa.
aviolation witness in the common exchange format for witnesses describes a set of program states of which at least one represents a specification violation.
these program states are described by a violation witness automaton.
a violation witness automaton is similarly defined to invariant witness automata with three differences as it only represents a subset of the cfa it may limit the cfa by not providing a o wtransition for each state it does not contain invariants and its transitions may in addition contain state conditions to model assumptions on the programs state.
figure contains a violation witness for fig.
3a that describes the path of line to line .
a violation witness is called valid if at least one concrete path in the program matches the described path otherwise it is invalid .
as the program in fig.
3a is correct the violation witness is invalid.
to increase the confidence in verification results sv comp requires since that all participating verifiers report a violation witness or correctness witness as part of each verification result.
precision refiners.
one component of c cegar for which conceptually different techniques exist is the precision refinement .
in our evaluation we will illustrate the advantage of c cegar with the possibility of an independent evaluation of precision refiners.
here we first of all give an example to show that different forms of precision refiners have different benefits.
the programs of figures 3a and 3b taken from sv benchmarks3 illustrate the precisions for a predicate domain computed by craig interpolation and newton refinement .
in fig.
3a an indefinite while loop adds a non deterministically computed even value to program variable y line and then asserts that y line .
because yis initialized with in line ywill always stay uneven and thus unequal to even if an overflow occurs.
this means that the assertion always holds.
trying to prove this craig interpolation implemented in cpachecker computes the predicate ymod 1for the loop head in line which a verifier can use to construct the right level of abstraction for proving the assertion in line .
newton refinement 539decomposing software verification into off the shelf components an application to cegar icse may pittsburgh pa usa implemented in ultimate automizer computes a predicate with the same meaning but it is more complex and increases verification overhead y y 4in fig.
3b a while loop adds value 2to program variable xuntilxis greater than or equal to non deterministic value n. afterwards it asserts that xmod .
becausexis initialized with 0andnis of type unsigned short the loop can at most add tox.
the type of x unsigned int is large enough to hold this value.
thus there will be no overflow on x andxwill always be even or .
this means that the assertion always holds.
trying to prove this craig interpolation creates a large number of predicates that enumerate all possible values for x i.e.
x x x etc.
computing these predicates requires many precision refinements and is costly.
in contrast newton refinement finds the more helpful predicate x x which encodes xmod 0and hints to a more suited coarse abstraction.
these small examples show that there is no single technique that is optimal for all programs.
c cegar is designed to open up the possibility for systematically performing exactly these kind of comparisons.
component based cegar for a decomposition of cegar we need to identify its individual components and precisely define the interfaces between components.
figure depicts the resulting workflow.
.
interfaces of c cegar the components of cegar pass infeasible counterexamples and precision increments among each other.
we briefly discuss the information passed paths.
both potential and infeasible counterexamples are typically described by sets of program paths .
program paths are sequences of program locations and program states.
an exchange format for paths should allow to describe program paths both concrete and abstract so that multiple paths can be described and information can be restricted to the important.
the exact path information that is exchanged must balance precision and abstraction a more precise description of program paths avoids imprecision but may become very large think about a precise description of many loop unrollings and lead the precision refiner to produce very specific precision increments.
a more abstract description of program paths may guide a precision refiner to produce more generic precision increments which are often better but it may also increase imprecision and require more time to analyze.
it may be beneficial to not only describe syntactic program paths but to include information about the program state like constraints on variable values for reaching a certain program location.
this can help the feasibility checker and precision refiner to reconstruct relevant information.
precision increment.
the precision increment produced for an infeasible counterexample helps the abstract model exploration to not explore the same infeasible counterexample again but to prove it infeasible.
the concrete type of precision depends on the abstract model explorer but for communicating precision increments we propose the use of partial invariants i.e.
invariants that hold for a subset of program paths.
from these partial invariants an 4it can be shown that this term is equivalent to ymod 1based on the c datatypes.
a detailed reasoning is given on our supplementary webpage task invariant witnessstrengthener p strengthened taskoff the shelf verifierverdict violation witnessabstract model explorer figure construction of an abstract model explorer from an off the shelf verifier abstract model explorer can infer its precision.
for example predicate abstraction can split partial invariants into atoms and create a mapping from program locations to predicates.
when exchanging partial invariants a balance between weak and strong invariants must be found.
in addition most of the time smaller invariants are easier to parse and reuse than equivalent but more complex invariants consider the example invariants of fig.
3a .
the types of these artifacts are arbitrary and information other than the proposed are possible.
but to achieve the goals of c cegar common and at the best standardized interfaces are required.
to exchange sets of program paths and precision increments we propose to use the existing exchange formats for verification artifacts violation witness.
we use violation witnesses for describing the potentially infeasible counterexample obtained from the abstract model exploration.
path witness.
if a violation witness is rejected by the feasibility checker then it describes an infeasible counterexample path and no valid violation.
to signify this change in the meaning of the witness we call a rejected violation witness path witness .
a path witness is passed from feasibility checker to precision refiner.
invariant witness.
precision increments are described by invariant witnesses which give partial invariants in a program e.g.
for invariants associated to loop heads.
with the existence of a general format for witnesses we thus have tool independent interfaces.
.
components of c cegar next we describe the three components of c cegar in more detail.
the three components use the above interfaces to pass information from one to the next component.
furthermore the components take input from and provide output to the environment.
abstract model explorer.
c cegar uses an abstract model explorer to compute the abstraction.
the abstract model explorer takes two inputs the program punder verification and the specification together called task and an invariant witness and provides two outputs potentially the final verdict correct and if the verdict is not correct a violation witness that describes at least one potential counterexample path.
the input invariant witness describes the precision increment.
the contained partial invariants are parsed and used for improving the precision of the abstraction employed during model exploration.
540icse may pittsburgh pa usa d. beyer j. haltermann t. lemberger and h. wehrheim p task violation witnessreducer p updated task with path programoff the shelf verifierverdict path witnessfeasibility checker figure construction of a feasibility checker from an offthe shelf verifier feasibility checker.
the feasibility checker is responsible for checking counterexample paths for feasibility.
a feasibility checker takes two inputs the task and a violation witness.
it provides two outputs potentially the final verdict incorrect and if the violation witness contains no feasible counterexample path a path witness that describes no feasible and at least one of the infeasible counterexample paths contained in the input violation witness.
precision refiner.
the task of the precision refiner is to compute new refined precision increments for the abstraction.
a precision refiner takes two inputs the task and a path witness.
it provides as single output an invariant witness that describes a precision increment computed based on the path witness.
.
usage of off the shelf components for a realization of c cegar as a cooperation of off the shelf components implementations of all three components are required.
a key advantage guaranteed by the usage of witnesses is the fact that such components can partially be generated with existing off the shelf verifiers.
abstract model explorer.
any off the shelf verifier can be turned into an abstract model explorer by encoding the invariants in the invariant witness which the verifier might not natively understand as additional code assertions in the program using metaval we call a task enriched with such invariants strengthened task .
in addition verifiers cpachecker and uautomizer natively support parsing invariant witnesses and using them for abstract model exploration.
feasibility checker.
any existing results validator for violation witnesses of which there are plenty can work as feasibility checker .
furthermore any off the shelf verifier can be turned into a feasibility checker by transforming the violation witness into program code .
this so called path program only encodes the program parts encoded by the witness.
precision refiner.
finally we can generate precision refiners out of invariant generation tools like .
to this end we combine the current task and a path witness into an updated task which only contains those parts of the program which cover the infeasible counterexample paths contained in the path witness.
this updated task is then passed to invariant generation .
if an invariant generator does not support the output format of invariant witnesses existing techniques can perform this transformation.
in addition any feasibility checker that is able to output an invariant witness can be used as precision refiner.p task path witnessreducer p updated task with path programoff the shelf invariant generator invariant witnessprecision refiner figure construction of a precision refiner from an off theshelf invariant generator overall this shows the advantage of the decomposition of cegar once such a component based framework is available different tools can be plugged into it with the help of various program transformations even those that do not natively support these interfaces.
implementation to realize a first c cegar instance we started with a decomposition ofcpachecker s implementation of cegar with predicate abstraction.
afterwards we experimented with the usage of other off theshelf components as feasibility checker and precision refiner.
.
cpachecker s predicate abstraction cpachecker is a configurable tool for software verification offering many different analysis techniques especially providing an implementation of predicate abstraction using cegar .
it has a mature code base and has proven its ability to verify and falsify programs by winning medals in the category overallinsv comp for the fifth year in a row among others by applying predicate abstraction.
cpachecker s implementation of predicate abstraction pred is a program analysis comprising two modules a model explorer and a combined feasibility checker and precision refiner.
the analysis is based on the cpa algorithm with precision adjustment and adjustable block encoding abe .
in general the analysis information is stored in an abstract reachability graph arg linking the analysis information with cfa nodes.
the analysis stores a set of available predicates as precision for each arg node together with a boolean formula abstracting the current state using predicates from the precision.
initially only the predicates true andfalse are available.
the abstraction is computed using the strongest postcondition semantics.
if the model explorer finds an abstract path in the arg to an error location this path is analyzed for feasibility.
within pred a potential counterexample path is checked for feasibility by validating the path formula which is build using the strongest postcondition semantics.
it is represented in an internal format similar and compatible with smt lib .
the obtained formula is checked for satisfiability using mathsat5 .
an unsatisfiable formula indicates an infeasible path.
in this case mathsat5 s craig interpolation is used to compute a precision increment.
the newly discovered predicates are added to the precision and the arg is recomputed.
otherwise a violation witness is computed for the found counterexample.
in addition the precision is reported using a predicate map which is a format containing the predicates in smt lib.
541decomposing software verification into off the shelf components an application to cegar icse may pittsburgh pa usa 1explorer actorfactory.create programvalidator cpa predicate norefinement.yml 3checker actorfactory.create programvalidator cpa validate violation witnesses.yml 5refiner actorfactory.create programvalidator uautomizer.yml figure example configuration of c cegar components in coveriteam .
decomposing cpachecker s predicate abstraction besides the existing cegar implementation cpachecker also provides additional helpful configurations validating potential counterexamples given as violation witnesses and analyzing only the part of a program described by a violation witnesses and computing a precision increment for the infeasible part.
to decompose this existing implementation we created new configurations to ensure that only the desired functionality is executed.
thereby we obtained three standalone and stateless components abstract model explorer.
this configuration computes only the arg and checks whether a counterexample path is present.
a potential counterexample path is exported as violation witnesses.
the initial precision is given as predicate map.
feasibility checker.
to check a given violation witness for feasibility we use cpachecker s existing witness based result validation working with violation witnesses.
precision refiner.
the precision refiner takes the path witness as input and uses strongest postcondition semantics to build a path formula for each path within the witness.
it then computes craig interpolants for each path and exports the computed interpolants in a predicate map.
.
implementation in coveriteam the c cegar implementation using these three components realized using coveriteam is called c pred .coveriteam is a framework for cooperative verification allowing for the definition of new verifiers as compositions of stateless components.
it provides an easy to use language for describing the components inputs and outputs as well as the communication among them.
compositions are defined in a domain specific language and components can be exchanged easily see fig.
for an example .
.
off the shelf components besides the thus constructed c pred we used several off the shelf components to evaluate the benefits of c cegar .
we searched for tools applying techniques conceptually different to cpachecker which can either work with the exchange formats directly or can analyze the corresponding path program.
we have chosen the following two tools fshell witness2test .fshell witness2test is an execution based result validator for violation witnesses that is implemented independent of any existing verification tool.
fshell witness2test extracts test vectors encoded in the violation witness automaton converts this test vector into a compilable test harness compiles the testharness against the program under verification and executes it.
if a specification violation is observed during execution the violation witness is shown to be valid through program execution.
if no specification violation is observed during execution the violation witness is rejected.
due to concrete program execution fshell witness2test is very precise.
but fshell witness2test can only validate violation witnesses that contain for each non deterministic value in the program a state condition that encodes the corresponding concrete value.
for example fshell witness2test would neither be able to validate nor reject fig.
because this violation witness automaton does not define a concrete value for the nondeterministic method call nondet in line of fig.
3a.
ultimate automizer .ultimate automizer is a verification tool that uses a finite state automaton for the program and encodes property violation as final states.
accepting runs of the automaton are then analyzed for feasibility.
by default it applies a cegar based predicate abstraction wherein the precision increment is computed using newton refinement.
newton refinement is conceptually different from craig interpolation which is employed by the cpachecker precision refiner.
whenever a path in the automaton is proven infeasible a generalization is aimed for to reduce the accepted language of the automaton.
a program is thus proven correct if the language of the automaton is empty.
ultimate automizer offers the option to only analyze the paths of a program covered by a violation witness and to store the computed precision increment in an invariant witness.
hence we can directly use ultimate automizer as both feasibility checker and precision refiner off the shelf.
evaluation within a c cegar implementation components can be easily exchanged by others which implement the same interface via different concepts.
we thus allow researchers to focus on enhancing individual components instead of reimplementing the whole cegar scheme.
for our evaluation we are interested in examining the overhead associated with such a decomposition.
moreover we want to investigate whether the component based implementation can bring an improvement over the tightly coupled one by studying novel combinations of components.
.
research questions we have already shown the feasibility of c cegar in sect.
.
here we want to study the following three research questions rq .
how large is the overhead of a component based approach that uses off the shelf components?
rq .
what are the cost for using standardized formats in c cegar ?
rq .
can the use of different off the shelf components in c cegar increase the overall effectiveness to solve verification tasks?
.
evaluation setup we run our experiments on machines with an intel core i5 v5 .
ghz cores gb of memory and ubuntu .
lts with linux kernel .
.
generic.
to increase the reproducibility of our results we run our experiments with benchexec .
each verification run is limited to use gb of memory cpu cores 542icse may pittsburgh pa usa d. beyer j. haltermann t. lemberger and h. wehrheim table comparison of cpachecker s predicate abstraction and the component based version in two variations correct incorrect overall proof alarm proof alarm pred c pred c predwit and min of cpu time.
the used setup is comparable to the setup used in the sv comp .
we use sv benchmarks the largest available benchmark set for verification of c programs in the version used in sv comp .
we use all verification tasks with a reachability property.
a verification task can be safe contains no violation or unsafe contains a violation .
we use cpachecker version .
.
coveriteam version c cegar icse20227 fshell witness2test8and uautomizer9 in its sv comp version uautomizer uses a wrapper script to determine the correct configuration to use in sv comp .
by default this does not produce invariant witnesses if a violation witness is given.
we communicated with the developers of uautomizer and adjusted the wrapper script according to their instructions so that uautomizer always creates invariant witnesses.
this adjusted wrapper script and all other data and tools is available in our supplementary artifact .
.
evaluation results rq overhead of component based design .
evaluation plan to analyze the cost of using a component based approach we compare the effectiveness rq .
and efficiency rq .
of pred described in sect.
.
and our component based version c pred described in sect.
.
.
to improve comparability we configure the model explorers of both pred and c pred to start the exploration at the root of the arg in each iteration.
rq .
effectiveness .
table shows the experimental results of the comparison the number of tasks solved by the componentbased version c pred reduces from to3 .
there are 25tasks that c pred solves even though pred does not but also 270tasks that c pred fails to solve but pred does a .
decrease .
for most of these tasks the reason for failure is the decrease in efficiency when increasing the time limit for c pred by the factor of twelve to180min c pred only fails to solve 60tasks that pred can solve.
this is only a .
decrease compared to pred.
reason for the remaining 60unsolved tasks is the feasibility checker used by c pred .
it a rejects more counterexamples because it is more precise than the internal check of pred b explores paths with unsupported program features that pred does not visit or c triggers smt errors because different interpolation sequences are queried.
these three issues are not related to c cegar but to the inconsistency between the internal feasibility checker of pred and the one used by cpu time for pred s 110100900cpu time for c pred s a comparison of cpu time for pred and c pred .
.
.
.
b distribution of run time factor for c pred compared to pred figure comparison of efficiency of pred and c pred across all successful verification runs c pred .
except for these issues we can conclude that c pred has the same expressive power and can solve the same verification tasks as the classic version pred when more time is given .
because the feasibility check of c pred is more precise than that of pred the number of false alarms reduces from 9to3.
decomposing an existing cegar implementation into components has almost no negative effects on the effectiveness of the approach.
moreover the new tool can have a higher precision because better components can be used.
rq .
efficiency .
in general c pred takes more cpu time to compute the result.
this effect is illustrated in the scatter plot in fig.
10a.
the plot shows all tasks that pred and c pred both solved correctly.
each point x y represents a task where pred takesx cpu seconds and c predycpu seconds.
to visualize overlapping datapoints each point is displayed with a transparency of .
figure 10a clearly visualizes that c pred has a lower efficiency compared to pred whereas the factor for the increased cpu time is bounded by roughly dashed line .
more precisely c pred uses on mean average the .
fold cpu time whereas the median increase is .
.
therefore we provide a more precise insight on the time differences in fig.
10b in of all cases c pred takes at most as much cpu time as the non composed version factor of .
.
for the increase is bounded by the factor .8and in of the cases the cpu time increases by at most .
.
the upper whisker at which includes of all data shows that there are some tasks for which c pred takes notably longer.
thus the median is more meaningful.
to increase readability 35outliers ranging from factor 13to31 are not shown.
we also observed that the median increase strongly correlates with the number of cegar iterations needed to solve a task.
figure visualizes the median increase grouped by the number of cegar iterations needed.
note that the i th bars s width represents the number of tasks that can be solved in iiterations.
when the task can be solved within a single cegar iteration in the median the cpu time does not increase factor of .
.
almost of all tasks are solved within at most cegar iterations.
as the number of tasks solved with more than five iterations is smaller than the 543decomposing software verification into off the shelf components an application to cegar icse may pittsburgh pa usa number of cegar iterations to solve taskmedian factor of increase in run time0.
.
.
.
.
.
.
.
.
.
figure median factor of run time increase by c pred compared to pred for the first numbers of cegar iterations.
the width of the bar for icorresponds to the number of verification tasks that require exactly icegar iterations 1int main void 2unsigned int x 3unsigned int y 5while y x y 9if x else error a program from sv comp where x 0is not a valid invariant at the loop head.q0 q1 q2 qerrline cond true line cond false line cond falseo w o w o w b counterexample computed by model explorer figure example comparing predicate map and invariant witness as exchange formats median may not perfectly summarize these iterations.
we present the full figure and the raw data on our supplementary webpage10.
the additional run time consumed by c pred stems mostly from the following facts due to the three stateless components less caching is possible e.g.
for incremental solver usage each component has to recompute basic information for the program especially the cfa which yields non negligible i o overhead and redundant counterexample checks may be performed because feasibility check and precision refinement are fully decoupled.
the efficiency of c pred decreases only by a constant factor median smaller than three .
rq cost of standardized formats .
evaluation plan instead of encoding the precision increment computed by the precision using the cpachecker internal format predicate map we use a standardized format namely the invariant witness.
we call this configuration c predwit .
we compare the effectiveness and efficiency of c pred with c predwit .
table also contains the experimental results of c predwit .
this configuration can solve in total tasks computing correct proofs and 744correct alarms.
compared to c pred the effectiveness reduces by 670tasks a decrease of around .
this decrease follows mostly from the fact that the precision refiner does not add the computed precision increment to the invariant cpu time for c pred s 110100900cpu time for c predwit s figure comparison of run time per task of c pred and c predwit in cpu time seconds witnesses.
as a result c predwit gets stuck in an endless loop and eventually aborts the computation.
since invariant witnesses are not primarily designed for the exchange of a precision increment we regularly observe this behavior.
we exemplify its main reason in fig.
figure 12a contains a simplified c program from our evaluation.
before the loop body is executed for the first time the value of xis1andyhas the value .
after the first loop iteration xhas the value of 0andy s value is unequal to0.
the model explorer computes the spurious counterexample visualized in fig.
12b.
the path contains exactly one loop iteration q0toq1 and leads to the error location afterwards q1toq2to qerr .
a helpful precision increment which can be used to prove the counterexample to be spurious and the program to be correct contains the predicate y x for stateq0and the predicate y x for stateq1.
although the invariant witnesses format can conceptually be used to express loop unrollings and thus can contain these two predicates none of the precision refiners used encode these or comparable predicates in an invariant witness.
in contrast the predicate map used to exchange information in c pred contains the predicates y y x andx which enable the model explorer to remove the spurious counterexample.
next we compare the efficiency of c pred and c predwit .
figure compares the cpu time used to compute the correct solution for a task.
it is visible that except for a few outliers both tools have the same efficiency.
the effectiveness of c cegar reduces by when using standardized formats whereas the efficiency is not influenced.
rq benefit of different components .
finally we analyze the advantages of the component based design by replacing the cpachecker components by existing off the shelf implementations.
here we consider two separate questions exchanging the feasibility checker in rq .
and the precision refiner in rq .
.
in the following we are using violation and invariant witnesses as exchange formats.
rq .
benefit of different feasibility checkers .
evaluation plan to analyze how different feasibility checkers influence the effectiveness and efficiency we replace cpachecker s witness validation with both fshell witness2test and uautomizer .
then we compare the effectiveness of the three resulting c cegar configurations.
544icse may pittsburgh pa usa d. beyer j. haltermann t. lemberger and h. wehrheim table c cegar using different components rq .
c predwit different feasibility checker with precision refiner cpachecker correct incorrect overall proof unique alarm unique proof alarm cpachecker fshell witness2test uautomizer rq .
c predwit different precision refiner with feasibility checker cpachecker correct incorrect overall proof unique alarm unique proof alarm cpachecker uautomizer table shows the experimental results for each of the three configurations it shows the overall correct results the correct proofs the unique proofs the correct alarms the unique alarms the incorrect proofs and alarms and the unknown results.
a proof or alarm is considered unique if the corresponding configuration is the only one that achieves that result.
the table shows that c pred with cpachecker as feasibility checker produces the best results.
considering the unique results among these three configurations it is visible that all three feasibility checkers allow the verification of tasks that neither of the other two configurations can solve.
c cegar allows a simple exchange of feasibility checkers.
the use of conceptually different off the shelf checkers can increase the effectiveness of c cegar .
rq .
benefit of different precision refiners .
evaluation plan we replace cpachecker s precision refiner which uses craig interpolation by an existing tool applying a conceptually different refinement strategy.
therefore we use a configuration of ultimate automizer for the path described in the violation witness computing the newtonrefinement.
to the best of our knowledge ultimate automizer is the only formal verification tool that is able to process violation witnesses as additional input and that also outputs invariant witnesses.
note that in theory any verification tool can be transformed to process violation witnesses through program transformation as explained in sect.
.
.
unfortunately based on sv comp no other verification tool is able to produce meaningful invariant witnesses this evaluation is available on our supplementary webpage11 .
our objective is to show the most important advantage of c cegar namely that using complementary techniques can lead to an increased effectiveness through uniquely solved tasks.
table also contains the results for c pred using cpachecker and ultimate automizer as precision refiner.
c predwit with ultimate automizer as precision refiner is able to find proofs vs. and309alarms vs. .
these numbers are lower than c predwit with cpachecker as precision refiner but this combination is still able to find 29proofs and 1alarm that are not found by c predwit cpachecker .
this shows that different precision refiners have different strengths and weaknesses so the easy replacement offered by c cegar can be beneficial.
taking a closer look at the two tasks given as motivating examples in fig.
3a and fig.
3b we observe the following for fig.
3b ultimate automizer is able to export a meaningful precision increment when cpachecker in contrast starts enumerating valid assignments for x. in this case the configuration with ultimate automizer as precision refiner can continue the analysis and solve tasks that cannot be solved by the other configuration.
on the other hand the precision increment computed by ultimate automizer often contains correct but complex predicates for which the model explorer runs into a timeout.
one example is given in fig.
3a where the precision increment y y is logically equivalent to ymod found by cpachecker but expressed in a more complex way.
c cegar allows a simple exchange of precision refiners.
the use of conceptually different off the shelf refiners can increase the effectiveness of c cegar .
.
threats to validity we have conducted our evaluation using the dataset sv benchmarks which is the largest publicly available benchmark set for c program verification and also used by competitions.
although this dataset is widely used and accepted for benchmarking our findings may not completely carry over to real world c programs or other programming languages.
regarding resources we limited the cpu limit to 15minand memory to15gb.
more resources will lead to improved results but both the new approach and the baseline would benefit from more resources.
we considered only off the shelf tools that participated in sv comp because we consider them state of the art.
for verification witnesses we used the standardized format which is also used in sv comp .
using other existing tools in addition may lead to different results.
to the best of our knowledge there are no other standardized formats applicable in the c cegar setting or other tools that can process the 545decomposing software verification into off the shelf components an application to cegar icse may pittsburgh pa usa used exchange formats properly.
even if such formats would exist or other tools are applicable but do not increase the effectiveness our findings remain valid.
in addition we cannot guarantee that decomposing other existing cegar schemes into components lead to the same results.
as the results from c pred and pred show a high agreement in the results we are confident that the implementation does not suffer from bugs.
anyhow such bugs would influence the effectiveness only negatively and our findings would remain valid.
the reported data may deviate on reproduction due to different experimentation environments and measurement errors.
to guarantee that our reported data has the highest precision possible we conducted the experiments using the benchmarking framework benchexec .
to account for small expected measurement errors we restrict the presentation of our data to two significant digits.
conclusion software verification is an important and complex problems in computer science important because our society depends on correctly functioning software and complex because the problem is in general undecidable.
software engineering offers the idea of decomposition to tackle complexity in order to be able to focus on subproblems which are easier to solve than the overall problem.
this paper investigated the problem of decomposing the oftenused cegar approach into components for which we can take publicly available binary components off the shelf .
this opens up many new opportunities.
in particular researchers can now focus on developing highly tuned components for each of the subproblems and there are easy ways to parallelize software verification in order to reduce the response time.
however tool developers also have to make sure that their components deliver high quality information to other components at the best in a standardized format.
in future work we will investigate the decomposition of further verification approaches as well as explore the options for parallelization.
an obvious first idea is to slightly change the outer cegar loop in such a way that the abstract model exploration generates a stream of counterexamples each of which is investigated independently by feasibility checks and precision refinements running in subprocesses which feed the precision increments onthe fly back to the abstract model exploration.
declarations data availability statement.
our implementation is open source and available online as part of coveriteam minor adjustments for the c pred configuration were checked in to the project repository for cpachecker .
the implementation and all experimental data are archived and available at zenodo .
funding statement.
this work was funded by the deutsche forschungsgesellschaft dfg coop .