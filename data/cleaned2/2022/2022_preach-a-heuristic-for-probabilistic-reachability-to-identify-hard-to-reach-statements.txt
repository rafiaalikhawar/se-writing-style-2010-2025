preach a heuristic for probabilistic reachability to identify hard to reach statements seemanta saha university of california santa barbara santa barbara ca usa seemantasaha cs.ucsb.edumara downing university of california santa barbara santa barbara ca usa maradowning cs.ucsb.edu tegan brennan university of california santa barbara santa barbara ca usa tegan cs.ucsb.edutevfik bultan university of california santa barbara santa barbara ca usa bultan cs.ucsb.edu abstract wepresentaheuristicforapproximatingthelikelihoodofreaching agivenprogramstatementusing1 branchselectivity representing the percentage of values that satisfy a branch condition which we compute using model counting dependency analysis which we use to identify input dependent branch conditions that influence statement reachability abstract interpretation which we use to identify the set of values that reach a branch condition and a discrete time markov chain model which we construct to capture the control flow structure of the program together with theselectivityofeachbranch.ourexperimentsindicatethatour heuristic based probabilistic reachability analysis tool preach can identifyhard to reach statements with high precision and accuracy inbenchmarksfromsoftwareverificationandtestingcompetitions apachecommonslang andthedarpastacprogram.weprovideadetailedcomparisonwithprobabilisticsymbolicexecution and statistical symbolic execution for the purpose of identifying hardtoreachstatements.preachachievescomparableprecision andaccuracytobothprobabilisticandstatisticalsymbolicexecutionforboundedexecutiondepthandbetterprecisionandaccuracy whenexecutiondepthisunboundedandthenumberofprogram pathsgrowsexponentially.moreover preachismorescalablethan both probabilistic and statistical symbolic execution.
ccs concepts software and its engineering software testing and debugging software verification automated static analysis theory of computation program analysis.
this material is based on research sponsored by nsf under grants ccf ccf and ccf .
the u.s. government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyrightnotation thereon.
the views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements either expressed or implied of the u.s. government.
this work is licensed under a creative commons attribution international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
reference format seemantasaha maradowning teganbrennan andtevfikbultan.
.
preach a heuristic for probabilistic reachability to identify hard to reach statements .
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction software quality assurance is one of the most fundamental problems in computing.
the most common software quality assurance techniqueissoftwaretesting.althoughtherehasbeenasurgeof progress in automated software testing techniques such as random testing fuzzingandsymbolicexecutioninrecentyears thereare remaining challenges.
on one hand fuzzing and random testing techniques are comparatively scalable but have difficulty in exploringhard to reach program paths.
on the other hand symbolic executionbasedtechniquescanexplore hardtoreach programpaths by solving path constraints but are not as scalable.
hybridtestingtechniques combineconcrete e.g.
random testing fuzzing and symbolic techniques in order toimprovetestingeffectiveness.typically astrategyfunctionfor hybridtestingdecideswhentoapplyconcretetechniquesandwhen toapplysymbolictechniquestoachievescalableandeffectiveexploration of the program behaviors.
in order to choose between concreteandsymbolicapproaches mostexistingstrategiesassess the difficulty of concrete testing based on the saturation of randomtesting orprobabilisticprogramanalysis .determining the likelihood or conversely difficulty of reaching a program statement is critical for assessing the difficulty of concrete testing and hence developing an effective hybrid testing strategy.
there aretwoexistingapproachesthataddressthisproblem probabilistic and statistical symbolic execution.
probabilisticsymbolicexecution isanextensionofsymbolic execution that computes probabilities of program paths.
however probabilistic symbolic execution suffers from the same limitations assymbolicexecution itcanonlyanalyzeprogrambehaviorsuptoacertainfixedexecutiondepth henceitcannotanalyzebehaviorsofarbitrarilylargeprogrampaths.
duetoexponentialincreasein numberofpathswithincreasingexecutiondepth pathexplosion problem thecostofsymbolicexecutionincreasesexponentially with increasing execution depth.
although the sizes of path constraints generated by symbolic execution increase linearly with the execution depth since the worst case complexity of constraint ieee acm 44th international conference on software engineering icse icse may pittsburgh pa usa seemanta saha mara downing tegan brennan and tevfik bultan solversisexponential thelinearincreaseinpathconstraintsizes can lead to exponential increase in analysis cost.
hence path explosioncombinedwithincreasingsizesofpathconstraintscanlead to double exponential blow up in the cost of symbolic execution limiting its practical applicability.
statistical symbolic execution is more efficient and scalable compared to probabilistic symbolic execution .
however it cannot compute precise reachability probabilities rather provides approximate reachability probabilities with statistical guarantee.
statisticalsymbolicexecutionsuffersfromsimilarissuesasprobabilistic symbolic execution.
there are two variants of statistical symbolic execution statistical analysis based on monte carlo samplingofsymbolicpaths and2 hybridanalysiscombiningboth statisticalandexactanalysisbasedoninformedsampling.oneof thedrawbacksofpurestatisticalsamplingisthatitneedstosample alargenumberofpathstoachievehighstatisticalconfidence.informed sampling obtains more precise results and converges faster than a purely statistical analysis but its effectiveness suffers when the number of program paths grows exponentially.
inthispaper wepresentaheuristicforprobabilisticreachability analysistoidentify hardtoreach programstatementsthataddresses the above shortcomings of probabilistic symbolic execution and statistical symbolic execution.
in particular our approach can model behaviors of arbitrarily long paths it does not suffer from path explosion i.e.
the cost of our analysis increases polynomially withthesizeoftheprogram anddoesnotdependontheexecution depth and finally it solves constraints arising from branch conditionsratherthanpathconstraintswhichreducesthecostof constraint solving.
ourapproach whichweimplementedinourtoolpreach works asfollows figure1 .inordertocomputereachabilityprobability of statements we introduce a concept called branch selectivity that determines the proportion of values satisfying a given branch condition.
a branch is very selective if only a few values satisfy the branchcondition.ontheotherhand ifalotofvaluessatisfythe branchcondition thenthebranchisnotveryselective.givenatarget statement in a program preach identifies the input dependent branchconditionsthatinfluencethereachabilityprobabilityofthat statement using dependency analysis.
then preach constructs adiscrete timemarkovchainmodelfromthecontrolflowgraph of the program by computing branch selectivity of each branch condition that influences the reachability probability of the target statement.
preach uses abstract interpretation to determine the set of values that reach each branch condition and model counting to compute the branch selectivity value for each branch in the program that influences statement reachability.
finally preach uses a probabilisticmodelcheckertocomputethereachabilityprobability of the target statement based on the constructed discrete time markov chain model.
oneshortcomingofourapproachisthatitisnotasoundprogram analysis technique and hence it does not provide guarantees intermsoftheprecisionoraccuracyofthereachabilityprobabilities it reports.
on the other hand though bounded symbolic execution is theoretically sound up to the execution bound and probabilistic symbolic execution can quantify how much of the execution space is not explored due to the execution bound for unboundedexecutions both probabilistic symbolic execution and statistical symbolic execution are not sound either.
we experimentallyevaluate preachonprograms fromthesvcomp benchmark set used in competition on software verification and competition on software testing .
each program inthisbenchmarksetcontainsanassertstatement.weusethese assert statements as the target of our probabilistc reachability analysis.weevaluatetheeffectivenessofourtechniqueinseparating hard to reach assert statements i.e.
assert statements with low reachability probability from easy to reach assert statements i.e.
assert statements with high reachability probability using a probability threshold i.e.
if the reachability probability of a statement is below the given threshold we classify it as hard to reach .
inordertodeterminethegroundtruth weuseageneratorbased random fuzzer that is based on jqf and zest .
we set a time limit for the random fuzzer and the assert statements that arenotreachedwithinthegiventimeoutaremarkedasthe hard to reachassert statements.
of the programs we used in our experiments therandomfuzzertimesouton51programs.preach classifiestheprogramsthattherandomfuzzertimesoutonashardto reach with95.
precisionand95.
accuracy.inparticular our techniquecorrectlyclassifies135outof142programsandgenerates only2falsepositives reports hardtoreach althoughthefuzzerdoes not time out and false negatives reports easy to reach although the fuzzer times out .
in order to further evaluate the effectiveness of our probabilistic reachability analysis we provide a detailed experimental comparisonwiththeprobabilisticsymbolicexecution pse andstatisticalsymbolicexecution sse extensionstosymbolicpathfinder spf tool.
experimental resultsshow that for programs with bounded execution depth pse achieves very high precision and accuracy to identify hard to reach cases.
however preach outperforms pse for programs with unbounded execution depth in termsofprecision accuracyandaverageanalysistime.forlarge search depths pse is unable to analyze of the target programs demonstrating its limitations in terms of applicability and scalability whereas preach can analyze .
we compare preach withsseonthesetofprogramsthatpseperformspoorly.ssewas unable to analyze of these programs and preach outperforms sse in terms of precision accuracy and average analysis time.
finally we analyze target statements in methods from apache commons lang and darpa stac benchmarks .
preachcanclassify19ofthe24targetstatementscorrectlydemonstrating its effectiveness on real world programs whereas pse and sse were able to successfully analyze and classify only one.
overview weformalizeprobabilisticreachabilityanalysisasfollows.given aprogram p letidenotetheinputfortheprogram and idenote the domain of inputs i.e.
i i .
note that ican be a scalar value a tuple oralistofvalues.givenatargetstatement tinprogram p thegoalofprobabilisticreachabilityanalysisistodeterminehow likelyitistoreachtargetstatement t.wedothisbydetermining how likely it would be to pick inputs that result in an execution that reaches t. in order to determine how likely it would be to pick 1707preach a heuristic for probabilistic reachability to identify hard to reach statements icse may pittsburgh pa usa 3urjudp s 7dujhw 6wdwhphqw w udqfk 6hohfwlylw 8vlqj 0rgho rxqwlqj dqg evwudfw qwhusuhwdwlrq7dujhw 6wdwhphqw 6xejudsk wudfwlrq 8vlqj rqwuro orz qdo vlv rqvwuxfwlrq 8vlqj hshqghqf qdo vlv dqg 4xhu rupxodwlrq5hdfkdelolw qdo vlv 8vlqj 3uredelolvwlf 0rgho khfnlqj q e z s w q50 s w q ij s w s w s w kdug wr uhdfk hdv wr uhdfk figure probabilistic reachability heuristic in preach 1public class main public static void main string args intarg verifier.nondetint if a r g return intx arg inty arg main inst newmain inst.test x y public void test intx intz system.out.println testing exsymexe7 inty z x y if z!
system.out.println branch foo1 else system.out.println branch foo2 assert false if y!
system.out.println branch boo1 else system.out.println branch boo2 figure an example based on sv comp benchmark such inputs we determine the probability of picking such inputs if inputs are chosen randomly.
we define p p t as p p t denotes the probability of reaching statement sduringthe executionofprogram poninputiifiis selected randomly from the input domain i. weassumeuniformdistributionofinputsinourcurrentimplementation.however ourtechnique canbeeasilyextendedto support any input distribution by integrating usage profiles used in other probabilistic analysis techniques.
it is well known that determining reachability of a statement in a program is an uncomputable problem.
hence determining p p t preciselyisalsoanuncomputableproblem.inthispaperwe present a heuristic approach that approximates p p t .
we report the reachability probability as a real number between and .
branch selectivity.
our heuristic approximation of p p t relies on a concept we call branch selectivity .
given a branch b branch selectivity s b isproportionaltotheratioofthenumberofvalues thatsatisfytheconditionforbranch btothetotalnumberofvalues inthedomainofconditionforbranch b.formally givenabranch b letdbdenotethecartesianproductofthedomainsofthevariables thatappearin b andlettb dbdenotethesetofvaluesforwhichbranchbevaluates to true.
let db and tb denote the number of elements in these sets respectively.
then s b tb db .
so the selectivity of a branch gets closer to as the number of values that satisfy the branch condition decreases and it gets closer to as the number of values that satisfy the branch condition increases.
if we think of branch as a sieve when s b branchbdoes not allow any value to pass and when s b branchballows all values to pass.
note that if we pick values from the domain drandomly with a uniform distribution then tb db corresponds to the probability of picking a value that satisfies the branch condition.
the branch becomes more selective as the probability of picking a value decreases.
an example.
consider the integer manipulating program in figure2.thisprogramisamodifiedversionofanexamplefromthe jpf regression directoryofthesv compbenchmarkusedforsoftwareverificationandtestingcompetitions .thetargetstatement istheassertionstatementinline19.the argvariable svalueisa randomlygenerated integervalueand itdenotesthe inputtothis program.
the question we want to answer for this program is how likely it is to reach the assertion statement at line if we randomly generate values for the argvariable?
the first conditional statement at line ignores all the negative values.
at line possible values for zcan be any randomly generatedpositivevalue dividedby5 minus7.now theassertionatline is reachable when value of zis equal to .
the likelihood of the valueofzbeingequalto0islowiftheinputisarandomnumber generatedfromauniformdistribution.therefore theprobability of reaching the assert statement in this program is low.
our analysis uses branch selectivity based on model counting to successfully determine the reachability probability of the assert statement in this program.
we inspect each branch condition leading to the assertion to determine how selective the branch is i.e.
what ratio of input values satisfy the branch .
if we assume a domain of integer values then for the conditional statement arg branchselectivityiscalculatedashalfofthedomain.therefore the possiblevaluesreachingtheassertionisreducedtohalf.next for the next conditional statement z branch selectivity is close to .mostvaluessatisfythisconstraintandconversely only1value ofzsatisfiesitsnegation.theassertionliesontheelsebranchof this condition making it reachable only for one value of z. using the branch selectivity values computed at these branches weconvertthecontrolflowgraphoftheprogramtoadiscretetime markov chain as shown in figure 4c.
we use a probabilistic model checker to analyze the markov chain and obtain a probabilistic 1708icse may pittsburgh pa usa seemanta saha mara downing tegan brennan and tevfik bultan measureforassertionreachability.fortherunningexample this reachability probability is computed as .
.32e .
the value .
arises from the branch selectivity for the branch condition arg and .32e 10arises from the branch selectivity for the branchcondition z .thereachabilityprobabilityoftheassertion statement is then reported as .16e hence this statement would be classified as a hard to reach statement by our analysis since it has a low reachability probability.
to assess the success of our analysis for this example we run a generatorbasedrandomfuzzerwithatimeoutof1hour.wefind that the fuzzer cannot generate an input to reach the assertion.
thefuzzergenerates 625inputsandnoneof themreachthe assertion which supports the result of our analysis.
sinceouranalysisdoesnotpreciselyrepresenttheoriginalsemanticsoftheprogram wecannotmakesoundnessclaimsabout theprobabilitycomputedbyourheuristic.ingeneralcase ouranalysis may over or under approximate the reachability probability.
byintegratingabstractinterpretationtechniquestoouranalysis we achieve better precision which we will discuss in section .
.
inthefollowingsectionswediscusshowwecomputeanduse branchselectivityvaluestogetherwithcontrolflow dependency analysisandabstractinterpretationtoextractadiscrete timemarkov chain and then use probabilistic model checking to compute approximations of reachability probability.
a probabilistic reachability heuristic we approximate p p t using a combination of control flow dependency analysis abstract interpretation model counting and probabilisticmodelchecking.first wediscusshowmodelcounting constraint solvers and abstract domains can be used to compute branch selectivity.
then we use control flow and dependency analysis and branch selectivity to transform the program s control flow graph into a markov chain.
we form queries on this markov chain solvable by probabilistic model checking whose solutions approximatep p t .i fp p t is less than a given threshold th target statementispredictedas hardtoreach .wediscussthesestepsbelow.
.
branch selectivity theenablingtechnologyforcomputingbranchselectivityismodel counting.modelcountingistheproblemofdeterminingthenumber of satisfying solutions to a set of constraints.
a model counting constraintsolverisatoolwhich givenaconstraintandabound returns the number of satisfying solutions to the constraint within thebound.forabranchcondition b recallthat s b tb db where dbis the cartesian product of the domains of the variables that appear in bandtbis the set of values in dbfor which bevaluates totrue.foragiven banddb amodel countingconstraintsolver computes tb .
then using tb we compute s b .
weusetheautomata basedmodelcounter abc tool whichis a constraintsolver forstringand numericconstraints withmodel countingcapabilities .theconstraintlanguageforabcsupports linear arithmetic constraints as well as typical string operations.
in order to compute s b we first extract the branch condition from the program and then generate a formula in the smt lib1public void test intx if x inty x if y assert false a using interval analysis1public void test intx intz intr inty r x z z x y if x z assert false b using relational analysis figure refined branch selectivity format that corresponds to the branch condition.
then we send the formula to abc as model counting query.
.
refined branch selectivity abstractinterpretationtechniquesoverapproximateprogrambehaviorsbyinterpretingprogramsoverabstractdomains.ourkey insight here is that it is possible to use abstract interpretation to refineandrestrictthesetofvaluesthatvariablescantakeateach branch in order to better approximate the branch selectivity.
given a branchb using abstract interpretation we generate a refinement condition rbtooverapproximatethesetofvaluesthatthevariables can take at that branch.
rbis then conjoined with tbanddbto compute refined branch selectivity rs b .
for a branch condition b refined branch selectivity is defined as rs b tb rb db rb .
to implement the refined branch selectivity we use state ofthe artjavanumericanalysistooljana whichsupportstwo differentabstractdomains intervals andpolyhedra where polyhedradomainleadstomorepreciseresultshoweveritisless scalable.weexperimentedwithbothofthesedomainstoextractthe refinementconditions rbforeachbranchusingintervalanalysis and relational using polyhedra domain analysis.
we call these implementations preach i and preach p respectively.
consider the two code snippets from fig.
3a and 3b.
at line in fig.
3a tbanddbarey andtruerespectively.
s b computedbypreachis0 .25predictingincorrectlythattheassertion isreachable.applyingeitherintervalorrelationalanalysis rbis extractedas y atline4 possiblereachablevaluesof xisgreater than and hence possible reachable values for yis less than due to the update on variable yat line .
tbanddbare updated as y y andy respectively using rbandrs b computed by preach is predicting correctly that the assertion is not reachable.
similarly at line in fig.
3b tbanddbarex zand truerespectively.
s b is computed as .
predicting incorrectly that the assertion is reachable.
applying an interval analysis there will be no refinement conditions as it is not possible to catch the relationbetweenthevariables xandzusingtheintervaldomain.
but applyingrelationalanalysisusingthepolyhedradomain rb is extracted as x z possible reachable values of zis equal to x .tbanddbare then updated as x z x zandx z respectively and rs b is computed as correctly predicting that the assertion is not reachable.
notethat forgeneralfunctioninvocationincludingrecursion it may be expensive to obtain precise interprocedural analysis reducing the effectiveness of refinement.
1709preach a heuristic for probabilistic reachability to identify hard to reach statements icse may pittsburgh pa usa duj a control flow graphduj b target statement subgraphduj h c markov chain construction figure4 targetstatementsubgraphextractionandmarkov chain construction for the running example .
target statement subgraph extraction thecontrolflowgraphofaprogramisarepresentationofallpaths thatmaybetraversedduringexecution.givenaprogram p atarget statement tinpand the input domain i we extract the control flowgraphof p g p andmarkthenodeofthecontrolflowgraph containing the target statement tas the node nt.
we expedite our analysis by extracting the target statement subgraph g p t ofg.g p t containsallthecontrolflowgraphinformationneededtoperformouranalysis.wedefinethissubgraph using standard concepts from control flow analysis.
we define a branchnode binacontrolflowgraphtobeanynodewithmorethan oneoutgoingedge.thecorresponding mergenode mofabranch nodebis its immediate post dominator.
the component cdefined bybis the union of branch node b its merge node mand all nodes of the control flow graph reachable from bwithout going through m. themaximal component of a node is the largest component containing that node.
any non maximal component containing this node will be contained in this maximal component.
to extract g p t we first find the maximal component of nt.i f ntis not contained in any component then ntmust lie on every path through g p .
therefore it is reached with certainty p p t andouranalysis canbeterminated.otherwise the maximal component of ntis themaximal statement subgraph .
g p t is a subgraph of the maximal statement subgraph.
to obtaing p t weremoveanycomponentofthemaximalstatement subgraph that does not contain the statement node nt.
the branch andmergenodesofthesecomponentsremaininthesubgraphwith oneoutgoingedgefromthebranchnodetothemergenode.
g p t results from this procedure.
figure shows the process of the target statement subgraph extraction on the running example from figure .
figure 4a gives the control flow graph g p with the statement node nthighlighted inred.figure4bshowsthetargetstatementsubgraph g p t extracted from g p .
in this example the branch corresponding to y 0isremovedfromthecontrolflowgraphstructure.thedecisionmadeatthisbranchdoesnotimpacttheprobabilityofreaching the target statement node.
note that the target statement subgraph extraction phase is a heuristic to s peed up our analysis.
the subsequent stages can beperformedontheentirecontrolflowgraphbutthiswouldresultin unnecessaryworkincludingextramodelcountingquerieswhich would slow down the analysis.
.
markov chain construction wedefineaweightforeachedgeof g p t .theseweightstransformg p t into a discrete time markov chain dtmc m p t .
a dtmc is a tuple s s p l wheresis a finite set of states s s is the initial state p s s is the transition probability matrix where summationtext.
s prime sp s s prime for alls s. each element p s s prime of the transition probability matrix gives the probability of making a transition from state sto states prime.
we use dependency analysis in the construction of the markov chainaswewanttoidentifythebranchesdependentoninputto set the weights of the edges accordingly.
dependencyanalysis.
abranchconditionisinputdependentif the evaluation of the condition depends on the value of the programinput.givenaprogramanditsmarkedinput weusestatic dependency analysis to identify the input dependent branches.
dependency analysis provides an over approximation of the set of branchconditionswhoseevaluationdependsontheinputs.weuse janalyzer an existing static analysis tool to perform the dependency analysis.
janalyzer is implemented on top of the wala program analysis framework.
then weconstructthemarkovchainbyassigningweightsto eachedge of g p t .g p t isa directedgraph each edgebegins at a source node sand ends at a destination node d. given an edge e s d ifeistheonlyedgebeginningat s theweightof eis1.
else sisabranchnodebydefinition.todetermineitsweightwe useacombinationofdependencyanalysisandbranchselectivity.
sincebis a branch node there is a branch condition associated.
if the branch condition is independent from the program input we weigh edge eas follows.
let ebe the number of edges originating at sandet ebe the number of edges originatingat swhichlieonapathtothetargetstatement nodent.i fet then the weight of eis e. otherwise if elies on a path to ntweight of eis et.i fedoes not lie on a path to nt weight of eis .
if thebranch condition is dependenton the program input we compute the weight of the edge eas follows.
we use a model countingconstraintsolvertodeterminethebranch selectivity of b s b .i feis the edge corresponding to the if condition the weight of eiss b .
else s b .
attheendofthisphase g p t hasbeentransformedintomarkov chainm p t wheretheprobabilityoftransitioningfromonestate to the next is given by the edge weight.
figure4cshows m p t fortherunningexample.thetransition probabilities are given as edge weights.
the two branch conditions yieldtheonlynon1edgeweightsinthegraph.bothofthesebranch conditions are input dependent as determined by the dependency analysis.foreachbranchcondition themodel countingconstraint solver abc was used to find its branch selectivity.
this selectivity wasused tocompute theweightof theedgecorresponding tothe ifbranchanditscomplementwasusedtocomputetheweightof the edge corresponding to the else branch.
note that the first order markov chains do not encode any context sensitivity thus branch probabilities e.g.
loop conditions 1710icse may pittsburgh pa usa seemanta saha mara downing tegan brennan and tevfik bultan would always result in the same selectivity measure regardless of the call site or iteration number.
.
pctl query formulation weautomaticallysynthesizequeriesover m p t whosesolutions yield an approximation of p p t .
the query we synthesize is what is the probability that the target node ntis reached at least once?
the answer to this query approximates p p t .
we use a probabilisticmodelcheckerprism atoolthatanalyzessystemsthat exhibitprobabilisticbehavior toanswerthisquery.wegenerate adiscretetimemarkovchain dtmc modelbasedonthesyntax supported by the prism tool.
we can synthesize queries like what is the probability of reaching a state in the markov chain eventually?
.
in prism a pctl formula is interpreted over the dtmc model.
two types offormulas are supported state formulas and pathformulaswherepathformulasoccuronlywhenthereisaprobabilistic measure that needs to be included in the specification.
for our analysis the queries we synthesize are path formulas and are of theform p p whichistheprobabilistic analogueofthepath quantifiers of ctl.
for example the pctl formula p ?
states what is the probability of reaching state .
the complexity of pctl query verification for dtmc is polynomial in the number of states .
since the number of states of the dtmc is linear in the size of the program overall complexity of pctl query verification is polynomial of program size.
loop analysis.
in analyzing programs which contain back edges either from loops or from recursion we consider two different queries for programs with loops.
whatistheprobabilitythattargetnode ntisreachedatleast once within a given loop bound?
whatistheprobabilitythattargetnode ntisreachedatleast once?
thefirstqueryenablesustomodelboundedloopexecutions.to answer this query we fix a loop bound and unroll any loops in the markovchain.ifthetargetnode ntisduplicatedduringthisloop unrolling process then the query becomes what is the probability that any target node ntis reached at least once?
oncetheloopsinthemarkovchainareunrolled thefirstquery becomestheinitialqueryontheunrolledmarkovchainexceptthat there might be multiple instances of the target node.
in answering the second query we leave the markov chain as is includinganybackedgesandgeneratethedtmcmodelforprism as it is.
prism calculates a steady state probability for unbounded loop scenario.
bounding the loop and asking the bounded version of the reachability query under approximates the unbounded case.
as the loop bound increases the solution for the bounded case approachesthatoftheunboundedcaseandinsomecasesitispossible toreachthesteadystateprobability i.e.
toreachafixpoint.note that in prism we are able to compute the steady state probability so it is not necessary to compute the fixpoint by increasing loop bounds.
this is one of the advantages of our approach over probabilistic symbolic execution.
implementation we have implemented our technique in a tool called preach probabilistic reachability analyzer targeting programs written in java programming language.
using the static analysis tool janalyzer we first extract the control flow graph from the given program.
after marking inputs for which we want to calculate reachability probability we use dependencyanalysisforthemarkedinputsandidentifyallinputdependent branches.
we identify the target statement node and dodominatorandpost dominatoranalysisinordertoextractthe target statement subgraph.
forcalculatingbranchselectivityofinput dependentbranches we first translate the branch conditions to smt lib format constraintsusingspoon andthenweuseabc formodelcounting.
to compute refined branch selectivity we applied two abstract domains interval and polyhedra using jana a numeric analysis tool for java.
we call these implementations as preach i and preach prespectively.wedefinethedomainsizeforintegersas signed bit for strings as length of with all printable ascii characters for char as unsigned bit integers.
once we get the model count from abc we calculate the branch selectivity.
to compute bounded reachability of a target statement we look for back edgesandifthereisone weunrollthelooptoacertainbound.
for unbounded cases we compute the steady state probability.
once we have all the branch selectivity values we construct the discrete time markov chain dtmc .
using the target statementnode weformulatethequeriestocalculatethereachability probability.
we use the probabilistic model checker prism for computingthetargetstatementreachabilityprobability.weconvert themarkovchaintoadtmcmodelinprismsyntaxandsynthesizequeries.then weexecuteprismtocomputetheprobability.
we use prism as it provides features to reduce the reachability checking of a statement in a program with unbounded loops to reachabilitycheckingofastateindtmc.ourcurrentimplementation determines reachability probability for each target statement separately.wecanextendourapproachtohandlereachabilityof multiple statements by synthesizing slightly more complex queries.
forcollectinggroundtruthvaluesof hardtoreach statements weruna generatorbasedrandomfuzzerforalltheprograms.we usejqf toolwhichisafeedbackdirectedfuzztestingplatform for java.
jqfincorporates coverage guidedfuzz testingtechnique zest .weusegenerator basedrandomfuzzingoptionprovided by zest.
we set a timeout of one hour and if the fuzzer fails to generateinputstoreachthetargetstatement wedeterminethat the target statement is hard to reach .
note that the preach approach can be extended to support alternativeconcretetestingtechniquesandthedefinitionof hard to reachstatements can be adapted accordingly.
for example for a randomtestingtoollikerandoop usedinthehybridtesting tool jdoop the definition of hard to reach can be changed by considering an input distribution that is different from uniform distribution by using different usage profiles .
experimental evaluation to evaluate preach we experimented on benchmark programs from the competition on software verification sv comp and 1711preach a heuristic for probabilistic reachability to identify hard to reach statements icse may pittsburgh pa usa thecompetitiononsoftwaretesting test comp whichwe callthesv compbenchmark.sofar test comphaveonlyused c programs from the sv comp benchmark.
among the benchmarksusedforjavainsv comp2021 weuse4modules jayhornrecursive jbmc regression jpf regression algorithms forevaluation.
we mark all the non deterministic inputs in the sv comp benchmarksasinputsforreachabilityanalysis.weusetheassert statements in these programs as target statements.
we use two criteriatoselecttheprogramsfromthesedirectoriesforourexperiments.weexcludeprogramsifoneofthefollowingtwoconditions hold targetstatementreachabilitydoesnotdependontheinputs preach is not applicable for these programs as it assesses reachability probability with respect to inputs.
verification tasks are specific to floating point arithmetic the model counting constraintsolver we use does notsupport constraints generated from such programs.
basedontheabovecriteria ourfinaldatasetconsistsofatotal of142programs.wemodifytheseprogramsinordertoallowus to run both our analysis and the generator based random fuzzer whilekeeping theprogram semanticsunchanged.
thesemodified programs are available at .
we run experiments on a virtual box equipped with an intel corei7 8750hcpuat2.20ghzand16gboframrunningubuntu linux18.
.3ltsandthejava8platformstandardedition version .
.0 232 from openjdk bit server vm.
.
results for the sv comp benchmark reachability probability computed by preach is a value between and .
in order to assess how good preach is to identify hard to reachstatements we classify program statements to two groups hard to reach andeasy to reach .
as ground truth we classify the programsforwhichtherandomfuzzerisunabletoreachthetarget statement within the given time bound as hard to reach .
we list the number of true positives tp ground truth is hard to reach and preach predicts hard to reach false positives fp ground truth is easytoreach andpreachpredicts hardtoreach truenegatives tn ground truth is easy to reach and preach predicts easy to reach false negatives fn ground truth is hard to reach and preach predictseasy to reach .
ahard to reach threshold th value .
meansstatementshavingreachabilityprobabilitylessthan0.05are classified as hard to reach .
then we evaluate preach with respect to the ground truth.
table1showstheoverallprecision recallandaccuracyresults of preach p.precision recallandaccuracyfordifferentimplementations of preach is shown in table .
we demonstrate results for multiplevaluesof thtoanalyzechangesinprecision recallandaccuracy across the benchmarks.
reducing thfrom .
to .
does notchangetheresultsatall.increasing thto0.1leadstointeresting changes in the results some of the true negative cases are updated tofalsepositives reducingprecisionandaccuracy.increasing th to .
changes the results further the number of false positive casesareincreasedandnumberoftruenegativecasesaredecreased.
increasing the value of thchanges the prediction of more cases fromeasy to reach tohard to reach and hence the overall precision is reduced from .
to .
and the overall accuracy is reducedfrom .
to .
.
the ability of using different threshold values demonstrates the quantitative nature of our analysis rather than being a fixed binary classification.
accuracyof preach psetting thas0.05or0.01is95.
.across allthebenchmarks accuracyisgreaterthanorequalto87.
reflectingtheeffectivenessofourheuristic.preach pfailstoidentify 5o ft h ehard to reach program statements having a recall of .
butitisverypreciseinidentifying hardtoreach programstatements with a precision of .
.
among cases only cases are false positives and cases arefalsenegatives.theremaining135casesarecorrectlyclassified bypreach.thereasonsbehindthe2falsepositivecasesandthe false negative cases are most of the input values generated by the fuzzer lead to exceptions and the fuzzer cannot generate enough valid inputs the numeric analysis tool cannot handle complexoperationssuchasmultiplication divisionandmodulus between more than one variables using the abstract domains.
experimental results show that among the variations of the tools preach p performs the best with a precision recall and accuracy of .
.
and .
respectively.
without applying refinedbranchselectivity preachcannotcatchtwoscenarios two dependent branch conditions cancel out each other input values are updated in a way that the branch condition becomes alwaystrueorfalse.hence thenumberoffalsenegativesincreases from5to13.preach iusesintervaldomainforrefinementanalysis which is not as precise as preach p using a plyhedra domain.
as a result extra false negatives are introduced by preach i. .
probabilistic symbolic execution pse weprovideanexperimentalcomparisonof preachwithprobabilistic symbolic execution pse .
we use spf as the symbolic execution engine for pse.
pse is unable to analyze some of the target programs due to unsupported constraints such as non linear path constraints preach does not face this issue as much since itonlyconsidersbranchconditions.therestoftheprogramsare markedasanalyzablebypse asshownintable2.forprograms wherethenumberofrecursivecallsorloopiterationsdependon theinput psecannotexploreallpossiblepathssinceitcanonly searchprogramsbehaviorsuptoaboundedexecutiondepth search depth and since the number of program paths grows exponentially.therefore wesetatimeoutof1hourforpseandevaluate fordifferentsearchdepths.sincepseisunabletocoverallprogram paths theprobabilisticmeasurementcomputedbypseisnotexact.
increasing the search depth allows pse to obtain more accurate resultsbutalsoincreasesthenumberofprogrampathsexponentially.
this leads pse to time out for some programs as shown in table2.thisisnotthecaseforthejpf regressionandjbmc regression benchmarks asthereisnoinputdependentrecursivecallsorloops.
we show the comparison of reachability probabilities computed by preach and pse in table .
as we do not have any ground truth for the probability measurement we calculate probability differences between these two techniques and analyze the differences in case of agreement and disagreement for hard to reach statementassessment.preachandpseagreeiftheirpredictions match disagree otherwise.
based on agreement and disagreement wedivideallthecasesinto3groups agreement disagreement 1712icse may pittsburgh pa usa seemanta saha mara downing tegan brennan and tevfik bultan table effectiveness of preach p in terms of precision recall and accuracy scores for sv comp benchmarks benchmarksthreshold th .
.
.
.
tp fp tn fn precision recall accuray tp fp tn fn precision recall accuracy tp fp tn fn precision recall accuracy jayhorn recursive .
.
.
.
.
.
.
.
.
jpf regression .
.
.
.
.
.
.
.
.
jbmc regression .
.
.
.
.
.
.
.
.
algorithms .
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
table2 numberofprogramsanalyzedbypreachandprobabilistic symbolic execution within hour timeout benchmarksnumber of programs analyzed preachprobabilistic symbolic execution analyzableanalyzable with search depth jayhorn recursive jpf regression jbmc regression algorithms total table probabilistic measurement differences and hard to reachstatementpredictiondisagreementsbetweenpreach pr and pse benchmarkssearch depth cases analyzabletoolagreement disgreement all cases average diff.pse checkpreach check avg.
diff.
avg.
diff.
avg.
diff.
jayhornrecursive10 21pr16 .
.
.
.
pr i16 .
.
.
.
pr p16 .
.
.
.
jpfregression 69pr58 .
.
.
.
pr i62 .
.
.
.
pr p64 .
.
.
.
jbmcregression 16pr14 .
.
.
pr i16 .
.
pr p16 .
.
algorithms 9pr3 .
.
.
pr i3 .
.
.
pr p .
.
.
and pse is correct disagreement and preach is correct.
the average difference in probability is low for the cases of agreement.
thedifferenceisevenlowerforjpf regressionandjbmc regression benchmarks as pse achieves very high precision and accuracy see table and preach agrees with the predictions.
for the cases ofdisagreement thedifferenceisveryhighformostofthecases whenpsepredictscorrectlybutpreachdoesnot.oneofthemain reasons for this is variable updates making some of the program pathsinfeasible.psecancatchtheinfeasiblepathswhereaspreach givesanapproximateresultforthesecasesusingbranchselectivity.
both preach i and preach p can address this issue.
using refined branch selectivity the number of agreement cases are increased and average probability difference is reduced for jpf regression andjbmc regressionbenchmarks.anotherreasonispreachpredicting aprogram statement as easy toreach but theground truth ishard to reach as fuzzer cannot reach the target statement due torecursionstackoverflowerror.averagedifferenceisalsohigh forjayhorn recursiveandalgorithmsbenchmarkswhenpreachpredictscorrectlybutpsedoesnot asthereisanexponentialincrease in the number of paths and pse poorly approximates the probability.
we now compare these two techniques in terms of hard to reach statementprediction accuracyandprecision.to compare preach andpse weset the hardto reach thresholdto0.
.
table4shows precision recall and accuracy for preach and pse with search depth and .
we evaluate all programs analyzable by preach.
the programs for which pse times out are marked as easy to reach as our target is to identify the hard to reach program statements.differentsearchdepthsdonotchangeresultsforjpfregression and jbmc regression benchmarks as these programs are freeofrecursivecallsandloopsthatdependoninputs.theprecision and accuracy values for preach are comparable to pse for these benchmarks.
the prediction results are improved a lot using preach iandpreach p.forjpf regressionandjbmc regression benchmarks precision recallandaccuracyareincreased.forjbmcregression benchmarks both preach i and preach p performs betterthanpseandforjpf regressionbenchmarks overallscores achieved by preach p are better than preach i and very close to the scores achieved by pse.
for jayhorn recursive and algorithmsbenchmarks psecannotachieveasgoodresultsaspreach preach i or preach p since these programs need to deal with inputdependent recursivecallsand loops.forlower searchdepth pse can not explore all the program paths and as a result thecomputedprobabilityisanunder approximation worsethan a heuristics based approach used in preach .
for higher search depth most of the programs time out and hence are marked aseasytoreach .asaresulttherearenotrue positivecasesmaking precisionandrecallvalues0aswellasnofalse positivecaseskeepingthetotalprecisionhigh .
.forthealgorithmsbenchmark even with search depth the precision and recall is as pse can notsupportmostoftheprograms markedas easytoreach asarraysizeisinputdependentand marked assymbolic whichisnot analyzableby spf.though forprogramswith boundedexecution depth due to the absence of loop and recursion jpf regression and jbmc regressionbenchmarks pseperformsbetterthanpreach but preach p is as good as or even better in some cases than pse.
weshowprecisionandaccuracyforthe85programsinthesetwo benchmarksthatareanalyzablebypseintable5.thescoresfor pse are not due to situations like integer arithmetic overflow thatarenotcaughtbysymbolicexecution.theprecision .
and accuracy .
for preach is comparable to pse and is impressive giventhatitisascalableheuristicapproach.theprecision .
andaccuracy .
bypreach pisveryclosetothescoresachieved by pse.
moreover pse performs very poorly on programs with unbounded execution depth jayhorn recursive and algorithms 1713preach a heuristic for probabilistic reachability to identify hard to reach statements icse may pittsburgh pa usa benchmarks whereas preach preach i and preach p have high precision and accuracy.
table6showstheaverageanalysistimerequiredandpercentage ofcasesanalyzedbybothofthesetechniques.evenforalowsearch depth the analysis time of pse is higher than preach.
note that lowersearchdepthsinpsepoorlyapproximatetheprobability.
however increasingthesearchdepthincreasestheanalysistime byordersofmagnitude.forbothjayhorn recursiveandalgorithms benchmarks the average analysis time increases and percentage of analyzed cases within the time bound decreases as the search depth is increased.
for the jayhorn recursive benchmark even for a search depth of the average analysis time increases by an order of magnitude.
this is because the number of recursive functioncallsareinputdependent.theaverageanalysistimeshown in the table is less than or equal to seconds since we set thetimeoutto1hour i.e.
3600secondsisthemaximumanalysis time .
the time for jayhorn recursive benchmarks with search depth greater than or equal to would be very high without this timeout.
average analysis time also increases for the algorithms benchmarks when the search depth is increased as number of loop iterations depend on the inputs.
these results show that pse is not scalable for unbounded execution depth whereas preach is.
preach iandpreach prequiremoreanalysistimecompared to pse for jpf regression and jbmc regression benchmarks.
as programsinthesebenchmarksareloopandrecursionfree pseruns fast whereas preach i and preach p perform abstract interpretation for branch selectivity refinement.
h owever as the search depth of the programs increases the branch selectivity refinement analysis time becomes less significant compared to the exponential time increase due to path constraint solving performed by pse reflected in the jayhorn recursive and algorithms benchmarks.
for thesebenchmarks asthesearchdepthincreasesto100 theanalysis timebypseisordersofmagnitudehigherthantheanalysistime requiredbypreach iorpreach p.theseresultsclearlyindicate thatpreach preach iandpreach pmaintainabalancedtradeoff betweenprecisionandscalabilityforprobabilisticreachabilityanalysis and amongthese three implementations preach p performs the best considering its high precision and accuracy.
.
statistical symbolic execution sse inthissection weprovideanexperimentalcomparisonof preachp with statistical symbolic execution sse .
prior work has demonstratedthatsseismorepreciseandfasterthanpsewhenlargeexecutionboundsarenecessary preventingpsefromterminating .
sse uses spf as the symbolic execution engine similar to pse.
we compare preach p and sse only for the jayhorn recursive and algorithmsbenchmarks fromsv comp as pse achievesvery highprecisionandaccuracyforjpf regressionandjbmc regression benchmarks and we have already compared the performance of preach p and pse on those benchmarks.
sse is unable to analyze out of target programs due to inabilitytohandlenon linearpathconstraintsorsymbolicarray indexing during symbolic execution.
as before we set a timeout of 1hourforsseandevaluatefordifferentsearchdepths.likepse sse is also unable to explore all program paths within an hour but it can provide statistical guarantees for the computed probabilitieswith respect to accuracy and confidence parameters .
sse has two different sampling approaches monte carlo and informed sampling.
we compare preach p to both of these sampling techniques in sse.
in both cases we set to be 5and target to be .
following the experimental setup in .
for monte carlo sampling we set the maximum sample size n1 a s 000andforinformedsampling weset n1as100andmaximum number of iterations as .
precision recall and accuracy for sse is presented in table .
sse has better precision recall and accuracy compared to pse but notcomparedtopreach p.recallandaccuracyforssedropswith increasing search depth.
for algorithms precision and recall is .
markedwitha astherewerenotruepositivecasesamongthe analyzable programs by sse.
similar to the experimental setup for the comparison to pse we mark a program statement as easy to reachif it times out.
we do not take the reported statistical confidence into account to determine which program statements should be marked as hard toreachoreasytoreach bysse.onecoulduseathresholdvaluefor thestatisticalconfidence andacceptonlythepredictionsachieving a certain confidence.
in that case the precision and accuracy of sse would drop further.
instead we present average confidence achieved by sse in table separately.
statistical confidence achievedby sse drops asthe search depthfor symbolicexecution is increased and more programs time out.
even though we set a large maximum number of samples for monte carlo sampling sse can not achieve a high confidence.
on the other hand informedsamplingcanachievehighconfidencewithsearchdepths 10or100forsomecases.but withaninfinitesearchdepth none of the sampling techniques can achieve high confidence.
averageanalysistimeforsseispresentedintable8.ingeneral preach p is orders of magnitude faster than sse.
monte carlo samplingisconsistentlyslowerforalltheprogramscomparedto preach p.informedsamplingperformsmuchbetterthanmonte carlo sampling.
analysis time of sse with informed sampling is closetopreach pforsomeprogramswhenashortsearchdepth value is used.
but irrespective of search depth for a good number ofprograms informedsamplingisalsoordersofmagnitudeslower than preach p and hence its average analysis time is significantly higher than preach.
these results demonstrate that preach p is more scalable compared to sse and achieves better precision and accuracy especially for programs containing large number of paths.
.
case studies inthissection weevaluatetheeffectivenessof preachtodetect hard to reach program statements in larger projects.
we are particularly interested in program points where inputs need to pass through numerous branches to reach.
we selected a set of methods fromapachecommonslang anddarpastacbenchmarks and identified target program statements.
we have analyzed programstatementsin12methodsfromapachecommonslang projectand12programstatementsfrom6methodsacross5projects from darpa stac benchmarks.
table shows preach results for the selected cases.
first werun psetocompute reachabilityprobabilityonall thesecases.
1714icse may pittsburgh pa usa seemanta saha mara downing tegan brennan and tevfik bultan table4 precision recallandaccuracyof preach pr andpse computedfor142programs programismarked easy to reach if analysis times out benchmarksprecision recall accuracy pr pr i pr ppse with search depth pr pr i pr ppse with search depth pr pr i pr ppse with search depth jayhorn recursive .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jpf regression .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jbmc regression .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
algorithms .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table precision recall and accuracy of pse and preach pr outof85programscomputedwithin1hourforjpf and jbmc regression benchmarks benchmarksprecision recall accuracy pr pr i pr p pse pr pr i pr p pse pr pr i pr p pse jpf regression .
.
.
.
.
.
.
.
.
.
.
.
jbmc regression .
.
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
.
.
.
table average analysis time for preach pr and pse maximum average analysis time is limited to seconds cases with timeout are included benchmarksaverage analysis time in seconds cases analyzed in hour prpr ipr pprobabilistic symbolic execution search depth jayhornrecusrive2.
.
.
.
.
.
.
jpfregression0.
.
.
.
.
.
.
jbmcregression0.
.
.
.
.
.
.
algorithms .
.
.
.
.
.
.
total .
.
.
.
.
.
.
among methods we analyze we find that pse is not able to handle methods due to either variable type conversion or lack ofsupportforsomestringlibraryfunctions.
psefailson2other methods due to incapability to model count for non linear path constraints and another methods due to lack of support for translationofexpressionstostringpathconstraints.preachdoesnot haveanyoftheseissuesastheunderlyingtechniqueissimplerthan symbolically executing a program and it can avoid dealing with non linear path constraints and complex string path constraints as it needs to consider individual branch conditions only.
finally pse successfully runs on methods but for of the methods it times out predicting only case correctly as hard to reach .
these results demonstrate the limitations and poor scalability of probabilistic symbolic execution on realistic programs.
we also cannot analyze these cases using preach i and preach p as the programs perform string operations and the abstract interpretation tool w e use for computing refined branch selectivity is limited to numeric analysis.evenwithoutrefiningthebranchselectivity ourresults for these case studies demonstrate that even the base technique preach usingbranchselectivityiscapableofpredicting hardto reachprogram statements efficiently for sizable programs.preachcanpredict19outof24casescorrectlywithanaccuracy of79.
setting thas0.
.weusedthesamevalueof thacrossall domains.differentvaluesof thforinteger mixeddomain .
and string domain .
increases the accuracy to .
supporting the quantitative nature of our analysis.
of the cases that preach can not predict correctly is due to the similar reasons as sv comp benchmarks.
the value of the input is updated inside the program and as a result the following branches do not depend on the initial input value anymore.
related work therehasbeenanincreasingamountofresearchonquantitative programanalysistechniquesbasedonmodelcountingconstraint solvers andtherehasbeenasurgeofprogressinmodelcounting constraint solvers .
model counting constraint solvers have been used in a variety of quantitative program analysistaskssuchasprobabilisticanalysis reliabilityanalysis estimating performance distribution quantitative information flow and side channel attack synthesis .branchselectivityandprobabilisticreachability heuristic we introduce in this paper are fundamental quantitative program analysis techniques and rely on the recent developments in model counting constraint solvers.
probabilistic symbolic execution and statistical symbolic execution can be used for probabilistic reachability analysis problem we study in this paper .
however pr obabilistic symbolic executionsuffersfrompathexplosion andincreasingsizeof pathconstraintswithincreasingexecutiondepth whichcanleadto double exponential blow up.
moreover probabilistic symbolic execution can only analyze program behaviors up to a fixed execution depth.
statistical symbolic execution is more efficient compared to probabilistic symbolic execution but still suffers with increasing executiondepth.
the approach wepresent in thispaper using branch selectivity addresses these issues since it does not suffer frompathexplosionanditanalyzesbranchconditionsinsteadof path constraints modeling behaviors of arbitrarily long paths.
hybridtestingtechniques combineconcrete andsymbolictechniquesinordertoimproveeffectivenessoftesting.
strategy function for hybrid testing need to decide when to apply concrete techniques and when to apply symbolic.
existing techniquesassessthedifficultyofconcretetestingtodomakethe decisionbasedonthesaturationofrandomtesting orusing apredefinedconfigurationoftimetorunforconcreteandsymbolic techniques or probabilistic program analysis .
markov decision process construction extracting control flow graph and 1715preach a heuristic for probabilistic reachability to identify hard to reach statements icse may pittsburgh pa usa table precision recall and accuracy of preach p pr p and sse computed for programs from jayhorn recursive and algorithms benchmarks program is marked easy to reach if analysis times out hour both monte carlo and informed sampling has same precision recall and accuracy benchmarksprecision recall accuracy pr psse with search depthpr psse with search depthpr psse with search depth jayhorn recursive .
.
.
.
.
.
.
.
.
.
.
.
algorithms .
.
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
.
.
.
table8 averageanalysistimeandstatisticalconfidence forpreach p pr p andssemontecarlo mcs andinformed is sampling maximumaverageanalysistimeislimitedto3600seconds caseswithtimeoutareincluded confidenceissetto .
for timeout cases benchmarksaverage analysis time statistical confidence pr psse mcs with search depthsse is with search depthsse mcs with search depthsse is with search depth jayhorn recursive .
.
.
.
.
.
.
.
.
.
.
.
.
algorithms .
.
.
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
.
.
.
.
table case study of preach on apache commons lang and darpa stac benchmarks.
preach predicts a statement as hard to reach if reachability probability is less than .
.
out of cases are predicted correctly project class name method nametarget statement line numbernumber of branches in methodmax branches to target statementreachability probabilityrandom fuzzer ground truthpreach predictionprediction match apache commons langfraction greatestcommondivisor .
yes yes numberutilscreatenumber .
no yes iscreatable .
no no fastdateprinter parsetoken .
no no strtokenizer readwithquotes .
yes yes strsubstitutor substitute .
yes yes numericentityunescaper translate .
no yes arrayutils shift .
no yes booleanutils tobooleanobject .
yes yes randomstringutils random .
yes yes stringutils containsany .
yes yes charsequenceutils regionmatches .
yes yes calculator 3 romannumeralformatter parseobject130 .
no no .
no no .
yes no calculator 4arithmetizer assessparentheses21394 .
no no .
no no imperialformatter parseobject70 .
no no .
no no .
no no emu6502 assembler assembleline214229 .
no yes .
no no linear algebra platform matrixserializer readmatrixfromcsv .
no no rsa commander decinputstream read .
yes yes putting probabilities as edge weight has been used to find optimal strategyforconcolictesting .probabilisticpathprioritization is used in to decide when to invoke symbolic execution in hybrid fuzzing.
our approach focuses on identifying hard to reach statements based on probabilistic reachability heuristic.
conclusions wepresentedanovelheuristicforprobabilisticreachabilityanalysis to identify hard to reach program statements that uses dependency analysis model counting abstract interpretation and probabilisticmodelcheckingtocomputeprobabilityofreachingaprogram statementgivenrandominputs.weexperimentallyevaluatedour approachonasetofbenchmarkprogramsanddemonstratedthat our approach can identify statements that are hard to reach withreasonableprecisionandaccuracy.weprovideddetailedcomparisonofourapproachagainstprobabilisticsymbolicexecutionand statistical symbolic execution demonstrating that our approach is more efficient and scalable.
acknowledgement we would like to thank all the reviewers for their useful technical commentsandinsightfulsuggestionstowardsimprovingthispaper.