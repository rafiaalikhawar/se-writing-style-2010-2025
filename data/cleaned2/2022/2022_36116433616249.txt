nezha interpretablefine grained root causesanalysis for microservicesonmulti modal observability data guangba yu pengfeichen sun yat sen university chinayufeng li hongyangchen sun yat sen university chinaxiaoyun li zibin zheng sun yat sen university china abstract root cause analysis rca inlarge scale microservice systems is a critical and challenging task.
to understand and localize root causes of unexpected faults modern observability tools collect and preserve multi modalobservability data including metrics traces andlogs.sincesystemfaultsmaymanifestasanomaliesindifferent datasources existingrcaapproachesthatrelyonsingle modal data are constrained in the granularity and interpretability of root causes.inthisstudy wepresent nezha aninterpretableand f inegrainedrcaapproachthatpinpointsrootcausesatthecoderegion andresourcetypelevelbyincorporativeanalysisofmulti modal data.nezhatransforms heterogeneous multi modal data into a homogeneousevent representationand extracts event patterns by constructingandminingeventgraphs.thecoreideaof nezhais to compare event patterns in the fault free phase with those in the fault suffering phase to localize root causes in an interpretable way.
practical implementation and experimental evaluations on two microservice applications show that nezhaachieves a high top1 accuracy .
on average at the code region and resource typelevelandoutperformsstate of the artapproachesbyalarge margin.twoablationstudiesfurthercon f irmthecontributionsof incorporatingmulti modaldata.
ccs concepts softwareanditsengineering softwarereliability software performance cloudcomputing .
keywords rootcauseanalysis multi modalobservabilitydata microservice acmreference format guangbayu pengfeichen yufengli hongyangchen xiaoyunli andzibin zheng.
.nezha interpretablefine grainedrootcausesanalysisfor microservices on multi modal observability data.
in proceedings of the 31stacmjointeuropeansoftwareengineeringconferenceand symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa 13pages.https pengfeichen is the corresponding author permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forpro f itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe f irstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspeci f icpermission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
severity debug message request complete metric trace log root cause figure multi modal observability data i.e.
metrics traces and logs are used to localize f ine grained root causes e.g.
regions ofcodedefectsorresource types .
introduction microservice architecture decomposes an application into many smallpiecesofservices allowingdeveloperstomodifyandredeploy speci f icservicesratherthantheentireapplication .however interconnected services are deployed across multiple hosts and the number of services in production increases rapidly as the business develops.manyfactors e.g.
dynamiccontainerenvironmentand complex service invocations can affect the performance and availabilityofmicroservice applications leadingtomoreperformance andavailability issues .
tohelpsitereliabilityengineers sres betterunderstandthe performanceandavailabilityofapplications observabilityisproposed with a capability of comprehensive visibility into distributed applications .
theprimary dataused inobservabilityare metrics logs and traces which are referred to as multi modal observability data .
as shown in fig.
when a fault occurs sres typicallyneedtocombinecluesextractedfrommulti modalobservabilitydatatolocalizetherootcause whichisthemostfundamental reason for the fault .
manuallytroubleshootingrootcausesbasedonmulti modaldata is time consuming and error prone in complex microservice applications due to the explosion and heterogeneity of the observability data.
over the years many metrics based approaches trace based approaches and log basedapproaches havebeendevotedtoautomaticallylocalizerootcauses.however weidentifythreeprimary limitationsofexisting root cause analysis rca approaches.
insufficient exploitation on multi modal data.
most of the state of the art rca approaches only use single modaldatatopinpointrootcauses.sincesystemfailures may manifest as anomalies in different modal data adopting single modal data could lose key rca clues and thus impact the accuracyofrca approaches details in .
.
coarse grained root causes.
existing single modal studies mainly localize the root causes of microservice applications esec fse december3 san francisco ca usa guangba yu pengfei chen yufeng li hongyangchen xiaoyun li andzibin zheng at the service level .
such coarse grained rootcausesrequiresrestomanuallytroubleshootthetrueroot causes e.g.
speci f ic code region or resource type of the faulty services whichdelays the failure recovery process.
weak interpretability of root causes.
existing rca techniquesplaceinsufficientemphasisontheinterpretabilityofroot causes which is crucial for sres to fully understand the underlying issues.
for example pdiagnose takes multi modal data as input by transforming heterogeneous logs and traces into time series.
however this approach sacri f icesthe detailed executioncontextofrequests e.g.
logcontentsandtracepaths .
asaresult itfailstoprovidedetailedexplanationsregarding where andwhy the faultyrequests occurred.
nezhaapproach.
to overcomethe abovelimitations we proposenezha which is a protection deity with multiple arms in chinese mythology an interpretable and f ine grained rca framework by incorporative analysis of multi modal data.
when anomaly detector .
detects an anomaly on front end service requests data integrator .
takes heterogeneous metrics traces and logs from the fault free construction and fault suffering productionphaseasinputsandtransformsthemintothehomogeneous event representation.
events in the same service instance are then ordered according to their timestamps and event groups across service instances are connected according to span ids to construct event graphs while overcoming clock synchronization problems.
pattern miner .
then extracts the common execution patterns ofthe applicationfrom the eventgraphs.
after transforming multi modal data into events i.e.
excluding speci f ic request parameters the event patterns in the construction phasearesimilartothoseintheproductionphase.duringthefaultsuffering phase faults manifest themselves in one or more data sources which causes some event patterns to deviate from their expected execution paths.
therefore the critical problem of nezha istoidentify whicheventpatternsdeviatefromexpectedexecution paths and howthesepatternschange intheactualfault suffering phase.
to localize such faulty event patterns expected pattern ranker .
.
isproposedtosolvetheproblem bypinpointing excepted patterns that frequentlyoccur in the fault free phase but rarelyhappeninthefault sufferingphase.thefaultyeventpatterns re f lect whichcode regionsor resources type are culprits whichis more f ine grainedthantheexistingrcaapproachesofpinpointing faultsat the service level solution oflimitation2 .
actualpatternranker .
.
isusedtosolveproblem bylocatingtheactualpatternsthatfrequentlyoccurinthefault suffering phase but rarely happen in the fault free phase.
such newly emerging patterns in the fault suffering phase facilitate sres to understand faults.
eventually pattern aggregator .
correlates expected patterns with actual patterns and takes pattern pairs as rootcausecandidates.
nezhaoutputsactionablerootcauseswith highinterpretabilitybycomparingexpectedpatternswithactual patterns solution oflimitation3 .
we conductedextensivestudiestoevaluate nezhaon twopopular microservice applications namely trainticket and onlineboutique .
bene f iting fromtheuseofmulti modal observabilitydata nezhaachievesahightop 1accuracy .
andsurpassesallcomparedapproachesbyalargemargin .
.
whenidentifyingrootcausesattheservicelevel.whenidentifying rootcausesattheinner servicelevel i.e.
coderegionorresource type nezhaoutperformsadvancedbaselinesby .
.
in a high top accuracy.
moreover two ablation studies further con f irmthe contributionof incorporatingmulti modal data.
contributions.
this study makes the following contributions weintroduceanovelapproachtorepresentheterogeneousmultimodal observability data i.e.
metrics traces and logs in a uni f ied homogeneous event format.
this representation enables the construction of eventgraphs and facilitatesthe future integrated analysisacrossmulti modal observability data.
wepresent nezha aninterpretableand f ine grainedmicroservice rca approach.
nezhais a statistical method to localize more granular and actionable root causes i.e.
code region or resource type with high interpretability which facilitates sres to take mitigationactions incon f idence.
weimplementtheprototypeof nezha andconductextensive experimentsontwowidely usedmicroserviceapplicationstovalidate the effectiveness and efficiency of nezha.
the results show thatnezhaoutperformsthestate of the artrca approaches at both service andinner service level.
weenhancetheobservabilityoftwowidely usedmicroservice applications onlineboutique and trainticket and open source them at and which will facilitate the future anomaly detection andrca research onmulti modal data.
backgroundand motivation .
background observability.
observabilityisameasureofhowwelltheinternal statesofasystemcanbeinferredfromknowledgeofitsexternal outputs .it hasbeenincreasinglyapplied tomicroservicesbecause cloud native environments become more and more complex and the potential root causes of faults become more challenging topinpoint.observabilitytypicallyusesthreetypesoftelemetry data metrics traces and logs to provide deep visibility into distributed systems.
observability allows sres to monitor systems moreeffectively helpingthemidentifyandconnecttheeffectsin complex chains andtrace themback to their causes.
metric.metrics are numerical values that describe the status of the microservices and infrastructure over a period of time.
metrics can be further classi f ied as system level metrics and applicationlevel metrics .
system levelmetrics suchas memory andcpu usage are immediate concerns whenever sres identify a performance degradation.
sres can identify issues caused by insufficient resourcesbyanalyzingsystem levelmetrics.however system level metrics cannothelpsolve problems causedbycode defects.
application level metrics e.g.
request latency orsuccessratio arederivedfrommonitoringrequeststodescribetheapplication status.
such metrics typically re f lect the faults surface rather than rootcausesoffaults.forexample adecreaseinsuccessratere f lects a decrease in availability and sres need to further analyze systemlevel metrics traces and logs to identify the root cause.
therefore we analyze application level metrics when performing anomaly detection andfocusonsystem level metrics inrca.
log.logs are textual records of what operations are performed duringprogram runtime.alog consistsofatimestamp thattells 554nezha interpretablefine grainedroot causes analysis formicroservicesonmulti modalobservabilitydata esec fse december3 san francisco ca usa front serve pd.
serve pd.
serve pd.
req.
failproduct query pd.
ab5 query pd.
ef2 query pd.
err query pd.
hg8product traid 12df info query pd.
ab5 traid 14bj info query pd.
ef2 traid 12df err query pd.
err traid 249e info query pd.
hg8front traid 12df info serve pd.
traid 14bj info serve pd.
traid 249e info serve pd.
traid 12df err req.
failfront recv.
recommend listrecommend product listproduct log6log5 log4 log3log2log1 traceid time loglevel logcontext a before integrating logs and traces b integrating logs and traces c after integrating logs and traces figure2 anexampleofintegrationwithtracesandlogs.
a srescannotdistinguishwhichrequestthefailedlogsbelongto.
b the contentsofthelogs after integration.
c sres can track logs belongingto eachrequest after integration.
when it occurred with a static structure and free form text.
the logtemplateistheconstantpartofalogstatementinthecode .
althoughlogsprovidevaluableinformationabouttheindividual serviceinstance thislocalizedknowledgelacksassociationsoflogs for the same request across different services.
analysis logs on differentservicesindependentlycannotcharacterizethebehavior ofthe overallsystem.
trace.tracesrepresenttheend to endpathsofrequeststhrough adistributed system.asa requestmoves throughasystem every operation performed is called a span which records the caller service the callee service and the operation time.
each trace corresponds to a request and has a unique identi f ier e.g.
trace id .
a span is a named and timed operation that shares the same trace idwithinthesametrace.eachspanalsohasauniquespanidto signify it.
the root span e.g.
front recv.
in fig.
b is the f irst spaninatrace whiletheotherspansarecorrelatedbyparent child relationships based on the parent span id properties e.g.
front recv.istheparentof recommend listrecommend infig.
b .the contributionoftracesislimitedinrcabecausetheyonlyrecord the coarse grainedservice operation level information.
.
motivation thissectionpresentsfourmotivationswithexamplesfromawidelyused microservice application onlineboutique .
details on the applicationanddata collection willbe describedin .
.
motivation1 enhancingrcathroughlogandtraceintegration.
logs serve asavaluable resource tocapture the internal states and behaviors of individual microservices.
however analyzinglogsforeachmicroserviceinisolationmayresultinalossof globalcontext leadingtoineffectiverca .foranefficientrca approach it is essential to combine logs from different microservices.
nonetheless as illustrated in fig.
a logs generated by a singlemicroservicecaninterleave asthemicroservicemayconcurrentlyservemultiplerequestsassociatedwithdistinctlogentries.
for a failed request existent rca approaches cannot determine whichlogsspreadingacrossmultipleservicesareassociatedwith the failedrequest to deduce the root cause.
traces capture global service interactions across various servers butofferlimitedinsightintolocalbehaviorswithinindividualspans.
to capitalize on the bene f its of both logs and traces we propose an integrationoftraces representingacoarse grainedglobalview and logs providinga f ine grainedlocalview tofurnishadetailedglobal perspectiveforeachrequest.asdepictedinfig.
b weaccomplish thisintegrationbyinsertingtraceidsintologmessages leveraging distributed tracing frameworks such as opentelemetry and skywalking .
inserting trace ids in log messages is a prevalent practice in numerous industrial systems e.g.
wechat andnormal phasecpu contentionerror returnnetwork jamtrace anomaly log anomaly system level metric anomaly time figure the occurrences of related system level metrics traces andlogs that can re f lect anomaly.
widelyadoptedframeworks e.g.
springcloud .byemployingthis approach when a request encounters a fault e.g.
the red line in fig.
c rcaapproachescantracktherequest leveldescriptive information e.g.
logs to effectivelyidentifythe root cause.
motivation enhancing rca through the integration of metrics logs andtraces.
while logsand tracesofferabundant clues for rca certain anomalies may not be apparent in these sources leadingtoapotentiallossofcriticalinformationpertaining torootcauses.fig.
3showsthreeexamplesoftheoccurrencesof system level metrics traces and logs that can re f lect anomalies whencpucontention error return andnetworkjamfaultswere injectedintotheonlineboutiqueproductservice.theanomaliesin metrics were identi f ied using the u1d458 u1d70erules with further details to bepresentedin .
.logsandtracespansthatexclusivelyoccur duringthefault sufferingphase butnotinthefault freephase are consideredabnormal.
as demonstrated in fig.
log and trace anomalies are absent whencpucontentionandnetworkjamfaultsareinjected because these faults do not alter the execution paths of onlineboutique.
inthesecases thelog basedortrace basedrcaapproachesmay miss the root causes.
fortunately system level metrics can provide valuableinsightstolocatefaultsthatremainundetectedinlogsand traces.forinstance anomaliesincpuusageweredetectedwhen cpucontentionfaultswereintroduced.however solelyrelyingon metrics based rca approaches may not identify faults that are not re f lected in metrics e.g.
error return fault in fig.
.
the examples infig.3underscorethenecessityofintegratingmetricswithlogs andtraces to effectivelyidentifyroot causes.
motivation enhancing rca through the integration of multi modal data in a uni f ied representation.
as highlighted in table1 a signi f icant portion of existing studies primarily focusesonsingle modaldataforrootcauseidenti f ication.sresare naturally inclined to merge the results of metrics based tracesbased and logs based methods to accurately pinpoint true root causes.
however this integration process can be labor intensive andineffectiveduetoseveralreasons.
whenindividuallyanalyzinglogs correlationbetweenlogsondifferentmachinesisnot achievable andasimilarissueariseswithmetrics.consequently single modal techniques are likely to produce less accurate results compared to multi modal approaches.
in situations where sres 555esec fse december3 san francisco ca usa guangba yu pengfei chen yufeng li hongyangchen xiaoyun li andzibin zheng table comparisonofstate of the artrca approaches.
approach metrics logstraces rca level microscope enc enc enc service microrca enc enc enc service sbld enc enc enc error log logfaultflagger enc enc enc error log microrank enc enc enc serviceoperation traceanomaly enc enc enc serviceoperation dejavu enc enc enc fault type cloudrca enc enc enc service pdiagnose enc enc enc 34resourcetype or error log nezha ours enc enc enc 34coderegion or resourcetype employ metrics based traces based and logs based approaches to determine root causes each method may propose a distinct root cause.there is currently no effective strategyto consolidate these outcomes or distinguish the true root cause among them.
as a result sres are compelled to manually verify each result one by one whichisalabor intensivetask.
independentlymanaging multiplesingle modalrcaapproachesnecessitatesincreasedeffort.
in light of these challenges we advocate for the integration of multi modal data intoa uni f iedrepresentation which will enhance the efficiency andaccuracyofrca.
motivation facilitating fault mitigationthrough unsupervised fine grained rca with enhanced interpretability.
dejavu andcloudrca aretwosupervisedmulti modal rcaapproachesthatnecessitateasubstantialtrainingdatasetwith labels.
however acquiring such a dataset can be costly and impractical for each application.
the multi modal method pdiagnose convertsheterogeneousmulti modaldataintotimeseriesandidenti f iesrootcausesbyevaluatingabnormaltimeseries.althoughthis transformationcanyieldeffectiveresults theprocessmayresult in a loss of execution context which is essential for developers tocomprehendtheunderlyingrootcause.preservingtheoriginal executioncontextenhancesinterpretabilityinrootcauseidenti f ication subsequentlyincreasingsres con f idenceintheobtained results.moreover localizingrootcausesattheservicelevelrequires amorecoarse grainedapproach.sresmustexpendconsiderable efforttodeterminethespeci f iccoderegionorresourceaccountable for faults.
from the sres perspective a f ine grained root cause identi f ication can alleviate their workload and reduce the mean timetomitigation.therefore wetrytoproposeanunsupervised f ine grained rca apparoach with improved interpretability which facilitates more effective faultmitigation.
.
problemformulation we formalize the problem of f ine grained root cause localization using multi modal observability data.
suppose that a large scale microservicesystemwith u1d441microservices metrics traces andlogs areaggregatedindividuallyateachmicroservice.ina slidingtime window e.g.
minute we have multi modal observability data de f inedas braceleftbig parenleftbig u1d703m u1d45b u1d703t u1d45b u1d703l u1d45b parenrightbig bracerightbig u1d441 u1d45b whereatthe u1d45b thmicroservice u1d703m u1d45b m1 ... m u1d45a indicates u1d45ametrics u1d703t u1d45b t1 ... t u1d461 denotes u1d461traces and u1d703l u1d45b l1 ... l uni2113 represents uni2113logs.given thedata ccollectedfromfault free constructionphase cand pcollectedfromfault sufferingproductionphase p we f irst unify the multi modal data in cand pas events and extract event patterns p u1d45d1 ... u1d45d u1d458 via constructing and miningeventgraphs.weattempttoidentify f ine grainedrootcauses throughthreephases weidentifywhicheventpatternsdonot follow expected execution paths and rank them into expected pattern list u1d43f u1d456 u1d460 u1d461e where u1d43f u1d456 u1d460 u1d461e ... u1d45d u1d456 u1d446 u1d450 u1d45c u1d45f u1d452e u1d45d u1d456 ... we pinpoint how expected patterns change in the actual fault suffering phase and rank them into actual pattern list u1d43f u1d456 u1d460 u1d461a where u1d43f u1d456 u1d460 u1d461a ... u1d45d u1d457 u1d446 u1d450 u1d45c u1d45f u1d452e u1d45d u1d457 ... we correlate expected patterns with actual patterns and takes pattern pairs as f inal root cause list u1d43f u1d456 u1d460 u1d461r ... u1d45d u1d456 u1d45d u1d457 u1d446 u1d450 u1d45c u1d45f u1d452e u1d45d u1d456 ... .
sres can check why u1d45d u1d456turn into u1d45d u1d457to determinethe f inal solution to recover applications.
overview in this study we present nezha an unsupervised f ine grained rca approachby incorporative analysis of multi modal data inaninterpretablemanner.figure 4showstheoverallstructureof nezha.the activitiesof nezhacanbedividedintothefault freeconstruction phaseandthe fault sufferingproduction phase.
inthe construction phase nezhatakesthefault free observabilitydataas input which contains all request types of the application within a time window.
obtainingashortwindowoffault freedataistrivialforsresbecausemostofthetimeisinnormalstatusandfaultsarescarcein production environment .
we recommend setting the window sizetothesameintervalasthemetriccollection 1minutebydefaultinthisstudy .
nezhaintegratestheseobservabilitydataand minestheirpatternsoffline.dataintegrationandpatternmining in the constructionphaseare the same asin the productionphase.
in the production phase anomaly detector .
detects whether the performance and availability of the system are abnormal in real time.
if an anomaly occurs data integrator .
uni f ies the multi modal data in the abnormal time window into events and consolidates the events into event graphs.
pattern miner .
extractscommonpatternsandcalculatessupportfor them from the event graphs in parallel.
expected ranker inpatternranker .
ranksthepatternsthatfrequentlyoccurinthe fault free phase but rarely in the fault suffering phase as the expectedpatterns.
actualranker ranksthepatternsthatfrequently occur in the fault suffering phase but rarely in the fault free phase astheactualpatterns.
patternaggregator .
aggregatesthe expected patterns and actual patterns to determine the ranked list ofrootcausecandidateswithinterpretability.comparedwithexistent rca approaches nezhaprovides f ine grained root cause candidates i.e.
region of code defect or resource type and tells sres why candidates are anomalous.
detailed design .
anomalydetector as described in .
nezhakeeps monitoring application level metricsofsystemstodetectanomalies.guaranteeingtheuserexperience which is typically re f lected in availability and performance is a critical requirement for cloud applications.
the availabilityof systemscanbere f lectedbytherequestsuccessratio whichisthe fraction of the number of successful requests to total requests over 556nezha interpretablefine grainedroot causes analysis formicroservicesonmulti modalobservabilitydata esec fse december3 san francisco ca usa data integrator log trace metric2 data integrator3 pattern minerconstrution phase fault free production phasepattern miner 1anomaly detector4 pattern ranker fault suffering patterns trigger graphsgraphs fault free patterns pattern aggregatorexpected patternspattern storerpatterns events graphsexpected ranker actual rankere1 e2e3 e4e5e6e7 e6 e1e7e3e4 e2e5e5e1e2 e1e2e5 e1e7 expected actual e1e3 e1e7 expected actual e3e6 e3e4 ......rank list actual patterns alert event log event span event figure the overview of nezha.nezhauses the multi modal observability data as input and outputs the ranked list of suspicious f ine grained root causes.
aperiodoftime.theperformance issuesmanifestthemselves as long time request duration.
to capture the tail latency we use p90 latency whichistheaveragelatencyfortheslowest10 ofrequests over a period of time.
compared to the average latency p90 can show the tail latency explicitly.
as aforementioned the success ratio and p90 latency delineate the system s health status.
we use time interval to denote how often the metrics are collected.
the time intervalvalueissetfor one minuteinthis study.
anomaly detector uses u1d458 u1d70erules to determine whether the target application isin an abnormal status.we calculate the mean u1d707and standard deviation u1d70eof success ratio and p90 latency in the construction phase.
in the production phase anomaly detector continuallymonitorsthesuccessratioandp90latencyoffront end serviceinaslidingtimewindow.ifthesuccessratioislessthan u1d707 u1d458 u1d70eorp90latencyisgreaterthan u1d707 u1d458 u1d70e u1d458 3bydefault anomaly detectordeclaresthecurrenttimewindowisabnormalandtriggers a root cause analysis.
u1d458 u1d70erule is a simple but effective approach and is widely used in academia and industry .
innezha thismodulecanbeeasilyreplacedwithotheranomalydetection approaches e.g.
usad rrcf andjumpstarter .
.
data integrator after anomaly detector determines whether the application is under abnormal status data integrator f irst queries pof the application in the abnormal time window.
considering the heterogeneity of observability data data integrator transforms the observability data in the time windows into events which is the basic unit of nezha.
theseevents in thesame service instance are then ordered according to their timestamps and span ids while overcomingclocksynchronizationproblems.eachrequestinthe time windowcorrespondsto an eventgraph.
.
.
uniqueevent generation.
definition event u1d452 .an event u1d452records theexecution status of a system at a point in time.
we use event set u1d438 u1d456 u1d4520 ... u1d452 u1d45b to denote theset ofall events forrequest u1d456.
metric.in eachtime window a service hasmany logs butonly one metric sample.
to overcome the heterogeneity between numericalmetricsandtext structuredlogs dataintegratorreplaces the set ofmetrics with suspiciousmetric alerts.
this isreasonable becauseanomalousmetricsthatcausealertsprovidemoreinformationtorcathannormalmetrics.metricsalertsaregeneratedwhen metricvaluesviolatethe u1d458 u1d70eruleorstaticthresholds.
nezhaisalso compatiblewithalarmsystemssuchasprometheus alertmanager.front recv product getproductfront recv start raw trace trace eventproduct getproduct start product getproduct end front recv endtransform figure transformation fromaraw trace to trace events.
front recv start request failedproduct listprod start product parseca start parse catalog failedgroup a front group e product front getcart endcart getcart asyn getcart with userstart list product group f productgroup c front group d cartfront getprod startgroup b front server span event client span event alert event log event cpu alertfront recv end front getcart startfront getprod end product listprod end product parseca endmem alert figure an example of event graph in onlineboutique.
all trace events andlogevents have the sametrace id.
thetimebetweenthestartandendofanalertiscalled alerttime .
wetreatalertsaseventsthatrepeatedlyoccurwithinthealerttime.
asdiscussedin .
application levelmetricstypicallyre f lect faults symptomsratherthantherootcausesoffaults.therefore we only consider the system level metrics in rca.
in addition we foundthatsomealertsfrequentlyoccurnomatterwhetherthere is a fault or not.
such regular alerts are not helpful to rca and sometimes even mislead sres.
to f ilter out these irrelevant metric alerts nezhaexcludesthealertsintheproductionphasethatalso occur inthe construction phase.
log.nezha f irst extracts and records the trace ids span ids detailshownin .
andtimestampsfromrawlogmessages.data integratoradoptsastate of the artlogparsingapproachdrain toextractthestaticlogtemplatesanddynamiclogparametersfrom the raw log messages in a streaming manner.
after log parsing wetreatthestaticlogtemplatesaslogevents.todistinguishthe log events associated with different requests each log event is accompaniedbyitscorrespondingtraceid spanid andtimestamp.
trace.the relation between parent and child span can be divided into synchronous and asynchronous calls.
with regard to synchronouscalls weconsiderthestartandendofaspanastwo traceevents.thesetwoeventmessagescanberepresentedasaconcatenationofthespannamewith start or end string.figure 557esec fse december3 san francisco ca usa guangba yu pengfei chen yufeng li hongyangchen xiaoyun li andzibin zheng shows an example of transforming traces with the synchronous call to trace events.
in terms of asynchronous calls data integrator representsthem aseventsconsisting ofspanname andthe asyn string e.g.
u1d452 cart getcart asyn .eachtraceeventisaccompaniedbyits trace id span id andtimestamp from span records.
.
.
event graphconstruction.
definition event graph u1d454 .an event graph u1d454 u1d456 u1d438 u1d456 u1d43f u1d456 u1d45b u1d458 isadirectedgraphofeventsintheeventset u1d438 u1d456.adirectedlinkbetween u1d452 u1d457and u1d452 u1d457 i.e.
u1d452 u1d457 u1d452 u1d457 denotesthat u1d452 u1d457isfollowedby u1d452 u1d457 1during theexecution.weuse u1d43acand u1d43apto denotethesetof event graphs fortheconstructionand production phase respectively.
foreachrequestinatimewindow dataintegratorconstructs an eventgraph inthe following three steps.
ordereventsinthesamespan.
foreachspan dataintegrator obtainsalllogandtraceeventswhichoccurredwithinthatspan.
dataintegratorthenchronologicallyordersthelogandtrace events into an event group based on their timestamps and adds asequencerelationshipfromaneventtoitsnexteventinthe group.fig.
6showssomeexamplesofeventgroups.
insertmetriceventstoeventgroups.
dataintegratorinserts the alert events after the f irst event of the event group if the correspondingservicehasalerteventswithoutlossofgenerality.
it can also be inserted in other f ixed locations as agreed.
if multiple alert events of the same service are detected all alarm events will be sequentially inserted after the f irst event.
for instance dataintegratorinserts mem alert andcpu alert of cartservice intoits eventgroup infig.
.
insert child groups to parent groups.
if the child span is in the same service instance as the parent span i.e.
internal function calls data integrator inserts child groups after the last event in parent groups whose timestamp is less than the f irsteventinthechildgroup e.g.
therelationbetweengroup e andfin fig.
.
we use timestamps directly because these two groups are on the same service instance and on the same node so they do not have the problem of clock drift.
for rpc call spansacrossservices dataintegratorinsertsthechildgroup afterthe f irsteventofitsparentgroupbasedontheparentspan idtoovercometheclockdrift e.g.
therelationbetweengroup bandeinfig.
.
after these steps we represent theheterogeneousmulti modal dataashomogeneouseventsandconstructtherelationshipsamong eventsasgraphs.thoughdeeptralog whichfocusesonanomaly detection rather than rca integrates logs and traces into graphs it does not consider metric clues.
nezhaovercomes the shortcoming of deeptralog by innovatively transforming metrics intoeventsandincorporatingthemintotheeventgraph.thereason whyweusegraphsratherthansequenceslikeminesweeper to represent the relationshipsbetween events is that microservice applicationsmaycontainasynchronouscalls.theeventlocation of asynchronous calls may change uncertainly in the sequential sequences making it difficult for nezhato mine for stable patterns.
compared with pdiagnose that transforms heterogeneous multi modaldataastimeseries nezharetainstheexecutioncontext of requestswhen transforming multi modal data as homogeneous events whichallowsfor improvedinterpretabilityinrca.e1e2e3e5 e1e2e3e5e1e2e3e5 e4req req req 1construction phase g c e1e2e6 e1e2e3e5e1e2e6 e4req req req 1production phase g p figure examples of event graphs inconstruction and productionphase.
u1d445 u1d452 u1d45e u1d456denotesthe u1d456thkindofrequest e.g.
login or query product .
the pattern u1d4522 u1d4523in u1d43acturned into u1d4522 u1d4526in u1d43apwhenafaultoccurred.
table example of nezhato perform rca fromfig.
.
patternsupport scoredeepth rank u1d446 u1d450 u1d45c u1d45f u1d452e u1d446c u1d446p u1d446 u1d450 u1d45c u1d45f u1d452e u1d446 u1d450 u1d45c u1d45f u1d452a u1d4521 u1d4522330.
.
u1d4522 u1d4523310.
.
u1d4522 u1d4524110.
.
u1d4523 u1d4525310.
.
u1d4522 u1d4526020.
meansthat thepattern is aggregatedby nezha.
.
pattern miner definition3 pattern u1d491 .apattern u1d491isasubgraphofcontiguous events in theset ofeventgraphs u1d43a.
after integrating multi modal data into event graphs nezha extractsthefault freeandfault sufferingpatternsfrom u1d43acand u1d43ap by traversing all event graphs in parallel.
the patterns in the event graphs are f inite because logs have been parsed into templates and onlythedirectlyconnectedeventsareconsidered.asanexample in the left part of fig.
a pattern u1d4521 u1d4522 u1d4523matches the event graphofthe f irstrequestbecausethegraphhas u1d4521followedby u1d4522 and u1d4522followedby u1d4523withoutothereventsinvolved.
definition support u1d460 .given a pattern u1d491 s count set u1d436 u1d491 u1d4501 ... u1d450 u1d458 where u1d450 u1d456denotes u1d491occurs u1d450 u1d456timesintheeventgraph u1d454 u1d456 thesupport u1d460 u1d491 ofpattern u1d491isthesumofthecountsinallgraphs i.e.
u1d460 u1d491 summationtext.
u1d458 u1d456 u1d450 u1d456.
u1d460c u1d491 and u1d460p u1d491 denote the support of u1d491in u1d43ac and u1d43ap respectively.
we use scandspto denote the support set of all patternsin the u1d43acand u1d43ap respectively.
after extracting patterns pattern miner counts the occurrences of each pattern to calculate the support of each pattern.
table showsanexampleofpatternminerminingpatternsandcalculating supportsinfig.
.intermsofpattern u1d4522 u1d4523 itoccursinallthree graphs in the construction phase.
therefore u1d460c u1d4522 u1d4523 3in the construction phase.
to prevent repeated calculations of sc wepersisttheresultsof scintopatternstorer .whendiagnosing faults weareinterestedinidentifyingtherootcausesthatresultin alargeportionof overallabnormalbehavior.
therefore wediscard thosepatternthatrarelyoccursby f ilteringpatternswhosesupport less than u1d460 u1d45a u1d456 u1d45b u1d460 u1d45a u1d456 u1d45b 5bydefault .
.
pattern ranker after transforming multi modal data as generalized events i.e.
excluding speci f ic request parameters the event patterns in the 558nezha interpretablefine grainedroot causes analysis formicroservicesonmulti modalobservabilitydata esec fse december3 san francisco ca usa construction phase are similar to those in the production phase.
during the fault suffering phase faults manifest themselves in one or more data sources which causes some event patterns to change.
inotherwords someeventpatternsdonotfollowtheirexpected execution paths in the fault free phase.
such patterns are likely to revealinsightsintoeventsassociatedwithrootcauses.forexample when a fault occurs between the code region of u1d4522and u1d4523in fig.
srescanchecktheevent graphsoneby oneandidentifythatthe pattern u1d4522 u1d4523in u1d43acturns into u1d4522 u1d4526in u1d43ap.
sres then take the code region between u1d4522and u1d4523as the root cause candidate and inspect the reason why u1d4522 u1d4523turns into u1d4522 u1d4526to determine the f inal solution.
we designed two rankers expected ranker and actual rankerto automate the above rca process.
.
.
expectedpa t ternranker.
expectedpatternrankeraimsto identifywhich event patterns do not follow expected execution paths andtakethemas expectedpatterns .thensrescancheckwhythese patterns do not follow expected execution paths to solve faults.
the core idea of expected ranker is to rank event patterns that occur multiple times in the fault free phase but rarelyin the faultsufferingphaseaboveothereventpatterns.arankingscore u1d446 u1d450 u1d45c u1d45f u1d452e is de f ined to measure how much utility each pattern contributes to root cause diagnosis.
for each pattern u1d491inc expected pattern rankercomputes its rankingscore u1d446 u1d450 u1d45c u1d45f u1d452e u1d491 as follows u1d446 u1d450 u1d45c u1d45f u1d452e u1d491 pr u1d454 u1d43ac u1d491 u1d454 u1d460c u1d491 u1d460p u1d491 u1d460c u1d491 .
the u1d446 u1d450 u1d45c u1d45f u1d452e u1d491 ofthe pattern u1d491quanti f ies howdistinctive u1d491isto the u1d43acas opposed to the u1d43ap.
if pattern u1d491occurs multiple times in u1d43acwhilerarelyin u1d43ap u1d491willbeassignedahigherscore.therefore the patterns with higher ranking scores are more suspicious to be rootcauses.asanexample anexceptionfaultoccursinthecode region of u1d4522and u1d4523in the production phase in fig.
.
from fig.
we can f ind that u1d4522is always followed by u1d4523in u1d43acbut rarely in u1d43ap.
thus it is intuitive to infer that there is a fault in the code region between u1d4522and u1d4523 causing u1d4522not to follow u1d4523.
in terms of pattern ranker it computes the ranking score of u1d4522 u1d4523as u1d446 u1d450 u1d45c u1d45f u1d452e u1d4522 u1d4523 .
which is the highest score i.e.
mostsuspicious inthe example.
.
.
actual pa t tern ranker.
though expected pattern ranker presentseventpatternsthatdonotfollowexpectedexecutionpaths sresalsoexpecttoknow howthesepatternschange intheactual fault sufferingphase whichwillfacilitatesrestounderstandfaults.
therefore actualpatternrankerisdesignedtopinpointthenewly emergingpatternsthatbreaktheirexpectedexecutionpathsand takethemas actualpatterns .thecoreideaofactualrankeristo rank event patterns that occur multiple times in the fault suffering phase but rarely in the fault free phase above other event patterns.
for each pattern u1d491inp actual pattern ranker de f ines its ranking score u1d446 u1d450 u1d45c u1d45f u1d452a u1d491 as follows u1d446 u1d450 u1d45c u1d45f u1d452a u1d491 pr u1d454 u1d43ap u1d491 u1d454 u1d460p u1d491 u1d460c u1d491 u1d460p u1d491 .
ranking list .
.
.
.
.
.8e1e2 e2e3 e2e4 e5e6 e6e7 e5e8e1e2e3 e4 e5e6 e8e7anomaly graph .8e1e2 .7e5e6 .6e5e8aggregated list figure example of constructing anomaly graphs to get an aggregated list inpatternaggregator.
nezhasearch... admin root cause analysis .
root cause service adservice excepted pattern adservice getads start adservice.java adservice.java actual pattern adservice getads start adservice.java adservice.java .
root cause service cartservice metric alert cpu usage monitor result root cause results anomaly time rca time figure ademoforinspecting root cause candidate.
actually not allpatternsinexpectedpattern rankerandactual patternrankerprovideusefulinformationforrootcausediagnoses.
for example the pattern u1d4521 u1d4522is given a score .
in fig.
.
but u1d4521 u1d4522occurs times in both u1d43acand u1d43ap which is hardly helpful for analyzing the underlying cause.
therefore we specify a minimumscorethreshold u1d446 u1d450 u1d45c u1d45f u1d452mintoexcludesuchuselesspatterns.
in this way the pattern u1d491is placed in the ranked score list only when u1d446 u1d450 u1d45c u1d45f u1d452e u1d491 u1d446 u1d450 u1d45c u1d45f u1d452min.
after excluding useless patterns we refer to the ranked pattern list output by expected pattern ranker astheexpectedpatternslistandtherankedpatternlist outputby actual pattern rankeras the actual patterns list.
.
pattern aggregator although expected ranker ranks patterns that point towards root causes itcansometimesreturnalonglistwhichisunfriendlyto sres.thisisbecausefaultsmaycausedownstreampatternsofroot causes in u1d43apto change resulting in all downstream patterns of root causes in u1d43achaving a high score as root causes.
for instance intheexampleinfig.
thepatterns u1d4522 u1d4523and u1d4523 u1d4525sharethe samescoreasoneexceptionfaultbetween u1d4522and u1d4523causesneither u1d4523nor u1d4525to occur in u1d43ap.
actually u1d4522 u1d4523and u1d4523 u1d4525point to thesamefault.checkingallpatternspointingtothesamefaultis unnecessaryandburdensomeforsres.inthisstudy werefertothe downstreampatternswiththesamescorelike u1d4523 u1d4525asredundant patterns.patternaggregatoraimstoexcludetheredundantpatterns ofexpectedrankertoprovideamorevaluablelistforsrestospeed uptroubleshooting.
patternaggregatorconstructsanomalygraphsbyassociating expectedpatternsand f ilteringredundantpatternsby retainingthe rootpatternsofgraphs.ifbothpatterns u1d452 u1d456 u1d452 u1d457and u1d452 u1d457 u1d452 u1d458arein the list and u1d446 u1d450 u1d45c u1d45f u1d452 u1d452 u1d456 u1d452 u1d457 u1d446 u1d450 u1d45c u1d45f u1d452 u1d452 u1d457 u1d452 u1d458 pattern aggregator will join u1d452 u1d458into u1d452 u1d456 u1d452 u1d457 i.e.
u1d452 u1d456 u1d452 u1d457 u1d452 u1d458 .
after iterating allpatternsinthelist patternaggregatorobtainssomeanomaly graphsconstructedfromthesepatterns.phase infig.8shows an example of constructing anomaly graphs.
pattern aggregator then chooses the root patterns of these anomaly graphs as f inal 559esec fse december3 san francisco ca usa guangba yu pengfei chen yufeng li hongyangchen xiaoyun li andzibin zheng expectedpatterns.phase infig.8showsthatthepatternnumber decreasedfrom 6to 3after excluding redundantpatterns.
to improve the interpretability of nezha we correlate the expectedpatterns withactual patterns to provide the complete fault scene.
for the expected pattern we identify its associated actual patternwiththecommonpre f ix.forinstance theexpectedpattern u1d4521 u1d4522 u1d4523hasthecommonpre f ix u1d4521 u1d4522astheactualpattern u1d4521 u1d4522 u1d4526infig.
.ifthereismorethanoneactualpatternwith thecommonpre f ix weselecttheactualpatternwiththehighest score as the actual pattern.
eventually nezhaoutputsarankedlistofrootcausescandidates tobechecked.candidatesarerankedindescendingorderbasedon thescoreofthecandidate sexpectedpattern.forexpectedpatterns with the same score we place the pattern with the deeper depth in the event graph further up the list because patterns with shallower depths are more likely to be causedbyanomalypropagations.
moreover weimplementademoof nezha shownasfig.
to demonstraterootcausescandidatesforsres.asshowninfig.
one pair of expected and actual patterns constitutes a root cause candidate.forcandidateswithoutmetricalertevents nezhashows the service name and the code region between events e.g.
1st candidateinfig.
.otherwise nezhadisplaysthemetricalertevent andcorrespondingmonitoringview e.g.
2ndcandidateinfig.
.
tosumup nezhaisabletoprovide f ine grainedandactionableroot cause candidates andtellssres why candidates are anomalous.
experimentalevaluation inthissecion weaimtoevaluate nezhatoanswerthefollowing researchquestions rqs rq1 howeffective is nezhainservice level rca?
rq2 howeffective is nezhaininner service level rca?
rq3 howmuchdoes multi modaldata contributeto rca?
.
experiment setup microserviceapplications.
wedeploytwoopen sourcemicroserviceapplications onlineboutique ob andtrainticket tt inour testbed.onlineboutiqueisamicroservicesystemfore commerce andtrainticketprovidesarailwayticketingservicewhereusers can check book and pay for train tickets.
both of them have been widely used in many previous studies .
the open sourced onlineboutique and trainticket are not equipped with adequate observability e.g.
traces are incomplete and logs do notcontaintraceid .inthisstudy we f irstinstrumenttheopentelemetry sdk for each service to obtain complete traces.
we then modify one line of logging pattern in the logging con f iguration of java service to insert trace and span ids into logs.
for services implemented in other languages we need to insert lines of code into the source code based on opentelemetry to obtain trace and span ids and modify the existent log statement foreachlog e.g.
fig.
.withthestandardopentelemetrytoolkit andexamplesinmanyprogramminglanguages itisnot difficult for developers to insert trace andspan ids intothe logs.
experimentalplatform.
wedeploytheonlineboutiqueand trainticket on a kubernetes platform with virtual machines each of which has a core .10ghz cpu 16gb memory and runs with ubuntu .
os.
we use opentelemetry collector tolog.
error req failed trace id trace 032x .format trace ctx .trace id span id span 016x .format span ctx .span id log.
error trace id s span id s req failed trace id span id source code modified code figure example ofcorrelation trace with logs.
collect traces and store them in grafana tempo .
logs are collected by grafana promtail and stored in grafana loki .
formetrics weusecadvisor tocollectsystem levelmetricsand istio tocollect application level metrics e.g.
requestlatency .
moreover prometheus node exporter on each node is used to export metrics to prometheus databaseto persist them.
data collection.
we use fault injection to mimic application issuesfollowingthepreviouswork .tomimic resource issues we inject cpu contention and network jam faults in the same way as the existing work .
mimicking code defectsatprogramruntimeischallengingbecausewecannotstopor restart services.
to achieve this we design some language speci f ic fault injectors for the characteristics of program language for java golang and python services .
we use the above injectors toinjecterrorreturnandexceptioncodedefectsfollowingprevious work .weseteachfaultdurationto3minutestoemulate theprocessbetweenfaultoccurrenceto f ix.werandomlyinjectone fault into one microservice following previous work .
in total weinject56faults 42resourceissuesand14codedefects into onlineboutiqueandobtaintracesandapplicationlogs.weinject45 faults resource issues and code defects into trainticket and gettracesandapplicationlogs.thecollectedmetricsencompass application level measurements e.g.
success ratio and systemlevel metrics e.g.
cpuusage rate .
evaluationmetric.
weusethe followingtwometricsto measuretheeffectivenessof nezhaandbaselinesbecausesomebaselinescan only localizeroot causes at the service level.
top k accuracy at service level u1d434 u1d446 u1d458 refers to the probability that root cause services are includedinthe top k results.
top kaccuracyatinner servicelevel u1d434 u1d43c u1d446 u1d458 referstothe probabilitythattheinner servicerootcauses resourcetypeor code region are includedinthe top k results.
implementationandsettings.
weimplementtheprototype ofnezhabuiltonpython3.
.allexperimentsareconductedona linux server with intel xeon gold 5318y .10ghz cpu gb ram 1tb ssd disk and running ubuntu .
.
the minimum score threshold u1d446 u1d450 u1d45c u1d45f u1d452min which is used to avoid the in f luence of normal f luctuations is setto .
i.e.
by default.
in this case a pattern u1d491inexpectedpatternrankerissuspiciousifthesupport of u1d491in fault suffering phase is less than half of the support of u1d491in fault free phase.the in f luence of u1d446 u1d450 u1d45c u1d45f u1d452minisdiscussedin .
.
.
.
baselines weusethefollowingsixstate of the artunsupervisedmetric based trace based andlog basedrcaapproachesasthebaselines.wedo not consider the supervisedapproaches because they need a large training dataset withlabels whichishardto obtain inpractice.
microscope isa metric basedrcaapproachthatidenti f ies rootcausesbasedonthecorrelationofmetricsalongdependency.
560nezha interpretablefine grainedroot causes analysis formicroservicesonmulti modalobservabilitydata esec fse december3 san francisco ca usa table comparisonofbaselines at service level.
approachonlineboutique trainticket u1d434 u1d446 u1d434 u1d446 u1d434 u1d446 u1d434 u1d446 u1d434 u1d446 u1d434 u1d446 microscope .
.
.
.
.
.
microrca .
.
.
.
.
.
sbld .
.
.
.
.
.
logfaultflagger .
.
.
.
.
.
microrank .
.
.
.
.
.
traceanomaly .
.
.
.
.
.
pdiagnose .
.
.
.
.
.
nezhaw oml14.
.
.
.
.
.
nezhaw om26.
.
.
.
.
.
nezhaw ol64.
.
.
.
.
.
nezha .
.
.
.
.
.
microrca presentsametric basedrcaapproachthatlocalizes suspicious services by applying a pagerank method onthe extractedanomalysub graph.
logfaultflagger is a log based rca approach that compares passingandfailinglogsto f ind faultsinfailinglogs.
sbld is a log based rca approach that analyzes the coverageoflogeventsusingspectrumalgorithms to f indsuspicious logevents.
microrank proposes a trace based rca approach that combinesthepersonalisedpagerankmethodandspectrummethod to locate suspiciousroot causes.
traceanomaly provides a trace based rca approach that adoptsadeeplearningmethodtolearnnormalpatternsoftraces offline anddetectanomaloustraces onlineto perform rca.
pdiagnose takesmetrics traces andlogsasinputandtransforms them into time series.
then pdiagnose determines root causes throughvotingabnormal time series.
.
evaluationresults .
.
rq1 effectiveness at service level.
the ground truths at the service level are the known injected services.
table 3shows the effectiveness evaluation results of different approaches at the service level.
from table we can observe that nezhaoutperforms all the baseline approaches signi f icantly and achieves high accuracy in u1d434 u1d446 u1d434 u1d446 u1d434 u1d446 onaverage illustrating that nezhacan successfully localize root causes at service level most of the time.
the excellent performance of nezhais mainly attributed to the fact that nezhatakes multi modal data as input and fuses them so that it can capture the abnormal behaviours of a wider range offaultsituations.
themetric basedapproachesmicroscopeandmicrorcaachieve low u1d434 u1d446 1and u1d434 u1d446 5onaverage.afteradetaileddissectionoftheir rca results we f indthat microscopeandmicrorcaare adeptat locating the root causes of resource issues but not good at code defects.
this is because microscope and microrca only take metrics into account but many code defects do not manifest themselves in metrics.
the accuracy of microscope is lower than microrca becausethedesignofmicroscopeneverplacesthefrontendservice as the root cause.
the two log basedapproaches i.e.
sbldand logfaultflagger obtain u1d434 u1d446 1and u1d434 u1d446 5lessthan30 .thesetwoapproachesdonot considermetrics.thus theymisstherootcausesoffaultscausedby resources because these faults would not change the log sequences.table comparisonofbaselines at inner service level approachonlineboutique trainticket ais ais ais ais ais ais sbld .
.
.
.
.
.
logfaultflagger .
.
.
.
.
.
pdiagnose .
.
.
.
.
.
nezhaw om26.
.
.
.
.
.
nezhaw ol64.
.
.
.
.
.
nezha .
.
.
.
.
.
the average u1d434 u1d446 5of two trace based approaches i.e.
microrank andtraceanomaly reachalmost50 and40 respectively.both approaches take traces as input and use the latency of spans to f ind root causes.
therefore they can only localize the faults that have signi f icant impacts on latency.
however the error return and exception faults do not manifest as anomalies in latency which results inlowaccuracyfor microrank andtraceanomaly.
multi modal approach pdiagnose achieves better accuracy than single modalbaselinesinonlineboutique.however theaccuracyof pdiagnose degrades dramatically from .
to .
at u1d434 u1d446 intrainticket.thepoorperformanceofpdiagnoseisattributed to two reasons.
pdiagnose transforms multi modal data as time seriesandlocalizesrootcausesbasedontheanomaloustimeseries.
however not all faults cause time series anomalies leading to missingsomerootcauses.
pdiagnoseperformsrcabasedon a simple voting mechanism that ignores the service dependency andanomalypropagation whichischallengingtogetconsensus intrainticket with41 microservices.
in conclusion nezhais effective inmicroservice root cause diagnosisattheservicelevelandimproves u1d434 u1d446 1by61.
.
and u1d434 u1d446 5by28.
.
onaveragecomparedtobaselines.
these results also validate our motivation to integrate multi modal data to facilitate root cause localizationin .
.
.
.
rq2 effectivenessatinner servicelevel.
thegroundtruthsat theinner servicelevelarethecoderegionorresourcetypeextracted from the fault injected operation.
we only compare nezhawith sbld logfaultflagger and pdiagnose because only these three baselineshavetheabilitytoidentifyrootcausesattheinner service level.
considering that the above three baselines are designed to pinpoint error logs rather than code regions their result would be determined to be correct if their output error logs are within the code regionofroot causes.
table4shows the effectiveness of different approaches at the inner service level.
nezhaperforms the best by taking all baselinesintoconsideration achieving u1d434 u1d43c u1d446 1of87 u1d434 u1d43c u1d446 3of97 and u1d434 u1d43c u1d446 5of on average.
with the incorporation of multimodal data while retaining execution contexts nezhacan localize root causes at the inner service level more accurately.
sbld and logfaultflaggerusethedifferencesinfrequencyandcoverageof logs to locate root causes.
resource faults do not cause a significant difference in frequency and coverage of logs so sbld and logfaultflaggercannotaccuratelyidentify theseroot causes.pdiagnose performs better than sbld and logfaultflagger because it considers valuable metrics and traces ignored by sbld and logfaultflagger.
however the performance of pdiagnose degrades dramatically in trainticket dataset because the voting mechanism of pdiagnose is difficult to get consensus in a system with many 561esec fse december3 san francisco ca usa guangba yu pengfei chen yufeng li hongyangchen xiaoyun li andzibin zheng rca time second event number minute ob tt figure changeofdiagnosis timewith eventnumber.
services.
to overcome the drawbacks of sbld logfaultflagger and pdiagnose nezhainserts metrics alert events into logs events so thatnezhacan handle both the code defects and resource faults whileretaining executioncontext.
to sum up the results demonstrate the effectiveness of nezha in localizing root causes at the inner service level and improves u1d434 u1d43c u1d446 1by67.
.
and u1d434 u1d43c u1d446 5by53.
.
on averagecomparedto baselines.
.
.
contribution of multi modal data.
we perform two ablation studies to explore the contribution of multi modal data so we derivethefollowingvariants nezhaw o mlthatdropsmetrics and logs nezha w o mthat drops metrics and nezha w o lthat drops logs.
the ablation study results on service and inner service levelareshownatthebottomoftable 3andtable respectively.
weobservethateachdatasourcecontributestotheeffectivenessof nezhabecausenezhawith allmulti modaldataperformsthebest.
in addition we observe that the contributions degrees of logs and metrics are not exactly the same in different datasets.
nezha w olis the second best in onlineboutique dataset while nezha w omperformsthesecond bestintrainticketdataset.webelieve this difference isdue to the distribution of fault types.
in the onlineboutique dataset there are more resource issues so nezha w o lperformsbetter.however inthetrainticketdataset thereare morecodedefects so nezhaw o mperformsbetter.though nezha w omlperformstheworst in ablation studies itdoesnot mean thatthecontributiondegreeoftracedataislowbecausetraceisthe core of linking logs of different services and building event graphs.
.
.
efficiency of nezha.
the diagnosis time of nezhais essential forachievingtimelyrca.itdependshighlyonthesizeofeventsin atimewindow.toevaluatethescalabilityof nezhawitheventsize weconductanexperimentonthechangesofdiagnosistimewith theincreaseofevents.thetimetocalculatefault freepatternsisnot includedinthediagnosistimebecausethepatternsinthefault free phase is calculated once and used multiple times.
fig.
11shows the diagnosistimeof nezhaunderthedifferenteventnumbersinatime window.
it can be seen that the diagnosis time increases linearly with the number of events.
in a time window of events onlineboutiqueandtraintickettake16secondsand30seconds to determine root causes respectively.
analysing trainticket data needslongerthanonlineboutiquebecausetraintickethasalarger number ofspans per traceand more complex dependencies.
thus nezhatakes longer to traverseallspans oftraces.
.
.
sensitivityofnezha.
theminimumscorethreshold u1d446 u1d450 u1d45c u1d45f u1d452min is one crucial factor that may impact the performance of nezha.
as stated in sec.
.
u1d446 u1d450 u1d45c u1d45f u1d452mincontrols the minimum score of patterns thatwillbe consideredasrootcauses.fig.
12showstheimpactof .
.
.
.
percent score min ob asi asi tt asi asi figure impactofminimumscore threshold u1d446 u1d450 u1d45c u1d45f u1d452min.
u1d446 u1d450 u1d45c u1d45f u1d452minon u1d434 u1d43c u1d446 1and u1d434 u1d43c u1d446 3ofnezhaon two datasets.
smaller u1d446 u1d450 u1d45c u1d45f u1d452minusually leads to lower accuracy as some event patterns withlowscorescausedbynormal f luctuationofthesystemaffect the f inal results.
according to fig.
u1d446 u1d450 u1d45c u1d45f u1d452min .67achieves the best accuracy in both two datasets.
the results also demonstrate thatnezhaexhibitslesssensitivityto u1d446 u1d450 u1d45c u1d45f u1d452minwhenitissetabove .
.notethatthebestcon f igurationof u1d446 u1d450 u1d45c u1d45f u1d452minhighlydependson the characteristics ofdatasets.
discussion .
limitationsandfuturework nezharelies on the anomaly detection approach triggers for rca thusitcannotidentifyrootcausesforfaultsthatescapeanomaly detection.futureworkcanintegratemorerobustanomalydetection algorithms e.g.
usad and monitor additional metrics beyond the p90 latency andsuccessratioto avoid missingfaults.
the applicability of nezhais limited to troubleshooting faults thatexhibitabnormalpatternsinmulti modaldata.somebyzantine faults such as returning an unreasonable result to the user cannot be identi f ied by nezhabecause these faults do not manifest themselves as any abnormal patterns.
troubleshooting for such byzantinefaultslike isthe future work to improve nezha.
thusifanon changefaultisnot f ilteredbyme wealsogenerate a suspicion list for sre to check which increases the checking burden on sre.
however sre believes that this false alarm burden is acceptable compared to a missed alarm.
in the future we will add more pluggable components to f ilter outnon changefaults as muchas possible.
.
threatsto validity the threats to the internal validity mainly lie in the fault free data collectionandminimumscorethreshold u1d446 u1d450 u1d45c u1d45f u1d452min whichcanintroduce bias on the effectiveness of nezha.
the accuracy of nezha canbeaffectediffault freedataisnoisyorlackscertaintypesof requests.
to mitigate this threat it is recommended to construct fault free data that includes a wide range of request types and has a similar number of requests to the production phase.
capturing workloads of systems and replaying these workloads is a common approachinthesoftwaretestphase.srescaneasilycollectsuch fault free data when replaying workloads.
even without replaying workloads collecting fault free data within a short time window is notdifficultastheproductionenvironmentispredominantlyina normalstatuswithlimitedfaults .
asthepatternofasimilar number of occurrences in the fault and fault free phases hardly provides a clue for rca the minimum score threshold u1d446 u1d450 u1d45c u1d45f u1d452min isusedtoexcludesuch uninformative patterns.we recommended setting u1d446 u1d450 u1d45c u1d45f u1d452minabove .
because a pattern u1d491is considered more 562nezha interpretablefine grainedroot causes analysis formicroservicesonmulti modalobservabilitydata esec fse december3 san francisco ca usa suspiciousifthesupportof u1d491infault sufferingphaseislessthan the support of u1d491infault free phase.
the external threat mainly comes from the microservice modi f ication and experimental environment.
the integration analysis ofnezhareliesontheinsertionoftraceidintologs whichmaynot be available in some practical systems.
however with the standard opentelemetrytoolkitand examples invarious programminglanguages itiseasyfordeveloperstoinserttraceandspanids intothelogs.forexample forjavaapplications weonlyneedto modifyonelineofloggingpatternintheloggingcon f iguration .
nezhais evaluated on two widely used microservice systems in akubernetes platform.itneeds further effort tovalidate the effectivenessof nezhainmorecomplexreal worldsystems.however it isreasonabletobelieve nezhacanworkinsuchasystemaccordingto currentresults.
thecomplexityof thesystems isalleviated by constructing datasets that include more than events for a single request and involves parallel and asynchronous service calls.
typically arequestinvolvingdozensofservicecallsinindustrial microservice systemscontains hundredsof log events .therefore theamountofeventsiscomparable.thecomplexityoffault scenariosisalleviatedbyinjectingresourceissuesandcodedefects from real faults in industrial systems into microservices.
thus the faultscenarios inour evaluation are representative.
related work metric based rca.
metric based rca approaches commonly diagnose problems by mining the relations between different metrics .causeinfer andmicroscope construct acausality graphusing thepc algorithm andidentify root causesbasedonthecorrelationofdifferentmetricsalongthecausal paths.
microrca f irst extracts an anomalous sub graph from anattributegraphincludingservicedependenciesandperformance metrics.apersonalisedpagerankmethodisthenusedontheanomalysub graphto locaterootcauses.microdiag f irstderives a metric causality graph bygrangercausalitytests.
then itweighs thecausalitygraphwiththepearsoncorrelationcoefficientbetween twometricsandrankstherootcauseswithpagerank.groot constructs the causality graph using monitoring events such as performance metrics deviation events and ranks the most probable rootcausesfromtheeventcausality graphbased onacustomized pagerankalgorithm.animportantdrawbackofmetrics basedrca approachesisthatanalyzingmetricsprovidesasuper f icialanalysis ofthesystem soperationsbutnotadissectionofhowthesystem isactually running.
log based rca.
most of log based rca methods localize root causes by comparing frequent patterns between logs of normal and abnormal phase .
sbld applies spectrum algorithms to the logging domain by abstracting logs into eventsandlocatingrootcausesbyanalyzingthecoverageofevents.
facebookproposesafastdimensionalanalysisframeworktolocate thefrequentitemsmostlikelytobetherootcausebyminingthe difference between the frequent item sets of normal and abnormal log .
logcluster uses log clustering to mine log sequences andcomparesproductionwithtestlogsequencesto f indpreviously unseen ones.
however current logs based rca approaches do not takeintoaccountthecontextualinformationofrequestsandcannot identifyfaultswhere logshave not changed.trace basedrca.
variousworkandtools havebeenproposedtogeneratetracesbyinstrumentingtracecode into the source code of applications.
the empirical study in shows that microservice debugging can be improved by employing proper tracing and visualization techniques and strategies.
but the studydoesnotprovideanautomaticrcaapproachbasedontraces.
gmta is a graph based trace analysis approach implemented anddeployedinebay.itabstractstracesintodifferentpathsandfurthergroupsthemintobusiness f lowsforarchitectureunderstanding andproblemdiagnosis.nevertheless suchaggregatedtraceanalysisapproachmaymaskasmallnumberofabnormaltracesthat are critical to root cause localization.
based on the insight that a microservice that is traversed by more abnormal and fewer normal traces is likely to be the root cause t rank proposes a lightweightperformancediagnostictoolbuiltonspectrumanalysis.
however iftwodifferentmicroserviceshavesimilarcoverageinformation t rank cannot distinguish between them.
microrank andtracerank combinepagerankandspectrumalgorithms to distinguish two different microservices with similar coverage.
nevertheless the root causes output by microrank and tracerank i.e.
service instance level or operation level are more coarse than nezha.
overall traces based rca approaches are limited by the granularity oftraces which ismostly attheoperation level rather thanthecoderegionlevel.moreover theabsenceofsystem level metricsalsomakestraces basedapproachesimpossibletospecify whether the faultsare causedbyresources.
conclusion in this study we present nezha an interpretableand f ine grained rcaapproachbasedonmulti modalobservabilitydata.
nezhauni f ies multi modal data as events within a single solution and mines event patterns by constructing event graphs.
nezhacorrelates and ranks event patterns by identifying which event patterns do not follow expected execution paths and how these patterns change in the fault suffering phase to localize root causes.
we have implemented a prototype of nezhaand conducted extensive evaluations on two widely used microservice applications.
our results show thatnezhaachievesahightop1accuracyatboththeserviceand inner service level and outperforms state of the art approaches by a large margin.
moreover nezhadeals with events with high scalability whichmakesitpractical for industrialsystems.
data availabilitystatement thedataandtheimplementationof nezhaarepubliclyavailable at zenodo and github1.
the augmented onlineboutique and trainticket are available at and .