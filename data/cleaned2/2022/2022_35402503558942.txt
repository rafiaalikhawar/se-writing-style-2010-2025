discovering featureflag interdependencies in microsoftoffice michaelschr der tuwien vienna austria michael.schroeder tuwien.ac.atkatja kevic microsoft cambridge uk katja.kevic microsoft.comdangopstein microsoft new york usa dan.gopstein microsoft.com brendanmurphy microsoft cambridge uk brendan.murphy microsoft.comjennifer beckmann microsoft redmond usa jennifer.beckmann microsoft.com abstract feature flags are a popular method to control functionality in releasedcode.theyenablerapiddevelopmentanddeployment but canalsoquicklyaccumulatetechnicaldebt.complexinteractions between feature flags can go unnoticed especially if interdependent flags are located far apart in the code and these unknown dependencies could become a source of serious bugs.
testing all possible combinations of feature flags is infeasible in large systems like microsoft office which has about 12000active flags.
the goalofourresearchistoaidproductteamsinimprovingsystem reliability by providing an approach to automatically discover feature flag interdependencies.
we use probabilistic reasoning to infer causalrelationshipsfromfeatureflagquerylogs.ourapproachis language agnostic scaleseasily tolargeheterogeneouscodebases and is robust against noise such as code drift or imperfect log data.
weevaluatedourapproachonreal worldquerylogsfrommicrosoft office and are able to achieve over precision while recalling non trivialindirectfeatureflagrelationshipsacrossdifferentsource files.wealsoinvestigatedre occurringpatternsofrelationshipsand describe applications for targeted testing determining deployment velocity errormitigation anddiagnostics.
ccsconcepts software and its engineering software configuration management and version control systems mathematics of computing probabilistic inference problems .
keywords feature flags loganalysis causalinference combinatorialtesting acm referenceformat michaelschr der katjakevic dangopstein brendanmurphy andjennifer beckmann.
.discovering feature flaginterdependenciesinmicrosoft office.
in proceedingsofthe 30thacm joint european software engineering conferenceand symposium on thefoundations of softwareengineering esec fse november14 18 singapore singapore.
acm newyork ny usa 11pages.
esec fse november 14 18 singapore singapore copyright held bytheowner author s .
acm isbn978 .
dark mode reducebrightness else showwhitebackground if !ripcord 3456 playanimation a sourcecode new design dark mode ripcord 3456 b interdependencies figure example of feature flag usage introduction feature flags also known as feature toggles feature switches feature gates or change gates are a design pattern to conditionally enable a code path .
they are a popular method within the software industry to provide the capability to control functionality inreleasedcode.developerscanwrapnewcodewithafeatureflag which can then be dynamically toggled even after the software has beendeployed.thevalueofafeatureflagisevaluatedatruntime anditiseitherqueriedfromaremotelocationordeterminedbased on parameters in the source code.
feature flags are used to run experimentsinproduction e.g.
fora btesting torolloutfeatures inastagedmanner orforemergencybugmitigation e brakes .
in the case of an e brake a feature flag is toggled when faulty behaviourisobservedsuchthatthebugcanbemitigatedrapidly without releasing a new version of the software.
for an example of howfeature flags are usedin source code see figure 1a.
whilefeatureflagsenablerapiddevelopmentanddeployment of software systems they can also accumulate technical debt.
managing many feature flags is complex and conflicts can result in unexpectedandsometimesdisastrousbehaviour asillustratedby the failure at knight capital group where reusing an old feature flag created erroneous trades in the stock market over a minuteperiodandresultedinthecompanygoingfromoneof thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse november14 18 singapore singapore michaelschr der katja kevic dan gopstein brendanmurphy andjennifer beckmann the largest traders in us equities to becoming bankrupt.
the managementandcomplexityoffeatureflagsincreaseswhenflagsare interdependent figure 1b .interdependenciesarise anytimeflags arenested whenthedynamicruntimevalueofoneflagdetermines whether or not another flag is queried.
in this way code that is far downstream from the parent flag can be affected and the inclusionofadditionalfeatureflagswillcauseyetmoreinterdependencies.
the farther apart interdependent flags are in the source code the more indirect their relationship can be.
developers might not even be aware that some flags are interdependent especially if the relationship extends beyond function module or even process boundaries.suchunknowndependenciescanbe andhavebeen asourceofseriousbugsthattakeasignificantamountoftimeto resolve.onewaytomitigatethesebugswouldbetotestallpossible combinationsoffeatureflags butthisquicklybecomesinfeasible forthe12000feature flags currently active in the microsoft office codebase thiswouldamountto .
107testablecombinations assumingtheseare allsimpleboolean flags whichthey are not.
thegoalofthisresearchistoaidproductteamstoimprovetheir system s reliability by providing a way to automatically determine featureflaginterdependenciesinalargesoftwaresystem.knowing the relationships between feature flags that exist in a codebase providesadiversityoftangiblebenefits wecanreduceourtestburdenbytargetingonlyknownsets ofinterdependent feature flags for combinatorial testing.
we can use the knowledge of feature flag relationships to determine the ideal deployment velocity the speed at which changes controlledbyfeature flags can be rolledout.
we can save time diagnosing failures involving feature flags by followingtheir transitive dependenciesand recognizing common interdependency patterns.
wecanpreventerrorsbyenablingdeveloperstocheckfor risky dependencies before togglingafeature flag.
to this end we developed a novel approach to analyze the feature flags that are currently active within the desktop microsoft office suite.
as stated microsoft office currently contains around 12000feature flags with different life spans.
every day feature flags are being added and removed.
a challenge in studying feature flag interdependencies in a large and mature system is that feature flags can occur in code written in many different programming languages.
furthermore over the years numerous apis have been written to wrap the official feature flag sdk for additional requirements.
the many different ways of defining feature flags in the source code across many different programming languages makesithardtousestaticordynamiccodeanalysistodetermine interdependencies.
the novelty of our approach is that we analyze the logs that are emitted every time a feature flag is queried in a runningmicrosoftofficeapplication.assumingfeatureflagqueries arealreadybeinglogged thepassivenatureofouranalysisrequires no changes to the surrounding configuration infrastructure and is completely decoupledfrom the sourcecode itself.
we investigate the following researchquestions rq1howcan we inferfeature flag interdependencies at scale?
rq2what is the accuracy of our method in a real world setting?
rq3do re occurring patterns of feature flag relationships exist?
related work interdependent feature flags.
the problem of interdependent feature flags is one that has existed for several decades beginning in the world of telecommunication switching .
the modern conundrum is well described by rahman et al .
every change totrunkshouldbetestedacrossallpossiblecombinationsofenabled featuretoggles.thisofcourseintroducesanexplosionofteststo run.
there isacommonposition that inpractice featureflags do not need to be exhaustively tested.
fowler recommends to test onlytwo combinations allthetoggles onthat are expected tobe on in the next release and all toggles on and neely and stolt suggest that combinatorial testing can largely be ignored if theflagsareindependent andtheseareoftenjustifiedbytheclaim that mostfeatureflagswillnotinteractwitheachother .inthe case of microsoft office however the reality is quite the opposite.
there are hundreds of interdependent feature flags and in the courseofoureverydayjobswe haveencounteredmanyscenarios whereundocumentedanduntestedinteractionsbetweenfeature flagsresultedinundesirablebehavior.thisunfortunatesituation lead us to try to build an understanding of which feature flags wereintertwinedwithothers.thisgoalisdifficultthough asnoted by meinicke et al .
who explain finding and understanding interactionsisnontrivial especiallywhenfeaturesaredeveloped separately andthere are noclear specifications.
moreover the types of interaction among feature flags are complex as well.
there are many ways for configuration data to be dependentoneachother.chenetal .
defineataxonomyofthese dependenciesincluding control defaultvalue overwritevalue and behavior dependencies.
our investigation focuses only on the controldependency where the value of one feature flag determines whether asecondfeature flag isorisnot executed.
mechanism of determining interdependency.
before studying the properties of interdependent feature flags we first had to identify the relationships between each of the flags in microsoft office.
some systems such as the one used at facebook expresses configurationdependencyassourcecodedependency whichentirelysolvestheproblemofdetermininginterdependency however itdependsonaspecificinfrastructurethatisn tavailableinmost systems includingours.
for many more systems if interdependency relationships are tobeestablished itmustbedonebyinference afterthecodehas beenwritten.medeirosetal .
proposedaconfiguration space sampling methodwhere they useda combination of samplingalgorithmstofindconfigurationsthatresultedinruntimefaultssuch as memory leaks and uninitialized variables.
while they showed thistechniquetobevaluable itbecomeseitherlessaccurateorless computationallyfeasibleifconfigurationspaceisverylarge which isthe casewithmicrosoftoffice.
a common method to analyse feature flags in the literature is to havehumansvalidatewherefeatureflagsexistandwhatthey re usedfor.thisislikelyasymptomofresearchersneedingtooperate overmanydisparatesystems thathaveheterogeneousfeature flagging mechanisms as well as not having the same long term incentivestoautomatethediscoveryprocessthatthemaintainerof anindividualsystemmighthave.oneexampleofmanualflagdiscover is meinicke et al .
who performed an automated search 1420discoveringfeature flaginterdependenciesin microsoftoffice esec fse november14 18 singapore singapore log time feature value a false c false b false c false a true b false c false a af cf b bf af cf c at bf af cf d at bf af cf e at bf af cf f at bf af cf g figure usingquery logs a to discoverco occurrences b d andinfercausalities e g throughgitcommitmessagestofindrepositorieswhichlikelycontained feature flags but then used manualinspectionto verify the flagsexisted.
asystemthesizeof microsoftofficeis toolargefor this approach and instead the relationship between configuration valuesmustbe discoveredas an automatedprocess.
the bulk of research on feature flag or configuration interdependencyisdoneinastaticanalysiscontext.forexample zhang etal.
usestaticanalysistoanalyzewhichregionsofcodeare effectedbyconfigurationoptions andfromthat determinewhich configurations depend on each other.
their goal was specifically to find silentmisconfigurations configurationvalueswhichhaveno effectontherunningprogram oftenduetointeractionsbetween configuration settings.
static analysishas many benefits including well definedcorrectnessguaranteesandtheabilitytofindpotential future problems beforethey re executed.
conversely it is difficult to have a static analysis system that can seamlessly process unconventional systems such as dynamically generated loaded code programs that use multiple languages and even large projects in a singlelanguagethatareonlyabletobebuiltusingcomplexcompiler configurationthat isdifficult to replicate inan external system.
despite not being popular for investigating interdependency runtime analysis has proven useful in many contexts related to independentconfigurations.
forexample attariyanandflinn usedynamicinformationflowanalysistotracedatacomingfrom configurationfilestoeventualerrorsasatoolforautomatedconfiguration debugging.
given the complexity of the microsoft office engineering ecosystem we opted for the more robust option of dynamicanalysisonwhichto baseour investigation.
inferring relationships foranytwofeatureflags aandb wewanttodeterminewhether the value of adetermines if bis queried.
in particular we want to determine if acausesb i.e.
a b or if the value of ahas no effectonwhether bisqueried i.e.
a b. forexample the dark mode flaginfigure 1isonlyqueriedifthe value of the new design flag is true assuming short circuitingof logical operators so new design dark mode .
however whetherornot dark mode isqueriedisindependentofthevalue oftheripcord 3456 flag soripcord 3456 dark mode .
sometimes featureflagrelationshipsareeasilyinferablefromthe sourcecodeitself.ingeneral however theheterogeneousnatureof a large codebase makes static analysis difficult especially for nonlocalrelationships.featureflagsmightbespreadacrossdifferent compilation units or be only very indirectly related.
in these cases we have to resort to dynamic analysis of the code s actual runtime behaviour.fortunately itispossibletodothisinanentirelypassive manner without changes to the source code.
in microsoft office any timea feature flagisqueried during therunofanapplication the query is logged together with the current value of the flag.
figure2apresents a simplified example of such query logs.
by combining the logs from multiple runs exercising different parts of anapplication wecangainbroadinsightintoglobalfeatureflag activation patterns.
.
co occurrence discovery ifa b then we would expect the timespan ab tb ta betweenanyparticularqueryof a attimeta andthefollowing query of b at timetb to always be roughly the same for all instancesof aandbthatoccur inthe logs.theactual valueof ab will be different for every pair of related feature flags and could rangeanywhere from a few nanoseconds e.g.
forflags thatoccur on the same line of code to even a few seconds e.g.
for flags that are relatedviasomeasynchronous operation like copy paste .
we can view abas a relative measure of similarity between the contexts in which flags aandbare evaluated.
for example twoflagsthatarequeriedinasingleexpressiononthesamelineof sourcecodehaveverysimilarevaluationcontexts andthusasmall ab aswilltwoflagsthatarelocatedinentirelydifferentsource filesbutconnectedviaafunctioncall however twoflagsthatare queried at entirely different points during an application s run will havealarge ab regardlessofwhethertheyarespreadfarapart inthe sourcecode orappear within afewlinesof eachother.
1421esec fse november14 18 singapore singapore michaelschr der katja kevic dan gopstein brendanmurphy andjennifer beckmann wecancollectall co occurring featureflagsbydraggingasliding windowofsomeempiricallydeterminedsize overthequerylogs selecting all feature flag pairs with ab .
figures 2bto2d demonstrate this process with 1s and show how a graph representationofthediscoveredco occurrencesissuccessivelybuilt up.
in this co occurrence graph each vertex represents a feature flagquerythatreturnedaparticularvalue afmeaningflag awith valuefalse and each edge signifies that the two connected queries co occurredwithinthesametimewindow .notethattheedges are directed we take the temporal order of queries into account to avoidaddingobviouslyparadoxicalrelationships ifaisqueried before b then b a. algorithm 1showstheco occurrencediscoveryprocessindetail.
althoughtheresultingco occurrencegraphalreadysignificantly reducesthestatespaceofpossiblerelationships cf.section .
itof course includes many co occurrences that are merely coincidental andnotactualcausalrelationships.todiscoverthose weneedto employ causalreasoning.
algorithm1 co occurrence discovery input setoffeature query logfiles l time windowsize output co occurrence graph g v e letg v e be an emptydirectedgraph foreach logfileldo foreach slidingtime window wofsize inldo foreach feature query qinwdo ifq vthen increasethe countofqinvby1 else addqtovwithan initial countof1 foreach combination q1 q2 inwdo if q1 q2 ethen increasethe countof q1 q2 ineby1 else add q1 q2 toewithan initial countof1 .
naivecausal reasoning toturnaco occurrencegraphintoa causalgraph whosevertices represent single feature flags and whose directed edges indicate causal parent child relationships we must look at the valuesof prospectiveparentflags.themain intuitionisthatif bisqueried regardless ofthe valueof a thena b. to illustrate this figures 2eto2gproceed with the running exampleand successivelyeliminatenon causaledges fromthecooccurrence graph.
first the edges at cfandaf cfare removed figure 2e becauseifboth atandafco occurwith cf then neither can actually be a causal factor for c the value of ais clearlyimmaterialto whether ornot cisqueried.
next bf cfis removed figure 2f because even though we do not see bt cf we also do not have any knowledge of bt cf asbtdoes not occur at all.
merely knowing of a cooccurrence bf cf is not enough evidence for us to assume a causal relationship b c we also require evidence of the absence of counter evidence bt cf .
put another way in orderto determine that some feature flag is the parent of another we needtoseeboththecaseswheretheflagis orcouldbe theparent and the cases where it is not.
it is only by contrasting these two scenarios that we can gain information.
finally only at bfremains figure 2g andthusthecausal graph issimply a b. .
noise figure3shows a typical instance of a real world co occurrence graph.
naive causal reasoning would require us to eliminate all of itsedges becausetheyclearlycontradictoneanother.butnotallof the co occurrencesin thisgraphare equally valid someofthem are purely noise whichcan appear for anumber of reasons bugslogging feature flag queries happens in a variety of heterogeneous environmentsand involves local caching asynchronous batched network transmissions and server side logprocessing.bugscananddohappen queriesgetdropped or logged in duplicate time ordering gets mixed up and so on.whilewecouldworkundertheassumptionthatbugsare relativelyrareandcouldbemitigatedbyrigorouslycleaning our input data we would much prefer to be able to draw valid conclusions from data that occasionally includes small inexplicableamountsofnoise.suchisthenatureofindustrial software engineering.
crossed signals ourlogs containfeatureflag queriesacross a variety of apps on a variety of platforms.
some of these share the same featureflags butusethemin differentways exhibiting different interdependencies.
it certainly makes sense to process some subsets of our logs separately e.g.
partitioned by platform.
on the other hand since apps do communicatewitheachotherandtherearelegitimatefeature relationships that cross app boundaries we would also like to capture those.
codedrift asthesourcecodechangesovertime andfeature flags are addedand removed the relationshipsbetweenfeature flags change as well.
the query logs are like a slow moving window sliding over the released app versions capturing multiple versions at once and slightly lagging behind thelatestchangesinthesourcecode butsteadilycatching up.
as most relationships between feature flags remain relativelystable however limitingourselvestoonlylogsfrom the very latest released or unreleased app versions would severelylimit the amount of data available for analysis.
coincidences sometimes the data justlines up in a way that isindistinguishablefromarealsignal.inprinciple wewill never be able to entirely rule out this kind of noise.
in practice wewouldlikeouranalysismethodtobesensitive enough to discardmany if not most such coincidences.
while some sources of noise can be mitigated we would like to deal with most data as is.
how can we infer causal relationships in the presence of noise?
and how can we be confident that our inferences are correct given that one small change in signal could completely changethe result?
1422discoveringfeature flaginterdependenciesin microsoftoffice esec fse november14 18 singapore singapore af5152 at10089 bf 3674bt 23a?
b p b at .
p b af .
p at b .
p af b .
et .
.
.
.
.
ef .
.
.
.
.05b?
a p a bt .
p a bf .
p bt a .
p bf a .
et .
ef .
figure causal inference on a noisy real world co occurrence graph.
the scenario af bis the most likely one because its errorvalue ef .05isthesmallest indicating theleast deviationofits probabilities fromthe expected pattern.
.
causal reasoningwith probabilities todealwithnoisydatawecanborrowsomenotionsfromprobabilitytheory.wecanviewafeatureflagqueryasa randomevent thateitheroccurswithinsometimewindowordoesnot.wecan alsoviewthevalueofthefeatureflagasthe outcomeoftheevent.
the probability that some feature flag bco occurs with another feature flag awhen the value of aisxcan then be described by theconditionalprobability p b ax p ax b p ax co occurrences of axwithb totaloccurrences of ax.
assumingthatweknow axoccursbefore b thiscanbeinterpreted as how likely is it that bwill be queried if ahas the value x?
the inverse how likely is it that ahad the value xif we know thatbwasqueried?
isgiven by p ax b p ax b p b co occurrences of axwithb totaloccurrences of b. ifahaskpossible observed values then there are 2ksuch probabilitiesbetween aandb assumingweknowthat acomesbefore b and thus the value of bis not relevant .
but how do these probabilitieshelpusdeterminewhether a bora b?
letusconsiderthe platonic ideal ofacausalrelationship if a b here aisassumedtobe abooleanflagandthisis theonlyoccurrence of both aandbin the source code.
clearly the likelihood thatbwill be queried if ais true is100 while the likelihood that bwill be queried if ais false is .
similarly the likelihood that a was true if bis queried is and the likelihood that awas false ifbis queried is .
we observe p b at p b af p at b andp af b .
realistically aorbmight occur multiple times in the source code possiblyinrelation withotherfeature flags if a x if a x b if x b if x a b the probabilities between aandbwill then be affected by some valuesproportional tothenumberof additionalchildrenof aand additionalparentsof b.inparticular wenowhave p b at where is some term proportional to the number of additional children of a andp at b where is some term proportional to the number ofadditionalparentsof b.the table below gives the expected probabilities for the three possiblescenarios at b whichwejustdiscussed thecomplementaryaf b i.e.
replacing aby!ainthecode andthecase when neither atnorafare acause of bandthusa b. at b af b a b p b at 1 p b af p at b 3 p af b in the case of a b the probabilities are unknown random values 1to 4 about which we know nothing except that they are very unlikely to match the probabilities we expect in the other two cases.
the exact values of and are also unknown and they aredifferentforeachparticularcombinationoffeatureflags a b andx butitisreasonabletoassumethatformostfeatureflagsthe number of parents and children will be much closer to one than forexample ten.both and arethusexpectedtobesignificantly smallerthanone onaverage.
knowingwhichprobabilitiestoexpectfor at bandaf b we can calculate two error values etandef indicating how much reality deviates from the expectations for each scenario.
the smaller the error the more likely the scenario if both errors are too large then a b. figure3demonstrates these calculations on anoisygraphbasedonrealdata.intheremainderofthissection we formalize this ideaandgeneralize itto non boolean flags.
probabilisticcausalinference.
assumethat aandbarefeature flags with ahavingkobserved values and that aoccurs before b. asashorthand wewillwrite aiforthetotalnumberofoccurrences ofathat return value i bfor the total number of occurrences of b returninganyvalue and aibforthenumberofco occurrences ofaiandb.
for each of the kpossible scenarios ai b we can compute an errorvalue ei k parenlefttpa parenleftexa parenleftbta parenleftbigg aib ai parenrightbigg k j iajb aj parenleftbigg aib b parenrightbigg k j iajb b parenrighttpa parenrightexa parenrightbta.
the overallerrorfor the possibility a bisthen given by e k min iei.
1423esec fse november14 18 singapore singapore michaelschr der katja kevic dan gopstein brendanmurphy andjennifer beckmann becauseeonly captures the relativeproportions between aand b we assess our confidence in eby computing the least absolute number ofcontributingobservations n min a1 ... ak b .
then for empirically determinedthresholds eand n a bifk 2ande eandn n a botherwise .
we are thus able to infer interdependence between feature flags basedonobserved co occurrences.
rq1.howcanweinferfeatureflaginterdependencies at scale?
looking solely at query logs we are able to discover feature flags that repeatedly co occurwithin certain time windows.basedonintuitionsaboutcodestructureandemploying notions from probability theory we developed a method of probabilistic causal reasoning that is robust tonoise by calculatinghowcloselyapairofco occurringfeatureflagsmatches an ideal causalrelationship.
evaluation we implementedourinference mechanismin pythonand applied ittoreal worldfeatureflagquerylogsfrommicrosoftoffice.we chose a sub sample of query logs restricted to a single release platform and code fork which made it easier to cross reference potential findings with the codebase.
for a period of one week wecollectedabout2.5millionfeaturequeriesperday fromabout 80000dailyappsessions.weperformedco occurrencediscovery every day with a time window size 1 s incrementally updating our database of co occurrences and re calculating all causal probabilities afterwards.
at the end of the collection period we haddiscovered pairsof12791co occurringfeatureflags.
of these 326418pairs of5724feature flags are potentially causally related e .
and593pairsof612featureflagswereconsidered to be likely causally related e .
.
figure 5presents some concrete examplesoffoundrelationships.
.
precision toevaluatethe precision ofourapproach howmanyoftherelationships we uncover are actuallytrue causal relationships?
we cross checkedtheresultsofourinferencealgorithmwiththemicrosoft office source code.
we selected pairs of feature flagsinapurposivesamplecoveringtherangeof eandnvalues returned by our algorithm.
the sample is balanced with 107of thesamplepairsexhibitingarealcausalrelationshipinthecodebase and 93of no discernible causality.
we manually inspected the sourcecodelocationsofeachselectedfeatureflagpairtodetermine causality.
this was a time consuming process as it is often not immediately apparent whether a causal relationship exists especially for relationships that would be rather indirect.
we erred on the sideofcaution andonlyreportedtruepositiveswhenthecausal relationship wasclear beyond doubt if the examinerwas not able toestablishacausalrelationshipaftersometime typicallyabout minutes the feature flag pair in question was marked as a false0.
.
.
.
.
.
.
.
.
.
.
.
e precisionn figure precision for different values of eand n. as our willingnesstoacceptunlikelycandidatesincreases sodothe rates offalsepositive parent child relationships.
table precision for n 100and differentvaluesof e discovered verified falsified epairs flags pairs flags pairs flags precision .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
positive thus it is possible that the number of true positives is actually higher thanwhat we report.
figure4showstheprecision true positivesdividedbysample plotted against e for different choices of n. we are able to achieve precisionwith e .
regardlessof n and90 precision with e .25and n .theexactnumbersofmanuallyverified truepositive andfalsified falsepositive pairsaregivenintable which alsoshows how many pairsof feature flags we are ableto discover at differentlevels of e. choosing e .50and n i.e.
classifyingratherunlikely pairstoberelated westillachieveaprecisionof66 significantly betterthanchance.thismakessense becausetheco occurrence discoverystepalreadyreducesthesetofpossiblerelationshipsin a major way filtering out those pairs of feature flags which are definitely not related.
adding probabilistic causal reasoning on top i.e.
only counting pairs with a e .
naturally increases precision further.
1424discoveringfeature flaginterdependenciesin microsoftoffice esec fse november14 18 singapore singapore augloopruntime.cpp boolfsimilarityenabled static const featureflag eduenabled ... static const featureflag conenabled ... static const featureflat entenabled ... return eduenabled conenabled entenabled a triangular relationshipeduenabled conenabled entenabled entitymanager.cpp voidentitymanager init if featureflags instance m pworkbook .
autorefresh refreshmanager createsharedinstance m pworkbook refreshmanagerimpl.cpp voidrefreshmanagerimpl createsharedinstance workbook p workbook try refreshmanager getapi refreshmanager newsharedobj refreshmanagerimpl pworkbook catch handler refreshmanagerimpl refreshmanagerimpl workbook pwo rkbook m pworkbook pworkbook m frefreshbar featureflags instance pworkbook .
showrefreshbar ... b indirectrelationship across multiple filesautorefresh showrefreshbar word.xml fsdropgallery id flyoutinsertpics featureflag pictureribbon commands fsmenucategory class standarditems items fsexecuteaction id insertpicfromfile fsexecuteaction id insertonlinepic featureflag onlinepics fsexecuteaction id clipartdialog items fsmenucategory commands fsdropgallery c relationship inresourcefilepictureribbon onlinepics figure real causal relationships between feature flags found in the microsoft office codebase.
the source code has been simplified forpresentational purposes.
1425esec fse november14 18 singapore singapore michaelschr der katja kevic dan gopstein brendanmurphy andjennifer beckmann .
recall since our goal is to find relationships between feature flags that are as of yet unknown we do not have a prioriground truth.
this makes it difficult to establish recall how many of the relationships between feature flags that are hidden in the codebase can our method uncover?
we are unable to answer this question directly.
however we can make inferences based on the quality of our results inparticular the types ofrelationships we are seeing.
figure5aisanexampleofan obvious relationship threefeatureflagsarequeriedtogetheraspartofabooleanpredicate giving rise to a triangular interdependency only if the eduenabled flagisfalsewillthe conenabled flagbequeried andonlyifboth eduenabled andconenabled arefalsewill entenabled bequeried.
this relationship is manifested entirely in a single line of source code producingastrongsignalinthequerylogsthatoursystem can easily detect.
figure5bshows a much more indirect relationship spanning multiple source files.
here the parent autorefresh and child showrefreshbar flags are queried indifferent program modules and are separated in the control flow by a number of function calls involvingmacroexpansions classconstructors andc templates.
apurelystaticapproachmighthavesomedifficultieswiththis but ourlog basedanalysisnaturallycapturesthedynamiccontrolflow the surroundingsyntactic complexityisentirelyirrelevant.
figure5cdemonstrates that our approach is also completely language agnostic.
in additionto flag usage inc c andother programminglanguages weareabletofinddependenciesbetween featureflagsusedsolelyinnon coderesourcefiles asinthepresent caseofthe pictureribbon onlinepics pairfoundinanxml configurationfile usedto constructan applicationui.
given the diversity of relationship types we are able to find see also section including very indirect relationships we believe that our results are indicative ofnon trivialrecall.
rq2.whatistheaccuracyofourmethodinareal world setting?to determine the precisionof our approach we manually evaluated a subset of discovered relationships in a largescalereal worldcodebaseandfoundthatweareabletoachieve precisionforlikelypairs e .
withanabsoluteminimumprecisionof66 .whileweareunabletopreciselyquantifyrecallduetoalackofgroundtruth weseeevidenceofnontrivialrecallintheindirectnatureofsomeofthediscovered relationships whichcanspanmultiplefilesandprogramming languages.
interdependency patterns sofar wehavediscussed featureflagrelationshipsmostlyaspairwise parent child relationships between two flags.
as figure 5a demonstrates morecomplexpatternscanemergeoncetransitive dependencies are taken into account.
each of the two flags in a parent child relationship can themselves be in further parent child relationships with other flags which is reflected in the values of and in section .
.
to investigate the extent of such transitive interdependenciesandwhetherornottheygiverisetore occurring patterns wecanstudythe globalcausalgraph offeatureflags as figure causal graph of all feature flags precision showing feature clusters simple pairs 35outward stars 5inward stars 4chains 4triangles 19other kinds.
seen in figure .
here we plotted the feature flags from our evaluation section that were considered to be likely causally related e .
.nodescorrespondtofeatureflagsandthedirected edgesrepresentparent childrelationships.theweaklyconnected componentsofthisgraphare featureclusters i.e.
subsetsoffeature flagsthatareonly indirectly connectedtoeachotherbutnotto flags from any other subset.
the layout was achieved using the fruchterman reingoldalgorithm whichnaturallybringsout independentclusters.thelocationanddistanceofnodesholdno further meaning.
based on visual inspection of this graph we identified five basic patternsof feature flaginterdependencies.the identifiedpatterns the rules used to determine if a feature flag cluster belongs to a specificpattern aswellasexamplesofcodestructuresthatcould give riseto eachpattern are given intable .
the most common pattern is the simple pair of parent child flags occurring times in our sample and involving flags .
ofallflagsinthesample .thesecondmostcommonisthe outward star pattern involving flags .
where one parent flag is at the center of numerous parent child relationships but the childrenarethemselvesnotinterconnected.thissituationarises when a single flag guards a large section of code containing many independent flags or when a often non boolean feature flag acts asaconfigurationparameterthatisrepeatedlyusedinscenarios involving other flags.
less common involving only flags .
istheinwardstar whereachildflaghasmultipleparentflags which canoccurwhenthechildflagisreusedindifferentcodecontexts.
triangleandchainpatterns each only occur times in our sample 1426discoveringfeature flaginterdependenciesin microsoftoffice esec fse november14 18 singapore singapore table identified patternsoffeature flag interdependencies pattern description code example occurrence involvedflags chain at least three nodes that are in consecutive parent child relationships.if a b ... if b c .
triangle atleastthreenodesinachain withthefirstnodealsobeing the parentofthe last node.
a b c .
inwardstar one node is the child of at least two parents which are not themselves connected.if a c if b c .
.
outwardstar one node istheparentofat leasttwochildren which are not themselves connected.f a b g a c .
simple pair twonodes that are inaparent child relationship.
if a b .
.
other unclassifiable often basic patterns with slight deviations orsuperclustersofmultiple patterns.
.
andarecloselyrelated triangleformationsareusuallyduetoshortcircuiting boolean predicates or closely nested if statements while chains arise either when consecutive parent child relationships are notnestedbutpurelysequential orwhentherelationshipsarevery indirect withenoughdistancebetweenparentandgrandchildto not be recognizedas atriangle.
inadditiontothesebasicpatterns anumberofclustersremained unclassifiable 19out of146 involving293 flagsintotal .of these many are essentially one of the basic patterns with slight deviations preventing easy classification.
for example one large cluster involving102flags the starburst inthelowercenteroffigure isalmostapureoutwardstarpattern saveforafewinterconnected children.
other unclassifiable patterns arise when two or more basicpatternsareconnectedbya bridgenode formingasingular supercluster.
bridge nodescould indicate two otherwiseunrelated application components that are linked by a common feature flag increasing software coupling and perhaps introducing a hidden interdependency.
inability to assign one of the basic classifications may well be an indicator of unusual complexity and therefore risk.
rq3.dore occurringpatternsoffeatureflagrelationshipsexist?
wefoundfivere occurringpatternsoffeature flag interdependency relationships simple pairs outward stars inwardstars triangles andchains.othertypesoffeatureflagclustersareoftendeviationsfromthesebasicpatterns.
wecanuseinterdependencypatternstoidentifyunusualor risky code structures.
threats to validity while our work is based on real world data of a large scale and mature software system there are threats to the generalizability of ofour approach.idealized assumptions.
if the relationships between feature flags areactuallysignificantlydifferentthantheplatonicideal if a b or the average number of children and parents per feature flag reflectedinthevaluesof and muchhigherthanweassume then our probabilistic method might have a hard time inferring relationships.
however we based our assumptions on our direct experience with actual code containing feature flags and empirical evaluation confirmsthe effectiveness of our approach.
lack of ground truth.
we have mentioned the difficulty of establishing recall as we lack ground truth.
it is possible that our approach while able to find some relationships is still missing a significant number.
but based on our findings which non trivial indirect relationships we are confident of achieving reasonablerecall.
theparameters e n which influencerecall need to be chosen empirically andwe believe we made reasonable choices for the purposes of this paper we have limited evidence that byincreasing we can further improve recall see section .
cold start problem.
our approach is fundamentally data driven inordertomakeinferencesaboutpossiblerelationshipsbetween featureflags thedataneedstocontainevidenceoftheserelationships intheformofsequentialfeaturequeries togeneratethese feature queries the applications need to run with certain combinationsoffeatureflagsenabled withoutknowingtherelationships between feature flags beforehand we would need to test all possible combinations of flags with all possible values in order to generatethedatanecessarytomakecompleteinferences thisis computationallyinfeasible.inreality forourapplications wedo not actually need to have perfect recall.
being able to infer a significant amount of interesting relationships is enough to make the systemuseful.furthermore preliminaryinferenceresultscanbe usedtoselectivelygeneratemissingdata enablingmoreinferences andimprovingrecall see section .
1427esec fse november14 18 singapore singapore michaelschr der katja kevic dan gopstein brendanmurphy andjennifer beckmann codebasebias.
iftheinferencemechanismistoocloselytailored to the particularities of a single codebase i.e.
that of microsoft office and the uses of feature flags therein then it might not be transferable to other applications.
however we believe that the foundations of our approach are entirely application agnostic and that it is sufficiently general to be applicable to other codebases.
moreover microsoft office itself consists of a heterogeneous set of applications with massive differences between their individual core components.
futurework in the future we aim to improve both precision and recall by completing our dataset and investigating larger time windows and wewanttofurtherexplorepatternsofinterdependenciesamong feature flag clusters.
completing the dataset.
the probabilistic causal discovery approach works best with complete data i.e.
a dataset in which both booleanfeatureflagvaluesarepresent.asthedatasetinpracticeis oftentimes incomplete i.e.
only one feature flag value is present as opposed to both we plan to systematically run an automated test suite on microsoft office applications with different sets of feature flag values.
the output that is logged by the simulator in our test suite is exactly the same as when real users would use a microsoftoffice application.
investigating larger time windows.
we plan to evaluate our approach using larger co occurrence time windows which couldallowustocapturefeatureflagpairsthatarebeingqueried further apart.
we hypothesize that more nested feature flags might be discovered in features that take longer to fully execute due to userinteractions e.g.
copyingandpasting.
exploring more interdependency patterns.
feature flag pattern recognition could be improved by tolerating slight deviations from existingpatternsandbyrecognizingmorecomplexcombinations identifying bridge nodes and superclusters.
we also want to better understand what code structures give rise to which interdependencypatterns andhowsuch patterns are linkedto faults.
applications weperformedthisresearchinresponsetoseveralpracticalproblemsweregularlyfaceinourorganization.oneofthemostvaluable outcomesofthisworkisthediversityoftangiblebenefitswecan receivebyapplyingourfindings.theseissuesspantheentirelifecycle of our product from automated testing to client side error mitigation.further thechallengeswehopetoaddresshaveimpacts that range from increased organizational efficiency to simplified developmentpractices.
targetedtesting .testingallpossiblecombinationsoffeature flag valuesbecomessubstantiallyharder asmore featureflags are used.thecombinatorialexplosionthatoccurswhenusingmany featureflagsmakesitimpossibletotestallcombinations.fowler recommends to test the feature flags that are known to be enabled in the next release.
however large projects can contain thousands of feature flags where every flag can be toggled.
therefore it is importanttoenabletoolingthathelpstosystematicallytestonlytherelevantcombinations.ourresearchonfeatureflagco occurrences can be applied to substantially decrease the number of feature flag valuecombinationstotest asonlytheco occurringfeatureflags combinationsneedtobetargetedforcombinatorialtesting.flags thatarenotco occurringcanbetestedindependentlyofeachother.
conversely flagswhicharediscoveredtobeinvolvedincomplex relationships can be highlightedfor additionalscrutiny.
deployment velocity .we plan to use the knowledge of feature flag dependenciestodetermine thevelocity withwhicha flagcan be rolled out.
feature flags by their design indicate the usage ofuniquemodulesofcode.interdependentfeaturesthenindicate interdependent modules which is the main factor in coupled code.
it is well studied that software coupling is correlated with negative quality indicators such as vulnerabilities .
consequently we extrapolate that interdependent flags are more at risk of admitting vulnerabilities.
we can use this information to roll out changes slower to ensure that they re thoroughly understood and tested before being fully deployed.
diagnostics .failures rooted in feature flags can be tedious and time consuming to diagnose.
troubleshooting failures when multiple feature flags are involved can incur substantial costs .
showing explicitly which feature flags are interdependent has the potentialtodecreasethetimetomitigatetheproblem anditmight uncover previously unknownrelationships as the cause of failure.
error mitigation .many features are developed behind feature flags such that the flag can be toggled in case of a failure .
the typical response to discovering an error behind a feature flag is to mitigate the error by immediately disabling the flag.
in the case of interdependent flags however this can have unintended side effects.itcoulddisablemorefeaturesthanintended orleavethe systemconfigurationinanunexpected anduntested state.
ourresearchcanenabledeveloperstocheckifthereareanydependencies before togglinga featureflag whichcan helpto preventa further regression.
conclusion in this paper we described an approach for automatically discoveringinterdependenciesbetweenfeatureflagsinordertoaidproduct teams inimproving theirsystem sreliability.unknown dependenciesbetweenfeatureflagscanbeasourceofseriousbugsbuttesting allpossibleflagcombinationsisinfeasibleforlargeprojects.our approachisbasedsolelyonanalyzingfeatureflagquerylogsandis especially suited for large heterogeneous codebases.
we developed amethodofprobabilisticcausalreasoningthatislanguage agnostic androbustagainstnoise.weappliedourapproachonthemicrosoft office codebase and achieved high precision and non trivial recall.
in analysing the results we found patterns of feature flag relationships that can be indicators for the amount of risk associated with certain flags.ourworkcan beapplied inreducingthetest burden forcombinatorialtesting indeterminingdeploymentvelocityfor safe rollouts in diagnostics of faults involving feature flags and in errormitigationbypreventingregressions.inthefuture wewill useautomatedtestingtoincreaseandimprovethedataavailable foranalysisandweplantoexperimentwithdifferenttimewindows to discover awider range of possible relationships.
1428discoveringfeature flaginterdependenciesin microsoftoffice esec fse november14 18 singapore singapore