singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems large scale analysis of non termination bugs in r eal world oss large scale analysis of non termination bugs in r eal world oss projects projects xiuhan shi xiaof ei xie singapor e management univ ersity xfxie smu.edu.sg yi li yao zh ang sen chen see next page for additional authors follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the programming languages and compilers commons and the softwar e engineering commons citation citation shi xiuhan xie xiaof ei li yi zh ang y ao chen sen and li xiaohong.
lar ge scale analysis of nontermination bugs in r eal world oss pr ojects.
.
proceedings of the 30th a cm joint e uropean softwar e engineering conf erence and symposium on the f oundations of softwar e engineering singapor e no vember .
.
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
author author xiuhan shi xiaof ei xie yi li y ao zh ang sen chen and xiaohong li this conf erence pr oceeding ar ticle is a vailable at institutional k nowledge at singapor e management univ ersity https ink.libr ary.smu.edu.sg sis r esear ch large scale analysis of non termination bugs in real world oss projects xiuhan shi collegeof intelligence and computing tianjinuniversity tianjin china shixiuhan tju.edu.cnxiaofei xie singaporemanagementuniversity singapore singapore xfxie smu.edu.sgyili schoolof computerscienceand engineering nanyang technological university singapore singapore yi li ntu.edu.sg yaozhang collegeof intelligence and computing tianjinuniversity tianjin china zzyy tju.edu.cnsen chen collegeof intelligence and computing tianjin university tianjin china senchen tju.edu.cnxiaohong li collegeof intelligence and computing tianjinuniversity tianjin china xiaohongli tju.edu.cn abstract termination isacrucialprogram property.
non terminationbugs can be subtle to detect and may remain hidden for long before they take effect.
many real world programs still suffer from vast consequences e.g.
noresponse causedbynon terminationbugs.
as a classic problem termination proving has been studied for manyyears.manyterminationcheckingtoolsandtechniqueshave beendevelopedanddemonstratedeffectivenessonexistingwellestablished benchmarks.
however the capability of these tools infindingpracticalnon terminationbugshasyettobetestedon real worldprojects.tofill in thisgap inthispaper we conducted the first large scale empirical study of non termination bugs in real worldossprojects.specifically wefirstdevotedsubstantial manual efforts in collecting and analyzing non termination bugsfrom3 142githubcommitsandprovidedasystematicclassificationofthebugsbasedontheirrootcauses.weconstructedanew benchmarksetcharacterizingthereal worldbugswithsimplified programs including a non termination dataset with real and reproducible non termination bugs and a termination dataset with fixed programs.
with the constructed benchmark we evaluated five state of the art termination analysis tools.
the results show that the capabilities of the tested tools to make correct verdicts haveobviouslydroppedcomparedwiththeexistingbenchmarks.
meanwhile we identified the challenges and limitations that these tools face by analyzing the root causes of their unhandled bugs.
finally wesummarizedthechallengesandfutureresearchdirections for detectingnon terminationbugsinreal world projects.
senchen and xiaohong li arethe corresponding authors.
permissionto make digitalor hard copies of allor part ofthis work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse november singapore singapore associationfor computing machinery.
acm isbn ... .
concepts theoryofcomputation programanalysis softwareand itsengineering software post developmentissues .
keywords non terminationbug benchmarking empiricalstudy acm reference format xiuhan shi xiaofei xie yi li yao zhang sen chen and xiaohong li.
.
large scale analysis of non termination bugs in real world oss projects.
inproceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa 13pages.
introduction termination concerns the livenessof a program which is crucial to software quality.
a program is non terminating if there exist someinputsthatcausetheprogramtoexecuteindefinitely.nonterminationofprogramsmayhavevastconsequences especially whenemployedinsafety criticalenvironments e.g.
aerospacesoftware.forexample softwarewithnon terminationbugscanbecome unresponsive leading to degraded user experiences and sometimes denial of service attacks .
the current attempts to this problem focus on proving termination .
yet determiningprogramterminationisshowntobeanundecidable problem and a failure to prove terminationdoes not indicate that the program can always terminate.
on the other hand it is alsochallengingtoshowthataprogramisnon terminating.the challengeliesinthefactthattheviolationwitnessesofaliveness propertyare infinite traces therefore one cannotcome up witha finiteoracleas inthe caseof a safetyproperty.
in recent years many advanced algorithms and techniques have been proposed to eitherprove terminationordemonstrate non termination of programs.
generally they are able to achieve good performance on standard benchmarks such as svcomp and termcomp .
these benchmarks often include manuallycrafted programs with significantlysimplified language 256esec fse november14 singapore singapore xiuhan shi xiaofeixie yi li yao zhang sen chen andxiaohongli.
featuresandexecutionenvironments tomaketheevaluationofvariousalgorithms easier.thisbringsconcernstowhether the evaluation results can truly reflect the performance of the techniquesonreal worldnon terminationbugs.forexample our studyshows thatwhileuautomizer correctlyhandles .
programs in sv comp but it cannot be directly appliedonrealossprojects anditonlysuccessfullyhandles47 of thereal worldnon terminatingprogramsafternecessarysimplifications have been made.
this indicates that the existing benchmarks maynotbeidealevaluationsubjectswhenthepracticalvaluesof the non terminationchecking techniques are concerned.
there have been a number of studies done on real world software bugs which play significant roles in raising awareness and bringing new insights to software quality assurance .
similarly we believe that a deep analysis of real world non termination bugs will provide useful insights todevelopersandguidethedevelopmentof newnon termination detectiontechniques.tothebestofourknowledge thereisstillno such study on non termination bugs which motivates our work.
in particular we would like to find out the answers to the following questions.
how commondo non termination bugs appearin real worldprograms?
whataretherootcausesofthesebugs?
how difficult is it to find these bugs?
how effective are the state of thearttechniquesindetectingnon terminationbugsinreal worldoss projects?
inthis paper we aimto bridgethisgap byconducting alargescaleempiricalstudyofnon terminationbugsinreal worldoss projects.wefacethreemainchallengesinthisstudy.
first there is no existing dataset on the non termination bugs from real world ossprojects.itisdifficulttoestablishreasonablecriteriaandcollect representative non termination bugs to build the dataset.
second the root cause analysis of non termination bugs is difficult.
due to the complexity of the real world program logic e.g.
complex datastructure nestedloops andrecursivefunction andthelack of a test oracle it is non trivial to understand whether they are real non termination bugs and why the programs do not terminate.third the state of the art tools cannot be directly applied to real world oss projects since many complex features are not well supported such as dependencies and complex data structures makingitdifficult to evaluate thesetoolsonoss projects.
to overcome these challenges we first collect commits from1 600c c projects whicharerelatedtonon termination bugs.
note that we selected c c in our work because the popular termination analysis tools e.g.
aprove cbmc and uautomizer onlysupportc c programs.
we dedicatedsubstantial efforts to manually investigate these commits and finally identified 445non terminationbugsfrom199projects.throughfurtherindepth analysis on the root causes of these bugs we systematically builtahierarchicaltaxonomycontaining24categories.toevaluate the state of the art tools i.e.
uautomizer cpachecker 2ls aprove and t2 on real world programs we built a new benchmark including non terminating programs and58fixedversions whichareextractedfromthereal worldnonterminationbugs.weevaluatedtheireffectivenessandsummarized thecommonreasonsfortheirfailures.ingeneral weaimtoanswer the followingresearchquestions rq1 whataretherootcausesofnon terminationbugsin real world oss projects?
rq2 how effective are the state of the art tools in proving the non terminationof real world programs?
rq3 whatarethepotentialrootcausesforthefailuresof the studiedtools?
by answering these questions we characterize the real world non terminationbugsandprovideusefulinsightsfordevelopers and researchers.
for e xample our results rev eal that infinite loops canbecausedby10typesofcommonlogicalfaults e.g.
missing iteratorupdate usingerroneouscondition aswellas6otherbug types related to general programming features e.g.
overflow type conversion .
infinite recursions can be caused by three incorrect recursion designs e.g.
incorrect return and types of unexpected recursion e.g.
misusing method overloading .
our study on the existingtoolsshowsthattheyarealmostcompletelyinapplicable to real projects.compared to the existing benchmarks the performance of existing toolsdrop significantly on theextractedbenchmarks indicatingthattheyarestillfarfromeffectiveindiscovering real world non terminationbugs.
we also discussand summarize keychallengesthatshouldbeaddressedinfutureresearch.more details canbe foundonour website.
in summary this paper makes the following contributions tothebestofourknowledge weconductedthefirstcomprehensive study on analyzing root causes of real world non terminationbugs.weconstructedasystematictaxonomy of bug categories and highlight their characteristics includingthe distributions root causes fixstrategies etc.
we constructed a new benchmark that is extracted from differentcategories of real worldnon terminationbugs includingthenon terminationversionsandthecorresponding fixedversions.thebenchmarkispublicavailableandwill be expandedcontinuously.
we evaluated the state of the art termination analysis tools ontheextractedbenchmarksandidentifiedtheirweaknesses.
we summarized the main challenges and provided future research directions for detecting non termination bugs in real world projects.
related work .
terminationanalysis the general approach to prove termination is to search for ranking functions .whichmapaprogramstate toanelementofsomewell fundedorderedset.mosttermination analysisapproachesrelyonstaticanalysisandconstraintsolvingto synthesize ranking functions.
podelski et al.
proposed an automated method for proving the termination of an unnested loop by synthesizing linear ranking functions.
cousot et al.
expressed programsemanticsinpolynomialformandautomatizedthefloyd naur hoare proof method to verify semialgebraic programs.
chen et al.
reduced non linearrankingfunctioninference forpolynomialprogramstosemi algebraicsystemsolvingproblems.xie etal.
proposethepathdependencyautomatontocapturethe 257large scale analysis of non terminationbugs in real worldossprojects esec fse november14 singapore singapore dependencies among the multiple paths in a loop.
ultimate automizer covers the whole set of program executions by taking the union of the languages of several automata each of which isprovedtobeterminatingbyexhibitinganappropriateranking function.formorecomplexprograms morecomplexrankingfunctions are proposedtoprove termination.
although a lotof termination proving techniques are proposed most of them are incomplete.
the failure of proving termination does not indicate that the program is non terminating.
hence this paper mainly focuses on detecting non termination bugs which cannot be directly solved by the proposed techniques.
we also aim to study real world non termination bugs and evaluate the state of the arttoolsonprovingnon termination.
.
non terminationanalysis the general approach to prove non termination is to search for recurrentsets .guptaetal.
developed a non termination p rover tnt whichprovesnon terminationbydynamicallyenumerating lasso shaped candidate paths to search for counterexamples to terminationandsearchforarecurrentsetforeachlasso.giesl et al.
usedconstraintsolvingtofindarecurrentsetinagivenloop to prove non termination ofthe loop.
cook etal.
proved nonterminationbyusingabstractinterpretationtoover approximate nonlinearprogramsandinferringlinearrecurrentsets.le etal.
proved non termination by iteratively collecting executions traces anddynamicallylearningconditionstorefinerecurrentsets.for provingthenon terminationofnon deterministicprograms closed recurrent sets are proposed which is a stronger notion than recurrent sets.
chen et al.
used a safety prover to eliminate terminating paths iteratively until it finds a closed recurrent set in theremainingpaths.larraz etal.
proved non terminationby max smt basedinvariantgeneration.
in addition there are other techniques that tend to identify infinitestates .carbin etal.
useddynamicaldetection torecord the program state atthe start of each loopiteration and proved non termination when two consecutive loop iterations produced the same state.
menendez et al.
proposed a methodology to detect non termination issues with a suite of peephole optimizations.
chatterjee et al.
provedthe non termination of non deterministicintegerprogramsbyrelyingonapurelysyntactic reversal of the program s transition system.
xie et al.
reduced the non termination analysis to a reachability problem i.e.
to find acounterexample that reaches an infinite state.
someeffortshavebeenrecentlymadetotakelow levelprogramming features e.g.
overflow into consideration which could be helpful for analyzing real world projects.
schrammel et al.
presented a modular termination analysis for c programs using template based inter procedural summarization towards analyzing real world software with bit precise termination arguments thatweresynthesizedoverlexicographiclinearrankingfunction templates.
maurica et al.
transposed theterminationanalysis offloating pointloopsintoterminationanalysisofrationalloops through the use of an innovative rational approximation which covers overflowissues.
theexistingtechniquesaremainlyevaluatedonstandardsimplifiedbenchmarkswhichfailtorepresentmostofthereal worldnon termination bugs.
this paper aims to study the real world non termination bugs and evaluate the practical value of the stateof the art techniques while identifying potential future research directions.
.
existingstudies on real worldbugs researchershavemadegreateffortsinexploringtherootcauses of various bugs and corresponding fix strategies in real world projects includingandroidbugs ossfuzzbugs buffer overflow bugs deep learning bugs autonomousvehicle bugs etc.. these studieshelp developers understandthepracticalrelevanceof different bugsandprovideinsights through examples for researchers to develop more advanced detection techniques.
however almost all of them focus on the violationofsafetyproperties whilethe violationof livenessproperties i.e.
non termination bugs are not touched.tothe bestof our knowledge our work is the first large scale empirical study onnon terminationbugsinreal worldprojects.additionally we constructed a new benchmark by simplifying the non termination bugsfrom real world projects.
data preparation .
data collection in this paper we mainly study the non termination bugs in c c projects.
we first randomly collected c c projects from githubbygithubapis .theseprojectsarecollectedfromtwo considerations mostofthecodearec c programsand2 they havedifferentnumbersofstarsrepresentingdifferentpopularity.
the collected projects cover open source projects designed for variouspurposes e.g.
database operatingsystem mediatools and game .thenwechosefivekeywords i.e.
infiniteloop endless loop long loop infinite recursion and deep recursion to identifypotentialnon terminationbugsfromthecommitmessages of these projects.
finally we obtained commit messages that cover466outofthe1 600projects.table 1showsthedetailedresults from eachkeyword.
we spent five person months investigating the collected commits.specifically wemanuallyanalyzedthecodesnippetscorresponding to the commit messages to understand the root causes of thenon termination.
notethat thekeychallenge isthat there is no oracle for non termination.
due to the high complexity of real world code it is difficult to understand some code in terms of whether and why they are non terminating.
we filtered some commitsthataredifficulttoanalyze theircorrespondingcode snippets do not contain a clear repeated procedure e.g.
loop structure and recursion the repeated procedures are too complex to understand e.g.
loopswithhundredsoflinesofcodeorcommits with large changes and the non termination can be affected by non c c code.finally wekept445commits i.e.
non termination bugs from real world projects which cover the different numbers of starsand involve various typesof projects.
these commits mainly belong to the following two categories infinite loop andinfinite recursion .
to confirm these bugs each of them isanalyzed discussed andconfirmedbyatleasttwoauthors.for cases that they could not decide all authors participated in the 258esec fse november14 singapore singapore xiuhan shi xiaofeixie yi li yao zhang sen chen andxiaohongli.
table detailsofthecollected commits.
keywords projects commits infinite loop endless loop long loop deep recursion infinite recursion total discussion and confirmation.
note that for the commits that are filtered we cannotconclude that they are terminating either.
finding a large portion .
of the collected oss projects havenon terminationissues.inparticular theconfirmednontermination bugs mainly belong to infinite loops .
and infiniterecursion .
.
.
manuallabelling based on the non termination bugs we performed a deep analysisontherootcauses.weadoptedanopencardsortstrategy toconstructanewhierarchicaltaxonomyoftherootcauses.three oftheauthorsmainlyparticipatedinthetaxonomyconstruction.
each participant had more than two years of experience in the researchofterminationanalysis.
two authors first constructed the leaf categories for all the bugs.
specifically in the first round the two participants individually analyzed the commit messages the original code and the changed code to define the root causes.
in the second round they had a discussiontoiterativelyunifythetwoversionsoftheleafcategories.
if there were disagreements between them other authors joined the discussionuntil a consensus wasreached.in the thirdround we randomly selected of the bugs which were labeled by the third participant based on the created leaf categories.
for resultsfromthethirdparticipantthatcontradictedthelabelsofthe firsttwoauthors allauthorsdiscussedthemuntilthecontradiction was resolved by updating the leaf categories or re labeling the conflictingcases.finally allauthorsdiscussedtheleafcategories and grouped leaf categories into high level categories to construct the hierarchical taxonomy of the root causes.
for example the common characteristic of signed over f low error and unsigned wraparound error is overflow therefore we grouped these two leafcategoriesintoahigh levelcategory over f low .
note that as infiniteloops and infiniterecursionhavevery differentcharacteristics weadoptedthesamemethodologydescribed above toestablishthe taxonomies for themseparately.
root causes of infinite loops figure1showsthe hierarchical taxonomy ofinfinite loopsincludingfourlevelsofcategories.ourtaxonomyofinfiniteloopsconsists of inner categories marked in grey color and leaf categories marked in white color .
to measure the frequency of bugs appearingineachcategory wecounted thenumberofbugs ineach category and the number of projects where the bugs are located showninthe upper the right corner ofeachcategory in figure .ingeneral therootcausesofinfiniteloopscanbedividedinto two categories namely logical errors category that are more related to the loop structure itself e.g.
loop condition and loop iteratorvariable and generalprogrammingerrors category2 that may affect the loop execution e.g.
overflow .
specifically most of the infinite loops .
are caused by logical errors that are rootedattheimproperdesignofloops e.g.
incorrectusageofloop iterator variable or incomplete loop condition checking which causesthelooptobestuckinastate.tooursurprise manyinfinite loops .
are caused by general programming errors such as improper type conversions even if the logic of the loops is correct.
however duetootherprogrammingerrorssuchasintegeroverflow andimplicitcasting theseloopscanbeexecutedinfinitely.next we providedetailfor eachcategory.
finding the main reasons for infinite loops are logical errors .
of the bugs covering .
of the projects indicating the difficulty of designing loops correctly.
in addition common programming mistakes can make logically correct loops execute infinitely .
of the bugs covering .
of the projects which may challenge the methods that attempt to prove non termination based only onprogramlogic.
.
logical error category1 fromtheprogram logicperspective thebehaviorofaloopiteration depends on the loop condition theloop iterator variables and the controlstatements e.g.
break .specifically theloopcontinuesto iterate whilethe conditionis true a loopiteratorvariable or loop iterator serves as an index of the loop and may affect the value of loop conditions and control statements may change the flow ofloopexecution.logicalerrorsaredividedintothreecategories related to these three loop elements i.e.
category .
.
and .
.
in total there are specific leafcategoriesundercategory .
finding3 mostofthelogicalerrorsarecausedbyincorrectloop iterators .
andincorrectloopconditions .
.asmall numberoferrorsareduetoincorrectcontrolstatements .
.
furthermore 10differentrootcaseswereidentified indicating thediversityoflogical errors.
.
.
loop iterator error category .
.
during loop execution loopvariablesareupdatediteratively.a loopiteratorerror refers to an incorrect update to loop iterators making the loop condition to be always true.
updates to loop iterators usually involve only a few lines of code but are error prone when their cascading effects span multiple iterations.
we found loop iterator bugs rooted in differentcauses.
category1.
.
misusingsameloopiteratorinnestedloops.
we observed that in nested loops developers may confuse the loop iteratorsof the inner loopswiththoseof the outerloops.there are sixinfiniteloops .
thatarecausedbyreusingthe sameiterator in nested loops.for example ifthe inner loop incorrectly uses the loopiteratoroftheouterloop e.g.
settingittozero theouterloop neverterminates.
259large scale analysis of non terminationbugs in real worldossprojects esec fse november14 singapore singapore root causes of infinite loops logical error loop iterator error .
misusing same loop iterator .
.
no update for loop iterator .
.
missing iterator update .
.
.
adding subtracting zero .
.
.
incorrect bit calculation .
.
.
initialization error for loop iterator .
.
missing initialization .
.
.
incorrect initialization .
.
.
incorrect update for loop iterator .
.
loop condition error .
missing corner case handling .
.
using erroneous condition .
.
incorrect control statement .
general programming error overflow .
unsigned wraparound error .
.
signed overflow error .
.
incorrect variable type .
type conversion .
.
type conversion in comparison .
.
.
type conversion in assignment .
.
.
misusing variable type .
.
undefined behavior .
figure taxonomy ofinfinite loop.
category1.
.
noupdatetoloopiterator.
alargeportionoferrors are caused when the loop iterators remain constant under some conditions makingthe loop stuckwithnoprogress.
specifically to oursurprise thereare74cases .
ofcategory1.
.
thataredue tomissingiteratorupdates category1.
.
.
.ouranalysisshows that the iterator updating statements are missed in cases which are often due to careless mistakes of developers.
the remaining casesarebecausetheiteratorupdatesareplacedincorrectlyafter thecontinuestatements not being executed as a result.
another group of errors .
is caused when the change made to the iterator value is effectively zero category .
.
.
.
for example ini x the loop iterator iremains unchanged when xis zero.
bit manipulations category .
.
.
such as and or and shift left can also lead to such errors.
figure 2shows an example of bit operation from the project brltty .2in this case the loop terminates only if wcbecomes zero.
however since wcis anextended signedcharactertype i.e.
wchar t theloopmakes noprogressif wcisnegativebeforeenteringtheloop.becauseof theshift rightoperations wcwilleventually remain causing a non termination.
wchar t wc static const wchar t mask sizeof wchar t do byte wc 0x3f 0x80 while wc while wc wc mask figure anexample ofincorrect bitoperation.
finding most .
of the loop iterator errors are due to no update to loop iterators.
they are due to careless mistakes 2commit 5bec3fff0bac50f4b4d4d3b02e70161a2bf38d0f i.e.
forgottoupdateiterator .
incorrectlocationsofupdate statements i.e.
update after continue statement .
incorrect update to iterators i.e.
update being zero .
and incorrectbit manipulations .
.
category1.
.
initializationerrorforloopiterator.
variableinitializationisimportantbuterror prone.wefound13cases .
thatarecausedbytheincorrectinitializationofloopiterators such asmissinginitialization category1.
.
.
and incorrectinitialization category .
.
.
.
uninitialized variables may lead to undefined behaviors that can cause an infinite loop.
incorrect initialization can also affect the loop execution which mainly includes incorrect positions ofinitialization statements e.g.
theinitialization forthe outer loop is incorrectly put in the inner loop and incorrect initializationvalues e.g.
thebinarysearchmaynotterminateifthe variables lowandhighare not initializedproperly .
category1.
.
incorrectupdateforloopiterators.
incorrectupdates to loop iterators lead to non termination.
we identified six infinite loops that are caused by incorrectly updated loop iterators.
notethatwedistinguishthiscategoryfromcategory1.
.2because wewouldliketoemphasizethedifferenteffectsofnoupdateand incorrectupdate.noupdateforloopiterator i.e.
category1.
.
causesthelooptogetstuckinonestate whileincorrectupdates maycausethelooptogetstuckinarecurrentsetofstates.figure showsaninfiniteloop3fromtheasteriskproject.ineachloopiteration lisdecreasedby2 whichresults inaninfiniteexecutionif l isinitializedtoanoddnumber.theupdateshouldvarybasedon the parityofthe initialvalueof l. finding5 apartfromtheproblemofnoupdatetoloopiterators infiniteloops can alsobeintroducedby incorrectinitializations .
incorrect updates .
and incorrect reusing of loop iterators .
.
3commit 3322180d4b452e11545b70abc9b2d5af3d241361 260esec fse november14 singapore singapore xiuhan shi xiaofeixie yi li yao zhang sen chen andxiaohongli.
1staticvoidunpacksms16 unsigned char i 2unsigned char l ... unsigned short ud ... unsigned short o ud while l intv i if l if l l v v i o v figure an infinite loop bug of incorrect update of loop iterator.
.
.
incorrect control statement category .
.
control statementsare usedto directthecontrol flowof theloopexecution.in our analysis of the logical errors .
are attributed to the incorrect control statements i.e.
break goto andcontinue .
for example the continueandbreakstatements can be misused break statements can be placed at incorrect locations resulting in incorrect termination condition and gotostatements may jump to incorrect program locations.
finding incorrect control statements bugs from projects can also introduce infinite loops where incorrect break statementscaused themost .
non termination bugs.
.
.
loop condition error category .
.
loop conditions determine whether the loop can start or terminate.
a proper loop condition is critical for the correctness and termination of the loop.
weobservedthatalargenumberofinfiniteloops .
arecaused byincorrect loop conditions.
category1.
.
missingcorner casehandling.
theloopcondition restrictsthescopeofstates i.e.
differentvaluesofvariables that can be reached.
if the scope is not well designed it may cause infinite execution.
we observe .
bugs caused by loose conditions that miss handling some corner cases.
of them are causedbythegeneralincorrectcomparisonoperators e.g.
usei rather than i .
the incorrect comparison operators can miss someboundarychecking.figure 4showsaninfiniteloopcausedby themissingcorner casehandlingfrom libssh .4thecomparison operator is not correct which makes the loop condition always satisfied.
channel read function returns if no more data can be read.theremaining65casesarecausedbylooseconditionsthat are more relatedtothe specific business logic ofthe programs.
while rc channel read channel buffer sizeof buffer while rc channel read channel buffer sizeof buffer fwrite buffer rc stdout figure anexample ofmissing corner case handling.
4commit 1b15896e8b29561447fff9a7bcaa028179eab51bcategory .
.
using erroneous condition.
it is worth noting that thereare34bugs .
causedbythetotallyincorrectloopconditions.
these conditionsmayuse incorrect iterator variables incorrectterminationlogic or truecondition thevalueisalwaystrue indicatingthedifficultyofsettingcorrectterminationconditions insomeloops.figure 5showsaninfiniteloopfrom binutils gdb .
.itisobviousthattheloopconditioncanalwaysbetruewhen cached frame reg countisnot zero.
for inti cached frame reg count i for inti i cached frame reg count i xfree cached frame reg .data figure anexample ofusing erroneous condition.
finding a large part of logic errors .
are due to the incorrectloopconditions.mostofthem .
areaffectedby improper corner case handling which reveals that developers shouldbeverycarefulontheloopconditions e.g.
theboundary .
what is more worrisome is that .
of them are caused by completely incorrect loop conditions that usually depend on the businesslogic.
.
generalprogrammingerror category2 in additionto the logicalerrors about the loopdesign weobserve that general programming errors can also lead to infinite loops whichaccountfor14.
infiniteloops.specifically integeroverflow variable type casting and undefined behavior can affect the update ofloopiterators resultinginnon termination.theseerrorsarenot directlyrelatedtothelooplogic.hence itishardtodetectthem byexistingterminationtools seesection thatmainlyfocuson the logicerrors.
.
.
overflow category .
.
without good consideration for overflow developerscanmisestimatetheupdateofloopiterators during the loop execution.
we observe infinite loops .
that are caused by overflow including unsigned wraparound error category .
.
and signed over f low error category .
.
.
category .
.
unsigned wraparound error.
for unsigned integer types wraparound operations will be executed when the value of the variable is out of scope.
for example the result of the expression uint max willbe0 whichiswell defined.dueto the wraparound of unsigned numbers the loop iterators can never breakthe loop condition causing infinite loops.
we find 9infinite loops due to the wraparound of unsigned numbers which account for2.
ofallinfiniteloops.figure 6showsanexampleinfinite loop from mupdf .6size tis an unsigned type.
if nis less than nwillbe wrappedaround to be anotherlarge positive value.
category .
.
signed over f low error.
it is well defined that wraparoundoperationwillbeexecutedwhenoverfloworunderflow ofunsignedintegeroccurs.butwhenoverflowoccurs theresultsof 5commit 8455d26243aef72f7b827ec0d8367b6b7816de07 6commit ce9d4462423ac74a1dbbc4ce52c2c81cfcdda766 261large scale analysis of non terminationbugs in real worldossprojects esec fse november14 singapore singapore 1voidpdf encrypt data ... size tn while n size tlen n n n len figure anexample ofunsigned wraparounderror.
signed integer types maybe various.
in general wraparound operationwillbeexecutedwhenoverfloworunderflowofsignedinteger occurs i.e.
the result of expression int max is int min .
similarly signed over f low error leads to the abnormal change of loopiterators leadingtoinfiniteexecution.wetotally find6such bugs accountingfor1.
ofallloopbugs.
.
.
incorrect variable type category .
.
the storage of differenttypesofvariablesisdifferent i.e.
differentranges .incorrect use of variable types can also cause infinite loops by changing the valueofloopiteratorsabnormally.thereare24bugsinthiscategoryincluding typeconversion category2.
.
and misusevariable type category .
.
.
uint16 t s len for s seqnum s seqnum len s for i s seqnum i len i s int i len ... figure anexample oftype conversionincomparison.
category .
.
type conversion.
when the types of left values and right values do not match the type conversion can happen inassignmentstatementsandcomparisonstatements whichcan affect the value of loop iterators and loop conditions.
there are atotalnumberof14bugscausedbytypeconversionincluding9 typeconversionin comparison bugs category2.
.
.
and type conversioninassignment bugs category2.
.
.
.figure 7showsan infiniteloopfrom owntone server .7thisloopwillgetstuckwhen seqnum lenis greater than uint16 max.
in this case bit expansionwilloccur andthetypeoftherightvalueintheloopcondition willbealarge32 bitinteger i.e.
itisgreaterthanuint16 max.
however themaximumvalueoftheleftvalue i.e.
s islessthan orequaltouint16 max indicatingthattheloopconditionwill be always true.
type conversion in assignment category .
.
.
involves the type conversion in assignment statements.
for example the valueofthe loop iterator can be truncatedifit is assigned to asmall type sothat itneverbreaksthe loopcondition.
category .
.
misusing variable type.
the type of a variable determinestherangeofitsvalues.theincorrecttypemaylimitthe range of the loop iterator which can lead to an infinite loop.
we totally find bugs caused by misusing variables which accounts for3.
ofinfiniteloops.figure 8showsaninfiniteloopbugfrom 7commit f9bfec180f91671d8ba72a01cab1781c1f5e99991 u32 div1 div2 intdiv1 div2 for div1 div1 div1 for div2 div2 div2 .... figure anexample ofmisusingvariable type.
linux media .8becausediv1anddiv2areunsignedvariable they never become negative.
hence the loop condition div1 and div2 0willbe alwaystrue.
finding not like logic errors that directly affect the loop execution generalprogrammingerrorscanalsoaffecttheloop execution whichmaybeverydifferentasexpectedbydevelopers.
specifically over f low .
andincorrectvariabletype .
can implicitly change the value of loop iterators and loop conditions which leads to infinite loops.
furthermore such errors are verycomplexandsubtle eachtakinganaverageofanhourto analyzeandconfirm.
.
.
undefined behavior category2.
.
during our classification we find some potential infinite bugs caused by undefined behavior andtheterminationoftheseprogramsmaybedifferentindifferent compilersandplatforms.thebest knownexamplesofundefined behaviors inprogramminglanguagescomefromcandc which have hundreds of them including simple local operations overflowingsignedintegerarithmetic .
undefinedbehavior could makeunexpectedconsequences e.g.
silentbreakage timebombs which depends on different compilers and platforms .9the unexpectedconsequencescanaffecttheterminationofloops.inour study undefinedbehaviorisarootcauseofinfiniteloop accounting for .
ofallloopbugsandinvolving .
projects.
uint64 t val inti bytes while val bytes bytes while val bytes bytes bytes figure anexample ofundefined behavior.
figure9showsapotentialnon terminationloopbugfrom ffmpeg .10when the value of bytesis uint64 t is an undefinedoperationleadingtotheundefinedbehavior.itsvaluevaries in differentcompilers and platforms i.e.
the loop can be infinitely executedifitsvalueisparsedasnon zero.theconfirmationofthis categoryofbugsisdifficult.weconfirmedthesebugsfrom1 the commitmessagesthatclearlypointoutthenon terminationand we reproduce them by simplifying the program.
for example we compile the loop in figure 9with gcc version .
.
in ubuntu 8commit 090341b0a95d1f6d762915a75c13b393366f4ab3 9these typesof bugs aremainly confirmed fromthe commitmessages 10commit d597655f771979c70c08f8f8ed84c1319da121e8 262esec fse november14 singapore singapore xiuhan shi xiaofeixie yi li yao zhang sen chen andxiaohongli.
root causes of infinite recursion incorrect recursion design incorrect arguments .
incorrect return .
deep recursion .
unexpected recursion incorrect self invoking .
misusing namespace .
.
miscalling inherited method .
.
misusing method overloading .
.
missing undef instruction .
.
incorrect cyclic invoking .
figure taxonomyofinfinite recursion.
.
.
.thevalueof valwasinitializedto thusthisloopfallsinto an infinite loop.
finding undefined behavior .
couldlead topotential infinite loop bugs which is more difficult to confirm as it depends onthe compilersandplatforms.
root causes of infinite recursion recursion11isanotherrepeatedstructurethatoneofthestepsof the function reenters the function itself.
figure 10illustrates the hierarchical taxonomy of infinite recursion bugs in real world c and c projects.
generally speaking our taxonomy of infinite recursion bugs consists of inner categories in grey and leaf categories inwhite .
finding infinite recursion accounts for a large portion .
of non termination bugs.
.
of the bugs are caused byincorrectrecursion thatmeanstheincorrectdesignofrecursions.
.
ofthebugsarecausedby unexpectedrecursion i.e.
developers do not intend to use recursions but the recursions are unexpectedlygenerateddueto programming errors.
.
incorrect recursion design category1 theterminationofrecursionmainlydependsonthe argument that will be sent to the parameters of the recursive function and the returnthatcandeterminetheexitofthecurrentiteration.ingeneral the incorrect recursion is mainly caused by incorrect arguments category1.
incorrectreturn category1.
and deeprecursion category .
.
category .
incorrect arguments.
we observe infinite recursions .
in incorrect recursion that are caused by using the unchangedarguments.similarwithloop theargumentsdetermine the number of iterations.
if the arguments keep unchanged the recursion gets stuck to a state i.e.
the values of arguments do not change leadingto the infinite execution.
11due to the space limit and the complex structure of recursion we put more detailed examples and discussions onourwebsite.category .
incorrect return.
most .
of the incorrect recursions are caused by the incorrect return12.
it is because of the incomplete condition for return.
for example the current iteration should exit but couldn t because of an incorrect return condition.
category .
deep recursion.
we also find a large part of recursion bugs .
in incorrect recursion that can cause stack overflow rather than non termination bugs so are linked with a dashed line in figure .
when recursion is executed the variables andsomeinformationneedtobesavedintostack.astherecursion can be excessively deep it causes call stack buffer overflow.
the deep recursion bugs are related to complex data structures e.g.
binarytreetraversal compilationprocess anddatabaseoperations .
finding11 .
oftheincorrectrecursionsarecausedwhen incorrectarguments e.g.
unchangedvalue areusedforthe recursions.determiningtheconditionforreturningvalueis error prone which accounts for .
of incorrect recursions.
in addition a largeportion ofbugs .
in incorrect recursions are deep recursion which may lead to stack overflow althoughthey can terminateintheory.
.
unexpected recursion category2 programmingerrorscanleadtounexpectedrecursionthatdoesnot terminate.specifically our study showsthat unexpectedrecursion involves62infiniterecursionbugsthatcover61.
projects.
the major reasons include incorrect self invoking category .
andcyclic invoking category .
.
category2.
incorrectself invoking thereare38infiniterecursions .
caused bythat the functioninvokes itself incorrectly and unintentionally.
specifically of them are due to misusing namespace category2.
.
.thefunction m fintendstoinvoke another function n fwheremandnare different namespaces.
however developers forget to use ncausing it to call itself.
of themareduetothe miscallinginheritedmethod category2.
.
.in c inheritance the method min a child class aintends to invoke the method min another child class b however developers forget to use the class name b i.e.
b m thusa mcalls itself.
of them aredueto misusingmethodoverloading category2.
.
.ithappens whenthemethod mintendstoinvokeanotheroverloadedfunction mbut it incorrectlyinvokes itself i.e.
using thesame arguments .
5of themare causedby missingundef instruction category2.
.
.
forthiscategory developersfirstuse definetodefineanidentifier aas a function b. however in the function b it invokes a i.e.
itself again before undef a. category2.
incorrectcyclicinvoking.
comparedtocategory .
which involves self invoking there are of infinite recursions .
thatarecausedbycycliccalling.giventwofunctions aand b i facallsbandbalso calls a then the unexpected cyclic calling isformed causing an infinite execution.
12withoutlossofgenerality arecursivefunctionthatdoesnotreturnanythingcanbe considered to returnnull.
263large scale analysis of non terminationbugs in real worldossprojects esec fse november14 singapore singapore finding our study shows that the number of infinite recursionscausedbyunexpectedrecursionandincorrectrecursion are very close and indicating that unexpected recursionisalsoimportantfornon terminationchecking.the main reasons include the unexpected self invoking .
andunexpectedcyclic invoking .
.
empiricalstudyon termination analysis tools in this section we introduce the benchmark extraction based on the non termination bugs and conduct an assessment of the sota tools based on the extracted benchmark to answer rq2.
we thenconductanin depthanalysisforthedetectionfailuresofthese toolsto answer rq3.
.
benchmarkextraction to evaluate the performance of the state of the art tools in analyzingtheterminationofreal worldprograms oneimportantstepisto setup a ground truth benchmark with real world non termination bugsbasedonaseriesofvaliditycriteria.thisisbecausereal world sourcecodecontainsnoisesthatarenotrelevanttonon termination bugs and existing tools cannot be directly applied to real world projects.
for ensuring the representativeness of our benchmark we extracted and sliced our benchmark from bugs based on thefollowingprinciples bugsfiltration .thenon termination bugs should be further filtered because most non termination bugs haveverycomplexdependencies e.g.
thebugsdependonmultiple codefiles complexvariabletypes andapis .wekeepsmall size bugsandfiltercomplexbugsbecauseitismoredifficultforusto guaranteethecorrectnessoflarge scalebenchmarksandexisting benchmarks often cannot support complex dependencies.
after this step we keep bugs to construct our benchmark from non termination bugs and used them for assessment.
context simplification .
for infinite loop bugs we follow four steps first weidentifyalltheloopiterations definedin .
andretainthe completeloopcondition.second weretaininstructions e.g.
if else branch andobjectsinthesourcecodeoftheprojectthatinvolve loop iterators which can change the value of loop iterators.
then weretainallcontrolinstructionsanddatestructure e.g.
circular linked list .
finally we remove other instructions that are extraneouswiththe loopin the project.for infinite recursion bugs we retain the instructions related to the value change of recursion parameters.
function rewriting .
we rewrite the function and retaintheeffectandreturnvaluesofthefunction includingapi function and customfunction .forrecursive bugs we focus more attentiononretainingrecursivecallsbetweenfunctions.
reserve nameandtype .wekeeptheconsistentnameandtypeofvariables andfunctionsinourbenchmarkwithprojects.
makebenchmark executable .
we adapt the selected loops and recursion functions by putting the loops and the first function call of recursion in a mainfunctionandaddingnon deterministicinitializationforthe variablestomakethemexecutable.notethatweextractedthenontermination benchmark based on non termination bugs and the1intmain unsigned char l verifier nondet uchar while l if l loop return0 figure benchmarkprogram extracted from figure .
terminationbenchmarkfromthecorrespondingfixedversionsrelying on the above principles.
we highlight that the extraction of the recursionbenchmarkismoredifficultthanloopbecauseitinvolves moredatastructuresandfunctioncalls.finally weconstructedour benchmark set including a non termination dataset with real andreproduciblenon terminationbugsanda terminationdataset with58fixedprograms.throughourstatistics theaveragenumbersoflinesinsv comp2021benchmarksandourbenchmarks are .
and24.
respectively.
figure3shows an infinite loop and the corresponding extracted benchmarkisshown infigure .first basedonthedefinitionof loop iterator in .
the unsigned char variable lis a loop iterator inloopcondition line .therefore we retainthe sourcecode in line and to our benchmark correspond to line and infigure .othervariables v i and u1d45c canbeignoredbecause theydonotimpactanyloopiteratorsandloopterminationproperty of this benchmark.
notice that we keep the consistent name of variables l and variable type unsigned char in our benchmark with real world projects and we set lto be non deterministic.
in addition we setamain function to make itexecutable.
correctnessofbenchmark.
sincetheextractedbenchmarksmay containmistakesduetosubjective biases detailsin .
we put lotsofefforttoensuringthe correctnessofourbenchmarks e.g.
whether it can terminate or not .
first we manually verify our benchmarkwithatleastthreeco authors.onlyifalltheauthors confirmthebenchmark weaccepttheresults.fornon termination benchmarks except for themanualconfirmation we alsodirectly run the program by setting the potential bug triggering values.
we ensurethatthebenchmarkscannotterminateinhalfanhourwhich could be a reasonable indicator because our program is simple and hasnohugebound e.g.
i .forterminatingbenchmarks theoretically itisdifficulttoensurethattheprogramscanterminateforallinputs.exceptforourmanualconfirmation wefound thatexistingtoolsalso rarelydeterminethemasnon terminating whichcouldbeanindicatorforthecorrectnessofterminatingcases.
finally weconstructabenchmarkset includinganon termination datasetwith56realandreproduciblebugsandaterminationdataset with58fixedversions.notethat2non terminatingprogramsrelatedtoundefinedbehaviorareremovedfromourbenchmarkbecause they cannotbe successfully reproduced.
.
toolassessment in this section our goal is to explore whether the termination of programsinourbenchmarkcanbedeterminedcorrectlybystate ofthe artterminationanalysistools.inordertomakeourassessment 264esec fse november14 singapore singapore xiuhan shi xiaofeixie yi li yao zhang sen chen andxiaohongli.
.
.
.
.
.
.
.
.
.
.
.
.
uautomizer cpachecker 2ls a3ro9 t2our benchmark existing benchmark figure comparison results of the termination analysis tools on theexisting benchmarkandours.
moreconvincing weselectfiveexistingtoolsforconductingourexperiment uautomizer cpachecker 2ls aprove andt2 .amongthem uautomizerwonthefirstprizeinthe termination category from sv comp to sv comp .
cpacheckerand2lsrespectivelywonthesilverandbronzeforthe terminationcategoryinsv comp2020andsv comp2021.the performanceofaproveisdemonstratedintheannualinternational competitionofterminationtools andaprovegotthetopthree fromsv comp2017tosv comp2019.t2ispowerfulandmore successful than julia and tnt which is demonstrated in .therefore ourselectedfivetoolsarerepresentativetools forterminationanalysis.theversionsofthesetoolsweusedinthe experimentsare uautomizer .
.
providedversionforsv comp cpachecker .
2ls .
.
aprove providedaversionfor sv comp and t2 version .
note that we tested these fivetoolsinubuntu4.
.0withamemorylimitof14.6gibofram aruntimelimitof15min ofcputime and alimitto8 processing unitsofacpu the same configurationsusedin sv comp.
we evaluate our benchmark on the state of the art termination analysis tools however these tools cannot directly work on a part ofspecial variable typesand functionsin real worldprojects.
therefore wefirstreplacethesespecialvariabletypeswiththeir supportedtypesandrewritethefunctionswiththeformthatcanbe supported in the termination analysis tools e.g.
file type variables arereplacedbyarray.wefindthatthefivetoolsallcannotworkon the c benchmark but can work on the c benchmark.
therefore recursion benchmarks involving c characteristics e.g.
class inheritance cannot be accepted by these five tools.
in conclude we test benchmarks in c programs in total and of them are loops theothersarerecursions.weprovidereplicationpackages including log files command lines and our benchmark files on zenodo13andwemakethepackagesavailableforotherstoallow other researchers and practitioners to generate interesting ideas andbuilduponour work.
the result of these five tools on our benchmark involving special features.
ua.
refers to uautomizer and ap.
presentsaprove.unreferstounknownandwrefersto wrong.
features total cate.
ua.
cpa 2ls ap.
t2 avg.
perc.
pointer manipulation un .
.
recursion un .
.
array un .
.
data structure un .
.
over f low un .
.
w .
.
type un .
.
w .
.
bit calculation un .
.
w .
.
total un w .
.
figure12showsthestatisticalresultsofthesetoolsonourbenchmark.overall thecapabilitiesofthesefivetoolstomakecorrect verdictsdropcomparedwithexistingbenchmarks.amongthem the capabilities of uautomizer to make correct verdicts drop most from .
correctly in sv comp to correctly in ourbenchmark.besides asshowninfigure allfivetoolsprefer to answer unknown which indicates the complexity of our benchmark is more than that in existing benchmarks.
the dropping in accuracyand thepreferenceto answer unknown involvestwomainreasons duringourbenchmarkextraction we set the precondition of these programs to be non deterministic which causes an over approximation to their real preconditions and makes termination analysis more complex.
for example in figure3and figure the value of ldepends on the valuepassed when calling the function and we set lto be non deterministic.
the benchmark extracted from real world projects may contain complexcomputation e.g.
bitcalculation pointermanipulation various data structures e.g.
linked list and data type e.g.
size t .
furthermore the error rate of these tools is increased in figure .
among them cpachecker has the highest error rate i.e.
more than times the error rate in sv comp i.e.
.
.
wealsotriedtoanalyzetherelationshipbetweenthesuccessrate anddifferentcategories14.ingeneral thesetoolsperformbetter onthelogicalerrorcategorythangeneralprogrammingerrorcategory confirmedthatexistingtoolsmainlyprove non termination logically.
for logical error benchmarks since they have been manuallysimplifiedfromreal worldprojects thesetoolscouldhandle them relatively easier.
to our surprise the non terminating benchmarksabout reusingsameloopiterator cannotbehandledbyall toolsalthoughtheylookquitesimple.forothers wecouldnotfind a clear relation between the success rate and different leaf categories.
therefore we further manually analyzed the failed cases and summarized common features that revealed the weaknesses of existing tools refer to section .
.
14due to the space limit more details including the results of each tool and the results oneachcategorycanbefoundonourwebsite .
265large scale analysis of non terminationbugs in real worldossprojects esec fse november14 singapore singapore .
analysisoftheunhandled cases basedontheresultsshowninfigure comparedwiththeresults on existing benchmarks the error rate of four tools except 2ls and the unknown rate of these five tools are raising on our benchmark.therefore wefurtheranalyzetheseunhandledbugs to explore the weaknessesoftheseexisting tools.
table2shows the results that the tools cannot handle benchmarksinvolvingspecialfeatures.thefirstcolumnrepresentsthe special features that can significantly affect the results of the tools.
we also list the total number of benchmarks involving corresponding features.
the second column refers to the results that the tools analyze these programs.
first all of these special features in the firstcolumncanmaketheterminationanalysistoolsprefertoanswer unknown especially for the pointer manipulation .
.
benchmarksinvolving pointermanipulation areunhandledbythese tools.however thesespecialfeaturesarecommonlyusedinreal world which indicates that the state of the art tools are inefficient andimmature in analyzing the terminationofreal world projects.
exceptformakingthesetoolsprefertoanswer unknown somefeaturescanaffectthesoundnessofthesetools i.e.
wrong answers whichshouldbepaidmoreattention.itismainlybecause some programming errors caused by over f low type andbit calculation whichcanchangethe ideal executionofprograms are not well considered.for example on average the programs involving over f low type andbit calculation can introduce .
.
and .
wrong results respectively.
this strongly indicates that the termination analysis techniques should take these features into account to make them sound and more practical.
in addition we observe that 2ls doesnot have any wrong answersbecausethese potentialprogrammingerrorshave been considered .
finding we identify seven programming features that can pose challenges to the existing termination analysis tools.
theytendtoproduceunknownanderroneousresults .
onthe programs involving thesefeatures.
discussions .
implications for program developers.
firstly the findings from our study can help avoid non termination bugs for developers in developing programs.specifically whenworkingonloops developersshould becarefulwiththewritestoloopiteratorsandensuretheloopvariablesneverendupstayingconstant becarefulwiththereuseof loop iterators check for possible overflow and type conversion errors andcarefullychooseappropriatevariabletypes.forrecursions programmers should be careful about unexpected recursions andpay attentionto the recursion arguments andreturns.
secondly we provide useful advice for troubleshooting nonterminationbugs.specifically fixstrategiesofinfiniteloopsmainly include add missing constraints to loop conditions .
this fixes incorrectly chosen loop condition that is inconsistent with the programmers expectations.
handle specific values .
most infinite loops end up being stuck in one state.
developers should first identify the problematic program state and then handle specific values e.g.
addanifstatementand break theexecution fromtheloop forthestate.
useloopcounters .loopcounterscanlimitthemaximum executions of the loop.
this fix strategy is simple but may leadtoerrorsinsubsequentprocedures.itisareasonablechoice whenthevalueofeachvariableattheendoftheloophasnoimpact ontheexecutionofthesubsequentcode.forinfiniterecursions the developersshouldidentifyifrecursionisusedintentionally.ifso they mainly correct the argument as well as the return.
otherwise one shouldbreakfrom the recursive orcycliccalls.
for researchers.
based on the experimental results in .
w e noticed that these tools fail to work on real world projects directly and perform worse on our real world benchmark than on existingwell establishedbenchmarks.therefore existingtermination analysis tools should be improved in terms of their scalability and applicabilityonreal worldprojects.furthermore generalprogramming errors suchasoverflows should be paidmore attention in future terminationanalysisresearch.
.
threatsto validity thecollectionofreal worldprojectsmayintroducebias.tomitigate this threat we downloaded c c projects to expand the evaluation scope with our best efforts.
furthermore we further selectedfivecommonlyusedkeywordstoidentifypotentialnontermination related commits.
due to the complexity of real world projects theclassificationofthenon terminationbugsinevitably involvessubjectivebiases.toaddressthis wefilteredourdataset basedonwell thought out criteria mentionedin .
.whileconstructingthenon terminationbenchmark thenecessarysimplification and abstractionmay change the original program behaviors.
tomitigate sucha threat eachbenchmarkextractedwasinspected by two authors independently and any discrepancy was discussed until aconsensus wasreached.
conclusion inthispaper weconductedastudyof445non terminationbugs collected from real world oss projects.
with substantial manualefforts wepresentedasystematictaxonomyofnon termination bugs including categories of infinite loops and groups of recursions andfurtherextractedanovelbenchmarkincluding114 programs simplified from these bugs.
moreover we evaluated five state of the art termination analysis tools using our newly constructed benchmark and identifiedchallenges that these tools face.
finally we highlighted the limitations of existing termination analysistechniques anddiscussednewresearch directions.
data availabilitystatement thedatathatsupportthefindingsofthisstudyareopenlyavailable in andthe artifact isopenlyavailable in .