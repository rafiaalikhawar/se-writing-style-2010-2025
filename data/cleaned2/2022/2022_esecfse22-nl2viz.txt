nl2viz natural language to visualization via constrained syntax guided synthesis zhengkai wu university of illinois at urbana champaign usavu le microsoft usaashish tiwari microsoft usa sumit gulwani microsoft usaarjun radhakrishna microsoft usaivan radi ek microsoft usa gustavo soares microsoft usaxinyu wang university of michigan ann arbor usazhenwen li peking university china tao xie peking university china abstract recent development in nl2code natural language to code research allows end users especially novice programmers to create a concrete implementation of their ideas such as data visualization by providing natural language nl instructions.
an nl2code system often fails to achieve its goal due to three major challenges the user s words have contextual semantics the user may not include all details needed for code generation and the system results are imperfect and require further refinement.
to address the aforementioned three challenges for nl to visualization we propose a new approach and its supporting tool named nl2viz with three salient features leveraging not only the user s nl input but also the data and program context that the nl query is upon using hard soft constraints to reflect different confidence levels in the constraints retrieved from the user input and data program context and providing support for result refinement and reuse.
we implement nl2viz in the jupyter notebook environment and evaluate nl2viz on a real world visualization benchmark and a public dataset to show the effectiveness of nl2viz .
we also conduct a user study involving data scientist professionals to demonstrate the usability of nl2viz the readability of the generated code and nl2viz s effectiveness in helping users generate desired visualizations effectively and efficiently.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
concepts software and its engineering visual languages automatic programming .
keywords program synthesis natural language to code constraint acm reference format zhengkai wu vu le ashish tiwari sumit gulwani arjun radhakrishna ivan radi ek gustavo soares xinyu wang zhenwen li and tao xie.
.
nl2viz natural language to visualization via constrained syntax guided synthesis.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction recent development in natural language to code nl2code research allows the end user especially novice programmers to create a concrete implementation of their ideas by providing natural language nl instructions.
while code generation for generalpurpose languages such as python is still challenging nl2code for a domain specific language dsl such as sql or nl2code in a specific application domain such as competitive programming has witnessed major advances.
given that data science has seen tremendous growth in recent years data visualization has become a great application domain of nl2code .
the main reason is that data scientists need to frequently produce visualization to help them perform exploratory data analysis eda to discover useful information from data and draw insights to support decision making.
yet it is quite a burden on data scientists as they have to memorize names of data visualization apis and their many parameters .
indeed in our user study section .
data scientists confirm that they could not memorize all the api options and have to look into api documentation frequently.
972esec fse november singapore singapore wu le tiwari gulwani radhakrishna radi ek soares wang li and xie it is difficult for an nl2code tool to achieve its goal due to three major challenges.
first in the stated nl instruction the user may use words whose semantics can be determined only in the context.
for example different nl2sql approaches include different strategies to handle schema encoding to create a mapping from the user input to the entities in the database while few approaches have achieved good adaptability .
in visualization an nl2code task gets more complicated as the user may already write some code to process the data and then use the natural language to visualization nl2visualization tool.
so the tool also needs to understand the program context.
second the user may not include all details needed for code generation in the nl instruction.
for example when trying to produce a line plot the user may not specify the name of the data column used for the x axis especially when there is a data column with index or time value.
third the results of nl2code are often imperfect and thus require the user s further interaction or update to fix issues in the results.
especially in data analysis data scientists often need to make quick changes to visualization as data analysis is a data driven process.
the first two challenges on the user input may make the user s further interaction even more necessary.
to address the aforementioned three challenges in this paper we propose a new approach and its supporting tool named nl2viz in the domain of nl2visualization with three salient features.
first we leverage not only the user s nl input but also the contextual input i.e.
data and program context that the underlying query is upon.
the data context includes the data tables that the user is working on and also the intermediate data vectors that the user has produced.
the program context includes the previous code and existing plots that the user has produced including the previous instruction plot pairs produced by our nl2viz tool for the user .
for example when the user creates her own filtering function and refers to the function name in her instruction we would be able to understand and use the function in the generated plotting code by leveraging the program context.
second to better fill the missing or ambiguous details in the nl input we differentiate between hard constraints and soft constraints retrieved from the nl input and contextual input.
the hard constraints are the ones that we have high confidence in and could be explicitly specified by the user.
for example the user states that she wants a scatterplot and then the plot type to be scatterplot would be a hard constraint.
meanwhile the soft constraints are the ones that we do not have high confidence in and could be inferred from the context.
for example the user does not mention the data column for the xaxis but the column with time information would be the likely x axis data.
third we provide the user interface to allow iterative refinement for the user to further fix or change the results.
we allow the user to give additional nl instructions to make changes to the visualization.
moreover we are not only having the plot as the output but also the working code snippet that produces the plot.
the user can also directly make changes on the code snippet data scientists find making code changes convenient as shown in our user study section .
.
we implement our approach as a tool named nl2viz in the jupyter notebook environment .nl2viz is directly embedded into the user s daily workflow without the burden to switch between different environments.
at a high level nl2viz first parsesthe nl instruction given by the user using semantic parsing into symbolic constraints that the target visualization program needs to satisfy.
nl2viz also generates such constraints after retrieving the data program and existing plot context in the current notebook.
next nl2viz uses a novel syntax guided program synthesis algorithm to generate a complete visualization program from these hard soft constraints.
during this process nl2viz keeps multiple candidates at each synthesis state and assigns a heuristic fitness score to help prioritize the most likely structure.
finally nl2viz can take a further refinement nl instruction to change the generated visualization program or the user can choose to directly use or apply changes to the generated program.
we assess nl2viz using four evaluations.
first we assess the synthesis accuracy in a one shot scenario.
our benchmark contains nl instructions collected from data scientists and online homework assignments.
overall nl2viz is able to achieve an overall accuracy of .
.
second we assess nl2viz s accuracy in interactive scenarios.
given an initial plot and an instruction for describing a small change nl2viz achieves .
accuracy in scenarios.
third we also assess nl2viz in a public dataset .
nl2viz outperforms a state of the art approach in easy to medium categories while achieving comparable overall accuracy of .
.
fourth we assess the usability of nl2viz via a user study where we ask data scientist professionals to use nl2viz to complete visualization tasks.
the participants are able to successfully complete .
out of the tasks on average.
most participants like nl2viz and are willing to use it before writing actual visualization code.
this paper makes the following main contributions we propose a novel nl2code approach that aims to address challenges on the user input and interactions in the application domain of nl2visualization by leveraging the data program context retrieving hard soft constraints and providing interactive refinement support.
we present nl2viz an end to end synthesis tool implemented in the jupyter notebook environment for helping data scientists visualize their data using an nl interface.
nl2viz shows both the plot and the readable code snippet for generating that plot allowing the user to modify extend and reuse the code snippet.
we evaluate nl2viz on a real world visualization benchmark and a public dataset to show its applicability.
we also conduct a user study with data scientist professionals on real world scenarios finding that nl2viz is easy to use and helpful for generating not only plots but also readable code that could be extended and reused.
in the rest of the paper section illustrates our overall approach using a motivating example.
section discusses the implementation ofnl2viz .
section presents our evaluation results.
section discusses related work and section concludes.
overview this section provides a high level overview of nl2viz via a motivating example.
in this example a data scientist named alice wants to study the trend of covid infection in europe.
she opens jupyter notebook a popular platform among data scientists to 973nl2viz natural language to visualization via constrained syntax guided synthesis esec fse november singapore singapore figure the covid dataset sampled rows .
load a covid dataset1 figure .
each row in the dataset reports the numbers of daily confirmed cases and deaths for a country in a certain day along with the accumulated numbers of confirmed cases and deaths until that date.
alice first wants to see the trend of confirmed cases for all countries in europe.
alice understands that she needs to restrict the continent column to europe .
because there are multiple countries in europe alice also needs to group data by country before she can iterate and plot a line chart for each country.
in the plot the x axis is the date sorted chronologically and the y axis is the confirmed cases for that date.
figure 2a shows the desired plot and code.
the plotting code is non trivial.
alice not only has to pick the right functions in matplotlib e.g.
plot but also needs to process the data and construct the desired arguments for these functions.
in our user study section .
data scientists usually could not remember the usage of plotting functions and have to look up their documentation or search for similar code in help forums.
this context switching breaks the data scientists workflow and negatively affects their productivity.
in contrast alice can perform the same task in nl2viz by typing plot line showing total confirmed cases for countries in europe plot is our magic command to invoke nl2viz in jupyter notebook .
because our target audience is data scientists who have sufficient coding skills nl2viz shows both the plot and the code to produce it figure 2a .
having access to the code allows alice to tune the plot if she wants.
for instance she can modify the code to change the x axis tick labels from every days to a different number.
alice can also reuse the code.
for example alice can easily wrap the synthesized code inside a function that plots the total number of confirmed cases in any given continent and then loops over the function to create plots for all continents.
alice also has an option to interactively change the existing plots using nl.
for instance she may type plot change y label to total confirmed cases to update the y axis label or plot change to asia to change the plot to countries in asia figure 2b .
so is feasible because nl2viz also uses knowledge of existing plots when synthesizing plots from text.
our approach.
we next explain how our nl2viz approach synthesizes the desired visualization program from the following three modalities of specifications for the example from figure data program context which includes the covid dataset as shown in figure .
the visualization context which includes existing plots and their nl instructions.
an nl instruction that describes the desired visualization task e.g.
plot line showing total confirmed cases for countries in europe provided by alice as the instruction.
given these inputs nl2viz synthesizes the desired program in two steps as shown schematically in figure .
in the first phase semantic parsing nl2viz parses the three inputs into symbolic constraints.
then in the second phase program synthesis nl2viz synthesizes a complete program that satisfies these constraints.
more specifically given an nl instruction and the current data context and program context nl2viz uses semantic parsing techniques to generate a ranked list lof tuples each of which t consists of two sets of constraints a set rmust ofhard constraints and a setrmay ofsoft constraints figure shows a simplified version of our grammar for the semantic parser .
the set rmust includes hard constraints that must be satisfied by the desired program p whereas constraints in set rmay are soft indicating that they may be satisfied by p. innl2viz the constraints take the form of a subset of rules of the grammar used to generate plotting programs.
for instance for the example from figure our semantic parser generates the following tuple rmust rmay among possibly others rmust plottype lineplot yaxis total confirmed filtercolumn continent groupcolumn country filtervalue europe rmay xaxis date dataframe df here the first rule plottype lineplot inrmust is a hard constraint when we synthesize the target plotting program using the visualization domain specific language s dsl s context free grammar cfg the derivation in the synthesize process should use the rule plottype lineplot .
the hard constraints in rmust are extracted from the english instruction that directly corresponds to the user s intent.
in contrast the first constraint xaxis date inrmay is soft indicating that the program may use the date column as the x axis.
these constraints in rmay are generated from analyzing the data program context and existing plots.
since these inputs provide only contextual hints that may be useful for deriving the complete program we treat rmay as soft constraints.
once nl2viz finishes generating hard and soft constraints from specifications our second phase program synthesis synthesizes a complete visualization program from these constraints.
nl2viz synthesizes a program from the visualization cfg that uses all rules inrmust and as many rules in rmay as possible.
in the final step nl2viz translates the program in the dsl to the target language python .
for instance given the preceding tuple rmust rmay our synthesizer is able to generate the desired program pin figure 2a.
our synthesizer generates one program pifor each tuple 2note that although the nl instruction does not mention continent the parser is able to include that column because the parser could derive a relationship between europe and continent from the data context.
974esec fse november singapore singapore wu le tiwari gulwani radhakrishna radi ek soares wang li and xie a the user invokes nl2viz to obtain a plot with code.
b the user creates another plot by adapting the existing one.
figure the screenshots of nl2viz in jupyter notebook while working with the motivating example.
natural language semantic parser visualization synthesizer visualization encoding data program contextnl2viz context encoder production rules existing charts figure the workflow of nl2viz .
tiinland finally returns a program pthat has the smallest cost among all pi s. the cost of each derivation is defined later in section .
.
given the nl instruction in figure 2b the semantic parser returns the hard constraint set rmust filtervalue asia filtercolumn continent .
the soft constraint set rmay now also includes the constraints of the previous plot.
given these constraints nl2viz is able to adapt the plot in figure 2a to the plot in figure 2b with minimal human guidance.
we next discuss the design and the implementation of nl2viz .
nl2viz natural language to visualization figure depicts our overall workflow for converting the given nl instruction to visualization code.
first we use a semantic parser to extractrmust the set of constraints that must be used from the user provided nl instruction.
we then analyze the data program context to extract a set of constraints that may be used i.e.
rmay .
finally our synthesis algorithm synthesizes the program in our visualization domain specific language from the extracted constraints and translates the program into python.root plotelems plotelems plotelem plotelems ?
plotelem histoelems filterelem groupelem histoelems histoelem histoelems ?
histoelem histotype column bins stack log density groupelem grouptype groupcolumns groupoperator figure simplified version of the nl grammar.
plot plt data mappings plottype legends data dataset process data processor processor filter ... groupby ... orderby ... mappings nil list mapping mappings mapping xaxis xaxis scaling ?
options ?
yaxis ... ... scaling range float float log scaling step scaling float ... options stacking options transparent options ... plottype histogram scatter lineplot ... legends legend title string labels ... labels label xaxislabel string yaxislabel string ... figure simplified visualization dsl.
.
parsing nl instruction to constraints figure shows a partial simplified version of our attribute grammar nl grammar used to parse an nl instruction to constraints.
we design this grammar by analyzing online tutorials visualization courses and jupyter notebooks with high upvotes in the kaggle competitions .
we attach semantic rules in the form of sattributes to the grammar.
each nonterminal in the nl grammar is 975nl2viz natural language to visualization via constrained syntax guided synthesis esec fse november singapore singapore associated with a list of attribute value pairs which corresponds to the semantics of this nonterminal.
given an nl instruction we use a semantic parser which uses an enhanced cyk algorithm to parse the instruction into a list of attribute value pairs.
these pairs form ourrmust set.
figure shows a simplified parse structure for the example in section .
we obtain the parse structure by making the following enhancements to the cyk algorithm.
setting attribute values for terminals.
we use annotators to initialize the attribute values.
for example for the nonterminal column we have an annotator columnvalue that parses the token europe into a columnvalue nonterminal symbol.
the columnvalue annotator maps one or multiple consecutive tokens to a value in some column in the given dataset.
by using annotators the semantic parser is able to parse tokens in a data context sensitive manner e.g.
parsing europe as a columnvalue and inferring continent as its columnname and program context sensitive manner e.g.
parsing foo as a function name if a function of that name appears in the jupyter notebook code cell .
setting attribute values for rule n n1n2.the attributes are propagated from children to parent following the semantic rules.
most semantic rules just propagate the lists of attributes from children to parent without change.
however in some cases the semantic rules can change the attribute name in children s list.
for example in the filterelem symbol the attribute columnvalue changes its attribute name e.g.
columnvalue becomes filtervalue .
fitness score.
each nonterminal also has a fitness score in the range of to represent the probability of producing that parse structure.
for instance the token countries does not exactly match the column name country in the dataset hence its symbol column is given a score of .87based on the edit distance of the two strings.
the score of a parent symbol is simply the product of the scores of its children.
note that our nl grammar is inherently ambiguous to capture different interpretations of an nl instruction.
from an nl instruction our semantic parser produces multiple parse structures each of which has armust set and a fitness score.
.
using data program context to construct may use constraints because the instruction usually does not contain all information necessary to synthesize the visualization i.e.
rmust is not complete nl2viz uses multiple heuristics to infer the potential omitted information i.e.
rmay from the data program context.
for example when plotting a scatter plot if the mapping of data columns to axes is not evident from the user s nl instruction our approach prefers a categorical column to be on the x axis.
our heuristics in nl2viz also capture popular data preprocessing patterns .
for example if the user wants to plot a line plot but we find that there are multiple points on the same x axis coordinate in the dataset then it is likely that there is an inherent grouping step by the column on the x axis before plotting.
nl2viz analyzes each column to determine a the type of values in that column b whether the column is categorical and c all the distinct values in that column.
we use this information to create rmay.
for example even if the instruction in figure does not mention continent in the text nl2viz infers that auxcolumn continent in the filterelem rule based on data insights and adds it to rmay.
.
designing visualization domain specific language given the sets ofrmust andrmay our synthesis algorithm synthesizes a visualization program in a domain specific language dsl .
figure shows a simplified version of this visualization dsl nonterminals start with uppercase letters function symbols start with lowercase letters and terminals are within quotes .
programs in this dsl are then translated to a target visualization library such asmatplotlib orseaborn in the final translation step.
to design this dsl we first perform a preliminary study on the jupyter notebook dataset released by felipe et al.
.
based on the stats of different plots used in the dataset and the documentation of popular visualization libraries such as mathplotlib seaborn and ggplot2 we include the frequently used plot types and parameters including the column to be plotted and the size color style of the visualization element.
additional grammar rules in rlink these parameters with the corresponding plot type.
based on the analysis of the plotting code fragments collected from the jupyter notebook dataset we also include rules in r that perform data preprocessing operations .
for example we observe that three commonly used typical patterns of data preprocessing are filtering grouping and ordering hence we extend the grammar rulesrto include rules that perform these steps.
.
constrained syntax guided synthesis having defined the nl grammar and the visualization dsl we next illustrate our main synthesis algorithm algorithm .
the algorithm takes a grammar g terminal sett nonterminal setn production rulesr start symbol plot and a pair rmust rmay of must use and may use constraints used for constraining derivations as input informally a derivation is application of a grammar rule toward generating the target program.
the algorithm returns a program generated by g generating which undergoes a derivation that satisfies rmust and minimizes the cost function.
in the visualization dsl we begin with the start symbol plot and perform a series of derivations to further extend to a complete program.
more formally a derivation is a sequence of terms that start with the start symbol plot and each subsequent term is obtained from the previous term by applying a production rule in g. if we use p1 r1p2to denote that p2is derived from p1by applying r1 then a derivation of p denoted by d can be written as plot r0p1 r1p2 r2 pk rkp a program is incomplete if it contains a non terminal symbol.
a complete program contains only functions and terminal symbols.
976esec fse november singapore singapore wu le tiwari gulwani radhakrishna radi ek soares wang li and xie root plot elements lineplot elem columnlineplot type line total confirmed countriesproperty plottype line score .
inproperty plottype line column to plot total confirmed filter column continent filter value europe group column country score .
europe cases forproperty column total confirmed score .6columnlineplot elementgroup element column valueproperty column continent column value europe score .0filter elementproperty column to plot total confirmed score .
property column country score .875property filter column continent filter value europe score .0property group column country score .
showing figure the parse structure for the motivating example.
example .
the derivation for the first program shown in section is shown in parts below with some simplification plot plt data mappings plottype legends data 3process process dataset processor processor dataset df processor filter filtercolumn filtervalue processor group groupcolumn group country mappings 2list mapping list mapping nil mapping xaxis xaxis x date mapping yxis yaxis y total confirmed plottype lineplot legends labels labels xaxislabel yaxislabel 2labels date total confirmed the algorithm works by maintaining a worklist that consists of tuples p d c where pis a potentially incomplete program generated by derivation dwhose cost is c. in each iteration the algorithm works by picking an element p d c from the worklist.
if the program pcannot be completed to a program that satisfies rmust determined using a subroutine feas or the current cost c is already more than the best cost found so far we just prune this search branch and continue with the next iteration line .
if not then we further process this tuple p d c .
we first check whether pis already a complete program line and if so we update the best solution found so far and continue to the next iteration lines .
if pis not complete we apply all possible single step rewrites to pand add new items to our worklist lines .
we next describe the subroutine feas d rmust that checks whether derivation dsatisfies the constraint rmust .
ifdis a complete derivation generating a complete program then feas d rmust returns true iff all rules in rmust are included in derivation d. since we aim to satisfy all constraints in rmust and as many constraints inrmay as possible for each derivation we define its cost to be equal to the number of the production rules used in this derivation that do not belong to the set rmay.
in the following definition of the cost function we use the notation d ito denote the subderivation s r0 p1 ri pi of the derivation dconsisting ofthe first irule applications.
if dhaskrule applications d k d. given the may use constraint rmay the cost of a derivation dis defined as follows cost d rmay k i 1coste ri d i rmay where the elementary cost function costeis defined as coste r d rmay 0ifr rmay 1otherwise the cost of a derivation is simply the number of rules in the derivation that are not included in rmay.
note that cost d rmay 0iff every production used in dlies inrmay.
.
extension to an interactive system we have implemented our approach with a supporting interactive tool.
after nl2viz synthesizes the first python program and shows the generated plot if the user is not satisfied with it then the user can give another nl instruction to refine the plot.
in the subsequent re synthesis runs nl2viz uses additional information from the program context the production rules used to generate the previous programs are included in the set rmay as may use production rules to help the synthesizer prefer programs that are similar to the previously generated programs.
evaluation we implement our approach as a python package that registers a magic ipython command plot in the popular jupyter notebook environment .
hence a user can input plot a histogram of cylinders to obtain an appropriate plot see figure .
the jupyter interface for nl2viz also supports rudimentary auto complete suggesting column names keywords and pre processing function names.
the data for plotting is assumed to be in the form of a dataframe object from the widely used pandas library .
we choose matplotlib and seaborn as the target plotting libraries for the generated code.
977nl2viz natural language to visualization via constrained syntax guided synthesis esec fse november singapore singapore algorithm branch and bound for csygus.
inputs a cfgg n t r s a pair rmust rmay of constraints ong output a programpwhose derivation dingsatisfiesrmust and has minimum cost under cost d rmay 1p null best program found so far 2c cost of the best program found so far 3q s s worklist queue 4whileq do p d c remove an element from q iffeas d rmust is false orc c then continue end ifphas no nonterminals then 10p p 11c c continue end 14r all rules inrapplicable on p foreachr rdo add p d r p c toqwherep rp and c c cost e r d rmay end 18end 19returnp figure the auto mpg dataset sampled rows .
our evaluation aims to answer four specific research questions rq1 one shot accuracy.
how accurately can nl2viz produce the target plot from a single nl instruction?
how effectively can the data program context help nl2viz resolve ambiguities in the user s nl instruction?
rq2 plot and change accuracy.
how accurately can nl2viz create a new chart from an nl change instruction?
how much does the user benefit from nl2viz in this scenario in terms of the instruction length reduction?
rq3 comparison with the state of the art.
how does nl2viz compare with other related state of the art tools for visualization synthesis?
rq4 usability.
how usable and accurate is nl2viz in a real setting?
benchmark.
we collect 303nl instructions for 54plots from two sources.
auto mpg plot descriptions.
in this source there are 267manually written nl instructions for 18plots selected fromonline tutorials that use the auto mpg dataset3 which contains technical specifications of cars as shown in figure .
these nl instructions are provided by 15professionals with experience in data science.
homework and covid assignments.
we also collect 36scenarios from homework assignments and jupyter notebooks that use covid datasets in github.
in these scenarios we use the problem statements as the nl instructions and the plots as the expected results.
we exclude 5instructions from these scenarios in which the plot types are not supported by nl2viz .
nl2vis dataset.
luo et al.
publish an nl2visualization dataset named nl2vis .
the nl2vis dataset is generated by applying a neural network based nl2sql to nl2vis model on a popular nl2sql dataset named spider .
although the nl2vis dataset has an impressive number of nl vis pairs we find that the dataset mainly focuses on the data preprocessing steps as most visualizations in the dataset are a direct presentation of the output by a sql query from the spider dataset without the plot options such as formats and legends.
so we evaluate nl2viz on the nl2vis dataset in only rq3 to compare with the results reported in luo et al.
s paper .
.
rq1 results one shot accuracy correctness.
we classify the output plots of nl2viz into four separate types based on how well they match the ground truth exact match.
in this case the output of nl2viz exactly matches the ground truth.
functionally equivalent.
in this case the output plot is functionally equivalent to the ground truth plot but differs in a minor often visual detail.
for example when the instruction does not specify that a histogram should have normalized frequency on the y axis the ground truth does use frequencies while nl2viz produces a histogram using counts instead of frequencies.
however the two plots are functionally equivalent for most purposes.
therefore we also consider this type to be correct.
functionally different.
in this case the output plot differs from the ground truth in significant details.
for example the output plot has an axis plotted using a linear scale while the ground truth uses a logarithmic scale.
no match.
here the produced plot is completely different from the ground truth.
we differentiate functionally different from no match because in a no match case often the time the semantic parser is not able to capture the intention from the nl instruction while in a functionally different case usually the synthesizer is not able to synthesize a reasonable program indicating that we should extract more may use constraints with higher accuracy.
when measuring the accuracy we consider the exact match and functionally equivalent types to be correct and functionally different and no match to be incorrect.
results.
the results of the evaluation are summarized in table .
overall nl2viz is able to produce the correct output in .
of the cases with .
being an exact match and .
being 978esec fse november singapore singapore wu le tiwari gulwani radhakrishna radi ek soares wang li and xie table accuracy of nl2viz .
the columns em fe fd and nm denote exact match functionally equivalent functionally different and no match respectively.
category correct incorrect em fe tot.
fd nm tot.
total homework auto mpg total auto mpg easy auto mpg hard table accuracy of the baseline approach nl2viz without context and data understanding .
category correct incorrect em fe tot.
fd nm tot.
total homework auto mpg total auto mpg easy auto mpg hard functionally equivalent .
of the remaining .
of the cases are functionally different.
to further analyze the results we separate the auto mpg instances into two categories hard andeasy based on whether the plot requires or not additional data preprocessing steps and additional parameters not in the input or dataframe.
the idea to differentiate hard and easy plots is due to the observation that in an easy scenario the synthesizer should be able to generate a correct program using only or mostly must use constraints while in a hard scenario some information of the plot is often missing or vague in the nl instruction such that the synthesizer requires enough may use constraints to generate a correct program.
among the plots 8are categorized as easy and 10as hard.
as shown in table the system achieves an accuracy of .
and70 in the easy and hard cases respectively.
we discuss the failure cases below.
analysis of failure cases.
for the homework category the main reason for failures is missing context the homework assignments often contain relevant data in previous discussions or problems.
in the two no match cases in the auto mpg easy category the semantic parser interprets the parameter representing point sizes as a group by column.
for example for the input scatter plot of mpg and acceleration with point size by cylinder the semantic parser interprets cylinder as a group by column instead of a parameter for the point size.
most functionally different cases in both the auto mpg easy and auto mpg hard categories involve bin sizes in histograms.
for example for the input plot a bar graph that shows me the number of rows with mpg in range to to and so on nl2viz is unable to identify the bin sizes due to the limitations of its dsl grammar.
for the auto mpg hard category the limitation of nl2viz is in the parsing of the filtering or group by clauses.
for example the input fragment yearly orannual represents the group bymodel year clause in the auto mpg dataset.
however nl2viz is unable to do these translations in a fraction of the cases.
as mentioned in section .
we choose to use a context free grammar to represent the nl instruction because the grammar would cover most cases.
however for words such as yearly orannual that are functionally equivalent to the column name model year we are unable to enumerate and cover all equivalent words in the grammar.
recent developments in the field of detecting equivalence via extrapolation present a potential solution and we believe that these scenarios can be correctly handled with better nl understanding.
effect of context and data understanding.
we also run a baseline synthesizer whose results are shown in table .
the baseline uses only nl information extracted using the semantic parser described in section .
and does not use the data program context.
as expected the code generated by the baseline approach in certain cases is incomplete.
for example in the instruction plot scatter average mpg by cylinder there is an inherent group operator since it is required to calculate the aggregation function average for the mpg column.
however the cylinder column cannot function as both the column for the x axis and group column resulting in a missing group operation.
tables and show that using the data program context substantially improves the results especially in the auto mpg hard category.
in particular no cases of the auto mpg hard category can get exact match results because all the plots in this category require information from the data context.
performance.
we measure the performance of nl2viz by the execution time.
it turns out that nl2viz is quite efficient and we set a timeout bound to be 30seconds.
the average execution time for an instruction is around 3seconds and of the instructions finish within 5seconds.
there are 3instructions causing timeout all of which are in the auto mpg hard category.
they all have a length of more than 150characters with the longest one being characters resulting in timeout in the phase of semantic parsing.
.
rq2 results plot and change accuracy this section shows the evaluation results of nl2viz with respect to rq2 i.e.
in the setting where nl2viz is provided with an already existing plot and a change instruction.
for example the initial plot could have been generated given the instruction scatter plot of mpg and acceleration grouped by cylinders and the change instruction can be change to average mpg and accleration .
for the initial instruction an initial plot is generated such that each car is a single point colored based on the number of cylinders.
for the change instruction a plot should be generated such that each point corresponds to a group of cars with the same number of cylinders with the coordinates given by average mpg and average acceleration.
table shows the information about the 40tests.
we separate the plots into the easy and hard types based on whether contextual information is needed to generate a plot.
further we group the change instructions into the replace andadd categories replace change instructions replace the value of some plot aspect with another while add change instructions add a new aspect to a plot.
979nl2viz natural language to visualization via constrained syntax guided synthesis esec fse november singapore singapore table results of change experiments.
the columns avg.
initlen.
avg.
chglen.
avg.
finlen.
and avg.
red.
stand for average initial instruction length average change instruction length average final instruction length and average instruction length reduction in correct cases respectively.
instruction length is in the number of characters.
plot type change category total correct avg.
initlen.
avg.
chglen.
avg.
finlen.
avg.
red.
easyadd .
.
.
replace .
.
.
hardadd .
.
.
replace .
.
.
add replace .
.
.
we do not consider the delete category in most practical scenarios users start with a simple plot and add more complexity over time.
accuracy results.
table shows the accuracy results of nl2viz on the change experiments.
we find that nl2viz performs well in general achieving .
accuracy correct out of total .
nl2viz is more effective in processing add instructions than replace instructions.
replace instructions change an existing correct aspect in the plot.
hence nl2viz needs to both locate the aspect to be replaced and parse the new aspect correctly.
while in an add instruction because the new aspect usually does not interfere with existing rules nl2viz just needs to add the new aspect.
instruction length results.
we also evaluate how much instruction length is saved by the change instruction.
for each initial instruction and change instruction pair we also generate a combined instruction from which nl2viz can produce the intended plot in one attempt.
in terms of absolute numbers we can see that the average length of a replace instruction is higher than that of an add instruction due to the need of specifying both the component to replace and the replacement.
on the other hand the average length of a combined instruction is higher than that of an add instruction due to the additional information added by the combined instruction.
we also measure the average instruction length reduction given by1 length change instruction length combined instruction .
we evaluate the setting where the user has already used the initial instruction to create a plot and later wants to update it either by using the change instruction or directly using the combined instruction.
we find that in general we achieve instruction length reduction via the interaction enabled by the change instructions.
we achieve higher reduction in theadd change category since the combined instruction text has to specify both the old and new aspects while the change instruction has to specify only the new aspects.
analysis of failure cases.
we note that the add change category has a higher accuracy than the replace change category because the aspect that the user wants to replace is often implicit in the change instruction.
in the example in section the change instruction is change to asia .
in this instruction by the help of data context it is easy to infer that the aspect needs to be replaced is europe .
however in some cases it is unclear whether the instruction is to change an existing aspect or to add a new aspect.
for example when the initial instruction is plot scatter of mpg versus model year which would cause to produce a scatter plot with each point representing a car and its mpg y axis versus model year x axis .
the change instruction is change to average mpg for all cylinders .table comparison with the state of the art.
deepeye nl4dv seq2vis nl2viz easy .
.
.
.
medium .
.
.
.
hard .
.
.
.
extra hard .
.
.
.
overall .
.
.
.
the idea of this change is to produce a final instruction that is plot scatter of average mpg for all cylinders .
the final plot is a scatter plot where x axis represents cylinder number and y axis represents average mpg.
in this case the for all cylinders in the instruction text represents a replace change.
however it can also be the case that the final instruction is plot scatter of average mpg versus model year group by cylinders .
in this case the final plot is a scatter plot where x axis represents model year and y axis represents average mpg with different cylinders having points with different colors on the plot.
.
rq3 results comparison with the state of the art luo et al.
report the accuracy of their neural translation modelbased tool seq2vis along with two other rule based and semanticparser based tools deepeye and nl4dv on a test set containing nl vis pairs from their nl2vis dataset.
due to the different target libraries of nl2viz and the nl2vis dataset matplotlib vs. vega lite although it is possible to translate one to another we find it not reasonable to directly compare the visualization programs as different programs may lead to the same or the essentially same plots.
we also notice that in luo et al.
s paper they measure the tree matching accuracy to compare their seq2vis tool with other tools.
the tree matching accuracy measures whether the flow of data transformation for each data column and its corresponding data shown on the axis are correct.
therefore for each test case we need to manually examine whether our synthesized visualization program is equivalent to their program which is the labeled output.
we are able to manually verify the nl vis pairs sampled from their pairs test set.
we treat our output to be correct if it is an exact match or functionally equivalent as defined in section .
.
table shows nl2viz s accuracy against other state of the art tools on the nl2vis dataset.
out of the sampled pairs there are visualizations that are currently not supported by nl2viz .
first 980esec fse november singapore singapore wu le tiwari gulwani radhakrishna radi ek soares wang li and xie .
.
.
5question 4question 3question 2question 1tasks succeeded figure the distribution of succeeded tasks and scores among participants.
we can see that nl2viz outperforms the other two rule based tools by a large margin in all difficulty groups.
the reason is that our tool supports the synthesis of data preprocessing steps while the other two tools do not have support or have only very limited support.
when compared to seq2vis a neural translation model based approach we find that in the easy and medium categories our nl2viz tool outperforms seq2vis .
a possible reason is that the easy cases here are similar to the easy cases in section .
and the medium cases here are similar to the hard cases and for both categories we see similar accuracy as that in section .
being .
vs. .
and .
vs. .
in these two categories our nl grammar and visualization dsl can cover the target visualization program.
therefore we are able to achieve higher accuracy than a learning based approach by using constrained syntax guided synthesis.
however in the hard and extra hard cases the accuracy ofnl2viz declines drastically.
the reason is that the nl instructions in these two categories are usually generated from nested sql queries especially for the extra hard category.
our grammar or dsl does not cover such data processing steps therefore it is impossible for nl2viz to produce correct visualization.
overall nl2viz achieves lower but comparable accuracy compared with the seq2vis tool while being able to achieve higher accuracy in easy to medium cases without the need for training data.
nl2viz also outperforms existing rule based approaches by a large margin by leveraging the data program context.
.
rq4 results usability and interaction to evaluate the usability of nl2viz we ask volunteers who have an average of .
years of experience in data science to complete plotting tasks using nl2viz .
among the plots in the tasks there are histogram bar charts scatter plot and line plots.
each participant is first asked to answer multiple background questions and is then given an explanation of the auto mpg dataset.
next we ask the participants to complete the tasks in order until they are satisfied or are not willing to try nl2viz any more.
each participant is given 20minutes to finish all 5tasks.
then the participants are asked to rate nl2viz on a scale of least positive to most positive on the following aspects question .
do you find nl2viz easy to use?
question .
do you find it easy to interpret the code generated by nl2viz and change for future usage?
question .
do you want to use nl2viz before you do visualization in future?
question .
isnl2viz able to understand your input?
on average the participants successfully complete .
out of tasks.
figure shows that the participants are generally in favor ofnl2viz with an average of 4out of for all questions.
the high variance for question 3is due to that participants with high expertise who are very familiar with writing visualization code strongly do not prefer to use nl2viz .
suggestions from the participants highlight two major issues.
three participants s2 s4 and s6 suggest that nl2viz should have a built in feature of highlighting to show which part of their natural language corresponds to which part of the generated code.
this feature would help users change their input when nl2viz misinterprets their intention.
another suggestion is to modify nl2viz to produce multiple candidate plots for the same input s1 s2 and s3 .
it is fairly straightforward to modify our semantic parser and synthesizer to produce multiple candidates and we intend to make this modification.
other suggestions include allowing for click selecting columns as an input modality s3 displaying a confidence score for the generated plot s6 and a separate cleaning step before visualization s5 .
related work natural language to visualization.
the idea of using natural language nl as a query interface for visualization is getting popular with the development in nl2code .
tong et al.
present datatone a mixed initiative approach to address the ambiguity problem in nl interfaces for visualization.
unfortunately because datatone is not publicly available we could not perform a direct comparison between datatone and nl2viz .
zhang et al.
propose text to viz whose usage scenario is quite different from ours.
text to viz is a visualization recommendation tool that focuses on data exploration.
it does not support precise nl instructions to a specific visualization.
instead the user s input works as a guide to explore charting options on certain columns or combination of columns.
we find it not fair to compare text to viz s accuracy on our dataset as it is not designed to produce visualization with the nl instruction provided.
similarly sun et al.
propose articulate a two step process to generate visualization from the given nl instruction.
first it parses the nl instruction into commands using supervised learning.
it then generates visualizations for the commands using heuristics.
articulate also focuses on data exploration instead of synthesizing precise visualization according to the given nl instruction.
narechania et al.
propose nl4dv which has similar functionalities as nl2viz .
it is also integrated into the jupyter notebook environment while producing the results in the vega lite format .
however nl4dv relies on only the nl instruction to generate the visualization.
it checks the data only to identify the database entities in the nl instruction without leveraging other contextual information from the data program context.
similarly it also lacks the ability to create the necessary data preprocessing steps.
luo et al.
publish a public dataset named nl2vis consisting of nl vis pairs.
they propose a nl2sql to nl2vis model to translate the nl sql pairs in the popular spider 981nl2viz natural language to visualization via constrained syntax guided synthesis esec fse november singapore singapore dataset to the nl vis pairs.
luo et al.
also propose a learningbased approach named seq2vis based on the seq2seq model used in nl2sql tasks.
they evaluate their approach on the dataset by comparing it with two other approaches namely nl4dv anddeepeye which is a keyword based approach previously proposed by them too.
they find their approach largely outperforms the other two approaches.
however since the spider dataset is an nl2sql dataset.
their approach focuses only on how the output is calculated using the data transformations defined in the sql query.
the nl instructions in the nl2vis dataset completely ignore important options of visualizations such as formats and legends.
despite this dataset s limitations we also evaluate nl2viz on this dataset in section .
.
it is worth noting that unlike nl2viz the preceding related approaches do not support further refinement on the result limiting the ability of users to further modify or reuse the results later in other tasks.
rong et al.
propose codemend which uses neural network to infer the correspondence between the given nl query and functions parameters in the target visualization program.
similarly setlur et al.
propose evizas which allows users to refine existing visualizations by asking questions or direct manipulation.
however both approaches lack the ability to generate complete visualization code and also cannot generate the necessary data preprocessing steps.
these approaches can be seen as complementary with nl2viz these approaches can be combined with the interactive technique in nl2viz to provide better user experience after the first shot query.
visualization recommendation.
visualization recommendation focuses on producing the recommended visualization encoding based on design domain knowledge .
dominik et al.
present draco which represents a visualization as a set of logical facts and thus converts visualization design patterns into a set of constraints.
it then uses constraint solving to recommend the best visualization scheme based on the collection of domain knowledge.
ding et al.
present quickinsights to discover interesting patterns from multi dimensional datasets by formalizing the notion of interesting patterns insights and present them as visualizations.
siddiqui et al.
propose an interactive visual analytic platform named zenvisage to find desired visual patterns from large datasets.
it extends vispedia proposed by chan et al.
which performs only a keyword query of collected graphs.
while the output of nl2viz is also a visualization the focus is different.
visualization recommendation tries to follow visualization design patterns.
nl2viz focuses on eliminating the ambiguity in nl instructions by bringing insights from data.
nl2viz is also extensible and can be integrated with existing visualization recommendation approaches.
syntax guided synthesis.
the constrained syntax guided synthesis problem is an extension of the syntax guided synthesis sygus problem first introduced by alur el al.
.
our constrained sygus problem asks for a program that is not only generated by the given grammar but also uses specific rules and non terminals of the grammar.
successful solution strategies for sygus are based on bottom up enumeration model based quantifier instantiation and top down search over the grammar .
hu et al.
consider qsygus a variant of the sygus problem wherea cost model given by a weighted tree automaton assigns costs to programs and the task is to generate the minimal cost program that satisfies the semantic constraint.
the solution used by hu et al.
is however infeasible in our setting due to the the presence of derivation constraints.
conclusion in this paper we have presented a novel nl2visualization approach and its supporting tool named nl2viz for automatically synthesizing visualization programs from a user s nl instruction.
the key idea underlying our approach is to leverage not only the nl instruction but also the other contextual information namely data context and program context and then convert the different kinds of specifications provided by the user into symbolic constraints which can be used to generate the desired visualization programs using syntax guided program synthesis.
moreover nl2viz includes an interactive interface for allowing the user to further refine and reuse the resulting visualization.
we evaluate nl2viz on a realworld visualization benchmark and a public dataset to show the effectiveness of nl2viz .
we also perform a user study involving data scientist professionals to demonstrate the usability of nl2viz the readability of the generated code and nl2viz s effectiveness in helping users generate desired visualizations effectively and efficiently.