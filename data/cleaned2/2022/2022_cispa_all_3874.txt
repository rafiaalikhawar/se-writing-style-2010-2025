clifuzzer mining grammars for command line invocations abhilash gupta abhilash.gupta cispa.de cispa helmholtz center for information security saarbr cken saarland germanyrahul gopinath rahul.gopinath cispa.de cispa helmholtz center for information security saarbr cken saarland germanyandreas zeller zeller cispa.de cispa helmholtz center for information security saarbr cken saarland germany abstract the behavior of command line utilities can be very much influenced by passing command line options and arguments configuration settings that enable disable or otherwise influence parts of the code to be executed.
hence systematic testing of command line utilities requires testing them with diverse configurations of supported command line options.
we introduce clifuzzer a tool that takes an executable program and using dynamic analysis to track input processing automatically extract a full set of its options arguments and argument types.
this set forms a grammar that represents the valid sequences of valid options and arguments.
producing invocations from this grammar we can fuzz the program with an endless list of random configurations covering the related code.
this leads to increased coverage and new bugs over purely mutation based fuzzers.
ccs concepts software and its engineering software testing and debugging .
keywords fuzzing cli options command line utilities acm reference format abhilash gupta rahul gopinath and andreas zeller.
.
clifuzzer mining grammars for command line invocations.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
https introduction command line utilities are programs that use the command line interface cli as their user interface.
such programs are the mainstay of the unix environment as well as numerous other operating systems.
the command line interface that these utilities rely on follow a simple formula utility parameter permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
utility ls optexpr a l w int .
.
.
int i i positive integers argument f f files figure the invocation grammar of ls excerpt here the parameter s are either command line switches such as a v etc.
which control some behavior of the program being invoked or data such as a file name that is being passed into the program to be processed.
given their importance numerous previous studies have focused on testing command line utilities.
however one limitation of all these studies is that they only fuzz the stdin of programs under fuzzing either ignoring the options that the program accepts or using a specific sequence of options .
unfortunately we cannot simply treat a command line as if it were just another input source as cli utilities expect specific options with a specific syntax.
a recent approach to invocation fuzzing thus has turned to parse program documentation including the output produced by the help option to obtain a set of valid options.
however as with all documentation this information may be non existent incomplete or no longer up to date.
in this paper we introduce clifuzzer a tool that automatically determines option syntax from code.
our technique is based on the observation that most utilities use a standard option parser such asgetopt for parsing their options an observation we first made in in a chapter in the fuzzing book textbook testing configurations .
here we prototyped an instrumention of the python argparse argument parsing module in order to create a grammar of command line parameters.
clifuzzer now turns this prototype into a full fledged command line fuzzer for c programs using getopt .
however the getopt specification string is not sufficient to obtain a grammar as it does not reveal the types of the individual arguments.
hence we also extract the type of argument that the utility expects by tracking which calls to runtime library functions get an argument from the command line.
as a result clifuzzer obtains a grammar that accurately describes valid input parameters for the utility under consideration.
figure shows a fragment of the final grammar recovered from ls.
clifuzzer uses this grammar to produce an endless sequence of valid invocations effectively fuzzing the command line.
the getopt function the standard clibrary functions used to parse command line invocations are getopt getopt long and 1667esec fse november singapore singapore gupta et al.
getopt long only .
these functions have two arguments that define the possible options.
theoptstring argument is a string which contains information about the short options of the utility.
the structure ofoptstring is described by the grammar below.
optstring prefix optionletter prefix optionletter letter letter letter w letter c c ascii is graph c each letter in the optstring represents an option that may be present in command line parameters.
a letter may be followed by a which means that that option if present in the parameters requires an option argument.
as an example of processing consider the options to ls.
the lsutility accepts among others two short options aand lthat are essentially boolean switches while wtakes an argument that specifies the column width as an unsigned int .
this is encoded into an optstring alw .
the longopts argument is a pointer to an array of the struct option which describes the long options accepted by a utility.
this struct is described in listing .
listing struct option 1struct option const char name name of the option int has arg does the option expect an argument ?
int flag flag for returning results int val the value to return long options such as long are stored as string in the name field of an option .valis the value to return when encountered a value of l makes long an alias for l which is intended.
mining parameter specifications clifuzzer uses context free grammars enriched by a few generative predicates as the parameter specification.
we construct this grammar in three steps.
converting option string to a context free grammar converting option arguments to predicates and arguments to predicates.
.
constructing grammars from option specs in this step we convert the short option optstring and long option longopts specifications to a context free grammar.
in order to mine these specifications we use shadow versions of getopt variants that log the parameters they were called with.
we use a shared library that contains the shadow variants.
this shared library is force loaded into the utility under evaluation by overriding ld preload .
hence when the utility is invoked the option specifications are logged.
once clifuzzer has extracted the optstring the algorithm in listing constructs the list of short options expected by a utility in the grammar.
at this stage the grammar encodes the argumentrequirement of all options but does not reflect their type and defaults them to strings.
similarly the set of long options is also extracted and inserted into the grammar.
listing constructing grammar options from optstring 1def gen options optstring grammar options ifoptstring options .
append letter optstring optstring elif optstring in optstring optstring while optstring optchar optstring optstring ifoptstring option s s optchar str options .
append option option s optcha r options .
append option optstring optstring elif optstring option s s optchar str options .
append option optstring optstring else option s optchar options .
append option grammar options return grammar the algorithm in listing first checks whether the given optstring starts with a hyphen.
if it does it indicates that the utility accepts any unspecified option letters without an immediate error postponing validation for later section .
hence we append letter to the context free grammar to account for this fact.
if the optstring starts with or it affects how missing arguments are indicated to the program.
however it has no direct impact on option specification.
hence we skip over these letters.
within the while loop we extract each option letter and check if any are followed by or .
if an option letter is followed by a single colon it indicates a mandatory option argument while a double colon indicates an optional option argument.
these are used to update the context free grammar.
long options from longopts is a data structure that does not require parsing and is directly translated to the context free grammar.
.
mining option argument types the next step in clifuzzer is ascertaining the type of optionarguments expected by options.
for this clifuzzer starts by scanning libc looking for functions that take a string argument.
clifuzzer then injects shadow variants for each of these functions such that invoking any of these functions would result in the arguments being logged.
clifuzzer invokes the program under test with a random argument for each option expecting arguments to determine the kind of argument required.
for example if the option takes in a filename as argument the utility calls open orstat variants to operate on 1668clifuzzer mining grammars for command line invocations esec fse november singapore singapore the passed argument.
similarly a utility would call one of atoi orstrtol s variant functions and one of atof orstrtod s variant functions to parse integer and floating point number arguments respectively.
.
arguments to predicates the final step in clifuzzer grammar construction involves determining the argument requirements of the utility.
arguments to utilities are similar to option arguments except that utilities can expect multiple arguments.
hence the utility is invoked with multiple number of arguments to determine how many arguments the utility expects and the type of argument is determined similar to option arguments from section .
.
.
using clifuzzer clifuzzer is implemented as clifuzzer .
a sample invocation that extracts the grammar from the lscommand is as follows 1clifuzzer get grammar o ls.
json .
coreutils ls this extracts the invocation grammar of lsto the file ls.json .
given this grammar one can fuzz the lscommand as follows 1clifuzzer f g ls.
json o ls.
out .
coreutils ls the goption specifies the invocation grammar and foption specifies how many invocations to produce.
evaluation for our evaluation we fuzzed the latest versions of command line utilities written in candc in linux.
these utilities use one of the getopt variants to parse their invocation.
we specifically chose those utilities that used one of the getopt variants for parsing as our grammar construction is dependent on mining specifications from getopt .
we also limited our study to utilities that take at least one file argument so that we have at least one entry point for delivering completely random input for fuzzing.
our subjects include seven of the nine utilities as bison dc gdb ptx spell andtroff that reported failures in linux by miller et al .
the number of options of the utilities ranged from to mean .
std deviation .
.
the lines of code of the utilities ranged from to mean .
std deviation .
.
clifuzzer logs the execution results in five groups crashes exit code .
unresolved invocations exit code .
passing invocations exit code .
graceful handling of invalid options exit code .
exceptions such as timeoutexpired .
for each utility we look for crashes and exceptions.
any exception found is manually verified to check whether it was a hang or happened by design e.g.
waiting to read from stdin .
we then manually replicate and confirm the failures.
.
comparison with afl to evaluate whether clifuzzer is able to progress beyond the state of the art we used afl as the baseline producing file and stdin inputs.
for fuzzing with afl each utility had a set of small valid seed inputs size 1k which we produced by hand such that when the utility in question read the file it returned exit code .
we ran afl for three hours on each utility without any options in its invocation.
we evaluate how much options can influencetable utilities reporting failures in their latest versions as bc bison cat cmp col colcrt column colrm comm cut dc diff expand fmt fold gdb grep head join look m4 nl nm od paste pr ptx rev sdiff spell strings strip sort tac tail tee tr troff tsort unexpand uniq wc xargs utilities where miller reported a bug but has not yet been fixed in the latest versions are italicised .
new failures found in latest versions by clifuzzer are bolded .
coverage by comparing the coverage achieved by clifuzzer and afl respectively.
afl fuzzed each utility for three hours.
clifuzzer performs better than most of those utilities.
it performs significantly better for some utilities such as spell andcolumn than others.
this observation can be explained on the basis of the utilities set of options.
the improvement in clifuzzer s code coverage for a utility is directly proportional to its number of valid options.
when a utility has a large set of valid options clifuzzer achieves significantly better coverage than afl since options do not form a part of afl s fuzzing process.
when a utility does not have a lot of valid options or even no options e.g.
revortsort then clifuzzer covers comparable code or marginally more than afl .
during the fuzzing campaign afl found crashes in gdbandcol.
the crash in gdbis same as what clifuzzer found while clifuzzer could not replicate the crash in col. this is because the input needs to contain particular characters in a particular order which clifuzzer s input generation technique did not achieve during its runs but afl did because of its coverage driven fuzzing nature.
.
comparison with miller et al.
another relevant baseline is the fuzzing effort by miller et al.
.
our effort here is to verify that clifuzzer can at least replicate the bugs that were found by miller et al.
on the particular versions that miller et al.
tested.
clifuzzer is able to replicate all of the failures reported in the latest study on utilities in linux conducted by miller et al .
in fact our approach finds an extra failure a crash in spell .
we also observe that asandptx s failures are triggered only when particular options are used12.
.
exploration of utilities finally to understand whether current utilities are robust we also run our fuzzer against the current versions of all utilities looking for any bugs that still exist.
we tested the latest versions of all utilities.
our findings were that in almost all cases the bugs have not been fixed despite their publication in the previous study.
the only exceptions are spell which fixed its crash issue in the latest version but not its hang issue and bison which fixed its hang issue in the latest version but 1as new a l8 2ptx