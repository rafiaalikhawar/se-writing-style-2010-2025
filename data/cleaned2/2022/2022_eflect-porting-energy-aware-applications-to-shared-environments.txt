eflect porting energy aware applications to shared environments timur babakol tbabako1 binghamton.edu suny binghamton binghamton ny usaanthony canino acanino1 binghamton.edu suny binghamton binghamton ny usayu david liu davidl binghamton.edu suny binghamton binghamton ny usa abstract developing energy awareapplicationsis awell knownapproach tosoftware basedenergyoptimization.thispromisingapproach is however faced with a significant hurdle when deployed to the environments shared among multiple applications where the energy consumption effected by one application may erroneously be observed by another application.
we introduce eflect a novel software framework for disentangling the energy consumption of co running applications.
our key idea called energy virtualization enables each energy aware application to be only aware of theenergy consumption effected by itsexecution.
eflect is unique in its lightweight design it is a purely application level solution thatrequiresnomodificationtotheunderlyinghardwareorsystemsoftware.experimentsshoweflectincurslowoverheadwithhigh precision.
furthermore it can seamlessly portexisting applicationlevelenergyframeworks oneforenergy adaptiveapproximation and the other for energy profiling to shared environments while retaining their intended effectiveness.
ccs concepts software and its engineering software performance.
keywords energy accounting energy profiling power disturbance concurrency acm reference format timur babakol anthony canino and yu david liu.
.
eflect porting energy aware applications to shared environments.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
.
introduction energy efficiency in server class computation platforms has sig nificant impact on environmental sustainability as well as oper ational cost.
energy aware applications emerge as a critical dimension of energy efficient computing.
an energy aware application is awareof its own energy consumption during the execution and the observation can in turn guide application specific energy optimization.
in software engineering two prominent use permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrightsforthird partycomponentsofthisworkmustbehonored.
for all other uses contact the owner author s .
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
c underlying os and hardwareif w 4j acc .
else acc .
energy reflection underlying os and hardwareenergy reflectiond b method 3j method 5j applicationapproximation policyenergy profileenergy aware application a energy adaptive approximation b energy profiling figure energy awareness in shared environments scenarios of energy aware applications are energy adaptive approximation andenergy profiling .
in fig.
a application amay adpatively adjust some application specific accuracy parameter accin the example based on prior energy consumption of some work unit w. in fig.
b an energy profiler c whose runtime is defactoanenergy aware application maywishtodetermine the energyconsumptionofdifferentlogicalunitswithinanapplication such as which method consumes more energy m1orm2.
.
the challenge shared environments energy aware applications are supported through energy reflection i.e.
the ability of an application to observe its own energy consumption.
naively exposing hardware energy data to the application however is fundamentally unsound in sharedenvironmentswhere multiple applications co exist.
to gain intuition on why well designed energy aware applications may ill behave in shared environments let us revisit fig.
.
in fig.
a a co running application b energy awareornot mayincurenergyconsumption.
the raw energy consumption wduring the execution of the work unit may include that incurred by b. as a result application amay degrade its accuracy to .
even though the energy consumption due to its execution remains lower than 4j.
similarly the hardware energy consumption during the m1 orm2 execution in c may include that incurred by d the quality of profiling results is severely discounted due to the noise introduced by d. the unfortunate phenomenon here is a fundamental hurdle againstthe portability ofenergy awareapplications awell behaved software system at the idealized exclusive development site illbehavesattherealisticshared deployment site.thelackofportabilitydirectlychallengesthe correctness ofenergy adaptiveapproximation and the usability of in situ energy profilers.
from time shared os to cloud computing platforms running applications in a shared ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa timur babakol anthony canino and yu david liu environmentisabasicneedinmoderncomputing.inthatsense the portability of energy aware applications in shared environments is critical for the future adoption of this promising technique.
this overlooked problem is hitherto only addressed by a small number of os centric solutions .
in other words to support energy aware applications service providers must modify existing osinfrastructure that impacts all applications and all usersontheserver achallengingcaseforadoptioninpractice.this is particularly bad news to software developers the feasibility of their solution energy aware applications becomes dependent of whether the os in the deployment environment has adopted the os features that commodity os do not support severely limiting the benefit of energy aware applications.
.
our solution eflect we introduce eflect a novel and lightweight software framework thatallowsenergy awareapplicationstogracefullyporttoashared environment without anymodificationto theos.
the key insight of eflect is tointroduce anintermediate layer of energyvirtualizationduring energy reflection so that the application in a shared environment can only observe itsshare of energy consumption with the illusion that it is exclusively responsible for the energy consumptionwhenitperformsenergyreflection.eflectvirtualizationsignificantlysimplifiesthe interface betweentheapplication and the underlying system and prevents the otherwise impedance mismatch between the development site and the deployment site.
the portability of energy aware application is achieved in that an energy aware application can make the strong assumption that all itsenergyconsumptionobservationindeedresultsfromitsownexecution regardlesswhetherthedeploymentenvironmentisshared.
the central problem eflect addresses is to compute an application s share of energy consumption in a shared environment.it continuously monitors both the application behavior and the underlying system behavior with several unique features whole stackmonitoringwithminimalinterface.
determiningthe application share of energy consumption in a shared environment requires a clear accounting of the complex behavior of the systems stack.eflectisasophisticatedframeworkthatinternallymonitors a rich number of states the activities of individual threads within an application the activities of individual applications in a shared environment the mapping between the application threads and the os threads the affinity of the threads and their migration and the raw energy consumption by the cpus across multiple energy domains.
the most important observation however is that eflect iscapableofhidingthesedetailswithinitself and leavingaminimal interface to the energy aware application.
the design philosophycan be summarized as let us worry about these details so an energy aware application developer does not have to.
an application level solution with decentralized monitoring.
unlike existing os centric solutions eflect is built at the level of the application a significantly more lightweight approach without the need of any vm os hardware modification.
each energy aware application in a shared environment is monitored by an individual instance of eflect and there is no coordination across differenteflect instances.
this fundamentally decentralized design prin ciple is a win for incremental deployment an eflect monitored application can not only work with existing os and hardware but also can it co run with arbitrary applications the co running applications may or may not be monitored by eflect and may not even be the same language runtime.
fine granularity.
eflect is a fine grained andonlinesolution thatinformstheshareofenergyconsumptionfor everytimeinterval inmillisecondscale oftheapplicationexecutionof everythread in theapplicationwhiletheapplicationisrunninginasharedenvironment.underthehoodof eflect theactivitiesoftheapplication as well as the activities of the entire underlying system are also monitored at this fine granularity and the relative ratio between the two is used to determine the energy reflection for each time interval and each thread in each application.
.
results we evaluate eflect through co running state of the art multithreaded java benchmarks with representative server workloads fromthedacapobenchmarksuite togetherwithtensorflow .
our results show eflect is capable of achieving energy virtualization with high precision and low overhead.
as end to end case studies we further investigate how to integrate eflect with two application level energy management frameworks aeneas forenergy adaptiveapproximation and chappie for energy profiling and seamlessly transition them to a shared environment.
to the best of our knowledge eflect is the first applicationlevel solution for porting energy aware applications to a shared environment.overall thispapermakesthefollowingcontributions a novel application level software framework for energy reflection in shared environments a systematic evaluation on the precision overhead and scalability of the framework acasestudyonhowourframeworkmayportexistingenergyadaptive approximation solutions to shared environments acasestudyonhowourframeworkmayportexistingenergy profiling solutions to shared environments eflect is an open source project and it is endowed with an api that allows the framework to be programmed for different porting needs.
the project is hosted on an anonymous github site motivating scenarios in this section we motivate the need for eflect with concrete examples of challenges when deploying energy aware applications in shared environments.
.
porting energy adaptive approximation one example of an energy adaptive approximation framework is aeneas .
in aeneas alternative algorithms and application parameters can be programmed as knobs and a goal for optimization can be defined by the programmer as a reward e.g.
the joules consumedforsomeunitofworkintheapplication.atruntime aeneas dynamically adjusts program knobs to find a reward optimal authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
eflect porting energy aware applications to shared environments icse may pittsburgh pa usa a an aeneas run of sunflow when co run with another sunflow b an aeneas run of sunflow when co run with eclipse figure aeneas monitored co runs of sunflowwith another application each graph is a representative trace of a run.
the x axis represents the units of work frames in elapsedtime.thedottedhorizontallinerepresentsthesla.
combination of knobs that meets the reward target also known as service level agreement sla .
for example aeneas may monitorsunflow a popular ray tracing benchmark.
a knob can be set for managing the level of image post processing quality less post processing produces an approximated image with less energy consumption.
processing each frame of sunflow can be defined as a unit of work and 35j can be set as the sla for processing aframe.
in an environment where only one aeneas runtime is inplace experiments show that aeneas is effective in convergingon the knobs that meet the sla .
in other words the energy consumption per frame will approach 35j as time goes on.
porting aeneas to a shared environment ho wever is non trivial.
figure2showstworunsofanaeneas monitored sunflow eachin asharedenvironmentco runningwithanotherapplication.first inbothsubfigures aeneasappearstohaveadifficulttimetoconverge atthetargetslaof35jquickly.indeed infig.2a asthe250 thframe isstillrenderedwithmorethan35j itisuncleariftheslawillever bereached.second theconvergencebehaviorof sunflow offig.2a and that of fig.
2b are different.
in other words the same energyaware application with the same setting may end up behaving differently depending on what other application is co running.
.
porting in situ energy profilers an energy profiler example is chappie .
given an application chappie is able to produce an energy footprint i.e.
the relative a h2profile in a single application environment b h2profile when co run with sunflow figure3 chappieenergyfootprintfor h2 thex axisrepresents the percentage of energy consumption consumed by a particular method.
the y axis lists the methods with top energy consumption.
energy consumption of program methods.
figure 3a shows a footprintproducedbychappie thetop 10energyconsumingmethods are shown for brevity for h2 a transactional database.
here it shows the top energy consuming method of the application valuedatatype.compare and the relative difference in energy consumption between any pair of methods.
porting chappie for deployment site in situ energy profiling in a shared environment however is a challenge.
figure 3b shows energy footprint produced by chappie for h2in the presence of a co running instance of sunflow.
while the top consuming method valuedatatype.compare remains stable the ranking of the remainingmethodsisdifferentfromtheresultinasingle application environment.
for example valuedatatype.comparevalues and valuearray.getmemory swap their positions in the ranking.
the root problem is that when the energy consumption of a method sayvaluedatatype.comparevalues is profiled by chappie the co running sunflow also incurs energy consumption which may be incorrectly attributed to the method.
eflect design overall eflect performs whole stack monitoring to determine the share of energy consumption an application incurs in a perthread and per time interval manner.
an algorithm specification is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa timur babakol anthony canino and yu david liu algorithm eflect algorithm 1typedef pid int process id 2typedef tid int thread id 3typedef eidenum e1 e2 ...en energy domain id 4typedef energy float energy in joules 5typedef activity float activity in jiffies 6typedef samplestruct 7 map angbracketlefteid energy angbracketright per domain energy 8 map angbracketlefteid activity angbracketright per domain activeness 9 map angbracketlefttid eid angbracketright thread affinity 10 map angbracketlefttid activity angbracketright per thread activeness 12typedef venergy map angbracketlefttid energy angbracketright virtual energy 13v list angbracketleftvenergy angbracketright virtual energy store 14interval int sampling interval 15function main 16p getcurretprocess 17loop at rate interval s dosample p 19v dovirtualize s 20function dosample p pid sample 21s newsample 22forein e1 e2 ...en do s. eflectenergy e s. eflectactivity e 25fortingetdomainthreads e do 26ifp getpid t then s. e s. eflectactivity t 29return s 30function dovirtualize s sample venergy 31v newvenergy 32for each t e ins.
do v s. s. s. 34return v 35function readenergy p pid venergy 36v newvenergy 37for each vinvdo v v 39return v 40function eflectactivity tid activity obtain thread activity 41function eflectactivity eid activity obtain domain activity 42function eflectenergy eid energy obtain domain energy reading 43function getcurrentprocess pid obtain current running process 44function getdomainthreads eid tid obtain processes in an energy domain 45function getpid tid pid get thread s process id shown in algorithm .
for readers unfamiliar with the applicationsystem interaction w.r.t.
energy consumption we first provide a background.
a primer on the system stack.
server class computers generally consist of multiple sockets.
in mainstream multi core cpus a socket coincides with the conceptual notion of the energy domain the hardware unit where energy consumption is reported andwherethevoltageandfrequencycanbeindependentlyadjusted through dynamic voltage and frequency scaling dvfs .
in other words when one core in an energy domain is adjusted toa particular frequency all cores in the same energy domain areadjusted to the same frequency.
in our algorithm we represent these energy domains by e1 e2 ...en line .
the per domainenergy consumption is represented as a mapping in the sample structure collected at each time interval.
duringthelifetimeofanapplication athreadmaymigratefrom one cpu core to another.
the cpu core occupied by a thread is known as affinity.
it is represented as a mapping in the sample structure.
as the energy domain is the granularity for which we canobtainrawenergyreadings italsoservesastheunitforthread affinity a thread may migrate between cpu cores within an en ergy domain but will not produce an observable difference in its contribution to the underlying energy readings.
the activities of individual applications in the os are represented through some abstract notion of time used by a process.
time keeping is a basic service universally supported in practical os.
in linux compatible systems the most widely known representation of time that indicate process thread activities is the jiffy.
for example linux periodically updates the number of jiffies the threads of a process consumes in the user mode and in the kernel mode.
in addition the same form of time keeping is also supported for hardware i.e.
how much time the cpu is actively running any process.
in our algorithm the thread activity information is represented as a mapping and the hardware activity information is represented as a mapping both in the sample structure.
algorithmoverview.
eflect first obtains the process id of the monitored application through getcurrentprocess line .
as shown by the top level loop at line eflect continuously monitorsthebehaviorofanapplication andateach interval itsamples the underlying hardware and operating system resources line and performs virtualization line i.e.
determining the shareof energy consumption attributable to the application thread ofinterest.
each step of virtualization produces a piece of virtual energydata i.e.
the energy consumption due to the application represented as venergy.
structurally each piece of virtual energy data is a mapping from each thread in the application tid to its respectiveenergyconsumption energy .as eflectproceeds it accumulates venergy data in structure v which eflect exposes to the monitored application we will discuss this interface at the end of this section.
notation is standard assignment and denotes list addition.
let us now focus on the two core steps in the loop sampling and virtualization.
sampling.
functiondosample lines20 representsasingle sampling of underlying hardware and operating system resources.
each step of sampling populates a sample lines .
eflectgathers the energy eflectenergy of each energy domain andrecords this information in map at line .
hardware activity in the form of jiffies per energy domain is also sampled stored in map at line .
for each thread that belongs to the application wemonitor line26 werecorditsaffinityinmap anditsactivity in map at line and line .
function eflectactivity is overloadedtoinspectosactivitieseitherbythread orbyhardware.
virtualization.
we compute the share of energy consumption due to the application through function dovirtualize line .
it returns a value of venergy i.e.
a mapping from the application s threads to their computed share of energy consumption from the raw sample collected from the underlying system.
logically this authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
eflect porting energy aware applications to shared environments icse may pittsburgh pa usa means we assign a thread a share of energy consumption based upon its slice of activity on an energy domain.
recall that we use os time jiffies to represent the level of activities of a thread.
the curious question is why times e rv e sa sa goodattributingfactorfor energy.inphysics energyiscomputedas the multiplication of powerand time.
an important insight here is that within an energy domain all cores share the same voltage and frequency andasaresult the samepower accordingtodvfsdesign.
more concretely given a sample swith thread affinity mapping s. for each thread tand its associated domain e line we computes.
s. i.e.
the proportion of e s activity that came from t. because we have energy measurements associated with energy domains weattributeaportionofthedomainenergyconsumption s. to thread tbased upon its proportional activity on that domain on line .
virtualization hides the details of wherea thread performed its work on the system.
if a thread tmigrates from energy domain e1 toe2 dosample will capture tlatest location upon a subsequent sampling the associated round of dovirtualize will take the threads latest energy domain into account.
from the application s viewpoint it sees that its threads consume energy but does not need concern itself with any of the details.
overall dovirtualize anditshelperdosample mustbeaware of underlying system details os jiffies os affinity cpu energy domains but all such details are hidden from the client appli cation the latter only needs to be aware what share of energy consumption it is attributed for.
recall the key design philosophy of our framework let eflect worry about the details so that an application developer does notneed to.
abstractionandcustomization.
eflectisanopenprogrammable framework that supports flexible customization.
in our algorithm specification it is important to observe that our discussion on energydomains threadaffinity andthreadactivityareall abstract independent of specific hardware topology os file system structures or platform specific representations.
while these latter details may beimportanttotheimplementation theyareagnostictotheoverallprocedures of dosample and in particular dovirtualize.
in other words our virtualization algorithm itself is platform independent.
eflect exposes an api for developers to specialize eflect to theirownsystems.thesefunctionsarelistedatlines40 .wealsoprovideasimpleprogramminginterfaceforeflecttointeractwith the application it monitors.
the primary function is readenergy which returns the accumulated energy attributed to the monitored application definedasthesumofentriesin v.severalapivariants are also supported such as timer based read.
the simple design here is aligned with the design goal of eflect exposing a minimalinterfacetotheapplication.inaddition itdecouplestheapplicationfromthevirtualizationprocess theapplicationcanquery itsenergy consumption at a pace it wishes which may differ from interval .
forexample inourcurrentimplementation see rawenergy consumptionvaluesarereadthroughqueryingahardwareregister a common feature in intel architectures.
alternatively users working with alternative cpu architectures may need to re implement the readenergy function to address their specific architectures or query the a d converter values of the external energy meter if energy values are obtained through a meter.
the remaining logicof eflect does not need to be changed.
as a second example our current implementation focuses on the most dynamic portion of energyconsumptioninserver classplatforms thecpuandmemory sub systems but a user can also write her own readenergy function to further include energy consumption values of network adaptors storage systems etc depending on need.
eflect implementation eflect is implemented in java and its runtime shares the jvm of the monitored application.
we now describe our default implementation of our api on a multi socket intel platform with linux details in .
.
our implementation of the eflectenergy api function resorts to the intel rapl interface to obtain energy samples.
these samplesarecollectedusingjrapl ajavalibraryforinterfacing with rapl.
as intel rapl reports energy samples per cpu socket eachcpusocketcorrespondstoanenergydomaininouralgorithmspecification i.e.
e1ande2.eachenergysampleisacombinationof socket energy consumption from cpu cores cpu uncore caches tlb etc and memory.
ourimplementationoftheeflectactivityapifunctionqueries the linux jiffy information through the procpseudo file system so that each sample collection is effectively a file system read.
recall that eflectactivity is an overloaded function that may either collect hardware jiffies or thread jiffies.
we gather the former through proc s subdirectory stat and the latter through proc s subdirectorynamedbyeachpid.ineachsubdirectory thejiffiesareseparated by user time kernel time interrupt time and nice time forinvokingutilitiesorshellscriptswithaparticularpriority .our activity data is the sum of them.
in the case of hardware jiffies the per core data are also aggregated per energy domain.
the getcurrentprocess getdomainthreads and getpid api functions are implemented with simple linux features.
the firstfunctionisimplementedbythe glibcsyscall getpid.thesecond function is implemented by searching the proc task directory.
the third function is implemented by parsing the data in proc task stat.
theinterval is set at 40ms.
the considerations of this setting are three folds.
first jiffies in linux are updated at 4ms by default so any rate higher than 4ms sample is unlikely to observe jiffychanges.second energysampling especiallyatahighrate maydisturb the energy behavior of the original application .
we choose to set the rate at one magnitude lower than 4ms so that nobenchmark we experimented is disturbed.
third the 40ms appears to incur low overhead with high precision detail in .
.
one implementation consideration is that querying rapl and the os file system synchronously may serialize both.
worse if one returnswithadelayduetounexpectedsystemevents bothmaybe delayed.
in our implementation both are sampled asynchronously each with a thread producing information to a buffer.
the threads are managed by a threadpoolexecutor .
with this design each iteration of dosample only involve efficient buffer lookups.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa timur babakol anthony canino and yu david liu experimental validation one experimental evaluation aims to answer the following questions.rq1 can eflect virtualize energy consumption of applications in a shared environment with decentralized and fine grained monitoring?
rq2 what is the precision runtime overhead and scalability characteristics of eflect?
rq3 can eflect help developersporttheirenergy awareapplicationstoasharedenvironment while retaining their effectiveness in energy management?
we answerrq1andrq2in this section and defer rq3t o .
.
experimental setup weevaluateeflectonadualsocketintele5 2630v42.20ghzcpu server with 64gb ddr4 of ram.
each socket cpu has cores virtual cores with hyper threading enabled.
the machine runs debian .
os linux kernel .
with the default debian power governor.
all experiments were run with java on top of hotspot vm build .
.
lts.
we evaluate eflect through co running state of the art multithreaded java benchmarks with representative server workloads spanning scientific computing databases graphics graph processing and machine learning.
most of our benchmarks come from the latestreleaseofthedacapobenchmarksuite whichweselect for two reasons.
first dacapo is arguably the most widely usedbenchmark suite for evaluating the performance of non mobile multi threadedjavaapplications.second thenewestreleasehassignificantly expanded the data size of several benchmarks sunflow andh2 and more importantly it includes some new benchmarks such as graphchi for graph processing and biojava for bioinformatics representative of the recent workloads.
to further evaluate eflect against machine learning workloads we also managed to haveeflectmonitortensorflow inasharedenvironment.each instance of tensorflow classifies images using a dnn inception v3 .
for each experiment we exclude harness setup time and run a benchmark for iterations with the first discarded as a warmup.
fig.
shows benchmark statistics.
.
eflect virtualization to answer rq1 we evaluate eflect s virtualization in a shared environment where each application is an instance of eflect.
as a result each application produces a virtualized energy trace ofits runtime.
to visualize we present the normalized energy share trace defined as a time series where each data point is the fraction of energy attributed to the eflect monitored application over the entire hardware energy consumption of the same time interval.
examples of homogeneous and heterogeneous workloads are presented in figs.
and .
in each figure the time stamps start when all co running benchmarks have started its 6thiteration and end immediately before any of the co running benchmarks completesits10thiteration recallthatwediscardtheresultsofthe first iterations .
we align the traces from each application based on timestamps and stack them on top of each other.
since the 1version evaluation git 8b7a2dc released in june workload total threads active threads execution time s avrora large .
batik large .
biojava default .
eclipse large .
graphchi huge .
h2 large .
jython default .
pmd large .
sunflow large .
xalan default .
tensorflow inception v3 .
figure benchmark statistics workload refers to the data sizespecifiedbydacapoforeachbenchmark theirdetails can be found on dacapo s website2.
total threads shows the number of the threads created throughout the lifetime of theapplication.activethreadsshowsthemaximumnumber of the concurrent threads at any interval.
execution time is averaged across runs when the application is not co running with other applications.
these statistics were produced with the experimental setup described in .
.
decision making of energy attribution is decentralized the sum at each timestamp is not guaranteed to be .
according to eflect both instances of sunflow in the homogeneous run observe approximately of hardware energy over the course of the runs aligned with our intuition of co running two similar cpu intensive applications.
note that eflect does not result in a naive even split of system energy as one sunflow instance receives greater virtualized energy the other receives less as can be seen at timestamp .
eachofthetwoinstancesof tensorflow exhibitsasymmetric workload distribution across two sockets.
interestingly we found that when instances of tensorflow co run each instance would choose one cpu socket to place the vast majority of its workload and this results in asymmetric workload distribution.
as shown in fig.5b thegreenapplicationinstancedominatestheuseofsocket1 while the red application instance dominates socket .
despite the asymmetric behavior however the key observation is that for both sockets the stacked energy consumption approximates at .
this result is aligned with our intuition that eflect divides up systemenergyacrossapplicationsatapertimeintervalgranularity despite the decentralized instances of eflect at work.
in the first heterogeneous case shown in fig.
6a we examine sunflow and h2.
the energy is not uniformly distributed with nearly being consumed by sunflow.
this is not surprising as sunflow is cpu bound while h2is i o bound.
in the second heterogeneous case in fig.
6b we examine h2and pmd.althougheflectreportsdifferentutilizationofeachsocketfor the applications the total energy is more evenly distributed with h2consuming .
of the total energy pmdconsuming .
and the rest is attributed to the os.
as a source code analyzer pmdis also i o bound so it is expected that the energy is more evenly shared across the two i o bound benchmarks.
first observe that the benchmarks exhibit phased behaviors on both sockets where energy utilization goes through significant fluctuation in a near periodic fashion.
second despite the fluctuations the sum of the two benchmark s normalized energy use is relatively stable indicating the vast majority of energy use is distributed to the two authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
eflect porting energy aware applications to shared environments icse may pittsburgh pa usa a two co runs of sunflow.
b two co runs of tensorflow.
figure normalized energy share traces of homogeneous co runs the red line is vertically stacked on top of the greenline withthegreenlineshowsthenormalizedshare of one application and the red line shows the sum of that of both.
the x axis represents the elapsed time.
a co run of sunflow green and h2 red .
b co run of h2 green and pmd red .
figure normalized energy share traces of heterogeneous co runs the red line is vertically stacked on top of the greenline withthegreenlineshowsthenormalizedshare of one application and the red line shows the sum of that of both.
the x axis represents the elapsed time.
applications.sometimestampsinsocket2aretheexceptiontothis trend.
this is possible when both benchmarks are waiting for i os.figure raw energy traces for co runs.
the red line is verticallystackedontopofthegreenline withthegreenline shows the energy consumption in joule of one application during an interval and the red line shows the sum of that of both.
the black line shows total energy consumed by the hardware socket duringtheinterval.thex axisrepresents the elapsed time intervals.
before we proceed we would like to distinguish between the normalized energy share trace we introduced earlier and the raw energy trace a time series of raw energy consumption.
an example is shown in fig.
.
as this figure shows the hardware energy consumption does fluctuate as time elapses.
the top flat line in fig.
and fig.
instead reveals that the overall share in percentage of energy consumption attributed to the applications is close to all consumed by the hardware.
in the rest of the section we address rq2.
.
scalability we next evaluate how eflect virtualization scales with an increasing number of applications.
scalability is important in applying eflect in a production like environment where the server may consolidate applications.
resultswithadditionalinstancesarepresentedinfig.
.overall the data is consistent with what was shown in fig.
as the number of applications increases similar energy shares are intuitively divided among the co running applications.
the consistency here is remarkable in the presence of dencentralization each eflect runtime makes independent decisions on how energy share is com puted and they happento match up well without any coordination.
one interesting observation is that the variations in energy behaviorbecomemorepronouncedastheapplicationcountincreases in the co run figure the up and down of individual lines exceptthetopline aremorenoticeablethanthoseofa3co runfigure.
the resource competition between applications is exposed which is expected from cpu intense workload.
despite the fluctuations of individual applications eflect is capable of achieving a stable sum the top line the sum of all individual energy shares is around and remains flat throughout the runtime.
in fig.
we further show a heterogeneous co run of eflectmonitoredapplications.again sunflow dominatestheenergyshare around75 followedby xalan around18 thenby graphchi around and finally by h2.
this is aligned with our general knowledgeonthecpu intensivenessofthesebenchmarks.furthermore observe that the top line closely matches of hardware energy consumption.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa timur babakol anthony canino and yu david liu a co runs b co runs c co runs figure8 normalizedenergysharetracesofco runswith35sunflow co runs.
the red line is vertically stacked on top ofthe greenline with thegreenline showsthenormalized share of one application and the red line shows the sum of that of both.
the x axis represents the elapsed time.
figure normalized energy share traces of heterogeneous co runs of sunflow xalan h2 and graphchi .
the red line is vertically stacked on top of the green line with the green line shows the normalized share of one application and the redlineshowsthesumofthatofboth.thex axisrepresents the elapsed time.
.
precision precision evaluation for energy accounting in the shared environment is a challenging task.
in particular note that it would be unsoundtoconsidertheenergytraceofanapplicationwhileitruns in isolation as a baseline and compare it against its energy tracewhile co running with others.
indeed co scheduling e.g.
isaclassictechniqueforimprovingenergyefficiency andthisoptimization is rooted on the fact that an application while co running mayexhibita differentenergybehavior i.e.
lessenergy thanwhen it runs in isolation.
thedecentralizednatureof eflectprovidesaninterestingalternativeforprecisionevaluation.akeyinsightfromourdiscussionof fig.
fig.
and fig.
is that the top flat line is aligned with our intuitionofprecision despitethedecentralizeddecision makingbyindividualeflectruntimes thesumoftheirindividualenergycon sumptionshouldaddupclosetothehardwareenergyconsumption.
asignificantmisalignmentbetweenthetwowouldbeanindication that eflect mis attributes energy.
weconcretizeourintuitionwithtwometrics gapandcorrelation to study the precision of eflect.
gap is defined as the average normalized distance between the sum of raw energy consumption of individual applications and the raw energy consumption of the hardware per time interval.
correlation is defined as the pearson s correlation coefficient pcc betweenthestackedrawenergytraceoftheapplicationsand therawenergytraceofthehardware.asametric gapindicatestheoverallmis alignmentbetweenwhateflectattributesandwhatthe machine consumes.
correlation in addition offers further evidence on alignment by taking the temporal dimension into consideration.
the gap and correlation results are produced using the data collected in the virtualization experiments and are presented infig.
10a and fig.
10b respectively.
observe that across all benchmarkswith2 co runs theaveragegapis low averagedat .
indicating the misalignment is small.
the correlation is high with an average of .
where .
is the golden standard for strongly correlation.
overall the combination result of low gap and high correlation provides evidence on the precision of eflect.
moreencouragingly ourprecisionresultsscaleswiththenumber of applications.
when compared with their counterparts of co running instances co running more than instances does not appeartoimpactprecisionsignificantly bothingapandcorrelation.
it is worth pointing out that eflect is capable of attributing the energy consumption due to systemcalls to the calling application because the jiffies we use for attribution consist of both kernel mode jiffies and user mode jiffies for each application see .
.
overhead we now discuss the impact of eflect on execution time.
we compute the percentage difference of the execution time between anoriginal benchmark run and an eflect monitored run.
over allbenchmarks eflect incurs a .
overhead for co running benchmark instances as shown in fig.
10c.
the same figure shows overhead appears to scale reasonably well.
as seen here the overhead does not appear to follow a trend ofincreasewhenthenumberofapplicationsincreases.forexample as the number of runtime instances increases neither batiknor h2 shows a pattern of increased overhead.
.
raw additional data our project website contains the full raw data.
it also includes corunscenariosthatweleaveoutduetospace suchasheterogeneous authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
eflect porting energy aware applications to shared environments icse may pittsburgh pa usa a gap b correlation c overhead figure precision and overhead.
the number after the benchmark name indicates the number of co runs.
combinations or the precision and overhead results for other benchmarks when co running applications are or instances.
eflect case studies toanswer rq3 wenextperformtwocasestudiesofportingenergyaware frameworks with eflect.
.
eflect for aeneas wefirstdemonstratethebenefitofportingaeneastoenableenergyadaptive approximation in a shared environment with eflect.
fig.
shows two aeneas runs of sunflow while the application is monitored by eflect which corresponds to the same a co run with another sunflow b co run with eclipse figure eflect monitored aeneas enhanced co runs of sunflowwithanotherapplication thex axisrepresentsthe unitsofwork frames inelapsedtime.thedottedhorizontal line represents the sla.
experiments we introduced in fig.
.
as shown eflect greatly enhances aeneas optimization in a shared environment.
in fig.
11a aeneas quickly converges to the target 35j sla after frames as opposed to its counterpart s sub optimal convergence without eflect in fig.
.
in addition the sunflow co run with eclipse in fig.
11b also converges in a similar time frame.
fig.
shows a co run of aeneas enhanced sunflow where both applications are aeneas enhanced each targeting a different sla.
this presents a challenging environment for both eflect virtualizationandtheaeneasoptimizer bothinstancesof aeneasenhanced sunflow s perform online adaptive approximation with eachinstancepotentiallyadjustingthesystemenergyconsumption whileeflecttriestopresentastablevirtualizationfortheother.as itturnsout eachinstanceof aeneas enhanced sunflow converges to the their respective target sla.
.
eflect for chappie for our second case study we use eflect to port chappie energy profiling to a shared environment in particular we study the stabilityof chappie energy footprints of co running applications.
we firstrunchappieonasingleinstanceofeachapplicationtoproduce a representativeenergy footprint and thenco run twoinstances of each application with chappie using eflect as a virtualization layer to produce two energy footprints.
we define the stability as authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa timur babakol anthony canino and yu david liu a sunflow instance with 35j sla b sunflow instance with 70j sla figure eflect monitored aeneas enhanced co runs of 2sunflow swithdifferentslas thefirstapplicationtargets 35jsla andthesecondtargets70j.thex axisrepresentstheunitsofwork frames inelapsedtime.thedottedhorizontal line represents the sla.
the pcc between each multi application energy footprint and the single instance footprint aligned through method names.
we detail these results in fig.
.
the data shows that chappie energy profiling results remain highly stable while being portedto the shared environment.
the co run energy footprints highly correlate with their single instance counterparts which indicates thataprogrammerusingchappie eflecttoprofileanapplication willseeconsistentenergyprofileseveninasharedenvironment.in other words despite co running multiple applications may indeed change the energy trace of each individual application the relative standingof methodenergyconsumptionwithineachapplication depends more on the logic within each application and it remains stable.
fig.
shows a computed footprint for h2.
this footprint is consistent with the single run footprint in figure 3a and an im provement over the shared environment case without eflect in figure 3b.
.
development effort thecustomizationeffortforportingenergy awareframeworkswith support for shared environments is minimal.
in our integration of eflectwithaeneas weprovideare implementationof aeneas sbenchmark co run co run avrora .
.
.
.
batik .
.
.
.
biojava .
.
.
.
eclipse .
.
.
.
graphchi .
.
.
.
h2 .
.
.
.
jython .
.
.
.
pmd .
.
.
.
sunflow .
.
.
.
xalan .
.
.
.
tensorflow .
.
.
.
figure13 energyfootprintcorrelationbetweensingle runs and co runs with eflect figure energy footprint for h2in a eflect co run.
rewardclass whose valuate method now calls eflect s readenergy .
in the chappie customization we reimplemented their energysampler classtocallreadenergyfromthe samplemethod.
their original source code tracks thread migration through sampling affinity.
since eflect is already socket topology aware we simplified their code.
in both cases we were able to complete the customization within hour.
threats to validity theprimarytargetplatformsthateflectisdesignedforareserverclass computing systems.
our experimental setup and benchmark selection reflect this assumption.
we think eflect may indeed be customizedonotherplatformswhereenergyconsumptionmatters such as mobile embedded systems.
this can be achieved through reimplementing a small number of apis defined in but theexperimental effectiveness of eflect on those platforms should not be taken for granted.
the use scenarios of co running multiple applications apps in mobile embedded systems do exist but we thinkthereisamorepressingneedforsupporttheminserver class systems where significant cpu memory sharing across multiple applications is a basic requirement.
in mobile systems for instance the largest energy consumption components are the display where sharing across different apps is limited.
related work the essential question of how to regulate the share of energy consumption to individual applications in a shared environment leads authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
eflect porting energy aware applications to shared environments icse may pittsburgh pa usa to ground up redesigns of operating systems.
one classic example is currentcy and its successor ecosystem .
just as an os can manage how cpu memory resources are allocated to processes currentcy manages how much energy is allocated or delivered to processes.
another example with a similar design goal is cinder .
strictly speaking these solutions focus on energy allocation instead of energy attribution so their goals are different from ours.
that said an energy aware application in their frameworks is only aware of the share of energy power delivered by the os so a parallel with ours can be set in terms of energy disentanglement.
unfortunately extensive os re design is a hurdle to the wider deployment of these attractive solutions.
appscope is an energy metering framework for android smartphones.
it relies on an os kernel modification to monitor kernel app activities and in turn provide a breakdown on energy consumption across hardware modules and systems applications.
power sandboxes is another os principal for mobile devices where an os level power sandbox can accurately attribute power withlimitedhardwaresharingtoconsider.bothrequireoschanges.
this requirement may be appropriate for their intended use context mobile devices but can be challenging for adoption inservers .
further afield power containers is another os solution that builds a linear power model over hardware performance counters on multi core cpus such as cycles and last level cache requests which serves as the basis for attribution of global power to individual cores.
this work differs from ours in that it addresses energy attribution for hardware components instead of applications.
in aequitus multiple energy management applications thatmay adjust thefrequency of the underlyingcpus through dvfs are given an equal slice of time in scheduling in a shared environment.
the goal of that system is to ensure fairness in energy management.
anindependentproblemisenergyprofiling i.e.
howtoattribute applicationenergyconsumptiontoindividualsoftwarecomponentsandprogrammingabstractions withinanapplication.eprof and e android aretwoexamplesthataccountforsmartphoneenergy power by attributing them to different software hardware functionalities such as phone wifi or user defined energy consuming events.
we reviewed chappie in .
finally populartoolssuchasthe screentime featureoniphones and power usage feature on many android phones support basic functionalitiesoftrackingtheusagetimeofindividualapps.eflect is significantly finer grained its jiffy based attribution is per time interval per energy domain.
our use of jiffies as an indicator for energyattributionisgroundedonthefactthatallcoresinthesame energy domain has the same power during the same time interval.
the time based energy estimation in the tools cited above however does not conform to this assumption.
conclusion eflect is a novel application level software framework aiming to port energy aware applications to a shared environment.
eflect monitors the activities of the underlying system in a fine grained manner but exposes a minimal interface to the client application.
through energy virtualization eflect can guide energy approximation and energy profiling frameworks to achieve their intendedgoals while avoiding energy entanglement.
eflect is a lightweight approach thatrequiresno modificationto vm os hardware and can be adopted to commodity computer systems.
reflectionsandoutlook.
theportabilitychallengethat eflect addresses is based on our own experience.
in prior efforts we attemptedtoportexistingenergy awaresolutions thosethoroughly evaluated in non shared environments but they behaved poorly in shared environments.
the eflect design we eventually came up with is simple and easy to deploy but the path leading to it was a learning experience.
in particular this is a design space where overhead precision and scalability all matter.
for example if we hadignoredthreadaffinityormigrationinourdesign theprecision would suffer.
as another example if we had not taken a samplingbasedapproachbutinsteadreliedonqueryingthreadjiffiesthrough instrumentation the overhead would rise significantly.
inouropinion therealexcitementof eflectisthe bridgeroleit playsforfutureresearch enablesexistingapplication levelenergyaware solutions to embrace platforms such as data centers andcloud servers with little additional effort.
in essence eflect empowersdeveloperswithenergyvirtualizationinamulti application environment where energy related developments would otherwise be convoluted due to energy entanglement.
our case studies in demonstratetwoapplicationsof eflectinenergy relateddomains.
now that the bridge is built new doors may be opened for exploring additional software engineering problems toward principled energy management in shared environments.
for example future research may systematically study the optimality and guarantees when multiple energy aware applications are approximated at the same time in a data center setting.
as another example in situenergy debugging tools may be designed for cloud servers andnew opportunities may exist for deployment site energy bug fix ing when coupled with state of the art techniques of automated program repair.
as yet another example closer to the case studies described in the paper a developer may use an eflect enabledchappie to profile her eflect enabled aeneas application in a shared environment.
such a combination may enable adaptive energyoptimizationwithnewknobsrecommendedin situinaserver environment.