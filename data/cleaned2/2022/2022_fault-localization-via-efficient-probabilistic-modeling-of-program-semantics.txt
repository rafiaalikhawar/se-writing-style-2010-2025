fault localization via efficient probabilistic modeling of program semantics muhan zeng yiqian wu zhentao ye yingfei xiong xin zhang lu zhang key laboratory of high confidence software technologies ministry of education peking university school of computer science peking university beijing pr china mhzeng wuyiqian ztye xiongyf xin zhanglucs pku.edu.cn abstract testing based fault localization has been a significant topic in software engineering in the past decades.
it localizes a faulty program element based on a set of passing and failing test executions.
since whether a fault could be triggered and detected by a test is related to program semantics it is crucial to model program semantics in fault localization approaches.
existing approaches either considerthefullsemanticsoftheprogram e.g.
mutation basedfault localization and angelic debugging leading to scalability issues or ignore the semantics of the program e.g.
spectrum based fault localization leadingtoimpreciselocalizationresults.ourkeyidea is by modeling only the correctness of program values but not their full semantics a balance could be reached between effectiveness and scalability.
to realize this idea we introduce a probabilisticapproachtomodelprogramsemanticsandutilizeinformation from static analysis and dynamic execution traces in our modeling.ourapproach smartfl semanticsbasedprobabilisticfault localization isevaluatedonareal worlddataset defects4j.the top statement level accuracy of our approach is which isthe best among state of the art methods.
the average time costis seconds per fault while existing methods that capture full semantics are often 10x or more slower.
ccs concepts software and its engineering software testing and debugging.
keywords fault localization semantics probabilistic modeling acm reference format muhan zeng yiqian wu zhentao ye yingfei xiong xin zhang lu zhang.
.
fault localization via efficient probabilistic modeling of program semantics.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
yingfei xiong is the corresponding author.
muhan zeng and yiqian wu are equal contributors to the paper and their names are sorted alphabetically.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
introduction in the last two decades testing based fault localization or fault localization in short has been a research focus in software engineering .givenaprogramandasetoftestswith at least one failing test a fault localization approach computes the suspiciousness score of each program element to determine which one is the most suspicious to be faulty.
here the program elements can be statements methods files or at any needed granularity.
among the large body of fault localization research a central focus is coverage based fault localization.
coverage based fault localizationinfersthesuspiciousnessscoresofprogramelements based on the coverage information and the basic idea is that an elementcoveredmorebyfailingtestsratherthanpassingtestsis morelikelytobefaulty.forexample spectrum basedfaultlocalization sbfl one of the most well known fault localization families calculates the suspiciousness score of a program element based on the number of passing tests and the number of failing tests covering the element.
however whetherabuggyprogramelementcausesthefailureof a test is determined by four conditions whether the test coversthe buggy program element whether the execution ofthebuggyprogramelementresultsinanerrorintheprogramstate whethertheerrorintheprogramstateispropagatedto theoutputand whethertheerrorintheoutputiscapturedby anassertionornot.coverage basedfaultlocalizationignoresthe semanticsofthetargetprogramandthusonlyconsidersthefirst condition.
a test may cover a buggy program element but still pass because the latter three conditions are not satisfied leading to inaccuracies in coverage based fault localization.
to overcome this problem different approaches have been proposed to take the latter three conditions also into consideration.
forexample mutation basedfaultlocalization mbfl generatesmanymutationsoneachelementandwatcheswhetherthe program output or the test result i.e.
the pass fail status changes.
if a change in a statement is more likely to change the programoutput or the test result in the failing tests and less likely in thepassing tests the statement is likely to be faulty.
angelic debugging uses symbolic analysis to determine whether the result of an expression can be modified to reverse the results of failing testswhilemaintainingtheresultsofthepassingtests andsuchan expressionisconsideredmorelikelytobefaulty.however these approachestakethefullprogramsemanticsintoconsideration and thus the analysis is inevitably heavy.
as an existing study reveals mutation basedfaultlocalizationoftenrequireshoursto localize a single fault.
as far as we are aware there is so far no successful application of angelic debugging to large programs.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa muhan zeng yiqian wu zhentao ye yingfei xiong xin zhang lu zhang in this paper we propose a novel approach to fault localization smartfl thatconsidersthefourfactorsviaefficientprobabilistic modeling of the program semantics.
our approach considers a sample space of all possible faults and analyzes which program elementismorelikelytobefaultybasedoncurrenttestresults.ourcoreinsightisthattheprobabilityofafaultinthecurrentprogramelementleadstothecurrenttestresultscanbeefficientlyestimated by analyzing the following theprobabilityofeachinstructioninthetracesoftestexecutions to introduce an error into the system state.
the probability of each instruction to propagate an error.
inthisway wedonotneedtoconsiderthefullsemanticsand can abstract each value into two possibilities faulty or not.
consequently theanalysisissignificantlysimplifiedandcanbeefficientlyapproached.alongwiththisinsight webuildaprobabilisticmodel based on the test execution traces and calculate the posterior probabilities of whether a statement is faulty based on the test result.
however realizingthisideastillhastwomainchallenges.the first one is how to model the effect from the control statements.
if theresultofaconditionalexpressionisfaulty theexecutedstatementsmayhavebeenchangedandthusanalyzingonlytheexecuted instructions in the trace is insufficient.
to overcome this challenge we statically analyze the impact of each conditional expression and combine the static impact with the dynamically obtained trace.
the second one is scalability.
though our modeling is significantly simpler than a model from the full semantics the probabilisticmodel may still be large as the test execution traces can be long.
to overcome this challenge we have introduced methods to select andcompresstracesandutilizeanefficientprobabilityinference algorithm .
wehaveevaluatedourapproachonthewidely useddefects4j benchmark .theresultsshowthatourapproachsignificantly outperforms mbfl the representative approach that leverages full program semantics in terms of both efficiency 210s per fault avg.
and effectiveness top accuracy .
our approach is also complementary to existing approaches while combining our approach with existing approaches using the combinefl framework the performance of the combined approach is further significantly boosted by on top accuracy.
in summary this paper makes the following main contributions.
a fault localization approach by efficient modeling of program semantics noveltechniquesformodelingthecontrolstatementsand for addressing scalability.
anevaluationonthedefects4jdatasettoshowtheeffectiveness and the efficiency of our approach.
therestofthepaperisorganizedasfollows.section2motivates ourapproachwithexamples.section3presentsbasicmathematical background about factor graphs.
section describes our approach indetail withanemphasisonhowtobuildtheprobabilisticmodel.
section5showstheexperimentresultsandanswerstheresearch questions.
section discusses related research.
section concludes the paper.
overview in this section we motivate our approach using an example.1public class condtest public static int foo int a if a buggy should be a a a return a test void pass assertequals foo test void fail assertequals foo figure a motivating example for condition modeling motivating example.
figure a is a simple program for illustration purpose.
the buggy condition a 2at line replaced the correct condition a .
there are two test cases to find the fault.fortest pass thefaultdoesnotinfluencetheevaluationof the condition so the result is correct.
however in test fail the faultmisleadsthetesttothewrongbranchandgetsawrongresult.
here we assume statement level fault localization and a desirable approach should rank line at the top.
coverage basedapproaches.
wefirstdemonstratewhycoveragebased approaches such as sbfl fail to discover this bug.
coveragebasedapproachesutilizecodecoverageinformationtocalculatesuspiciousness scores.
in sbfl approaches the suspiciousness scores ofanelement earecalculatedfromfournumbers thenumberof passing tests covering e the number of failing tests covering e the total number of passing tests and the total number of failing tests.
however intheabove case the coverageofpassing testsandfailing tests are completely identical resulting in equal suspiciousness scores for every statement regardless of specific sbfl formulas.
as analyzed in the introduction sbfl formulas cannot distinguish the suspicious degrees of different statements because coverageisonlyoneoutofthefourconditionsthatleadtotestfailure.
intest pass thoughthefaultyexpressioniscovered theresulted runtime state is still correct and thus calculating suspiciousness with only coverage cannot distinguish each statement.
other existing approaches.
to address the above challenge manyexistingapproachestrytoanalyzealsothelatterthreeconditions i.e.
whethertheexecutionofastatementproducesafaulty state whether the faulty state is propagated to the output and whetherthetestcapturesthefaultinthestate.however toanalyze the three conditions precisely we need to consider the full semantics of the program which is difficult to achieve efficiently.
here we analyze two families of approaches.
a typical family is mbfl.
mbfl mutates each statement to generate multiple mutants and check whether the output of each testexecution orthetestresult i.e.
thepass failstatus changes.
in this case mutating the statement at line or the statementatline6hasahighprobabilitytofailtest pass whilemutating the statement at line has a much smaller probability to fail test pass.
in this way we know that the statement at line has a weak authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fault localization via efficient probabilistic modeling of program semantics icse may pittsburgh pa usa correlation to the test result of passand is more likely to be faulty.
however to obtain statistically significant information we need to generateanumberofmutantsforeachstatement andalltestsneed tobeexecutedoneachmutant whichtakesasignificantamount oftime.inanexistingempiricalstudy mutation basedfault localization requires hours to localize a single fault.
another example family is angelic debugging .
angelic debugging analyzes for each expression whether its result can be modified to reverse the results of failing tests while maintaining theresultsofthepassingtests.inthisexample changingtheresult of expression a 1at line or the result of expression aat line to any value different from would fail test pass and thus the two expressions are not considered to be buggy.
however such an analysis requires symbolic reasoning which is known to be heavy and has limited scalability.
so far there is no successful application of angelic debugging to large programs within our knowledge.
our approach.
different from the above approaches our approachtakesaprobabilisticviewonfaultlocalization.letusconsider a sample space of all possible faults that the current program couldpotentiallycontain.giventhecurrenttestresultsasanobservation our approach estimates the probability of each program elementbeingfaulty.toefficientlyestimatetheprobabilities our approach builds a probabilistic model based on the probability that each statement produces and propagates faulty values.
concretely we introduce a set of bernoulli random variables to represent whether a statement is correct denoted by si whereiis the line number of the statement.
we also introduce another set of bernoullirandomvariablestorepresentwhethertheoutputvalueof anexpressionexecutioniscorrect.inthisexample weuse vp i vf i to denote the value produced by the expression execution at line i intest pass fail .similarly vp 2andvf 2denotesthecorrectness ofthetestinputsand vp 6andvf 6denotesthecorrectnessofthe test outputs.
sincetheinputvaluesofthetestsarecorrect wehavethefollowing probabilities.
p vp p vf please note that since the bernoulli random variables are binary wealsoknow p vp p vf .to easepresentation we will only present one of the two probabilities.
since passpassesand failfails wehavethefollowingprobabilities.
p vp p vf now let us further consider the probabilities that the statements produceandpropagatethefaultyvalues.first wenoticethatifthestatementmustbeexecutedduringthetestexecution thestatementitself is correct and the input values are all correct the result must be correct.
then we have the following conditional probability p vt s3 vt p vt s6 vt 1wheret p f then we noticethat whetherthe statementatline 4should be executed depends on the result of the expression at line .
that is iftheexpressionproducesthecorrectresult theexecutionsof thestatementatline4inthetwotestsarecorrect.thenwehave the following conditional probability by considering both data andcontrol dependencies.
p vt s4 vt vt 1wheret p f next weconsiderthecasewherefaultyvaluesmaybeproduced or propagated.
if an expression may produce a faulty result any ofthethreefollowingconditionsmusthold theexpressionitself iswrong theinputoftheexpressioniswrong ortheexpressionshould not be executed.
to simplify our probabilities model wedo not distinguish the three cases and uniformly consider theprobability that an expression returns a faulty value when some source is wrong.
wenoticethatdifferenttypesofoperationsbehavedifferently.
some are very sensitive to the faults when something goes wrong the result is highly likely to be wrong.
in our example a 1is such anoperation.someareinsensitivetothefaults whensomething goeswrong theresultcould still becorrect.
inour example a 2issuchanoperation.asaresult wegiveahighprobabilitytothe sensitive operations of returning a faulty value when something is wrong and give a lower probability to the insensitive operations.
as a result we have the following probabilities.
p vt s3 vt .
p vt s4 vt vt .
p vt s6 vt .99wheret p f based on the above probabilities we build a factor graph using these probabilities as