an empirical study of blockchain system vulnerabilities modules types and patterns xiao yi the chinese university of hong kong hong kong sar china yx019 ie.cuhk.edu.hkdaoyuan wu the chinese university of hong kong hong kong sar china dywu ie.cuhk.edu.hklingxiao jiang singapore management university singapore singapore lxjiang smu.edu.sg yuzhou fang the chinese university of hong kong hong kong sar china yzfang ie.cuhk.edu.hkkehuan zhang the chinese university of hong kong hong kong sar china khzhang ie.cuhk.edu.hkwei zhang nanjing university of posts and telecommunications nanjing china zhangw njupt.edu.cn abstract blockchain as a distributed ledger technology becomes increasingly popular especially for enabling valuable cryptocurrencies and smart contracts.
however the blockchain software systems inevitably have many bugs.
although bugs in smart contracts have been extensively investigated security bugs of the underlying blockchain systems are much less explored.
in this paper we conduct an empirical study on blockchain s system vulnerabilities from four representative blockchains bitcoin ethereum monero and stellar.
specifically we first design a systematic filtering process to effectively identify vulnerabilities and their patches from issues prs pull requests and commits on github.
we thus build the first blockchain vulnerability dataset which is available at we then perform unique analyses of this dataset at three levels including i file level vulnerable module categorization by identifying and correlating module paths across projects ii text level vulnerability type clustering by natural language processing and similarity based sentence clustering and iii code level vulnerability pattern analysis by generating and clustering code change signatures that capture both syntactic and semantic information of patch code fragments.
our analyses reveal three key findings i some blockchain modules are more susceptible than the others notably each of the modules related to consensus wallet and networking has over issues ii about of blockchain vulnerabilities are of traditional types but we also identify four new types specific to blockchains and iii we obtain blockchain specific vulnerability patterns that capture unique blockchain attributes and statuses and demonstrate that they can be used to detect similar vulnerabilities in other popular blockchains such as dogecoin bitcoin sv and zcash.
corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
concepts security and privacy software and application security .
keywords blockchain security system vulnerability data mining acm reference format xiao yi daoyuan wu lingxiao jiang yuzhou fang kehuan zhang and wei zhang.
.
an empirical study of blockchain system vulnerabilities modules types and patterns.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction while blockchain was first invented as a transaction ledger of the bitcoin cryptocurrency it is now serving as a fundamental component of many cryptocurrencies the total market capitalization of which is close to two trillion usd in february .
smart contract platforms e.g.
ethereum and hyperledger fabric and decentralized computing platforms e.g.
interplanetary file system and blockstack further evolved the blockchain technology into various decentralized applications such as defi decentralized finance smart contract oracles decentralized identities decentralized iot management and decentralized app markets .
to protect the decentralization of these systems and secure those finance critical cryptocurrencies security is a top priority of many blockchains.
prior research on blockchain security focused on smart contract vulnerability detection and network analysis.
many static program analysis tools e.g.
oyente zeus securify gigahorse and ethbmc have been proposed to detect vulnerable smart contracts via symbolic execution and model checking.
dynamic tools and learning based tools were also invented.
besides smart contract analysis some works analyzed network traffic hijacking and mining attacks and performed transaction attack analysis .
in contrast blockchains system level security issues are much less explored in academic research.
to the best of our knowledge there was only one study in this direction.
it specifically analyzed blockchain bugs with only security bugs covered and four analyzed.arxiv .12162v2 feb 2023esec fse november singapore singapore xiao yi daoyuan wu lingxiao jiang yuzhou fang kehuan zhang and wei zhang in this paper we aim to systematically understand blockchain system vulnerabilities by conducting an empirical vulnerability study of the representative blockchains in four directions including the classic bitcoin the smart contract platform ethereum the anonymous coin monero and the payment network stellar .
they are not only popular in the cryptocurrency market but also backed up with solid technical papers.
as depicted in figure the first step and challenge of our study is to effectively collect vulnerable issues and their patches of those four blockchains.
this is difficult because there is very little cve information associated with blockchain projects unlike other vulnerability mining studies and the large number over 34k of raw blockchain bugs in our crawled database makes manual vulnerability filtering1ineffective.
to address this we propose a vulnerability filtering framework based on the intuition that vulnerabilities have unique characteristics from various aspects and we can gradually identify candidate vulnerabilities by analyzing attributes of the code commits files labels and keywords.
eventually we obtain vulnerabilities and their patches as our blockchain vulnerability dataset.
based on this unique dataset we study three key yet unexplored aspects of blockchain vulnerabilities including susceptible blockchain modules common blockchain vulnerability types and blockchain specific patch code patterns.
to this end we perform the file text and code level vulnerability analysis as follows.
firstly we conduct the module analysis by inspecting patched files.
however inspecting each individual file is time consuming because there are unique patch file paths.
therefore we propose to identify the module path i.e.
the folder name that could summarize the module of enclosed files e.g.
the rpc folder indicates the rpc module .
we further correlate module paths across different blockchains by identifying a reference blockchain architecture and mapping different module paths into this architecture.
this module categorization allows us to obtain a layered map of blockchain vulnerabilities in different modules and pinpoint susceptible blockchain modules.
we find that some modules are more susceptible than the others such as the highly susceptible ones related to consensus wallet and networking each with over vulnerabilities.
secondly we perform the type analysis by analyzing vulnerability text more specifically vulnerability titles.
this is because a vulnerability type is typically captured by the title of an issue pr pull request e.g.
bitcoin pr wallet fix uninitialized read in bumpfee ... where uninitialized read is the type.
to eliminate noisy words and generate good quality clusters about types we leverage the part of speech analysis of nlp natural language processing to first extract type keywords before we conduct actual clustering.
by extracting type keywords in various situations and identifying a suitable clustering algorithm and its setting we successfully map .
of the vulnerabilities into the clusters of different types and analyze the top types that affect at least ten vulnerabilities each.
among these types we identify four new vulnerability types that are directly related to blockchain transaction block peer node and wallet key password.
we also show that traditional vulnerability types still hold of all the blockchain 1that said we need to recognize or differentiate realvulnerabilities from regular bugs.vulnerabilities.
furthermore we analyze the type differences across different blockchain projects.
thirdly we conduct the pattern analysis by analyzing vulnerability patch code.
in particular we focus on blockchain specific vulnerability types since the code patterns of traditional vulnerability types are well known.
to facilitate similar patch code into the same cluster we design and generate the code change signatures that concisely capture both syntactic and semantic information of patch code fragments.
by clustering code fragments into clusters of code change signatures we identify blockchain specific vulnerability patterns that check unique blockchain attributes e.g.
the sender address transaction order block header and gas limit and validate various blockchain statuses during node synchronization peer validation wallet and database operations.
we further leverage these patterns to discover similar vulnerabilities in other popular blockchains notably dogecoin bitcoin sv and zcash which have a collective market capitalization of over billion usd as of january .
most of our vulnerability reports have been confirmed and are under patching with only two being rejected.
this demonstrates the real world impact of our vulnerability patterns.
a thorough detection of blockchain system vulnerabilities based on the patterns extracted in this paper will be our future work.
to sum up the main contributions of this paper are as follows we design a systematic filtering process to curate a unique vulnerability dataset and will release it to the research community.
the link of the dataset is already available at https github.com vprlab blkvulndataset.
we develop a set of new methods to analyze blockchain vulnerabilities build a knowledge base on previously unknown patterns of the vulnerabilities and their fixes.
we reveal three key findings about blockchain system vulnerabilities in terms of their susceptible modules various vulnerability types and specific vulnerability patterns.
moreover we demonstrate the usage of these vulnerability patterns by detecting similar vulnerabilities in other popular blockchains.
the rest of this paper is organized as follows.
we first provide the background of studied blockchains and their bug fixing process in and describe our systematic data collection in .
we then present our multi level vulnerability analysis in and respectively.
summarizes the related works.
finally concludes this study.
background .
four representative blockchains studied in this paper we study the representative blockchains that are i popular in the cryptocurrency market ii in different directions of blockchain usages and iii backed up with solid technical papers.
under these three conditions we select the classic bitcoin the smart contract platform ethereum the anonymous coin monero and the payment network stellar .
next we present their basic information and the development status on github.
bitcoin introduces the concept of blockchain and uses it as a distributed ledger to record transactions for public verification.
as of january the bitcoin cryptocurrency or btc has the top one market capitalization of more than billion usd.
the bitcoin software was released in and it is actively maintained by overan empirical study of blockchain system vulnerabilities esec fse november singapore singapore vulnerability analysis file level module categorization .
text level t ype clustering .
code level pattern analysis .
results susceptible blockchain modules .
common blockchain v ulnerability types .
blockchain specific patch code patterns .
vulnerability filtering commit based filtering file based filteringlabel based filtering keyword based filteringgithub apis code hunks github issues prs github commitsraw bug databasefinal vulnerability datasetsystematic data collection figure the overall workflow of our blockchain vulnerability study.
contributors on github in a repository called bitcoin bitcoin .
the primary programming language of bitcoin is c .
ethereum is the first blockchain system with the capability of constructing turing complete smart contracts which contain a set of pre defined rules and regulations for self execution.
to maintain the operation of ethereum it creates a native cryptocurrency called ether or eth which is the second largest cryptocurrency with a market capitalization of more than billion usd as of january .
the ethereum software was released on github in and its go implementation is maintained by over contributors in a repository called ethereum go ethereum .
monero aims to mitigate the privacy leakage in blockchain systems since each blockchain transaction is transparent and could leak some sensitive information.
to do so monero uses an obfuscated ledger to prevent the transaction details e.g.
transaction source amount and destination from being revealed to outside observers.
as of january the monero coin xmr is ranked 47th with a market capitalization of over .
billion usd.
the monero software was released on github in and it is maintained by over contributors in a repository called moneroproject monero .
the primary language of monero is c .
stellar is a blockchain based payment network that can perform cross border money transfer in seconds.
it uses a novel consensus protocol called stellar consensus protocol scp for fast and secure transactions among untrusted participants.
the native cryptocurrency of stellar is called xlm which is ranked 30th with a market capitalization of around .
billion usd as of january .
the stellar software was released on github in and it is currently maintained by more than contributors in a repository called stellar stellar core .
similar to bitcoin and monero the primary language of stellar is also c .
.
bug fixing process in blockchain projects it is also necessary to understand the typical bug fixing process of blockchain projects hosted as open source projects on github in order to collect and analyze their vulnerabilities and patches.
a commit is a set of changes submitted by developers into a project repository a commit can change anything ranging from changing source code to modifying document files or merging multiple previous commits.
a change consisting of a consecutive sequence of added deleted lines is also known as a hunk .
apatch is a collection of changes or commits that can be applied to a set of files via a patching tool.
an issue is often a report on a project s github page it may describe a potential bug or sometimes an enhancement or aquestion and may come with fixes and solutions.
a pull request pr is the proposed commit for a project from a separate clone of the project it can be pulled from the project clone and accepted into the original project based on the review of managing developers.
for simplicity we do not explicitly distinguish an issue and a pr in this paper since the latter often contains a bug description too.
indeed github itself mixes up the usage of issue pr numbers.
systematic data collection as shown in figure the first and a critical step of our study is to collect a good quality blockchain vulnerability dataset across multiple blockchain systems that satisfies two conditions i cover as many vulnerabilities as possible in the studied blockchains i.e.
minimizing false negatives and ii introduce as fewnon vulnerability bugs as possible in the dataset i.e.
minimizing false positives .
some other vulnerability studies leverage the cve common vulnerabilities and exposures or bulletin i.e.
bug bounty information to collect vulnerability data.
however we found that there is very little cve bulletin information about most blockchains because blockchain vulnerabilities are critical and often patched directly via the reports from bug bounty programs without releasing a cve.
for example ethereum go ethereum had only four cves released before our data collection while bitcoin had cves.
we take a different way directly analyze the blockchain projects issues and commits in their github repositories and extract the vulnerable ones from them.
we first crawl all blockchain bugs and organize them into a raw bug database in .
.
the major challenge is how to recognize or differentiate realvulnerabilities2 from a large number of regular bugs.
to address the challenge we propose a novel vulnerability filtering framework in .
that systematically and effectively filters out regular bugs and extracts blockchain vulnerabilities.
we eventually obtain the first dataset of blockchain system vulnerabilities in .
comprising more than 1k vulnerabilities identified from over 34k issues.
it could not be done via manual analysis or via prior training based patch identification since i there is no ground truth training set for blockchain vulnerabilities and ii the learning based nature of those techniques tends to identify only the similar bugs or vulnerabilities.
2in this paper we adopt a broad definition of vulnerabilities that considers the bugs with security impact as vulnerabilities.esec fse november singapore singapore xiao yi daoyuan wu lingxiao jiang yuzhou fang kehuan zhang and wei zhang .
crawling and organizing blockchain bugs as illustrated in figure our blockchain bug database is constructed from two data sources the issues andcommits by leveraging github apis3.
for the issues we collect all the information of each closed issue pr including the issue title issue body comments events and bug category labels.
we consider only closed issues prs because open issues are not confirmed bugs yet and certainly have no patches.
note that even for closed issues they may not be the real bugs and could have no patches i.e.
they were simply closed by developers .
for the commits we first crawl allthe commits of a repository and then determine which commits are bug related.
for each commit we collect its title commit message affected files and id url for some commits filtered according to .
their actual code change hunks are also collected and processed according to .
and used for code level pattern analysis in .
we have collected a total of closed issues prs and commits as the raw dataset at the end of february .
the detailed breakdown of these issues prs and commits across four blockchain projects is available in table .
with the raw data collected a non trivial task is to organize and correlate the issues with their corresponding commits.
specifically we need to determine all the relevant commits for a given issue pr if an issue pr has no patch commits it is not a real bug and will be filtered out.
by summarizing the issue pr and commit s github structures we observe three kinds of information we can leverage for such correlation.
first we leverage the issue page s event information e.g.
xxx mentioned this issue and yyy added a commit and retrieve the commit urls from those events.
for example in https github.com bitcoin bitcoin issues we obtain the commit url via the event of laanwj added a commit that referenced this issue.
second for a pr like we can directly retrieve its commit lists at its commits tab page.
although these two kinds of information is useful for most issues prs some commits may not appear in the events of issues or commit lists of prs.
to overcome this our script analyzes all the commits titles and messages and identifies issue pr numbers from them.
with these strategies we successfully build the relationship between the issues and commits and finish constructing the raw bug database shown in figure .
.
a vulnerability filtering framework to evolve the raw bug database into the final vulnerability dataset we design a systematic vulnerability filtering framework expressed as a seven step process i.e.
s0 s4b in table to effectively differentiate vulnerabilities from regular bugs with minimal manual work.
the intuition is that vulnerabilities have unique characteristics at various aspects and we can gradually identify candidate vulnerabilities by analyzing attributes of the code commits files labels and keywords.
as shown in table we perform the filtering at the following four aspects commit based filtering.
firstly in the step s0 we leverage the most straightforward characteristic that a closed vulnerability must associate with code commits .
in other words an issue pr without any commit could be excluded directly.
since we have already built and rest reference issuestable intermediate results of the filtering in each step.
actioncommit file label keyword s0 s1 s2 s3a s3b s4a s4b include exclude remain the relationship between issues prs and commits in .
we easily exclude issues prs out of the entire issues prs.
file based filtering.
secondly we leverage two characteristics of patch files to filter out the bugs that are certainly not vulnerabilities.
the basic idea of these two characteristics is that the patch of a vulnerable issue pr must make some real code changes including changing files with actual source code and not containing only test code.
specifically in the step s1 we determine the file types with actual source code by their file suffixes for four blockchains.
an issue pr whose commits do not modify any file in these types should be excluded.
for example there are different file types for bitcoin s commits but only these seven file types .cpp .h .py .sh .cc .c .java contain actual source code whereas other file types like .yml and .mk are unlikely related to vulnerabilities.
this step filters out more issues prs then the remaining are further filtered by the step s2.
specifically s2 excludes the test only commits and their associated issues prs.
with the file based filtering we exclude of the issues prs.
label based filtering.
thirdly we leverage the characteristic of the labels of issues prs certain words in the labels could indicate whether an issue pr is related to a vulnerability or not .
for example the privacy label marks privacy related bugs in the bitcoin project and the obsolete vuln label indicates the early stage vulnerabilities of ethereum.
to avoid false positives we are conservative in specifying vulnerability labels we assign only three labels i.e.
the privacy obsolete vuln and special label sec xxx that appeared in the beginning of issue pr titles and mark their corresponding issues prs explicitly as vulnerabilities in the step s3a.
in contrast there are much more labels clearly indicating nonvulnerability issues prs.
specifically out of the entire labels from four blockchain projects we manually determine that of them arenotrelated to vulnerabilities such as refactoring docs and type feature .
with these labels we filter out their associated issues prs in the step s3b.
after this step we have narrowed the filtering scope from to issues prs a reduction of .
keyword based filtering.
lastly we directly check issues prs text based on the characteristic that some keywords could indicate an issue pr vulnerable whereas others could imply an issue pr not related to vulnerabilities .
to this end we first perform a word count analysis on the words in issue pr titles and bodies sort these words by their appearance frequency and exclude the words that appear only once.
we then group the words by their semantic similarity using the spacy nlp library.
since similar words are grouped together we manually go through all the clusters to obtain a set of vulnerability related words step s4a or non vulnerability words step s4b .
specifically we obtain clusters of vulnerability related words and clusters of non vulnerability words which allows us to automatically identify vulnerable issues prs and exclude irrelevant issues prs in the step s4a and s4b respectively.an empirical study of blockchain system vulnerabilities esec fse november singapore singapore table metadata of the raw and vulnerability datasets.
repositoryraw bug database vulnerability dataset closed issues prscommitsvulnerable issues prspatch commits bitcoin ethereum monero stellar total eventually our filtering framework extracted suspicious issues prs in the step s3a and s4a from the entire issues prs.
we have manually examined all these candidates and confirmed that of them were actually vulnerability related.
this suggests that our filtering achieves a precision of .
in identifying true vulnerabilities.
it is also worth noting that our filtering framework may potentially have a high recall in identifying all patched vulnerabilities in the projects although there is no ground truth for exact measurement since it handles at least .
of all the issues prs although the remaining after step s4b are discarded we believe that they have a low chance of being vulnerabilities due to no relevant keywords.
.
the vulnerability dataset and its metadata we then retrieve the actual code hunks for the identified issues prs from their corresponding commits.
this allows us to further exclude issues prs because they associate with invalid code commits through the code hunk analysis.
specifically we identified duplicate code commits whose code hunks were the same e.g.
and for which we kept just one code commit for each duplicate pair.
we also found empty code commits where we were not able to obtain their code hunks due to disappeared e.g.
commit 7e193ff6 or large diffs e.g.
go ethereum commit 34dde3e2 .
as a result our final vulnerability dataset consists of vulnerability related issues prs and their commits as shown in table .
it is worth noting that while items in our dataset are all security patches some of them are not conventionally technical vulnerabilities but more like security enhancements such as upgrading weak crypto algorithms to strong ones.
in this paper we do not distinguish them.
in table we also list the metadata of each blockchain project.
we can see that bitcoin and ethereum contribute .
of the vulnerabilities in our dataset whereas the percentages of monero and stellar vulnerabilities are relatively low.
this is mainly because bitcoin and ethereum have much more code commits than the other two blockchains holding a similar percentage .
of the entire commits.
additionally we notice that stellar has around the same number of patches as monero whereas the number of issues prs is three times lower v.s.
.
the main reason is that stellar developers tended to use one pr to cover multiple bug fixes at the early stage of stellar development.
based on this unique dataset we perform a comprehensive vulnerability analysis at three different levels in and .
file level module categorization at the first level of our study we perform the module analysis of patched files.
we first propose a lightweight method for categorizing vulnerable modules in .
and then present the categorization result and its implication in .
.
.
identifying and correlating module paths for vulnerable module categorization we found that vulnerable issues prs or more precisely patch commits totally generated unique file paths in bitcoin in ethereum in monero and in stellar which makes inspecting each individual file time consuming.
therefore we propose to identify the module path i.e.
the folder name that could summarize the module of enclosed files e.g.
the rpc folder indicates the rpc module .
for some paths of generic names e.g.
the src folder we consider its sub folders as module paths.
since ethereum s folder structure is more complicated than the other three projects we also consider three additional folders the core swarm and eth folders as generic and consider their subfolders as module paths.
eventually we obtain a total of module paths in bitcoin in ethereum in monero and in stellar from patch commits in the four studied blockchains.
further since different blockchains have different path names for the same module e.g.
the consensus module of bitcoin ethereum is in consensus while that of stellar is in src scp we need to correlate those module paths across projects .
our solution is to identify a reference blockchain architecture and map different module paths into this architecture.
since many blockchains are based on bitcoin we use bitcoin core s architecture as our reference.
for easier understanding we separate the entire architecture into four layers as shown in figure and unify the traditional miner mempool and validation engine components into the consensus module.
we then manually map those module paths into our blockchain architecture one by one.
it is worth noting that a vulnerable issue pr may affect multiple modules so the sum of the numbers of vulnerabilities of all the modules is larger than .
also some patch commits change only the files directly under the generic src folder and do not have module paths.
we inspect all such patch files in bitcoin in ethereum in monero and in stellar and map their corresponding vulnerabilities into the modules in figure based on the patch file names.
.
susceptible blockchain modules figure shows the result of our module categorization in a layered map of blockchain modules and the numbers of vulnerabilities in those modules.
we can see that modules in the policy peer network layers each introduce around one fourth of the vulnerabilities while the ui modules and other uncategorized modules contribute the remaining .
among all modules we find that some modules are more susceptible than the others.
notably the modules related to consensus wallet and netconn contain over issues each.
other modules about rpc gui cmd and storage are also susceptible affecting around issues each.
we observe that esec fse november singapore singapore xiao yi daoyuan wu lingxiao jiang yuzhou fang kehuan zhang and wei zhang ui layer peer layernetwork layer policy layergui cmd policy 45node 63rpc p2p consensus 265storage crypto 67others .
.
.
.
.
netconn wallet 214evm 28external 82utils figure a layered map of blockchain vulnerabilities in different modules.
the consensus module covers the consensus e.g.
the proof ofwork mechanism miner block transaction related components.
unfortunately it was affected by vulnerabilities with the major module path from the consensus folder.
other module paths include miner ethchain src cryptonote core src scp and src ledger .
in the peer layer the wallet module handles transactions for each peer and the storage module manages the storage of those transactions.
as shown in figure the wallet module was affected by vulnerabilities which are mainly from the src wallet and accounts module paths.
in contrast the storage was affected by vulnerabilities all of which are from database related module paths such as src blockchain db src leveldb and ethdb .
the netconn and rpc modules collectively incurred the most blockchain vulnerabilities in our dataset.
as a distributed system by nature blockchain systems heavily rely on network synchronization and rpc remote procedure call .
since it deals with complex network communication of different peers multiple security issues could occur such as data race deadlock resource leak and denial of service.
surprisingly the gui cmd module is also a major source with vulnerabilities from the module paths like src qt ethereal ui src daemon and cmd .
the underlying faults vary but segfault and deadlock are typical bugs.
text level type clustering at the second level of our study we conduct the type analysis by analyzing vulnerability text.
in this section we first present a nlpbased approach for clustering vulnerability types in .
and then summarize the clustering results and showcase common blockchain vulnerability types in .
including the ones not known before.
.
nlp based analysis of vulnerability titles for type clustering we find that a vulnerability type is typically captured by the title of an issue pr page e.g.
bitcoin pr wallet fix uninitialized read in bumpfee ... where uninitialized read is the type.
however simply clustering issue pr titles does not generate goodquality clusters about vulnerability types because each title could have some noises.
for instance in the earlier example wallet and bumpfee would affect the clustering quality.
to address this problem we propose a novel nlp based method to first extract type keywords before we conduct actual clustering.
this method is based on a grammatical pattern of vulnerability titles we observed that a type is often a noun phrase located in between a verb e.g.
fix and a preposition e.g.
in .
figure shows an intuitive illustration.
overall our approach consists of two major steps nlp based keyword extraction and clustering the obtained type keywords.
before these two steps we also need to perform some pre processing.
pre processing.
to this end we remove useless words and formalize remaining words in the vulnerability titles.
specifically the useless words include i the module version information e.g.
the word before such as the wallet above or the word inside such as or ii the special word e.g.
sec for ethereum and one character word like a note that numbers and symbols like or ... could be automatically handled by tokenizing and iii noun like adjective words e.g.
possibility of and use of .
after cleaning useless words we further formalize the remaining words by setting them to the lower case and tokenizing them via the nlp nltk library s regexptokenizer .
during this process we also unify a few words e.g.
replacing all tx txs txns using transaction .
in table we list several example titles our script automatically cleaned.
nlp based keyword extraction.
according to the grammatical pattern shown in figure our objective is to find the target verb and preposition that could determine the range of type words.
however one vulnerability title may contain multiple verbs or prepositions.
moreover some verbs mainly act as nouns in our context such as check and leak .
based on these two reasons we do not directly use the nltk library s pos tag for a realtime part of speech analysis.
instead we perform a pre analysis of words parts of speech in our cleaned vulnerability titles and build a vocabulary of verbs and prepositions and count their frequencies in our dataset.
eventually we obtain a list of verbs and prepositions and rank them by frequencies.
table shows the top frequently used verbs and prepositions in our dataset.
based on our vocabulary of verbs and prepositions and their frequencies we are able to automatically locate the target verb and preposition for a cleaned vulnerability title in various situations using the following rules if only one verb and one preposition exist and the preposition appears after the verb with one or more words in between such a verb and preposition e.g.
the word fixandinof the example e1 in table are the target words.
if there is no verb but the preposition exists e.g.
the example e2 or there is no preposition but the verb exists e.g.
the example e3 the preposition or the verb will be determined as the target.
if multiple verbs appear in a title the one with the highest frequency will be regarded as the target verb.
for example in figure or the example e4 the word fixhas higher frequency than the word read in our vocabulary fixis used as the target verb.
if multiple prepositions appear in a title the first one appearing after the target verb with one or more words in between is determined as the target preposition.
for instance in the example e5 in table both words onandinare prepositions but since the word onappears before in onis then determined as the target preposition.an empirical study of blockchain system vulnerabilities esec fse november singapore singapore table examples of the cleaned issue pr titles and their corresponding type keywords extracted.
id raw title cleaned title type keywords e1 accounts fix two races in the account manager fix two races in the account manager e2 blockchain db sanity check on tx hash vector sizes sanity check on transaction hash vector sizes e3 avoid possibility of null pointer dereference e4 wallet fix uninitialized read in bumpfee .
.
.
e5 prevent dos attacks on in flight data structures prevent dos attacks on in flight data structures fixuninitialized read inbumpfee operation verbvulnerability t ype keywords location preposition figure an example issue pr title to illustrate the grammatical pattern of vulnerability titles we observed.
table the top frequently used verbs and prepositions.
verbadd remove fix make fixed set avoid improve handling added prepositionin for on of with from by before if after if none of above applies for a vulnerability title we conclude that it has no target word.
after recognizing the target verb and preposition for each vulnerability title the keywords in between the two target words are extracted as the type for the vulnerability.
however as we list above some cleaned titles may end up with only one target word or even no any target word.
we handle those special titles as follows if only the target verb exists all words after the target verb will be regarded as the type keywords.
if only the target preposition exists all words before the target preposition will be treated as the type keywords.
if no target word exists the entire cleaned title becomes the type keywords.
clustering type keywords.
with the extracted type keywords we aim to cluster them based on their semantic meaning rather than their appearance as a string of letters.
thus after embedding all the keywords into the vector space using word2vec we choose the word mover s distance wmd as the similarity metric.
another reason for applying wmd is that it performs well on short sentences like our type keywords.
then we calculate their pairwise similarity with wmd and generate a large similarity matrix.
the last step is to cluster the type keywords based on the similarity matrix.
to reach an optimal clustering result we tested four clustering algorithms k means gaussian mixture agglomerative clustering and affinity propagation ap .
the first three algorithms require a pre defined number of clusters as the key parameter while ap needs a damping factor.
for the first three algorithms we tried a wide range of cluster numbers from to with an interval of .
for ap we tried the damping factor from .
to with an interval of .
.
we kept other parametersunchanged as default.
after clustering with the given parameters we computed the silhouette coefficient score to determine the performance of the corresponding combination.
as a result agglomerative clustering with clusters was the best setting for our similarity matrix which reached a coefficient score of .
.
.
common blockchain vulnerability types according to table we obtain not only the traditional vulnerabilities such as race condition and sanity check but also blockchainspecific vulnerabilities.
among the top vulnerability types we find that seven of them are related to blockchains characteristics.
in particular the .
vulnerabilities from four types t4 t7 t9 and t12 are blockchain specific which are related to blockchains transaction block peer node and wallet key password.
additionally we have three more vulnerability types t2 t14 and t20 that have some portions of their vulnerabilities related to blockchains features.
the rest of .
vulnerabilities are solely the traditional vulnerabilities not specific to blockchains.
next we explain three categories of these blockchain types specific partially specific and traditional .
for the patterns of blockchainspecific vulnerabilities we will present them in .
.
blockchain specific vulnerability types.
since transactions blocks gas fees are the unique characteristics of blockchain systems the type t4 and t7 record a large number of such new vulnerabilities.
examples are bitcoin pr fix mempool dos vulnerability from malleated transactions and ethereum pr gpo nonexistent block checks .
moreover as a peer to peer software by nature blockchains could suffer from peer node vulnerabilities.
by inspecting such vulnerabilities in the type t9 we find that they are mainly related to the unique p2p features in blockchains such as header sync and block validation.
examples include bitcoin pr timeout for headers sync and ethereum issue sec peer td in newblockmsg not verified .
lastly blockchain systems often provide wallets to end users which cause the new vulnerabilities related to wallet keys and passwords in the type t12.
for example bitcoin pr describes the vulnerability patch of securely erase potentially sensitive keys values .
partially blockchain specific vulnerability types.
we also observe three vulnerability types partially specific to blockchains i.e.
t2 t14 and t20.
specifically vulnerabilities in the type t2 performed various checks e.g.
error and length checks and some of them checked blockchain related properties.
for example bitcoin issue check for duplicate transactions earlier for dos prevention and ethereum pr check propagated block malformation on receiption .
in contrast the type t14 and t20 fixed more traditional vulnerabilities related to rpc calls and database corruption due to exceptional closing with a few vulnerabilities directly related to blockchains.
examples of blockchain relatedesec fse november singapore singapore xiao yi daoyuan wu lingxiao jiang yuzhou fang kehuan zhang and wei zhang table the top blockchain vulnerability types that affect at least ten vulnerabilities in our dataset.
id type vulnerability issues prsspecific?
all b e m s t1 race condition t2 check validation h t3 resource leak t4 transaction related t5 deadlock t6 go panic t7 block related t8 denial of service t9 peer node related t10 sanity check t11 overflow t12 wallet key password t13 uninitialized read t14 rpc related h t15 out of bound t16 off by one t17 segfault t18 memory pool t19 nil pointer deref t20 database corruption h sum .
.
.
.
.
means most in this type are blockchain specific and h means some are specific.
b e m and s represent bitcoin ethereum monero and stellar respectively.
vulnerabilities are ethereum pr implement cli configurable global gas cap for rpc calls and monero issue db corruption due to unfinished blockchain tasks.
traditional vulnerability types in blockchains.
besides blockchain specific vulnerabilities table also shows that vulnerabilities are solely from the traditional vulnerability types.
the top types such as race condition deadlock and denial ofservice are more frequent probably because it is difficult for blockchain systems to avoid them due to the sync among distributed nodes.
further analysis.
according to the detailed distribution of vulnerability types across different blockchain projects in table we make three observations.
first ethereum has more than half of the t1 race vulnerabilities much higher than the other three.
after investigating all the race related vulnerability issues prs we identify that the swarm subsystem is the major cause.
specifically swarm is only available in ethereum and used for distributed storage and content distribution.
second we notice that t6 go panic appears only in ethereum because only ethereum is implemented in go.
moreover since go is a memory safe language ethereum has fewer memory related t13 t18 vulnerability issues prs than bitcoin.
third we find that monero has the most number of t10 sanity check and t16 off by one vulnerabilities while stellar has the least number of vulnerability types since it is relatively new.
code level pattern analysis at the third level of our study we perform the pattern analysis by analyzing vulnerability patch code.
in particular we focus on blockchain specific vulnerability types i.e.
the seven types mentioned in .
since the code patterns of traditional vulnerability types like race condition deadlock overflow and uninitialized readare well known e.g.
.
in this section we first propose our approach to summarizing patch code patterns in .
and then present blockchain specific code patterns in .
.
.
generating and clustering code change signatures for vulnerability patterns to obtain vulnerability code level patterns our objective is to put similar patch code changes into the same cluster so that analysts can summarize patterns from each cluster.
to this end we need an effective representation of code changes so that it keeps important semantic information yet ignores unimportant or noisy information.
we call this representation the code change signature .
table illustrates the evolution process from raw code hunks to their code fragments i.e.
contiguous lines of code and the corresponding code change signatures using three examples.
taking the code in table 6b and 6c as an example both patches check whether the sender of a transaction is valid.
however if the variable name senderaddr is different the similarity between their raw code fragment change i.e.
the syntactic changes indicated by f2 and f3 would be low.
to capture the essential changes in patch code we do not use the syntactic changes but their code change signatures like s2 and s3 the details of which will be illustrated during their generation.
next we introduce our approach to generating code change signatures and clustering them.
before these two major steps we first clean up code hunks and turn them into fragments and then align up the changed lines of code in each fragment.
cleaning and splitting each code hunk into fragments.
the raw code hunks we retrieved contain not only meaningful diff code but also test code neighboring context e.g.
in line and block comments unchanged code lines include andimport statements and modification of none code files e.g.
mark down json and text files .
therefore we first initiate a cleaning process to keep only the actual diff code hunks and separate them into individual fragments by continuous and lines.
taking the code hunk in table 6a as an example it is separated into four code fragments f1 line f1 line f1 line and f1 line after removing the neighboring context lines i.e.
line and the comments in line and .
aligning up changed lines of code in each fragment.
before we generate each code fragment s change signature based on deleted and added lines in it we need to first pair up the changed lines of code since only some code fragments have one to one line change i.e.
at most one line and one line .
for example in table only the fragments f1 and f1 have one to one line change.
for a multiple line change in other fragments we measure the edit distance similarity between each line and all lines and pair the one with the highest similarity.
for instance line in table 6c is paired with line since it has the highest similarity with line as compared with all the other lines.
however some lines could be simply deleted or added causing their similarity with all other lines to be low.
we handle this by notpairing the lines with the highest similarity of less than .
.
as a result line in table 6a will not be paired with line due to the low similarity.
generating the signatures of code changes.
after determining the paired lines of code we extract their syntactic changes to generate the signatures with the following alterations an empirical study of blockchain system vulnerabilities esec fse november singapore singapore table the evolution from raw code hunks to their code fragments and code change signatures.
a example monero commit 1d5e8f46.
src crypto tree hash.c void tree hash const char hashes size t count char root hash code hunk line size t cnt tree hash cnt count char ints memset ints sizeof ints zero out as extra... char ints calloc cnt hash size zero out as extra... assert ints memcpy ints hashes cnt count hash size for omit cn fast hash hashes ints cn fast hash hashes ints j hash size ... cn fast hash ints ints cn fast hash ints i hash size ints j hash size cn fast hash ints root hash cn fast hash ints root hash free ints code fragments f1 char ints memset ints sizeof ints char ints calloc cnt hash size assert ints f1 cn fast hash hashes ints cn fast hash hashes ints j hash size f1 cn fast hash ints ints cn fast hash ints i hash size ints j hash size f1 cn fast hash ints root hash cn fast hash ints root hash free ints code change signatures s1 var calloc memset assert s1 cn fast hash s1 cn fast hash s1 cn fast hash free b example ethereum commit b765e2d1.
core transaction pool.go func pool txpool validatetransaction tx types.transaction error code hunk line return fmt.errorf tx.v !
v v senderaddr tx.from if senderaddr nil len senderaddr !
return fmt.errorf invalid sender xxx this kind of validation needs to happen elsewhere... code fragment f2 senderaddr tx.from if senderaddr nil len senderaddr !
return fmt.errorf invalid sender code change signature s2 from if nil len return err c example ethereum commit 7c24cd79.
chain transaction pool.go func pool txpool validatetransaction tx types.transaction error code hunk line sender pool.
omit .prostate.getaccount tx.sender sender pool.
omit .currentstate .getaccount tx.sender senderaddr tx.sender if senderaddr nil return fmt.errorf invalid sender sender pool.
omit .currentstate .getaccount senderaddr totamount new big.int .set tx.value code fragment f3 sender pool.
omit .currentstate .getaccount tx.sender senderaddr tx.sender if senderaddr nil return fmt.errorf invalid sender sender pool.
omit .currentstate .getaccount senderaddr code change signature s3 getaccount sender if nil return err recognizing and marking the type of statements.
we first determine the control flow statements by six reserved keywords if for while return throw and defer .
if a control flow statement is identified we keep not only their type keyword but also their logical operators e.g.
in line in table 6b.
if a statement does not contain any control flow keyword we regard it as a function call if it includes a function or an assignment statement if it does not.
for example neither line and line in table 6a have a control flow keyword but line contains a function calloc so we regard line as a function call and line as an assignment.
preserving the name only for a function call.
for function calls we found that the function name itself is often enough to capture the statement nature despite parameter changes.
therefore in code change signatures we eliminate the function s parameters and caller variables.
for example we eliminate the three parameters ofcn fast hash in table 6a and keep its function name only.
as a result it is easy for the generated three signatures s1 to be in the same cluster.
the symbols for calling a function vary including .
and .
additionally if a function is called by another in a statement we consider the last one as the actual function call of this statement e.g.
getaccount in table 6c.
abstracting variable names and variable values.
we also abstract variable names and variable values for a more concise signature.
specifically we substitute variable names with the keyword var.
if a variable is an array we further add one or more such as var for line in table 6a.
for variable values we define six keywords for the substitution of different types of values nilfor nil null and none bolfortrue andfalse numfor numbers txtfor strings len size for size related functions e.g.
len length size and sizeof and errfor error functions.
clustering code change signatures.
as mentioned earlier we cluster code change signatures from the vulnerabilities of blockchainspecific types.
since the rpc related and database corruption types i.e.
the type t14 and t20 in table have only one or two blockchainspecific vulnerabilities there is no need to cluster their signatures.
eventually our target is code fragments from vulnerabilities of the type t2 t4 t7 t9 and t12 see .
.
the clustering process is similar to that in .
.
one difference is that the wmd similarity is no longer applicable because code fragment signatures cannot be mapped to the token based vector space.
therefore we choose the normalized levenshtein distance as the metric for calculating the similarity between code fragment signatures.esec fse november singapore singapore xiao yi daoyuan wu lingxiao jiang yuzhou fang kehuan zhang and wei zhang table blockchain specific patch code patterns obtained from the clustering result of code fragments.
type id description pattern in the revised code change signature with some generalizations example transaction relatedp1 check the transaction sender address from sender address if nil len !
num isvalid return err e p2 check the size of transactions in a pool getserializesize size if max standard tx size return bol b p3 shuffle the transaction order otherwise fingerprinting clear selected coins shuffle push back b p4 prevent the duplicated transaction boost foreach insert if size !
size return dos b p5 prevent the malformed transaction if !isstandardtx return dos b p6 prevent the double spent transaction relay if relayablerespend var bol b block relatedp7 validate the new header not from an invalid block if isvalid while!
insert return dos b p8 check the gas limit in a block header calcgaslimit if cmp !
num return err e p9 check the block timestamp time int64 if m p10 validate some block fields number and hash not null getblockbynumber hash if !
nil e p11 do not connect a corrupted block if corruptionpossible return abortnode bol b p12 prevent a malformed block to be propagated or forked if calcunclehash !
unclehash if derivesha !
txhash break e peer node relatedp13 disconnect after the timeout of header synchronization if getblocktime getadjustedtime num return bol b p14 disconnect outbound peers on the invalid chain if gethash !
fdisconnect bol b p15 drop the remote peer on an invalid or unverified td if cmp blocktd !
e wallet key passwordp16 immediately wipe the memory for critical secret keys rct2sk mlsag gen memwipe memory cleanse return m p17 try to keep the wallet address in testnet or memory generate if !
mainnet create address file err m p18 do not skip asking for password when watch only if ask password m other check p19 check the validity of quorum set if !isquorumsetsane err if throw invalid argument s rpc related p20 enforce a gas cap of caller to protect against dos if rpcgascap if !
nil if cmp num warn e db corruption p21 avoid corruption due to unfinished blockchain tasks critical region local m this column lists one example issue pr for each code pattern where b e m and s represent bitcoin ethereum monero and stellar respectively.
to find a suitable clustering algorithm here we also tested the four algorithms in .
i.e.
k means gaussian mixture agglomerative clustering and affinity propagation ap .
for the first three algorithms that require a pre estimation of the number of clusters we compute the silhouette coefficient score in a wide range of cluster numbers but the result is not satisfactory.
therefore we choose ap as our code clustering algorithm since it does not require pre setting the number of clusters and performs well with a gradual tuning of the damping factor to .
.
under this setting we eventually obtain a total of clusters for further pattern analysis.
.
blockchain specific patch code patterns after clustering code change signatures we inspect all the clusters and generalize the code patterns from them.
table lists the evidently blockchain specific vulnerability patterns.
they are organized in seven categories by their types see .
and most checkrelated patterns have been categorized into the detailed types.
transaction related patterns.
we have identified six patterns p1 p6 related to blockchain transactions.
they check the sender p1 size p2 and order p3 of a transaction and prevent duplicated p4 malformed p5 double spent p6 transactions.
specifically p1 checks a sender address function to guarantee non null values with valid lengths.
p2checks the maximum size of transactions allowed in a pool.
besides the sender and length the order of transactions could incur privacy risks like fingerprinting if not randomized.
to address this and as the case of bitcoin p3is to clear the original order shuffle it and push back the new order.
both p4 andp5check the blockchain structure to prevent duplicated or malformed transactions otherwise dos could happen.
p6prevents double spent transaction relays via relayable respend which was checked in bitcoin and .
block related patterns.
we identify another six patterns p7 p12 related to blockchain blocks.
as a basic blockchain unit a block stores multiple transactions and will be appended to the chain according to the consensus protocols.
however vulnerabilities couldhappen if the header p7 gas limit p8 and timestamp p9 of a new block is invalid or if some block fields are not null p10 or if a corrupted p11 or malformed p12 block is identified.
specifically p7validates that a newly appended block header is not from an invalid block.
p8checks the gas limit in a block header where gas is the fee for running smart contracts in ethereum .p9checks whether the timestamp in a block is less than the current time such as monero and ethereum .
p10 validates the block fields like number and hash and guarantees they are not null.
both p11 andp12 check the structure of a block to prevent a corrupted or malformed block being connected or forked.
peer node related patterns.
we also identify three patterns p13 p15 related to peer node synchronization and validation.
specifically p13 checks the time of block header synchronization and if it is timed out the node would disconnect.
bitcoin shows such an example in bitcoin where the timeout is checked via getblocktime .
a similar case is bitcoin for the block download timeout.
additionally p14andp15perform the validation of remote peers and drop them if they fail.
for example bitcoin and in p14 validate the hash of outbound peers via gethash .
p15 on the other hand checks the ethereumspecific td total difficulty field of a peer and guarantees the advertised td actually deliverable as in ethereum and .
wallet related patterns.
we further identify three patterns related to the blockchain wallet.
first since secret keys of a blockchain wallet are critical p16immediately wipes the memory via memwipe monero or memory cleanse bitcoin after generating some secrets.
second the addresses in a wallet are also sensitive and should be kept in testnet or memory.
for example monero in p17 adds a create address file option for the address generating function generate to create an address file only in the testnet environment.
similarly bitcoin keeps the address table in memory and only writes to file when necessary.
third a blockchain wallet requires users to always input passwords for critical operations.
for example monero in p18 performs such password checks via ask password .an empirical study of blockchain system vulnerabilities esec fse november singapore singapore other blockchain specific patterns.
from p19 to p21 we summarize the last three kinds of blockchain specific patterns.
specifically p19 checks the validity of a stellar specific concept called quorum which represents a set of nodes that are sufficient to reach an agreement in the stellar network .
for example stellar and check the sanity of quorum via isquorumsetsane .p20 is a rpc related pattern which restricts the gas cap of rpc calls.
if the requested gas exceeds the cap limit via rpcgascap the caller should be warned see ethereum .
the last pattern p21 asks a blockchain client to gracefully shutdown itself when there are unfinished block synchronization and processing.
this can be done by setting a global blockchain lock viacritical region local as shown in monero .
.
applying the obtained patterns for vulnerability detection while the focus of this paper is not vulnerability detection we demonstrate the impact of obtained patterns by applying them to detect the same kinds of vulnerabilities in other blockchain projects.
specifically in the blockchain world it is normal for new blockchains to fork or partially reuse the code of classic blockchains such as bitcoin and ethereum.
these forked blockchains thus could encounter similar vulnerabilities that appeared in bitcoin and ethereum.
here we demonstrate a simple direct search of the vulnerable clones and leave a variant search to the future work.
among the top cryptocurrencies4 we identified that blockchains were forked from bitcoin or had similar codebase as bitcoin including the rank dogecoin bitcoin cash litecoin.
for each blockchain band a given vulnerability pattern p we leverage the vulnerable file f vulnerable function method m and surrounding code cto first locate a clone of the original unpatched code of p .
we then determine whether the cloned code is vulnerable or not by checking if a patch of p has been applied.
we use the pattern p3 p7 p11 p13 and p14 see .
that caused bitcoin vulnerabilities in recent years to detect their cloned ones in the projects.
the results are worrisome six projects are affected by at least one vulnerability and two projects dogecoin and bitcoin sv even suffer from all five kinds of vulnerabilities.
among a total of the vulnerabilities discovered only ten use the same file and function name as the original vulnerability.
this suggests the importance of generalized code patterns over the exact signatures relying on file names or function names.
we have reported all the vulnerabilities to their corresponding vendors via email github discord and dash s bounty and offered them fix suggestions in late june and early july .
a summary of our vulnerability reporting is available at com fse .
dogecoin promptly confirmed all of our five reports and planned to fix them in their next minor release version.
zcash horizen and ravencoin also confirmed our reports and are coordinating with their developers for fixes.
dash checked our report on p3 and believed that they had applied a different patch by sorting inputs and outputs based on bip69.
bitcoin sv replied to two of our reports on p7 and p14 however they seem not keen to fix them.
we are still waiting for bitcoin sv s replies on the other three reports.
4based on the market cap at on june .
related work blockchain vulnerability research.
existing blockchain security studies mainly focus on smart contract vulnerability detection and transaction or network level analysis of the blockchains.
for smart contract vulnerability detection both static and dynamic program analysis tools have been proposed.
for instance oyente zeus securify gigahorse and ethbmc detected vulnerable smart contracts via symbolic execution while contractfuzzer and confuzzius used fuzzing inputs to detect smart contract vulnerabilities and sereum and soda monitored run time contract execution to detect on chain attacks in modified evms.
for transaction level analysis karame et al.
analyzed the double spending resilience of bitcoin fast payments.
txspector studied ethereum transactions by replaying historical transactions and recording evm bytecode level traces.
defiposer proposed methods for discovering profit generating transactions in defi protocols just in time.
for network level analysis apostolaki et al.
analyzed routing attacks by hijacking bgp prefixes and showed that such attacks could delay the propagation of blocks without being detected.
gao et al.
showed that by power adjusting and bribery racing attackers could increase their mining rewards.
mining based vulnerability detection.
code clone detection is a long standing research topic in the software engineering area .
existing approaches are mainly based on detecting duplicated token subsequences or identifying exact or similar subtrees in abstract syntax tree ast representations.
for tokenbased approaches ccfinder cp miner and redebug are the representative work.
recently a token based approach vuddy generated code fingerprints via abstraction and normalization to speed up code clone detection.
for tree based approaches e.g.
deckard and clonedr they considered code s structural information by generating asts and embedding them into a vector space for similarity comparison.
conclusion in this paper we conducted the first empirical study of blockchain system vulnerabilities and their security patches using four representative blockchains.
to enable this study we proposed a vulnerability filtering framework to effectively identify vulnerabilities and their patches from issues prs and commits on github.
based on this unique dataset we performed three levels of analyses.
our analysis revealed three key findings of blockchain system vulnerabilities including i the modules related to consensus wallet and networking are highly susceptible each with over issues ii around of blockchain vulnerabilities are in traditional types but we also identify four new types specific to blockchains and iii we are able to obtain blockchain specific vulnerability patterns that check unique blockchain attributes and validate various blockchain statuses and demonstrate that they can be applied to detect similar vulnerabilities in other top blockchains.
in the future we will perform a thorough detection of blockchain system vulnerabilities based on the patterns extracted in this paper.