a highlyscalable hybrid cross platform timing analysis frameworkproviding accuratedifferential throughput estimation via instruction level tracing min yih hsu minyihh uci.edu university ofcalifornia irvine california usafelicitashetzelt fhetzelt uci.edu university ofcalifornia irvine california usadavid gens dgens uci.edu university ofcalifornia irvine california usa michaelmaitland michael.maitland si f ive.com sifive california usamichaelfranz franz uci.edu university ofcalifornia irvine california usa abstract differentialthroughputestimation i.e.
predictingtheperformance impactofsoftwarechanges iscriticalwhendevelopingapplications thatrelyonaccuratetimingbounds suchasautomotive avionic or industrialcontrolsystems.however developersoftenlackaccess to the target hardware to perform on device measurements and hencerelyoninstructionthroughputestimationtoolstoevaluate performance impacts.
state of the arttechniquesbroadlyfallintotwocategories dynamic and static.
dynamic approaches emulate program execution usingcycle accuratemicroarchitecturalsimulatorsresultinginhigh precisionatthecostoflongturnaroundtimesandconvolutedsetups.
static approaches reduce overhead by predicting cycle counts outside of a concrete runtime environment.
however they are limited by the lack of dynamic runtime information and mostly focus onpredictionsoversinglebasicblockswhichrequiresdevelopers tomanually construct criticalinstruction sequences.
we present mcad a hybrid timing analysis framework that combinestheadvantagesofdynamicandstaticapproaches.instead of relying on heavyweight cycle accurate emulation mcad collectsinstructiontracesalongwithdynamicruntimeinformation from qemu and streams them to a static throughput estimator.
this allows developers to accurately estimate the performance impact of software changes for complete programs within minutes reducing turnaround times by orders of magnitude compared to existingapproacheswithsimilaraccuracy.ourevaluationshows thatmcadscalestoreal worldapplicationssuchasffmpegand clangwithmillionsofinstructions achieving geo.meanerror compared to ground truth timings from hardware performance counters on x86andarm machines.
bothauthors contributed equallytothis research.
nowaffiliated withcerebras esec fse december sanfrancisco ca usa copyright held bytheowner author s .
acm isbn979 .
generalandreference performance computingmethodologies modelingandsimulation softwareanditsengineering software performance software evolution .
keywords performance throughput analysis differential throughput analysis combiningstatic anddynamic analyses acm referenceformat min yih hsu felicitas hetzelt david gens michael maitland and michael franz.
.
ahighlyscalable hybrid cross platformtiminganalysis framework providing accurate differential throughput estimation via instruction level tracing.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of softwareengineering esec fse december3 sanfrancisco ca usa.
acm newyork ny usa 11pages.
introduction semantically equivalent modi f ications of a given piece of software canresult invaryingdegreesofperformance degradationdue to resourcecontentionsonthearchitecturalandmicroarchitectural level.
for systems that have tight timing restrictions it is therefore criticaltoidentifyspeci f icimplementationsthatminimizenegative performance impacts and maintain timing restrictions over the executionofthewholeprogram.ifthetargetsystemisnotavailable toperformon devicemeasurements developersinsteadneedtorely ontoolstoestimatecyclecountsforagivenprogramorinstruction sequence.tothatend severalapproacheshavebeendevelopedthat roughlyfallintooneoftwocategories i emulatingtheexecutionof concrete runtime instances of the program on simulated hardware i.e.
dynamic approaches and ii estimating the cycle count of programinstructionswithoutconcreteexecutionunderanabstract runtime environment i.e.
static approaches .
dynamic approaches achieve high precision using architectural simulators which faithfully model the runtime behavior.
theyprovideconcreteandgenerallyaccurateestimates however theysufferfromhighruntimeoverheadandcanrequirehoursto daystoanalyze aprogram.furthermore architectural simulators exhibit a high architecture dependence and are complicated to set thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa min yih hsu felicitas hetzelt david gens michaelmaitland andmichaelfranz up oftenrequiringdedicatedexpertknowledgeand orgivingriseto compatibility issues with standard tools and default environments.
static approaches alleviate the performance and setup cost of dynamic hardware simulators.
traditionally suchapproachestarget worst caseexecutiontimepredictions over all possible execution paths .
more recent works focus on smaller execution sequences andalsoconstructparametricmodelsthatgeneralizetomultiple architectures.
these models are either trained end to end using throughputdata orprogrammaticallytunedforkeyparameters thatarepubliclyavailableorobtainedfrommeasurements .
however staticapproachesarefundamentallylimitedinpractice due to their lack of concrete dynamic runtime information.
hence traditionalstaticapproacheslacksupportforessentialprogramconstructssuchasloops data dependentcontrol f lows andmemory accesses .inaddition thescopeofmanystaticthroughput estimationtoolsislimitedto throughputpredictions ofindividual basic blocks i.e.
only a handful of instructions.
even fortoolsthatcanintheoryprocessmultiplebasicblocksatonce predictionsdonotusuallyholdacrosscontrol f lowtransfers.for example mca does not follow call or jump targets and instead simplyfallsthroughtothenextinstructionwhileaddingastatic cyclepenalty1.
inthispaper wepresentmcad alightweight alternativethat provides whole program throughput prediction of binary software.
mcad follows a hybrid approach that supplements static throughput estimates with dynamic runtime information.
to avoid the overhead of cycle accurate architectural simulation mcad uses an emulation based approach to obtain execution traces using qemu and forwards them to the llvm machine code analyzer mca forinstruction levelanalysis.inaddition mcadextendsmcatoresolveseveralinherentlimitationsofstaticthroughput estimation.
first mca s instruction analysis is redesigned to processinstructionsinastreamingfashion whichenablestheanalysisto scaletolarge real worldbinaries.
second mcad provides an interfacetoincorporatedynamicinformationintothe analysis.
the dynamic information captures concrete control f low which allows mcad to accurately predict instruction cycle counts across basicblockboundaries.inaddition theinstructionstreamcanbe supplementedwitharbitrary metadata such asmemory aliasing properties or execution context information to further improve prediction accuracy.
themainpurposeofmcadistoprovidefast yetaccuratedifferential timinganalyses cyclecounts forwholeprogramexecution traceswhichtypicallycontainhundredsofthousandstomillionsof instructionscanusuallybeproducedwithintheorderofminutes orseconds whichallowsdeveloperstoquicklyidentifytheleast intrusive change with respect to execution time.
we extensively testandevaluatemcadwithrespecttoscalabilityandaccuracyon a number of differentreal world applicationssuch as ffmpeg and clang to demonstrate that mcad can model microarchitectural behaviors suchasinstructionlatenciesinsuperscalarprocessors accuratelyandwithlowcost.thegeo.meanerrorindifferential timing between mcad and hardware performance counters in our l224loop vmulps xmm0 xmm1 xmm2 vhaddps xmm2 xmm2 xmm3 vhaddps xmm3 xmm3 xmm4 cmp r9d eax jle l1 l0 mulq r8 jump loopl1 movl ebp eax addl ebp jno loop figure x86 64 assemblycontrol f low.
experiments is smaller than across several different microarchitectures andapplicationsoftware.
summaryofcontributions wepresentmcad anewopen source2frameworkforthroughputestimationyielding highlyaccurate differential timings onparorbetterthanthecurrentstate of the art while reducing turnaround time byseveral orders of magnitude.
our prototype implementation leverages qemu as a fast instruction executor utilizing mca to model individual perinstructionexecutioncycles ratherthansimulation based approachesthatfaithfullymodelcomplexprocessorfrontends.
weprovideadetailedevaluationofmcadwithrespectto accuracy and scalability for the popular x86 and armv8 instruction setarchitectures usingseveral differentdevices andhardware performancecountersto collect timingmeasurements for real world traces as ground truth.
backgroundand motivation inthissectionweprovidebackgroundoninherentlimitationsof static throughput estimation approaches and present a use case scenario to motivate the designgoalsof mcad.
.
static throughput estimationchallenges throughput estimation is an active area of research that aims to statically predict the performance upper bound of a program usuallymeasuredbycyclecountsorinstructionpercycle ipc ofa singlebasicblock.currenttoolsmodelmicroarchitecturaldetails such asinstruction latency and numberof micro opsof the target processor.
however there are two major issues with this approach i it does not easily transfer across branch instructions or function call boundaries ii dynamic information such as execution context andmemory aliasingisusually not taken intoaccount.
controlflowtransfers.
figure1showsthecontrol f lowofanx86 64 assembly code snippet consisting of three basic blocks loop l0 andl1.
blockloopcalculates a vector dot product followed by a conditional branch into either block l0orl1based on a datadependent comparison withboth blocks jumping back to loopat the end.
usingintelcoffeelakeasanexampletargetarchitecture throughputpredictionsoftheindividualbasicblocksofthisprogramwill contributions in thisworkhavebeen adopted and arecurrently in use as part of llvm.
822a highly scalable hybrid cross platform differentialthroughput estimationframework esec fse december3 san francisco ca usa notgeneralizeacrossexecutions.thereasonisthatinstruction level throughputforthisprogramactuallydependsontheorderingof executedbasicblocksonthatarchitecture.inparticular executions wherel0followsloop listing1 areroughly5 10cyclesslower per iteration than executions in which l1followsloop listing2 .
this might seem counterintuitive as listing 1contains fewer instructions than listing 2and more importantly there is a memory read instruction movl ebp eax in the latter trace which shouldbeslowerthanscalarmultiplication mulq r8 .however measurements on the target architecture reveal that there is a substantial slowdown in traces that follow the shorter listing 1due to resourcecontentionbetween the twobasic blocks.
vmulps xmm0 xmm1 xmm2 vhaddps xmm2 xmm2 xmm3 vhaddps xmm3 xmm3 xmm4 cmp r9d eax jle l1 mulq r8 jmp loop listing traceofexecuting l0afterloopinfigure vmulps xmm0 xmm1 xmm2 vhaddps xmm2 xmm2 xmm3 vhaddps xmm3 xmm3 xmm4 cmp r9d eax jle l1 movl ebp eax addl ebp jno loop listing traceofexecuting l1afterloopinfigure speci f ically the vhaddps instruction always requiresexecution port which is also demanded by the mulqinstruction .
this createsadependencybetweenthosetwoinstructionsandforcesthe mulqinstructiontostalluntilprevious vhaddpsinstructionsrelease thedesiredexecutionport.ontheotherhand inlisting 2movland addldo not have con f licting resource requirements with the previousinstruction.thatmeansbothinstructionswillbedispatched intoexecutionnolaterthantheprevious vhaddps instructionsand execute in parallel thus resulting in higher instructions per cycle count thanlisting .
as explained earlier current static throughput prediction approaches will use static instruction ordering as a substitute for dynamiccontrol f low resultinginalow accuracyprediction.moreover existing approaches face severe practical limitations with regardstoscalability.insection 3wedetailourdesignofmcad whichtackles both ofthesechallenges.
vsetvli zero a0 e8 m2 tu mu vadd.vv v12 v12 v12 vsetvl rd rs1 rs2 vadd.vv v12 v12 v12 listing example risc vassemblycodeexecutioncontext.
listing3showsarisc vassemblysnippetcomprisedofvectorinstructions.inrisc v the vsetvlandvsetvli instructionssetthevectorlengthmultiplier lmul whichdetermines the number of elements that are processed by subsequent vectorinstructions.therefore thelatencyofeachvectorinstruction differs depending on thecurrent value of lmul.
for instance line in listing 3sets lmul to due to the m2operand which resultsina cycle latencythatre f lects a lmul of 2for the vaddinstructioninthenextline inline3lmulissettothevaluestoredin registerrs2 resulting in a potentially differentlatency that re f lects the lmul that was just set for vaddat line .
due to the lack of dynamicruntimeinformation staticapproachescannotdetermine theconcretevalueof rs2andthereforecannotaccuratelymodel the latency ofthe vaddinstructioninline4.
this example shows that while the instructions on line and areidentical theirexactlatenciesare actuallyin f luencedbythe environment values namely lmul as well as dynamic values storedintheregisters.currentthroughoutpredictionapproaches fail to provide accurate estimations for these cases and resort to a conservative upper bound latency due to the lack of dynamic information.
some existing tools can circumvent this issue with manualannotations.forinstance llvmmcaallowsdevelopers to instrument their programs with special comments that contain runtime information which mca uses to make more accurate queriesintotheschedulermodel.however whiletheseinstrument comments can improve analysis handwriting themdoesnot scale well withlarge number of instructions.
memory aliasing.
real processors reorderinstructions tooptimize instructionthroughput.tothatend theyanalyzememorydependencies between individual load and store instructions to determine a valid instruction scheduling that minimizes contention.
static throughput estimators trying to model this behaviour are limited due to the lack of concrete memory aliasing information.
forinstance listing 4showstwox86 64instructionsthataccess memoriesindexedbybaseregisters r13and r14.withoutknowing the exact values in these base registers it s hard to know if memoryaliasingpreventstheinstructionsfrombeingreordered whichmakesabigdifferenceintermsoflatency.sometoolslike mca either assumes that individual memory operationsnever accessaliasingaddressesorthatallmemoryaccessesalias bothcases resultinginloweredprediction accuracy.
addq7 r13 movq r9 r14 listing x86 64 assemblycodewith memory accesses .
differential throughput estimation differentialthroughputestimationismeanttopredicttheperformance impacts of applying certainchanges e.g.software patches on the target programs.
to motivate mcad s differential throughout estimating capabilities we detail how mcad can be applied to f indtheoptimalvariantofasecuritypatchtoabinarywithtight timing requirements post deployment.
in our scenario a buffer over f low vulnerability due to a missing bounds check has been identi f ied.
to f ix the vulnerability the developer needs to patch the missingcheckintothebinary.asdetailedinsection .1thelocation 823esec fse december3 san francisco ca usa min yih hsu felicitas hetzelt david gens michaelmaitland andmichaelfranz qemu abcd plugin target binary emulationbroker frontend instruction streambroker disassembler sub region address range debug infoscheduler load store unitresource managersub region managerhw component simulatorsmcad core summary viewsocket analysis pipeline timeline viewviewercore figure2 generalwork f lowandmajorcomponentsinmcad.
components with dashed outline are optional ofthepatchaswellasthespeci f icassemblyinstructionscanhavea highimpactonoverallperformanceduetoresourcecontentionson the micro architectural level.
developers therefore typically iterate throughseveralsemanticallyequivalentversionsofapatchinorder to minimize the performance degradation.
mcadprovidesdeveloperswiththemeanstoquicklyiteratethroughseveralversionsof the target binary to estimate the resulting performance impact and triagepotential bottleneckswithoutrequiringaccesstotheactual hardware.
to perform the throughput estimation a developer runs the originalbinaryaswellasseveralpatchcandidateswithconcrete inputs through the mcad pipeline and compares estimated cyclecountsbetweenversions.ifrequired mcadallowstorestrict the analysis to speci f ic regions of the program see section .
.
in addition mcad provides a timeline view which details each instruction s state transitions through the instruction pipeline see section4.
.
this information helps developers to triage performance degradations and guides them towards execution paths that are less sensitive to changes.
design in this section we present our overall design of mcad depicted in figure2.
as explained in the previous section current throughput predictionapproachesfaceseverechallengeswithrespecttoprediction across basic blocks lack of dynamic information as well as scalability and turnaround times.
the main goal of mcad is totackleallofthesechallengestoenablescalableandprecisedifferential throughput analyses that can be used to actively drive development and steer engineers towards implementations with favorable runtimebehavior.
.
goalsandchallenges mcad s designshould tackle three main goals first mcad aims to provide whole program throughput estimatesacross thousandsofbasic blocks and potentially millions of instructions.
at a high level mcad consists of a broker componentthatprovidesexecutiontracesinformofinstructionstream alongwithitsdynamiccontexts andacorecomponentthatanalyzesinstruction levelthroughputoftherespectivetraceon the f ly.
resultscanthenbeprocessedbyaviewercomponentforhumanreadablesummarizationanddatareporting.inprinciple themethod bywhichexecutiontracesareobtainedandstreamedtothecore component is not tightly coupled to the method that is used to analyze the instruction stream.
in early tests we compared severalexistingthroughputanalysistoolsforusewithourcorecomponent.
however we encountered several challenges with adopting any of themforourframework.asillustratedintheprevioussection state of the art throughput prediction approaches do not generalize over dynamic contexts like control f low transfers register state and memoryaliasing.besides asexistingthroughputpredictiontools are designed for single basic block use they also fail to scale up in terms of both memory consumption and processing capabilities when streaming input instructions on the f ly from the broker componentevenfortrivialprograms.wealsoencounterednumerous bugswhenusingthetoolsthatseemedmost f ittinginthisdynamic context someofwhichwe detailinsection .
second mcadaimstosupportadevelopment drivenwork f low.
thismeans thatdevelopersareabletousemcadtoanalyzethe timing impact after modifying some part of the code which might taketheformofbothabinarypatchorasource levelchangeofthe originalprogramunderourmodel.inadditiontowhole program analyses developershenceare able to chooseto analyze only parts of the program.
selecting which parts of the program to analyze is doneatvaryinglevelsofgranularitytoreducenoiseintheresulting reports and speed up the analysis if so required.
for example in the scenario outlined by section .
the target program might contain components such as unmodi f ied sequences of code which areirrelevanttothethroughputanalysis butwhoseruntimemight dependonunpredictableinputs e.g.randomnumbergenerators .
insuchcases thedevelopercancircumventthosecomponentsby excluding theirtraces from mcad s analysis.
third mcadaimstoprovide timelyfeedbackforthethroughputestimatesusinganapproachthatideallyalso generalizes across architectures.whilepurelydynamic approachesare alreadycapable of producing whole program estimates today the associated turnaround times and costs of setting up and running full scale system simulation can be prohibitively expensive i.e.
on the order ofhoursorevendays .furthermore existingdynamic throughput analysis tools are often tightly coupled to a speci f ic architecture whichiswhyweoptforanemulation basedapproach for producing execution traces inside our broker component using qemu .
we will elaborate how mcad tackles each of the respective challengestoachievethesegoalsthroughouttherestofthissection.
.
scalablethroughput prediction asexplainedinsection .1allexistingthroughputpredictionengines are designed with single basic block use in mind.
in our prototypewebuildontopofmca aperformanceanalysistooland librarythatwasdesignedtoestimatethebasicblockthroughputin a static fashion.
mca employs a microarchitectural simulator to emulate an individual instruction s timeline inside an out of order processor.
it taps into the llvm compiler s scheduling database a mature and production tested data source whose contents are curatedbyhardware vendors.
however we found that mcahasdifficulties toscale upin our dynamicscenario.likeotherthroughputpredictionengines itdoes notsupportaccurateanalysisofinstructionsbeyondabranchpoint or a function call out of the box.
on top of that we found that some of the design trade offs inside mca make it prone to high 824a highly scalable hybrid cross platform differentialthroughput estimationframework esec fse december3 san francisco ca usa memory pressure while processing large number of instructions.
enablingonlineanalysiswithinmcadrequiredseveralchangesto the underlying analysis infrastructure such as mca s serialization memory model andinstructionlifecycle.
in section .
we explain our modi f ications of mca used in mcadtotackletheaforementionedissuesandmakemcad score componentscaleupto real world applications.
.
development drivenwork f low mcad enablesadevelopment drivenwork f low byproviding fast whole program throughput estimates that can easily be compared between two versions of a program.
furthermore for cases that only modify a small portion of the original binary mcad also provides an option to analyze only part of the binary.
in this mode developers can designate the desired area by either specifying the symbol of a function or providing explicit address ranges in the program.
if an address range is provided mcad essentially yields theoriginalbasic blockgranularity oftheunderlyinganalysis engine while providing the f lexibility of comparing the execution of multiple basic blocks at the same time.
the proposal in section .
to automatically insert runtime information via instrumentcommentsintheexecutiontracelowerstheburdenondevelopers since they no longer have to insert handwriten comments everytime the lmul changes nor modify existing comments when a program changes.
.
analysis performance andgeneralization across architectures thebrokercomponentisresponsibleforsupplyingexecutiontraces tothecorecomponent.thisincludesinteroperatingwiththeorigin of execution traces and converting them into a uni f ied low level representation.
this also means that the broker and core components need to work together to enable a timely and architectureindependentoperationofmcad.bydefault executiontracesare transmitted remotely from qemu using a custom plugin.
qemu s emulation basedapproachincursaround30 runtimeoverhead effectivelyenablingnear nativeexecutionspeedswhenusinghardwarevirtualizationextensions.qemualsohasextensivesupport for many major architectures 3meaning that mcad s broker componentisabletoful f illbothoftheserequirements.itisnoteworthto mention that mcad also provides a facility for reading offline executiontraces whichcanbecollectedfromexecutionsonaphysical deviceusinganykindoftracingmethodavailableforthatdevice.
asmentionedearlier mcad scorecomponentusesmca.since mcausesllvm s infrastructure targetingdifferent hardwarearchitecturesandprocessormodelsintheanalysisenginerequires littleeffort.4asaresult boththebrokerandthecorecomponentof mcadgeneralizewellacrossseveralarchitecturesandprovidetopof the line performance.
moreover with qemu and llvm mcad uses tools that many software developers will already be deeply familiar with.
3qemu supports x86 mips sparc arm powerpc risc v among many others includingindividual processor models and speci f icmicroarchitectures 4llvm supports x86 mips sparc arm powerpc risc vamongmanyothers.
.
supplementing dynamicinformation as detailed in section .
due to unknown runtime state static throughput estimators fail to model many essential programming constructs accurately.
mcad addresses this issue by providing concrete runtime information that resolves ambiguities regarding blockordering registerstate andmemory aliasing.
ingeneral thepredictionsofstaticthroughputestimatorstonot generalizeaccrossbasicblockboundariesduetothelackofinformation aboutdynamic targets anddata dependent control f lows.
mca forexample simplyfallsthroughtothenextinstructionupon encountering ajump or call.
mcad supplements this information basedontheconcreteexecutiontracesobtainedfromqemuand forwardedto our analysiscore.
theexampleillustratedbylisting .
showsthedifficulties oftraditionalthroughputanalysistoprovideaccuratepredictionsin the presence of run time information such as values of immediates or data in registers.
although existing tools like llvm mca are abletocircumventthisissuewithmanualannotations suchsolutionsdon tscalewellwithlargenumberofinstructionscommonin an execution trace.
with mcad a potential solution to accurately analyzelisting 3isprovidingnecessarydynamicinformationofthe executiontracetotheanalysisengine.morespeci f ically thetool responsible for generating execution traces qemu by default can extract lmul when it comes across either the vsetvlorvsetvli instruction.
such lmul values are subsequently provided along withthe trace to the analysisengine to aid precision withoutany intervention fromthedeveloper.this caneasilybe generalizedto otherapplicationsbysendingdifferentkindsofdynamicinformationto the analysisengine accordingly.
mca contains a component called load store unit lsunit in figure2 whichsimulatesloadandstorereorderingthatcouldhappeninthehardwareschedulerofthesimulatedprocessormodel.
this type of hardware optimization re orders memory instructions to break dependencies when possible which is largely determined by their memory aliasing properties at runtime as shown in the exampleillustratedbylisting .
.however withoutprecise memoryaccessinformation mcacanonlymakecoarse grained assumptions for instance all memory instructions are aliasing witheachother whicharecontrolledby acommandlineparameter.mcadleveragesthememorytracescollectedfromqemuto improvethissituation.wemodi f iedmca sloadstoreunitsuch thataliasingpropertiesarenowdictatedby f ine grainedmemory accessing traces as provided by our qemu plugin.
this enables our customcore componenttosimulateloadandstore reordering with higher accuracy by using dynamic information as it becomes available duringexecution.
.
model assumptions mcad is able to model out of order and superscalar execution commonlyseeninmodernprocessors.supportforsimultaneous multithreading smt data or instruction cache and branch predictor simulation are planned as future additions to the project.
in addition mcadcurrentlyonlysupportsanalysisofsinglethreaded executions.
825esec fse december3 san francisco ca usa min yih hsu felicitas hetzelt david gens michaelmaitland andmichaelfranz implementation in this section we describe the work f low and implementation of mcadindetail.figure 2depictstheinteractionbetweenthedifferent components f irst the target binary program is executed byqemu whichcollectsexecutiontracesandsendsthemtoour analysisengineinrealtime.insideouranalysisenginetheexecuted instructionsarefurtherprocessedbytiminganalysesbuiltontop of mca which provides algorithms for microarchitectural simulationandinstructionschedulingofmodernprocessors.finally mcad provides estimates for key timing and performance metrics liketheprospectivecyclecounts instruction levelthroughput and the abilityto identifypotentialbottlenecks.
.
instructionbroker mcad sbrokerimplementationisastandaloneprocessthatproducesmcinst objects aninternalrepresentationformachine codeinstructionsusedwithinllvm andforwardstheminbatches tothecorecomponent.thebrokerinterfaceisdesignedtobeextensible andallow integrationof customimplementations and enable streamingofinstructionsequencestothecorecomponentfroma variety of different sources.
so far we integrated and tested two brokerimplementations anassembly f ilebrokerthattakesitsinput from an assembly f ile on disk and a qemu broker that uses a qemu plugin to communicate with the qemu broker process usingtcp socketstoprocess therawexecutiontraceinrealtime before streamingthemintothe core componentfor analysis.
brokerimplementationscanchoosetoattacharbitrarymetadata tothestreamedinstructiontrace forinstance byattachingloadand storeaddressesandthesizeofmemoryoperationswecanenable moreprecisedependencydetectionbetweenmemoryaccessesin the analysisengine ofthe core component.
in particular mcad s qemuplugincollectsrawinstructionsasexecutedbytheemulator alongside additional information regarding memory operations which is then used to improve analysis results with respect to instructionreordering.inthismodeofoperationmcad sbroker dynamically instruments memory read and write operations to gathertargetaddressandsizeofthedata.theqemupluginwill then send these data to the receiving core component that runs in parallel in a separate process.
inside the core component this metadata that is attached to memory operations is then inserted intoaregistrythatisusedbythecorecomponentforjointanalysis.
developingcustombrokersisstraightforwardandonlyrequires implementing a few callback functions before loading them as sharedlibrariesduringruntime.thisallowsuserstorapidlyswitch between different workloads and environments depending ontheir needs.itisimportanttonotethatwedonotmakeanyassumptions aboutabroker sinternalexecutionmodel solongasthebroker adheres to the streaming interface to supply the next batch of instructions.
.
analysis core ourcorecomponentbuildsontopofstate of the artthroughput prediction engines which are designed as offline tools for static throughput estimation ofsmall sequences ofmachineinstructions usually at the basic block granularity .
given a short sequence of assembly instructions they provide throughput estimation resultsonthemicroarchitecturalleveleitherthroughend to endtrained models for a given architecture or through simulation of the differentstagesinside amodern processorwithvaryinglevels ofdetail andmanuallytunedkeyparametersperarchitecture.unfortunately all existingthroughput prediction tools failed to scale up with our dynamic model of execution as an example using the standard videoandaudioencoderffmpeg executesaround20million instructions on a linux x86 64 machine while decoding a short mpeg video with duration of seconds.
within mcad this typeofapplicationwouldbeconsideredalightweightreal world workload.wefoundthatnoneoftheexistingapproacheswereable to analyze anywhere near this kindof workload.
however since mca already has support for slightly larger pieces of code compared to all other related approaches through theirloopkernel analysis weimplementedmcad sdefaultanalysis engineontopofthat.ourinvestigationintoadoptingmcaforour corecomponentshowedseveralfailurecaseswhilehandlinglarger workloads.internally mcamodelsfourdistinctexecutionstages entry dispatch execute andretire.undermcad swork f low the instruction stream provided by the broker enters from the entry stageandisprocessedbyeachsubsequentstagesequentially.mca then assigns aninternal datastructure to eachinstruction to keep track of its scheduling status within the simulation pipeline.
originally this pipeline reads all input instructions ahead of time before the start of the analysis.
because mca assumes those instructions tocomefroma f ile.thisproperty whileitalignswiththeoverall designgoalofmcatoprovidethroughputestimatesforonlysmall sequences of assembler instructions is not suited for whole programanalysis.insomeofourtests mcaconsistentlydrainedall available physical memory on the machine running the analysis dueto the allocation ofthis internal instructionrepresentation.
to address the scalability issue we created a new incremental mode for the mca simulation pipeline.
in this mode the simulation pipeline fetches input instructions incrementally.
if there are no instructions available from the input source the pipeline willsaveitscurrentstateandexit.uponthearrivalofnewinput instructions thesimulationwillberestoredandproceedfromits previousstate.
toreduce memoryconsumption weimplemented a new instruction recycling mechanism for the mca simulation pipeline.
this instruction recycler will reclaim and collect internal instruction data structures from retired instructions instead of releasing their memory.
these recycled data structures will then bereusedtomodelnewincominginstructions.ourexperiments showedthatwiththis recycling mechanism mcad score analysis uses one third of memory on average than the unmodi f ied mca implementation.
mca simulates different execution units which process individual instructions and determine results of the operation in question.
theseestimatesincludecyclecounts potentialpipelinestalling and predictionsofpossibleinstructionre ordering.forinstance mca s load storeunittrackstheavailabilityofmemoryoperationsand their data dependencies.thisiscrucialforsimulatingout of order schedulinginmodernprocessors whichfrequentlyreordermemory operations based on their dependencies.
we signi f icantly extended theseexistingcapabilitiesbyprovidingan onlineanalysiswork f low by sequentially processing the incoming instruction stream and itsdynamiccontextsaccordingtothesimulatedpipeline mcad 826a highly scalable hybrid cross platform differentialthroughput estimationframework esec fse december3 san francisco ca usa is able to present an estimate of how arbitrarily long instruction sequencesmightbe scheduledwithin the processor.
.3sub region feature and viewer component mcad s viewer component displays throughput estimations with informationliketotalcyclecountsorpotentialpipelinestalls.an exampleof this can be seeninlisting .
we also prototypeda view of the timingitineraryof individualinstructionin a timeline view.
for instance listing 6shows the timeline of the execution trace in listing .
from this timeline we can easily spot the resource contentionbetween mulqandvhaddps asmentionedinsection .
.
this particular view is a fork from the timeline view that exists in mca.
however the timeline view in mca has limitations on the maximum number of analyzed instructions and cannot inspect theitineraryofasubsetofananalyzedexecutiontracewhichwe implemented as part of mcad s subregion feature.
for this reason third partyvisualizationtoolsarealsosupportedinthiscomponent.
for instance we prototyped a new timeline view based on chrome developer tools devtools .
in our early test we already found thisaloteasiertoscrollandnavigatethroughthethousandsoreven millions of instructions that are processed by mcad compared to the terminal based llvm mca timeline view.
since this view was designed to analyze large number of network requests it provides asolidbasisto helpour newtimelineviewscaleup.
instructions total cycles total uops dispatch width uops per cycle .
ipc .
block rthroughput .
listing summary view .
d eeeee r .. vmulps .
d eeeeeee r .. vhaddps .
d eeeeeeer vhaddps .
d ee r cmpl .
d ee r jle .
d eeeee r mulq .
dee r jmp listing timeline view evaluation mcad s main goal is to enable developers to quickly assess and iterateonthetimingimpactofprogrammodi f ications including patches acrosscontroltransfers e.g.branchesandfunctioncalls .
inthissection weusebinaryprogramsofdifferentreleaseversions to evaluateperformanceand cycle countaccuracyagainstphysical hardwaretracestoquantifyhowmcadfaresincomparison.more formally given two different versions u1d456and u1d457of a program u1d443 denotedas u1d443 u1d456and u1d443 u1d457 aswellasathroughputpredictor u1d43bthatprovides the number of execution cycles under a speci f ic input for the respective program we de f ine the differential throughput u1d43b u1d443 u1d456 u1d443 u1d457 describingthechangeincyclecountsbetweenversion u1d456andversion u1d457ofprogram u1d443as predictedby u1d43bas follows u1d43b u1d443 u1d456 u1d443 u1d457 u1d43b u1d443 u1d457 u1d43b u1d443 u1d456 given two versions of a program u1d443 u1d456and u1d443 u1d457 as well as their inputs we f irstusemcadtopredicttheirdifferentialthroughput resulting in u1d440 u1d436 u1d434 u1d437 u1d443 u1d456 u1d443 u1d457 .
second we similarly measure their relative difference in cycle counts from version u1d456to version u1d457using hardwareperformancecountersonphysicaldevices resultingingroundtruth differential throughput u1d43a u1d443 u1d456 u1d443 u1d457 .
finally we formally de f ine the error of mcad s prediction of differential throughput between version u1d456andversion u1d457as u1d438 u1d456 u1d457 u1d43a u1d443 u1d456 u1d443 u1d457 u1d440 u1d436 u1d434 u1d437 u1d443 u1d456 u1d443 u1d457 .
differential throughput prediction to assess the overall accuracy and ability to generalize throughput predictions across control transfers we conduct experiments using two popularand widely usedapplicationsastarget programs the ffmpegvideo encoder decoder and the c c objective c compilerclang.weselect ffmpegforourcasestudyasvideoencoding represents acomplex andhighly performance intensive taskwith manyapplicationsinreal worldusecases.
clangrepresentsalargescalesoftwareconsistingofcomplexbranchinglogic whichiswell suitedtotestmcad scross branchpredictionaccuracyandalso plays an importantrole inmanyreal world scenarios.
wecollectbaselinecycle countmeasurementsonthreephysical machines with different instruction set architectures isas and microarchitectures intelcoffeelake coreinteli78700kx86 64cpu clocked at .70ghz and32gof ram running ubuntu .
amdzen2 coreamdryzen93900xx86 64cpu clocked at .48ghz and32gof ram running ubuntu .
arm cortex a57 core arm cortex a57 aarch64 cpu clockedat .73ghz and4g of ram running ubuntu .
compared to running baseline measurements on smaller program scopes e.g.a single basic block measuring larger execution traces faces much more operating system noise.
to avoid noise due to cpu migration or context switching we allocate a single processor core exclusively for theprocess under measurement.
in addition wedisablesimultaneousmultithreading smt alsocalled hyper threading on intel processors on the benchmarking core sinceitisnotsupportedbyouranalysisengineasmentionedinsection3.
.
the baseline measurements are obtained using linux perf which leverages the performance monitor unit pmu provided by the underlying hardware andare averagedover repetitions.
.
.
ffmpeg.
weevaluate ffmpegonsubsequentversionpairs using different release versions in the following order .
.
.
.
.
.
.
.
and4.
.foreachexperiment weusethe same14kbmpeg 4video f ileasreferenceinputandexecutethe following command ffmpeg i input.mp4 f null figure3a 3b and3cdepict the differential throughput predictions ofmcad u1d440 u1d436 u1d434 u1d437 ffmpeg u1d456 ffmpeg u1d457 andthebaseline u1d456 u1d457forversion pairs u1d456 u1d457 as .
.
.
.
and so forth.
in addition the 827esec fse december3 san francisco ca usa min yih hsu felicitas hetzelt david gens michaelmaitland andmichaelfranz perfdiff.
throughput mcad diff.
throughput geomean error error .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.5diff.
throughput a ffmpegintelcoffeelake2.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
b ffmpegamdzen22.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
error percentage c ffmpegarm cortex a57 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.5diff.
throughput d clangintelcoffeelake6.
.
.
.
.
.
.
.
.
.
.
.
.
.
e clangamdzen26.
.
.
.
.
.
.
.
.
.
.
.
.
.
error percentage f clangarm cortex a57 figure differential execution timing comparisons between subsequent development versions of ffmpegandclang.
relative cyclecount differences are plotted inblue andorange.graybars represent mape with geo.mean plotted inred.
coffeelake zen .
.
.
.
.
.
.
.
.
cm coffeelake100 cm zen2 figure number of cache misses during the execution of different ffmpegversionsoncoffeelakeandzen2machines.
figures present the resulting error rates u1d438 u1d456 u1d457for the corresponding version pairs between ground truth measurements on physical devices andpredictions bymcad.
our results show that mcad closely follows hardware cycle countsandneverdeviatesfromchangesinthebaselinecountby more than .
on average the error is .
for intel .
for amd and .
for the arm cortex a57 with a standard deviation of less than .
in all cases.
nevertheless on both intel and amd machines twoversionpairsshowunusuallyhigherror .
.
and .
.
deviatefrombaselinemeasurementsbyaround10 to .
furtherinvestigationshowedthatthisdeviation islikelydue to a high number of cache misses during the execution of ffmpeg version3.3onintelandamdmachines.figure 4showsthenumber ofcachemisseswhenrunningdifferentversionsof ffmpegoncoffeelakeandzen2 measuredusinghardwareperformancecounters averagedover1000repetitions.onbothmachinesthenumberof cachemissesspikesforversion3.
exceedingthesecondhighest measurement by at most .
as detailed in section .
mcad utilizes llvm s instruction scheduling database for instruction latencyinformationwhichassumesthatallmemoryaccessesresult in cache hits.
therefore without proper and potentially expensivecachesimulation seesection .
mcad sprecisionwillbe hinderedbycyclecount penaltiesoriginatingfrom cache misses.
.
.
clang.
we conducted our experiments for clangusing differentreleaseversionsasfollows .
.
.
.
.
.
.
and .
.
in order to reduce the amount of i o interference and simplify the experiments without losing generality we focus on the backend of clang s compilation pipeline.
more speci f ically we measure the cycles consumed by clangin compiling an unoptimizedllvmirprogramtoanobject f ile.thellvmirinput f ile input.ll isgeneratedfrom the following c program int foo int x int y return x y weuseinput.ll asthereferenceinputforourexperimentsand executethe following command clang o2 c input.ll o dev null figure3d 3e and3fdepict the differentialthroughput predictions ofmcad u1d440 u1d436 u1d434 u1d437 clang u1d456 clang u1d457 andthebaseline u1d456 u1d457aswellas the error rates u1d438 u1d456 u1d457between predictions by mcad and baseline for versionpairs u1d456 u1d457 as andsoforth.
again ourresultsshowthatmcadcloselyfollowsthehardware cycle count and never deviates from the changes in the baseline count by more than .
on average the error is .
for intel .
foramd and1.
forthearmcortex a57withastandard deviationoflessthan5 inallcases.onbothintelandamdmachines we observe a spike of nearly error on version pair .
.
.
similar to the culprit for unusually high error percentage in section .
.
we f ind that this spike of error is caused by higher number of cache misses on version .
compared to other clangversions clang13.0creates13 to35 morecachemisses onbothmachines.inaddition onthearmmachine weobserve around10 oferroronversionpairs .
.
and .
.
.we f indthatthisiscausedbysuddenincreaseofmemoryoperationsin bothversionpairs.forinstance thenumberof ldur memoryload andstr memorystore instructions increases byafactorof 27in said version pairs.
modern processors usually apply advanced optimizations suchasload storeforwarding duringtheexecutionof 828a highly scalable hybrid cross platform differentialthroughput estimationframework esec fse december3 san francisco ca usa perfdiff.tp mcad diff.tp geomean error error .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
error percentage .
.
.
.15diff.
throughput a ffmpeg .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
error percentage .
.
.
.02diff.
throughput b clang figure5 differentialthroughputpredictionofsmallchanges inffmpegandclangon intelcoffeelake these memory operations which might not be accurately modeled bymca.
.
differential throughput predictionon smallchanges sofar mcadhasshownitsaccuratedifferentialthroughputpredictions on changes between major software release versions.
in this sub section we futher illustrate mcad s capability of predicting differential throughput originating from much smaller changes like software patches.
this issupported byrepeating the intelcoffeelakeexperimentsfromsection .
.1andsection .
.
but using minorffmpegandclangreleases which have far less modi f icationsbetweenthem ratherthantheirmajorreleasesasthe analysis targets.
ideally we should characterize the size of changes between two different versions based on their program binaries.
however measuring differences between two binaries is a hard problem .therefore we uselinesof source codechanges locc asanapproximatemetricofchangebetweentwosoftware versions.
for our evaluation we repeat the experiments detailed in section5.
.1forffmpegon7minorreleasesforversion4.
.
.
.
.
.
.
.
.
.
.
.
.
and .
.
.
the locc between minor releases range from to around lines with a geomean of lines whereas loccbetweenmajor ffmpegreleasesevaluatedin section5.
.1rangefrom128kto390klineswithageomeanof227k.
figure5ashowsthedifferentialthroughputresultsalongwiththeir errorpercentage.
we repeat the experiment for clang for which we evaluate minor .
releases .
.
.
.
.
.
.
.
.
.
and .
.
.
the locc between these minor releases range from to around 4k lines with a geomean of lines.
in contrast the locc between major clangreleases evaluated in section .
.2range from .6m to 6m lines with a geomean of .6m lines.
figure 5bshowsthedifferentialthroughputresultsaswellastherespective theirerrorpercentage.
both experiments show that mcad s predictions follow the hardwarecyclecountsclosely withonlymarginalerrorrateofless than1 onaverageand1.
inthe worst case.
.
scalabilityandcomparison besides accurate predictions that generalize across control f low transfers another major goal of mcad is scalability.
in particular weaimformcadtoscaleupwiththecomplexityofreal worldtarget programs.
in this section we compare against fourstate of theartthroughputpredictionandanalysisapproaches osaca ithemal uica and llvm mca .
we present the results intable1.
first wefocusonthebenchmarksthesetoolsusedintheirrepositoriesorpublications.wecomparethetypeandsizeofbenchmark aswellastheirsupportedtargetinstructionsets.allpriorartoperates on the individual basic block level with the exception of llvmmcawhichalsocontainsdesignatedsupportforloopkernels.
however in both cases instruction sequences usually consist of only instructions at most.
on the other hand mcad was designed to work on real world program traces containing millionsof instructions.
mcad also supports most of the hardware architectures that qemu and llvm support which amounts to nearly different instruction set architectures isas .
in contrast mostother tools are highly architecture speci f icand onlysupport x86 64. we further evaluatethesetoolsusing thesame reference input and compare their performance with respect to execution time and memoryconsumption.forthispurpose wecollectedtheexecution traceofa ffmpeginvocation using version .2asdescribed insection5.
.1storing the results into a f ile.
the resulting instruction stream consists of roughly million x86 64 instructions.
to give state of the art approaches the bene f it of the doubt we perform thisexperimentonan80 coreintelxeone7 4870machine clocked at .4ghz equipped with 198gb of ram and the same amount of swapspace settinga48 hour time limit onthe execution.
as shown osaca and ithemal did not f inish this task osaca bailedoutwithfailuresrelatedtoloadinghardwaremodelsafter parsingtheinput f ile ithemalpromotedanout of memoryerror from its dynamorio runtime before bailing out.
similarly uica could not f inish within the time limit after consuming signi f icant amount of memory.
last but not the least despite being ableto f inish llvmmca consumedsigni f icantlymore timeand memorycomparedtomcad demonstratingtheeffectivenessof our changes over standardmcainour implementation.
discussion currentstate of the artthroughputpredictionapproacheseither explicitlymodelorlearnmicroarchitecturalimplementationdetails resourceusage instructionscheduling andlatencynumbers using data.thisdataissometimesprovidedbyprocessorvendorsdirectly although most of the time it is collected using emperical methods 5uica uses the mean absolute percentage error mape to compare the error of a predictionagainstasingleexecutiononaphysicaldevice whereasweusethemean errorof the predicted difference in cyclesbetween twoexecutions.
829esec fse december3 san francisco ca usa min yih hsu felicitas hetzelt david gens michaelmaitland andmichaelfranz table comparison ofdifferenttools to predictcyclecountsofsoftware across various dimensions.while the errormetrics differ we presenterrornumbers as reported by themostrecentwork forcompleteness.
uica osaca ithemal llvmmca mcad execution time timeout after48h.
exitw errorafter24h.
exitw errorafter2m.
.98s .69s ffmpegresults clangresults memory usage 113gb n a n a .39gb .16gb scalesto ofinstrs.
mean error benchmarktype basic block loop kernel basic block loop kernel whole program supported isas x86 64only x86 64only x86 x86 64 isas isas handlesbranches like measuring instruction latencies using many different software con f igurations andlargenumbersofrepetitionstoreduceinherent errorsignals.
mcad builds on top of this prior work that provides insights intomodernprocessorpipelinesthroughdetailedmeasurements andexperiments.since alot ofthisresearchhas beencontributed inpart by vendors directly andinotherparts incorporatedby the community into the llvm compiler infrastructure mcad currently usesllvm mcaas thecore analysisengine.
however the core analysis component in our designcan support other throughput analysis engines in principle which would allowus to predict timingeffectsofanumberofoptimizationsinmodernprocessors thatarenotcurrentlymodeledbyllvmmca suchasincluding instructionprefetchingandbranch prediction whichusually happenintheprocessorfrontend.themainobstacletowardsthatas demonstrated by our experiments in section .
however remains overcoming scalability issuesofthe relatedapproaches.
lookingaheadtofutureworkweanticipatethatresearchinto analysis of multi process and multi thread executions should be feasiblewithinmcad inprinciple.asintroduced insection 3we collect execution traces using qemu and a custom plugin and certain recently added qemu plugin interfaces would allow us to distinguish traces originating from different virtual cpus at runtime.nevertheless howtoincorporatemodernprocessors concurrency models into current throughput prediction approaches remains an open research question.
it would also be possible to substituteqemuforothermethodsofexecutiontracecollectionentirely for instance leveraging binary rewriting tools would enable us to insert instrumentations that report the executed instructions natively.
last but not least we believe a more scalable intuitive and interactive timeline or waterfall view could provide developers with more insights by visualizing resource dependencies among instructions pointing towards potential avenues for improving continuous developmentoftiming sensitive code.
related work inthissection wecategorizethemostrelevantpriorapproachesand alsocomparethemagainstmcad.tothebestofourknowledge noneoftheexistingsystemssupportsanalyzingtimingeffectsof programsinatimelymannerthatsupportsadevelopment driven work f lowthatcanguideimplementationchangeswithrespectto timing sensitive systembehavior.
a large body of prior research focused on static prediction of worst case timing behavior .
however reasoningabouttimingpropertiesofarbitraryprogramsreducestothe halting problem inthe generalcaseandas aresult approachesfor calculating worst case execution time make strong assumptions suchasanupperboundonthenumberofloopiterations recursion depth effectsofmemoryaccesses andexternali o operations.in practice thismeansthattheuseroftraditionaltoolshastoprovide upperboundinformationforallloopconstructs recursion avoid indirectmemoryaccessesthroughpointers andavoidtheuseof i o operations inanalyzedparts of the code.ensuringproper and correctusagethentypicallyrequiresdedicatedbuildtoolchainsand environmentsetups aswellasexpertknowledgeabouttheanalysis framework.
moreover such tools typically over approximate cycle countsuptoseveralordersofmagnitudeoverphysicalhardware executioninordertoremainsound withseveraltoolsproviding timingestimatesinunitsof wall clocktime ratherthancycles .
more recently a number of approaches proposed throughputmodelingofmachinecodeusingparametricmodelsfor accurate yetfastthroughputprediction.suchapproachespredict timing aspects of a particular instruction sequence of the target program rather than reasoning about the entire set of possible executions at once like prior static approaches do.
while their underlyingparametricmodelsrequireknowledgeofkeymicroarchitectural aspects such as port usage instruction latencies and other internal details that may not be publicly available recent advancesinmachinelearningshowedthatarchitecturedependence canbe tackledtosomeextent by learningmodel parametersfrom data .however withoutrulingouttheuseoflearning based solutions our evaluation show that currently such approaches are severelylimitedwithrespecttoscalability providingthroughputestimatesonlyforahandfuluptoafewhundredinstructionsatmost also lacking support for predictionacrosscontrol f lowtransfers.in 830a highly scalable hybrid cross platform differentialthroughput estimationframework esec fse december3 san francisco ca usa contrast mcadhandlescomplexbinaryprogramscontainingliterally millions of individualinstructionswithnear native execution speeds.
dynamicapproachesaimatprovidingdetailedandconcretetiming analyses of the runningsoftware using concrete inputs.
there are two main f lavors of dynamic timing analysis tools either using physical hardware tracing or using architectural simulators.
approaches using physical tracing execute the program on the target architecture and measure cycle counts directly using the facilities provided by the device .
while in theory this yields the most precise results and should also be reasonably fast in practice this is often not the case the target architecture might be a productionsystemthatisnotreadilyavailabletothedeveloperrunning the test and in a collaborative environment each team would require their own physical device to test their changes against.
additionally settingupandusingfacilitiesforaccuratecycle count measurementscanbeatime intensivetaskinandofitself requiring complicated setup and potentially support by the target program s buildtoolchainaswellastheoperatingsystemoftheproduction system.
cycle accuratearchitecturalsimulators ontheother handpromisetoprovideasimilarlevelofaccuracyasphysicaltracingwithoutrequiringanactualphysicaldevicetocaptureprogram execution.unfortunately simulation based approaches also come with major drawbacks f irst performance is typically at least three orders of magnitude slower than native execution or even slower astheyfaithfullysimulatemicroarchitecturaldetailsofmodernprocessorpipelinescompletelyinsoftware.second theyareusually aimedtowardsexplorativehardwaredesignandimplementation studiesofnovelarchitecturesratherthansimulatingthroughputof software for existing platforms.asaresult theseframeworks are noteasilyaccessibleandcanbedifficulttointegrate withexisting software development tools and continuous integration work f lows duetothehighresourcerequirementsandtime intensivenature ofthe simulation basedapproach.
conclusion tosummarize ourresultsshowthatmcadimprovesonthestateof theartbyscalinguptocomplexreal worldsoftware.itiswellsuited to providing cycle count estimates with rapid developer centric turn around times while targeting a range of different hardware architectures.mcadcandrivesoftwaredevelopmentbyquickly iterating on small changes and assessing their timing impact on real world programs such as ffmpegandclang with a mean error indifferentialthroughputestimatesof comparedtohardwarebasedmeasurements.