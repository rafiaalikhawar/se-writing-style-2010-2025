sjfuzz seed and mutator scheduling for jvm fuzzing mingyuan wu southern university of science and technology shenzhen china the university of hong kong hong kong china mail.sustech.edu.cnyicheng ouyang minghai lu mail.sustech.edu.cn mail.sustech.edu.cn southern university of science and technology shenzhen chinajunjie chen yingquan zhao junjiechen tju.edu.cn zhaoyingquan tju.edu.cn college of intelligence and computing tianjin university tianjin china heming cui the university of hong kong hong kong china heming cs.hku.hkguowei yang the university of queensland queensland australia guowei.yang uq.edu.auyuqun zhang southern university of science and technology shenzhen china zhangyq sustech.edu.cn abstract while the java virtual machine jvm plays a vital role in ensuring correct executions of java applications testing jvms via generating and running class files on them can be rather challenging.
the existing techniques e.g.
classfuzz andclassming attempt to leverage the power of fuzzing and differential testing to cope with jvm intricacies by exposing discrepant execution results among different jvms i.e.
inter jvm discrepancies for testing analytics.
however their adopted fuzzers are insufficiently guided since they include no well designed seed and mutator scheduling mechanisms leading to inefficient differential testing.
to address such issues in this paper we propose sjfuzz the first jvm fuzzing framework with seed and mutator scheduling mechanisms for automated jvm differential testing.
overall sjfuzz aims to mutate class files via control flow mutators to facilitate the exposure of inter jvm discrepancies.
to this end sjfuzz schedules seeds class files for mutations based on the discrepancy and diversity guidance.
sjfuzz also schedules mutators for diversifying class file generation.
to evaluate sjfuzz we conduct an extensive study on multiple representative real world jvms and the experimental results show that sjfuzz significantly outperforms the sota mutation based and generation based jvm fuzzers in terms of the inter jvm discrepancy exposure.
moreover sjfuzz successfully reported potential jvm issues where were confirmed as bugs and have been fixed by the jvm developers.
mingyuan wu is also affiliated with the research institute of trustworthy autonomous systems shenzhen china.
yicheng ouyang is now a phd student in university of illinois urbana champaign.
yuqun zhang is the corresponding author.
he is also affiliated with the research institute of trustworthy autonomous systems shenzhen china and guangdong provincial key laboratory of brain inspired intelligent computation china permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
concepts software and its engineering software testing and debugging .
keywords jvm testing mutation based fuzzing acm reference format mingyuan wu yicheng ouyang minghai lu junjie chen yingquan zhao heming cui guowei yang and yuqun zhang.
.
sjfuzz seed and mutator scheduling for jvm fuzzing.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
.
introduction the java virtual machine jvm refers to the virtual machine which interprets and executes java bytecode compiled from various highlevel programming languages e.g.
java scala and clojure .
typically after source code files are compiled to bytecode class files jvm first leverages class loaders to load such class files in terms of the strict order of loading linking and initialization.
then jvm directly executes the bytecode or transforms the loaded bytecode into machine code for actual execution via just in time jit or ahead of time aot compilers for optimization purposes.
multiple jvm implementations such as oracle s hotspot alibaba s dragonwell ibm s openj9 azul s zulu and gnu s gij have been widely applied in support of a variety of java bytecode based applications.
while ideally they are expected to implement the same jvm specification and conform to consistent cross platform robustness they are usually implemented by different groups for different platforms and thus may cause de facto inconsistencies which are likely to indicate jvm defects e.g.
the same class file may run smoothly on one jvm but trigger verifier errors on another jvm.
testing jvms via manually designing tests based on analyzing jvm semantics can be extremely challenging due to their intricacies i.e.
it is hard to generate sufficient high quality inputs based on complicated jvm semantic rules to thoroughly test the program esec fse december san francisco ca usa m. wu y. ouyang m. lu j. chen y. zhao h. cui g. yang and y. zhang.
states of jvm executions.
to address such a challenge prior research work attempts to integrate fuzzing and differential testing for automated jvm testing i.e.
designing fuzzers to generate class files as tests for executing different jvms such that their discrepant execution results defined as inter jvm discrepancies in this paper can be used for testing analytics.
for instance classfuzz fuzzes java class files by mutating their modifiers or variable types to test the loading linking and initialization phases in jvms.
more recently classming fuzzes live bytecode to mutate the control flows in class files to test deeper jvm execution phases e.g.
bytecode verifiers and execution engines across multiple jvms.
however the power of the existing jvm fuzzers may not be fully leveraged since they fail to apply seed scheduling and mutator scheduling mechanisms which have become vital in enhancing fuzzing effectiveness.
in particular seed scheduling refers to aggressively selecting and mutating seeds to facilitate program bug vulnerability exposure.
many coverage guided fuzzers schedule seeds for mutation simply when executing them can increase code coverage.
the existing jvm fuzzers on the contrary fail to leverage code coverage as seed scheduling guidance because they can hardly exploit the runtime coverage information for fuzzing since jvms are likely to cause non deterministic coverage at runtime due to their adopted mechanisms e.g.
parallel compilation and on demand garbage collection .
specifically classfuzz only collects coverage information for initializing jvms and classming even exploits no coverage for fuzzing.
similarly while scheduling mutators guided by code coverage has been proven effective recently the existing jvm fuzzers are restrained by selecting mutators uniformly under no guidance.
in this paper we present sjfuzz scheduling for jvmfuzz ing in our github repository a jvm fuzzing framework which applies seed and mutator scheduling mechanisms to facilitate the exposure of discrepant execution results among different jvms i.e.
inter jvm discrepancies for jvm differential testing.
specifically sjfuzz schedules seeding class files under two types of guidance discrepancy and diversity.
on one hand sjfuzz retains the class files that can be executed to directly incur inter jvm discrepancies or used to generate mutants for sufficiently testing jvms i.e.
avoiding early termination on jvm testing process as seeds for further mutations.
on the other hand assuming that increasing code coverage can be reflected by diversifying test case class file generation sjfuzz applies a coevolutionary algorithm to filter the remaining class files to augment class file diversity for further mutations.
moreover sjfuzz also iteratively schedules mutators to augment the overall distances between seed and mutant class files.
in particular for a given seeding class file sjfuzz estimates the diversity expectation of each mutator and selects a mutator to optimize the class file diversity.
to evaluate sjfuzz we conduct a set of experiments upon various popular real world jvms e.g.
openjdk openj9 dragonwell and oraclejdk.
in particular we apply sjfuzz andclassming the stateof the art mutation based jvm fuzzer to generate class files via seeding class files selected from popular open source java projects which are then executed in the studied jvms to expose their discrepancies.
moreover to further demonstrate the power of sjfuzz we also include javatailor a generation based jvm fuzzer that utilizes existing jvm historical bug revealing test programs to1protected enumeration url findresources ... i0 ... r4 r1.parent ... i0 i0 ifi0 goto line lookupswitch i0 case goto line default goto line r3 r5 ... z0 r1.ignorebase r1.ignorebase is always if z0 goto line r7 specialinvoke r1.getrootloader if r7 !
null goto line ... r8 specialinvoke r1.getrootloader r9 virtualinvoke r8.getresources r2 ... r6 staticinvoke collectionutils.append r3 r14 return r6 figure a class file generated under diversification guide.
expose jvm discrepancies as our baseline.
the results suggest that sjfuzz significantly outperforms classming in terms of inter jvm discrepancy exposure e.g.
exposing .
.
more total unique discrepancies on average.
meanwhile sjfuzz also outperforms the javatailor by .
.
in terms of total unique inter jvm discrepancy exposure.
moreover we have reported potential issues to their corresponding developers after analyzing the inter jvm discrepancies incurred by sjfuzz .
as of submission time bugs have already been confirmed by the developers.
in summary this paper makes the following main contributions technique.
we introduce sjfuzz which to the best of our knowledge is the first jvm fuzzing framework that applies seed and mutator scheduling mechanisms to test jvms.
implementation.
we implement our jvm testing approach as a practical system based on jimple level mutation via the soot analysis framework .
evaluation.
we conduct an extensive evaluation upon four popular jvms and various real world benchmark projects.
the experimental results demonstrate that sjfuzz significantly outperforms the sota mutation based and generation based jvm fuzzers.
notably we reported potential issues found by sjfuzz out of which were confirmed and were fixed by the developers.
motivating example in this section we introduce a real world jvm bug exposed by applying differential testing via mutating program control flows to illustrate the potential issues of state of the art classming and motivate sjfuzz .
specifically figure shows a simplified jimple code snippet of a mutated method findresources inantclassloader.class from project ant where the jimple code representation refers to a soot based intermediate representation of java programs for simplifying java bytecode analysis .
running such a class file exposes an execution discrepancy between openjdk .
.0 232 and openj9 .
.0 232 .
specifically in the original seeding class file after z0is assigned with the value of member ignorebase ofr1 i.e.
line line is immediately executed followed by line .
however inserting the lookupswitch instruction changes the control flow to be from line to line .
next method getresources of the root class loader is invoked line .
as 1063sjfuzz seed and mutator scheduling for jvm fuzzing esec fse december san francisco ca usa update seed s estimation mutantappend queue ... seed schedulingclass file method mutator execute jvms mutator scheduling seed class figure the framework of sjfuzz .
a result by passing parameter meta inf manifest.mf togetresources openjdk8 .
.0 232 returns nothing while openj9 .
.0 232 returns the paths of the manifest.mf files in its lib jars.
we further found such a discrepancy was triggered as openjdk8 failed to find the existing resources.
although this discrepancy can be exposed by simply inserting alookupswitch instruction to the seeding class file classming failed to expose such a discrepancy under multiple runs in practice.
specifically we found that for the example class file classming updated new seeding class files after iteratively generating mutants via uniformly selected mutators and failed to reproduce the discrepancy inducing execution path under a fair time limit.
this fact suggests that adopting similar seeding class files via only uniformly selected mutators may hinder the effective exploration of discrepancy inducing mutants.
furthermore we also observe that while classming typically adopted similar seeding class files mutated from one root throughout causing inefficient usage of computing resources which can be leveraged to explore other promising seeding class files e.g.
the ones that can expose multiple discrepancies simultaneously.
this fact also leads to a demand of scheduling multiple seeding class files other than only one in one run based on their discrepancy guided potentials.
to conclude inspired by previous works all these insights motivate our proposed approach sjfuzz which effectively schedules seeding class files and diversifies their mutations to increase the chances of exposing discrepancies for jvm testing.
the approach of sjfuzz the framework of sjfuzz is demonstrated in figure .
overall sjfuzz enables iterative mutation based class file generation.
in particular given a seeding class file sjfuzz adopts the control flow mutation strategy to generate its mutant class file section .
.
accordingly for each iteration sjfuzz schedules seeding class files section .
under the diversity and discrepancy guidance.
sjfuzz also schedules mutators deterministically or randomly to augment class file diversity section .
for further iterations.
algorithm shows the details of sjfuzz which is initialized by adding one seedclass into the queue and assigning the seedclass to be optional defined in section .
.
under each iterative execution line sjfuzz schedules control flow mutators for each class file in the queue to facilitate class file diversity lines to .
note that a newly generated class file is initialized as an optional seed line .
such a seed and its parent i.e.
mutantclass andclass can be identified whether to be primary defined in section .
after running on the adopted jvms lines to .
for any valid mutant class file sjfuzz updates its distance to its seeding class file to guidealgorithm the framework of sjfuzz input seedclass budget bound output queue function sjfuzz framework queue list queue.add seedclass setclasstooptional seedclass while total budget has not exceeded do forclass in queue do method randomlyselectmethod mutantclass schedulemutator class method setclasstooptional mutantclass runjvms mutantclass ifmutantclass incurs new discrepancies then setclasstoprimary class ifmutantclass is valid then setclasstoprimary mutantclass ifmutantclass is valid then distance levenshtein class mutantclass updatemutatordistance class distance else updatemutatordistance class primary retainprimaryseeds queue bound discrepancy guidance option scheduleoptionalseeds queue bound diversity guidance queue merge primary option retain seeds for next iteration return queue further mutator scheduling lines to and the distance for each invalid mutant class file is updated to line .
at last all theprimary class files and filtered optional class files are retained for future mutations as the output of the discrepancy guidance and the diversity guidance lines to .
after each iteration the updated seeding class files are used for jvm differential testing.
such iterations are terminated when hitting the budget .
note that sjfuzz only enables valid class files for mutations because mutating an invalid class file tends to cause exceptional program behaviors rather than unexplored inter jvm discrepancies.
.
control flow mutation prior research work on fuzzing compilers including jvms tend to mutate program control flows via a set of corresponding mutators for exposing bugs in their deep execution stages .
following such prior works and also for a fair comparison with them sjfuzz also adopts such control flow mutation with representative mutators.
specifically in source code level sjfuzz randomly selects two original instructions and creates a directed transition between them.
if such a transition is a loop the corresponding iteration will be limited to times.
correspondingly sjfuzz implements the mutators with the jimple level instructions goto lookupswitch and return provided in soot .
sjfuzz iteratively selects random positions from randomly selected methods to apply the control flow mutators.
specifically sjfuzz establishes an instruction list which contains the instructions executed by the adopted jvms under their execution order.
next sjfuzz selects and inserts a control flow mutator into a random spot of the instruction list under each iteration.
1064esec fse december san francisco ca usa m. wu y. ouyang m. lu j. chen y. zhao h. cui g. yang and y. zhang.
.
seed scheduling since it is difficult to directly apply coverage guidance for fuzzing jvms we adopt two alternative types of guidance for our seed scheduler.
in particular we develop a discrepancy guided seed scheduler which retains discrepancy inducing class files for further mutations.
we also develop a diversity guided seed scheduler which filters other class files to augment the overall class file diversity via a coevolutionary algorithm .
discrepancy guided seed scheduling.
intuitively if running a mutant of a class file can cause inter jvm discrepancies such a class file is likely to generate more discrepancy inducing mutants than other class files as it implies a potential connection with program bugs .
therefore such a class file and its mutant if valid i.e.
successfully running in at least one jvm under test without unexpected behaviors such as verifier errors or crashes are defined asprimary class files and are retained for future iterative executions.
this seed scheduler is essentially similar to many coverage guided seed schedulers which tend to retain seeds when running them can increase code coverage.
diversity guided seed scheduling.
when running a mutant of a class file does not instantly cause inter jvm discrepancies it does not necessarily suggest that no discrepancy inducing mutants can be generated in future iterative executions.
in other words leveraging such class files can also possibly advance the inter jvm discrepancy exposure.
in this paper such class files are characterized as optional .
note that differential testing usually enables vast space for generating test cases which indicates that the total number of class files that cause discrepancies between sophisticated jvms can be rather limited.
we can then infer that the optional class files may significantly outnumber the primary class files.
therefore sjfuzz should filter the optional class files to ensure fuzzing efficiency.
we consider that increasing code coverage can be essentially reflected as diversifying execution paths on the same jvms and thus demands diverse test cases i.e.
class files .
therefore our seed scheduler for optional class files is guided by class file diversity so that the optional class files are filtered to augment class file diversity.
in particular how to measure class file diversity should be resolved in the first place.
to accurately reflect the fine grained differences between class files an ideal metric is expected to reflect their instruction by instruction comparisons.
therefore we adopt the executed instruction list of a given class file namely entryinstruction as the representative instructions to efficiently measure the diversity between jvm class files.
note that entryinstruction reflects the instruction level execution order and retains only the unique executed instructions to reduce the ambiguity of diversity measurement caused by repeated instructions e.g.
in loops.
eventually we measure the diversity between a pair of class files by deriving differences between their associated entryinstruction s. in this paper sjfuzz applies edit distance i.e.
levenshtein distance a metric widely used to derive the minimum number of single character edits insertions deletions or substitutions between two strings to measure the difference between entryinstructions because the mutation based class file generation can analogize the single character string edits as demonstrated in .
to be specific sjfuzz generates class files by mutating the selected seedingclass files i.e.
inserting the instructions with the adopted control flow mutators.
the resulting iterative single point mutations between the seed and mutant class files can be modeled as inputs for levenshtein distance based computation when such class files are all modeled as strings .
for instance assume two entryinstructions of their corresponding class files c1 and c2 .
we can observe that c1can be transformed fromc2by only inserting one instruction i2betweeni1andi3.
therefore their levenshtein distance is computed as .
accordingly sjfuzz adopts a coevolutionary algorithm to efficiently evaluate the individual optional class files out of their group by constructing its fitness function to reflect their average distances with other optional class files.
specifically for each optional class file sjfuzz calculates its total levenshtein distance with other optional class files.
subsequently the average levenshtein distance is calculated as the fitness score of the given class file.
by sorting all the derived fitness scores sjfuzz retains the top n corresponding optional class files for further mutation based class file generation where n is predefined as the bound variable in algorithm .
to illustrate we incorporate the discrepancy and diversityguided seed schedulers to facilitate code coverage and inter jvm discrepancies when differentially testing jvms.
.
mutator scheduling since it is computationally expensive to derive the exact diversity of the overall class files on the fly sjfuzz schedules mutators to diversify the seed and mutant class files under each iteration to approximate the overall class file diversity instead.
in particular sjfuzz first applies the edit distance i.e.
levenshtein distance in this paper to delineate the diversity between a pair of class files.
accordingly sjfuzz establishes a deterministic mutator scheduling mechanism for estimating the mutator that can optimize the seedmutant distance.
meanwhile sjfuzz also develops a random mutator scheduling mechanism to prevent the potential local optimization that can derive local optimal mutators caused by the deterministic mutator scheduling mechanism .
as a result sjfuzz derives a mutator for a given class method by combining the two mechanisms.
deterministic mutator scheduling.
note that any mutator selected from one iteration can incur cumulative impact on the mutations of the subsequent iterations.
to capture such cumulative impact from the previous mutations sjfuzz adopts the monte carlo method to develop the deterministic mutator scheduling mechanism where given a selected method mp sjfuzz develops a value function represented as v ci aj mp to determine the mutation opportunity of class file ciby applying a mutator ajas demonstrated in equation .
such a value function can reflect the resulting diversity of the overall class files under the mutation i.e.
the cumulative diversity expectation between the seed and mutant class files under all the iterations.
v ci aj mp e nn k 0distancek ci aj mp heredistance refers to the levenshtein distance between the seeding class file ciand its mutant class file by applying mutator aj upon method mp.distancek ci aj mp refers to their levenshtein distance in the kthiteration which can be dynamically updated 1065sjfuzz seed and mutator scheduling for jvm fuzzing esec fse december san francisco ca usa algorithm mutator scheduling input class method explorationrate output mutantclass function schedule mutator rand random ifrand explorationrate then mutator selectrandommutator class method mutatedclass mutate mutator class generate a mutant by a mutator else bestmutator selectdeterministicmutator method mutatedclass mutate bestmutator class return mutatedclass since the mutation spot is randomly selected in mpunder each iteration.
erefers to the mathematical expectation of distance s. it can be derived that v ci aj mp forciis incrementally updated and inefficient to be directly computed.
therefore we further enable dynamic updates on vk ci aj mp as presented in equation to approximate its value where is a constant.
note when one class filecifails to generate a valid class its distance is set to .
vk ci aj mp vk ci aj mp distance vk ci aj mp as a result we select a mutator ajcorresponding to the largest v ci aj mp forci.
typically sjfuzz allows computing v ci aj mp after running the mutant class files on jvms such that it can be used for mutator selection of the subsequent iteration when needed as in line of algorithm .
random mutator scheduling.
only maximizing v ci aj mp tends to cause local optimization i.e.
v ci aj mp is likely to converge to one mutator after iteratively selecting it while the actual optimal mutator cannot be derived until later iterations.
to address such an issue sjfuzz further leverages a random mutator scheduling mechanism to reduce its possibility to select a sub optimal mutator under early terminated executions by randomly selecting one mutator for class file generation for the ongoing iteration.
as a result by properly combining such a mechanism with the deterministic mutator scheduling mechanism it can potentially extend the monte carlo process until convergence for enhancing the selection probability of the optimal mutator i.e.
preventing the local optimization.
the overall mutator scheduling mechanism is presented in algorithm .
we first set an explorationrate and generate a random value for comparison line .
next if such a random value is less than the explorationrate sjfuzz chooses the random mutator scheduling mechanism to return a random mutator for the ongoing iteration lines to .
otherwise sjfuzz derives the mutator via thedeterministic mutator scheduling mechanism lines to .
evaluation we conduct a set of experiments on various popular jvms.
note that we include two state of the art jvm fuzzers the mutationbased fuzzer classming and the generation based fuzzer javatailor in our evaluation for performance comparison.
in particular classming fuzzes live bytecode to mutate the control flows in class files as mentioned and javatailor generates class files from jvm historical bug revealing test programs provided by the authors .
overall we aim to compare sjfuzz with them interms of their resulting inter jvm discrepancies the class file generation efficiency and the reported bugs by answering the following research questions rq1 issjfuzz effective in exposing inter jvm discrepancies?
rq2 are the seed and mutator schedulers effective?
rq3 is the diversity guidance effective?
moreover we report and analyze the bugs detected by sjfuzz with all the evaluation details presented in our github page .
.
benchmark construction we adopt multiple widely used real world jvms i.e.
openjdk openj9 dragonwell and oraclejdk for running sjfuzz to expose their execution discrepancies.
note that their detailed versions are available on our github page since multiple versions of each jvm are used in our evaluation.
we also adopt state ofthe art mutation based approach classming and generation based approach javatailor as the baselines for comparison as they outperformed other existing jvm differential testing approaches .
specifically for a fair comparison with sjfuzz which integrates differential testing and test generation we also run classming and javatailor on all studied jvms in parallel.
to launch sjfuzz we adopt class files via randomly sampling from well established open source projects as the seeding class files for mutation based class file generation.
to construct such benchmarks we first attempt to collect all available class files originally adopted for evaluating classming for approaching a fair performance comparison.
as a result eclipse jython fop and sunflow are selected due to their availability while others incur stale configurations jar incompatibility mismatched main declarations etc.
moreover we also adopt antandivy two popular command line applications from apache projects and junit a widely used unit testing framework to expand our benchmark diversity.
note that while the existing approaches e.g.
classming and classfuzz are designed to only launch mutations for the entry methods corresponding to the main methods in this paper we attempt to adopt diverse entry modes i.e.
diverse method types entries for mutation.
particularly we adopt two such modes mainentry andjunit entry .
more specifically in addition to main entry adopted by the new junit entry mode on the other hand refers to mutating other entry methods associated with junit tests of the seeding class files.
to our best knowledge we are the first to execute the unit tests of the seeds in compiler testing.
junit entry can benefit the class file generation for the following reasons.
first junit entry supplements main entry on the mutation space for a class file which cannot be explored by main entry only since a large amount of junit test classes are designed for non main methods in practice.
next the execution discrepancies between jvms are likely to be better presented in junit entry since assertions examine different jvm executions upon class files and thus enable smaller scope in exposing discrepancies and easier analytics than main entry .
in this paper for main entry we select seeding class files as the class files containing the main methods.
for junit entry since each project contains various test classes we randomly adopt class files under test for each project with more than corresponding 1066esec fse december san francisco ca usa m. wu y. ouyang m. lu j. chen y. zhao h. cui g. yang and y. zhang.
test methods from the projects fop jython ant ivy and junit which all use the junit framework with available test source files on the corresponding github repositories.
note that fop jython ant and ivyare chosen as both the main entry and junit entry benchmarks for straightforward performance comparison between the two modes within one project.
.
environmental setups we perform our evaluation on a desktop machine with intel r xeon r cpu e5 and gb memory.
the operating system is ubuntu .
.
the explorerate for algorithm is set to .
and thebound for algorithm is set to by default.
similar as prior work all benchmarks are executed by all the studied approaches for hours to generate class files to reflect a large enough testing budget .
note that we run each experiment times for obtaining the average results to reduce the impact of randomness.
.
result analysis table discrepancies exposed by sjfuzz classming and javatailor .
project benchmark .class sjfuzz classming javatailor total unique total unique total unique eclipse eclipsestarter .
.
.
.
.
.
fop fop .
.
.
.
.
.
jython jython .
.
.
.
.
.
sunflow benchmark .
.
.
.
.
.
ant launcher .
.
.
.
.
.
ivy main .
.
.
.
.
.
fop junit fopconfparser .
.
.
.
.
.
fopfactorybuilder .
.
.
.
.
.
resourceresolverfactory .
.
.
.
.
.
fontfilereader .
.
.
.
.
.
jython junit pybytearray .
.
.
.
.
.
pyfloat .
.
.
.
.
.
pysystemstate .
.
.
.
.
.
pytuple .
.
.
.
.
.
ant junit antclassloader .
.
.
.
.
.
directoryscanner .
.
.
.
.
.
project .
.
.
.
.
.
locator .
.
.
.
.
.
ivy junit resolvereport .
.
.
.
.
.
apacheurllister .
.
.
.
.
.
configurator .
.
.
.
.
.
ivyeventfilter .
.
.
.
.
.
junit junit rulechain .
.
.
.
.
.
testwatcher .
.
.
.
.
.
errorreportingrunner .
.
.
.
.
.
money .
.
.
.
.
.
average .
.
.
.
.
.
p value n a .35e .
.
.
rq1 the inter jvm discrepancy exposure effectiveness of sjfuzz.
note that in this paper to identify unique discrepancies we first summarize the symptoms of the discrepant jvm behaviors including assertions in junit tests exceptions and the results printed in standard output.
then we compare such symptoms with the previously recorded unique discrepancies to distinguish whether they are unique or not.
more specifically we first divide the overall output results into two categories non exception output e.g.
assertions in junit tests and results printed in standard output and exception .
typically an exception can be respectively presented for different jvms.
we then represent an exception as a tuple of its type and location from the output result.
furthermore given one exception on all tested jvms one discrepancy is formed by collecting analyzing and combining all their exception information.
ifno such a discrepancy was collected before it is considered unique.
the implementation code for this process can be found at .
the inter jvm discrepancy results both the total and the unique discrepancies after executing the generated class files are presented in table .
for instance for benchmark jython.class sjfuzz exposed a total of .
discrepancies and .
unique discrepancies averagely.
we can observe that overall sjfuzz can significantly outperform classming in terms of the inter jvm discrepancy exposure.
to be specific sjfuzz can expose .
total discrepancies and .
unique discrepancies on average while classming can expose .
total discrepancies and .
unique discrepancies on average i.e.
sjfuzz exposes over .
.
more total unique discrepancies than classming .
moreover we can further find that for all the adopted benchmark projects sjfuzz can significantly outperform classming in terms of both the total and unique discrepancy exposure.
note that sjfuzz also exposes all the discrepancies found byclassming in our evaluation.
meanwhile we can observe that sjfuzz can also outperform javatailor by .
more total discrepancies .
vs. .
and .
more unique discrepancies .
vs. .
respectively.
furthermore we apply the mann whitney u test to illustrate the significance of sjfuzz .
it can be seen in table that the p value ofsjfuzz comparing with classming in terms of the average unique discrepancies is far below .
in each benchmark which indicates that sjfuzz outperforms classming significantly p .
.
we can also observe that the p value of sjfuzz comparing with javatailor in terms of the average unique discrepancies is also below .
.
.
such results can reflect that sjfuzz can be quite effective.
interestingly we can observe that the advantage of sjfuzz over javatailor is not quite obvious as over classming i.e.
javatailor is a more powerful baseline.
we infer it is mainly because javatailoradopts a database containing a variety of historical jvm bugrevealing test programs which can be quite enlightening for testing tasks.
nevertheless as a typical data driven approach it can be naturally prone to common issues e.g.
data dependency and extra effort on maintaining the database.
surprisingly sjfuzz a lightweight end to end approach can still outperform javatailor in exposing both total and unique discrepancies indicating the power of our adopted mechanism of seed and mutator scheduling.
finding sjfuzz is effective by exposing .
more unique discrepancies averagely than classming .
vs. .
and .
more unique discrepancies averagely than javatailor .
vs. .
under the same evaluation setups.
figure sjfuzz classming javatailor efficiency in hours.
we further investigate the impact of the execution time on discrepancy exposure by sjfuzz classming and javatailor .
figure 1067sjfuzz seed and mutator scheduling for jvm fuzzing esec fse december san francisco ca usa a exploration rate.
b bound.
figure the impact of the parameter settings on sjfuzz in all benchmarks.
shows how the exposed unique discrepancies on all the benchmarks by the three approaches vary over time.
we can observe that although we enhanced the differential testing efficiency by running jvms in parallel for classming andjavatailor as in section .
we can also observe that sjfuzz can in general consistently outperforms classming andjavatailor in finding jvm discrepancies all the time before terminating the executions.
such results can further indicate the power of the discrepancy guidance mechanism ofsjfuzz .
we also investigate the discrepancies exposed by our adopted entry modes for class file mutations main entry andjunit entry .
specifically sjfuzz can significantly outperform classming under both the entry modes i.e.
sjfuzz can expose .
unique discrepancies in main entry benchmarks and .
unique discrepancies in junit entry benchmarks while classming can only expose .
and .
unique discrepancies under such two entry modes respectively.
javatailor also exposes .
unique discrepancies in main entry benchmarks and .
unique discrepancies in junitentry benchmarks.
additionally for the projects which enable both main entry and junit entry i.e.
fop jython ant and ivy sjfuzz exposes .
unique discrepancies in total under junit entry and .
under main entry .
such a result indicates the effectiveness of our newly proposed junit entry mode for jvm testing.
we highly encourage future researchers practitioners to look into the junit entry mode for advancing jvm testing.
finding junit entry is more effective than main entry in exposing inter jvm discrepancies.
we have also observed that sjfuzz has rather stable performance across different configurations.
to evaluate the impact of the parameter settings on sjfuzz we evaluate the unique discrepancies in terms of different explorationrate in algorithm and bound in algorithm values on our benchmark suite as presented in figure .
in particular we set bound to the default and investigate the impact of different explorationrate i.e.
.
.
.
and .
figure 4a .
we also set explorationrate to the default .
and investigate the impact of different bound figure 4b .
each box plot presents the distribution of exposed unique discrepancies for one configuration across all our studied subjects.
we can observe that different configurations exert limited impact on the performance indicating the effectiveness and stability of sjfuzz .
.
.
rq2 effectiveness of the seed and mutator schedulers.
in this section we investigate the effectiveness of the seed and mutator schedulers respectively.
effectiveness of the seed scheduler.
to investigate the effectiveness of the adopted seed scheduler of sjfuzz we record the number of discrepancies exposed by the primary andoptional class files of the original sjfuzz approach denoted as sjfuzz primary andsjfuzz optional respectively.
furthermore we also build the two variant techniques of sjfuzz sjfuzzpg which only activates discrepancy guided seed scheduling for sjfuzz and sjfuzzef which equally filters the class files regardless whether they are primary oroptional .
note that sjfuzzpgretains the initial class file for further mutations until it explores a primary class file given that the initial class file is not primary .
in general we can observe from table that sjfuzzpgcan be effective by exposing .
total discrepancies and .
unique discrepancies on average.
interestingly only sjfuzzpgitself can enable quite close performance with classming .
total discrepancies and .
unique discrepancies on average as in table .
such results can indicate the effectiveness of our discrepancy guided intuition i.e.
exploiting the power of discrepancy inducing class files can advance jvm differential testing.
interestingly table demonstrates that by integrating sjfuzzpg andsjfuzzef i.e.
applying the original sjfuzz mutating primary class files can incur significantly more inter jvm discrepancies i.e.
.
vs. .
total discrepancies with .
vs. .
unique discrepancies between sjfuzz primary and sjfuzzpg.
such results indicate that injecting optional class files for test case generation can advance the primary class files to generate more discrepancy inducing class files.
to illustrate when mutating optional class files generate discrepancy inducing mutant class files they are all converted to beprimary .
thus primary class files are increasingly adopted for further mutations such that their chances to expose discrepancies can be augmented.
furthermore the fact that sjfuzz optional outperforms sjfuzzefsuggests that directly retaining primary class files for further mutations can also advance the optional class files to expose inter jvm discrepancies.
we can infer that by independently mutating primary class files via revoking their filtering process more optional class files can be retained for further mutations because the primary class files no longer compete against them for being selected.
to summarize sjfuzzpgandsjfuzzefcan mutually advance each other to optimize the performance of sjfuzz .
finding as different components of the seed scheduling mechanism sjfuzz pgand sjfuzz efare both effective and integrating them can further advance each other in terms of exposing inter jvm discrepancies.
effectiveness of the mutator scheduler.
to investigate the effectiveness of the mutator scheduler of sjfuzz we build a variant technique sjfuzzuniform of the original sjfuzz by selecting mutators uniformly.
overall we can observe from table that sjfuzzuniform can expose .
total discrepancies and .
unique discrepancies averagely.
although sjfuzzuniform still outperforms classming .
.
averagely in exposing total unique discrepancies the exposed discrepancies decrease significantly after disabling 1068esec fse december san francisco ca usa m. wu y. ouyang m. lu j. chen y. zhao h. cui g. yang and y. zhang.
table average number of discrepancies found by the studied techniques upon all benchmark projects.
studied subjects all discrepancies unique discrepancies sjfuzz primary .
.
sjfuzz optional .
.
sjfuzzpg .
.
sjfuzzef .
.
javatailor .
.
sjfuzzuniform .
.
classming .
.
sjfuzz .
.
mutator scheduling i.e.
.
.
averagely in exposing total unique discrepancies compared to sjfuzz .
moreover javatailor can outperform this variant by .
.
averagely in exposing total unique discrepancies.
such results indicate that applying the mutator scheduler in sjfuzz can make significant contributions in terms of inter jvm discrepancies.
finding applying the mutator scheduling mechanism can significantly improve the power of exposing discrepancies for jvm fuzzers.
.
.
rq3 effectiveness of the diversity guidance.
the previous findings of the effectiveness of different sjfuzz components can imply their underlying mechanism of diversifying class file generation can be potentially effective.
however accurately measuring data diversity can be rather challenging.
in this paper we delineate class file diversity in terms of the average seed mutant levenshtein distance of the collected class files.
note that since javatailor is a generation based approach i.e.
generating new class files with a variety of jvm bug revealing test programs can naturally result in significantly large levenshtein distances we thus only include classming in this discussion.
the diversity results of the class file generation are presented in figure .
we can observe that sjfuzz incurs much larger average seed mutant levenshtein distance compared with classming i.e.
overall .
larger and .
.
larger under main entry junitentry .
it can be inferred that classming tends to generate similar mutants which also indicates the effectiveness of sjfuzz s diversityguided class file generation mechanism.
we further attempt to infer the possible reasons behind the diversity performance difference between sjfuzz andclassming in terms of the seed mutant levenshtein distance.
assume a mutated class file simplified version in figure with only one executed instruction line .
initially classming would select and insert the return mutator line because other mutators can result in the potential def use violation of the r0 exclusive variables and thus the verification error.
such an error can hinder the detection of deep bugs e.g.
bugs incurred in execution engine.
however under this circumstance the class file in figure is likely to be retained as the seed to repeatedly select the return mutator under each iterative execution for further class file generation.
as a result all the mutant class files realize single mutation difference with their respective seeds i.e.
leading to potential short seed mutant levenshtein distance.
in contrast sjfuzz is free from such constraints because it can diversify seed optional class files with best effort.
figure average seed mutant levenshtein distance.
1class a ... public void somefunction r0 java.lang.system java.io.printstream out return inserted by return mutator ...... figure an example of mutating paradox for classming .
figure average unique discrepancies exposed by different distance metrics in all benchmarks.
moreover even when a seed optional class file generates a similar mutant class file they together are hardly retained for further mutations under the diversity guided class file filtering mechanism.
finding diversifying class file generation is advanced in testing the deep bugs in execution engine by retaining sufficient valid class files.
at last we study the effectiveness of our adopted distance metric i.e.
the levenshtein distance which is used to measure class file diversity.
to this end we adopt more distance metrics for discussing their impact on sjfuzz .
specifically we adopted gestalt pattern matching distance bag distance and jaro distance in our evaluation.
in particular gestalt pattern matching distance adopts the number of matching characters and the length of strings to measure the similarity for two given strings.
bag distance utilizes the maximum length between the relative complements of two given strings character sets with respect to each other to measure their distance.
jaro distance is also a type of edit distance to calculate the similarity of two strings.
as shown in figure distance metrics exert limited impact on the effectiveness of sjfuzz in terms of exposing unique discrepancies.
interestingly we can observe that adopting edit distances i.e.
jaro distance and levenshtein distance can achieve slightly better performance than other distance metrics.
.
bug report and discussion we manually analyze all the collected discrepancies to derive potential issues.
note that in this paper we define a bug as an error or an unexpected behavior for a specific jvm version.
as a result we report potential issues from the discrepancies found by sjfuzz classming fails to expose any of these issues while javatailor can 1069sjfuzz seed and mutator scheduling for jvm fuzzing esec fse december san francisco ca usa table issues found by sjfuzz .
jvms reported confirmed loading phaselinking phaserun time crashloading phaselinking phaserun time crash oraclejdk openjdk dragonwell openj9 total expose of them as in table to their corresponding developers.
as of today were confirmed while were fixed by the developers.
the remaining confirmed bugs are marked as won t fix .
we present some example bug reports as follows.
.
.
resource retrieval bug.
we reported an openjdk bug on retrieving jar information which was confirmed by the openjdk developers with a bug id jdk .
this bug was exposed by the execution discrepancy between openj9 and openjdk.
specifically they both executed one class file from antclassloader.class where openjdk failed to retrieve the jar information from given resources while openj9 succeeded.
the developers inferred that certain side effect changed the behaviors of the original method.
.
.
runtime inconsistency bug.
we have reported an openj9 bug on issuing a runtime erroneous return under the mutated classes from money.class as shown in figure .
we applied its original junit tests on all the class files mutated from money.class which resulted in multiple errors discrepancies.
in particular openj9 reported an assertionerror while openjdk passed the test.
however when we further removed one junit test which caused stackoverflowerror both openj9 and openjdk passed the test.
accordingly we summarized that such a discrepancy may be caused by the unresolved dependency between junit tests and reported it to the corresponding developers .
to tackle such an issue developers applied option optlevel at the warm level and inferred this as a jit issue.
after checking thetree simplification an optimization feature in openj9 developers found that openj9 made a wrong assumption to the nodeisnonzero flag set.
as a result the instruction ificmpne was changed to goto by openj9 and it caused the associated branch to be always executed even when the value of the associated variable did not meet the branch conditions.
eventually they fixed this issue as follows ...the nodeisnonzero flag was set because il gen assumed that slot was still being used to store the receiver and thus the flag did not need to be reset.
there is a method that is supposed to check if slot was re used so that flags can be reset.
this problem can be fixed by adding cases to handle other types of stores to slot ... i will open a pull request to make this change.
.
.
verifier bug.
a verifier bug usually is derived by analyzing the discrepancies about throwing a verifyerror or not.
in particular verifier bugs are perceived typical deep bugs i.e.
bugs that are tricky to be detected and debugged.
by executing the mutated errorreportingrunner.class from project junit we discovered that openjdk .
.0 232 openjdk .
.
and openjdk .
.
threw verifyerror while openj9 .
.0 232 and openj9 .
.
wrongly took it as a valid class file1class a ... public boolean iszero int var1 this .amount openj9 and openjdk get var1 here boolean var2 if var1 var2 true openjdk executed here else var2 false openj9 executed here return var2 figure runtime inconsistency bug in openj9.
for execution.
moreover there even incurred a discrepancy among multiple openj9 versions i.e.
openj9 .
.
threw a verifyerror .
accordingly we inferred that openj9 .
.0 232 and openj9 .
.
were buggy and reported them to developers.
interestingly it took the developers quite a while to understand the cause of such bugs.
at first they speculated this issue as an out of sync problem it seems the code in verifier is likely out of sync or some new changes related to verifier were only merged for openjdk8 openjdk11 given that only openjdk9 openj9 captured verifyerror.
need to further analyze to see what changes in verifier caused the issue.
when they attempted to locate the issue by checking the exception table they found no exception table for the associated method of the mutated class file.
next they divided the issue into two different checking branches one was investigating the simulatestacks for how it propagated the uninitalizedthis a variable to mark the status of simulatestacks which may or may not be launched in the mergestacks code the other was comparing the differences inrtverify.c for different jvm releases.
finally by comparing different versions of rtverify.c the developers have identified that a checking mechanism on uninitializedthis was disabled in matchstack when creating the stackmap .
accordingly openj9 .
.0 232 and openj9 .
.
were confirmed to fail to capture theverifyerror .
the buggy instructions of rtverify.c are demonstrated in figure .
openj9 .
.0 232 openj9 .
.
were allowed to correctly throw verifyerror when enabling the checking mechanism on uninitializedthis by removing line in figure .
however since such a checking mechanism was designed to prevent a spring verifier issue it could not be removed simply.
meanwhile even though the verifyerror could be correctly captured on openj9 .
.
its associated verifyerror message was rather out dated.
such issues together deliver a potential demand on upgrading the verification logic of openj9.
at last the developers have stated that they intend to generate a patch to fix all of the exposed issues .
.
.
controversy arousing issue.
in addition to assisting developers in exploring the deep bugs we even triggered an in depth discussion and revisit to the validity of well established jvm mechanisms via a potential issue reported by sjfuzz .
we have found an issue that openj9 could break the structured locking.
in particular when executing the corresponding 1070esec fse december san francisco ca usa m. wu y. ouyang m. lu j. chen y. zhao h. cui g. yang and y. zhang.
1if !verifydata createdstackmap enable to fix another issue if livestack uninitializedthis !targetstack uninitializedthis rc bcv fail goto finished figure openj9 buggy code in rtverify.c.
... return0 return without exitmonitor ... monitorenter enter the monitor ... invokestatic print.logprint iload iconstm1 iadd istore iload ifle go to line ... figure the illegalmonitorstateexception issue of openj9.
mutated class directoryscanner.class openjdk threw an illegalmonitorstateexception because the executing thread accessed a method and executed entermonitor but simply returned without executing exitmonitor .
however openj9 did not throw illegalmonitorstateexception .
accordingly we inferred that openj9 allowed returning a method under mismatching entermonitor andexitmonitor which broke structured locking and have reported it to the openj9 developers .
figure refers to the partial class file that exposed this issue.
at first the developers denied the potential violation of structured locking i.e.
they analyzed our submitted class file and claimed no violation of structured locking.
however during our further investigation we discovered that while exitmonitor has not been executed from line to line in figure line was executed followed by a return instruction line where illegalmonitorstateexception should have been thrown.
correspondingly the developers reconsidered this issue and finally agreed on the violation of structured locking.
since the developers still insisted on the legitimacy of their development schemes they further questioned and inspected the validity of the structured lock mechanism.
we may end up with cleaner locking code if we enforced structured locking.
this also came up recently in a discussion on how to handle osr points for inlined synchronized methods.
we should investigate the benefits costs of adopting structured locking.
by tracing back to the jvm specification on the structured locking mechanism the developers argued that structured locking could be allowed yet not required.
as a result they considered revoking structured locking to be more as an domain specific adaptation rather than a bug controversially.
in summary sjfuzz is capable of detecting multiple types of deep bugs via exposing inter jvm discrepancies for testing analytics.
furthermore the bugs detected by sjfuzz can be rathertricky to be explored by the existing approaches e.g.
the bug incurred by unresolved junit test dependency and the bug that urged developers to trace back to jvm specifications.
threats to validity the threats to external validity mainly lie in the subjects and faults used in our benchmark.
to reduce the threats we determine to select all the possible projects from classming .
moreover we extend our selections of seeding class files to complicated and popular java projects such as ant for evaluating the scalability of our approach.
the threats to internal validity mainly lie in the potential faults in our implementation including dependent libraries .
to reduce such a threat we apply mature libraries such as soot to implement sjfuzz .
we also carefully review and test our implemented code and the library code.
as a result we even detected a defect in our adopted soot version which injected unexpected string into the output class files such that a valid class file was presented as invalid.
correspondingly we hacked soot s source code and fixed this issue.
the threats to construct validity mainly lie in the metrics used.
to reduce the threats we leverage various widely used metrics for jvm testing including the number of discrepancies as well as the class file diversity and unique bugs found.
related work jvm and compiler testing.
in addition to the aforementioned classfuzz javatailor andclassming sirer and bershad first proposed a grammar based approach to generate class files by randomly changing a single byte in a seed input which can be hardly applied for deeply testing jvms.
yoshikawa et al.
developed a type system that generates java class files which are random executable and finite and then tested them on selected jit compiler or other java runtime environments.
freund and mitchell developed a type system specification for a subset of the bytecode language with type checking and prototype bytecode verifier implementation.
savary et al.
derived an abstract model from formal specifications to test the java byte code verifier.
calvagna and tramontana proposed an automated conformance testing approach to model jvm as a finite state machine and derive test suites to expose their unexpected behaviors.
more recently padhye et al.
automatically guided quickcheck like random input generators to semantically analyze test programs for generating test oriented java bytecode.
since the coverage data in java just in time compilers jits is deterministic wu et al.
proposed jitfuzz which leverages the power of coverage guidance and optimization activation mutators to test jvm jits.
on the other hand since the coverage is non deterministic in the whole jvm as mentioned sjfuzz adopts discrepancy and diversity to guide the fuzzing campaign for jvm.
gao et al.
incorporated code representation learning and clustering to improve the performance of program synthesis based jvm testing such as javatailor .
there are some work on compiler testing .
for example yang et al.
proposed a random mutation based compiler testing tool for open source c compilers which crashed every compiler they tested and found previously unknown bugs in three years.
more recently cummins et al.
developed deepsmith for accelerating compiler validation via deep learning to model the 1071sjfuzz seed and mutator scheduling for jvm fuzzing esec fse december san francisco ca usa real world code structures and generate vast realistic programs to expose compiler bugs.
similarly liu et al.
automatically generated well formed c programs to fuzz off the shelf c compilers based on generative models.
compared to the existing jvm and compiler testing approaches either performing worse or requiring extra knowledge in addition to a single seeding class file sjfuzz adopts seed and mutator schedulers based on easy to catch runtime discrepancy diversity information i.e.
acquiring no extra knowledge of bytecode constraints or jvm specifications.
seed scheduling in fuzzing.
many coverage guided fuzzers adopt seed scheduling mechanisms to enhance their effectiveness.
afl typically schedules seeds whenever executing them can increase code coverage.
bohme et al.
developed aflfast to construct a markov chain model by utilizing coverage feedback and then scheduled the seeds according to the probability generated from the model for further exploration.
they also proposed aflgo to reach a given program location by scheduling the most related seeds i.e.
the seeds closer to the target location for mutation.
she et al.
proposed k scheduler to schedule the seeds based on all reachable and feasible edges by using the graph analysis of control flow graph.
li et al.
proposed cerebro to schedule seeds based on the code complexity execution time and coverage information balanced by an online multi objective based algorithm.
chen et al.
leveraged the power of different fuzzers by merging seeds generated from them into one corpus and scheduling seeds among various fuzzers.
li et al.
proposed steelix which utilizes comparison progress information and coverage feedback for scheduling seeds to facilitate the fuzzing efficacy.
to bias input generation towards rare branches lemieux and sen proposed fairfuzz to schedule the seeds that hit rare branches for mutation.
to facilitate the hybrid fuzzing efficiency chen et al.
proposed meuzz to schedule the seeds between a coverage guided fuzzer and a concolic execution engine via machine learning.
chen et al.
proposed savior which schedules the seeds that can reach more sanitizer instrumentation i.e.
a potential buggy point to expose vulnerabilities of the target program.
zhao et al.
proposed digfuzz to schedule seeds based on the difficulty of their corresponding paths and prioritize them for concolic execution via a monte carlo based probabilistic path prioritization model.
zhang et al.
developed truzz which schedules the seeds based on the coverage feedback in a newly discovered execution path i.e.
a seed increasing more code coverage has a higher priority to be selected.
however such existing seed scheduling mechanisms can hardly be used for jvm fuzzing because they are widely guided by code coverage.
in this paper sjfuzz adopts diversity and discrepancy as alternative guidance to alleviate the impact of lacking code coverage information for seed scheduling.
mutator scheduling in fuzzing.
similar to the above mentioned seed scheduling mechanisms many mutator scheduling mechanisms tend to select mutators to increase code coverage during fuzzing.
stephens et al.
developed driller which selects the symbolic executor to mutate a seed if it fails to increase code coverage under a given time budget.
lyu et al.
proposed mopt which utilizes particle swarm optimization pso algorithm to find the optimal scheduling probabilitydistribution of mutators via historical code coverage for enhancing fuzzing effectiveness.
fioraldi et al.
proposed afl to facilitate fuzzing efficacy by scheduling different mutators from different fuzzers e.g.
mutators from afl and redqueen .
wu et al.
conducted a study on the havoc fuzzing strategy widely adopted by many coverage guided fuzzers and found that applying different mutators leads to different code coverage among various projects.
next they proposed an improved mutator scheduling mechanism based on a multi armed bandit algorithm according to the real time coverage feedback.
xie et al.
proposed deephunter by scheduling affine transformation mutator and pixel value transformation mutator to a given seed via their reference images.
although failing to exploit code coverage as the existing mutator schedulers sjfuzz still schedules mutators in a lightweight manner by diversifying class file generation via monte carlo method .
conclusion in this paper we proposed sjfuzz the first fuzzing framework using seed and mutator scheduling for automated jvm differential testing.
specifically sjfuzz employs a discrepancy guided seed scheduler which retains discrepancy inducing class files and class files that generate discrepancy inducing mutants.
it also employs a diversity guided seed scheduler which filters other class files via a coevolutionary mechanism to augment class file diversity for further mutations.
moreover sjfuzz applies a mutator scheduler based on the monte carlo method to diversify the class file generation.
to evaluate the efficacy of sjfuzz we performed an extensive study to compare sjfuzz with classming the state of the art mutationbased jvm fuzzer on various real world benchmarks.
the results show that overall sjfuzz significantly outperforms classming in terms of exposing inter jvm discrepancies for jvm differential testing e.g.
sjfuzz exposes .
unique discrepancies while classming only exposes .
unique discrepancies averagely on all the studied benchmarks.
we also compare sjfuzz with the generation based approach javatailor in terms of exposing jvm discrepancies.
the results also suggest sjfuzz outperforms javatailor e.g.
sjfuzz exposes .
more unique discrepancies than javatailor .
to date we have reported previously unknown potential issues discovered bysjfuzz to the jvm developers where were confirmed as bugs and were fixed.
data availability all the source code the evaluation details and the bug reports of this paper are available on our github page .
acknowlegement this work is partially supported by the guangdong provincial key laboratory grant no.
2020b121201001 and national natural science foundation of china grant nos.
.
this work is also partially supported by kuaishou.
1072esec fse december san francisco ca usa m. wu y. ouyang m. lu j. chen y. zhao h. cui g. yang and y. zhang.