retrieving data constraint implementations using fine grained code patterns juan manuel florez jonathan perry shiyi wei andrian marcus jflorez jperry swei amarcus utdallas.edu the university of texas at dallas richardson texas usa abstract business rules are an important part of the requirements of softwaresystemsthataremeanttosupportanorganization.theserules describetheoperations definitions andconstraintsthatapplyto the organization.
within the software system business rules are often translated into constraints on the values that are required or allowed for data called data constraints.
business rules are subject to frequent changes which in turn require changes to the corresponding data constraints in the software.
the ability to efficiently andpreciselyidentifywheredataconstraintsareimplementedin thesourcecodeisessentialforperformingsuchnecessarychanges.
in this paper we introduce lasso the first technique that automatically retrieves the method and line of code where a given dataconstraintisenforced.lassoisbasedontraceabilitylinkrecovery approaches and leverages results from recent research that identified line of code level implementation patterns for data constraints.
we implement three versions of lasso that can retrieve data constraint implementations when they are implemented with any one of frequently occurring patterns.
we evaluate the three versions on a set of data constraints from real world java systems and find that they improve method level link recovery by and in terms of true positives within the first results compared to their text retrieval based baseline.
more importantly the lasso variants correctly identify the line of code implementing the constraint inside the methods for of the constraints.
ccs concepts software and its engineering software evolution design patterns requirements analysis software maintenance tools.
keywords businessrule dataconstraint traceabilitylink recovery empirical study fine grained traceability code pattern permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
reference format juan manuel florez jonathan perry shiyi wei and andrian marcus.
.
retrieving data constraint implementations using fine grained code patterns.
in44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction business rules describe the operations definitions and constraints thatapplytoanorganization .whenasoftwaresystemisdeveloped to support such an organization these rules inform the creation of the software requirements.
however business rules are known to change unpredictably.
for example the reserve requirements for depository institutions .
d regulation d of thefederalreserve limitswithdrawalsoroutgoingtransfers from a savings or money market account to no more than six such transactionsperstatementperiod.thisrestrictionwastemporarily lifted in making the number of transfers no longer limited.
performing this change on a system subject to this regulation requiresknowingthesourcecodeelementsthatareresponsiblefor implementing this rule.
many business rules and other type of requirements are translatedwithinthesoftwaresysteminto dataconstraints .
data constraints specify what values are allowed or required for thegivendata.intheexampleabove therelevantdataarethenumber of monthly withdrawals and the number of monthly transfers from an account savings or money market .
the constraint states that the sum of the values of these two data elements should be less than or equal to six.
the two data elements are defined in the code we call these data definition statements and the constraint is checked in some other part of the code which we call constraint enforcing statement .
developers implementing the changes caused by the new rule will have to find the data constraint enforcing statements and they could benefit from tool support as is the case in any software change process .
recent research by yang et al.
explored the implementation of data constraints in database backed web applications.
they discovered that developers struggle with maintaining consistent data constraintsandwithcheckingthemacrossdifferentcomponents and versions of their web applications.
this observation underscores the need for tool support when it comes to maintaining the implementations of data constraints in particular.
inthispaper weproposeandevaluateanewapproach lasso locatingdataconstraintsin sourcecode thatcanautomatically ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa juan manuel florez jonathan perry shiyi wei and andrian marcus identifytheenforcingstatementsforagivendataconstraintina software.
lasso is designed as an extensible framework section .
theframeworkisbuiltontopofastandard traceabilitylinkrecovery tool i.e.
for a textual input it returns a list of relevant methods fromthecode whichisreplaceableandcustomizable.themain novelty is that lasso formalizes and uses structural information aboutdataconstraintimplementationsoriginatingfromprevious work on the subject section .
with this information lasso is able to improve the method level retrieval performance of the underlyingtraceabilitylinkrecoverytool.moreimportantly lasso is able to pinpoint the lines of code where a constraint is implemented.theabilitytotracedataconstraintstoline of codelevel implementations sets lasso apart among traceability link recovery approaches whichlargelyoperateatcoarsergranularitylevels i.e.
file class method .
florez et al .
conducted an empirical study and identified data constraint implementation patterns used by developers injavacode.theimplementationpatternsdescribethestructure of the implementations and are presented in a pattern catalog.
we convert the pattern descriptions into context free grammar production rules.
these productionsrules are then used by lasso to identify lines of code that exhibit the implementation patterns.
weinstantiatelassowithdetectorsfor13ofthemostcommonly occurringpatternsfromthepatterncatalog andrefertothisversionoflassoaslasso .withthesecomponents wecreatethree instances of lasso i.e.
lasso 13luc which uses a lucene based traceability tool bm25 lasso 13vsm which uses the vector space model and lasso 13lsi which uses an lsi based traceabilitytool .weevaluatethesethreeinstancesoflasso 13and compare the performance of each with their respective traceabilitytool as the baseline.
specifically we compare their performance on retrieving methods implementing constraints in real world javasystems.163oftheseconstraintsarefrompreviousresearch while are new to this paper.
we found that the lasso13luc lasso 13vsm and lasso 13lsi outperform their baselines by30 and163 intermsoftruepositivesretrievedinthe first10results respectively.inaddition weevaluatelasso sac curacy in pinpointing the lines of code enforcing the constraints withintherelevantmethods.wefoundthatlasso 13ranksthecorrect enforcing statements accurately for of the constraints at rank and at rank .
the main contributions of the paper are a novel approach and framework that for a given data constraint automatically finds the method and lines of code where it is implemented.
anewannotateddatasetof136dataconstraintsandtheir implementations from real world java systems which complements data from existing research.
theresultsoftheevaluationoftwolassoinstancesandtwo baseline approaches.
the data code and results are in our replication package .
background inthispaper weusethe constraintimplementationpattern cip catalog defined by florez et al.
.
to make the paper self contained we summarize here the most important information we use.table cip catalog excerpt.
cip name binary comparison.
description two values are compared using an operator such as equals does not equal greater than etc.
statement type expression.
parts variable1 op variable2 example instance if maxfreq wave.getnyquist parts maxfreq wave.getnyquist .
cip name if chain.
description a chain of ifs is used like a switch on a field checking against the possible values of the variable.
statement type if statement.
parts variable example instance if onset emergent ... elseif onset impulsive ... elseif... parts onset .
florezet al.studied the textual formulation and line of code implementation on a set of constraints from java systems.
the constraints were categorized into four types value comparison has 2operands.
the value of x variable is constrained by the value of y variable with an equality or relational operator.
example swarm will allow the maximum frequencytobesettoanypositivevaluegreaterthantheminimum frequency containstwoconstraints maxfrequency and maxfrequency minfrequency .
dual value comparison has 2operands.
x variable and y condition isoneofthe2mutually exclusivevaluesthatimpliesthe other e.g.
true false enabled disabled .
example if configuration file is not available or readable... contains two constraints file isavailable and fileisreadable .
categorical value has operands.
x variable is constrained to a finite set s options of two or more values.
example onmissingextensionpoint what to do if this target tries to extend a missingextension point.
fail warn ignore containsoneconstraint onmissingextensionpoint fail warn ignore .
concretevalue has2operands.theconstraintdirectlydeclares x variable tobec value .example thedefault dateis .
contains a constraint switchdate is1582 .
the implementation of a constraint consists of two parts an enforcingstatement anddatadefinitionstatements.eachenforcing statement was categorized according to the type of code construct whereitappears e.g.
expression ifstatement returnstatement etc.
and the number of operands it uses.
the result was the definition of cips i.e.
code patterns with line of code granularity.
in this paper we only utilize information about cips which were identified as the most commonly used boolean property binary comparison constantargument nullcheck assignconstant binary flag check if chain equals or chain switch len char self comparison returnconstant nullzerocheck and nullemptycheck.table1shows thedefinitionof2ofthe13patterns.thecompletecipcatalogcan be found in the original publication .
foreachcip weusethedescriptionandthenumberofrequired operands whichweconvertintoagrammar section3 .inaddition for each constraint type florez et al.identified which cips aremostcommonlyusedforimplementingconstraintsofthattype.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
retrieving data constraint implementations using fine grained code patternsicse may pittsburgh pa usa figure1 overviewoflasso.grayboxesarereplaceablecomponents.
there can be any number of cip detectors.
for example constraints of dual value comparison type are most frequentlyimplementedusingthe booleanproperty cip withthe next most common cip being null check.
lasso also leverages this information as part of its ranking model.
approach description ourapproach lasso locatingd ataconstraintsin sourcecode isdesignedasanextensibleframeworkthatautomaticallyidentifies implementationsofgivendataconstraintsinthesourcecode.an overview of the lasso framework is presented in figure .
the main novelty of lasso is its ability to identify constraint implementationsatline of codegranularity.thisisenabledbythe ast based cip matching component ast cip see section .
.
ast cip is composed of several cip detectors.
each one can detect instances of one cip in the source code bytraversingthe abstract syntax trees asts of the target system.
as shown in table flo rez et al .
defined each cip using natural language description and an example.
such definition is ambiguous and can not be used forspecifyingthepatternforeachdetector.basedontheirdefinitions wedefineasyntacticpatternofeachcip usingacontext free grammar cfg .
ast cip takes the source code as input and iscomposed of a number of detectors each capable of identifying instancesofonecip.theusercanmakeachoiceofhowmanycip detectorstoprovide.addingmorecanresultinmoreconstraints beingcorrectlytraced.ast cipproducesasetofsourcecodestatements i.e.
enforcingstatementcandidates escs thatmatchthe syntactic patterns of the cips used by the detectors section .
.
.
in addition lasso uses a traceability link recovery tool tlrt that accepts natural language i.e.
the description of a data constraint and source code as inputs.
the tlrt retrieves relevantsource code methods for the constraint.
lasso is agnostic to the internal retrieval model of the tlrt which means the framework can use any tlrt as long as it uses the appropriate input and producesoutputatmethod levelgranularity.weimplementedthree instancesoflasso usinglucene vsm andlsi basedtlrt section .
finally lasso s ranking component rank uses the escs identified by the ast cip component and the method level results returned by the tlrt to produce a list of methods ranked by their likelihoodthattheyimplementagivendataconstraint andalistwhile swarm will allow the maximum frequency to be set to any positive value greater than the minimum frequency this value will adjust automatically ifit is greater than the nyquist frequency of the wave being manipulated.
figure example of constraint input from the swarm sys tem.
the entire text is the context.
the constraint in bold and the operands are highlighted in gray.
figure3 theoperands body andblockelementsoftheescthat implements the constraint in figure .
of code statements inside each method ranked by their likelihood to enforce the constraint section .
.
.
lasso inputs for each target system lasso takes as input its source code which is used by the tlrt and the ast cip components.
theconstrainttypetocipmapping section2 containsinformation about the type of data constraints and frequency of existing cipsimplementingeachconstrainttype.thisinformationisemployedbytheusertodescribetheconstraintandalsobytherankingcomponenttoestimatethelikelihoodthatacertaincipimplements a given constraint type.
for each constraint three elements are specified by the user and used as queries by lasso.
.theconstraintcontext istheparagraphwheretheconstraint is described in the existing documentation e.g.
requirements use cases and manuals .
this is used by tlrt.
.theconstraint type is set according to the definitions in the constrainttypecatalog.thecipcatalogweusedefinesfourconstraint types value comparison dual value comparison categorical value and concrete value section .
this is used by rank.
.theconstraint operands are the noun phrases referring to the dataonwhichtheconstraintisdefined.thenumberofoperands varies foreach typeof constraint section two operandsfor valuecomparison twooperandsfor dualvaluecomparison three or more operands for categorical value and two operands forconcrete value.
this information is used by rank.
figure2showsanexampleoftheconstraintinputsthatlasso takes.
the constraint context is all the text in the figure.
the constrainttype derivedfromthetextdescribingtheconstraint is value comparison as it matches the definition a value is constrained by anothervalueusingarelationaloperator greaterthan inthiscase .
theoperands ofthisconstraintare maximumfrequency nyquist frequency of the wave .
note that reference resolution is not done automatically but left to the user who in this case should select the noun phrase maximum frequency instead of the pronoun it .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa juan manuel florez jonathan perry shiyi wei and andrian marcus .
ast cip component theast cipcomponentusesthesourcecodeandtheconstraint detectors to identify enforcing statement candidates escs .
.
.
esc definition.
each esc has the elements abody e.g.
theastelementthatmatchesthecip which can be a field definition a statement or an expression.
amethodwhere it appears.
a list ofoperands.
an optional blockof statements.
acip type corresponding to the cip that it matches.
thenumberof operands ofanescdependsonits ciptype as described in section .
figure shows the esc that implements theconstraintinfigure2.theesc s ciptypeisbinary comparison hence ithashastwo operands basedonthecipcatalogweuse .
lasso aggregates the terms of an operand by collecting both the identifierscontainedinsidetheesc body wave.getnyquist for operand in the example and the identifiers in the operand s definition double getnyquist for operand in the example .
thedefinitionsareobtainedbysymbolresolution andcanbedone with any analysis framework that provides the functionality.
theblockelement applies only to the escs whose bodyappears in the condition of a if while o rdo whilestatement.
the block correspondstoallthetextinthebodyof thestatement including boththenandelseblocks in the case of ifstatements.
the esc blockdoes not apply to escs whose body appears between the parentheses of a forstatement because these conditions are more complex than those of the previously mentioned statements.
notethatsomeescsmayappearoutsideofmethods e.g.
infield definitions.
in this case the corresponding definition is considered to be apseudo method.
.
.
cip matching.
as discussed the ambiguity in the cip definitions by florez et al.
makes it hard to specify which instances should be matched by each cip detector.
to address this challenge weexpressthecipsusingacontext freegrammar cfg shownin figure4.wedefinegarmmarsfor13mostcommoncips section2 .
the grammar of each cip covers all instances of the pattern in florez sdata.byconvention non terminalsareinuppercaseand terminals are in lowercase.
the non terminals in blue are the start symbolsformatchingthe13cips.inthisgrammar aterminalor non terminalmaybeassociatedwithan operandspecifier which is an annotation following a colon e.g.
op in bool val op on line .
operand specifiers are used to identify the symbols that areoperandsineachcip.thesameoperandspecifierdefinesthe samesymbolindifferentplacesinacip sgrammar.forexample var opon lines to requires the same variable to appear in these conditional expressions.
lasso can have any number of cip detectors.
to identify escs lasso first parses all files in the source code except for the test filestogenerateasts.testfilesareignoredbecausethesedonot contain the implementation of business rules in this case data constraints .
investigating the association between data constraint implementationsandtheirtestcodeissubjectoffuturework.lasso thenvisitseverynodeineachast.whenanastnodeisvisited ast cip attemptstomatch thegrammarofeach detectoronsaid node.anindividualcipdetectorwillreturnanesc ifandonlyifthe1boolean property bool val op 2bool val var bool method call bool field access bool 4binary comparison val op1cmp val op2 val op1relop val op2 6cmp 7relop !
8val var method call field access 10constant argument var .
m name op1 argsliteral op2args 11args exprargs 13null check nullrelop val op val oprelopnull 16assign constant var op1 literal op2 17var var field 19binary flag check int val op1bitop int val op2relop lit int op2 20int val var int method call int field access int 21bitop 23if chain if var op literal body elseif 24else if elseif var op literal body else 25else elseif var op literal body else 27equals or chain var op literal chain 28or chain var op literal chain 29chain var op literal chain 31switch len char switch val op.
length len case 32len case case literal int stmts len case 34self comparison var oprelopvar op 36return costant return literal op1 38null zero check null check and or var op.
length 39and or 41null empty check null check and or var op.
equals figure grammar for cips.
nodeisavalidproductionofthedetector scorrespondinggrammar.
if the node is not a valid production the detector returns nothing.
traversing all nodes in all asts results in the final list of escs.
to produce all elements of the esc as result each detector uses thematchingastnode esc body themethodwherethematching nodeappears esc method thespecificdetector esc ciptype and thelistofoperands esc operands .thenumberofoperandsdiffers by cip and is extracted by each detector based on the grammar.
inadditiontotheoperandidentifiersintheesc body lassoalso includesthetextfromtheirdefinitions seefigure3 .thedefinition ofeachoperandisresolvedusingsymbolresolution yieldingone of the possible definitions field definition method definition variable parameterdefinition.incasetheoperanddefinitionisamethod definition only the identifiers corresponding to the method name parameternames andparametertypesareaddedtotheoperand.
for parameters only the parameter name and type are added to theoperand.fortheremainingtypesofdefinitions allidentifiers in the defining statement are added to the operand.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
retrieving data constraint implementations using fine grained code patternsicse may pittsburgh pa usa considertheexampleinfigure3 whenthelassoreachesthe ast node corresponding to the ifstatement condition it attempts tomatchthegrammarofeachdetector.alldetectorsbuttheone forbinary comparison will return nothing as this node matches no other cips.
the given node matches the cip as it is a binary expression using a relational operator.
after finding that the node matchesthegrammar thedetector identifies theoperands.inthis case there are two operands as per the cip definition they are settings.spectrogrammaxfreq andwave.getnyquist .symbolresolution is applied as appropriate for each operand in the first case the field is resolved and in the second case the method is resolved.
the identifiers found in the definitions are then added to the terms of the corresponding operand.
.
ranking component rankusesfourtypesofinformationfromtheinputs i.e.
userinput and cip catalog and from the output of the other two components i.e.
tlrt and ast cip to rank all escs for a given constraint theconstraint context the constraint type and the list of constraint operands from the user input.
the esc cip type the esc method the list of esc operands andtheesc block fromtheast cipoutput foreachesc that matches any of the cips implemented in the detectors.
which cips are used most frequently to implement constraintsofthegiven constrainttype fromtheconstrainttype to cip mapping.
the ranked list of methods produced by the tlrt.
we introduce abbreviated notations for the various information used in the ranking.
for the constraint elements we use cc constraint context ct constraint type andco list of constraint operands .fortheescelementsweuse et escciptype em esc method eo list of esc operands andeb escblock .
lasso first applies standard text retrieval preprocessing techniques to all textual fields of both constraint inputs cc co and escs eo eb .specifically weapplyidentifiersplitting basedon camelcaseformat andunderscore format stemmingusingtheporter algorithm and stop word removal the list of stop words is available in our replication package .
lasso then uses ccor co as appropriate as input to tlrt and obtains a ranked list of methods which we denote as um.
giventhe inputconstraint foreach escidentified bythe astcip lasso uses four heuristics for computing a relevance score .the common terms between the constraint operands co and the escoperands eo .
the intuition is that if the operands from theconstraintdescriptionmatchtheescoperands thentheesc is likely to implement the input constraint e.g.
the term nyquist appears in one constraint operand and one esc operand in fig.
.
.the common terms between the constraint operands co and theescblock eb .insomecasestheesc bodyusestermsdifferent from those in the constraint e.g.
i j so the previous heuristic will not find common terms.
however op erations in the esc block may indeed use these terms if the logic is related to the constraint.
matching constraint operand terms with terms in the esc block increases the likelihood that the esc enforces the given constraint.
.thefrequencyoftheesc ciptypeet withrespecttotheconstrainttype ct extractedfromthecipcatalog.previousresearchbyflorezetal .
seesection2 identifiedwhichconstrainttypes are implemented by which cips.
for example they found that ofconstraintsofdualvaluecomparisontypeareimplementedusing the boolean property cip while are implemented with the null checkcip.hence iftheesc ciptypematchestheformer then it is more likely it implements the given constraint.
.thetlrtrankoftheesc method em.iftheesc methodis ranked high by the tlrt then it is likely that the esc implements the given constraint and less likely if the rank is low.
for these heuristics we define five measures two for the first one and one each for the others that take values between and .
.coe constraint esc operands .
lasso pairs each operand oi incoto the operand ojineowith which it has the largest number oftermsincommon.thepairingisstrictlyone to one.thenthe coemeasure is calculated according to equation .
coe summationtext.
i js oci oej co wheresreturns the percentage of terms in the constraint operand ocithat are also in the esc operand oej.
unpaired elements e.g.
if the constraint has more operands than the esc have a valueof zero for s. for the example in figure the second constraint operandoc2 nyquistfrequencyofthewave getspairedwiththe second esc operand oe2wave.getnyquist .
the first constraint operandoc1 max frequency gets paired with the remaining esc operandoe1 though they have no terms in common.
the value of the measure is then coe s oc1 oe1 s oc2 oe2 co .
.
.
the value ofs oc2 oe2 is .
because the second constraint operand hastwooutoffivetermsincommonwiththesecondescoperand nyquist and wave.
.eco esc constraintoperands performsthesamepairingas coe.
this time the ecomeasure captures the percentage of terms from each esc operand ojthat in common with the constraint operan eco s oe1 oc1 s oe2 oc2 eo .
.
.
the value of s oe2 oc2 is .
because oe2has four terms wave get nyquist double and two of them match theconstraint operand nyquist and wave.
the reason we performthe matching both ways coe andeco is that even though an esc may contain most or all terms in the constraint operands also including a lot of unrelated terms suggests that it might be dealing with different data.
.cob constraint operandblock isthepercentageoftermsinall elements of cothat appear in eb.
we do not perform the matching in the opposite direction analogous to coeandeco because the esc blocks can be long and hence contain a lot of different terms causing the values to be too small to make a difference in the score.
thisscoreisbasedontheintuitionthatifthenamesofoperands are used in the body of the conditional statement then the escis more likely to be relevant compared to the case in which the operands only appear in the condition.
.ecip expectedcip .basedontheinformationfromthecip catalog ecipis .0i fetis the most frequently used pattern implementingct .
if it is the second most frequent and .
otherwise.
specifically valuecomparison dualvaluecomparison concrete value constant argument assign constant categorical value .
notice that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa juan manuel florez jonathan perry shiyi wei and andrian marcus in the cases of value comparison andcategorical value there is only one most common cip .
in these cases we considered that the second most common cip did not appear in enough instances to makeitcommonenough soonlyonecipgetsthefullscore .
and all others get zero.
.cm contextmethod .cmis1 rwhereristherankofthe eminum or if tlrt did not return that method.
the final relevance score for an esc is computed according to equation .
namely the relevance score rs for an esc e is equal tothesumoftheweightedvaluesofthefivemeasuresforthatesc i.e.
coe eco cob ecip andcm .
rs e summationdisplay.
i 1mi e w mi whereeach mi e isthevalueofameasureandeach w mi is its corresponding weight.
theescsaresortedindescendingorderoftheirrelevancescore thosewithascoreofzeroareomittedfromtheresultlist.results that only have a non zero value for cmare also omitted as our tool prioritizes results found via cip matching.
at most one esc is returned for each line of code in each file with only the esc withthe highest score returned for each line.
the esc rankings are converted to method level by ranking each distinct em produced by the tlrt in the same order as they appearintherankedesclist withoutrepetition.forexample if escsinranks1 and100areinmethoda andescsinranks3 and4areinmethodb methodawillberankedfirst andmethodb will be ranked second.
the list of escs is preserved alongside each method and they appear in the same order as in the original list of escs.
continuing the above example method a will have an esc result list with escs and method b will have escs in its list.
lasso instantiation weimplemented13cipdetectors oneforeachofthefrequently occurring cips see section .
we used the javaparser library toimplementthesedetectors.forthis weemployedtheparsingca pabilitiesofthelibrarytoparsethesourcecodefiles andusedast visitors to implement each detector as specified by the correspondinggrammar.wealsoreliedonthelibrary ssymbolresolutionto resolve operand definitions.
we used these detectors to formulate three lasso instances lasso 13luc which uses as tlrt lucene .
.
with its default similaritymetric implementing the bm25 model .
lasso 13vsm whichusesastlrtlucene8.
.
withitsclassicsimilarity metric implementingthe vectorspacemodel vsm more specifically tf idf.
lasso 13lsi which uses as tlrt latent semantic indexing lsi .
thethreeinstancesalsodifferinwhattextisprovidedasinputto tlrt inthecaseoflasso 13lucandlasso 13vsm theconstraint contextis used while for lasso 13lsi it is the concatenated terms of all the constraint operands.
these inputs were selected because they achieved the highest performance for each tlrt according toapreliminarytest.theresultsofsuchtestcanbefoundinour replicationpackage .thethreetlrtcomponentsusethesametable software systems in the validation data set vds .
system domain kloc mtha mybatis .
.
persistence framework shardingsphere5.
.
rc1db sharding middleware skywalking .
.1app.
perf.
manager jabref .
citation manager jpos .
.
finance library log4j .
.
logging framework checkstyle .
source code style checker a number of methods text processing as described in section .
and return results at themethodlevel.forlsi weusedadimensionparameterof300.
thisparameteryieldedthebestperformanceonourdataaccording toourpreliminarytests resultsfoundinourreplicationpackage .thesetwotextretrieval basedtraceabilitylinkrecoverytechniqueshavebeencommonlyusedasbaselinesinpriorstudieson traceabilitylinkrecovery andbuglocalization .
the lasso instances and the two tlrt work on java code.
evaluation the goal of our evaluation is to assess how effective lasso is in locatingthedataconstraintimplementationsatbothmethodand line of code level as it works at both granularities.
our evaluation answers two research questions rq1 whatistheperformanceoflasso 13luc lasso 13lsi andlasso 13vsmonmethod leveldataconstrainttraceability link recovery?
rq2 howaccuratelycanlasso 13luc lasso 13lsi and lasso 13vsm retrieve the lines of code that implement a constraint?
.
experimental setup subjects of the study.
we perform an intrinsic evaluation by comparing lasso 13luc and lasso 13vsm with the lucene based tlrt they are built upon.
likewise we compare lasso 13lsi with the lsi based tlrt.
datasets.
weneedground truthdatasetswherethetracesfrom the data constraints to their implementations lines of code are known.
we use two datasets in the evaluation.
the first is the data published by florez et al .
which we refer to as the calibration data set cds since we use it for calibrating the weights of the five measures used by the lasso instances for ranking see sec tion .
.
we describe the calibration below.
cds consists of tracedconstraintsin8real worldjavasystems .thatstudyhad adatasetof187constraints.weselectedonlythe163constraints implemented with one of the cips detected by lasso .
we collected an additional dataset called validation data set vds consisting of136constraints from7new systemsdifferent fromtheonesincds .thetextualartifactsforallsystems authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
retrieving data constraint implementations using fine grained code patternsicse may pittsburgh pa usa aretheircorrespondingusermanuals.weusedthefollowingprotocoltoconstructvds whichissimilartotheoneusedbyflorez et al.
.
first one author examined the textual artifacts of the systems and extracted data constraints from each.
next we recruited four tracers to identify the implementations of these constraints.
all tracers are computer science graduate students each with at least years of programming experience in java.
the tracers were instructed to find a single implementation per constraint specifically the one described in the textual artifact where the constraint originated.
the reasons for this are aligned withthosearguedbyflorezetal .
.namely itisverydifficult todefineastoppingcriterionthatwouldconsistentlyresultinall implementations of a constraint being reliably found and term mismatchandimplementationcomplexitiesmakeitnecessaryto usetheconstraintcontexttohaveareasonablecertaintythatthe trace is correct which means only the instance of the constraint defined in the text can be reliably traced.
eachconstraintwasassignedtotwotracers.thetracersproduced identical traces for constraints of .
the disagreements were caused either from misunderstandings of the code semantics asthecodedoesnotalwaysusethesametermsastheconstraint s textualdescription or from tracersselectinga statementthat does not refer to the specific implementation of the assigned constraint but rather one in related functionality.
this relatively low agreementrateistobeexpectedduetothecomplexnatureofthetask whichrequiresthetracersbefamiliarwiththetargetsystem scode.
to ensure the quality of vds two authors determined the final trace through discussion based on the tracers answers.
finally to determine which constraints were suitable for our evaluation one author labeled each trace with the cip that corresponded to it.
only those constraints implemented with one of the cips for whichweimplementeddetectorswereaddedtothevdsdataset resulting in constraints in total.
metrics.
becausebothcdsandvdscontaintraceabilitylinksat line of codegranularity thelinesofcodeforeachtracecorrespond tothegroundtruth foreachconstraint.bothlassoinstancesand thebaselinesproducerankedlistsofmethodsastheiroutputs.
to measuretheireffectiveness ifamethodintheresultlistcontains thegroundtruthlines weconsidertheconstraintasretrievedat thatrank.wecallthisthe methodrank oftheconstraint.recallthat thelassoinstancesalsoproducearankedesclistforeachmethod.
wedefinethe escrank asthepositionoftheesccontainingthe ground truth lines in the esc corresponding ground truth method.
aswediscussedabove eachconstraintincdsandvdshasonly one ground truth.
this means that commonly used information retrievalmetricsarenotverymeaningfulhere.specifically map will always have the same value as mrr divided by method rank or0iftheconstraintwasnotretrieved .precisionwillalways be either if the ground truth was not retrieved or divided by the amount of results if it was.
recall will either be if the ground truth was retrieved and if not.
in light of this we report mrr average recall and the average method rank.
these metrics are provided for completeness as we focus our analysis on the hits n metrics defined as the percentage of constraintswitha methodrank between1andn i.e.
constraints wherethegroundtruthwasretrievedwithinthefirstnmethodsof the output ranked list.
this metric is easy to interpret as it meansthatapotentialuserhastoexaminenresults inthiscasemethods tofindtheconstraintimplementation.theimportanceofthismetric sometimes under different names has been argued in the fields of buglocalization queryreformulation and duplicate bug report detection .
inputgeneration.
asdiscussedinsection3.
lassorequires the type operands and context of each constraint as input.
to constructtheinput oneauthorextractedtherequiredinputfieldsfor each constraint.specifically the constraintcontext isa paragraph wheretheconstraintisfoundinthetextualartifacts.theconstraint type was assigned as one of the four constraint types in sec.
.
the operand list is composed of the noun phrases that describe each operand usingonlytermsfoundintheconstraintcontext exceptinthecaseofnumbers.ifnumberswerespelledout theywereturned into digits e.g.
one became .
additionally symbols werealso spelled out for example becomes infinity .
sec.
.
shows an example of specific input for a constraint.
the inputs for all constraints can be found in our replication package .
baselinecalibration.
to find the optimal input i.e.
constraint context or constraint operands for the tlrt of each lasso instanceandthebestparametersforlsi weevaluatedthebaselines on the combined cds and vds data sets using each input with eachtechnique.thebestperformingcombinationsareexplained in section and the full results are in our replication package .
calibration of lasso ranking weights.
we empirically calibratedtheweightsforthefiverankingmeasures sec.
.
using cds.wedesignedanalgorithmtofindthecombinationofweights that result in the best results for lasso 13luc in cds.
we used lasso 13luc for calibrations as opposed to lasso 13lsi or lasso13vsm becauselucenewithitsdefaultsimilarityperformedbetter than the other two approaches.
that is we optimized the weights based on the strongest baseline.
the calibration algorithm runs rounds of testing one for each weight .
each metric begins as a free metric and at the end of eachround onemetricwillbecomefixedwithaweight.oneach round for each free metric the algorithm generates scenarios corresponding to all combinations of weights for all free metrics one of .
.
.
... .
.
and the fixed weights.
the value of the free weight that leads to the highest value of hits becomes fixed.
the optimal configuration for lasso 13luc for cds iscoe .
eco .
ecip .
cob .
cm .
.asmentionedabove weusethesameconfigurationfor lasso 13lsiand lasso 13vsm as we want to assess how robust these weights are to changes in the data sets and tlrt.
.
rq1 results table 3a shows the results obtained by lasso 13luc lasso 13lsi lasso 13vsm the lucene based tlrt the vsm based tlrt and thelsi basedtlrt onthecalibrationdataset cds with163constraints.
table 3b shows the results obtained by the six approaches onthevalidationdataset vds with136constraints whiletable3c shows the results on the combined data sets with constraints.
.
.
weightcalibrationvalidation.
toensurethattheconfiguration was not overfitted to the test data we evaluated the lasso instancesonthevalidationdatasetwiththeconfigurationobtainedfromthealgorithminsec.
.
.comparingtheresultsfromtable3a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa juan manuel florez jonathan perry shiyi wei and andrian marcus and table 3b we observe that all three lasso instances achieve improvementsonbothdatasets.lasso 13lucimproves hits from .
to .
over the lucene baseline on cds and from .
to .
on vds.
similarly lasso 13vsm improves hits 10from22.
to49.
overthevsmbaselineon cds and from .
to .
on vds.
finally lasso 13lsi improves hits 10overthelsibaselinefrom12.
to39.
oncds andfrom27.
to66.
onvds.thisindicatesthat the weight calibration is robust and transfers to other data sets.
from here on we perform all analyses on the results on the combined data set i.e.
cds vds .
.
.
lasso 13luc vs. lucene based tlrt.
table 3c shows the resultsobtainedbylasso 13lucandthelucene basedbaselineon the combined data sets.
as discussed before hits n indicates the percentage of constraints for which the relevant method is retrieved in top n in theory insuchcases theusersneedtocheckatmostnmethods tofindtherelevantone.priorresearchontraceabilitylinkrecoveryarguedthatretrievingthegroundtruthonthetoppositionis perfect performance returning it in the top is excellent and in top very good .
note that the number of methods in the targetsystemsis9.6konaverage .wefocustheanalysisof the results on hits i.e.
indicating very good performance .
weobservethatlasso 13lucobtains25.
hits which meansthatforoneinfourconstraints lasso 13lucretrievesthe relevant method in the first place.
at hits lasso 13luc improvesthebaselineapproachby30 .
vs51.
.inother words fortwothirdoftheconstraintslasso 13lucretrievesthe relevant method in top compared to half the constraints for the baseline.
lasso 13luc also improves the hits and hits results over the baseline by and respectively.
notehowlasso 13lucimprovestheaveragemethodrankfrom .
to .
a reduction of one order of magnitude.
thelowerrecallforbothlasso 13instancesvs.theirbaselinesis tobeexpected andalsobothreturnthesameresultsdespitehaving differenttlrt i.e.
avg.recall columnintable3isthesamefor bothapproaches .thisisbecause asexplainedinsec.
.
onlytheescsthathaveavalueforthefirst4metricsareretrieved meaning that which escs are returned does not depend on the results of tlrt.
instead the tlrt resultsare used as partof the rankingof these escs and as such both lasso instances achieve different values of hits n average method rank and mrr as expected.
.
.
lasso 13lsi and lasso 13vsm vs. baseline tlrt.
table 3c shows the results obtained by lasso 13lsi the lsi based baseline lasso 13vsm and the vsm baseline on the combined data sets.
we observe that lasso 13vsm improves the hits results of the vsm baseline by .
vs. .
while lasso 13lsihas an improvement of .
vs. .
over its baseline.
we note that the vsm baseline performs worse than the lucenebased one by in terms of hits while the lsi baselineperforms worse.
the improvement in terms of average rankfor lasso 13vsm over its baseline is similar to that achieved bylasso 13luc over its baseline namely one order of magnitude.
with that in mind the size of the improvement obtained by lasso13lsi compared to lasso 13luc or lasso 13vsm indicates that lasso is especially well suited to improve a poorly performingbaselinetlrt.notably thereductioninaveragerankisevenmoredramatic for lasso 13lsi going from .
to .
or two orders of magnitude.
.
.
analysis of the results.
we perform a deeper analysis of the lasso 13lucresults givenitperformsbetterthantheothertwo lasso variations.
we examined a random sample of constraints where the ground truth was not retrieved where it was retrievedwithmethodrank11 and10wherethemethodrank was .
themostcommonreasonfornotretrievingorlow rankingof the ground truth was a term mismatch between the operands in the constraint text and the operands of the esc which is a known problem in traceability link recovery.
specifically we identified the following causes of term mismatches usesofabbreviations argoumlconstraint minimiseclass iconsindiagrams isenabledbydefault whichappearsin the source code as mini compoundidentifiers antconstraint ifthevalueof is true clonevm vs. isclonevm and misspellings argoumlconstraint useguillemots for stereotypes clearbydefault guillemots inthetextvsthe correctguillemets in the code .
thestandardtextretrievaltechniquesthatlasso 13usestoprocessthetextinoperandscannotsuccessfullyovercomethesemismatches.thereare however techniquesthathavebeenspecifically designed to tackle these situations e.g.
abbreviation expansion identifiersplitting spellcheckers which could be easily integrated into our approach.
thenextmostcommoncauseforlowrankingsisthetlrthigh scoresforunrelatedmethods.thishappensmostlybecauseofterms intheconstraintcontextthatareverycommononthesystemor thathappenincombinationsthatthebm25scoringconsiderstobe veryrelevant.forexample fortheantconstraint defaultforcache stillisfalse thegroundtrutheschasmaximumvaluefor coeand eco butavalueofonly0 .03forcm.thishappensfortworeasons thegroundtruthescisinafielddefinition whichonlyhastwo matching terms with the constraint context cache and false bm25 ranks longer methods with the word combination resource collection from the context near the top of its list.
implementation decisions can also cause this problem for the log4jconstraint if true thereare6classesinthe system with locationinfo properties plus a class actually named locationinfo .theusagesofanyofthesesymbolsarerankedhighly not only by the tlrt but also by lasso specific scoring since theyalsohaveoperandtermsincommon.foramybatisconstraint the first ranked methods contain the same error message error cannotrollback.nomanagedsessionisstarted.
whichmatches terms form the context and causes them to be ranked highly.
this appears to be a commonly used pattern in this system that hinders our approach but can be addressed by removing error messages fromtheescblock.onewaytoaddressthesesituationsistouse thecodearoundtheesctobetterunderstandofthesemanticsof the esc.
such exploration is subject of future work.
finally anexpectedtypeofconstraintimplementationthatisdifficult for lasso to retrieve is the case where the enforcing state mentisusedtocheckmultipleconstraints.theseweredescribedby authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
retrieving data constraint implementations using fine grained code patternsicse may pittsburgh pa usa table retrieval performance of lasso variations and their corresponding baselines.
data set technique h h h 10avg.
method rankavg.
recall mrr cdslasso 13luc .
.
.
.
.
.
lucene .
.
.
.
.
.
lasso 13vsm .
.
.
.
.
.
vsm .
.
.
.
.
.
lasso 13lsi .
.
.
.
.
.
lsi .
.
.
.
.
.
a results on cds constraints vdslasso 13luc .
.
.
.
.
.
lucene .
.
.
.
.
.
lasso 13vsm .
.
.
.
.
.
vsm .
.
.
.
.
.
lasso 13lsi .
.
.
.
.
.
lsi .
.
.
.
.
.
b results on vds constraints cds vdslasso 13luc .
.
.
.
.
.
lucene .
.
.
.
.
.
lasso 13vsm .
.
.
.
.
.
vsm .
.
.
.
.
.
lasso 13lsi .
.
.
.
.
.
lsi .
.
.
.
.
.
c results on cds vds constraints florezetal .
andserveasjustificationfortheinclusionof data definition statements in the definition of the cips.
for example for the skywalking constraint ax length is itscorrespondingenforcingstatementis if value!
null value.length lengthdefine.value .
this statement is used to check many properties in the system namely those that use the length annotation lengthdefineisoftype length definedinthe code of the system.
locating this enforcing statement would requireidentifyingusagesofthe length annotation relevantinthis case length publicvolatile staticstringinstance name andaddtheconcretevalueoftheannotationtothecorresponding operand in this case lengthdefine.value .
while this processwouldmostlikelyimprovetheperformanceoflasso it is outside of the scope of this paper.
in of the analyzed constraints a true positive different from the ground truth was retrieved within the first results.
this wasexpected asflorezetal .
documentedthatinsomecases one constraint isenforced in several places inthe code e.g.
when it is involved in multiple features .
since the ground truth dataonlyannotatesasingleenforcingstatementperconstraint even if there are more we do not count the extra enforcing statements as true positives.
expanding the data sets to annotate all enforcing statements for each constraints is subject of future work.lasso 13luc outperforms the lucene based baseline by .
vs .
lasso 13vsm outperforms the vsmbasedbaselineby70 .
vs. .
lasso 13lsioutperforms the lsi based baseline by .
vs. .
all in terms of hits .
.
rq2 results toevaluatehowaccuratelylasso 13canpointtothecorrectenforcing statement we further examine the esc lists for the evaluation results.
we perform all analyses on the combined cds vds data.
the esc ranks for the three lasso variations are the same as the tlrt does not change which escs the ast cip componentmatches only the method ranking this is why we get the same recall for all variations .
table shows the distribution of the esc ranks for all constraints.
lasso places the correct enforcing statement in escrank for of constraints of cases and in for .
lasso does not return the correct enforcing statement for constraints none in table and does not return the ground truth method for n a in table .
we focus on the subset of constraints for which the lasso instances return method level results in top i.e.
constraints for lasso 13luc for lasso 13vsm and for lasso 13lsi shown in table .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa juan manuel florez jonathan perry shiyi wei and andrian marcus table distribution of the esc ranks for constraints with methodsretrievedintop10byeachbaselineandalsoforall constraints.
esc ranktop lsi top vsm top luc.
all .
.
.
.
.
.
.
.
.
.
.
.
none .
.
.
.
n a .
total for the constraints lasso 13luc ranks the ground truth enforcingstatementas1in162cases as2 3in28 as in .
and it does not point to the ground truth in .
.
for constraints lasso 13lsi ranks the ground truth first in cases of in in and does not point to it in .
in other words for the methods returned bylasso 13luc in top the approach pinpoints precisely of theescwithinthereturnedmethod inthetoppositionand on position or .
for lasso 13lsi this figure is in and in .
wemanuallyexaminedtheescresultsforthegroundtruthof constraints where the ground truth esc had a rank of wheretheescrankwas4 allsuchcases and10wherelasso did not return the ground truth esc.
inconsistentidentifiernaminginthesourcecodewasthelargest cause of low rankedor missed escs.
for example thejabref constraint if a file is imported has the terms file and imported aspartofitsoperands however its enforcingstatementusesthe term loaded instead and file appears inside this esc s block giving it a score of for coe though it achieves a maximum score forcob.however otherescsinthemethodcontaintheseterms because they are related in functionality but do not enforce thesame constraint for example an esc containing the identifier is fileexportachieves a higher coescore and is thus ranked higher.
similarly the enforcing statement of the jabref constraint if thereare problems usestheterm warning whichcausesittonot be retrieved while the string passed to the exception reporting the problem does contain the term which is returned as an esc.
inthreecases thegroundtruthenforcingstatementcouldnotbe found because it checks the opposite condition to the one specifiedintheconstraint e.g.
thejabrefconstraint therearemorethantwo personsintheauthorlist isimplementedas if authors.length .
one way to address these cases is to look for the negation of the constraints as well but that is subject of future work.
inthreecases thegroundtruthenforcingstatementwasreturned in position and the esc ranked first has the same score as the ground truth esc.
this happens because both escs have the same numberof termsintheir bodyandthesame matchingtermswith the constraint operands.
for example in the jabref constraint an export option is also specified the two escs are f cli.isfile export and the ground truth is if cli.isexportmatches .
both have the same number of terms and match only export .for three constraints different from those mentioned in the previoussection wefoundthetoprankedesctobeatruepositive.
theantconstraint ifthemanifestisomitted ischeckedintwo places in the ground truth method.
this is because the manifestis loaded on demand and so the object can be in a state wherethe manifest was provided by the user but has not been loaded.
the method checks once to see if the manifest has been loaded and attempts to load it if not and then again to confirm that the loadingreturnedanything becauseitcanreturnnullifthemanifest was omitted .
since our ground truth data only has annotated one enforcing statement per constraint lasso finds additional true positives fortheconstraintsthatareenforcedinmultipleplacesin the code.
florez et al .
found that of the constraints in the cds are enforced in multiple places.
creating a data set where all enforcing statements are annotated is subject of future work.
lasso 13ranksthecorrectenforcingstatementaccurately for of the constraints at rank and atrank .
for the methods returned by lasso 13luc in top itaccuratelypinpoints95 oftheescwithinthe returned method in at rank and at rank .
threats to validity our evaluation is implicit and relies on data sets from previous research and new data we produced for this paper.
these data sets are built following the same protocol and only contain a single ground truth enforcing statement per constraint even if there may bemoreinsomecases.theresultsmaybedifferentondatawith more complete ground truth annotations.
ourevaluationassumesa perfect user aslasso 13isgiventhe correct inputs for each constraint specifically the operand list and theconstrainttype whichwerederivedfromeachconstraintbyanauthor whoisfamiliarwithboththecatalogofdataconstrainttypes anddataconstraints ingeneral.inareal world situationtheuser maynotbeabletoprovidethecorrectinputineachcase.evaluating how robust lasso is with respect to incomplete or incorrect input issubjecttofuturework.tomitigatethisissue theinputforthe lasso instances and the baselines are the same.
our evaluation is performed only on constraints that are implemented with the cips that lasso has detectors for.
this is by design as our goal was to evaluate the performance in detecting known patterns i.e.
corresponding to the detectors .
tackling the presence of unknown patterns is part of our future work.
the correctness of the traces in our data sets is also a threat.
even though the level of agreement between tracers is arguably low wearguethisisactuallyhigh duetotheveryunlikely natureoftwotracersagreeingonaline of codetracebychance asouragreementcriterionwasstrict i.e.
thetracershadtoreportthe exactsamelines .tomitigatethisthreat eachtracewassetonly after a discussion between two authors.
the weight calibration algorithm we used to set the parameters for lasso might not have generated the optimal combination of weights.
ho wever we show that a relatively simple process with a small data set provides values that are robust against overfitting hence we believe they will translate to other data sets.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
retrieving data constraint implementations using fine grained code patternsicse may pittsburgh pa usa asweanysuchempiricalstudy externalvaliditydependsonthe sizeofourdata.giventhenoveltyofthiswork onlytwoannotated data sets exists for supporting this work i.e.
the one from and the one we created .
to mitigate this threat we annotated data from systems not used in the previous study.
related work lasso is related to automated requirements to code traceability link recovery techniques albeit it focuses on a specific subset of therequirements i.e.
dataconstraints .researchinthisfieldspans decades and has produced a multitude of techniques that can trace naturallanguageartifactstosourcecodeartifacts.ourworkdiffers from the existing approaches in two main ways the natural language artifacts are data constraints a source of information not yetleveragedbyanyotherapproaches and lassoretrievesboth method levelandline of code levelcodeartifact whichhasonly been achieved with limited success in previous studies.
improvements in the performance of these techniques have originated from both the use of different retrieval models vsm probabilistic topicmodels machine deep learning ai techniques and the use of alternate sources of information code authorship nonfunctionalkeywords dynamic analysis .more related to the present work code structure has been exploited but only in the form of method class relationships unlike the line of code patterns that enable our approach.
the fine grained code patterns represent an additional source of information that is orthogonal to those previously studied presented above and similar performance improvements as the onesreported here could be expected to be achieved by integrating any of these approaches with lasso as the tlrt component.
thesemanticgreptool canbeusedtodefineandretrieve patternslikethecipsthatenablelasso.whilewechosetousea parsingandanalysislibraryforjava javaparser toimplement the detectors for the ast cip component of lasso any tool that can return a list of escs could be used instead.
the work by blasco et al .
uses lsi and genetic algorithms toretrievetracesatlowergranularitythanmethodsforanatural languagerequirement inaspecificcommercialvideogame.this approachisfundamentallydifferentfromlasso asitismeant totracerequirementsthatarelargerthandataconstraints andthatare assumed to be implemented in multiple code locations each.
in contrastour techniqueassumes thateach dataconstraint will be implemented in a discrete location inside a method as observed by previous work .
additionally their technique randomly selects seed lines for the genetic algorithm based and the results are nondeterministic.ourapproachbothusesspecificline of codepatterns to build the escs and is deterministic.
arelatedlineofresearchusesstaticanalysistoreverseengineer business rules usually from a legacy system where only the binarycodeisavailable .theseapproachesdifferfromlassointhattheydonotusethetextofthebusinessruleasinput insteadrelyonthedeveloperselectingrelevantinput output variables.
from this setof variables they perform forwards or backwardslicing andfindthebranchesintheslice sinceconditional branches are the locations where business rules are checked.finally recent research by yang et al.
explored the implementation of data constraints in database backed web applications.
they discovered that developers struggle with maintaining consistent data constraints and with checking them across different componentsandversionsoftheirwebapplications.thisworkis one of the main motivation behind our research.
conclusions lassoisanoveltraceabilitylinkrecoverytechnique designedas framework which uses fine grained code patterns to enable the retrieval of links with line of code granularity.
three concrete versionsofthisframework lasso 13luc lasso 13vsm andlasso13lsi were shown to achieve a hits of .
.
and .
respectively while outperforming their corresponding baselines by and respectively.
additionally all three lasso 13variationscanreturn thecorrectlineofcodeimplementationwithinthefirst3ranksinthecorrespondingmethodfor79 of constraints.
thesefindingsshowthatempiricalknowledgeofthespaceof constraint implementations and common sense heuristics can enable effective retrieval at line of code granularity while improving the performance of method level approaches.
lassoisextensiblewithnewtypesofconstraintimplementation patternmatchersand withenoughsuchextensions lassocould beusedtotraceanytypeofdataconstraintsimplementedwithanycurrent or future implementation patterns.
since lasso operates atline of codelevel weenvisiontoolsthatwillautomaticallyidentify and change the enforcing statement when the underlying rules change.
researchers identified trace accuracy and trace granularity as tworemaininggrandchallengesintraceability .future requirements to code traceability link recovery approaches can bootstraponlasso whichwillfindthelinesofcodeimplementingtheconstraintsembeddedintherequirements andusethese seeds to improve the accuracy of tracing the larger requirements.
this willnotonlyimprovetheaccuracyofcoarse grainedtraceability but will also provide fine grained links that can be directly used when they are needed.