making python code idiomatic by automatic refactoring non idiomatic python code with pythonic idioms zejun zhang australian national university australia zejun.zhang anu.edu.auzhenchang xing data61 csiro australian national university australia zhenchang.xing anu.edu.auxin xia software engineering application technology lab huawei china xin.xia acm.org xiwei xu data61 csiro australia xiwei.xu data61.csiro.auliming zhu data61 csiro australia liming.zhu data61.csiro.au abstract compared to other programming languages e.g.
java python has more idioms to make python code concise and efficient.
although pythonic idioms are well accepted in the python community python programmers are often faced with many challenges in using them for example being unaware of certain pythonic idioms or do not know how to use them properly.
based on an analysis of python repositories on github we find that non idiomatic python code that can be implemented with pythonic idioms occurs frequently and widely.
unfortunately there is no tool for automatically refactoring such non idiomatic code into idiomatic code.
in this paper we design and implement an automatic refactoring tool to make python code idiomatic.
we identify nine pythonic idioms by systematically contrasting the abstract syntax grammar of python and java.
then we define the syntactic patterns for detecting nonidiomatic code for each pythonic idiom.
finally we devise atomic ast rewriting operations and refactoring steps to refactor nonidiomatic code into idiomatic code.
we test and review over refactorings applied to python projects from github and submit pull requests for the randomly sampled refactorings to projects.
these evaluations confirm the high accuracy practicality and usefulness of our refactoring tool on real world python code.
our refactoring tool can be accessed at .
.
.
.
keywords pythonic idioms abstract syntax grammar code refactoring introduction programming or code idioms are widely present in programming languages .
they represent notable programming styles and features of a programming language.
python is well known for its pythonic idioms .
many books and online materials promote the use of pythonic idioms for not only concise coding styles but also improved performance see table for examples .
in spite of the benefits of pythonic idioms and the availability of many online materials our investigation of some highly viewed python questions on stack overflow suggests that developers are often unaware of pythonic idioms or do not know corresponding author.when and how to use pythonic idioms properly see the examples in table and the analysis in section .
.
due to these challenges in using pythonic idioms developers may implement a functionality in a non idiomatic way without using pythonic idioms.
table shows some examples.
we study python projects on github see section .
and find that non idiomatic code that can be implemented with pythonic idioms is widely present at the repository file method and statement level see table .
non idiomatic code and idiomatic code co exist in many repositories files or even methods.
as seen in table non idiomatic code syntax is similar to those of other mainstream programming languages e.g.
java .
in contrast pythonic idioms have uncommon syntax.
developers even those with little python programming experience can still write non idiomatic code.
however to use pythonic idioms they would need to learn new syntax or need some tool supports.
although online documentation of pythonic idioms provide rich learning materials they cannot directly support programming with pythonic idioms.
to the best of our knowledge only two tools provide limited support for using pythonic idioms.
among the nine pythonic idioms in table pylint can detect two types of non idiomatic code which can be refactored into chain comparison and truth value test respectively.
however it offers only a simple refactoring suggestion which may not be intuitive to developers.
for example for the code a and b and c and d pylint suggests simplify chained comparison between the operands .
unfortunately the developer did not understand this suggestion initially.
when pylint developer further explained that the code can be refactored into a and b c and d the developer understood what to do and left a comment would it be an idea for pylint to output the suggested refactor to the user?
which received thumbs up by other developers.
teddy collects non idiomatic code fragments and corresponding idiomatic code three pythonic idioms list comprehension set comprehension and truth value test overlap with idioms in table .
it detects nonidiomatic code similar to the collected examples and recommends corresponding idiomatic code examples.
developers still have to manually refactor the non idiomatic code.
1arxiv .05613v1 jul 2022esec fse november singapore zejun zhang zhenchang xing xin xia xiwei xu and liming zhu in this paper we develop the first automatic refactoring tool that detects types of non idiomatic code referred to as antiidiom code smells and refactors these anti idiom code smells into idiomatic code implementing the same functionalities.
existing work mines recurring code idioms from source code or relies on books that include many idioms that are not unique to python.
to identify unique pythonic idioms we contrast the language syntax of python and the other mainstream programming language java in this work .
this is inspired by the observation that non idiomatic code syntax is similar to those of other languages but idiomatic code has unique syntax.
our analysis identifies types of pythonic idioms see table .
we confirm the validity of these pythonic idioms through the python language specification and online materials .
for each pythonic idiom we define syntactic patterns for detecting non idiomatic code fragments that implement the same functionality as the pythonic idiom.
following the refactoring principle one small step at a time we formulate four atomic ast rewriting operations and compose these atomic operations for each pythonic idiom for refactoring anti idiom code with the corresponding pythonic idiom.
to evaluate the code smell detection and refactoring accuracy of our approach we apply our tool to python projects which detects and refactors over anti idiom code smells.
we verify the refactoring results by both testing and code review.
our approach achieves smell detection accuracy for six idioms and refactoring accuracy for eight idioms.
it makes only a few rare detection errors and only one refactoring error due to the limitation of python static analysis and the complex program logic.
to explore the usefulness of our code refactoring tool in practice we randomly sample refactorings respectively for each pythonic idiom and submit in total pull requests to projects to make the project members review our refactorings.
as a result we receive replies from projects of which accept our pull request with praise of our refactorings and replies merge the pull requests into their repositories.
our results show developers care about pythonic idiom refactorings and our refactorings have been well received in practice.
the developers feedback on the rejected pull requests reveal some interesting concerns about the readability and performance of pythonic idioms which deserve further study.
the dataset of anti idiom code and corresponding idiomatic code produced in this work provides the first large scale test bed to systematically investigate such concerns.
in summary this paper makes the following contributions to the best of our knowledge we are the first to automatically detect non idiomatic code and refactor it into idiomatic code for widely used pythonic idioms.
through the evaluation on a large number of real world python projects we confirm the high accuracy practicality and usefulness of our refactoring tool.
our work creates the first large scale dataset of anti idiom code smells and corresponding idiomatic code for studying and validating the claims and concerns about pythonic idioms.
formative study and motivation we conduct an empirical study of pythonic coding practices to answer the following three research questions table pythonic idioms conciseness and performance idiom resource anti idiom code smell idiomatic code x list comprehensionperformance benefits to using a list comprehension t for i in range t.append i t i for i in range .
set comprehensionset comprehension is a more compact and faster way to create sets simpsons set set for word in chars simpsons set.add word simpsons set word for word in chars .
dict comprehensionuse a dict comprehension to build a dict clearly and efficiently b for k v in a.items b kb v k for k v in a.items .
chain comparison...can have a positive effect on performance a b and b c and c d and d e and e fa b c d e f1.
truth value test...can make your code more efficient... if a passif not a pass1.
loop elsean efficient for loop implementation finishedforloop true for x in range n if n x finishedforloop false break if finishedforloop passfor x in range n if n x break else pass1.
assign multiple targetsspeed up and shorten your code is to assign the variables in your program at the same time a b c d 7a b c d .
star in func callunpacking is faster than accessing by index s sum values values s sum values .
for multiple targetsaccessing by index slow things down compared to for loop item unpacking for item in sales a item item item for product price sold units in sales a product price sold units1.
rq1 what are the benefits of pythonic idioms?
rq2 what are the coding practices concerning pythonic idioms and anti idiom code smells?
rq3 what are the challenges for writing idiomatic code?
.
rq1 the benefits of pythonic idioms compared with other mainstream programming languages python supports more idioms which are highly valued by python developers .
by referring to several resources i.e.
books presentations and websites about pythonic idioms we summarize the key benefits of pythonic idioms conciseness i.e.
fewer lines or fewer tokens and performance.
to help readers understand these two benefits we summarize in table the code examples of idiomatic code and the corresponding non idiomatic code i.e.
anti idiom code smell for each pythonic idiom excerpted from the reference resources.
we also excerpt relevant performance descriptions.
we omit conciseness related descriptions as code conciseness can be observed intuitively from code examples.
to confirm the performance benefit we use the timeit package to record the execution time of idiomatic and non idiomatic code snippets shown in table .
we execute each code snippet three times repeatedly and take the average execution time.
we divide the execution time of non idiomatic code by that of corresponding idiomatic code which indicates how much speedup idiomatic code has compared with non idiomatic code.
as shown in the fifth column of table idiomatic code has about .
.07x speedup.
we acknowledge this is only an anecdotal experiment.
many online resources argue pythonic idioms e.g.
list comprehension may achieve significant performance advantages over non idiomatic code but they generally do not provide specific empirical evidences.
this calls for more systematic investigation of such performance claims which is beyond the scope of this work.
2making python code idiomatic by automatic refactoring non idiomatic python code with pythonic idioms esec fse november singapore figure the usage of pythonic idioms and anti idiom code smells in repositories files and methods table python coding practices with respect to pythonic idioms and anti idiom code smells idiomrepository file method npy pyid npy pyid npy pyid list compre set compre dict compre chain compare truth val test loop else assign multi star in func call for multi .
rq2 python coding practices .
.
data preparation.
to understand the coding practices with respect to pythonic idioms and anti idiom code smells we crawl the top repositories using python by the number of stars from github.
repositories can be successfully parsed using python .
we collect python source files from these repositories.
we then detect the occurrence of idiomatic code and the anti idiom code that can be refactored with pythonic idioms in these python source files.
all nine pythonic idioms can be detected by analyzing abstract syntax trees asts .
list set dict comprehension and loop else idioms directly correspond to ast nodes we can directly detect such idiomatic code instances.
for star in function call we extract starred node in function call node.
for truth value test we extract the test node corresponding to an object.
for chaincomparison assign multiple targets and for multiple targets we extract operators of the compare node the value and targets of the assign node and the target of for node with elements greater than respectively.
for non idiomatic code we use our detection rules see section .
to detect non idiomatic code instances.
we count the number of repositories files methods and statements that contain the instances of idiomatic code and non idiomatic code.
note that a repository file or method may contain both pythonic idioms and refactorable non idiomatic code.
.
.
result.
figure shows the numbers of repositories files and methods using different types of pythonic idioms and antiidiom code smells.
we see that although pythonic idioms are well adopted in the python projects there are still non trivial usage of non idiomatic code that can be refactored with pythonic idioms.
furthermore a repository file or method generally uses multiple types of idiomatic and non idiomatic code.
there are non trivial numbers of repositories and files that use or more types of pythonictable statistics of pythonic idioms and anti idiom code smells at the statement level idiom non idiomatic idiomatic sum list compre .
set compre .
dict compre .
chain comparison .
truth value test .
loop else .
assign multi targets .
star in func call .
for multi targets .
idioms or contain or more types of non idiomatic code that can be refactored with pythonic idioms.
table summarizes the number of repositories files and methods containing non idiomatic code smells the npy column pythonic idiom pyid and both non idiomatic and idiomatic code for each pythonic idiom.
we see that many repositories files or even methods often have a mix of idiomatic and non idiomatic code to achieve the same functionality.
for example a large number of repositories and files mix the use of the list comprehension idiom and non idiomatic list operation and methods contain both idiomatic list comprehension and non idiomatic list operation that can be refactored into idiomatic list comprehension.
among the nine pythonic idioms set comprehension and loop else have relatively low mix usage while truth value test and assign multipletargets have high mix usage in methods.
table summarizes the occurrence of non idiomatic code that can be refactored with an idiom the non idiomatic column and the occurrence of a type of pythonic idiom the idiomatic column at the statement level.
sum is the sum of the two occurrences and is the percentage of the non idiomatic code out of the sum.
for the five pythonic idioms set comprehension dict comprehension truth value test loop else and star in func call the percentages of non idiomatic code are about .
.
.
list comprehension and for multi targets have low non idiomatic percentages .
and .
respectively .
this may be due to the popularity of these two idioms in the python community.
most of online resources we read mention these two idioms.
these two idioms have been used more than 349k and 127k times.
although the percentage of nonidiomatic code is low there are still large numbers of non idiomatic code fragments and that can be refactored with the list comprehension idiom and the for multi targets idiom respectively.
in contrast chain comparison and assign multi targets have high non pythonic percentages .
and .
respectively .
expression comparison and assignment are very basic programming constructs no matter in python or other programming languages.
however developers may not realize unique pythonic idioms for comparison and assignment.
for example developers are surprised when they see python can make comparison for more than two operands2.
.
rq3 challenges in writing idiomatic code we examine stack overflow questions to understand the challenges in writing idiomatic code.
we search the questions for each pythonic idiom using the python tag and the pythonic idiom name.
we examine the returned top questions and summarize the challenges in using pythonic idioms in the discussions.
we summarize 3esec fse november singapore zejun zhang zhenchang xing xin xia xiwei xu and liming zhu three key challenges.
table shows some representative examples.
many questions have very high view counts which indicate common information needs.
the c column lists the challenge index as discussed below.
one question may involve several challenges.
however we observe that the three challenges have a progressive relationship.
for example when developers do not know the meaning of an idiom they would also further ask how to use the idiom correctly.
therefore we list only the most fundamental challenge.
developers do not know certain pythonic idioms.
for example for the dict comprehension idiom the 4th row in table the developer knows list comprehension but he she does not know whether he she can initialize dictionary in a similar way.
the question has been viewed about times.
although it was asked years ago it was still actively discussed about month ago as of this paper writing .
idioms in python are more than those in other mainstream languages which brings challenges for developers to learn and write idiomatic python code.
developers know certain pythonic idioms but they do not understand what the idioms can do.
consider the question for using asterisk operator in the function call the second last row in table which has been viewed about times.
the developer notices a single asterisk zip x can be used before a parameter in function calls but he she does not know what this means and what it can be used for.
actually the x is to unpack x into multiple arguments.
knowing what an idiom can be used for is the pre requisite for using it in practice.
developers know what a pythonic idiom can do but they do not know how to use them properly.
the 2nd row of table shows such an example.
the developer wants to refactor a list initialization using list comprehension.
unfortunately he she does not know whether and how if else statement can be used in the list comprehension idiom.
the question has been viewed about times.
in fact list comprehension has complex syntax and it may nest multiple loops and multiple if statements.
developers have to read and understand this complex syntax in order to use the list comprehension idiom properly.
it has been generally accepted that pythonic idioms result in concise code and improve runtime performance.
however non idiomatic code that can be refactored with pythonic idioms is widely present in real world projects and is often mix used with idiomatic code.
this could be caused by the fact that developers are often unaware of pythonic idioms or do not know when and how to use pythonic idioms properly.
although there are rich learning materials about pythonic idioms there are no effective tools to assist developers in writing idiomatic code and to enforce the consistent use of pythonic idioms in practice.
our approach we now present our refactoring tool for improving idiomatic coding practices.
figure shows the three steps for designing and implementing our refactoring tool.
these three steps answer three technical questions respectively how to identify programming idioms unique to python how to detect anti idiom code that can be implemented in pythonic idioms how to refactor nonidiomatic code with pythonic idioms in a systematic and extensibletable challenges in writing idiomatic python code idiom c question list comprehension question here is the code i was trying to turn into a list comprehension ... is there a way to add the else statement to this comprehension?
asked years active years viewed 165k times set comprehension question fastest way to generate a random like unique string with random length in python answer ...use a set comprehension to produce a series of keys at a time to avoid having to look up and call the set.add method in a loop... asked years active months ago viewed 16k times dict comprehension question i like the python list comprehension syntax.
can it beused to create dictionaries too?
for example by iterating over pairs of keys and values asked years active days ago viewed .0m times chain comparison question i write the following statement if x start and x end ... the tooltip tells me that i must simplify chained comparison what have i missed here?
comment thanks i didn t know you could do that in python.
was really scratching my head on this one.
asked years active years ago viewed 100k times truth value test question does python have something like an empty string variable where you can do if mystring string.empty asked years active days ago viewed .5m times loop else question why does python use else after for and while loops?
asked years active months ago viewed 245k times assign multiple targets question python assigning two variables on one line answer ...use sequence unpacking self.a self.b a b asked years active years viewed 19k times star in func call question what does the operator mean in python such as in code like zip x or f k ?
asked years active months ago viewed 234k times for multiple targets question tuple unpacking in for loops asked years active month ago viewed 222k times figure approach overview way.
rather than relying on mining code patterns or personal programming experience our solution is built on the effective analysis of python language syntax and specification.
.
identifying unique pythonic idioms a programming idiom can be regarded as a micro level code pattern.
mining programming idioms in code may identify a wide range of code patterns including not only pythonic idioms but also many generic code patterns and api usage patterns.
as online materials about idiomatic code usually mention only some popular pythonic idioms e.g.
list comprehension 4making python code idiomatic by automatic refactoring non idiomatic python code with pythonic idioms esec fse november singapore truth value test and enumerate function repeatedly based on personal programming experience collecting pythonic idioms from online materials is ad hoc and may miss important pythonic idioms.
in this work our goal is to not only identify pythonic idioms but also analyze these idioms to design the methods for detecting and refactoring non idiomatic code in a systematic manner.
therefore we resort to python language syntax and specification.
we observe that non idiomatic code share the common or similar syntax as other mainstream programming languages while pythonic idioms have unique syntax.
based on this observation we identify unique pythonic idioms by contrasting python syntax and the syntax of the other programming language.
in this work we choose java due to its popularity and syntactic similarity to python.
we examine each syntactic construct of python in python language specification and check whether there is some similar syntactic construct s in java.
for similar syntactic constructs we further compare and analyze the differences of the syntax grammars between python and java.
we consider the following four cases as candidate pythonic idioms python supports new syntactic constructs which do not exist in java.
this includes four syntactic constructs listcomp setcomp dictcomp andstarred which correspond to four idioms list comprehension set comprehension dictionary comprehension and single asterisk operator.
the list set dict comprehension create iterable object with one line of code .
the single asterisk operator is usually used to unpack the an iterable into positional arguments inside a function call star in func call .
we also identify several other new constructs such as yield with andgeneratorexp .
however it is very inconvenient to implement the same functionality as these new constructs in a non idiomatic way.
as such the yield with orgeneratorexp equivalent non idiomatic code is too complex to safely refactor.
therefore we do not consider yield with andgeneratorexp in this work.
python syntax adds new nodes.
python and java have the same syntactic construct but python syntax adds new nodes to extend its functionality.
this includes the loop construct which consists of the forandwhile statement.
for example the forstatement of python adds orelse node i.e.
the loop else idiom .
the orelse node is executed after the loop iterator is exhausted unless the loop ends prematurely due to a break statement .
python syntax adds new elements.
python and java have the same syntactic construct but python syntax supports more elements .
this includes the assign statement with multiple targets the assign multi targets idiom the chaincomp with multiple operators the chain comparison idiom and the forstatement with multiple targets the for multi targets idiom .
for example the assignment statement of python allows multiple variables to be assigned simultaneously.
a useful scenario for assign multi targets is to swap variables without creating temporary variables.
python syntax supports more comprehensive data type.
python and java have the same syntactic construct but python supports objects of more data types.
this includes the truth valuetesting idiom .
in python any object e.g.
string numeric type and sequences can be directly tested for truth value.
for example we can directly check if a variable a of list data type is empty with if not a instead of if a .table lists the nine pythonic idioms we identify and the code examples of idiomatic code and corresponding non idiomatic code.
for each identified pythonic idiom we read python language specification to confirm its validity.
we also search online materials with the idiom names to support our analysis.
searching with specific idiom names can find relevant supporting documentation.
however searching python idiom generally return many materials which do not cover all nine types of pythonic idioms.
.
detecting anti idiom code smells for each pythonic idiom we define syntactic patterns for implementing the pythonic idioms in a non idiomatic way.
contrasting python and java syntax provides the basis for defining such patterns.
in a sense we try to implement a pythonic idiom in a java style python code pattern.
the defined syntactic patterns can detect anti idiom code smells that can be refactored with pythonic idioms.
table lists our detection rules and illustrative examples.
.
.
list set dict comprehension.
the list comprehension idiom is used for the list initialization 2nd row in table .
the rule first finds an empty assignment statement stmt e.g.
dblist .
then it finds a forstatementstmt nwhich iteratively adds elements to the target dblist ofstmt .
there cannot be other statements using the target dblist ofstmt 1betweenstmt 1andstmt nto lest the dblist is modified i.e.
isnotuse stmt .target stmt stmt n .
since thestmt ncorresponds to the comp node of the listcomp construct which only supports forclause and ifclause the rule checks whetherstmt nsatisfies the matchcompre condition i.e.
if the stmt n corresponds to the syntax grammar of comprehension.
the detection rule for the non idiomatic code of the set comprehension and the dict comprehension idiom are the same.
.
.
chain comparison.
the chain comparison a op1bop2c ... y opnz is equivalent to a op1b and bop2c and ... yopnz .
the non idiomatic code of the chain comparison must be a boolop and expression which contains at least two compare nodes.
moreover the two compare nodes have the same operands.
for example for the expression cp and cp 3rd row in table thecpis the common operand of the two compare nodes and the expression can be refactored as cp .
.
.
truth value test.
the truth value test idiom is used for checking the truthiness of an object.
generally when developers want to compare whether an object is equal or is not equal to a value many programming languages use or !
operator to achieve the functionality.
in python any object can be directly tested for truth value so developers do not need to use or !
operator to test truth value.
python documentation specify the built in objects inemptyset e.g.
andset are considered as false value.
therefore if a statement directly compares an object to the element ofemptyset it will be regarded as a non idiomatic code of the truth value test.
however not all compare nodes are refactorable with truth value test.
for example a!
in return a!
cannot be refactored because return a changes the code semantic.
according to python syntax the non idiomatic code of truth value test corresponds to a test type node.
therefore our rule checks whether a compare node is the child of a test type node for example the runs is the child of an if node if runs 4th row 5esec fse november singapore zejun zhang zhenchang xing xin xia xiwei xu and liming zhu table examples of detection and refactoring of anti idiom code smells idiom detection rules and examples of code pairs refactoring steps 6making python code idiomatic by automatic refactoring non idiomatic python code with pythonic idioms esec fse november singapore in table .
since the if node is a test type node the compare node runs is refactorable to a truth value test.
.
.
loop else.
the else clause of the loop statement is executed after the iterator is exhausted unless the loop was ended prematurely due to a break statement.
the non idiomatic way of implementing a loop else generally has an assignment statement stmt 1to flag current state a forstatementstmt nwhich contains a statement sto change the current state and a break statementstmt jto end the loop and an ifstatementstmt n 1after the forstatementstmt n to check the current state to execute different operations.
there are four circumstances c1andc2complement each other and c3and c4complement each other.
thec1satisfies the following semantic conditions the semantic of the assignment statement stmt 1is the same as the semantic of the test node of if statement stmt n .test and the semantic of assignment statement sis different from the semantic of stmt wheresand the break statement stmt jare at the same scope.
these semantic conditions are designed because the non idiomatic code of loop else implies two execution paths 5th row in table stmt sandstmt stmt n 1orstmt sandstmt j stmt n .
thec2satisfies the following semantic conditions the semantic of the assignment statement stmt 1is the opposite of the semantic of the test node of the if statement stmt n .test the if statement stmt n 1has an else clause and the semantic of the assignment statementsis the opposite of the semantic of stmt 1wheresand the break statement stmt jare at the same scope.
the c2condition is a complement to the c1condition.
if stmt n 1has an else clause andstmt n .test has the opposite semantic with stmt it indicates that the else clause has the same semantic as stmt .
therefore the code satisfying the c2condition is also refactorable to a loop else.
for example 5th row in table if we change stmt n .test good partition into not good partition and add an else clause to the if statement the code satisfies the c2condition.
thec3satisfies the following semantic conditions the semantic of the assignment statement stmt 1is the same as the semantic of test node of the if statement stmt n .test and the semantic of the ifstatementsin the body of the loop statement stmt nis different from the semantic of stmt and the body of the if statement scontains the break statement stmt j. thec3is a variant of c1andc2.
thec1 andc2requires an assignment sto change the current state but c3 uses an if statement sto detect the change of the current state and break the loop such as if not good partition break .
thec4satisfies the following semantic conditions the semantic of the the assignment stmt 1is the opposite of the semantic of test node of the if statement stmt n .test the if statement stmt n 1has an else clause and the semantic of the test node of if statement s.test in the body of the loop statement stmt nis the opposite of the semantic of stmt 1and the body of the if statement scontains the break statement stmt j. thec4complements c3 in the same vein as c2complements c1.
.
.
assign multiple targets.
the assign multiple targets idiom is to assign multiple values at the same time in one assignment statement.
for several consecutive assignment statements if an assignment statement stmt kdoes not use the result of an assignment statement stmt ibefore it these assignment statements are refactorable to assign multi targets.
when an assignment statementstmt kuses the result of the an assignment statement stmt ibefore stmt k the code usually is to swap variables by creating temporary variables.
for such non idiomatic code it requires that the target of a statement stmt jbetween the stmt iand thestmt kis the same as the value of stmt i. for example 6th row in table stmt k d f uses the target f ofstmt i f d and the target d of thestmt j d d is the same as the value d of thestmt i f d .
this sequence of assignments via a temporary variable can also be refactored with the assign multiple targets idiom.
.
.
star in function calls.
the star in function call idiom is usually used to unpack an iterable to the positional arguments in a function call .
the non idiomatic way of passing a sequence of arguments is that the subscript sequence of multiple consecutive parameters of a function call is an arithmetic sequence of the same variable.
for example is an arithmetic sequence where the common difference is for accessing the first second and third element of sys.argv second to last row in table .
it can be refactored into sys.argv .
.
.
for multiple targets.
the non idiomatic code of the formultiple targets idiom only contains one variable as the target of for statement p. the body of puses the subscript expression to get elements of the variable.
for example the last row of table the code uses interval and interval to get the elements of the variable interval inside the body of for loop.
instead the elements of interval can be accessed using a for multiple targets idiom.
.
refactoring with pythonic idioms according to a refactoring is a series of small behavior preserving transformations.
based on this principle we analyze the ast transformations required to transform a piece of anti idiom code into an idiomatic code.
we identify four atomic ast rewriting operations across all idioms and then compose these atomic operations into the refactoring steps for each pythonic idiom.
the four atomic operations are as follows copy s i copies the node sof non idiomatic code to the positioniof a node of idiomatic code.
if the node at the position iis empty we copy sinto the position i. otherwise we insert sinto the positioni.
since a refactoring does not change the code semantics many parts of non idiomatic code can be copied to the resulting idiomatic code.
for example for the list comprehension idiom 2nd row in table both the target node item and the iter node cmplist of non idiomatic code are copied to the corresponding target and iter position of the comprehension node respectively.
for another example for the chain comparison idiom 3rd row in table we copy operands of compare node of non idiomatic code into the position of operands of a new compare node.
create s info builds the node of type swith information info where represents any amount of information.
to refactor non idiomatic code into pythonic idioms it is sometimes necessary to create some new ast nodes or elements which do not have the corresponding parts in the non idiomatic code.
for example for the truth value test idiom 4th row in table we need to create a not node.
for another example for the star in function call idiom 7esec fse november singapore zejun zhang zhenchang xing xin xia xiwei xu and liming zhu second to last row in table we need to create a starred node with subscript information from the non idiomatic code.
remove s removes the node sfrom the ast of non idiomatic code which is no longer needed in idiomatic code.
generally refactoring non idiomatic code into idiomatic code will reduce the lines or tokens of code.
therefore it is natural to remove those no longerused nodes.
for example for the loop else idiom 5th row in table we need to remove the initial flag assignment good partition true and the flag update statement good partition false which are no longer needed when the loop else idiom is used.
for another example for the assign multi targets idiom 6th row in table we remove assign statements from stmt 2tostmt n. replace s t replaces the node sof non idiomatic with the node tobtained through code transformation.
for example for the chaincomparison idiom 3rd row in table we replace the original expression cp and cp with the resulting chain comparison cp .
for another example for the for multi targets idiom the last row in table we replace interval interval with interval 0 interval 1 respectively.
the 3rd column of table shows the refactoring steps to complete each pythonic idiom refactoring.
the green line numbers shows the steps that are performed to refactor the examples of nonidiomatic code on the left into the idiomatic code on the right in the 2nd column of table .
for example to refactor the non idiomatic code example into a list comprehension code 2nd row in table we first create a listcomp node comp and then traverse the for statementstmt nto copy its children to the comp node line e.g.
copy item.
avatar to the position of stmt n.elt i.e.
elements to add to the list .
since stmt nandstmt 1are at the same scope line we directly replace stmt .value withcomp in and then removestmt n line .
finally the new stmt 1is the idiomatic code obtained through the refactoring.
when stmt 1andstmt nare at different scope line we do not perform the remove operation for thestmt 1becausestmt nmay not be executed after executing stmt so we only replace stmt nwithstmt 1and then update the value ofstmt n line .
evaluation this section reports the evaluation of our approach.
we focus on two aspects the correctness and usefulness of refactoring antiidiom code smells with pythonic idioms rq1 how accurate is our approach when refactoring real world anti idiom python code with pythonic idioms?
rq2 do code refactorings performed by our approach have practical value for real world projects?
.
rq1 correctness of refactorings .
.
motivation.
refactorings involve complex logic for detecting anti idiom code smells and applying code transformation.
we would like to confirm the design and implementation of our approach is robust and correct on real world python code.
.
.
method.
as described in section .
.
we collect repositories from github which can be successfully parsed using python and collect python source files from these repositories.
we apply our refactoring tool to these python source files to detectnine types of anti idiom code statements and refactor these statements with pythonic idioms.
we use both testing and code review to verify the correctness of refactorings.
testing based verification.
to determine the test cases that cover the detected non idiomatic code fragments we first collect the fully qualified names of all methods called by a test method using the dlocator tool .
if the method that contains a non idiomatic code fragment belongs to the list of the methods called by the test method we consider this test method as a test case for the nonidiomatic code fragment.
note that one test case may test one or more methods and one method may undergo one or more different types of refactorings.
then to execute the test cases successfully we install the packages that the project depends on by reading its requirements.txt.
note that not all test cases can be executed successfully because of several problems such as requiring other non python packages or to manually configure some parameters.
we filter out such fail to execute test cases.
in the work we use pytest a popular python unit testing frame which also supports the python s default unittest tool .
we run the test cases on the original methods with non idiomatic code fragments to ensure they pass successfully.
then we run the test cases again on the refactored methods.
if the refactored methods pass the test cases we consider the detection of anti idiom non idiomatic code fragments and the corresponding code refactorings are correct.
for the refactorings that fail the test cases the two authors independently analyze the failure causes.
two authors have more than three years of python development experience.
they examine the detected non idiomatic code fragments and the idiomatic code obtained by the refactorings and determine if the failures are caused by non idiomatic code smell detection or pythonic idiom transformation.
a detection failure means a detected non idiomatic code fragment is not refactorable e.g it cannot be safely refactored into semantic equivalent idiomatic code.
if the failure is caused by non idiomatic code detection we do not double count it as the failure of pythonic idiom transformation.
the two authors discuss to resolve their disagreement and reach the consensus.
finally we compute the accuracy of anti idiom code smell detection and idiomatic code refactoring for each pythonic idiom.
code review based verification .
we randomly sample pairs of non idiomatic code fragments and the corresponding idiomatic code fragments for each pythonic idiom.
then the two authors independently review these code pairs and determine if the non idiomatic code fragments are detected correctly and if the idiomatic code fragments are refactored correctly.
they discuss to resolve their disagreement and reach the consensus.
based on their code review results we compute the accuracy of anti idiom code smell detection and idiomatic code refactoring for each pythonic idiom.
.
.
result.
table presents the analysis results.
ref and tcs of the testing column are the number of refactorings with successfullyexecuted test cases and the corresponding number of test cases.
ref of the code review column is the number of refactorings we reviewed.
d acc and r acc are the accuracy of non idiomatic code smell detection and idiomatic code transformation respectively.
in total we successfully test refactorings from repositories and reviewed refactorings from repositories.
overall our 8making python code idiomatic by automatic refactoring non idiomatic python code with pythonic idioms esec fse november singapore table accuracy of anti idiom code smell detection d acc and idiomatic code transformation r acc idiomtesting code review refs tcs d acc r acc refs d acc r acc list compre set compre dict compre chain compa .
truth test .
loop else assign multi tar .
star in func call .
.
for multi tar total .
.
.
approach is very robust on real world code.
it achieves accuracy of detection and refactoring for five pythonic idioms i.e.
list comprehension set comprehension dict comprehension loopelse and for multi targets.
it achieves detection accuracy for chain comparison and refactoring accuracy for truth valuetest assign multi targets and star in func call.
detection failure analysis.
our verification identifies detected non idiomatic code fragments which are not refactorable including for truth value test for assign multi targets and for star in func call.
for example for the truth value test if xpath results if xpath results is an empty string the if condition is false.
however the idiom if not xpath results will be true if xpath results is an empty string.
therefore if xpath results cannot be refactored into if not xpath results .
other nonrefactorable truth value test cases suffer from the same problem.
the two non refactorable assign multi targets failures are caused by the limitation of the python static parsing.
for example for the two assignment statements stmt lib ... andstmt tmpl lib .
lib ofstmt 2is a variable because python uses curly brackets to insert variables in string.
stmt 2uses the target lib ofstmt so the two statements cannot be refactored into lib tmpl ... lib because it will make tmpl use the old value of lib.
since the parser parses lib into a string constant and does not parse the lib inside the brackets into a variable we loss the information of data dependency and mistakenly identify the statements as refactorable.
for the star in func call idiom both testing and code review find two non refactorable non idiomatic code fragments identified by our detection tool.
the reason is that our tool does not consider the semantic of python slice.
for example for the code self.add circle arc p p p is an arithmetic sequence.
however python list grows linearly and is not cyclic as such slicing does not wrap from end back to start going forward as we expect.
code transformation failure analysis.
our tool makes only code transformation error for chain comparison.
for the code type is not none and self.
meta types and type not in self.
meta types it has three comparison operations and type is the common operand of the first and the third operation.
therefore we refactor it into none is not type not in self.
meta types and self.
meta typestype .
however if self.
meta types is none the refactoring will report a typeerror at runtime because none is not iterable.
as our tool does not analyze the priority of comparison operations and adjust their order when refactoring the code the resulting code encounters the runtime error.table results of our refactoring pull requests idiom category accepted rejected merged repo list comprehension set comprehension dict comprehension chain comparison truth value test loop else assign multi targets star in func call for multi targets total our refactoring tool is robust and correct on real world python code.
the limitation of python static parsing and the complex program logic may result in a few rare detection and refactoring errors.
.
rq2 usefulness of refactorings .
.
motivation.
our tool is the first refactoring tool for pythonic idioms.
we would like to know how well python developers accept the refactorings our tool makes and what opinions they have towards pythonic idiom refactoring in practice.
.
.
method.
we randomly sample refactorings including the original non idiomatic code fragments and the resulting idiomatic code after refactoring for each type of pythonic idiom.
the sampled refactorings come from repositories.
we fork the repository corresponding to the non idiomatic code fragment and commit a pull request with the resulting idiomatic code.
readers can find the list of the pull requests in our replication package.
we collect the developers responses to our pull requests and count how many pull requests have been accepted or rejected by developers.
among the accepted pull requests we further count how many pull requests have been merged into the repositories.
.
.
result.
table presents our experiment results.
among pull requests we received responses including accepted and rejected.
of the accepted pull requests have been merged into the repositories.
the six pull requests that are not merged as they are not yet tested.
the response rate indicates that python developers pay attention to the pythonic idiom refactorings.
the acceptance rate and the merge rate among the responses provide the initial evidence of our refactoring tool s practicality and usefulness.
among the accepted pull requests many developers praise the refactoring pull requests we made to their repositories.
for example two developers praise the dict comprehension refactoring name mod for name mod in module.named modules if isinstance mod convnd thanks for the contribution looks great!
.
many developers confirm that the suggested refactorings are more pythonic such as definitely more pythonic!
on a list comprehension refactoring.
some developers express the interests in refactoring other places with the same pythonic idiom such as i will change the other place to a more pythonic style ... inspired by our pull request for an assign multiple targets refactoring.
we analyze the rejected pull requests and summarize four main concerns developers have about pythonic idiom refactorings readability performance systematic refactoring and inertia .
9esec fse november singapore zejun zhang zhenchang xing xin xia xiwei xu and liming zhu readability.
out of reject responses are concerned that the pythonic idioms make the code less readable.
for example the developer comments on a suggested star in func call refactoring clip.size while your change is indeed feasible i believe the original style is more readable .
even with the readability concern some developers express that they learn something from the suggested refactorings.
for example the developer comments on the chain comparison refactoring sessions is none is metrics ... interesting ... i learned something today though thanks.
as another example the developer worries that refactoring may loss specific information for the truth value test.
for example a developer replied i feel like asserting it to empty dict is more explicit and readable if assert deepdiff.deepdiff ... is refactored into assert not deepdiff.deepdiff ... .
performance.
reject responses are concerned about the performance or memory usage.
for example for the list comprehension refactoring the developers reject the pull request because they are not sure that the performance improvement would be significant in their project.
for the star in func call refactoring which refactors ss ss ss ss ss ss ss into ss the developer believes the refactoring can cause memory fragmentation.
systematic refactoring.
reject responses indicates that developers do not want to refactor the project in an ad hoc way.
two responses are discouraged to refactor only one code fragment of the project.
for example although the developers reject our pull request for a set comprehension refactoring they propose that such refactorings should be applied to the whole project rather than by a single pull request to just one place.
in another reject response the developer replies that waf is just a tool for us.
we don t need style patches for it.
for a list comprehension refactoring.
in fact we believe these responses confirm the need for systematic pythonic idiom refactoring tool like ours.
our tool can scan and refactor the whole project and dependent packages.
it was just we submitted only some randomly sampled refactorings to the projects.
inertia.
rejects are because the developers prefer the original code.
for example a developer replies thanks for the suggestion i prefer the existing code for a star in func call refactoring.
and some developers would like to accept pull requests to fix bugs instead of code refactoring e.g.
the developer replies to a formultiple targets refactoring i think it s better to leave the rubi code alone for now unless there is work to fix it.
.
our pythonic idiom refactorings have been well received by the developers.
the developers also raise concerns about readability and performance of pythonic idioms which deserve further study.
related work .
pythonic idioms how to write pythonic code has been a popular topic .
several studies identify some python idioms to help developers write more idiomatic code commonly referred to as more pythonic .
alexandru et al.
identify pythonic idioms list comprehension and dict comprehension overlap with our work from several books.
merchante et al.
identify the usage of pythonic idioms in github.
kula et al.
visualize the usage of the with open idiom over time and find that projects areaccustomed to using the with open idiom instead of non idiomatic counterpart.
phan udom et al.
develop a tool to recommend pythonic code examples by searching similar code examples from code snippets of three repositories.
different from these related works our work identifies unique pythonic idioms from the language syntax and find idioms star in func call for multi targets assign multi targets loop else that have not been identified before.
furthermore we not only identify pythonic idioms but also develop an automatic tool to refactor anti idiom code into idiomatic code.
.
code refactoring martin fowler proposes code refactoring about years ago.
an active line of research is to recover refactorings made in the code .
prete et al.
detect the largest number of refactoring types based on the fowler s catalog.
tsantalis et.
al.
identify java refactoring types by statement matching algorithm and refactoring detection rules.
dilhara et.
al.
identify python refactoring kinds e.g.
rename move pull up methods which do not overlap with our refactoring type.
another active line of research is to refactor code .
ouni et al.
propose a multi objective search based approach for finding the optimal sequence of refactorings.
k hler et al.
develop a tool to automatically convert asynchronous code to reactive programming.
pylint is a static code analysis tool which could give refactoring suggestions for chain comparison and truth value test but it does not support automatic refactorings.
to the best of our knowledge our tool is the first automatic refactoring tool which covers types of pythonic idioms.
discussion .
pythonic coding practices refactoring is a widely adopted practice to improve code quality.
a wide range of refactorings have been proposed to address code smells such as code clones feature envy shotgun surgery.
our work introduces a new type of code smell i.e.
non idiomatic code that can be refactored with pythonic idioms.
our empirical study on github repositories and stack overflow questions calls for the tool support for assisting developers in using pythonic idioms consistently.
our refactoring tool is the first tool of this kind.
the evaluation on a large number of python projects provides positive and encouraging feedback on the prototype.
some developer feedback raises concerns about the readability and performance of pythonic idioms.
this calls for the careful validation of the conciseness and performance of pythonic idioms.
however existing online materials are anecdotal and mostly based on personal programming experience.
our work produces a large dataset of non idiomatic versus idiomatic code from real world projects which serves as an excellent testbed to empirically investigate the general claims and concerns about pythonic idioms.
.
threats to validity threats to internal validity relate to two aspects in our work the errors in the implementation of code refactoring tool and personal bias in evaluating accuracy of code refactoring.
for the aspect we have double checked the code and verified the accuracy of our tool implementation by manually examining a 10making python code idiomatic by automatic refactoring non idiomatic python code with pythonic idioms esec fse november singapore large number of refactoring instances outputted by each step of our tool.
as for the aspect two authors with more than three years of java and python programming experience check the accuracy of refactoring instances independently.
furthermore we collect a large number of real test cases to test the refactored code.
threats to external validity relate to the generalizability of experiment results.
to alleviate this threat we built a large scale dataset of repositories and python files.
to explore whether our code refactoring has practical value for developers we submitted pull requests to project members to review.
the number of pull requests is larger than existing user studies in previous works .
we release our tool and data in zenodo3for public evaluation.
conclusion and future work this paper designs and implements the first automatic refactoring tool for nine types of pythonic idioms.
our tool is motivated by the empirical observation of the challenges in writing pythonic code from the stack overflow discussions and of the wide presence of non idiomatic code in thousands of real world python projects.
rather than relying on idiom mining literature review or personal programming experience our approach identifies pythonic idioms and define non idiomatic syntactic patterns and idiomatic code transformation steps through the systematic analysis of python abstract syntax grammar.
our tool is robust and correct in detecting anti idiom code smells and refactor these smells in real world python projects.
the refactorings made by our tool have been well received and praised by the python developers.
in the future we will integrate our refactoring tool into the open source linting tool e.g.
pylint .
we will systematically investigate the readability and performance concerns about pythonic idioms based on the largescale refactoring dataset our tool produces.