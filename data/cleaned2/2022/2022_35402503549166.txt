multi phaseinvariant synthesis daniel riley floridastateuniversity unitedstates driley cs.fsu.edugrigoryfedyukovich floridastateuniversity unitedstates grigory cs.fsu.edu abstract loops with multiple phases are challenging to verify because they requiredisjunctiveinvariants.invariantscouldalsohavetheformof implicationbetweenapreconditionforthephaseandalemmathat is valid throughout the phase.
such invariant structure is however not widely supported in state of the art verification.
we present a novel smt based approach to synthesize implication invariants for multi phaseloops.ourtechniquecomputesmodelbasedprojections to discover the program s phases and leverages data learning togetrelationshipsamongloopvariablesatanarbitraryplaceinthe loop.
it is effective in the challenging cases of mutually dependent periodic phases where many implication invariants need to be discovered simultaneously.
our approach has shown promising resultsinitsabilitytoverifyprogramswithcomplexphasestructures.
we have implemented and evaluated our algorithm against several state of the artsolvers.
ccs concepts software and its engineering formal software verification.
keywords automated safety verification inductive invariant synthesis satisfiabilitymodulotheories modelbasedprojection acmreference format daniel riley and grigory fedyukovich.
.
multi phase invariant synthesis.
in proceedings of the 30th acm joint european software engineering conferenceandsymposium on the foundationsof softwareengineering esec fse november14 18 singapore singapore.
acm newyork ny usa 13pages.
introduction automatedsoftwareverificationtoolsoftendelegatetheircomputationaltasks tosolversforsatisfiability modulotheories smt and constrained horn clauses chc .
the latter aims at synthesizing inductive invariants for loops and recursive calls and it enables sound reasoning about software safety.
existing chc solvers extensively rely on smt solvers.
the ability to discover a solution often critically depends on the capabilities of the smt solver to apply interpolation or quantifier elimination.
recently proposed permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse november 14 18 singapore singapore copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
methods while still relying on smt solvers to prove invariants are guided by external sources such as user providedgrammars templates orconcretedatatogenerate differentpiecesofinvariants.
programsthatdisplaycontrol flowdivergenceinthebodiesof theirloopsusuallyrequire multi phaseinvariants thatareusually disjunctiveandaremoredifficulttoinfer .ourworkis motivatedbytheneedforimprovedmethodstoverifymulti phased systemsusedinseveral fields specifically control software and reactive systems perform tasks depending on their environment .
such changes boil down to phases where the behavior of the system will be different based on the conditions.
these systems are often safety critical such as self driving systems flight software or medical diagnostic software.
multi phase loops may arise from a common transformation technique such as loop flattening used by verification frontends when translating from a programming language such as c orjavainto chcs .
verification systemshavebecome more modular withsolversinthebackendrelyingonfrontendsystems to translate a given program.
consequently the backend solvers do not always have control over the result of the translation and can be given multi phase loops even if the source program does not have them.
termination checking is often reduced to safety verification .
a ranking function is found to overestimate the number of iterations of a loop.
in a complicated case of lexicographic ranking functionsynthesis variousprogram phases need to be analyzed.
multi phase invariants may help in these cases.
our new approach to multi phase invariant synthesis aims to find predicates that have the form of implication where the lefthandsideiscalleda phaseguard uniquelydescribingwhenacertain phaseisenabled andtheright handsideiscalleda phaselemma .
implicationsbydefinitionencodeadisjunction sotheirusehere intuitively captures the disjunctive nature of multi phase loops.
generation of phase lemmas is challenging because they should be valid under their phase guards.
in this paper we describe a new algorithm to derive both phase lemmas and their phase guards automatically.
we build on top of the houdini strategy where invariants are selected from a set of candidates.
the synthesis loop can be parameterized by grammars be data driven or follow some semantic inference rules.itbegins similarlyto manytraditional algorithms i.e.
by guessing candidates and checking their inductiveness using an smt solver.
our main idea is to synthesize a phase guard for each candidate that fails the inductiveness check thus weakening it.
intuitively a phase guard represents a set of states for which the failedcandidate isinductive.
esec fse november14 18 singapore singapore daniel riley andgrigory fedyukovich program weaken propagateenum cands lemmas foundhoudini safe inductive invariantsygus data learningdata learning fast forwarding quantifier elimination inductive lemma figure architecture of implcheck .
our first main insight is that phase guards are computed by amodel basedprojection mbp thatunder approximates quantifierelimination qe overtheloopbody.becauseadiverging control flow can be represented as a disjunctive formula its underapproximation adisjunct encodesaloopphase.weuseanmbp algorithm to lazily compute all phase guards and organize theminadecision tree.
thesecondimportantdesignchoiceistheuseofdatatracesfrom a particular phase for discoveringphase lemmas.
for numeric programs existingmethods havealreadyproventheir success but they criticallydepend onrelevantdata.
we propose a newmethodfordatacollectionusingansmtsolverthattakesa bounded unrolling of a phase beginning at a state where the phase guard does not hold and proceeds to states where it holds.
this avoidsthecreationofthefullunrollingthatexecutestheloopfrom its initial state upuntil the entry to the current phase.however a naive application ofthisidea mayresult insome importantcomputation from a previous phase not being taken into account.
to mitigatethis ouralgorithmreusestheinvariantsfromtheprevious phases and any global invariants1 if they have already been found.
the high level overview of the approach is shown in fig.
.
the algorithm takes a program encoded in chcs then extracts and organizes itsphases intoadecision tree.
the search ofcandidates begins with an enumerative approach that supplies an initial set of candidates which if they fail the houdini check are passed to ourweakeningengine.theenumerationblockofourframeworkis parameterizeable by any paradigm which synthesizes expressions including a syntax guided synthesis sygus approach and or adatalearner thatextractsinvariantsfromboundedbehaviors.
inweaken and propagate candidatesaresynthesizedintothe form of implication with the premise being a phase guard and the conclusion being a phase lemma.
these implication candidates are passed to houdini to calculate their inductive subset.
when the collection of lemmasreturned by houdini is strong enough to blockthe errorstates the program isverified safe.
1a globalinvariantis one that is not associated with a phase guard .ournew algorithm has beenimplemented in a tool called implcheckontopofthe freqhorn chcsolverandthe z3 smt solver and uses their quantifier elimination mbp and data learning algorithms.
we have evaluated it against state of the art on a set of public benchmarks.
of particular interest are a subset from chc comp that include a variety of phase structures within their loops which we believe tests the robustness of our approach.thesetofexperimentsconfirmsthat implcheck iscapable of inferring a much larger set of multi phase invariants than the competitorsandthatitsoverheadwhilerunningonsingle phase benchmarks issmall.
therestofthepaperisstructuredasfollows.weproceedwith an illustrating example in sect.
2and a brief background in sect.
.
sect.4summarizesourcontributionsonsynthesizingphaseguards usingmbpandorganizingtheminadecisiontree.theoverviewof thealgorithmisthenpresentedinsect.
.sect.6givestwostrategies on synthesizing phase lemmas by propagation using quantifier elimination a general approach and accelerateddata learning an approach designed for numeric programs .
the implementation is briefly reported in sect.
and the evaluation and comparison against the state of the artisdetailedinsect.
.
illustrating example theprograminfig.
2illustratesthemainconceptsofourapproach.
it has three variables xalways increments yis assigned nondeterministically and zincrementsconditionally.theloopbodyhasa singleconditionalanduptothreedifferentphases dependingon thevalueof y.theplotinfig.
2depictsthecasewhen yispositive andthustheloopgoestothreephases fromtheinitialstateuntil the guard starts to hold when the guard holds and when the guard does not hold anymore.
after the loop terminates and if yis positiveand xissufficientlylarge ourgoalistoprovethat zequals .
a safety property canbe proved byfinding an inductive invariantwhichintuitively1 isimpliedbytheinitialstatesformula is closed under the transition relation and implies the safety property.aninductiveinvariantforourillustrationprogramisgiven in fig.
.
it is nontrivial in our experiments ten state of the art invariant synthesizers failed to discover it automatically within a one hourtimeout.intuitively theinvariantdescribesarelationbetween variables x y andzin three phases of the loop when yis positive ifxis sufficiently smallthen zremainsatzero then zandxgrow simultaneouslyuntilatsomepoint zreaches1000andstagnates.
ouralgorithmgeneratesanindividualinvariant calleda lemma for each of the three phases and then conjoins them together.
each lemma has the form of an implication its antecedent is called a phaseguard andits consequent iscalleda phase lemma .
todiscoverphaseguards ourapproachanalyzesthecontrolflow of the program and organizes its phase reachability information in adecisiontree dt showninfig.
.dtapproximatestheorderand conditions of visiting all possible phases.
that is if yis positive theny xdiv1000holdsatthebeginning y xdiv1000holds after some iterations and y xdiv1000holds at the end and thustherightmostbranchofthedthasdepththree .ingeneral we canshowthateveryprogramhasonlyafinitenumberofphases 608multi phase invariant synthesis esec fse november14 18 singapore singapore intx y z x z y nondetint while if y x z x if y x y assert z x yzvalues of variables iterationsphase phase phase figure c likeprogram with amulti phase loop.
y y xdiv1000 y y xdiv1000 y y xdiv1000 y y xdiv1000 y y xdiv1000 y y xdiv1000 figure decision tree forphase guard selection.
first phase x y z 0second phase x y z 3third phase x y z figure data matricescapturing variable values.
inv x y z. y y xdiv1000 z y y xdiv1000 z x 1000y y y xdiv1000 z figure safe inductive invariant.
precomputed before the analysis so our algorithm can cheaply traversethe dtmultiple times throughout the verification.
to discover phase lemmas we can in principle follow various techniques fromguess and checktofixpointcomputation.however for numeric programs the most effective approach in our experienceisbasedondatalearningand houdini.itbeginswith constructingadatamatrixforallthephasesindividually shownin fig.
andinferringrelationshipsbetweenvariables.forthefirst phase the process is straightforward a value for yis randomly picked and if it is positive then we have to follow the rightmost branch of the dt.
thus the values for xandzin the first three iterationsareinferred precisely givingusaphase lemma z 0to be associated with the phase guard y y xdiv1000.
then thechosenbranchofthedtleadsustothesecondphase i.e.
in whichy y xdiv1000holds .
the data matrix creation in this case is trickier since for y 5we would have to unwind the loop times which is expensive .
instead we simulate thisusing a technique called fast forwarding the loop unrolling begins atanarbitraryiteration suchthatthefirstphaseguardholdsatthe beginning but the second guard holds at the end.
for our example it issufficient toget theseconddata matrixand consequently the second phase lemma z x 1000y.
lastly the third phase is computed similarly and the conjunction of them is sufficient for provingthe safetyproperty inthe program.
background this paper approaches the problem of automated software verification by reduction to satisfiability modulo theories smt problems.
.
logicnotation andmainroutines automated smt solvers determine the existence of a satisfying assignmenttovariables alsocalleda model ofafirst orderlogic formula.
we write m to denote that a model msatisfies a formula and m to denote the satisfiability of .
formula is logically stronger than formula denoted if every model of also satisfies .
the unsatisfiability of formula is denoted false.
by writing x we denote a predicate over free variables x.we useiteto denote if then else .
for a formula terms formulas aandb we write to denote after all instances of aare replaced by b. for a set of terms formulas xand a mapping mfromxto other terms formulas denotesthesimultaneousreplacementofall x1 x2 ... x bym x1 m x2 ... respectively.
by wedenotethespaceofallpossiblequantifier freeformulas in our background theory and by varsa sequence of possible variables.
because in the paper we mainly deal with conjunctive formulas which are created by adding dropping conjuncts we sometimes slightly abuse the notation and refer to s 2 as a conjunction ofallits elements i.e.
logicalandtext.
c sc.
theproblem ofquantifier eliminationis fora given vecy.
vecx vecy to generate an equivalent vecy free formula and it can be approached by converting vecx vecy to dnf eliminating quantifiers from each disjunct and disjoining the results.
our main insight instead is to buildthephaseguardgenerationengineontopofanotionofmodelbasedprojection mbp thatunder approximatesqewithout converting to dnf.
specifically one could compute a number of mbpslazily anddisjoin them.the number of mbpsis in practice significantly lower than the number of disjuncts in the dnf of the same formula whichyieldssignificant performance gains.
definition3.
.
givenaformula over vecx vecy andamodel m an mbp vecy m isa vecy free formula if the following hold ifm vecx vecy then m mbp vecy m mbp vecy m vecy.
vecx vecy forlinearintegerarithmetic anmbpforformula anditsmodel mcan be constructed from literals of formula converted to the negation normal form nnf finding literals that evaluate to true onm andeliminating vars fromtheirconjunction.moreformally itispresentedinalgorithm .wedeferanexampleofthealgorithm run to sect.
.
where it is used in the context of multi phase program verification.
609esec fse november14 18 singapore singapore daniel riley andgrigory fedyukovich algorithm1 mbpvars m basic mbp construction input m model vars vars formula output vars free mbp 1 tonnf 2 vars vars l l literals m l 3returnqe vars vars .
vars vars .
programsandtransitionsystems we view programs as transition systems and throughout the paper use both terms interchangeably2.
definition3.
.
atransitionsystem pisatuple vars vars init tr wherevarsandvars arecopiesofthe sequenceofvariablesatthe beginning and the end of a transition respectively initandtr are the symbolicencodings ofthe initial states and thetransition relation.
a program pand an encoding badoferror states define averification problem which is satisfiable if the set of error states is unreachable.
if satisfiable a solution of a verification problem is asafeinductiveinvariant representedbyaformula invsuchthat invover approximates init is closed under tr andinvis strong enough to blockallerrorstates.
definition .
.
givenp vars vars init tr a formula invis asafeinductiveinvariant ifthefollowingconditions respectively calledan initiation aconsecution andasafety hold init vars inv vars inv vars tr vars vars inv vars inv vars bad vars false example3.
.
theproblemoffindinganinductiveinvariantfor program infig.
2can be formulatedas follows.
x z inv x y z inv x y z x x y y z ite y xdiv1000 z z inv x y z inv x y z y x y z false .
data learning weusedatalearningtodiscoverinductiveinvariantsbyexamining programtraces.tracesaregatheredasafiniteunrollingbasedona boundedmodelchecking bmc formula .
anunrolling of length mof a program p vars init tr is a conjunction unrl vars ... vars m def init vars tr vars vars ... tr vars m vars m witheach i j k n suchthat i jandk n vars i vars j .
notethatwerelyonsequences ratherthanonsets ofvariables vars and we can extract the nthvariable of varsviavars .
this is useful for obtaining data to learn predicates which consist of 2althoughthepresentationassumessingle loopprograms ourimplementationworks also for programswith multiple loops.values for each variable in each iteration of the program.
it can be either obtained by a dynamic execution or extracted from a model m unrl vars ... vars m for some unrolling of the program.
the valuesobtainedfrom the modelare then storedinamatrix.
anm nmatrixais composed of mrows representing the iterationsofaprogramandof ncolumnsrepresentingthevalueofa variablevars .eachelement a ofaholdsthevalueinthe ith iterationofthe jthvariable thatis if m unrl vars ... vars m thena def m vars i .
fig.4showsthreeexamplematricesrepresentingthreedifferent phases of example .
.
an unrolling for our motivating example begins at the initial state and captures the information shown in thefirst phase matrix of fig.
.
for instance the first matrix is computedfromamodelof unrl vars vars vars containedof init and two copies of tr.
after an unrolling data learning proceeds to analyze the resultingmatrix.
from linear algebra given a vector space vover a field f its basisb b1 ... bi is the minimal subset of vif every vector v vcanbewrittenasalinearcombinationof b.thebasis bof thenullspace thesetofallvectorsthatwhenmultipliedby aequal to vec0 ofaproducescandidateinvariants .invariantsfoundfrom basisvectorstaketheshapeofequalities a1x1 a2x2 ...aixi .
example .
.
letabe the matrix of second phase in fig.
.
solvinga vecb the solution for vecbis parenleftbig parenrightbig .
then the candidate invariantis z x 1000y.
a weakness of this approach stems from the construction of the datamatrixusedtoproducecandidateinvariantsforanarbitrary phase itwouldrequireconstructingpotentiallylargeunrollings.
we willexplore awayaround this weakness insect.
.
.
inductivesubset extraction in this paper we target invariants composedfrom multiple lemmas i.e.
inv l0 ... ln where each lipasses the initiation and consecution checks from def.
.
.
thus invariants can be found by anenumerationofcandidateformulasandfindingasubsetofthem suchthattheirconjunctionfulfillsthethird safety checkaswell.
givenaninitialsetofformulas eithercapturedinapredetermined grammar obtainedfromsyntax orbehaviors anenumerativeapproachaimsatgraduallynarrowingittoasubset the conjunction of which is a solution.
the houdini algorithm showninalgorithm findsformulasthatpasstheinitiationand thencontinuestoiterativelyremovebadcandidatesusingsocalled counterexamples to induction .iftheremainingcandidatesarenot consistent withthe setof errorstates the program issafe.
example .
.
letcands z z for example .
then algorithm 2iterates two times.
first it finds that z 0is not inductive e.g.
by finding model m x y z x y z and it keeps only z 0because m z .
second it finds that z 0is inductive and returned as alemma whichis however not enough for provingthe safety.
while the algorithm is useful for finding conjunctive invariants its weakness is in a too aggressive weakening i.e.
keeping or dropping the entire candidate .
however the dropped candidate 610multi phase invariant synthesis esec fse november14 18 singapore singapore algorithm2 houdini p bad cands cf.
input p vars vars init tr program bad errorstates cands 2 output res safe unknown setlemmas cands of inductive lemmas 1cands c cands init vars c vars 2while m s.t.
m cands vars tr vars vars cands vars do 3cands c cands m c vars 4ifcands vars bad vars falsethen 5returnsafe cands 6returnunknown cands z 0can be weakened in another way by adding a phase guard as infig.
.our novel weakeningstrategyisdiscussedinsect.
.
phasereachabilitytree thereasonforcontrol flowdivergencecanoftenbeextracteddirectlyfromtransitionrelations3.whenatransitionrelationisin adisjunctivenormalform dnf theneachdisjunctrepresentsa group of programexecutionsbelonging to the same phase.for deterministic programs these disjuncts have conditions on the states atthebeginningofatransition usuallycalled sourcestates that has to be true for all executions in the corresponding phase.
these conditions are quite important for our invariant synthesis since they can be used to weaken candidates that do not pass a houdini run andthuswecallthem phaseguards .obtainingphaseguards inourapproachproceedsintwostages.first ouralgorithmcomputesafinitenumberofphasesfromthetransitionrelationusing quantifierelimination qe .theresultingformulasrepresentphase reachabilityinformationthat arearrangedinadecisiontree dt and lastly strengthened based on their position in the dt to reflect somecontext specific information.
.
model basedprojectionsas phaseguards informally a guard is a description of a subset of source states that needtobetrueforalltransitionsofthephase.insteadofconverting atransitionrelationtodnf andthenapplyingqetogetaguard for each disjunct our approach picks one representative transition ofaphaseandidentifiesitsphaseguard.atransitionisrepresented by a model of the trformula over source and destination variablesvarsandvars .
thus we have to compute an mbp of formula vars .tr vars vars basedonthat model.
example4.
.
recallexample .
inwhichthetransitionrelation isas follows.
x x y y z ite y xdiv1000 z z 3the main benefit of conducting an analysis over this symbolic encoding vs over theprogram ssourcecode isthattheapproachislanguage agnostic.furthermore isisalsoinsensitivetotheverificationfrontendthatdoestheencoding.specifically tools often perform various program transformations including ones that change the control flowstructure sometimesdrastically.thus thephasereachabilityinformation obtained fromthe source code level maynot be adequateat the level of the symbolic encoding.algorithm3 allmbp vars m input vars vars formula output mbps vars free setof model basedprojections 1mbps 2whiletruedo 3if m vars vars logicalandtext.
i mbpsi vars then mbps mbps mbpvars m vars vars 5else returnmbps the formula is satisfied by the model m x y z x y z thus we proceed to generating an mbp.
algorithm 1then splits the transitionrelation intoliterals literals tr x x z z z z y y y xdiv1000 y xdiv1000 y xdiv1000 it is easy to see that after collecting literals that are satisfied by m and conjoining them we can get an under approximation of the transitionrelation that only describes the firstphase y xdiv1000 x x z z y y lastly by eliminating x y andz we get the first phase guard y xdiv1000.
toobtainalloftheguards werepeattheprocessofgathering models of trthat are not covered by the previously generated guards as presentedinalgorithm .
.
organizingphaseguardsinadecisiontree itisconvenienttorepresentphasesinadecisiontree thatiscomputed exactly once prior to the invariant synthesis run.
we introducethenotionofaphase reachabilitytreetoapproximateall possibleexecutionscenarios assumingthatthephaseguardsare alreadycomputed.intuitively itgatherssequencesofphasesthat could be visited by a program the feasibility of every transition is checkedbyan smtsolver using the symbolic encoding of p. definition .
.
given a program p vars vars init tr a phase reachability tree dtpis a quadruple v e r p of sets of vertices from some set v edgese v v a rootr v and a vertex labelingfunction p v such that for all r v e formula init vars p v vars issatisfiable for all v1 v2 e wherev1 r p v1 vars tr vars vars p v2 vars issatisfiable for all paths r v1 ... vn indtp for every two vertices vi vj formulas p vi andp vj are equisatisfiable only if i j. everypath indtpcorrespondsto aprefix ofsomeexecution ofp possiblyspurious.whilethe dtpgivesusincompleteinformationaboutprogramtraces itisoftensufficienttoderivephase invariants anditischeaptocompute.notethatgettingthemost precisephase reachabilityinformationforaprogramcouldbedifficult evenimpossible sinceitmayrequireknowingsomeauxiliary helper invariants.
however even a coarse dtpfits well for the purposes of our approach which reasons automatically in terms 611esec fse november14 18 singapore singapore daniel riley andgrigory fedyukovich algorithm4 strendt p dtp input p vars vars init tr program dtp e v r p phase reachabilitytree output dtp augmentedphase reachabilitytree 1for u v edo 2ifu rthen abduce init vars p v vars 4else abduce p u vars tr vars vars p u vars p v vars 6if falseand vars tr vars vars vars then forw subtree dtp v do p w p w of batches of loop iterations and discovers some locally inductive factsaboutphases see sect.
.
weslightlyabusethenotation andforanedge u v wereferto the phase associatedwith u resp.v as to a parent resp.
child phase.
construction of the dtpfrom the set of phase guards g returnedbyalgorithm 3isratherstraightforward itposesanumber of smt checks as shown in def.
.
given a set of phase guards and the symbolic encoding of p. at each parent phase viand each potential child phase vjfrom some gi g the reachability is checked by posing a satisfiability query to an smt solver.
if successful edge vi vj is added to e and the construction process recursesfor vjandgi vj .
unsatisfiability ofsomereachability formula guarantees that it is impossible in general to have a phase vjright after vi.
note that by construction some elements of the initial gmay appear in the final dtpseveral times but only once per path.
that is each path captures only phase guards without repetitions even if a phase of pis visited multiple times during the phase guardoccursin exactlyonce.inthecaseofinterleavingphases traversalofthe dtp cycles through .thus theconstructed dtp alwayshasafinitedepthwhichmakesitconvenientforthefurther synthesis process.
.
context specific phaseguard strengthening whileourprimarysourceofphaseguardsisthembpprocedure insomecases thediscoveredformulasarenotstrongenoughtobe phaseguards.ourmotivating example illustrates thiscase.
recall example4.
in which formula y xdiv1000is generated.
however if we use it solely i.e.
without conjoining with y inthe phase guardfor someinvariants our algorithm will not be able to produce the desiredinvariants as infig.
.
intuitively phaseguardstrengtheningisneededtobringmore context information into the phases e.g.
if a value of some variable s is unknown at the initial state then the loop may have severaldifferentphasescenarios dependingontherangesofpossiblevaluesofthatvariable s .inordertobringthisspecificphasereachabilityinformationtoinvariants weperform strengthening of dtpafter itisgeneratedfrom mbps insect.
.
.algorithm 4gives pseudocode of the algorithm.
it has two parts discovery of strengthening and its propagation to the subtree.
the algorithmtraversesthetree top to bottom andfindsedges where theenda parent phasedoesnotimplythebeginningofthe child phase.
the main idea is to infer a reasonably weaker condition underwhichthe child phaseisreachable andthenaddittothe phase guard of the child phase .
this is commonly achieved by abduction and ourpseudocode usesthefollowing implementation basedonquantifierelimination abduce a vars b vars def qe vars w .a b wherewisasubsetof vars whichcanbefoundheuristically.inour implementation we enumerate different wuntil abduction results in a formula that is non trivial and locally inductive.
then it is conjoined to all phase guards associated with the vertices in the subtree.
example4.
.
for example .
theneed ofstrengtheningofthe phaseguardisrevealedbysolving the validity of formula x z y xdiv1000 because the implication does not hold we aim at finding a reasonably weaker predicate to be conjoined with the antecedent to make the implication valid.
because there is only one model for formulax z then constraining xorzmakes no sense.
thus the abducible predicate has to be applied to variable y and itcan be foundbyqe over the following formula qe x z. x z y xdiv1000 .
the resultingformula y 0islocally inductive strengthening produced this way is not unique and in principle thisproceduremayberepeatedseveraltimes thatcanfurtherbe exploitedbyseveral maybe parallel runsofthemainalgorithm see thenextsection .
itisalsopossible toinferstrengtheningof dtpbeginning from the query in the reverse order.
we omit these extensionsofour approach inthe interestof savingspace.
invariantsynthesis basedon phase reachabilitytree in this section we present our core contribution an automated algorithmto discovermulti phaseinvariants.
itrelies onthe phasereachability tree dtp precomputed and possibly strengthened as shown in sect.
.
the main insights are to search for candidates that do not pass the initiation inductiveness checks in houdini to attempttoweakenthemusingphasesfrom dtp and importantly togeneratenewcandidates forthenextphases.whilethissection focuses on conveying the main ideas the two important design choicesfor newcandidate generationare deferredto sect.
.
.
overview algorithm 5givesanoverviewofourapproach.ittakesasinput a set of candidates for invariants which can be originated from any external source like data learning recall sect.
.
sygus e.g.
orany setof predeterminedtemplates.
thealgorithmtheninvokesalgorithm 2tocomputeaninductive subsetoflemmasfromthegivensetofcandidates.iftheconjunction of lemmas is safe the program is correct and the algorithm 612multi phase invariant synthesis esec fse november14 18 singapore singapore algorithm5 implcheck p cands phaseinvs dtp .
input p vars vars init tr program cands 2 phaseinvs 2 dtp precomputed phase reachabilitytree output inductive lemmas 2 res lemmas houdini p cands phaseinvs 2ifres safethen return safe 3ifcands lemmas then return unknown 4pickl cands lemmas 5phaseinvs weakenandpropagate p l dtp phaseinvs 6returnimplcheck p cands l phaseinvs dtp algorithm6 weakenandpropagate p l dtp .
input p vars vars init tr program l an invariantcandidate dtp v e r p phase reachabilitytree output cands 2 1cands 2for v1 ... vn paths dtp do 3fori ...ndo li l forj i ... 0do lj bwpropagate p lj p vj p vj k forj i ... ndo lj fwpropagate p lj p vj p vj k cands cands braceleftbig vars.
p vm vars lm vars bracerightbign m 10returncands terminates line .otherwise itpicksacandidate lthatfailedinitiation and or consecution then searches for a suitable phase amongverticesof dtpthatcanweaken l line4 .theweakening and new candidate generation is performed in algorithm .
lastly a set of new phase candidates is unified with the set of candidates tobecheckedby houdini inthenextrecursivecallofalgorithm .
a phase lemma has the form of implication and it is guessed in algorithm line9 by composing a guard as the left hand side of the implication and a formula l taken either from the initial candidatesetorderivedfromitastheright handside.algorithm is iterative in nature it generates sequences of phase candidates followingtheactualpathsof dtp.thatis ifaphasecandidateis created for the initial candidate land anithphase of some path thenthealgorithmseekstopropagate lbackwardtothe i th phaseof forwardto i thphase andifsuccessful evenfurther.
example .
.
recall example .6and failed candidate z for example .
.
following the rightmost path of dtpin fig.
thealgorithmguessesthefirstconjunctofinvariantinfig.
5and proceedsto the nexttwophases.
soundnessofouralgorithmisimmediate sincebasedon houdini itonlyterminateswith safewhenalltheconditionsofdef.
.
are fulfilledbyan external smtsolver.theorem .
termination .
assuming termination of houdini and ofthesmt solver thenalgorithm 5will terminate.
given an initial set of candidate invariants n and a formula tr there can only be a finite number of phase guards m produced by quantifier elimination.
these two pieces are the input to algorithm5.
on each iteration a candidate l is picked and sent to algorithm 6toattempttoconnectitwithaphase line 9ofalgorithm6.
the loop in algorithm 6will terminate when all phases of thetrhavebeenexplored i.e.
allpathsin dtphavebeenexplored of which there can be only a finite many or when a candidate has been matchedwithits appropriate phase.
there aretwoconditionsfor algorithm 5to terminate bothof whichareguaranteed.either houdini returnswitharesult safe line2 orthealgorithmrunsoutofcandidatestocheckandreturns unknown line3 .thealgorithmconsidersatmostapolynomial number of distinct candidates meaning if no safeinvariant is found theresult unknown isreturnedafterthesetofcandidates isexhausted.
.
optimizations forreadabilitypurposes algorithm 6ispresentedinanoversimplified form so a direct implementation of which could be inefficient.
specifically twoouternestedloopsattempttomatchcandidate l witheverypossiblephase often severaltimes .inpractice there are many optimization opportunities which we have in the implementation that check the consistency of land each phase p vi beforecreatingcandidates.inparticular beforeproceedingtoline we require the following.
for the head v1ofevery path we require that init vars p v1 vars l vars isvalidsinceotherwisethe initiationcondition wouldnot hold.
similarly for every vi we require that p vi vars l vars tr vars vars p vi vars is satisfiable we do not use a stronger constraint involving the validity here since we may not know the precise reachability information at an arbitrary phase .
additionally every edge of dtpneeds to be processed only once for some path andshould be skippedinthe otherpaths.
lemma propagation may be ineffective i.e.
depending on the strategy to be presented in sect.
it may return trueorfalse candidates.
the loops at lines 6and8break in this case and the algorithm proceedsto anewphaseorcandidate.
in practice it is rarely the case that many candidates require all iterations of triple nested loops in algorithm .
recall that input candidates to this algorithm are failed by houdini so our expectation then is that they will work only on a subset of phases paths.thus inpractice theaforementionedoptimizationsare often sufficient to preventthe algorithm from diverging.
synthesis ofphaselemmas in this section we describe our lemma synthesis strategies for algorithm 6that are specifically tailored to a more semanticallyaware search based respectively on candidate propagation and data learning.
these two approaches are used in algorithm 6at 613esec fse november14 18 singapore singapore daniel riley andgrigory fedyukovich x y z inv x y z inv x y z x x y y z ite x y mod3 z z inv x y z inv x y z x z false figure transition system encoding.
the callfw bwpropagate .
the difference between these can be treatedasademarcationbetweenamore generalinstantiationof our algorithm sect.
.
and the one specific to arithmetic theories sect.
.
.
.
phasepropagation usingquantifier elimination intuitively once a candidate invariant and its phase guard is created we can try to propagate it to the next phase i.e.
to a loop iteration where another phase guard holds based onour dtp.
for any background theory that admits quantifier elimination qe algorithm 6can propagatecandidates using def.
.
.
definition6.
.
givenatransitionrelation tr vars vars anda phasecandidate g vars l vars andanextphaseguard gnext thefwpropagate methodcomputes acandidate as follows qe vars.tr vars vars g vars l vars gnext vars thebwpropagate methodcomputes acandidate as follows qe vars .tr vars vars gnext vars g vars l vars example6.
.
fig.6gives aprogram with three phases and its inductive invariantisas follows.
inv x y z.x y x y mod3 x z x y mod3 x z x y mod3 x z forward reasoning begins with an analysis of the initial state x y 767976andx zdirectlyfollowfromtheinitialassignments to the variables.
while the former is a global invariant in contrast the latter needs the phase guard x y mod3 .
in order to propagate this candidate forward we note that under this phase x grows by one and zdoes not change thus if xwas equal to zthen x z giving usthe nextcandidate x z .
in practice propagated candidates are often too strong because theydescribeexactlywhathappensinthenextstepafterswitching toanewphase.inmanyothercases helperinvariantsneedtobe discovered prior to quantifier elimination otherwise the synthesis proceduredoesnothaveenoughinformationabout theswitching state.
this motivatesus to designalternative strategies forsynthesizingphaselemmasincertaintheories.
.
fast forwarding to data candidates numerictheoriesenjoywell knownapproacheslike todatadriven invariant generation.
gathering data for the early phases ofalgorithm7 fwpropagate p inv vars g gnext k data gatheringat arbitrary point.
input p vars vars init tr program inv invariant g phase guard gnext the next phase guard k unrolling bound output dm data matrixto be usedfor data learning 1unrl g vars inv vars gnext vars 2forc do 3unrl unrl tr vars c vars c 4letmbe s.t.
m unrl 5ifm then 6return 7forc do 8ifm gnext vars c then dm addrow dm m vars c 10candfromgaussjordan dm 11return anexecutionistrivialsincetheunrollingbeginsfromthe initstate recallsect.
.
.anaiveapproachwouldunrolltheprogramwhile thefirstphaseguardholds.theresultingmatrixwouldproducea candidate lemma for the phase however this is not scalable due to thetaxingnatureoflargeprogramunrollings.tosolvethisproblem we produce useful data in a more economical way with the notion of fast forwarding .
tostart atraceisproducedasinalgorithm line3 ofsome lengthk5.thenthesupportinglemmas6 aphaseguard andthe next phase guard are added line .
by providing a phase guard g vars in wearerequiringtheunrollingtobeginataparticular pointintheexecution.importantly wealsoprovide inv vars all lemmaslearnedsofar andthe phaselemmasassociatedwith g. g vars inv vars tr vars vars gnext vars tr vars vars ... tr vars k vars k an invariantfor the program inthe examplefromfig.
7requires asupportinglemmatodiscover andmustbeprovidedtothesolver beforeanunrollingbegins line 1ofalgorithm .otherwisethe invalidmatrix noguard orlemmas infig.8maybe produced.
if the solver is provided with the lemma x y line1 then it canproducevalidinformationtocreatetheothertwomatricesin fig.
oneforeachphase.eachrevealsaphaselemmathattogether withtheirphaseguardverifies the program.
theevenphase matrix has a basis vector of parenleftbig parenrightbigwhich yields the phase lemma x 2y.
applying the next guard xmod2 yields the phase lemma x 2y .
the algorithm then terminates withthe invariant inv x y.xmod2 x 2y xmod2 x 2y 4a fast backwarding conceptisdefinedsimilarlyandskippedintheinterestofspace.
5ourimplementationusesavalueof10for k.thisisdonetokeepunrollingssmallfor performancereasons.howevervaluesofupto30havebeentriedwithnoimprovement to the outcomes.
6supporting lemmas arethe previouslylearned lemmas from earlieriterations.
614multi phase invariant synthesis esec fse november14 18 singapore singapore x y inv x y inv x y x x y ite xmod2 y y inv x y inv x y x y false figure transition system with alternatingphases.
nogrd orlms x y 3even phase x y 3oddphase x y figure matrices produced foreachphase offig.
.
the importance of our fast forwarding technique lies in its abilitytosynthesizedifficulttoinferlemmas andassociatethem with their phase.
the expression x 2y 1is such an example sinceonitsownitisnoteasytodiscover andthentocoupleitwith thecorrectphaseguardisadifficulttask.fast forwardingtackles thosetwochallengeswiththedatalearningapproachconnectedto aparticularphase.
implementation we have implemented our algorithm called implcheck in the latest version of the freqhorn tool .freqhorn follows the sygus paradigm to guess and check for invariants derived from syntax and data.
we leverage this design to start the implcheck algorithm.thedecisiontreecontaining mbpsisbuiltintheearly stagesofan execution andonly onceinan execution.
candidatesthatfailtheinitialinductivenesscheck moveinto algorithm whereweidentifythephasethatthecandidatebelongs toinalgorithm .algorithm 6takesmbpsfromthedecisiontreeto test as phase guards described in sect.
.
if a guard is successfully found the guard and candidate are made into a phase invariant in the form ofimplication.
new candidates are also discovered by our data learning techniquefromsect.
.
.weusephaseguardsandlearnedlemmasto createanunrollingandthenobtainadatamatrixfromtheunrolling.
with fast forwarding weareabletoprobeaparticularphaseof the program and connect lemmas discovered by the data learner withthe phaseguardas anewphaseinvariant.
additionally weleveragethe candidatepropagation featureof freqhorn butmakeitmore phase aware recallsect.
.
which allowsfor lifting successfulcandidates to the nextphase.
evaluation we are interestedinansweringthe following researchquestions rq1 how effective is implcheck in solving multi phase benchmarkscomparedto state of the artchcsolvers?
rq2 howcrucialaredatalearningviafast forwardingandmbp strengthening to solving multi phase benchmarks?
rq3 howdoes implcheck performonalargesetofwellstudied benchmarks?throughout this section we discuss these questions in the context ofour experimental results.
the results are summarizedintab.
.
experimentalresults.
implcheck hasbeencomparedagainst chcsolvers freqhorn pcsat ic3ia gspacer spacer hoice eldarica andgolem andsygus solversloopinvgen andcvc5 .
since the input to all of these tools adheres to the smt lib2 format or the sister sygusformat wedonotcomparetoothersoftwareverificationtoolsthat wouldrequireadditionalsymbolicexecution encodingofprograms to symbolic constraints making the experimental comparison less fair.
rq1.
we analyzed the performance of implcheck on safe multi phasebenchmarkspreviouslystudiedby golem .these programs are over integers and have single loops with a variety of phasestructures.
with a minute timeout implcheck can solve of the thelargestnumberofallthetoolsinthecomparison.
freqhorn cansolve28.
eldarica performedthebestoutofthecomparison tools solving25ofthemulti phasebenchmarks.
eldarica sability to solve these likely comes from its use of disjunctive interpolation .gspacer solved hoice andgolemeach solved .
pcsatandic3iaeach solved respectively while cvc5and spacersolved and .
finally loopinvgen solved .
these results are displayedintable .
thereare10benchmarksthatareonlysolvedby implcheck and onesuchexamplefortheothertools whichisuniquelysolvedby golem.
these results show that implcheck is capable of verifying avarietyofphasestructures.
rq2.wecomparedtheperformanceof implcheck invarious configurations isolatingthesubsystemsofthealgorithmtohighlight their impact.
a summary of the results is in table which displays the lemma synthesis method the direction of propagation the number solved the averageandthe median time to solve.
the subsystems are described in sect.
.
in summary phasedatagenerates lemmas using the fast forwarding data learning technique phaseprop propagateslemmasacrossphases and strenmbpstrengthenstheguardsinthedt.
fwdpropagate andbwdpropagate determine thedirection oftraversalthroughthe program.bydefaultbothforwardandbackwardpropagationareenabled but we explicitly disableone to parse outtheir impact.
data learning with fast forwarding phasedata turns out to be themostimpactfulsubsystemonitsown.thisfeature withforward propagation solves benchmarks.
phaseprop with backward propagation solves a similar number of benchmarks as forward and proves to be a useful tactic for some cases with two examples solvedby bwdthat are not solvedwith fwd.
the combination of the three options phasedata phaseprop andstrenmbp along with fwdpropagate solves the highest number of benchmarks at .
there is a noticeable time cost across the tests however with the median solve time around two seconds instead of below one second.
phasedata is able to solve many more of the examples below one second than the three options togethercan.
it is worth noting that even the worst configuration of implcheck phasedata bwd still outperforms all of the tools used for comparison.
615esec fse november14 18 singapore singapore daniel riley andgrigory fedyukovich table timingsinseconds standsforaruntime less than asecond standsfornotsolved .
benchmark implcheck freqhorn gspacer spacer ic3ia loopinvgen eldarica cvc5 hoice pcsat golem s split 01 .
.
s split 02 .
62. .
s split 03 .
.
.
14. s split 04 .
.
.
.
s split 05 .
1. s split 06 .
.
.
s split 07 .
.
1. s split 08 .
.
.
s split 09 .
s split 10 .
s split 11 .
s split 12 .
.
s split 13 .
1. s split 14 .
.
s split 15 .
s split 16 .
s split 17 .
.
.
.
.
s split 18 .
31. s split 19 .
s split 20 s split 21 .
.
.
s split 22 .
.
s split 23 .
.
.
s split 24 .
s split 25 .
s split 26 .
.
.
s split 27 .
s split 28 .
.
.
.
.
.
s split 29 .
.
.
s split 30 .
s split 31 .
.
.
s split 32 s split 33 .
s split 34 .
126. .
.
.
.
.
s split 35 .
s split 36 .
.
s split 37 .
.
.
s split 38 .
.
.
1. s split 39 .
.
.
.
.
1. s split 40 .
.
s split 41 .
s split 42 .
.
1. s split 43 .
.
s split 44 .
.
s split 45 s split 46 .
.
.
33. s split 47 .
s split 48 s split 49 s split 50 .
s split 51 .
.
s split 52 .
s split 53 .
s split 54 .
total solved uniquely solved avgtime solved .
.
.
.
.
.
.
.
.
.
.
median time solved .
48. .
.
.
1. table summary of implcheck subsystems.
benchmark phasedata bwdpropagate phasedata fwdpropagate phaseprop bwdpropagate phaseprop fwdpropagate phasedata strenmbp bwdpropagate phasedata strenmbp fwdpropagate phaseprop strenmbp bwdpropagate phaseprop strenmbp fwdpropagate phasedata phaseprop bwdpropagate phasedata phaseprop fwdpropagate phasedata phaseprop strenmbp bwdpropagate phasedata phaseprop strenmbp fwdpropagate totalsolved avgtime solved .
.
.
.
.
.
.
.
.
.
.
.
median time solved .
.
.
.
.
.
.
.
616multi phase invariant synthesis esec fse november14 18 singapore singapore table summary ofresults overgeneralbenchmarks.
benchmark implcheck freqhorn eldarica gspacer golem ic3ia total solved avgtime solved .
.
.
.
.
.
median time solved .
.
.
rq3.wecomparedtheperformanceof implcheck onasetof 277wellstudiedbenchmarkstakenfrompreviousliterature 16 .thissetofbenchmarkscoversbothsingleloopandmultiloop programs with the multi loop programs having either nested loopsorconsecutive loops.
whatweaimtoshowisthattheoverheadfrom implcheck is notprohibitivelylargeonmoregeneralcases.theresultsintable show that implcheck is abletoverifymore benchmarksthanthe other tools and the average overhead for examples solved by both implcheck andfreqhorn isonly4.5seconds.
implcheck solves 244ofthe277and freqhorn solves237.thisresultisencouraging because it shows that implcheck is not pinned to solving one programtype ie.multi phase andaddsonlyasmalloverheadto theseexamples.
threats to validity ourapproachhasbeenbuiltundertheconsiderationofliaandthe assumptionthattheunderlyingtheoryadmitsquantifiereliminationformbpgeneration.toextendthisapproachtoothernumeric theorieswewouldneedtoconsiderhowtogenerate mbpssince theyarecrucialtoourphasefindingalgorithm.forbooleanprograms sinceourfast forwardalgorithmreliesondatalearningwith integers we could instead rely on a qe approach to solve those problems.
implcheck isachcsolverandtakestheoutputofaverification front end like seahorn .
we rely on the correctness of the translationfromthesourcecodefortheinputtoouralgorithm.ifthe translationresultsinmulti phaseloops webelieveouralgorithm wouldhave successverifying thosecases.
our analysis of program phases and the construction of our dtp in a worst case scenario could be exponentially expensive.
however inpracticethisanalysisiscompletedinlessthanasecond forbothmulti phaseexamplesandthebenchmarksinthelargeset including mbpstrengthening.
related work inductiveinvariantsynthesis.
there are many automatedsoftware verification approaches that discover proofs in the form of an inductiveinvariant .
there are many barriers to this problem mainly due to its undecidability requiring us to continue to look into this problem and consistentlyenlargetheapplicabilityofthetools.whilemanymethods have been successfully used for invariant synthesis the vast majority donot reliably solve the caseofmulti phasedloops.
sygus isalsousedforgeneratingsafeinductiveinvariants with the help of either a user provided grammar or an automaticallygeneratedone .thereareseveralpositivestothis approach and implcheck takesadvantageofenumerationearlyin theexecutiontofindaninitialsetofcandidates.providingadetailed fine grain grammar could in theory allow for the verification of multi phase programs with previous sygusapproaches.
however the grammar would need to include details about the construction ofimplicationsandthe needfor supportinglemmas.
multi phase loops.
verification of loops with phases requires disjunctiveinvariants andhasbeenthesubjectofseveralworks .
the studies to synthesize disjunctive invariants appears inseveralfields suggestingthisisanimportantproblemtosolve.
workonthisproblemhaseitherreliedonexplicitlysplittingaloop ofconsecutivephases neededauser providedgrammarand interaction orusedabstractiontechniqueswhich naturally include disjunctions .
other work on disjunctive invariant synthesiswereapproachedbyabstractinterpretation gr bner basis computation andsygus .
an approach to loop summarization reasonsaboutprogramphasesusing lazy qe but does not connectthemwithsupportinginvariants.
noneoftheseofferashighadegreeofflexibilityasourapproach our fast forwarding technique is effective in finding non trivial invariantsthatarehardfortechniquesworkinginrigiddomains andtheymayrequiresupportinginvariantstocompleteverification.
ourapproachisalsoagnostictothesyntacticloopstructureofa programandaimsat recovering itfromthesymbolicencoding that e.g.
could flatten nestedloops .
data driven approaches.
previous work such as use data derived from a given program to aid the inference of candidate invariants.
at the core of these approaches is a guessand check structure wherethe guessphaseusesdatacollectedfrom program traces and the checkphase gathers data from counterexamples.
invariants in the form of both inequality and equality can be synthesized from traces using techniques from .
machine learning techniques for verification also use counterexample derived data.
it is our extension of the data driven approach withour fast forwardingtechniquetoproduce aprogram traceatanarbitrarypointinaprogramsexecution typicallyaround the pointsofaphasechange that setsour work apart.
conclusion wehavepresentedanovelapproachtosynthesizesafeinductive invariants by implicit splitting of program phases and we have augmented the freqhorn algorithm to use our new technique calledimplcheck .our approachusesmodel basedprojectionsto discoverphaseguards storedinadecisiontree anditusesadata learning technique to discover phase lemmas.
key pieces of this approach are the ability to accurately fast forward an unrolling to generate meaningfuldata and generatethese two ingredients.
we have demonstratedthe usefulness of our approach by successfully solving anumber ofchallenging verification tasks.
motivation for future improvements to our approach include investigatingthebenchmarkssolvedbyothertoolsbutnot implcheckand improving the efficiencyof our algorithm.
support for arraysandalgebraicdatatypesisalsoagoalforfuturedevelopment.
artifact available.
a virtual machine isavailable to reproduce the reportedresults .