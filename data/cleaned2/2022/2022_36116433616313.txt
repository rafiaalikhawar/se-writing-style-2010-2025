crystallizer a hybridpath analysis frameworktoaidin uncovering deserializationvulnerabilities prashast srivastava purdueuniversity unitedstatesflaviotoffalini epfl switzerlandkostyantynvorobyov oraclelabs australia fran oisgauthier oraclelabs australiaantoniobianchi purdueuniversity unitedstatesmathiaspayer epfl switzerland abstract applications use serialization and deserialization to exchange data.
serializationallowsdeveloperstoexchangemessagesorperform remotemethodinvocationindistributedapplications.however the application logic itself is responsible for security.
adversaries may abuse bugs inthe deserializationlogicto forciblyinvoke attackercontrolledmethods bycraftingmalicious bytestreams payloads .
crystallizer presentsanovelhybridframeworktoautomaticallyuncoverdeserializationvulnerabilitiesbycombiningstaticand dynamic analyses.
our intuition is to first over approximate possible payloads through static analysis to constrain the search space .
then we use dynamic analysis to instantiate concrete payloads as aproof of conceptofavulnerability givingtheanalystconcrete examplesofpossibleattacks .ourproof of conceptfocusesonjava deserialization as the imminent domain ofsuch attacks.
weevaluateourprototypeonsevenpopularjavalibrariesagainst state of the artframeworksforuncoveringgadgetchains.incontrast to existing tools we uncovered previously unknown exploitable chains.
furthermore we show the real world security impact of crystallizer by using it to synthesize gadget chains to mountrceanddosattacksonthreepopularjavaapplications.we have responsibly disclosedallnewlydiscoveredvulnerabilities.
ccsconcepts security andprivacy software andapplication security .
keywords deserialization vulnerabiltiies java hybridanalysis acm reference format prashastsrivastava flaviotoffalini kostyantynvorobyov fran oisgauthier antoniobianchi andmathiaspayer.
.
crystallizer ahybrid path analysis framework to aid in uncovering deserialization vulnerabilities.
in proceedings of the 31st acm joint european software engineering conferenceandsymposium on the foundations of softwareengineering esec fse december3 sanfrancisco ca usa.
acm newyork ny usa 12pages.
esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
introduction serialization is a key feature in modern languages e.g.
java c or php that enables cross platformcommunication remotemethod invocations and object persistence.
serialization converts object graphsintobytestreams.symmetricallytoserialization deserialization rebuilds the original object graph from the bytestream.
by default deserialization ensures that the deserialized objects are valid but it does not enforce security constraints.
security both during and after deserialization is the sole responsibility of the application logic.
incomplete security checks allow attackers to bendthecontrol flow data flowofaprogram.theseattackscanhijack the deserialization process granting the attacker remote code execution rce denialofservice dos orinformationpersistence capabilities such as arbitrary file writes afw .
deserialization vulnerabilitieshave showncatastrophic security impact .e.g.
the equifax data breach was caused by a deserialization vulnerability enabling rce in the .
more recently the log4shell vulnerability in the widely used log4j2library can be exploited in newer versions of the jdk that were previously thought safe by leveragingdeserialization basedattackvectors .
payloadsfordeserializationattacksarecomposedofnestedobjects that when deserialized force the application to invoke an attacker controlledsequenceofmethods alsocalleda gadgetchain.
the last gadget of the chain is usually called sinkand may invoke system functions e.g.
runtime.exec with attacker specified arguments allowing the attacker to execute arbitrary system commands.
the gadgets in the deserialization domain are conceptually similar to gadgets in return oriented programming rop for binary exploitation small pieces of code in the vulnerable programthatarestitchedtogetherbyanattacker.however deserializationgadgetsdonotoperateatthemachinecodelevel instead they bend the serialization logic to express malicious actions.
attackchainsheavilydependontheapplicationlogic.therefore finding such gadget combinations that bypass the application logic iscrucialtofixvulnerabilities.asofnow discoveringdeserialization vulnerabilities is predominantly manual and requires solving three main challenges c1.
sink gadgets identification new sink gadgets that are usefultotheattackerarecurrentlyidentifiedthroughheuristics e.g.
marking calls to runtime.exec .
however we observe this approachoverlooksnon trivialsinksandinhibitsdiscoveringother interesting types ofattacks e.g.
dos .
thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa prashastsrivastava flavio toffalini kostyantynvorobyov fran ois gauthier antonio bianchi andmathiaspayer c2.
large state space the search space for gadget chains in current applications is massive with thousands of gadget combinations.thismakesfindingagadgetchainthatcanbeusedtomount adeserializationattackisakinto findinganeedleinahaystack.
c3.complexpayloadcreation deserializationpayloadsrequire careful instantiation of classes and arguments that obey the executionconstraintsofthegadgetchain.consequently validbytestream creation becomes exceedingly complex due to the large number of possible combinationsthat nestedobjectscan assume.
to overcome the aforementioned challenges we design crystallizer a hybrid framework that combines static and dynamic analysistosynthesizeconcretepayloadsforgadgetchainsandfind deserialization vulnerabilities automatically.
first our framework identifies new sink gadgets in an application.
then it uses static analysis to construct a gadget graph a data structure that encodes all possible gadget chains within a target software up to a certain length .
this greatly reduces the explorable state space for gadget chains.crystallizer creates payloads as bytestreams out of the reduced state space dynamically.
ourframework synthesizes payloadsinachain awaremanner itkeepstrackoftheexecutionchain orderandperformsabest effortapproachtocreatewell formedargumentsforeachofthegadgetswhileobeyinglanguagesemantics.
we implement our proof of concept tool for java as it is widely adoptedas the backbone for software development .
we evaluate crystallizer on seven librariesand three applications.
across theseven libraries it finds new chains in addition tosevenpreviouslyknowngadgetchains .thisdemonstrates crystallizer s ability to find both existing and new gadget chains automatically.furthermore wecompare crystallizer againsttwo state of the art tools for finding java based deserialization vulnerabilities and showcase that crystallizer drastically outperforms existing state of the art in terms of finding exploitable gadget chains.
finally we showcase the real world security impact ofcrystallizer bysynthesizingpayloadsthatweusetodemonstratedosandrceattacksonthreepopularjavaapplications.the correspondingproof of conceptexploitswereresponsiblydisclosed.
in summary this paper makesthe following contributions we perform a systematic analysis of how deserialization vulnerabilities manifest themselves in the form of gadget chains including challenges to uncover them automatically.
we present crystallizer a hybrid framework to automatically uncover deserialization vulnerabilities by crafting payloads that exercise gadgetchains inthe target.
weevaluateitagainstsevenlibrariesandfind41newchains inadditionto seven previously knownchains.
crystallizer outperforms state of the art tools for finding java baseddeserializationvulnerabilitiesanddemonstrate real world security impact by using it to mount dos and rceattacksonthree popular real world applications.
all our evaluation artifacts along with the source code of our framework are made available at hexhive crystallizer .
deserialization attacks wediscussthebasicsofjavaserialization.then weestablishterminologyrelevanttodeserializationattacksandshowcaseanexampleattack on a popular java based library apache commons collections .
finally we discuss domain specific challenges.
.
serializationanddeserialization serializationistheactionoftransformingobjectsintoabytestream.
deserialization later rebuildsthe objectsfrom the received stream.
serialization for java employs the serializable interface .
serialized objects of classes that implement this interface can be createdusingthe writeobject methodprovidedbythejdk .
the method encodes the object s fields into a bytestream to e.g.
senditacrossthenetworkorstoreitintoafile.ontheotherend the method readobject deserializes the byte stream and rebuilds the original object automatically.
note that the deserialized object sclassmustbeinthe classpath otherwisedeserialization fails.
javaallows specifyingcustomserializationanddeserializationroutinestoinstructthereceiverapplicationaboutcustom dataprocessing i.e.
post processingdatawhilefillinganobject s fields.asthese mechanismsallow greatflexibility theyalsoleave alarge exploitableattacksurface.
.
payload formalization letusestablishterminologyrelevanttodeserializationattacks.a gadgetisanyinvokedmethodduringdeserialization.itformsthe basic building block for an attack.
a gadget chain corresponds to a sequenceofmethodinvocationstriggeredupondeserializationof apayload.payloadrefers to a bytestream corresponding to a set of serializednestedobjects.apayloadthatexploitsadeserialization vulnerability forces the application to call an attacker specified gadgetchainwhichcanbeusedtomountanattack e.g.
rce.in general a deserialization attack is possible because the deserialization process automatically rebuilds the received object from the attacker specified bytestream and in so potentially enables attacker specifiedcode to be executed.
gadgetsfallintothreecategories i triggergadgets are thefirstelementsinvokedduringdeserializationandserveasthe attack s entry points.
in java such gadgets are usually classes that overridespecificmagicmethods e.g.
readobject .customdeserializationroutinesoperateondatathatmaybeattacker controlled allowingthetriggergadgetstokickstartachain ii linkgadgets orchestrate the flow of attacker controlled data from a trigger to a sinkgadget and iii sinkgadgets launchtheattackbyrunning attacker specifiedmalicious actions.
ourgadget graph represents an over approximation of all the possiblegadgets chains in a program.
hence a payload exercises onlyaspecificpathinthegraphbetweenthetriggergadgetandthe sinkgadget.sincegadgetsarethemethodsexecutedthroughthe standarddeserializationprocess wemodelthegadgetgraphasa subcomponentoftheapplicationcallgraphwhosenodesaremarked as gadgets trigger link or sink .
.1describes our approach to extracting the gadgetgraph.
.
payload example we present a known deserialization attack on apache commons collections libraryexplaining i executionflowofagadgetchain vulnerable to a deserialization attack and ii the creation of a payloadthat exercises this vulnerable chain.
1587crystallizer a hybrid path analysis framework to aid in uncoveringdeserialization vulnerabilities esec fse december3 san francisco ca usa badattributevalueexpexception void readobject objectinputstream ois trigger gadget object valobj ois.readfield val valobj.tostring valobj instance of tiedmapentry tiedmapentry string tostring link gadget this.getvalue object getvalue link gadget this.map instance of lazymap this.key instance of string foo this.map.get this.key lazymap object get object key sink gadget the transformer triggers a command object val this.factory.transform this.key an application invokes .readobject to deserialize the byte stream ois badattributevalueexpexception.readobject ois figure1 asimplifiedexampleforthegadgetchainexecuted upon thepayload listing being deserialized.
figure 1shows the vulnerable gadget chain.
the readobject method of the badattributevalueexpexception class is executed first making it the trigger gadget.
this gadget rebuilds the object instance of badattributevalueexpexception from the bytestream and invokes a tostring method on one of its fieldmembers val .
the object valobjis an instanceoftheclass tiedmapentry thenitstostring methodiscalled whichin turncallsits getvalue method.the getvalue methodretries akeyfromamap .ifthemapisaninstanceof lazymap itwill trytobuildanitemcorrespondingtothekeyparameter foo by using a transformer class whose object can be instantiated in such a way that the item building performs rce .
since executing the gadget get method inside the lazymap can lead to rce we categorize it as a sink gadget.
the gadgets belonging totiedmapentry are referred to as link gadgets since they chain the invocation from the trigger gadgetto the sink gadget.
thegadgetchainhighlightstwokeyobservations i thegadget chain is a subgraph of the application callgraph and ii exercising this gadget chain requires a bytestream that is crafted from a set of nestedobjectsinsuchawaythattheabovegadgetchainisinvoked.
thepayloadthatexercisestheabove mentionedgadgetchain to achieve rce is shown in listing .
the first step is to instantiate atransformer that executes exec bin bash line8 .
the transformer isthenusedtoinstantiatea lazymap object line .
thelazymapautomatically instantiates any missing entry using thetransformer class instance thus invoking exec .
we then usethelazymap tobuilda tiedmapentry line14 andbindittoa badattributevalueexpexception instance line .specifically this class overrides the readobject method and acts as our trigger gadget.
valis the final payload which is serialized line to abytestream ready to be sentto avulnerable application.
command to execute 2finalstring execargs bin bash preparing object for transformer which is used inside the sink gadget to grant rce to an attacker 6finaltransformer transformers newtransformer newinvokertransformer exec newclass string.class execargs ... 10finalmap innermap newhashmap preparing object for lazymap which acts as the sink gadget 12finalmap lazymap newlazymap innermap transformers prepraring object corresponding to a link gadget 14tiedmapentry entry newtiedmapentry lazymap foo preparing object corresponding to the trigger gadget 17badattributevalueexpexception val newbadattributevalueexpexception val 19objectoutputstream os newobjectoutputstream new fileoutputstream payload.bin writing the object into serialized bytestream payload 21os.writeobject val listing1 simplifiedjavacodecreatingthepayloadtargeting apache commons collection .figure describes the observed controlflow execution upon deserializing thispayload.
.
challenges recallingtheexamplein listing1 weidentifythreemainchallenges forautomatingchaincreation sinkgadgetidentification largestate space andcomplex payloadgeneration.
c1sink gadgetsidentification.
whiletrigger gadgetsare easy to locate i.e.
they are overrides of known magic methods such as readobject linkgadgetsaregenericnodesinagadgetgraph.
identifying sink gadgets requires non trivial code knowledge.
previous works use heuristics to locate the usage of specific functions e.g.
runtime.exec .
however we observe that they overlookalargegroupofalternatesinks.therefore weadoptabroader definition agadgetisconsideredasinkifitmayoperateonobjects ofanytype.
we identify such gadgets by checking if they may use objectsoftype object .
sinceobjectcorrespondsto the root of the class object hierarchy a gadget operatingon this type can operate on objects of any class.
we chose this definition because i itmayresultinahigherchanceofmanipulatingthegadgetto perform attacker specified functionality and ii it allows crystallizertotargetandfindawidespectrumofthreats e.g.
logic based dos chains that were missedbyprevious works.
c2 large state space.
to estimate the explorable state space of gadgetchains weconductapreliminaryanalysisin apachecommons collections .
first we extract a callgraph through soot and then build a gadget graph on top of it see .
.
the callgraph consistsof 009gadgetsand 579edges.ouranalysisreduces thislargespaceto 295gadgetsand 168edgesinourgadgetgraph.
even within agadgetgraph the number ofcandidate chains to be explored is still large thus necessitating automated exploration.
wequantifiedcandidategadgetchainsinthisgadgetgraphfrom trigger to sink gadgets using a djikstra like algorithm .
to keeptheanalysis concise we upper boundthe maximum length of discovered candidate chains.
for a maximum path length of there are 866candidate chains to be explored.
c3 complex payload generation.
payloads are composed of well formed objects that obey the execution constraints of the gadgetchain.in listing1 alazymapobjectrequiresinstancesof map 1588esec fse december3 san francisco ca usa prashastsrivastava flavio toffalini kostyantynvorobyov fran ois gauthier antonio bianchi andmathiaspayer andtransformer to be passed to its constructor line .
moreover weneedtoobeythelanguagesemanticsandpassobjectsas arguments that implement the respective mapandtransformer interfaces.
next as we create the object for the predecessor gadget tiedmap we must ensure that the previously created object for lazymapis correctly passed as an argument.
therefore building concretepayloadsthatexercisegadgetchainsischallengingbecause it requires i inference of correct parameters and ii instantiation ofvalid connections between objects.
3crystallizer design crystallizer isahybridpathanalysisframeworktoautomatically uncover deserialization vulnerabilities by finding gadget chains intargets.givenagadgetgraph ourintuitionistoautomatically identify the sink gadgets and then find possible paths leading to sinks that can be instantiatedas asetofconnectedobjects .
.
crystallizer produces payloads as long as there exists a sequenceofgadgetsthatreachasink.
crystallizer takesinformation about trigger gadgets and a target as input then it outputs concrete payloads that execute the gadget chain demonstrating potentiallyexploitablegadgetchains.developerscanusethisinformationtopatchdeserializationbugs attackerscanuseadjustthe parameters to fine tune the execution of the chain.
figure 2shows an overview of crystallizer s three components static analysis module 1infigure sink identification 2infigure and the probabilisticconcretizationphase 3infigure .
.
static analysis module this module takes a library and information about trigger gadgets asinputandproducesagadgetgraph.theinformationprovided abouttriggergadgetsisintheformofmethodsinvokedbyatrigger gadget.crystallizer usesthis information to automatically infer which methods in a library can be used as entry points.
looking at our example in .
alltostring methods present in the target libraryaretreatedasentrypointsintothetargetlibrary.leveraging thisabstractedviewofthetriggergadgetsisinlinewithpriorworks for automateddiscovery ofdeserializationattacks .
we buildthegadgetgraph infoursteps.
i we extractanoverapproximatedcallgraphusingclasshierarchyanalysis cha from the target software using the entry points described above ii in the callgraph we select all classes that implement the serializable interface directly or through one of their ancestors .
andmarkalltheirmethodsasgadgets iii weusethetrigger gadgetinformationtomarktheentrypointsinthegadgetgraph accordingly whilewemarkalltheothernodesaslinkgadgets and iv finally we discard all nodes that are unreachable from trigger gadgets.thegadgetgraphproducedbythismodulehasonlythe entrypointsand linkgadgetsmarked whilewemark thesinksin this gadgetgraph withthe helpofthe sinkidentificationmodule.
.
sinkidentification startingfromthe staticanalysismodule sgadgetgraph we infer which gadgets can be used as sinks.
here we describe the sink definition in .
gadgets that use arbitrary class objects.
our module enablescrystallizer to identify sinks for rce dos or afw.
we finally markthe sink gadgetsinthe gadgetgraph accordingly.toinfersinkgadgets crystallizer performsatwo stepprocess.
first itdynamicallyinferscandidategadgetsthatmayusearbitrary objects.
second a set of static filters validates if the candidate gadgets use arbitrary objects.
the candidate gadgets not filtered out areflaggedassinkgadgets.thedynamicinferencegivesinitialevidence of whether a gadget may perform malicious actions and the staticinference incorporatesaccess patterns to increaseprecision.
dynamicinference .crystallizer flagsgadgetsthatmayuse an arbitrary object either as one of its declaring classes fields or as a method parameter passed to the gadget itself.
it performs this dynamic inference with the help of a honeypot class a serializable classthatraisesanexceptionwheninstantiated.
crystallizer randomly picks one of the reachable gadgets from the gadget graph and flags it as a candidate for static filtering if it can instantiate an object of the honeypot class into i one of the field members of thedeclaring class or ii one ofthe method parameterscan be instantiated with the honeypot class.
crystallizer flags a candidate gadget ifone ofthe previoustwo conditionsis fulfilled.
crystallizeralso logs the argument type through which the honeypot class was instantiated referred to as the taintedargument type .
thisinformationisusedduringthestaticfilteringphaseformaking crystallizer more precise inidentifying sink gadgets.
staticfiltering .theflaggedcandidatesmustpassasetofstatic filters.thesestaticfiltersarenecessarytoweedoutgadgetsthatdo not usetaintedarguments.
the filters are based on the characteristicsofknownsinks.weusetheargumenttypeinsteadoftheactual argumentthroughwhichthehoneypotclasswasinstantiatedfor filteringsincetherecanexistmultiplearguments fieldmembersor method parameters of the same type.
if a candidate gadget passes throughanyofthestaticfiltersthenitisflaggedasasinkgadget.
incaseafieldmemberwasusedtoloadinthehoneypotclass we applyasetofthreefilters i weflaggadgetsthatdirectlyrefertoa field having the same type as the tainted argument.
ii we extend thepreviousanalysistoallreachablemethodsusingafieldwiththe sametaintedargumenttype.
iii wealsoflaggadgetsthatindirectly usethetaintedargument.weidentifyindirectusagebycheckingif thetaintedargumentiscasttoanothertypeintheclassconstructor and then see usage for this new type in the gadget.
however in casetheargumentisloadedinthroughamethodparameterthen we flag the gadget if any of the method parameters corresponding to the taintedargument were usedinamethodinvocation.
.
probabilisticconcretization leveraging the gadget graph we propose a probabilistic method to generatepayloadsthattriggerdeserializationvulnerabilities.we achieve this goal by using three modules.
first we use a candidatechainextractormoduletofindagadgetchainthatconnects a trigger and a sink.
second we feed the candidate chains to a dynamic analysis module which attempts to create a payload for the corresponding chains.
finally we submit the payload to the deserializationprobingmodulethatdeserializesthepayloadand returnsfeedbacktothedynamicanalysismodule.thefeedback canbeadjustedaccordingtothethreatmodelandrecognizechains exhibiting the intended behavior.
specifically we show how adopting different heuristics enables us to identify rce afw or dos 1589crystallizer a hybrid path analysis framework to aid in uncoveringdeserialization vulnerabilities esec fse december3 san francisco ca usa static analysis module payload feedbackdeserialization vulnerability probabilistic concretizationdeserialization probingdynamic analysis modulecandidate chains extractionlibrarytrigger gadgets gadget graph gadget graph legend trigger sink linksink identification gadget graph figure architectural overview of crystallizer .
chains.crystallizer adopts a dynamic approach to concretization to ensure that it only reports chains for which it can create payloads that exercise them.
this is in stark contrast to purely static approaches that are plagued with falsepositives i.e.
reporting chains that cannot really be exercised due to not taking into considerationtheexecutionconstraintsofthechainorthelanguage semantics discussedin .
candidate chain extractor .this module uses a djikstra like algorithm to identifycandidategadgetchains that mappaths from entry points to sink gadgets.
we further define a threshold to upper boundthelengthofcandidatechains.withoutthisthreshold thestatespaceofcandidategadgetchainswouldbecomeintractable foranexhaustiveexploration.inourexperiments wesetathreshold ofuptofivegadgetsasinspiredbyknownexploitablegadgetchains.
dynamicanalysismodule .agadgetchainisfullyconcretized if there exists an input payload that exercises the gadget chain whenpassedtoadeserializationentrypoint.toconcretizeagadget chain weinstantiateobjectsforeachofthegadgetsinthechain.the objectsmustprovidetwoprerequisites language specific inour casejava createwell formedfor declaringclassesofthegadgets and chain specific instantiate the objects in such a way that the executionflowssuccessfully from one gadgetto another.
basedontheinsightdescribedabove wepresentourconcretization methodology for gadget chains in algorithm .
the procedure takes as input a candidate gadget chain and outputs a payload that can be tested by the deserialization probing module.
the concretizationprocessinstantiatesthenodesinreverseorder i.e.
from sink to target line .
we adopt this strategy to fulfill the chainspecific prerequisite described previously.
furthermore this allows the algorithm to terminateearly if noobjectscan be instantiated.
to satisfy chain specific prerequisites crystallizer uses an objectcache tostorepreviouslyinstantiatedobjects.whenanodeis passedtothe objectfactory forinstantiation line itchecksif the object cache contains an object of the same type or can be cast into therequestednode.iftheseconditionsaremet wedistinguish twocases.
i theobjecthasthesametypeastherequestednode.
thus we reuse it as is line .
ii the object can be cast into therequestednodetype.thus werandomlycreateanewobject or return the existing one from the cache line .
we perform thisactionrandomlyinsteadofinaguidedmannersincereasoningaboutthesemanticsismoreexpensivethanjustexercisingall possiblecombinations.iftheobjectcachedoesnotcontainsuitable objects then we instantiate a new node line by satisfyingalgorithm1 dynamicanalysismodule input candidate gadgetchain g output payloadfor concretized gadget chain p procedure concretizechain u1d43a u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d436 u1d44e u1d450h u1d452 u1d45f u1d452 u1d463 u1d43c u1d461 u1d452 u1d45f u1d44e u1d461 u1d45c u1d45f u1d43a.
u1d45b u1d45c u1d451 u1d452 u1d460.
u1d45f u1d452 u1d463 u1d43c u1d461 u1d452 u1d45f u1d44e u1d461 u1d45c u1d45f while u1d45f u1d452 u1d463 u1d43c u1d461 u1d452 u1d45f u1d44e u1d461 u1d45c u1d45f.h u1d44e u1d460 u1d443 u1d45f u1d452 u1d463 u1d456 u1d45c u1d462 u1d460 do u1d45b u1d45c u1d451 u1d452 u1d45f u1d452 u1d463 u1d43c u1d461 u1d452 u1d45f u1d44e u1d461 u1d45c u1d45f.
u1d45d u1d45f u1d452 u1d463 u1d456 u1d45c u1d462 u1d460 u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d442 u1d44f u1d457 u1d452 u1d450 u1d461 u1d439 u1d44e u1d450 u1d461 u1d45c u1d45f u1d466.alt u1d45b u1d45c u1d451 u1d452 u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d436 u1d44e u1d450h u1d452 u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d436 u1d44e u1d450h u1d452.
u1d45d u1d462 u1d461 u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 end while return u1d443 u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d436 u1d44e u1d450h u1d452.
u1d454 u1d452 u1d461 u1d447 u1d45c u1d45d u1d441 u1d45c u1d451 u1d452 end procedure procedure objectfactory u1d45b u1d45c u1d451 u1d452 u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d436 u1d44e u1d450h u1d452 u1d450 u1d459 u1d460 u1d45b u1d45c u1d451 u1d452.
u1d454 u1d452 u1d461 u1d437 u1d452 u1d450 u1d459 u1d44e u1d45f u1d456 u1d45b u1d454 u1d436 u1d459 u1d44e u1d460 u1d460 if u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d436 u1d44e u1d450h u1d452.
u1d456 u1d460 u1d443 u1d45f u1d452 u1d43c u1d45b u1d460 u1d461 u1d44e u1d45b u1d461 u1d456 u1d44e u1d461 u1d452 u1d451 u1d45b u1d45c u1d451 u1d452 then if u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d436 u1d44e u1d450h u1d452.h u1d44e u1d460 u1d438 u1d465 u1d44e u1d450 u1d461 u1d447 u1d466.alt u1d45d u1d452 u1d45b u1d45c u1d451 u1d452 then u1d45a u1d462 u1d460 u1d461 u1d445 u1d452 u1d461 u1d462 u1d45f u1d45b u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d436 u1d44e u1d450h u1d452 u1d45b u1d45c u1d451 u1d452 else u1d45a u1d44e u1d466.alt u1d445 u1d452 u1d461 u1d462 u1d45f u1d45b u1d45c u1d44f u1d457 u1d452 u1d450 u1d461 u1d436 u1d44e u1d450h u1d452 u1d45b u1d45c u1d451 u1d452 end if end if u1d450 u1d459 u1d460 u1d442 u1d44f u1d457 u1d450 u1d459 u1d460.
u1d45d u1d456 u1d450 u1d458 u1d436 u1d45c u1d45b u1d460 u1d461 u1d45f u1d462 u1d450 u1d461 u1d45c u1d45f .
u1d456 u1d45b u1d460 u1d461 u1d44e u1d45b u1d461 u1d456 u1d44e u1d461 u1d452 return u1d450 u1d459 u1d460 u1d442 u1d44f u1d457 end procedure the language specific prerequisites.
for primitive data types we use a pre defined finite set created from commonly used values in knownvulnerabilitiessourcedfromysoserial .foruser defined data types we instantiate using a randomly chosen constructor synthesizing the requiredparametersrecursivelyif necessary.
deserializationprobing .onceapayloadissuccessfullyinstantiated we submit it to the deserialization probing to test if the payload expresses the intended behavior i.e.
rce afw or dos.
we use different feedback according to the attack we detect.
for rce and afw crystallizer reports a payload if it can execute eachgadgetinthechainfromthetriggertothesink.totrackgadget chain execution we use method level coverage feedback.
however totransformthechaininaconcreteexploit humanassistanceis neededtofine tunetheconcretizedpayload discussedin .
.for thedoschains instead weareinterestedinpayloadsthatkeepthe cpubusyforalongtime therefore weconsiderthedeserialization execution time as feedback.
specifically we consider possible dos chainsthatrequiretimemorethanagiventhresholdtobeexecuted 5s inour experiments .
in contrast to rce afw payloads no human intervention is needed since the synthesized payload by itself exhibitsthe intendedbehavior.
we onpurpose usethesamesinkgadgetsforrce afwand dos chains.
our intuition is that a sink operating on arbitrary classescanbeeasilytunedtoexpressdifferentattacksbycombining heuristics anddifferentfeedback.
1590esec fse december3 san francisco ca usa prashastsrivastava flavio toffalini kostyantynvorobyov fran ois gauthier antonio bianchi andmathiaspayer implementation here we describe the static analyzer dazzer our probabilistic concretizationtoolbuiltontopofjazzer andthemethod level instrumentation.
static analyzer.
we develop ourstatic analyzer on topof soot version4.
.
.
soot is the standard tool for analyzing java bytecodeandprovidesbuilt inanalysisforcallgraphandclasshierarchy .
our analyzerconsists of .1kjava loc.
dazzer.to assist the object creation we develop dazzer.
our tool aids the payload synthesis in dynamic analysis module .
andtheidentificationofsinkgadgetsinsinkidentification .
.
dazzerextendsjazzer whichisoriginallydesignedtofuzzmethods inisolationbycreatingconcreteargumentsforthem.incontrast dazzerisdesignedtoperformeffectivegadgetchainconcretization whichrequiresadoptinguniqueandgeneralizedstrategiesforobjectcreation.wedevisethethreestrategiesbasedonouranalysis of numerous previously known deserialization based vulnerabilities and deriving commonalities in terms of how they manifest themselves.first wemaketheobjectcreationchainawarebyintroducing the concept of a probabilistic object cache.
second in additionto regularinstantiation dazzer employs reflection based strategiestoforceobjectcreationifnopublicconstructorsareavailable whichweemployduringpayloadcreationofagadgetchain.
finally weimprovethecapabilitiesoftheobjectcreationmodule tohandlethegenerationof genericobjects oftype object .
jazzer only returns null objects when requested objects of type object.
in contrast dazzer not only returns commonly used objects in chain executions such as strings and hashmaps but more importantly extends it to use the object cache which was instrumental inhelping crystallizer toconcretizegadgetchains.overall we added2kjava locontop ofthe originaljazzer.
method levelfeedback.
crystallizer createsaninstrumented version of the target library by adding method level coverage feedbackatthebytecodelevel.weusesoottoinsertinstrumentation atthestartofeachmethodtologitsexecution.weusethisfeedbackduringprobabilisticconcretizationforidentifyingconcretized gadget chains .
.
the method level feedback and deserialization tracing support were implementedin 470java loc.
evaluation ourevaluationof crystallizer revolvesaround fiveresearchquestions.
rq1 cancrystallizer find deserialization vulnerabilities in previously well testedlibraries?
.
rq2 how does crystallizer perform against state of the art tools?
.
rq3 how docrystallizer s components influence the gadget chain discovery?
.
rq4 whatsinks does crystallizer find?
.
rq5 cancrystallizer detectnoveldeserializationvulnerabilities inenterprise software?
.
environment .we evaluate crystallizer on seven popular java based libraries table and three popular enterprise applications .
.
these cover a diverse range of functionality and havetable evaluation benchmarks paired with their ground truth chains.
benchmark version s description gtvuln apache commonscollections acc3.
.
data structuremanipulation apache commonscollections acc4.
.
data structuremanipulation aspectjweaver .
.
language featureextension beanshell .05b embeddable interpreter beanutils .
.
utilitylibrary groovy .
.
object orientedlanguage vaadin .
.
web applicationdevelopment beenpreviouslywell testedfordeserializationvulnerabilities.moreover wecompare crystallizer againsttworelatedtools gadget inspector and rasheed et al.
tool .
we evaluate on an intel xeon e5 .1ghz processor with 47g ram running ubuntu .
.crystallizer isconfiguredtoberuninsingle threadedmode andwascompiledwith javacversion11.
.
.
.
rq1 library basedevaluation we assess the effectiveness of crystallizer atuncovering deserializationvulnerabilitiesbyrunningitonthepreviouslywell tested seven libraries described in table .
to runcrystallizer on these libraries we followthe methodology in figure .
first crystallizer creates gadget graphs as a part of the static analysismodule.weprovideinformationaboutaknowntrigger gadget sourced from ysoserial for each of the libraries to crystallizer .
.crystallizer employsfouruniquemethods tostring compare hashcode invoke to automatically identify entrypointsintothelibrary.
table2detailsthesizeofthegraphs for each target library as well as the time taken to create them alongwiththenumberofentrypointsused.afterthegadgetgraph iscreated weperformsinkidentificationforwhichweallocatea time budget ofone hour since itisadynamic process.
in theprobabilisticconcretizationphase crystallizer identifies candidate gadget chains and thenattempts to concretize them.
we allocate a time budget of up to24hoursfor thisphase.
table3 providesanoverviewofthisphase.acrossallsevenlibraries crystallizer concretizes 837gadgetchains.
we manuallydeemed chains as being interesting i.e.
the sink gadgets in these chains performsemanticfunctionalitythatcouldbepotentiallyexploitable.
fromthese 604chains 48weremanuallyvalidatedtobeexploitable.
thesink gadgetsininterestingchains performawiderange of potentially exploitable semantic functionality.
certain sink gadgets perform traditionally vulnerable functionality like using reflection to invoke arbitrary methods or writing arbitrary bytestreams to files.however thereisalsoasubsetofsinksthatareperforming functionality that would not be categorized as traditionally vulnerablebutwhencoupledwithotherprimitivesprovidedbythetarget theybecomeexploitable.arepresentativeexampleofsuchasinkis lazymap.get shownin figure1 .thissinkgadgetallowsusing classes called transformers that allow transformationsto be performed on the key that is being inserted into the map.
it is possible touseasetof transformers whichwhenexecutedmountanrce attack.crystallizer owingtoitssinkidentificationcanidentify not only the lazymap.get method but also all transformers that are instrumentalinmounting the rceattack.
1591crystallizer a hybrid path analysis framework to aid in uncoveringdeserialization vulnerabilities esec fse december3 san francisco ca usa .
of the concretized chains are not deemed interesting since the sinks do not perform exploitable functionality.
this included functionalitysuch as wrapping objects into containers like hashmaps.
these sinks are flaggedbecause our current methodologyfor sinkidentificationonlyinfers whetherasinkgadget may operate on potentially attacker controlled objects but does not reason about the semantic functionality performed on such objects.
weplantointegratethissemanticfunctionalityreasoningasapart offuture work to make our sinkidentificationmore precise.
toassesstheexploitabilityofthegadgetchainsconcretizedby crystallizer we manually see if the payload for a concretized gadgetchainshowcasingapotentialdeserializationvulnerability that can be tweaked to mount an exploit.
the exploitability is assessedwiththehelpofasyntheticapplicationthatdeserializes user provideddataandhasthevulnerablelibraryonitsapplication classpath.
thismethodologyis inline withtheapproachadopted by park et al.
to perform their library based evaluation.
using the methodology outlined above we confirm exploitablity of chainsconcretizedby crystallizer bysuccessfullymountingrce attacksforsixoutofthesevenlibrariesandanarbitraryfilewrite attackfor the remaining library aspectjweaver .
the amount of manual effort required to convert a payload synthesized by crystallizer into a working payload varies.
the payloadssynthesizedfor vaadin beanutils andacc4.0bycrystallizerdid not require any further manual tweaking to mount an exploit.for aspectjweaver andgroovy weperformminimaltweaking where only the stringparameters used in the sink gadget are adjustedtomounttheexploit.theremainingtwolibraries acc3.
andbeanshell requireadditionalreasoningaboutthelibrarysemanticstoconvertthesynthesizedpayloadby crystallizer intoa payload that mounts an exploit.
specifically we have to infer what primitivesprovidedbythelibrarycouldbeusedasparametersin thesinkgadgettocall exec withanattacker controlledstring.
6providesadetaileddiscussionofmanual effort.
finally we perform a deeper analysis of the chains that are concretizedby crystallizer .thefirstobservationisthat crystallizersuccessfully discovers thesevenknowngroundtruthchains listedin table1 acrossallourevaluationtargets.inadditionto findingthesegroundtruthchains crystallizer concretizesnew gadgetchainsaswell.
figure3showsthetimetakenby crystallizerto create payloadsfor exploitablegadgetchains.
table4summarizesourfindingswithrespecttothenovelchains uncovered crystallizer automatically concretizes up to 17previouslyundiscoveredchainsperlibrary thatarecomposedofupto six gadgets.wequantifythecomplexityofthenovelchainsbymeasuring theunique classes theyare composed of.intuitively the more uniqueinstantiatedclassesachaincontains themorelanguageand chain specificprerequisites crystallizer fulfills .
.ourresults showthenovelchainsaremorecomplexthanthegroundtruthones containingtwiceasmanyuniqueclasses.wepresentanexample ofanovelgadgetchainin listing2.asdemonstrated throughits automated reasoning about gadget chains crystallizer uncovers gadgetchains corresponding to complex paths.
takeaway crystallizer can both synthesize payloads for previouslyknownchainsinlibraries aswellascreateconcretepayloads for novel gadget chains in well tested libraries in an efficient manner.table gadget graphsize ofthe targetlibrariesand the timetaken by crystallizer to create italong with the numberofentry points used to create the graph.
benchmark entry gadgetgraphtime s points gadgets edges acc3.
acc4.
aspectjweaver beanshell beanutils groovy vaadin average table candidate chains explored by crystallizer along with chains that were successfullyconcretized chains that were deemed to be interesting and chains that were manually validated to be exploitable.
benchmark gadgetchains candidates concretized interestingconfirmed exploitable acc3.
acc4.
aspectjweaver beanshell beanutils groovy vaadin average table novelgadgetchains foundby crystallizer along with their average gadgetfrequencyand acomparison of theuniqueclasses present inthe discovered groundtruth chain and the novel chains.
benchmark novel avg unique classes chains gadgets known novel acc3.
acc4.
aspectjweaver beanshell beanutils groovy vaadin average trigger 2badattributevalueexpexception .readobject links 4tiedmapentry .tostring 5tiedmapentry .getvalue 6singletonmap .get 7singletonmap .isequalkey fastarraylist .equals sink lazymap.get listing2 asimplifiedexampleofagadgetchaincorrespondingto anovelpath foundby crystallizer .
1592esec fse december3 san francisco ca usa prashastsrivastava flavio toffalini kostyantynvorobyov fran ois gauthier antonio bianchi andmathiaspayer .
.
.
.
.
.
time h 246810121416confirmed exploitable chainsacc .
vaadinaspectjweaver acc .0beanutils groovybeanshell figure time required by crystallizer to discoverthe exploitable gadgetchains.
.
rq2 comparisonagainststate of the art tools we compare crystallizer against two state of the art tools for findingjava baseddeserializationvulnerabilities i gadgetinspector is apure static analysis tool that given a library as input uses a set of heuristics to report potential gadget chains.
this tooldoes not create concrete payloads.
ii rasheedetal.
employheapabstractions toidentify gadgetchainscorrespondingtodeserialization basedvulnerabilities.
this toolcreates concrete payloads similar to crystallizer .
crystallizer v s gadget inspector .we compare crystallizeragainstgadgetinspectorbyrunningbothtoolsonthelibrary datasetspecifiedin table1andevaluatethereportedgadgetchains.
for this experiment we run crystallizer end to end on the libraries illustrated in figure .
furthermore we configure both toolstouncovergadgetchainscorrespondingtoattackpatternsthat havebeenpreviouslyfoundintheselibraries rceinalllibraries exceptfor aspectjweaver inwhichanarbitraryfilewrite afw exists .
the reason behind this configuration is two fold.
first this configurationensuresfeatureparitywith gadgetinspector since the latter cannot detect dos chains like crystallizer .
second it allows us to use known chains from available datasets to validate false negatives i.e.
exploitable chains that exist but are undiscovered.for crystallizer weexecutethesinkidentification for hour and probabilistic concretization for 24hours.
gadget inspector terminatesinafewminutes.
table5showsourfinding.
crystallizer usesitshybridanalysis methodology to find confirmed exploitable chains for mounting the targeted attack in alllibraries in our dataset.
specifically crystallizer finds previously known exploitable chains in addition to previously unknown ones.
conversely gadget inspector discovers only one exploitablechain for the acc .1library and missesthe previously known exploitable chains in the remaining six libraries.
we investigate the exploration methodology adopted by gadget inspectortounderstandwhyitdoesnotfindthepreviouslyknown exploitable chains.
one of the reasons was that as a part of its exploration methodology once it deems a gadget as exploredbased on its set of employed heuristics it does not try to uncover any chainsfurtherusingthesamegadget.thisstrategypreventsgadget inspector from reporting certain gadget chains.
we find a concretetable5 comparisonofgadgetinspectoragainst crystallizerin terms of gadget chains reported for libraries and theones which were confirmed to be exploitable.
benchmarkgadgetinspector crystallizer reported exploitable concretized exploitable acc3.
acc4.
aspectjweaver beanshell beanutils groovy vaadin average .
.
.
exampleofthisin vaadin.thisshowstheimportanceofexercising and exploring alternative paths while performing gadget chain discovery as done by crystallizer .
we investigate if we can create exploitable payloads for any ofthechainsreportedbygadgetinspector.first threechainsreportedby gadgetinspectorinthreeoutof the libraries acc .
aspectjweaver andacc .
are not exploitable due to incorrect reasoning about java language semantics.
for example in some chains gadgetinspectorincorrectlyassumesthatclassmembers declared as transient are attacker controlled.
second since gadget inspector is a static tool it does not give any guarantees aboutwhether it is possibleto create a concrete payload.this drastically inhibited the ability to build exploitable payloads for the remainingeightoutofthe13reportedchains.asanexample all thethree reportedchains in vaadinuse agadget that requiredan http servlet session to be setup upon instantiation and hence wasbeyondthescopeofourassessmentsincethechainreliedon externalfactors.incontrast crystallizer doesnotfacesuchissues since the dynamic approach of crystallizer ensures a chain is pairedwithconcrete payloads.
crystallizer v s rasheed et al.
here we compare crystallizeragainst the results presented in the paper by rasheed et al.
ideally wewouldperformacomparativeevaluationsimilartogadget inspector but were unable to do so.
specifically it failed while running the pathanalysisalgorithm onour evaluation dataset.
consequently wecompareagainsttheirreportedresultsfor acc .1andacc .
since these are the only two libraries in their dataset for whichthey were ableto create aconcrete payload.
for each of these libraries their tool only found one path corresponding to a known ground truth chain for which they manually created a concrete payload.
in contrast crystallizer not only concretizedpayloadstothetwogroundtruthchains butalso nine new gadget chains shown in table .
this drastic performance difference can be attributed to our hybrid analysis methodology.
insteadofrelyingonheavyweightvalue flowanalysistobuildheap accesspaths whichcanbepronetoimprecision ouruseoflightweightstaticanalysistobuildthegadgetgraphcoupledwithour dynamic analysis module that performs path concretization allows usto uncover andconcretize more gadget chains.
takeaway crystallizer ismoreeffectiveatuncoveringand creatingconcretepayloadsforgadgetchainsthantheexistingstateof the arttoolsusing its hybridanalysismethodology.
1593crystallizer a hybrid path analysis framework to aid in uncoveringdeserialization vulnerabilities esec fse december3 san francisco ca usa table6 comparisonof crystallizer againstcrystallizerngintermsofgadgetchainsreportedforlibrariesandthe ones which were confirmed to be exploitable.
benchmarkcrystallizer ng crystallizer reported exploitable concretized exploitable acc3.
acc4.
aspectjweaver beanshell beanutils groovy vaadin average .
.
.
.
rq3 comparativeperformance evaluation sincecrystallizer employsahybrid pathanalysismethodology we evaluate the relative importance of its static and dynamic components.
we create a variant of crystallizer that attempts to synthesizeconcretepayloadsforagadgetchainwithoutagadget graph crystallizer ng .however weequip crystallizer ng withtheknowledgeoftriggergadgetsandserializablegadgetsto createastrongerbaselineforcomparison.giventhisknowledge crystallizer ng uses the same probabilistic concretization moduleasusedin crystallizer andattemptstouncoverexploitable gadgetchains bycreating concrete payloadsfor them.
this approach is an appropriate evaluation candidate since turningoffanyoftheothercomponentswouldcreatevariantsthathave aweakercapabilityset i disablingsinkidentificationwouldcreate avariantthatmarks allgadgetsassinksleadingtoapathexplosion problem making the results meaningless ii replacing our path concretizationmodule witha vanilla fuzzerwould also be weaker since it would not know how to generate objects.
by comparing crystallizer againstcrystallizer ng wecangetanaccurate estimateofthebenefitsofbuildingagadgetgraphandusingitto uncover gadget chains.
similar to our evaluation of crystallizer we deploy crystallizer ng on seven target libraries for hours.
table 6presents an overview of the results.
first crystallizer is21.1xand17.3xmoreperformantonaveragethan crystallizernginconcretizinggadgetchainsanduncoveringexploitablechains respectively.second asevident thethreeexploitablegadgetchains thatcrystallizer ng uncovers are in three libraries beanshell beanutils andgroovy each of which are i previously known and ii simplesttoconstructrequiringonlyoneclasstobeinstantiatedcorrectly.inadditiontopreviouslyknownones crystallizer canuncovernovelgadgetchainsthatareexploitableanddrastically more complex as shownpreviously in table4 .
takeaway with the help of a gadget graph crystallizer reducesthestatespacethatitexplorescreating .1xmoreconcrete payloadsforgadgetchainsandfinding .3xmoreexploitableones.
.
rq4 sinkidentification evaluation we perform an in depth analysis of the sinks detected with our frameworkas apartofthelibrary based evaluation .
.we also evaluatetheefficacyofthestaticfiltersusedby crystallizer at improvingthe precision ofsinkidentification discussedin .
.table7 pre filtering referstothesetofsinkgadgetsflagged by sink identification s oracle.
post filtering shows the numberofremainingsinkgadgetsafterapplyingthestatic filters.
these are the sinks that crystallizer tries to concretize paths to.
reduction refers to the difference between thenumberofpre and post filtered sinks.
benchmarkpre filtering post filtering reduction sinks sinks sinks acc3.
.
acc4.
.
aspectjweaver .
beanshell .
beanutils .
groovy .
vaadin .
average .
previous gadgets ... sink 4fastarraylist .equals jdk method 6java.util.abstractmap .equals link 8lazymap.get listing3 asimplifiedchainshowinghowanexploitablepayload wascreated bycreating aroute through ajdk function.
we detect two new sinks in acc .
that led to six new exploitable chains missed by gadget inspector.
for one of the exploitable chains crystallizer markedfastarraylist.equals as a sink and created a concrete payload to reach this sink from a trigger gadget.
upon tinkering with this payload we noticed that iffastarraylist were to be instantiated with a lazymap wemanuallyfoundawaytoexerciseknowndangerousfunctionality factory.transform by routing it through a jdk function abstractmap.equals asshownin listing3.thisparticularchain wasnotreportedbygadgetinspector becauseaccordingtoitsanalysis itdidnotinferthat fastarraylist.equals couldberouted todangerousfunctionalitywhichasweshowedisnotthecase.this example showsour approach can find non trivialsinks.
filters are useful when performing sink identification we evaluatetheeffectivenessofstaticfiltersinmakingthesinkidentification moreprecise.specifically thefiltersensurethetaintedarguments thatcanbeattacker controlledareusedbythegadgetunderconsideration discussed in .
.
precision while performing sink identificationis importantsinceitdirectly impactsthenumberof gadgetchainsexplored.theresultsofthisevaluationarepresented intable .
we see that the filtering is highly effective in drastically reducing the state space to be explored by removing of the sinks that are not using the taintedargument.
takeaway the sink identification is suitable for discovering non trivialsinkgadgetsandthestaticfiltersitemploysareeffective at filtering false positive candidate sink gadgets.
.
rq5 crystallizer in the wild toshowcasetheeffectivenessof crystallizer atfindingdeserialization vulnerabilities in the wild we deploy it on two popular 1594esec fse december3 san francisco ca usa prashastsrivastava flavio toffalini kostyantynvorobyov fran ois gauthier antonio bianchi andmathiaspayer trigger 2badattributevalueexpexception .readobject links 4tiedmapentry .tostring 5tiedmapentry .getvalue 6lazymap.get closuretransformer .transform sink whileclosure .execute links truepredicate .evaluate nopclosure .execute listing gadget chain showcasingdosbehavior.
apache applications pulsar andkafka and mount two novel attacks.
specifically we mount a rce attack against pulsar and a dos attack against kafka.
these vulnerabilities are responsibly disclosed and acknowledged by the maintainers.
furthermore to show generalizability crystallizer rediscovers a previously known rce vulnerability cve in a vulnerable versionofthe oracle coherence library .
kafka.kafkaisaframeworkthatenablesbuildingdataprocessingpipelines .itprovidestheabilitytocapturedatafromvarying sourceswhichinturncanthenbestoredandprocessed.kafkauses entities called connectors that move data in and out of kafka as serialized bytestreams .
consequently the deserialization of untrusteddatathatmaybeattacker controlledopens upkafkato attacksmountedusing deserialization basedvulnerabilities.
kafkausesjava basedserializationanddeserializationtostore andretrievedatafromafileonalocalfilesystem.sincethefilethat it uses for storage could be manipulated by an attacker it employs afiltering basedmechanismtopreventdeserializationofasetof specificclasses .theprimaryinsightwehadfromthedenylist is that it did not prevent deserialization of allclasses belonging to known gadget chains but only classes that were instrumental in mounting knownattacksfor rcespecifically.
based on the above insight we deploy crystallizer to synthesize gadget chains to mount dos attacks instead.
crystallizer found a chain in the apache commons collections library that exhibits dos behavior.
specifically crystallizer synthesized a chain that upon deserialization performs the semantic action of executing an infinite loop while .
the gadgets employed in the chain are shown in listing .
evidently none of the gadgets usedinthechainareapartofthedenylistemployedbykafka.this in turn allowed us to mount a dos attack on the latest release of kafka as offebruary withthe helpofthis chain.
pulsar.pulsarprovides aframeworkfor server to servermessaging.
as a part of its messaging subsystem it provides extended functionality using light weight processes to process messages.
these compute processes allow for employing java based serialization and deserialization for message handling .
processing messages that point to untrusted data makes pulsar prone to deserialization attacks.
there is no serialization filtering performed by the deserialization apiusedbypulsar .therefore itispossible to mount a deserialization based attack using any of the classes present in the application s classpath.
for pulsar v2.
.
we noticed that the classpath includes the commons collections library.
trigger 2badattributevalueexpexception .readobject links 4limitfilter .tostring 5chainedextractor .extract sink reflectionextractor .extract listing5 vulnerablegadgetchainincoherenceuncovered andconcretized by crystallizer crystallizer discovered a gadget chain in this library with which we mountedan rceattackagainst pulsar.
coherence .coherenceisanin memorydatastoragethatallows fast access to key value data.
it is integrated as part of oracle weblogicwhichisapopularapplicationserver.weblogicinterfaces with user provided data so a vulnerability found in this library allowsmounting an attackthroughthe weblogic server.
owing to the large size and the underlying complexity of the coherencelibrary 13m theinitialgadgetgraphconstructedby crystallizer is large containing 734gadgets and edges.crystallizer thenrunsthesinkidentificationphaseover thisgadgetgraphforonehour.attheendofthisphase itidentifies potential sinks and candidate gadget chains for concretization.fromthesecandidatechains itconcretizes19unique chainsoverfivedaysacross20campaigns.fromthese19unique chains one is manually validated to be a previously known vulnerabilityin thecoherence library cve .
in addition sevenofthesechainsareconfirmedtobealternativepathstothe samevulnerablesinkincludingmorecomplexpathsaswell.finally theremaining11arepathsconcretizedtothreeuniquesinksthat we deemedas not performinginteresting semantic functionality.
thechainconcretizedby crystallizer ispresentedin listing5.
crystallizer identifies reflectionextractor.extract asasink since it has a reference to an array of type java.lang.object which isinstantiated with our honeypotclass during itsdeclaring class instantiation.
the payload which crystallizer constructs to concretizethecandidatechainispresentedin listing6.crystallizerbyuseofitschainconcretizationstrategyaugmentedwith an object cache algorithm enables it to concretize this chain without manual adjustment.
specifically while invoking the setter methods for limitfilter instead of generating a new object it retrievesanobject cobj fromitsobjectcache cobj .additionally crystallizer didnotinstantiatea reflectionextractor object explicitlysinceitinferredhowtobuilditindirectlybyinstantiating achainedextractor objectwitha string.
takeaway crystallizer effectively leverages the complete applicationclasspathtolaunchattacksagainstreal worldenterprise applicationseven inthe presenceof specific bypassprotections.
discussion the manual effort required to analyze concretized chains by crystallizer islowerthanexpected.thereasonisthatwecanreuse knowledge acrosschains inthe formof the unique sinksthat they target.
for aspectjweaver .
instead of analyzing 74concretized chains we only had to examine 2sinks manually.
this strategyworksbecausetheexploitabilityofaconcretizedgadget chain hinges on whether the sink gadget can be repurposed to 1595crystallizer a hybrid path analysis framework to aid in uncoveringdeserialization vulnerabilities esec fse december3 san francisco ca usa 1chainedextractor cobj newchainedextractor execute 2limitfilter lobj newlimitfilter 3lobj.setbottomanchor cobj 4lobj.setcomparator cobj preparing object corresponding to the trigger gadget 7badattributevalueexpexception val newbadattributevalueexpexception lobj 9objectoutputstream os newobjectoutputstream new fileoutputstream payload.bin writing the object into serialized bytestream payload 11os.writeobject val .
listing6 simplifiedjavacodeshowcasingthepayloadcreated bycrystallizer which uncovers the deserialization vulnerabilityincoherence mountanattack.oncetheexploitationstrategyforasinkisfigured out thisinformationcanthenbereusedinalltheotherconcretized chains that are targeting thesamesink.
onaverage ittook an experiencedjavadeveloperwithknowledgeofdeserializationattacks lessthan 5minutesperchaintovalidatetheirexploitabilityonce the conditions for exploitation were identified.
the hybrid analysis methodology adopted by crystallizer can suffer from false negatives i.e.
not creating payloads for certain vulnerablechainsthatexistinatarget.thesefalsenegativesmay creep infromtwomainsources.
first boundedsearch upto auserconfigurable maximum length inherently misses longer gadget chains.however thiscanbeaddressedbyincreasingthemaximum path length and allocating more computation time.
second the capabilityof crystallizer toconcretizeagadgetchaindependson the concretization module capabilities in solving chain constraints.
in some instances as shown for vaadin these constraints may correspondtothesetupoftheenvironment.weplantoinvestigate the concretizationofsuch chains as apart offuture work.
uncoveringadeserializationvulnerabilityinanapplicationrequiresnotonly thepresenceofavulnerablegadget chainbutalso anentrypointwheretheapplicationisdeserializinguntrusteddata.
we acknowledge that in the context of discoveringvulnerabilities in an application crystallizer is semi automated.
while it can findvulnerablegadgetchains automatically itstill requiresa user to identify anend point intheapplication deserializingdata where thepayloadcanbedelivered.however inthecontextoflibraries crystallizer can automatically create payloads that trigger the vulnerability.
while exploiting this vulnerability requires an applicationto be usingthatlibrary it does notchangethe factthat the vulnerability in the library still exists.
this view is in line with prior responses from library developers .
related work rasheedetal.
leveragepartialinstantiationofgadgetchainsby relying on heap abstraction and using a fixed set of sinks.
similar hybrid approaches were proposed by cao et al oddfuzz and gcminer to identify deserialization vulnerabilities in java applications.
a key difference with these works is that they require a pre defined set of sinks as compared to crystallizer whichautomaticallyidentifiessinks.specifically certainchainslike those exhibiting dos listing or using unconventional sinks for rce listing3 cannotbefoundbyoddfuzzandgcminer.thecorresponding sinks for these chains are not treated as securitysensitivebasedontheirpredefinedlist.unfortunately atthetime of writing oddfuzz is not open sourced and we were unable to reproduce results from gcminer.
pacheco et al.
propose automatic techniques to instantiate objects whichcanbenefit crystallizer initsobjectinstantiation.
we plan to explore them as future work.
gauthier et al.
propose an active mitigation to recognize malicious chains through markov basedmodeling while crystallizer isatestingtooltofind deserializationvulnerabilities.cristallietal.
discussedother dynamic mitigation policies.
regarding dos dietrech et al.
manually create a payload that upon deserialization triggers large call trees recursively leading to resource exhaustion.
in contrast crystallizer automaticallydiscovers dos likegadget chains.
deserializationattacksalsoimpactotherlanguageslikephpand .net.
dahse et al.
employ a static analysis based method to detectphpobjectinjection poi chains andparketal.
extend poi construction with an automatic exploit generation technique both yielding impressive outcomes.
however these approaches arecloselytiedtophpand relyonpredefinedsinks.incontrast crystallizer identifiessinksautomatically.moreover java sstatic typing imposes more stringent constraints on gadget chain concretization compared to php s dynamic typing.
shcherbakov et al.
uncover.net baseddeserializationvulnerabilities.byleveragingknownvulnerablechains.incontrast crystallizer sfocus is new gadget chains.
objectmap is designed to identify deserializationerrorsinphpandjavaapplications.itidentifiesthe entrypointsofanhttprequest thenprobesdifferentinputsuntil adeserializationerrorarises.objectmap however exploresmaliciousinputwithoutmodelingtheinputspacesasagadgetgraph norincludingthe notionof source sinkgadgets.
conclusion deserialization vulnerabilities are common in complex distributed applications.
we introduce a hybrid approach to automatically discover such deserialization vulnerabilities highlighting incomplete checks when objects are deserialized in target applications.
our method uses static analysis to identify candidate gadget chains and dynamic analysis to generate concrete payloads to exercise gadgetchainsshowingproofofadeserializationvulnerability.
crystallizer outperforms existing state of the art tools in uncovering java baseddeserializationvulnerabilities and is showncapableof mounting attacksonpopular real world applications.