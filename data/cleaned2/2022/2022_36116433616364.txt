knowledge based version incompatibilitydetection for deep learning zhongkai zhao zhongkai.zhaok gmail.com tongji university shanghai chinabonankou koub purdue.edu purdueuniversity westlafayette indiana usamohamed yilmaz ibrahim ibrahi35 purdue.edu purdueuniversity westlafayette indiana usa muhao chen muhchen ucdavis.edu university ofcalifornia davis davis california usatianyizhang tianyi purdue.edu purdueuniversity westlafayette indiana usa abstract version incompatibility issues are rampant when reusing or reproducing deep learning models and applications.
existing techniques arelimitedtolibrarydependencyspecificationsdeclaredinpypi.
therefore these techniques cannot detect version issues due to undocumented version constraints or issues involving hardware drivers or os.
to address this challenge we propose to leverage theabundantdiscussionsofdlversionissuesfromstackoverflow tofacilitateversionincompatibilitydetection.wereformulatethe problem of knowledge extraction as a question answering qa problemanduseapre trainedqamodeltoextractversioncompatibilityknowledgefromonlinediscussions.theextractedknowledge is further consolidated into a weighted knowledge graph to detect potential version incompatibilities when reusing a dl project.
our evaluation results show that our approach can accurately extractversionknowledgewith84 accuracy and ourapproach canaccurately identify65 of known versionissuesin popular dl projects with a high precision while two state of the art approaches can only detect and of these issues with and17 precision respectively.
ccsconcepts softwareanditsengineering softwarelibrariesandrepositories.
keywords version compatibility knowledge extraction deeplearning acm reference format zhongkaizhao bonankou mohamedyilmazibrahim muhaochen andtianyi zhang.
.
knowledge based version incompatibility detection for deep learning.
in proceedings of the31st acm joint european softwareengineeringconferenceandsymposiumonthefoundationsofsoftwareengineering workdoneas a remoteresearchintern at purdueuniversity.
esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
acm newyork ny usa 12pages.
introduction deep learning dl has been applied in various domains such as computer vision natural language processing and autonomous driving .
developing dl applications requires a heterogeneousdlstack includinglibraries e.g.
pytorch tensorflow runtime e.g.
python drivers e.g.
cuda cudnn os e.g.
linux and hardware e.g.
nvidia gpu .
the complex inter dependencies between these dl stack components often result in dependency issuesthatarehard todiagnoseandresolve .previousstudies haveshownthattheseissueshavebeenidentifiedasamajorreasonfor build failuresin dlprojects which significantlystagnates developerproductivity andsoftware reusability in dl .
several techniques have been proposed to detect dependency issues in python projects which can be applied to dl projects since most dl projects are python based.
however thesetechniquessufferfromtwolimitations.first allofthesetechniquesonlydetectdependencyissuesamongpythonpackages with theonlyexceptionofpyego whichcandetectissuesamong pythonpackages somesystemlibraries andpythoninterpreters.
noneofthemcandetectissuesrelatedtodrivers os andhardware.
second these techniques rely on dependency knowledge specifiedinpypiandapidocumentation whichhaslimitedcoverage of known version issues due to undocumented dependency and version constraints.
meanwhile popular q a websites such as stack overflow so haveaccumulatedawealthofinformationaboutdependencyissues andtheirsolutions.comparedwithotherinformationsourcessuch aspypi q apostsaremoreup to dateandcomprehensive coveringvariousundocumentedissuesdevelopershaveencountered in practice.
however given the ambiguity and sophistication of naturallanguage extractingknowledgefromfree formtextischallenging.
for example a so answer states that for tensorflow .
you can see only whl files up to python .
are available.
i am guessingthatyouareeitherusing3.7or3.
.thatiswhypipinstall tensorflow gpu .
.
.isnotworking.
tosuccessfullyextractthe versionknowledge oneneedstobuildtechniquestocorrectlymatch package names withtheirversions andinferthe in compatibility relationshipbasedonthecontextandnarrativetransitionacross multiple sentences.
thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa zhongkai zhao bonan kou mohamedyilmaz ibrahim muhao chen andtianyi zhang figure anoverview oftheknowledgegraphconstruction andincompatibilitydetection process toaddressthischallenge weproposeanovelapproachcalled decide which uses a pre trained question answering qa model to extract version compatibility knowledge from so posts.
figure providesanoverviewof decide.specifically wereformulatethe knowledgeextractiontaskasaquestion answeringtask giventwo versioned dl stack components mentioned in a so post we query aqamodeltopredictwhethertheyarecompatibleorincompatible based on the post.
we use unifiedqa as the qa model which is trained on eight large scale datasets and has demonstrated superior performancein naturallanguageunderstanding.we carefully designasetofalternativequestiontemplatesbasedonthelinguistic patterns of sentences that discuss version issues in stack overflow as shown in table .
by combining predictions from several alternativequestionsbasedonthelossvalues decidecanachieve morerobustpredictions whichisalsoknownasself consistency prompting .
decidefurther consolidates the extracted knowledge into a weightedknowledgegraph whichservesastheknowledgebasefor versionincompatibility detection.
specifically given adl project decidefirstanalyzesitsconfigurationscriptaswellassourcecode to identify the required dl stack components and their version constraints.then itextractsdlstackinformationfromthelocal machine and checks the knowledge graph for potential incompatibilities.
uponthe detectionofanincompatibility decidealso suggests the so posts where the knowledge is extracted from to helpdevelopers fixthe issue.
we applied decideto 355k so posts that may mention version issues in deep learning producing a large knowledge graph with3 in compatibilityrelationsamong48populardlstack components acrossthe dl developmentstack.
a manualanalysis reveals a reasonable accuracy of the extracted knowledge.
furthermore we evaluated decideon popular dl projects with 17known versionissues incomparisontotwo state of the artapproaches pyego andwatchman .wefoundthat decide candetect65 oftheseissueswithahighprecision significantlyoutperformingpyego precisionand29 recall and watchman precisionand6 recall .theseresultsdemonstrate thefeasibilityofknowledgeextractionfromstackoverflowviaa pre trained qa model and the effectiveness of knowledge based versionincompatibility detection.
in summary we make the following contributions we proposed a novel knowledge extraction paradigm that reformulates the knowledge extraction task as a questionanswering task and implemented a knowledge extraction figure required dependencies for alice to reproduce a dl project and version incompatibilities bold in a local environment pipeline that extracts version compatibility knowledge from so posts using apre trainedqa model.
we developed a knowledge based version incompatibility detection approach for dl projects.
wecomprehensivelyevaluatedthequalityoftheconstructed knowledgegraphandcompared decideagainsttwostateof the arttechniques on10 real world dl projects.
wemadepubliclyavailablethefirstlarge scale knowledge graph with version compatibility relations which can be used to facilitate future research on version incompatibility detection inference andrepairfor deep learning.
our code data and the resulting knowledge graph have been madepubliclyavailable at .
motivating example suppose alice is a developer and she wants to reuse a tensorflow modelforsentimentanalysisfromgithub.alicestartsbyinstalling dependenciesdeclaredinthe requirements.txt fileviapip.figure2shows part of the requirements.txt file.
she successfully installstensorflow andnumpy.
however when she is installing scipy pipthrows an error message that a numpyversion between .
.5and1.
.0isrequiredfor scipy .
.
butthecurrently 709knowledge basedversionincompatibilitydetectionfordeep learning esec fse december3 san francisco ca usa installednumpyversionis1.
.alicesolvestheproblembydowngrading the numpyversion.
yet this is just the start of a chain of versionincompatibilityissueswhereeachofthemgraduallyreveals itself after the previous ones are resolved.
alicecontinuestoinstall scikit learn withpip.thistime pip throws an error error could not build wheels for numpy which usepep517andcannotbeinstalleddirectly.
alicefindsthismessage confusingasshedoesnotknowwhatpep517is.soshesearchesfor this message online but none of the most popular answers google returns such as updating pip works.
alice then tries to search for the error message directly on stack overflow so .
with some digging she finds a post that suggests this error to be related to using a macbook with an apple m1 chip.1since apple m1 uses thearmarchitectureratherthanx86 itisnotcompatiblewiththe default distributions of certain libraries such as scikit learn .
according to the so post this issue can be solved by replacing macos blas withopenblas anopen sourceimplementationlinear algebralibrarythat scikit learn dependsonandiscompatible with arm.
after installing openblas alice successfully installs scikit learn onapplem1.
now the target dl project successfully compiles on alice s laptop.shestartsrunningittotrainthemodelbutimmediatelygets a runtime exception modulenotfounderror no module named tf.contrib.
alice is confused since she has successfully installed all librarydependenciesspecifiedin requirements.txt .aftersearching online alice found another so post stating that tf.contrib has been deprecated since tensorflow .
and its functionality hasbeenmigratedtothecore tensorflow api.2currently shehas tensorflow .
installed which no longer has the tf.contrib module.
thus she needs to downgrade her tensorflow version to .x.comparedwiththepreviousincompatibilityissue thisissue is much harder to diagnose since it is not explicitly declared in the requirement.txt file norclearlyrevealedinthe errormessage.
alice downgrades tensorflow to1.15and re starts training.
another error occurs importerror libcublas.so.
.
cannot open sharedobjectfile nosuchfileordirectory.failedtoloadthenative tensorflowruntime.
alicehasnocluewhatthiserrormeans soshe searchesonlineagain.shefindsyetanothersopostthatasksabout thesameerrormessage butittakesherawhiletoreadandcompare all13answerpoststothisquestion.3shelearnsthat tensorflow .15requirescuda10.
aparallelcomputingframeworktoutilize nvidia gpus.
after manually checking the current cudaversion she finds that cuda10.
is installed on her laptop.
she follows the instructionsinan answer post to download cuda10.
andfinally resolves the conflict.
now with all version issues resolved alice can finally run the dl projectto trainhermodel.
insteadofrepeatedlysearchingandreadingmanysoposts alice canusedecidetoquicklyfindallpossibleversionincompatibilities betweenadlprojectandherlocalmachine.
decidestartsbyextractingversion relatedknowledgefromthousandsofsoanswer posts and consolidates the extracted knowledge into a weighted knowledge graph.
then it iteratively queries the knowledge graph to detect version incompatibilities among required dl components locally installed components.
furthermore to help alice understandtherootcauseoftheincompatibilityandfindsolutions deciderecommends a list of so answer posts from which the incompatibility knowledge isextracted.
existing techniques such as watchman and pyego are limited in detecting the aforementioned dependency issues for two reasons.
first most of the existing techniques only analyze dependenciesamongpythonpackagesandthuscannotfindissuesacross differentdllayers.tothebestofourknowledge pyego isthe onlytechniqueanalyzingsystemlibrariesandpythonruntimeinaddition to python packages.
however it still cannot analyze drivers os containers andhardware.
second existing techniques mainly rely on version information specified in pypi metadata or api documentation which is often incomplete or out of date.
by contrast decideacquiresversioncompatibilityknowledgefromabundant so posts which are far more comprehensive and up to date.
therefore itcandetectadiversesetofversionincompatibilitiesacrossall layers of the dl development stack i.e.
libraries runtime drivers os containers and hardware .
our experiment shows that decide outperformspyego andwatchman byatleast58.
in precision and35.
inrecall section .
.
problem formulation definitions dependencymanagementanddependencyissuedetectionarewellestablishedresearchproblemsinsoftwareengineering se .comparedwithconventionalsoftware dependencyissues indeeplearning dl applicationsaremoresophisticateddueto thecomplexdldevelopmentstack.thus inthissection wefirst formally definethe researchproblem and related conceptstohelp readers understandthe scope of this project.
ourgoalistodetectpotentialversioncompatibilityissueswhen reusing or deploying a dl project on a local machine.
we use u1d443 to denote a dl project to be deployed and u1d440to denote the local machine where u1d443executes.the formaldefinitionsare as follows definition1.
dl stack components in this work we consider the version issues among componentsin the following five different dl stack layers library layer this layer contains the popular frameworks e.g.
tensorflow pytorch and other libraries e.g.
numpy scipy that a dl application directly depends on.
runtime layer this contains the execution interpreters or virtualmachinesof programming languages e.g.python interpreter jvm .
driver layer this layer includes hardware drivers andacceleratedsdks e.g.cuda cudnn os containerlayer thisincludestheoperatingsystemsandothercontainersorvirtual environments e.g.
anaconda docker .
hardware layer this includes the hardware andchips e.g.cpu gpu tpu .
definition2.
localdlstack wedefinethedlstackcomponents u1d43finstsalled in the local machine u1d440as u1d43f u1d452 u1d4631 u1d452 u1d4632 ... u1d452 u1d463 u1d45b u1d45b inwhich u1d452 u1d463 u1d456 u1d456isadl stack component u1d452 u1d456withversionnumber u1d463 u1d456.
definition .
required dl stack we define the dl stack componentsrequiredbythedlproject u1d443as u1d445 u1d452 u1d4501 u1d452 u1d4502 ... u1d452 u1d450 u1d45b u1d45b .
u1d452 u1d450 u1d456 u1d456is a dl stack component u1d452 u1d456with a version constraint u1d450 u1d456 where u1d450 u1d456isexpressedinarange format u1d463 u1d45a u1d456 u1d45b u1d463 u1d45a u1d44e u1d465 u1d463 u1d45a u1d456 u1d45b u1d463 u1d45a u1d44e u1d465 .
definition .
version incompatibility with the basic concepts defined above we can now formulate the problem of version incompatibility.
given a local dl stack u1d43fand required components 710esec fse december3 san francisco ca usa zhongkai zhao bonan kou mohamedyilmaz ibrahim muhao chen andtianyi zhang u1d445inadlproject foranypair u1d459 u1d463 u1d45f u1d450 where u1d459 u1d463 u1d43f u1d45f u1d450 u1d445 aversion incompatibility issue occurs if one of the following two conditions is satisfied.
first if u1d459and u1d45frefer to the same component u1d463is not in therangeof u1d450.second if u1d459and u1d45faredifferent thereisanimplicit dependency between u1d45f u1d45aand u1d459 u1d463and u1d45aisnot inthe range of u1d450.
whilethefirstconditioniseasytocheck thesecondconditionis sophisticated and challenging since it requires identifying implicit dependencies between dl stack components.
existing approaches relyonprogramanalysisordependencygraphsfrompypiorthe python official website to identify implicit dependencies.
however theseapproachescannothandleimplicitdependenciesacrossdl stack layers or capture undocumented dependencies.
in this work we propose to utilize the rich information shared on stack overflow whichcapturesvariousandup to dateversionincompatibility issuesintherealworld.weextractandrepresentsuchinformation inaweightedknowledge graph whichisdefinedbelow.
definition weighted knowledge graph a weighted knowledge graph is defined as u1d43e u1d43a u1d441 u1d438 where u1d441 u1d45b u1d463 u1d456 u1d456 isasetofnodesdenotingthedlstackcomponentswiththeir versionnumbers and u1d438 u1d452 u1d464 u1d457 u1d457 isasetofedgesrepresentingthecompatibleorincompatiblerelationshipbetweentwodl stackcomponents.eachedgeislabeledwithanormalizedweight u1d464 which captures the confidence of this knowledge detailed in section4.
.
knowledge graph construction this section presents how decideextracts version compatibility knowledge from so posts to buildaknowledge graph.
.
data collectionandfiltering wedownloadedthestackexchangedatadump with53million stackoverflowpostsfrom july31 2008toseptember5 .
since our purpose was to extract version compatibility knowledge related to deep learning we first filtered the so data dump to find relevant so posts.
to do this we manually identified a set of so tags relatedto deeplearning.
specifically thefirstauthormanually went through popular so tags i.e.
tags with more than 10k questions fromallthe63 715tagsinstackoverflowandcreatedan initiallexicon with12 keywordsrelatedto deeplearning.togeta more accuratetag list the firstauthor then searchedthe remaining so tagsandfound tagscontainingatleastone of these12 keywords.
then he inspected all these tags and selected a final set of so tags related to deep learning.4we filtered the so posts to onlyretainpoststaggedwithatleastoneofthe46tags.
.9mposts remainedafter this step.
then we performedanotherround of filteringtofind so posts thatmaymentionversioncompatibilityissues.fromthedl related posts obtained from the previous step the first author searched version incompatibility and manually inspected the first posts fromthesearchresults.then hesummarized22linguisticpatterns from the sentences mentioned version issues in these posts.
table1shows five examples of the linguistic patterns.5we 4thecompletelistoftagscanbefoundat main decide docs so tags.json 5thecompletelistoflinguisticpatternscanbefoundat decide blob main decide docs linguistic patterns.txtfurther filtered the dl related so posts with these patterns to find so posts that mention version issues.
after this step 549k posts were retained.
furthermore toensurethequalityofthesoposts weonlykept poststhatweremarkedasacceptedanswers aswellaspostswhose vote score i.e.
upvotes minus downvotes was above one.
this resulted in 355k posts which formed the information source to extract versioncompatibilityknowledge.
to evaluate the accuracy of our data collection process we randomly sampled posts from the filter results.
this sample size is statistically meaningful with a confidence interval.
the first two authors independently inspected these posts and found of them indeed contained version compatibility information.
the cohen skappascoreofthisevaluationis0.
.inotherwords ourdata collectionpipelineidentifiedsopostswithversioncompatibility knowledgewith84.
accuracy whichisreasonableforknowledge extraction.
.
dl stack component recognition duringthemanualinspectioninthepreviousstep weobservedthat not all paragraphs in a version related so post mentioned version compatibilityinformation.toimprovetheknowledgeextraction efficiency wedesignedafiltering mechanismin decidetolocate paragraphs that may mention version compatibility information.
thekeyinsightisthatversionincompatibilityinvolvestwodlstack componentsandtheirversions.so decideonlyselectedparagraphs that mentionat leasttwodifferentversionedcomponents.
in the current implementation decidesupports the recognition of48popularcomponentsacrossthefivelayersinadlstack.these components were manually identified by the first author from the posts with the highest score i.e.
upvotes minus downvotes amongallpostsobtainedfromthepreviousstep.inaddition the firstauthoralsoaddedsynonymsoraliasesforthesecomponents to improve the accuracy of dl stack component recognition.
table2shows some of the components and their synonyms.
currently we onlyconsiderthesepopular components.one can easilyextendthembyaddingmorecomponents eithermanually or from an existing lexicon.
adding more components does not induce any additional effort to adapt the following steps since the following steps are designed as a general process for any dl stack components.
basedonthe48dlstackcomponents decideperformskeyword matchingtoidentifyparagraphsthatmentionatleasttwodifferent components.
specifically given a so post decidefirst removes code snippets wrapped in pre tags from the post to focus on the natural language text data.
it keeps the inline code elements wrapped in code tags to preserve the text flow.
then decide splits thepreprocessed textinto paragraphsby line breaks.
when matching dl stack components decideperforms case insensitive keyword matching.
furthermore we designed three regex patterns to identify version numbers mentioned in a paragraph.
table shows the three regex patterns and some examples of matched versionnumbers.
6acompletelistof48dlstackcomponentscanbefoundat decide blob main decide docs dl stack components.txt 711knowledge basedversionincompatibilitydetectionfordeep learning esec fse december3 san francisco ca usa table examples oflinguisticpatternsto match version related posts regexpa t tern matched examples in ?compatible version s ?
with component name ?
... iam using cuda9.
as .
is notyet compatiblewithtensorflow s pre built binary... do not does not did not don t doesn t didn t ?
s work s ing ed ?
s with for together ...tensorflow .
doesn tworkwith cuda10.1because of thefollowing... be is are was were been removed deprecated no longer support since from in sversion s ?...support for fftwwas removedin versions of scipy .
and numpy .
... mov down up grad e ed ing s your ?
s component name s version ?
s from to ?...downgradenumpyversionfrom1.
.2to1.
.4willresolve issue with tensorflow... latest new earlier older previous later recent minimum maximum s version s ?
s of ?...whatchanged the latestversionof numpyrequires python .
hencetheerror message... table examples of the recognized dl stack components names after are aliases layer dlstackcomponents library tenforflow tf numpy np pytorch scikit learn sklearn runtime python driver cuda cudnn os container ubuntu windows macos debian anaconda hardware applem1 arm amd table versionmatchingpatterns regexpa t tern matchedexamples v d .d .
.
.
v2.
v1.
.
v d .
d .x .x .
.x v1.x v2.
.x component v d python v3 cuda windows after extracting a set of dl stack components and version numbers in a paragraph decidemakes the best effort to match a component with its version.
we formulate this matching problem as aweightedstablematchingproblem .thestablematchingalgorithm tries to establish a one on one matching between each component and each version while maximizing the depth of the lowest common ancestor of every matched component and version in the dependency tree of a sentence.
this measurement is morerobustthanthetoken leveldistance sinceweobservethat the closest version number to a component in a sentence might referto another component given thecomplex grammarstructure innaturallanguage.considerthisexample foryourinstallation of tensorflow .
version of cuda library should be used .
though .0is closer to tensorflow it is actually the version of cuda.
figure3shows the dependency tree of this sentence.
the lowest commonancestorof .0andtensorflow isused depth0 while thelowestcommonancestorof .0andcudaisversion depth .thus decidematches10.0withcuda.specifically decideuses stanza to perform dependency parsing.
afterthematchingprocess ifacomponentinthelibrary runtime driver oros containerlayerdoesnothaveamatchedversion itwillnotbeconsideredforcompatibilityinferenceinthenextstage.
yet if a component in the hardware layer does not have a matched version it will still be considered for compatibility inference in the nextstage.
this design choice is based on our observation thatdevelopersdonotalwaysreporthardwareversionswhenmentioning version issues on stack overflow.
consider the example i face the same problem on macos .
.
bigsur with the apple m1 chip .7in .
for yourbe of cudaversion libraryshould ofinstallationobl punct nsubjaux aux nmod casenmodcasenummod nmod case compound figure dependency tree where the depth of the lowest commonancestorfor10.0andcudais1whilethedepthfor thelowest commonancestorfor10.0and tensorflow is .
thissentence macoswillbematchedwith11.
.
whileapplem1is acomponentwithnoversionnumber.intheend decideidentifies a total of paragraphs from so posts that mention at leasttwodifferentversionedcomponents.
overall our matching algorithmmakes thebest effortto match a dl stack component and its version.
given the ambiguity and complexityofnaturallanguage wecannotalwaysguaranteethe correctness of matching.
yet with the careful design above we argue that our matching algorithm works in most cases.
to confirm this we randomly sampled so posts from the 355k posts from the previous step to evaluate our matching algorithm.
this sample size is statistically meaningful with a confidence interval.
the first two authors independently checked the matching results from each post to determine whether dl stack components were correctly matchedwith theirversions.
then they compared theiranalysisresultsandresolvedanydisagreements.thecohen s kappa score was .
.
overall our matching algorithm achieved ahighaccuracyof87.
.thisresultindicatedthatourmatching algorithm workedfinefor mostcases.
.
compatibility inference viaapre trained qa model afterrecognizingtwodlstackcomponentsandtheirversionsina paragraph decideinfersthecompatibilityrelationshipsbetween thembasedontheinformationintheparagraph.analyzingfreeformtextinsopostsischallengingduetotheambiguityintheir 712esec fse december3 san francisco ca usa zhongkai zhao bonan kou mohamedyilmaz ibrahim muhao chen andtianyi zhang context importtensorflow issuehasbeenresolvedbychanging python from bit to bit and python version must be .
.7because3.8isnotcompatibleforinstallingtensorflow through pip install tensorflow .
.
.
question ispython3.7compatiblewithtensorflow .
.
?
answerfromunifiedqa yes.
context tensorflow .
doesn t work with cuda .
because of the following importerror libcublas.so.
.
cannot open shared object file no such file or directory .
tensorflow is looking for libcublas.so.
.
whereas cudaprovideslibcublas.so.
.
.
.
.
question doestensorflow1.13workwithcuda10.
?
answerfromunifiedqa no.
figure qaexamples forversioncompatibility inference table4 questiontemplatesforversionknowledgeextraction q1 is u1d452 u1d434 u1d463 u1d434 compatible with u1d452 u1d435 u1d463 u1d435 ?
q2 is u1d452 u1d434 u1d463 u1d434 not compatible with u1d452 u1d435 u1d463 u1d435 ?
q3 does u1d452 u1d434 u1d463 u1d434 support u1d452 u1d435 u1d463 u1d435 ?
q4 does u1d452 u1d434 u1d463 u1d434 not support u1d452 u1d435 u1d463 u1d435 ?
q5 does u1d452 u1d434 u1d463 u1d434 require u1d452 u1d435 u1d463 u1d435 ?
q6 does u1d452 u1d434 u1d463 u1d434 not require u1d452 u1d435 u1d463 u1d435 ?
q7 does u1d452 u1d434 u1d463 u1d434 work with u1d452 u1d435 u1d463 u1d435 ?questiontemplatesq8 does u1d452 u1d434 u1d463 u1d434 not work with u1d452 u1d435 u1d463 u1d435 ?
narratives as well as their sophisticated structures.
prior work that useslinguisticpatternsorrulestoextractprogrammingknowledge falls short in reasoning the deep semantics in natural language.
in this work we propose to reformulate this compatibility relationshipclassificationtaskasaquestion answering qa taskandthen use a pre trainedqa model to solvethe task.
specifically decide usesunifiedqa asthepre trainedqamodel.unifiedqaisa large model with billion parameters and it is pre trained on eight datasets.ithasbeendemonstratedtounderstanddeepsemantics in natural language and achieve state of the art performance in multipleqabenchmarks .unifiedqatakestwoinputs a questionand acontext document from which the answer is extracted.
decideusestheparagraphwheretwoversionedcomponentsare recognized as the context document and then asks unifiedqa a yes or no question to infer the compatibilityrelationship between thetwocomponents.figure 4showstwoqaexamplesfromtwo real so posts and .
the selection of appropriate question prompts for qa models has a noticeable impact on model performance .
hence we carefully crafted eight question templates based on the linguisticpatternsidentifiedinthepostfilteringprocedure .
we experimented with all eight question templates and some of their combinations on unifiedqa.
the experiment results indicate thebestperformanceofunifiedqaisachievedbycombiningq1 andq2.moredetailsonevaluationsofdifferentquestiontemplates can be read insection .
.
8the pos tags are omitted in this dependency tree for presentation.
the definition of eachedge label canbefoundat figure part ofthe resultingknowledgegraph .
knowledge consolidation the exacted version compatibility relationships may contain redundancies and inconsistencies as the relevant information can be presentedinmultiple posts.
toeliminateredundancies andreconcileconflicts decideconsolidatesrelationsbetweenthesamepairs ofversioneddlstackcomponentsbycalculatingtheconfidence weight for each relation.
for a pair of versioned components let u1d436 u1d45c u1d45a u1d45d u1d44e u1d461 u1d456 u1d44f u1d459 u1d452 denotethenumberofpoststhat decideinfersacompatibilityrelationshipbetweenthem and u1d43c u1d45b u1d450 u1d45c u1d45a u1d45d u1d44e u1d461 u1d456 u1d44f u1d459 u1d452 denotethe numberofpoststhat decideinfersanincompatiblerelationship betweenthem.wedefine the confidenceweightof the relationship between twoversionedcomponentsas follows u1d450 u1d45c u1d45b u1d453 u1d436 u1d45c u1d45a u1d45d u1d44e u1d461 u1d456 u1d44f u1d459 u1d452 u1d43c u1d45b u1d450 u1d45c u1d45a u1d45d u1d44e u1d461 u1d456 u1d44f u1d459 u1d452 u1d436 u1d45c u1d45a u1d45d u1d44e u1d461 u1d456 u1d44f u1d459 u1d452 u1d43c u1d45b u1d450 u1d45c u1d45a u1d45d u1d44e u1d461 u1d456 u1d44f u1d459 u1d452 if u1d450 u1d45c u1d45b u1d453isapositivenumber itimpliesacompatiblerelationship.
otherwise itimpliesanincompatiblerelationship.relationships withaneutral confidence weight u1d450 u1d45c u1d45b u1d453 are discarded.
after the knowledge consolidationprocess decideproducesa knowledgegraphconsistingof1 431nodesand3 124edges.each node in the graph represents a unique versioned dl stackcomponent whileeach edge represents an in compatibilityrelationship betweentwocomponentswithaconfidenceweight.anillustration oftheknowledgegraphisprovidedinfigure wherecomponents of different layers in the dl development stack are denoted by differentcolors.forexample keras .
.
tensorflow .
and scipy .
are colored red in figure since they come from the librarylayer.alltherelationsintheknowledgegraphareweighted.
in figure the relation between python3.
andtensorflow2.
hasaconfidenceweightof .
indicatingacompatiblerelationship.
thisweightiscalculatedbasedonequation1 where10soposts mentionthesetwolibraryversionsarecompatible u1d436 u1d45c u1d45a u1d45d u1d44e u1d461 u1d456 u1d44f u1d459 u1d452 and posts mention the opposite u1d43c u1d45b u1d450 u1d45c u1d45a u1d45d u1d44e u1d461 u1d456 u1d44f u1d459 u1d452 .
this pipeline of building the weighted knowledge graph can be adapted to extract open endedknowledge for differententitiesfrom future so posts.
compatibilityissuedetection givenadlprojecttoreuseandalocalenvironment decideperforms version incompatibility detection based on the knowledge 713knowledge basedversionincompatibilitydetectionfordeep learning esec fse december3 san francisco ca usa graph in three steps identifying the required dl stack from the givendlproject identifyingthelocaldlstackfromthelocal environment and querying theknowledgegraph todetectpotentialversionincompatibilityifinstallingtherequiredcomponents onthe local environment.
eachstep isdescribedbelow.
.
requireddl stack identification decidefirstidentifies requireddl stack componentsfrom the configuration file and source code.asa commonpractice developers usually specify required dependencies for a project in a configuration file named requirements.txt .decidecollects the namesandversionconstraintsofthepackagesandlibrariesspecifiedinrequirements.txt .however asthecomponentslistedin requirements.txt can be incomplete decidefurther performs static analysis to obtain the full list of python packages used by theproject.specifically decideparsesallthepythonfilesinthe project into abstract syntax trees asts and extracts package names specifiedinthe importstatements.
.
localdl stack identification following definition in section decidecollects the version informationofthecomponentsinfivedlstacklayers.notethat a developer may deploy the given dl project in either a native python environment or a virtual environment managed by anaconda .decidewillfirstdetectwhichenvironmentisusedby running echo conda prefix .ifthiscommandoutputsanonemptypathofacondaenvironment thenitisavirtualenvironment.
otherwise itis a native environment.
dependingonthe localenvironment decidewill invoke different system commands to gather the versioninformation ofthe local dl stack.
wedescribehow decidegatherstheversioninformationineach layer below library if the local environment is a native python environment decideusespip thedefaultpythonpackagemanager togatherlocallyinstalledpythonpackagesandtheirversions via pip freeze .
then decidegathers the version information of system libraries e.g.
gcc by directly calling corresponding system commands e.g.
gcc version and parsing the outputs.
in the current implementation decide only extracts the version information of the popular system librariesdescribedinsection .
.ifthelocalenvironmentisa virtual environment managed by anaconda decidewill usethecondacommandtocollectversioninformation conda list .whilepipiscenteredaroundpythonpackages conda supports the management of system libraries e.g.
gcc and hardwaredrivers e.g.
cudnn inadditiontopythonpackages.
thus decidecanuse conda list togathertheversioninformation of both python packages and system libraries in a singlecommand execution.
runtime sincewefocusonpython baseddlprojectsinthis paper decidegatherstheruntimepythoninterpreterversion byinvoking python version andparsingtheoutput.this command works inboth native andvirtual environments.
driver if the local environment isnative decidewill collect the version information of hardware drivers and toolkits by directly invoking the correspondingcommand for each drivercomponentdescribedinsection .
e.g.
nvcc v forruntime cudaversions nvidia smi fornvidiagpudriverversions.
if the local environment is virtual decidewill use conda list to gather the version information of hardware drivers andtoolkits.
os container decideusesapisinpython osmoduleorthe command of each os container component to gather their version information e.g.
python osmodule for os version conda version for anacondaversion.
hardware decidegathers hardware information by parsing theoutputsofsystemcommands e.g.
uname a forthecpu architecture nvidia smi for the nvidiagpumodel.
in the current implementation we focus on popular dl stack componentsin the five layers.
these componentsare described in section4.2and a complete list can be found inthe supplementary material.
our approach can be easily extended to collect version information for other components by adding the corresponding systemcommands as describedabove.
.
version incompatibilitydetection after collecting version information of required dl stack components and local dl stack components decidedetects version incompatibilitiesinthefollowingsteps.foreachrequireddlstack component u1d45f u1d450 u1d456 u1d456 decidefirst checks if it is installed in the local machine.if u1d45f u1d456islocallyinstalledwithaversion u1d463 u1d456and u1d463 u1d456isintherange u1d450 u1d456 decideconsiders there is no version issue and moves on to the next component.
otherwise decidereports a dependency issue andinfersthecorrectversionof u1d45f u1d456.toinferthecorrectversion decidefirstqueriestheknowledgegraph u1d43e u1d43atogetasetofcandidate versions u1d446 u1d456 u1d4601 u1d4602 ... u1d460 u1d45b sortedintheascendingorder.foreach candidatein u1d446 u1d456 decidecheckifitiscompatiblewitheachinstalled componentinthelocaldlstackbyqueryingtheknowledgegraph.
then decidechooses the candidate with the latest version u1d460 u1d45a m n which is compatible with every other component in the local stack.
it then pushes u1d45f u1d460 u1d45a u1d456into a stack u1d449to keeptrack of the installedorfixedcomponentversions.
deciderepeatstheprevious stepstocheckalltherequireddlstackcomponents.duringthis process if decidecannot infer a component version that satisfies the required version constraint and is compatible with all other components in the local stack decidefirst backtracks to the previousinferencestepandpopsuptheinferredcomponentin u1d449.itwill thenpickanotherversioncandidateofthatcomponentin u1d446 u1d456and continuetheprocess.if u1d449isempty then decidereportsnosolution canbe found.
duringthis process everytime decidereports aversionissueorrecommendsacompatibleversion italsoreports the so posts where the in compatibility knowledge is extracted to help developers understand the issue or recommendation.
for each project in the evaluate benchmark detailed in section .
decide is able to detect and report version issues within minute without using gpu.
evaluation we conduct experiments to answer five research questionsbelow rq1 howeffectivelycan decidedetectversioncompatibility issuesinreal dl projects?
714esec fse december3 san francisco ca usa zhongkai zhao bonan kou mohamedyilmaz ibrahim muhao chen andtianyi zhang rq2 howaccurate isthe extractedknowledge inthe resulting knowledge graph producedby decide?
rq3 howaccuratelycanthepre trainedqamodelin decide infercompatibilityrelationsbetweenversioneddlcomponents?
rq4 to what extentcandifferent questiontemplatesaffectthe accuracyofthe pre trainedqa modelin decide?
rq5 to what extent can different knowledge consolidation strategies affect the accuracy of the resulting knowledge graph?
.
version incompatibilitydetection .
.
benchmark construction.
to evaluate the performance of decideon real life deep learning projects we created a benchmark consistingof 10popular dl projectsfrom github.to create this benchmark we first searched for deep learning projects on github that have at least stars and have a requirements.txt file.giventhesearchresults werandomlysampledonedeeplearning project at a time and manually checked whether it contains theimplementationofadeeplearningmodel.then wemanually reproduceditonourlocalmachinetocheckifitindeedcontains versionissues.ourlocalmachineincludesaubuntu18.04ltswith an intel x86 cpu and one rtx a5000 gpu.
the default python versionis3.6andthenativecudaversionis11.
.wecontinued this process until we found projects with at least one version issueonour local machine.
table5showsthenamesandstatisticsofthese10dlprojects.
on average these projects have stars lines of code and .
version issues.seven of them are computer vision models two arenaturallanguageprocessingmodels andoneisagraphicalneuralnetwork.toensureacomprehensiveidentificationofversion incompatibility issues we reproduced each project ensured that the model could run successfully without errors and documented allencounteredversionissuesduringthereproductionprocess.we get version issues from the projects in total.
of these issues involve components at the same level while issues involve componentsbetweentwodifferentlayers e.g.
incompatibilitybetween tensorflow and cuda.
specifically issues involve a library component involve a runtime component involve a driver component 1involvesanos containercomponent and1involves ahardwarecomponent.detailsoftheseversionissuescanbefound inour artifact .
table benchmarkprojectstatistics project name star loc domain issue tkipf gcn gnn chonyy ai basketball analysis cv fidler lab polyrnn pp cv taki0112 stylegan tensorflow cv rishizek tensorflow deeplab v3 plus cv cfernandezlab cfl cv nvlabs noise2noise cv localminimum qanet nlp kaonashi tyc rewrite cv gaussic text classification cnn rnn nlp avg .
median .
.
comparison baselines.
we compare our tool against two state of the artapproaches pyego andwatchman watchman extractsdependencyrelationsbetweenthirdpartypythonpackagesfrompypidocumentationandusesthe extracteddependencyrelationstodetectdependencyconflictsof installedpackagesinapythonproject.weusedthepublicweb interface of watchman from its official website for evaluation.
this web interface takes a text file of installed packages as input and outputs potential dependency issues among the packages.tocouplewiththisinputformat foreachdlproject in the benchmark we listed all locally installed packages and their versions as well as any missing package and its version constraint specifiedin requirements.txt inatext file and uploadedittothewebinterfaceofwatchman.theversionissues reported by watchman will be used to compare with the ground truth.
pyego extractsdependencyrelationsbetweenpythonpackages pythoninterpreters andsystemlibrariesbasedonpypidocumentation python documentation etc.given a python project itusestheextractedknowledgetoinferthelatestcompatibleversionsofrequireddependenciesfortheprojectbasedonthesource code.weusedthepyegoimplementationfromitsgithubrepository for evaluation.
given a dl project we used pyego to infer a set of compatible versions for the required dl components.
then we compared the inferred versions of required components with the versions of locally installed components to detectversionissues.
.
.
evaluationresults.
table6showstheprecison recall andf1 score ofdecide watchman and pyego.
overall decideachieves .
precisionand64.
recall significantlyoutperformingwatchman and pyego.
the success of decidecan be attributed to two factors.first decideiscapableofdetectingversionissuesacross allfivelayersinadlstack whilepyegoandwatchmancandetect version issues in at most two layers i.e.
library and runtime .
for example an issue is caused by the incompatibility tensorflow .
.3and cuda .
which involved the library layer and the driver layer.
however both watchman and pyego do not contain version knowledge related to hardware drivers in their knowledge base sotheyignorethisissueorreportthelatestlibraryversion that is compatible withotherthird party librariesandthepython runtime version.
in our benchmark a majority of version issues involve the driver os container and hardware layers.
figure shows the number of version issues detected by decide watchman andpyegoondifferentdlstacklayers.second deciderelies onversioncompatibilityknowledgeextractedfromthousandsof so posts which is more comprehensive and up to date than the information sourcesofpyego andwatchman.
table accuracyofversionincompatibilitydetection precision recall f1score watchman .
.
.
pyego .
.
.
decide .
.
.
715knowledge basedversionincompatibilitydetectionfordeep learning esec fse december3 san francisco ca usa figure6 thenumber ofversionissuesdetectedby decide pyego andwatchman ondifferentdlstacklayers .
knowledge graphquality to evaluate the accuracy of the extracted knowledge in the knowledgegraphproducedby decide werandomlysampled343version in compatibilityrelationsfrom3 124relationsintheknowledge graph.
this sample size is statistically meaningful with a confidence interval.
for each relation the first two authors independently verified whether the relation is true by searching online.
then they compared their verification results and resolved any disagreement.thecohen skappascorewas0.
.overall 287of the relations are verified to be correct indicating a high accuracy .
.
there are three reasons for the inaccuracy.
first oftheincorrectrelationswereduetothemismatchbetween acomponentnameandaversionnumber.
wereduetoincorrect predictions from unifiedqa.
were due to incorrect version knowledge sharedinthe originalso post.
.
pre trainedqa model performance when constructing the knowledge graph unifiedqa received a totalof5 532queries i.e.
aquestionandaparagraphfromso to predict compatibility relations between two dl components.
thus toevaluatetheaccuracyofunifiedqa werandomlysampled360 ofthe5 532queries.thissamplesizeisstatisticallysignificantwith a confidence interval.
the first two authors independently validatedeachqueryresultanddiscussedanydisagreements.the cohen s kappa score for this step was .
.
we found that unifiedqa achieved .
precision and .
recall on these queries.therearethreereasonsforincorrectpredictions.first oftheincorrectpredictionswerebecauseunifiedqamisunderstood the question.
second for of the incorrect predictions the two dlcomponentswerejustmentionedinthegivenparagraphand didnothavedependencyrelationships.thus thereisnoversion knowledgetoextract butunifiedqastillpredictsarelation.finally of the incorrect predictions were due to a mismatch of components and their versions in the query.
this is more of an error propagatedfrom the previous dl componentrecognitionstep.
.
questiontemplatedesign question prompt design is a classic problem when applying pretrainedqamodelstodownstreamtasks .inthisexperiment we designed8questiontemplates as shownintable .wemeasured theprecisionandrecallofeachtemplateonthesamesampleof360 relations as in section .
.
table7shows the model accuracy whenusing differentquestion templatesto extract version compatibility knowledge.amongeightquestiontemplates q7 i.e.
doesawork withb?
achieves the bestperformance.
table qamodelaccuracyofdifferentquestiontemplates question precision recall question precision recall q1 .
.
q5 .
.
q2 .
.
q6 .
.
q3 .
.
q7 .
.
q4 .
.
q8 .
.
previous work has attempted to ask alternative questions to a qa model and ensemble the answers to improve the robustness and consistency of the qa model .
inspired by this we also experimented with three different combination strategies to check if they indeed improve the model accuracy in our approach.
the first combination strategy is to combine two questions with opposite phrases e.g.
isacompatiblewithb?
and isanotcompatiblewith b?
.thesecondcombinationstrategyistocombineallquestion templates with positive phrases q1 q3 q5 q7 and all templates with negative phrases q2 q4 q6 q8 .
the third combination strategy is to simply combine all eight question templates.
given a combinationofquestiontemplates decidewillgenerateacorrespondingsetofquestionsandretrievemultipleanswersfromthe unifiedqa.
for each question template the unifiedqa forwards thequestiontogetherwiththecontextandgetsacross entropyloss value that measures how confident the model is aboutthe answer.
then itselectstheonewiththelowestlossvalueasthefinalanswer following the ensemble methodin the previouswork .table8 showsthemodelaccuracywhenusingdifferentcombinationsof questiontemplates.wefoundthatcombiningmultiplequestions doesnotalwaysleadtobetterperformancecomparedwithusing a single question.
for example when combining questions with all positive phrases together q1 q3 q5 q7 the precision and recall become worse compared with using q7 alone.
among all combinations combiningq1andq2achievesthebestperformance .
precision and .
recall while the improvement over the bestindividualtemplate q7 ismarginal.
table accuracyofcombined questiontemplates question precision recall question precision recall q1 q2 .
.
q5 q6 .
.
q3 q4 .
.
q7 q8 .
.
q1 .
.
q2 .
.
q1 .
.
.
knowledge consolidation design the knowledge consolidation module of decideaims to eliminate redundancies and reconcile conflicts in the prediction results of the qa model.
we tried three different knowledge consolidation strategies majorityvote i.e.
selecttherelationpredictedbythe majorityofposts weightedmajorityvote i.e.
selecttherelation predictedfromthesopostswhosetotalsoscoreisthehighest vote by loss i.e.
select the predicted relation with the lowest loss value .
in the resulting knowledge graph in compatibility 716esec fse december3 san francisco ca usa zhongkai zhao bonan kou mohamedyilmaz ibrahim muhao chen andtianyi zhang relationswereconsolidatedfrommultiplepredictedrelations.thus we randomly sampled of the relations and retrieved the originalpredictionsfromunifiedqa.thesamplesizeisstatistically significant at a confidence interval of .
then we evaluated the three strategies on this sample and compared the consolidation results to the ground truths which were manually validated by the firstauthor.notethattofullyevaluatetheknowledgeconsolidation strategies weexcluded25 incorrectrelations that werecausedby themismatchbetweencomponentnamesandversions.theresults showed thatthe majority vote strategyachieves the best accuracy .
followed by voting by loss .
and weighted majority vote .
.yettheaccuracyvarianceamongthesethreestrategies issmall.thisresultimpliesthat unlikequestiontemplatedesign knowledgeconsolidationdoesnothaveasignificantinfluenceover the knowledge extractionpipeline.
discussion ourexperimentresultsdemonstratetheeffectivenessofleveraging the rich version knowledge shared on stack overflow to detect versionincompatibilityissuesindeeplearning.furthermore we demonstrate the feasibility of leveraging pre trained qa models to extract version compatibility knowledge from online discussions.thisissignificantsincegiventhesuperiorperformanceof pre trained large models on text data our approach can more accurately reasonabout thedeep semantics innatural language narratives compared with rule based systems.
our experiment results alsodemonstratethat withcarefulpromptdesign usingthepretrainedqamodelwithoutfinetuningcanalreadyreachareasonable accuracy .
precision and .
recall as shown in section .
.
in this work we proposed a pipeline for generating a largescale and high quality knowledge graph which is easily extensible withmoresoposts.fornow decideonlybuildstheknowledge graphfromsopostsconcerningdlprojects versionissues.future researchers can extend this knowledge graph and apply it to other tasksbyaddingmorediversesoposts suchasdetectingversion issues in java projects by extending the knowledge graph with so posts concerning java ecosystem.
comparison to chatgpt.
given the recent advances in large language models llms such as chatgpt one alternative solution is to directly ask llms whether two versioned libraries are compatible or not.
we investigated this by prompting chatgpt gpt3.
withthetemplate is compatible ?
.
specifically we tested chatgpt on all pairs of incompatible dl components from our benchmark as well as randomly sampledpairs of compatible components.
we foundout thatchatgpt correctlypredicted12incompatiblerelationsand211compatible relations.whilechatgptachievesadecentrecall .
onthe benchmark itachievesamuchlowerprecision .
comparedto ourtool .
.thisfindingsuggeststhatchatgptindeedobtains some dl compatibility knowledge.
however chatgpt may still generatehallucinatedknowledge whichpreventsitfromaccurately identifying versionissuesindl projects.
threats to validity.
in terms of internal validity one threat is the smallbenchmarkusedtoevaluate decide.sofar thisbenchmark containsonly10dlprojectsfromgithub.whiletheseprojectsare popular projects at least stars from different dl domains ourexperimentcanstillbenefitfromalargerbenchmarkwithmore domains.
in the future the authors will expand the current benchmark to include more dl projects.
furthermore given the large numberofprocessedsoposts wecannotmanuallyvalidateeach one of themto evaluatethe accuracy of our knowledge extraction pipeline.thus weinspectedrandomsamples whichmayleadto impreciseestimation.wemitigatethisthreatbyusingastatistically significant sample size at the confidence interval.
in terms of external validity the current implementation of decideonlysupports48populardlstackcomponents.while decide has been demonstrated to effectively extract version knowledge ofthesepopularcomponents itmaynotbeabletoextractuseful knowledgefordlcomponentsthatarerarelydiscussedonstack overflow whichdiminishesitseffectivenessforversioncompatibilitydetection for thosecomponents.
in termsofconstruct validity wecannot guarantee the dl stack component recognition algorithm always correctly assigns the versionnumberstotheintendedcomponent.considertheexample answer v2.
try to install tensorflow .
on your python.
since the current implementation of decideis designed to match as manycomponent versionpairsaspossible v2.0willbeincorrectly matched with python although it only indicates we are reading the secondedition ofthis answer.
future work.
there are several interesting future directions to explore for this problem.
first decidecurrently only extracts knowledge from so posts.
other types of documents such as pypi documentationandgithubissuepages alsocontainknowledgerelevant to library versions.
thus it is worthwhile extending decide toextractknowledgefromothertypesofonlinedocuments.specifically the knowledge consolidation process needs to be redesigned tomergeknowledgeextractedfromdifferenttypesofdocuments whileaccounting for their credibility recency andpopularity.
second decidecanonly detectversionincompatibilities without automatically repairing the version issues in dl projects.
however the knowledge graph generated from so discussions contains knowledgeofcompatiblerelationsbetweendlcomponents.inthe future weplantoinvestigateeffectiverepairstrategiesbasedon the knowledge graph.
finally although the pre trained qa model in decidecan extract version knowledge with reasonable accuracy .
precision and .
recall its accuracy could be further improved with finetuning.
in the future we plan to fine tune unifiedqa by creating a largesetofsopostslabeledversioncompatibilityrelationships.alternatively we can also substitute unifiedqa with stronger llms such as chatgpt to extract version knowledge from so posts.
recentworkhasdemonstratedthatchatgptachievesgoodperformanceinknowledgeextraction .therefore webelieve it is a promising direction to improve decideperformance by substituting unifiedqa withchatgpt.
related work .
version incompatibilitydetection there is a large body of literature on version incompatibility detection .
those most related to our workaretechniquesdesignedforthepythonecosystem .
wang et al.
proposed watchman which collects the metadata 717knowledge basedversionincompatibilitydetectionfordeep learning esec fse december3 san francisco ca usa ofeachpypiprojectandconstructsaknowledgebasze.itgenerates andtraversesadependencygraphtolookforversionincompatibilitiesamongagivenlistofthird partypythonpackages.yeetal.
proposed pyego which automatically infers the latest compatible versionsforrequireddependenciesinpythonprojects.theyconstructed a knowledge graph that stores relations and constraints amongthird partypythonpackages thepythoninterpreter and systemlibraries.theknowledgeiscollectedfromofficialdocuments suchaspypiandpythonofficialwebsite.snifferdog constructs anapibankthatmapsapistodifferentversionsofpythonpackages.
with this bank snifferdoginfers required package versions for jupyter notebooks from api usage.
since these techniques only extract dependency relations from official documents such as pypi metadata theycannotdetecterrorsinthedriver os container and hardwarelayerinadlstack.bycontrast decideusesapre trained qamodelto extractversionknowledgefromonline discussions whichare more comprehensive andup to date.
there are also some version incompatibility detection approaches for other ecosystems such as java and javascript .patraetal.
proposedconflictjs whichdetectsconflicts injavascriptlibrariesbyidentifyinglibrariesthatwritetothesame globalmemorylocation.heetal.
proposedictapifinder which usesaninteger proceduraldataflowanalysisframeworktoidentify incompatibleapiusagesinandroidapplications.however these techniquescannotbeappliedtopython baseddlprojectsdueto the languagedifference.
.
knowledge extractionfrom se documents several approaches have been proposed to extract api knowledge or insightful sentences from api documents and so discussions .
someofthemperformknowledge extraction with rule based pattern matching .
for example li et al.
developed a set of linguistic patterns to extract ten types of api usage sentence level caveats from so posts.
recently moretechniqueshavesoughttoimprovetheirflexibilityinprocessing se documents via neural networks.
for example liu et al.
trainedafeed forwardneuralnetworktoclassifydescriptivesentences of apis from api documentation.
similarly deeptip usesacnnmodeltoextractsentence levelapiusagetipsfromso postswith atrainedcnn model.comparedwith previouswork our approach performs a more fine grained knowledge extraction that requires a delicate recognition of dl components followed by inference of their relationship rather than classifying sentences.
furthermore previousneuralapproachesneedtoacquirealarge labeleddatasetfirstandtrainamodelfromthescratch.however our approach makes use of a pre trained qa model and demonstratesthefeasibilityofachievingareasonableaccuracywithout finetuning throughcarefulquestiontemplate design.
conclusion this paperpresents decide a knowledge based version incompatibilitydetectionapproachfordeeplearningprojects.thekeyinsight is to leverage the abundant version compatibility knowledge from stack overflow to facilitate the detection of version incompatibilities.specifically decideusesapre trainedquestion answering qa model to extract version compatibility knowledge from thefree form text in online discussions.
compared with existing rulebased knowledge extraction systems utilizing a pre trained qa modelempowers decidetoreasonaboutthedeepsemanticsinnaturallanguagewithouttheneedofacquiringdomain specificdatato trainamodelfromscratch.theevaluationresultsdemonstratethat ourapproachcanextractversionknowledgewith84 accuracyand canaccurately identify65 of known versionissuesin 10popular dl projects with a precision significantly outperforming two state of the artapproaches.
acknowledgment theauthorswouldliketothanktheanonymousreviewersfortheir valuable comments.
this research was in part supported by an amazonresearchawardandaciscoresearch award.