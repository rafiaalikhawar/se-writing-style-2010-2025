dynamic update for synthesized gr controllers gal amram tel aviv universityshahar maoz tel aviv university itai segall nokia bell labsmatan yossef tel aviv university abstract reactive synthesis is an automated procedure to obtain a correct byconstruction reactive system from its temporal logic speci cation.
gr is an expressive fragment of ltl that enables efficient synthesis and has been recently used in different contexts and application domains.
in this paper we investigate the dynamic update problem for gr updating the behavior of an already running synthesized controller such that it would safely and dynamically without stopping start conforming to a modi ed up to date speci cation.
we formally de ne the dynamic update problem and present a sound and complete solution that is based on the computation of a bridgecontroller.
we implemented the work in the spectra synthesis and execution environment and evaluated it over benchmark speci cations.
the evaluation shows the efficiency and effectiveness of using dynamic updates.
the work advances the state of the art in reactive synthesis and opens the way to its use in application domains where dynamic updates are a necessary requirement.
acm reference format gal amram shahar maoz itai segall and matan yossef.
.
dynamic update for synthesized gr controllers.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction reactive synthesis is an automated procedure to obtain a correctby construction reactive system from its temporal logic speci cation .
rather than manually constructing an implementation of a reactive controller and using model checking to verify it against a speci cation synthesis offers an approach where a correct implementation is automatically obtained for a given speci cation if such an implementation exists.
gr is a fragment of linear temporal logic ltl that has an efficient symbolic synthesis algorithm and whose expressive power covers most of the well known ltl speci cation patterns of dwyer et al.
.
gr speci cations include assumptions and guarantees about what needs to hold on all initial states on all states and transitions safety and in nitely often on every run justice .
gr has been used in several application domains e.g.
to specify and implement autonomous robots control protocols for smart camera networks distributed control protocols for .
this work is licensed under a creative commons attribution international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
vehicle management systems and device drivers .
several tools support gr synthesis .
many reactive systems are very difficult or very expensive to stop.examplesincludemissionandbusinesscriticalsystemswhose continuous operation is one of their key requirements.
thus whenupdatesinfunctionalityarerequired thebehaviorofsuchasystemhastobeupdatedwhileitisexecuting.indeed ourmainmotivation for the present work comes from a proof of concept project we have conducted on using reactive synthesis in several application domains asacollaborationbetweentelavivuniversityandnokia belllabs.dynamicupdatewaspresentedbytheindustrypartner as a necessary requirement for the use of reactive synthesis in the target application domain.
inthisworkwepresentaformulationandsolutionofthe dynamic updateproblemforsynthesizedgr reactivesys tems.
specifically givenanalreadyexecutingcontroller c1 synthesized from some gr specification spec1 and given anew gr specification spec2 we formalize a notion of an update strategy a strategyforthesystemtoforcetheexecutiononapathfromthe current state of c1to some state of c2 a controller synthesized fromspec2 while taking some steps in compliance with spec1and from some point on start taking steps in compliance with spec2.
notethatanupdate strategyexecutionstartsfromthecurrentstate ofc1 which is a moving target.
the dynamic update problem is to compute and then execute such an update strategy if one exists.
we solve the dynamic update problem for gr by showing how to construct a bridge controller which implements an updatestrategy andapplyitto c1dynamically whileitisexecuting.we provethatoursolutioniscorrectandcomplete i.e.
thatwhenan update is possible we find one and execute it and when an update is not possible we report so.
we further prove that our solution is optimal i.e.
that it minimizes the maximal possible bridge length.
finally we present a heuristic optimization based on the early detectionofasuccessfulupdate whichaimstosavecomputation time and to shorten the length of the actualbridge that is executed.
this optimization is one of the unique features of our work taking advantage of the dynamic nature of the problem.
an important characteristics of our setup and algorithms is that they are symbolic.
thus the update strategy we compute is a symbolic representation of all possible correct and shortest bridges.
then the actual bridge that will be executed depends on the state in which the running controller might be in when the bridge is ready and of course on the behavior of the environment.
note that the dynamic update problem is relevant for setups where the synthesized controller is implemented in software as in e.g.
various robotics setups and not in setups where itisexpectedtobeimplementedasahardwarecircuit e.g.
inthe aigerformat usedinthesyntcompcompetitionseries .
ieee acm 44th international conference on software engineering icse icse may pittsburgh pa usa gal amram shahar maoz itai segall and matan yossef indeed oursolutiontakesadvantageoftherecentlypresentedjustin timereactivesynthesis whichisapplicableonlytosoftware implementationsof synthesized controllers.
we have implemented dynamic updates on top of the opensource spectra synthesis and execution environment .
given an already executing synthesized system the implementation al lows the engineer to define a new specification and dynamically update the executing system to comply with it.
we deliberately divide the implementation between two machines that communicate overtcp themachinethatrunscontrollerand bridgesynthesis andthemachinethatexecutesthecontroller e.g.
arobot .thus ourimplementationsupportsatrulyremotedynamicdeployment asisindeedrequiredinthetargetapplicationdomaindefinedby nokia bell labs.
we evaluated our work using three sets of benchmark specifications.theevaluationshowstheefficiencyandeffectivenessofour work.
all examples and experiment results we report on in this paper are implemented in spectra and available in supporting materials .
the dynamic update problem for synthesized controllers has beenstudiedbefore.inparticular nahabedianetal.studieddynamic updates in the context of event based controller synthesis .
our work is distinctive in several ways most notably a in its applicabilityandexpressiveness supportforthegr fragmentofltl including safetiesandjustices with acomputationmodel that is not specific to event based specifications and b in itsefficiency and scalability thanks to the symbolic nature of the algorithms and implementation.
we discuss related work in detail in sect.
.
.
an illustrative running example to demonstrate the dynamic update problem and our solution we consider a variant of the obstacle evasion specification which isinspired by robotic motion planning and was recently used as a benchmarkinthesynthesisliterature see e.g.
.moreover thisproblemisverysimilarinnature size andexpectedupdates to the target application developed in nokia bell labs a general platform for scheduling the activities of several robots while they patrol and perform different tasks in an environment with several target locations and obstacles.
the target locations the specifictasks and the location of most obstacles are fixed during mostnormal execution but do change dynamically from time to time.
scalabilityintermsofthenumberoflocationsanddynamicupdate without stopping are considered critical requirements.
consider a single cell sized robot and a cells sized obstacle bothmovingonan n ngrid.initially therobotandtheobstacle start in two opposite corners of the grid.
both the robot and theobstacle can move to any adjacent cell.
the robot moves twice upon every step of the obstacle.
moreover the obstacle chases the robot and always tries to get closer to it.
the problem is tosynthesize a strategy for the robot so that collision never occurs regardless of the obstacle s behavior.
we model the robot s and obstacle s locations via two coordinates robx roby ... n and obsx obsy ... n .1weprovidethecompletespecification with simulation videos in supporting materials .
1the coordinates specify the location of the obstacle s upper left corner.
... 2pred robotloc x y robx x r o b y y locations the robot must never visit 5gar avoid1 g!robotloc 6gar avoid2 g!robotloc 7gar avoid3 g!robotloc 8gar avoid4 g!robotloc locations the robot must visit infinitely often 11gar alweventuallyvisit1 gfrobotloc 12gar alweventuallyvisit2 gfrobotloc 13gar alweventuallyvisit3 gfrobotloc a switching condition 16switch robotloc listing examples of safety avoid guarantees justice alwaysvisit guarantees and a switching condition using spectra syntax.
these are the parts of the specification that may be updated from time to time in our example.
in addition to evading the moving obstacle in our specification the robot has some safety guarantees to avoid certain locations avoid guarantees and some justice guarantees to visit some other locations infinitely often always visit guarantees .2we provide an example of such guarantees in lst.
.
fig.
illustrates our example grid world.
mostimportantlyforthedynamicupdatecontext theavoidand always visitguaranteesmaychangefromtimetotime.specifically weconsiderthatduringthecontroller sexecution thesystemrequirementsmaychange sotheengineershavetoupdatetherobot s avoidandalways visitguarantees whiletherobotisrunningand as it continues to evade the moving obstacle.
moreover we include an optional switching condition cond specified by the declaration switch.the switchingconditionrequires therobottoswitch to thenewspecificationonlyinastatewheretheassertion condholds.
again the need for supporting an optional switching condition as partofthedynamic updateproblem isarequirementdefinedby nokia bell labs.
notethatthisexamplesynthesisproblemisnottrivial.asthe robot evades the obstacle that chases it it has not only to avoidcertain locations but also to always eventually visit some otherlocations.
since the obstacle is chasing it in order to make sureit can visit a location the robot sometimes has to first lure the obstacle to move farther from the target location in point and then whentheobstacleisfarenough racetogettothetargetinpoint before the obstacle gets there or blocks the way.
on top of this non trivial behavior we add here the dynamic update of the avoid and always visit locations.
we now demonstrate the dynamic update use case.
the engineers have synthesized a controller from an obstacle evasion specificationandstartedexecutingitonarobot.usingthiscontroller the robot evades the moving obstacle that chases it while avoidingsomecellsandalwayseventuallyvisitingsomeothercells as specified in the specification.
after some time the requirementschange so the engineers write a new specification that includesup to date avoid and always visit guarantees and optionally aswitching condition .
thus while the first controller is running the engineers use our tool to synthesize a controller for the new 2this is an instance of the patrolling pattern from .
787dynamic update for synthesized gr controllers icse may pittsburgh pa usa figure1 anillustrationofourexampleinagridworldwitharobot that has to avoid the acells and always visit the vcells all while evading a 2x2 moving obstacle chasing it.
specificationand mostimportantly abridge controller.then ifthe bridgecoversthestateinwhichthefirstcontrollerhappenstobe atwhenitisready thebridgeforcestheexecutionoftherobotto takesomestepsincompliancewiththefirstspecification reacha statethatsatisfiestheswitchingcondition e.g.
robotloc seelst.
andfromthatpointonstarttakingstepsincompliance withthenewspecification eventuallystartingtoexecuteusingthe new controller.
preliminaries .
reactive systems givenasetofbooleanvariables v astatesovervisasubsetof v i.e.
s 2v.ifs1 ... snarestatesoverthedisjointsets v1 ... vn resp.
we write s1 ... sn as an abbreviation for s1 sn.a n assertion overvisabooleanformulaover v.foranassertion andastate s wewrite s if isevaluatedto truebyassigning trueto all variables in sandfalseto variables in v s.i fs wesay that sisa state.for asetof variables v v primeisthe setof variablesobtainedbyreplacingeach v vwithitsprimedversion v prime v prime.
furthermore for a state soverv s primeis a state over v prime defined by s prime v prime v s .
a reactive system repeatedly reacts to inputs coming from its environment.
this interaction is modeled as a two player game played between the environment player and the system player.
at each turn the environment provides an input and the system replieswithanoutput.thisinteractionisformallycapturedthrough a game structure.
agame structure is a tuple gs x y e s e s 3where xisthesetofvariablesownedbytheenvironment yisthe setofvariablesownedbythesystem anditisdisjointto x eis anassertionover x whichconstitutesthe initialassumptions ofthe 3some presentations use a game structure that includes a graph and a winning condition formula.
in our notation they are separate.
the difference is only notational.environment sisanassertionover x y whichconstitutesthe initialguarantees ofthesystem eisassertionover x y x prime whichconstitutesthe safetyassumptions oftheenvironment and sis an assertion over x y x prime y primewhich constitutes the safety guarantees of the system.
intuitively a game structure models the two player game describedabove asfollows.
first the environmentchoosesan input s0x 2xsuchthat s0x e andthesystemreplieswithanoutput s0y 2ysuch that s0x s0y s. s0x s0y forms the play s first state and then the players repeatedly construct the next states by choosing inputs andoutputs.
fromstate s the environmentcan choose aninputsx 2xif s s primex e andthesystemcanrespondwith sy 2yif s s primex s primey s. game structures naturally extend to finite type variables which are not necessarily boolean.
example .
.
for the obstacle evasion example see sect.
.
x obsx obsy andy robx roby .theinitialassumptionsand guaranteesare e obsx obsy s robx roby .thesafetyassumptionsmodelthewaytheobstaclemoves toan adjacent cell at each step .
the safety guarantees are a conjunction of movement restriction two cells at most at each step and the avoid guarantees from lst.
e.g.
robx nequal2 robx nequal1.
letgs x y e s e s be a game structure.
the game structure sstatesare2x y.atransitionfromstate stostatetis consistent with e resp.
s e s i f s t prime e resp.
s e s .
consistency with eis defined also when t 2x.a transitionthatisconsistentwith e resp.
s e s iscalleda e transition and resp.
for the others .
a sequence of states is consistent with e resp.
s e s if anypair of consecutive states init isconsistentwith e resp.
s e s .a state sisadeadlock for the environment if sx 2x s s primex negationslash e .sis a deadlock for the system if sx 2x s s primex e sy 2y s s primex s primey negationslash s .
aplayis a sequence of states such that the first state in the sequence s0 e s any pair of consecutive states in the sequence is consistent with e s and the sequence is either infinite or ends in a deadlock.
the system employs a strategy to repeatedly choose the next output.thisoutputdependsonthegiveninputandonthestates traversedsofar.a strategyisapartialfunction 2x y 2x 2y.
a state sisconsistent with if for any sx 2xsuch that s s primex e s sx is in the domain of .
we further require that a strategysatisfiesthefollowing if s0 ... si 2x y isconsistent with and si s primex eforsx 2x then s0 ... si sxisinthe domain of forsy s0 ... si sx si s primex s primey s and we say that s0 ... si sx sy is consistent with .
a play is consistentwith ifeveryprefixofitisconsistentwith .w esay that is froms 2x yif everys sis consistent with .
acontrollerisanalgorithmthatimplementsastrategy.therefore acontrollerreceivesastateandaninputasarguments and returnsanoutput.duringaplay thecontrollerisrepeatedlyapplied and reacts to the sequence of inputs produced by the environment.
hence acontrollerretainsmemoryfromoneinvocationtoanother.
remark1.
forthestudyofdynamicupdates weconsidergame structures with no initial constraints since an update occurs from an intermediate state whichdependsontheexecutionofanother runningcontroller.allnotationsdefinedabovearetransferredtogame 788icse may pittsburgh pa usa gal amram shahar maoz itai segall and matan yossef structureswithnoinitialconstraintswithaminorexception wedo not set rules for the initial state of a play.
.
the gr winning condition a gr formula over a set of variables vis a formula of the form m i 1gf je i n j 1gf js j whereje ... jem js ... jsnareassertions over v.gandfare the linear temporal logic ltl operators globallyandfinally resp.
therefore a gr formula statesthatiftheassertions je ... jem thejusticeassumptions hold infinitelyoften then js ... jsn thejusticeguarantees holdinfinitely often as well.
example2.
.
fortheobstacleevasionexample seesect.
.
the justice guarantees are the always eventually visit guarantees in lst.
e.g.
gf robx roby .
for a game structure gsand a gr formula overx y gs is agr specification.
for an infinite play s0 s1 ... we write if there exist k mandi such that j i sj negationslash je k or for each k n there are infinitely many states siin such that si js k. given a specification gs the play wins for the system if ends in a deadlock for the environment or isinfiniteand .astrategywinsfrom statesif any play from s consistent with it wins for the system.
the winning region of a specification is the set of all states from whichawinningstrategyexists.astrategyisawinningstrategyif it wins from every state in the specification s winning region.
problem definition consider a situation in which an engineer synthesized a controller c1w.r.t.somegr specification spec1 andduringanexecution ofc1 new up to date system requirements are defined formulated in a new specification spec2.
apparently the engineer can use spec2to synthesize a new controller c2 stopc1execution and startexecuting c2.however theexecutionofthesystemwedeal withmustnotbestopped itshouldbeupdatedtobehaveaccording tospec2whileitisrunning.hence fromauserperspective once spec2is provided to the synthesizer the controller can take several steps in compliance with spec1and from some point on should satisfyspec2.
belowweelaborateontherequirementsthatanupdate strategy shouldsatisfy.then weformalizethesetoobtainaprecisedefinition of the dynamic update problem.
timingofchangeinenvironmentbehavior.
weassumethat oncespec2is available the environment starts behaving according to its safety assumptions.
this assumption is reasonable when the environment is independent and uncontrollable.
in these cases we adaptspec2immediately asitprovidesanup to dateperspective ontheenvironment sbehavior.however minormodificationsin thesolutionweshallprovidecaptureotherpossibilitiesonemay consider as we elaborate later in remark .
a switching condition.
the dynamic update problem may include a switching condition.
that is an assertion that must hold at the state in which the controller starts obeying spec2 s guarantees.
for example we may require that the switch will occur only when the robot is located at some specified region i.e.
as we have done inlst.
orwhenthedistancefromthemovingobstacleexceedssomethresholdetc.weremarkthattherequirementtoallowthe definitionofaswitchingconditionaspartoftheproblemdefinition came from the concrete case study we work on with nokia bell labs.
note that the switching condition is optional.
if the engineer does not provide a switching condition we consider it to be true.
a bounded switching phase.
werequirethatthesystemupdate unlike e.g.
satisfactionofajusticeguarantee occurswithina boundednumberofsteps.consequently thedynamic updateprob lemformulationexcludesthepossibilityofanunboundedswitchingphase.wethusrequirethatreachingastatethatsatisfiestheswitchingconditionandfromwhich spec2 sguaranteesholdwilloccur withinaboundednumberofsteps.note however thatwedonot assumeagiven fixedbound asinput butonlyrequirethatabound on the length of the switching phase exists.
we now formalize all the above.
note that for the simplicity ofpresentation inthedefinitionbelowweconsiderthatthetwo specificationsaredefinedoverthesamevariables.thisisjustifiedasfollows if spec1isdefinedover x1 y1 andspec2over x2 y2 we mayregardbothasspecificationsover x x1 x2 y y1 y2 since variables that are defined but do not appear in a specification have no effect on its semantics.
definition .
update strategy .
letspec1 gs1 x y e s e s 1 andspec2 gs2 x y e s 2 begr specifications andlet condbeanassertionover x y the switching condition .astrategy isanupdate strategyfromstate s0if assumingtheenvironmenttakesactionsincompliancewith e there exists k such that for every prefix of a play s0 s1 ... sk consistent with there exists siwithi k for which the switching phase prefix s0 ...siis consistent with e s the switching condition holds si cond the switching phase future si si ...is consistent with e s andsi si ... 2. intuitively thestate siindef.
.1isthestateinwhichtheswitch actually occurs.
the system takes s transitions until reaching si sisatisfies the switching condition and the system takes s transitions from si.
if there is no switching condition we set cond true and then item holds vacuously .
definition .
dynamic update problem .
given game structures and a switching condition as in def.
.
compute a strategy and a set w such that is an update strategy from each s w soundness andthereexistsanupdate strategyfromastate siff s w completeness iff such a set and strategy exist.
illustration .
figure 2a illustrates the dynamic update problem.
the red dashed arrow denotes a c1computation that reaches state s0 from which we apply an update strategy.
the update strategy takesseveral e s transitions redarrows untilreachingstate si i 5in our example that satisfies cond marked in green .
from s5 only e s transitions are taken blue arrows .
the suffix of that computation is performed by the controller c2 which ensures satisfaction of spec2.
note that s3also satisfies cond but it isnotour 4spec2does not include initial constraints as such constraints have no role in the dynamic update context see sect.
rem.
789dynamic update for synthesized gr controllers icse may pittsburgh pa usa a update strategy b bridge construction and its execution figure2 illustrationsofanupdate strategyandoursolution.red arrowsdenote spec1 outputs bluearrowsdenote spec2 outputs and green states satisfy the assertion cond switching state since two additional s transitions were taken after visiting it.
example .
.
in our obstacle evasion example the required update strategy is not trivial.
the robot must consider the old and newavoidguarantees whichmayblocksomepaths to andfrom the switching cell do it while observing the obstacle s locationsand reacting to its moves and eventually end up in a state from which the new controller can take over.
solving dynamic update to solve the dynamic update problem we need to synthesize an update strategyorstatethatsuchastrategydoesnotexist.wesolve the problem in two stages.
first we compute the system s winning region w.r.t.
spec2 gs2 2 w2 and synthesize a matching controller c2.i fw2is empty we already know that an updatestrategy does not exist.
second if w2isnotempty wemoveontosynthesizeabridgecontroller b.thebridgeforcestheplayfromthecurrent butyet unknown statein c1intow2 infinitelymanysteps.onitsway thebridgemakessurepassingastatethatsatisfies condafterwhich violationsofthesafetyguaranteesof spec2 i.e.
s arenotallowed.
notethattheconstructionsof c2andthebridge controller bare independent of one another.
c2is constructed from spec2 and the bridgeisconstructedusingareachabilitygame basedontheoldandnew specifications as we elaborate next.
furthermore importantly both constructions are independent of the controller c1 which keeps running typicallyon a separate machine while c2and the bridge controller bare constructed.
the computation of w2andc2is done by a standard gr synthesis and we omit its details.
we turn to describe the construction of the bridge controller and the execution of the update.
finally we discuss correctness optimality and complexity.
remark .
note that the bridge controller that we compute in sect.
.
below does not represent a single possible update.
rather it is a symbolic representation of all possible correct and shortestbridges.
then in sect.
.
we show how a concrete bridge is executed depending on the state in which the running controller might be in whenthebridgeis ready andonthebehaviorofthe environmentin every step of its execution.
.
bridge controller construction to synthesize a bridge controller we extend ywith two variables switchandallowed.
intuitively switchis turned on by the system to mark that we switched to s transitions.
unlike switch allowed is an auxiliary variable i.e.
a variable whose value is uniquely determinedbyitspreviousvalueandbythevaluationofallother variables.
allowedmonitors the play states and evaluates to true onlywhenthesystemisallowedtoswitch ifonly s transitions havebeentakensincevisitinga cond state i.e.
astatewherethe assertion condholds.
we consider the game structure hatwidergs x y switch allowed e s where sis the conjunction of the formulaslistedbelow dividedintothreegroups.
transitions t1 t2 set rules for an appropriate use of s 1and s .switch s1 s3 set rules for the valuation of switch.permission p1 defines how allowedis updated in each step.
hence s logicalanddisplay.
t1 t2 s1 s2 s3 p1 where t1 s s .thesystemmustalwaysfollow spec1orspec2safety guarantees.
t2 switch prime s .whenswitchistrue only s transitionsare allowed.
s1 switch switch prime allowed prime.we turn on switchfor the first time only if we are allowed to.
s2 switch switch prime.onceswitchisturnedon itremainstrue.
s3 s switch prime.whenwetakea s s transition wemust switch.
p1 allowed prime cond s allowed s .allowedis valuatedto trueiff wetakea s transitionfroma cond state or allowedholds and we continue with a s transition.
let hatwidey y switch allowed hatwidev x hatwidey and hatwiderw2 s hatwiderv s x y w2 w2 switch allowed wherefor u v s u denotes the state s uoveru.
let hatwidew hatwidervbe the set of states fromwhichthesystemcanforcereaching hatwiderw2 switch andletbbe amatchingcontroller.thatis bwinsthereachabilitygamewith target set hatwiderw2 switch .
hatwidewandbareconstructedbytheprocedurepresentedinalg.
.
the algorithm employs the modal calculus controllablepredecessor operator which is defined as follows.
let x andybe the environment and system variables resp.
and eand sbe matching safety assumptions and guarantees resp.
for a set of statesw e s w s 2x y sx 2x parenleftbig s s primex e sy 2y s s primex s primey s sx sy w parenrightbig .
that is e s w includes all states from which the system can forcereaching win asingle step for eachlegal inputby the environment the system has a legal output to reach w. consider alg.
and observe that there exists k such that fors hatwidew bforces reaching hatwiderw2 switchfromswithinksteps.
indeed kisthe numberoffixed pointiterations performedinthe 790icse may pittsburgh pa usa gal amram shahar maoz itai segall and matan yossef algorithm computing hatwidewand a matching bridge controller b j z0 hatwiderw2 switch b0 repeat j zj zj e s zj bj bj s t zj zj zj s t prime s untilzj zj hatwidew zj b bj return hatwidew b computation of hatwidew.
in the next subsection we prove that bis the bridge controller we are interested in.
remark3.
toconstruct b onemaysuggestanalternative simpler naive approach to the problem using two reachability strategies a e s reachability strategy with target cond from which we can applya e s reachabilitystrategywithtarget w2.thissuggestion is sound but incomplete i.e.
it may not find all states from which an update strategyexists.forexample considerastate ssuchthat for some e inputs from s the system has a s response that leads the playtoastatefromwhichanupdate strategyexists and forall other e inputsfrom s thesystemhasa s responsethatleadstoa statefromwhichanupdate strategyexists.hence anupdate strategy exists from s but the two phase reachability suggestion above fails to identifys.
remark .
we present switchandallowedas new variables only for the presentation of the bridge construction.
in practice we do notaddthemtothegamestructureandtheyonlyserveasmemory variablesforthebridge controller whenactivatedfrom w hatwidew x y bforces reaching w2withinksteps for some k so that the memory variable switchistrue.
recall that if switchistrue then only s transitions have been taken since visiting a cond state.
remark5.
weconstructthebridgewhileconsideringthesafety assumptions e as we made a design decision to immediately adapt thenewenvironmentassumptions seetheconsiderationswepresented before def.
.
.
other options are easily supported via minor modifications in the game structure hatwidergs.
as an example we can let the controllerchoosewhentheenvironmentswitchesfrom e 1to e by addingafreshsystemvariableandconstrainingtheenvironment s behavior on its value.
likewise we can decide that the change in assumptionswilloccurina cond state whenthesystemswitchesto s 2etc.
these alternatives are relevant for setups where the timing of the change in the environment can be controlled by the system or its operator.
.
execution of the update we are ready to present the execution of the update.
given spec2 s winningregion w2 amatchingcontroller c2 abridge controller b anditswinningregion w alg.2showstheexecutionoftheupdate uas follows.
first if w then an update strategy does not existandweannounceit line0 .otherwise welookatthecurrent play state s0 andcheckwhether s0 w initialactivation i .in cases0 w we proceed to ii the code that we activate from this point on.
in ii we iteratively generate a response sygiven the currentstate sandthe input sx.weapply bfroms0 untilreachingalgorithm the execution of the update u ifw then return switchingcannotbeforcedfromany state i .
initial activation from state s0 ifs0 nelementwthen return switching cannot be forced from the current state ii .
a response from state sand input sx if s nelementw2 switch false thensy b s sx elsesy c2 s sx returnsy w2whileswitchistrue line ii .
.afterwards weapply c2for the remainder of the play line ii .
.
incases0 nelementw wereporttotheengineerthatanupdate strategy doesnotexistfromthecurrentstate line i .
.notethatif s0 nelementw the engineer can try and execute alg.
again as the play may traverse into w. illustration .
figure 2b illustrates a bridge controller b as computedby alg.
andhow itis used.the dashedred arrowrepresents a play prefix induced by the spec1controller c1.
in parallel to this playprefix wecomputethereachabilitybridgecontroller b following alg.
.fortunately thecomputationof bendswhentheplayprefix reachesstate s0 coveredby b.hence thebridgetakescontrol takes two e s transitions redarrows reachesastate siwhichsatisfies cond i 2in our example green states satisfy cond takes an additional e e transition bluearrow andpassescontroltothe spec2 controller c2for the remainder of the play dashed blue arrow .
.
correctness optimality complexity oursolutionissoundandcomplete.ifthereisanupdate strategy we find it and execute it if there is not any we report so.
formally theorem4.
construction correctness .
alg.2issoundand complete the algorithm implements an update strategy from w. there exists an update strategy from siffs w. beyondcorrectness wementionthatthereachabilitystrategy minimizesthenumberofstepstakenuntiltheactivationofthenew controller.
to elaborate the bridge not only minimizes the longest possibleswitchingphaselength denoted k butalsominimizesthe number of steps actually executed denoted j see def.
.
.
both results follow from the next theorem.
theorem .
bridge optimality .
fors w letk s be the minimalintegers.t.thereexistsanupdate strategyfrom sthatsatisfies the conditions of def.
.
with the parameter k s .
then the bridge b forces reaching hatwiderw2 switch from swithin at most k s 1steps.
the proofs of thms.
.
and .
appear in .
finally notethat asymptotically theupdatecontrollersynthesis does not add computational cost to the gr synthesis of the new controller.theconstructionofthebridgeinvolvesasinglefixedpoint loop and is thus computed in o n symbolic operations 5thepossiblesingleredundantstepreportedinthetheoremcanbeavoidedbyaminor modification of hatwidergs.
mainly turning on allowedwhencondis reached.
we decided to give the single redundant step version as it slightly simplifies the correctness proof.
791dynamic update for synthesized gr controllers icse may pittsburgh pa usa algorithm optimized computation of z hatwidewandb replacing alg.
j z0 hatwiderw2 switch b0 repeat s c1 s current state if s switch allowed zjthen stopc1 z zj b bj returnz b end if j zj zj e s zj bj bj s t zj zj zj s t prime s untilzj zj hatwidew zj b bj return hatwidew b wherenisthesizeofthestatespace.thatsaid thenumberoffixedpoint iterations is just the length of the maximal possible bridge and in practice the length of the bridge is orders of magnitude smaller than the state space see our evaluation in sect.
.
remark no overhead accumulation .
our solution enables theseamlessapplicationofasequenceofdynamicupdates.thatis oncetheupdatecompletesandalg.2returnsanoutputfrom c2 c2 controlstheexecution andanotherdynamicupdatecanbeapplied whennecessary.applyingasequenceofupdatescomesatnocostin terms of additional variables and thus no overhead is accumulated.
early detection of success we propose an optimization for the execution of the update u based on a modified construction of the bridge controller.
the optimizationwedescribecanleadtoashorterswitch i.e.
reduce thenumberofstepswetakeuntilswitchingto s transitionsand thus to a gs2 2 strategy.
furthermore the optimization can reduce the computation time of the bridge.
the optimization is based on a simple idea rather than computing the complete bridge band only then checking whether the currentstateoftheexecutingcontrolleriscoveredbyit wesuggest to check before every loop iteration of alg.
whether the current stateoftheexecutingcontrollerwasalreadycoveredbytheset b computed so far.
in case balready covers the current state we can immediately apply alg.
i.e.
apply buntil reaching its target and thenswitchto c2.inotherwords insteadofcomputingallstates fromwhichanupdatecanbeexecuted theoptimizationstopsas soon as the current state of the controller is within the part of the bridge that was computed so far.
this early detection of success allowstostopthecomputationof bandthustoreducecomputation time.
we present this optimized construction in alg.
.
illustration3.
figure3illustratesanoptimizedbridgecomputation ofalg.
.thereddashedarrowrepresentsaplayprefixinducedbythe spec1controller c1.
after the computation of each bridge component we check if the current play state has been covered.
fortunately after the computation of b3 the play reaches s0which is covered by b ascomputedsofar.hence wedonotcomputetheremaining semitransparent set b4thatalg.1wouldhavecomputed.welet btake control and lead the play to b0 from which we activate c2.note that the optimization requires more communication betweenthesynthesizerand c1aswellasmultiplechecksonwhether itscurrentstateallowstoswitch alg.
line4 .thisadditionalcomputation is however negligible as it involves only a small constant number of symbolic operations.
finally notethattheheuristicoptimizationdoesnotcompromise soundness and completeness.
it potentially reduces the numberof steps during the bridge construction and it never adds steps.in our evaluation we present evidence that this optimization is veryeffectiveinreducingthebridge scomputationtimeandactual length when executed.
implementation we have implemented and integrated the bridge construction of alg.
theproposeddynamic updatestrategyconstructionofalg.
and further the optimized bridge construction of alg.
in the spectraspecificationlanguageandsynthesisenvironment .
the implementation consists of two controller constructions a just in time controller forspec2 c2 and a bridge controller bfollowing alg.
or alg.
.
a just in time controller stores an efficientsymbolicrepresentationandcomputesconcretenextstates only when they are required.
the separation between c2andb allowsustoconsidertheaddedvariables switchandallowed only during the bridge phase.
c2does not use these variables neither asgamevariables norasmemoryvariables andthusthejust intimec2is synthesized from the new specification by the standard synthesis procedure of spectra including the heuristics suggested in .
the added cost of the dynamic update synthesis is due solely to the construction of b. in our implementation the bridge controller bminimizes the number of steps taken until we can activate c2.
specifically at each step from the current state s given input in we apply a binary search on the array b0 ... bj 6to find a valid output out such that in out is of lowest index i.e.
closest as possible to the target b0.
note that the array is strictly monotonic i.e.
for allm the set of transitions represented by bmis a strict subset of the set of transitions represented by bm .
the search for the outputouttakeslog b steps where b denotes the length of thearray.clearly log b isboundedbythenumberofvariables x y switch allowed .inpractice ittendstobemuchsmaller.
6for efficiency the actual implementation uses the array of winning regions z0 ... zjratherthanthearrayofcontrollers b0 ... bj.weusethe bnotation for the simplicity of the presentation.
figure optimized bridge construction.
red arrows denote spec1outputs blue arrows denote spec2 outputs green states satisfy the assertion cond.thesemi transparentellipse b4isabasicbridgecomponent that the optimized bridge did not compute.
792icse may pittsburgh pa usa gal amram shahar maoz itai segall and matan yossef hfxwhv 6hqg v wr v qwkhvl hu 5hfhlyh dqg h hfxwh lw i xsgdwdeoh h hfxwh lyhq fkhfn zkhwkhu xsgdwdeoh5hfhlyh dq xsgdwh uhtxhvw rpsxwh dqg dqg vhqg wkhp wr h hfxwru rpsxwh dqg whudwlyho jlyhq hdfk m uhwxuq zkhwkhu xsgdwdeoh i xsgdwdeoh vhqg wr h hfxwru whudwlyho frpsxwh dqg vhqg hdfk m wr h hfxwru hfxwh wkh uhfhlyhg vwhsv ri wkh eulgjh riekj g s jpihqvig lpeieva ranoekj figure dynamic update communication timeline theimplementationisdividedbetweenanexecutorandasynthesizer which communicate over tcp.
it thus supports a truly remotecommunicationbetweenthemachinethatrunssynthesis and the machine that executes the controller e.g.
a robot .
figure4showsthetimelineofcommunicationduringanupdate.
while the executor is executing c1 the synthesizer receives an update request for spec2and synthesizes c2.
then the synthesizer uses alg.
to compute bandw the bridge and the set of states from which the system can force an update and sends them to the executor.
the executor checks whether an update is possible fromitscurrentstateusing wandreturnstheanswertothesynthesizer.iftheanswerispositive theexecutorstartsexecuting b immediately.
while bis executed the executor receives c2from the synthesizer and it starts executing c2right after the bridge execution is completed according to alg.
.
in the optimized version where alg.
is replaced by alg.
the bridge is computed and sent to the executor iteratively untilreaching a bjfrom which the system can force an update.
then the bridge bjconstructed so far and c2 are executed using alg.
.
preliminary evaluation weprovideallthespecifications rawresults andmeanstoreproduce the experiments described below in supporting materials .
.
research questions we consider the following research questions.
rq1.howdoupdate strategysynthesisandstandardgr synthesis compare w.r.t.
running times?
what is the added cost of supporting dynamic update?
rq2.how many steps does it take for the bridge controller to complete and activate c2?
rq3.does our optimization improve performance in terms of a the bridge construction running time and b number of steps taken to complete it?
.
corpus and applied updates ourcorpusincludesthreesetsofspecifications instancesofour runningexample obstacleevasion whichweusetodynamicallyupdate the avoids and always visit guarantees instances of a prioritized arbiter specification a variant of a benchmark from the reactivesynthesiscompetitionsyntcomp whichweuseto dynamically update the identity of the prioritized client and instances of a job scheduler specification which we use to dynamicallyupdateasubsetoftheserversthatgoesdownformaintenance.foreachofthesesets wecreatedmanypairsofspecificationswhere each pair is an example of an update from the first specification in thepairtothesecondspecificationinthepair.wedescribethem below.
configurations based on the obstacle evasion problem.
for everyn andm we created pairs of realizable specifications by adding to the obstacle evasion specification over an n ngrid msafety guarantees randomly chosenmcellsthat therobot mustavoid mjusticeguarantees randomly chosen mcells thatthe robot mustvisit infinitely often and onerandomlygeneratedswitchingconditionoftheform cond robx i roby j i.e.
aconditionthatinstructstherobot to visit a randomly chosen designated cell as part of the updatestrategy see def.
.
.
we denote these pairs by pairs n m .
configurationsbasedontheprioritizedarbiterproblem.
the arbiter the system grants requests raised by nclients the environment .
it must never grant two requests simultaneously it can grant client i s request only when client iraises a request and it mustmakesurethateachrequestiseventuallygranted.weassumethataclientlowersarequestiffitwasjustgranted.finally prioriti zationmeansthatoneoftheclientsisprioritized apendingrequest bytheprioritizedclientmustbegrantedbeforeanyotherclient s request is granted.
we considered variants with n clients.
for each of these we created pairs of specifications with nclients that differ in the identity of the prioritized client.
our switching condition is the assertion no pending request by the prioritized client .
we denote these pairs by pairs n .
configurations based on the job scheduler problem.
the scheduler thesystem assignsjobsofdifferentlengths maxlength k to one of nservers.
the scheduler must eventually assign every incomingjob.onceajobisassignedtoaserver itcannotbereassigned.
when a server is assigned a job of length l k it works on it for lconsecutive states after which it is available for new assignments if any.
a new job must not be assigned to a serverthat is currently down for maintenance.
for every n andk we created pairs of realizable specifications whereupdatesspecifywhichservershouldnowgodownformaintenance.correctupdatestrategiesensurethatexistingjobsthatare already assigned to a server complete before the server goes down for maintenance.
we denote these pairs by pairs n k .
overall ourcorpusincludes1080configurations 16setsofpairs for the obstacle evasion problem sets of pairs for the prioritized arbiter problem and sets of pairs for the job scheduler problem each consisting of configurations.
.
validation to validate our implementation we defined assertions over the behaviorofthesystemexecutionduringandaftertheupdate assertionsonthebridgephase anassertionstatingthattheswitching 793dynamic update for synthesized gr controllers icse may pittsburgh pa usa state satisfies cond and an assertion stating that after the bridge the execution should match the behavior specified by spec2.
we verified these assertions automatically using hundreds of executionlogsofdynamicupdatesoverourcorpus.forexample fortheobstacleevasion weprogrammaticallyverifiedthatinthe logs the robot visits the specified condcell and from then on does not visit the cells it should avoid according to spec2.
.
experiment setups and results our corpus includes pairs of realizable specifications where the second specification also includes a switching condition.
for each pair we performed the following experiment.
first we constructed andexecutedacontrollerforthefirstspecificationinthepair.then weperformedadynamic updatewiththesecondspecificationas the new specification.
for each of the dynamic updates performed we measured the time it took to synthesize the new controller the gr just in time synthesis cost in spectra the time it took to synthesize the bridge controller the cost that the dynamic update taskadds andthe numberof stepstaken bythe bridgecontroller when the update was executed.
we ran all experiments on an ordinary laptop pc intel core i7 cpu .8ghz 8gb ram with ubuntu .
bit os java 64bit andcudd3compiledfor64bit.timeswereportaremedian values of runs measured by java in milliseconds.
although the algorithmswedealwitharedeterministic weperformed10runs since jvm garbage collection and bdd dynamic reordering add variance to running times.
toaddress rq1andrq3 a foreachset ofpairs wereport the median times we obtained.
in tbl.
tbl.
and tbl.
we report median values for dynamic updates between obstacle evasion specifications betweenprioritizedarbiterspecifications andbetween job scheduler specifications.
for example for the obstacle evasion configurations foragridofsize32 32andnumberofsafetiesand justiceguarantees m i.e.
for pairs themediansynthesis timeofanewcontrolleris25.6sec themedianbridgecontrollersynthesis time is .
sec and the median optimized bridge controller synthesis time is .
sec.
hence in tbl.
the cell on row and column new controller reads .
on row no and column bridge reads .
and on row yes and column bridge reads .
.
toaddressrq2andrq3 b foreachperformeddynamicupdate wemeasuredtheactualbridgelengthasexecuted i.e.
thenumberof stepstakenbythebridgecontroller.foreachsetofpairs pairs n m pairs n andpairs n k in tbl.
tbl.
and tbl.
respectively wereportthemedianactuallengthasexecuted.forexample for theobstacleevasionconfiguration pairs themedianactual executionlengthofthenon optimizedbridgeis27steps andofthe optimizedbridgeis11.hence intbl.
thecellonrow no andcolumn length reads27 andonrow yes andcolumn length reads .toanswerrq1 weobservethatthetimethatthedynamicupdateadds i.e.
synthesistime ofthe non optimized bridge is approximatelyofthesamemagnitudeasthesynthesistimeofthe new controller.
in particular this means that as long as the synthesisofspec2isfeasible thedynamicupdateremainsfeasible as well.
toanswerrq2 thelengthoftheactualbridgesasexecutedis small in particular ordersof magnitudes shorter relative to the worst case length see the last paragraph of sect.
.
.
in the arbiter scase bridgelengthisalways1sinceprioritizedrequestsareansweredimmediatelyandthuswearealwaysatmostastep away from a switching condition state.
toanswerrq3 weseethattheoptimizationisefficientandeffective.itreducesthebridgesynthesistimeandimprovesthequalityoftheupdateasitshortensitsactuallength.moreover themore challenging the case the higher the factor of improvement.
.
threats to validity we consider the following threats to the validity of our evaluation.
first our implementation may have bugs.
to mitigate this we performed extensive validation see sect.
.
.
second runningtime measurements have variance due tothe random generation of updates the bdd libraries and the javagarbage collector.
to mitigate we performed every experiment multiple times and report median values see sect.
.
.
third runningtimemeasurementsofouroptimizedversionmay be affected by the time between steps of the controller executor whichisconfiguredinourtestingenvironment.weusedaconstant steptimeforeachsetofspecifications.choosingadifferentstep time could have changed our results.
in reality every system may have a different step time.
fourth we used only three sets of specifications with specific kinds of updates.
we took the specifications from well knownbenchmarks but we do not know if these specifications and up dates are representative of specifications and updates engineers will apply in practice.
that said we chose the obstacle evasion specification because it is very similar to the target application developed bynokia belllabs and we used hundredsof randomly generated updates involving changes in safeties and justices on all three sets of specifications.
finally dynamicupdaterequirescommunicationbetweenthe synthesizerandtheexecutor.ourimplementationofthiscommuni cationisbasedontcp.thecommunicationtimeisstronglyaffected bytheconnectionbetweenthesynthesizerandtheexecutor.for example asynthesizerandanexecutorthatareconnectedviawifi maycommunicate slowerthan asynthesizer andanexecutor that are running on the same machine.
thus our results in this regard areimplementationspecific.onemayobtaindifferentresultswhen using different means of communication.
794icse may pittsburgh pa usa gal amram shahar maoz itai segall and matan yossef m 9grid size optimized?
new controller bridge length newcontroller bridge length newcontroller bridge length newcontroller bridge length 8no0.
.
.
.
.
.
.
.
yes .
.
.
.
16no1.
.
.
.
.
.
.
.
yes .
.
.
.
32no4.
.
.
.
.
.
.
.
yes .
.
.
.
64no29.
.
.
.
.
.
.
.
yes .
.
.
.
table obstacle evasion synthesis times sec bridge computation times sec and actual length as executed clients optimized?
new controller bridge length 70no5.
.
yes .
80no7.
.
yes .
90no13.
.
yes .
100no24.
.
yes .
table prioritized arbiter synthesis times sec bridge computation times sec and actual length as executed related work manyauthorshavediscusseddynamicadaptationingeneralandthe dynamic update problem in the context of synthesized controllers in particular see e.g.
.
baresi and ghezzi present a broad discussion on the motivation for dynamic updates that is for changes to occur as the softwareisrunningandwhileassuringcontinuousdependability.
the combination of synthesis and dynamic updates goes in this direction.
zhang and cheng present a ltl an approach to formally specifyadaptationrequirementsintemporallogic.theyconsider three adaptation variants one point guided and overlap .
one mayviewourworkasimplementingacaseofguidedadaptation where the synthesized update strategy plays the role of the guide.
in another work the same authors present a model based approach to adaptation separating the adaptation behavior and non adaptivebehaviorspecifications anddemonstratedusingan adaptive gsm oriented audio streaming protocol for a mobile computing application.
the two works do not use synthesis for the construction of an update strategy.
la manna et al.
studied a notion of updatable states .
a state is updateable if the concatenation of someexecutions that lead into the state with anyfuture behavior induced by the new controller satisfies the new specification.
their work is specific to assume guaranteespecificationsgivenasuniversalmodalsequencediagrams msds .theydescribearelated tool in butdo not provide an empirical evaluation or complexity analysis.
morerecently nahabedianetal.
proposedatechniquefor dynamic update in the context of event based controller synthesis.
the work supports updates of labeled transition systems ltss specifiedusingltlsafetiesandfluents .itpresentscorrectness criteria and a sound and complete solution.
it considers various complexities of updates e.g.
planned updates and allowing oneto specify the requirements for a transition period where both the old and the new specification may not hold.
it supports the specification of a transition requirement which is similar to ouroptional switching condition.
it is implemented as an extension of the mtsa tool and presents validation through several case studies.
ourworkisdistinctiveinseveralways mostnotably a inits applicabilityandexpressiveness supportforthegr fragment of ltl including safeties and justices with a general computation model thatis notspecific toevent based specifications and b in its efficiency and scalability thanks to the symbolic nature of the algorithms and implementation.
note that the work in uses concretealgorithmswhichinthissensedonotscale.indeed the evaluation in presents transition systems of up to states andmaximumsynthesistimesof5minutes whileourevaluation uses controllers of up to about reachable states from state spaces of 220to 2110states and synthesis times of up to minutes but typically much less.
importantly due to the difference in computation models our main motivating example of obstacle evasion whilepatrollingbetweenlocationsonagrid andtheothersystems we present in our evaluation cannot be modeled and solved using the approach of .
livingstonandmurray suggestedadynamic updatetechniqueforgr restrictedtoaddingorremovingjusticeguarantees.
theiraimistousetheexistingcontrollertoreducethesynthesis time of the modified specification but their solution also works at runtime and thus forms a restricted dynamic update technique.
our work is not restricted to updates in justice guarantees but covers the complete gr including safeties and justices.
anotherrestricteddynamic updatetechniqueforgr isproposedbyshietal.
whosuggesttechniquesforseveraltypes 795dynamic update for synthesized gr controllers icse may pittsburgh pa usa k servers optimized?
new controller bridge length newcontroller bridge length newcontroller bridge length newcontroller bridge length 4no0.
.
.
.
.
.
.
.
yes .
.
.
.
6no0.
.
.
.
.
.
.
.
yes .
.
.
.
8no0.
.
.
.
.
.
.
.
yes .
.
.
.
10no1.
.
.
.
.
.
.
.
yes .
.
.
.
table job scheduler synthesis times sec bridge computation times sec and actual length as executed ofcontrollersynthesisandupdateinruntime toovercomeunexpected accidents caused e.g.
by a malfunction device.
the work does not provide correctness criteria or an evaluation.
finally most recently finkbeiner et al.
present a form of aliveupdateforcontrollerssynthesizedfromltlspecifications withadifferentsemanticsthanours.moreover duetotheuseof ltl unlikeouruseofgr theircomplexityofcheckingwhether an update is possible is double exponential.
conclusion we formulated and solved the dynamic update problem for synthesizedgr reactivesystems updatingthebehaviorofanalready runningsynthesizedcontrollersuchthatitwouldsafelyanddynamically without stopping startconforming toa modified up to date specification.
we formally defined the dynamic update problem in the context of gr and presented a sound and complete solution.
thesolutionisbasedonthesymboliccomputationofanoptimal bridge controller whichguaranteesashortestswitchingphase if one exists.
finally we presented a heuristic optimization based on the early detection of a successful update which may reduce both bridge synthesis times and actual bridge steps when executed.
weimplementedourideasinthespectrasynthesizer.ourevaluation shows the efficiency and effectiveness of our work.
the workopensthewayfortheuseofgr synthesisinapplicationdomains where dynamic updates are a necessary requirement.
wesuggestthefollowingfutureworkdirections.first weconsider developing means to deal with the case of an unrealizable dynamicupdate i.e.
whereswitchingcannotbeforced.7currently our technique is limited to detecting unrealizable dynamic updates butnottofurtherdealwiththem.whenthesystemcannotforce a strategy update it is still possible that an update can be done withthecooperation oftheenvironment.thatis theremayexist a sequence of inputs by the environment that enables a strategy switch.
this calls for synthesizing a cooperative bridge controller.
second we hope to complete the case study of deploying our implementation in nokia bell labs system and report on our experience in a follow up paper.
7notethatthisisdifferentthanthecasewherethenewspecificationisunrealizableby itself whichmaybeaddressedinvariousways e.g.
usingcores counter strategies or repairs .