static stack preserving intra procedural slicing of webassembly binaries quentin sti venart vrije universiteit brussel brussels belgium quentin.stievenart vub.bedavid w. binkley loyola university maryland baltimore md usa binkley cs.loyola.educoen de roover vrije universiteit brussel brussels belgium coen.de.roover vub.be abstract therecentlyintroducedwebassemblystandardaimstobeaportable compilation target enabling the cross platform distribution of programswritteninavarietyoflanguages.weproposeanapproach toslicewebassembly programs in order to enable applications inreverseengineering codecomprehension andsecurityamong others.givenaprogramandalocationinthatprogram programslicingproducesaminimalversionoftheprogramthatpreserves the behavior at the given location.
specifically our approach isa static intra procedural backward slicing approach that takesinto account webassembly specific dependences to identify theinstructions of the slice.
to do so it must correctly overcome the considerablechallengesofperformingdependenceanalysisatthebi narylevel.furthermore fortheslicetobeexecutable theapproach needs to ensure that the stack behavior of its output complies with webassembly svalidationrequirements.weimplementedandevaluated our approach on a suite of real world webassembly binaries finding that the average size of the slices computed is of the original code an improvement over the attainedbyrelatedworkslicingarmbinaries.togainamorequalitativeunderstandingoftheslicesproducedbyourapproach we compared them to source level slices of benchmark c programs.
this inspection helps to illustrate the slicer s strengths and to uncover potential future improvements.
keywords static program slicing webassembly binary analysis acm reference format quentin sti venart david w. binkley and coen de roover.
.
static stack preserving intra procedural slicing of webassembly binaries.
in 44thinternationalconferenceonsoftwareengineering icse may21 pittsburgh pa usa.
acm new york ny usa pages.
https introduction the recent inclusion of webassembly binaries in web applications posesnewchallengeswithrespecttotheirsecurity comprehension and reverse engineering.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
is a binary instruction format for a stackbased virtual machine designed as a compilation target for high level languages.
the specification of its core has been a w3c standardsincedecember2019 .webassemblywasdesignedfor thepurposeofembeddingbinariesinwebapplicationsinaportable manner thereby enabling intensive computations on the web.
a empirical study by hilbig et al.
found use cases on the web as diverse as game engines natural language processing and mediaplayers.thankstoitsabilitytoincorporateruntimefunctions exportedbythehostenvironment webassemblyhasalsofound usagebeyondwebapplications broadeningthevalueofanalysesfor webassembly.examplesincludedesktopapplications smart contracts iot back ends and embedded software .
programslicing isaprogramdecompositiontechnique that based on a specific program point called the slicing criterion identifies a subprogram of the code relevant to the slicingcriterion.
program slicing has numerous applications in debugging programcomprehension software maintenance re engineering refactoring testing reverseengineering tierlessormulti tier programming and vulnerability detection .
assuch therearenumerousinvaluableapplicationsofslicingfor webassembly binaries.
slicing for example can provide a building blockfor reverseengineering andfor toolssuchas binarytranslators profilers and debuggers .
in terms of security slicing can help with the inspection of webassembly binaries encountered in thewildwherethesourcecodeisunavailable.suchoftentedious andtimeconsumingmanualinspectionsaimtounderstandthecode wellenoughtoascertainthatitisfreefrommaliciousintent.binary slicing can also serve applications such as constructing abstract program models for wcet estimation .
programslicingapproachescanbecategorizedalongmultipledimensions .staticapproachescomputeaslicethatpreservesthe behaviorforallpossibleprograminputs while dynamicapproaches consider only a subset of the inputs.
executable slicing approaches produceaprogramthatcanbeexecuted whileapproachescomputing a dependence closure slice do not.intra procedural approaches compute a slice that preserves the behavior of a given function whileinter procedural approaches preserve the behavior of the entireprogramacrossfunctioncalls.finally programslicingcan identify the portion of the program that either affects the slicing criterion backward slicing o ri sa ff ec t edb yi t forward slicing .
this paper presents the first static intra procedural backward slicing approach for webassembly that is capable of producingexecutable slices.
our approach relies on control and data dependencies to identify the set of instructions that are part of a slice given a specific instruction as the slicing criterion.
this requires webassembly specificdatadependenciesandcontroldependencies ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa quentin sti venart david w. binkley and coen de roover whichweidentifyanddescribeindetail.furthermore itrequires satisfying the webassembly validation requirement webassembly programsmustadheretoaparticularstackdisciplineinordertobe executable.correctlyremovinginstructionsthatarenotpartofthe slice i.e.
thatdonothaveanyeffectontheslicingcriterion may violate this property.
thus the slicer must identify places where the closure slice may leave the stack in an undesirable state and then compensate by including additional instructions to satisfy the validation requirement.
this paper makes the following contributions wedescribethefirststaticintra proceduralbackwardslicing approachforwebassembly.thefirsttwophasesofthisthreephasealgorithmcomputea closureslice ofawebassembly binary.
toproducean executable slice ouralgorithm sthirdphase implements a stack preserving approach to produce a valid executable webassembly program from the closure slice.
usinganimplementationofourthree phasealgorithm we empiricallyevaluateourapproachquantitativelyonarealworlddatasetof8386webassemblyprogramsscrapedby hilbig et al.
from which we compute slices andqualitativelybycomparingslicesproducedbyourimplementation against slices produced by codesurfer o n a set of c programs compiled to webassembly.
background a brief tour of webassembly webassembly is a stack based assembly language.
for the sake of simplicity we describe our approach using a minimal version ofwebassemblycalledminiwasm introducedbysti venartand de roover .
miniwasm retains the defining features of webassembly including structured control flow the most essential assembly instructions direct function calls indirect function calls throughfunctiontables unaryandbinaryoperations and32 bit integers.ourimplementationactuallysupportsalargersubsetof webassembly as demonstrated by our consideration of real world programs in our empirical evaluation where we are able to slice99.
of potential slicing criteria.
we describe our implementation and its limitations in further detail in section .
.
.
the miniwasm language figure depicts the syntax of miniwasm.
a moduleconsists of a sequence of type declarations type a sequence of function declarations func and a table table that identifies the targets of indirect function calls.
as this work presents an intra procedural slicingapproach wefocusonfunctiondeclarations.amoredetailed explanation of miniwasm and its formal semantics is given by sti venart and de roover .
afunctionisdeclaredwithatypeindex tidx whichcorresponds to the type declaration at that index in the sequence of type declarations.functions firstdeclarethe typesoftheir localvariables.parameters and local variables are anonymous and accessed through anindex.forexample afunctionwithoneformalparameter and 1our implementation is available publicly at icse2022 and a full replication package is available at .module moduletype func table type type func ft bt ft t t t i32 func func type tidx func type tidx local t instr table tablen instr data control data drop t.constn t.binop t.unop local.getn local.setn global.get n global.set n t.load t.store control blockbt instr end loopbt instr end ifbtinstr elseinstr end callftn call indirect ft br ifl n l tidx a number figure syntax of miniwasm two local variables accesses the formal parameter at index and thelocalvariablesatindices1and2.theremainderofafunction declaration is the sequence of instructions that form the function s body.
broadly speaking there are two kinds of instructions.
control instructions e.g.
loopand call structuretheprogram scontrol flow while data instructions manipulate the stack drop const locals local.get and local.set and globals global.get and global.set .
operations binop andunop are left unspecifiedastheirconcreteinstantiationisinconsequentialtoprogram slicing.
blocks block loops loop and function calls call call indirect areannotatedwiththeirtypes respectively bt andft .
blocks act as delimiters inside functions for identifying jumptargets.loopsarebasicallyblockswhosesemanticscapture the iterating behavior.
we include an ifinstruction in miniwasm that was previously treated as syntactic sugar .
it is a conditional that encloses one consequent branch and one alternative branch.
.
the scam mug in miniwasm toillustrateprogramminginwebassembly weconsiderthe scam mug c program which is heavily used in the slicing literature.theprogram whichfeaturedonthesouvenirmuggivento attendees at the first scam workshop is designed to challenge staticanalysistools especiallythosemakinguseoftransitivedependence analysis.
for example the minimal slice at the end of the codetakenwithrespecttothevariable xdoesnotincludeline8 despite the transitive dependence.
the code features the following main function in c where all called functions are side effect free authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static stack preserving intra procedural slicing of webassembly binaries icse may pittsburgh pa usa 1int main int i int x int c while p i if q c x f c g i h i the equivalent function in miniwasm is given below with functionsp q f g andhassignedtheindices0 and4respectively func type int main local i32 i32 i32 declare i x c local.get push local i calli32 i32 p i if loop local.get push local c calli32 i32 q c if call i32 f local.set x result of f call i32 g local.set c result of g end local.get call 4i32 i32 h i local.set i result of h i local.get call 0i32 i32 p i br if loop if stack top end is true end online2 thefunctiondeclarestheequivalentoflocalvariables i withindex0 x index1 and c index2 .alllocalvariablesare initialized to zero in webassembly.
line retrieves and pushes the value of the first local variable on the stack.
the next line calls function which expects its single argument to be on the top of the stack in this case local .
the if instruction on line checks whether the top of the stack the function s return value is true differs from and if so executes its thenbranch which capturesthebodyoftheloop.anoptional elsebranchisunnecessary here.thisinstructionshouldnotbeconfusedwith br if n which breaks nnested blocks if the value on the top of the stack is true.
the loopinstructiononline6denotesthestartofaloop.when execution encounters a breakit re executes the loop from the start.
inwebassembly the breaking ofaloopbehaveslikea continue statementinc.intheexample br if 0startsthenextiteration ifthevalueonthetopofthestackis true.the signifieswhich loop in this case the immediately enclosing loop line .
if no breaks areencountered executioncontinues withthe instruction that follows the loop s matching endkeyword.
thus lines and combine to implement the whileloop of the c program.
the bodyof the loop callsfunction with localvariable q c on line .
if the result of this call is non zero it calls function f andassignstheresulttolocalvariable1 x online11 anddoesthe samewithfunction3 g andlocalvariable2 c .finally nearthe end of the loop body on line local variable i is assigned the result of function h i .
finally the br ifinstruction on line 20checkstheloopcondition thevalueonthetopofthestack and jumps back to the beginning of the loop if the value is non zero.
.
webassembly validation requirement webassemblyprogramshavetobe wellformed accordingtosection of the webassembly standard .
of particular interest for program slicing is that the body of a function has to be well typed.
eachinstructionhasaspecific stacktype t t wheret 1isthe expectedsequenceoftypesforthevaluesontopofthestackbeforethe execution of the instruction and t 2is the sequence of types for the values on top of the stack after its execution.
for example the i32.const instructionhastype i32 meaningthatitdoes not need anything from the stack and pushes one value of type i32.
typing extends to sequences of instructions e.g.
the sequence local.get local.get i32.const i32.addhas type i32 i32 .
thefollowingexampleillustratestheimpactthatslicingwebassembly code can have on this validation requirement.
func type local.get push f irst parameter if local.get push fi rst parameter local.get push s econd parameter i32.add slicing criterion call 0i32 i32 drop end thisfunctiontakestwoparameters assumingthattype1is i32 i32 .itfirstpushesthefirstparameteronthestack line2 and if that parameteris non zero executesthe body ofthe ifstatement line3 .thiswillpushbothparametersonthestack lines4and sum them line and then call function before droppingthe return value of the call from the stack.
this leaves the stack emptyattheendofthefunction sexecution.ifthevalueofthefirstparameterwaszero theifbodyisnotexecuted buttheconditionisstillremovedfromthestack henceinbothcasesthestackisempty at the end of the function s execution.
considertheintra proceduralclosureslicetakenwithrespectto the instruction i32.add.
this instruction requires that two values are available on the stack.
through use definition chains that can becomputedstatically weknowthatthefirstvalueiscomputedby the instruction local.get on line while the second is computed by the instruction local.get on line .
these are thedata dependencies of the i32.addinstruction.
the execution of the i32.addinstruction depends on whether the ifstatement executesits thenbranch.therefore line3isa controldependency andneedstobeincludedintheslicetoo.finally the ifinstruction has a data dependency on line as the value pushed is used as the condition.
as a result we obtain the following closure slice it containsalltheinstructionsrelevanttotheevaluationoftheslicing criterion.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa quentin sti venart david w. binkley and coen de roover func type local.get if local.get local.get i32.add end however thisclosureslicedoesnotrepresentavalidwebassembly program as it leaves one value on the stack in the ifstatement.
any attempttoexecute sucha programwill leadto anerror from the webassembly validator.
phase three of our algorithm includes adropinstruction after line to effectively clean up the stack.
the webassembly slicing algorithm ouralgorithmconsistsofthreephases adata gatheringphasethat computes the dependencies of each instruction in a function a slicingphasethatidentifiesthewebassemblyinstructionsofthe closureslice andareconstructionphasethatincludesadditional instructionstomaintainthestackdisciplineandthusensurethat the slice is a valid executable webassembly function.
this section details each of the three phases.
.
data gathering phase the data gathering phase computes the following elements.
stack layout.
for webassembly programs the layout of the stack can be computed statically for any instruction including loops.astackspecificationanalysis computestheimpactof everyinstructiononthestackandassignsnamestoeachelementin theresultingstacklayout.toillustrate thefollowingcodehasbeenannotatedwiththeresultsofthestackspecificationanalysiswhere for example denotes a stack that contains a single element denoted by the opaque identifier i0.
1local.get 2i32.const 3i32.add 4call 1i32 use definitionchains.
inordertoidentifydatadependences uses of each element on the stack are linked to their respective definitions through use definition chains .
for example in the previous code listing the instruction i32.addusesi1andi0and definesi2.use definitionchainsmaptheuseof i1toitsdefinition by the instruction i32.const and the use of i0to its definition by the instruction local.get .
here a use denoted use is a pair consisting of the name of an element on the stack e.g.
i0 and the occurrence of an instruction e.g.
the position of a specific i32.constinstruction in the binary .
we denote the set of uses of instruction instrasuses instr and the set of instructions that contain the definitions corresponding to a use as defs use .
memory dependences.
identifying data dependences through use definition chains alone does not suffice for slicing as therecan be indirect data dependences that arise through the use of webassembly slinearmemory whichmodelstheprogramheap.
for example the i32.loadinstruction in the following code is data dependentonthe i32.storeinstruction aslicethatincludes the load instruction but not the corresponding store instruction would not preserve the semantics.1i32.const stack 2i32.const stack 3i32.store stack stores at 4i32.const stack 5i32.load stack loads from modelingmemorydependenciespreciselyrequiressomeformof alias analysis.
to date no alias analysis algorithm has been devised forwebassembly.thusweresorttoasoundover approximation allloadinstructions are marked as potentially data dependent on every store that may be executed before the loadinstruction i.e.
for which there exists a path in the cfg from the storeto the load .asimilarover approximationisusedforthememorydependenciesof callinstructions.indeed asthefollowingcodecould representthecallofafunctionwithapointerasargument anypre cedingmodificationtoanypointerneedstobeincludedintheslice.
1i32.const could be a pointer 2call callinstructionsarethereforetreatedasboth loadinstructions memory can be read during a function call and storeinstructions memory can be written during a function call .
both over approximations could be rendered more precise with additional informationfromasoundaliasanalysis.wedenotetheinstructions that are memory dependencies of an instruction instras the set memorydeps instr .
global.set instructions.
inwebassembly globalvariablescan be used to share data across function calls.
for example when producingwebassembly currentc compilersuseglobal variable as the address in the linear memory where the stack pointerresides .
incrementing or decrementing the value of global is used to grow or shrink the stack.
although there might be no explicit dependence on global variable it is important to include anyinstructionthatmodifiesitintheslice.inthecaseofcprogramscompiledtowebassembly thisensuresthatfunctioncallspreserve the same call stack semantics.
for the same reason and becauseour approach is intra procedural and thus cannot know which global variables are required across function calls all global.set instructionsarecollectedandconsideredpartoftheslice.thisover approximationisindependentoftheslicingcriterion.thisisagaina conservative over approximation in practice not all global.set instructionsarerelevantfortheslicingcriterion.wedenotetheset of all global.set instructions as globalsetinstrs .
control dependences.
in addition to data dependences slices needtoaccountforcontroldependencesastheycapturewhether aninstructionis executedornot.consider thefollowingexample where the value of local variable is initially set to and then set to if the value of local is true i.e.
any non zero value .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static stack preserving intra procedural slicing of webassembly binaries icse may pittsburgh pa usa 1i32.const 2local.set local 3local.get 4if i32.const local.set local 7end value of local depends on the value of local local.get here theinstruction local.set inthebodyofthe ifiscontroldependentonline4 whichisdata dependentontheinstruction local.get .hence boththe ifand local.get instructions willneedtobeincludedinanyslicethatincludestheinstruction local.set online6.werelyontheso called exactalgorithm byferranteetal.
tocomputecontroldependences.wewrite controldeps b a when instruction bis control dependent on instruction a orinotherwords whenthereisacontrol dependence fromatob.
hence controldeps instr maps an instruction to the instructions on which it depends on due to control dependences.
.
slicing phase our algorithm for identifying the instructions that makeup the closure slice is inspired by traditional approaches to slicing wheretheslicingcriterion datadependences andcontroldependences are used to transitively add instructions to the slice.
we include agrawal s additions for structured control flow which arerequiredtoproperlysupportwebassembly sstructuredjump instructions e.g.
br .
note that unlike most slicing approaches where the slicing criterion includes a program location and one ormorevariablesofinterest weonlyrequireaprogramlocation given as an instruction as the slicing criterion.
the variables of interest are implicitly determined by the instruction.
inordertosupportwebassembly however tw odomain specific extensionsareneeded.first becausewedonothaveinter procedural information global.set instructionsareconsideredpartofthe sliceasexplainedpreviously.second withoutprecisealiasinginformation any write to the memory potentially influences any subsequentreadfromthememory thusmemorydependencescome into play as soon as any read is included in the slice.
ourslicingalgorithm givenasalgorithm1 worksasfollows.
the slice starts empty line and the initial worklist contains the instructionthatistheslicingcriterionaswellasall global.set instructionsfoundinthefunctionbeingsliced line2 .thealgorithmthenproceedsasatypicalworklistalgorithm.instructions instrin the worklist that are already part of the slice are ignored line .
other instructions are added to the slice line and their dependencies are added to the worklist use definition chains are followed to find data dependences foreachuseofavalueonthestack line8 theinstructions that define that value are added to the worklist line thecontroldependenciesofthecurrentinstructionareadded to the worklist line the memory dependencies of the current instruction are added to the worklist line .
once the worklist is exhausted the resulting slice is augmented accordingtoagrawal stechnique specificallythe conservativealgorithmgiven in fig.
of their paper where the brinstructions as unconditional jumps in webassembly are treated as gotostatements.
for each instruction in the slice all brinstructions that are control dependent on the instruction are added to the slice line16 .theslicingalgorithmreturnsthesliceaugmentedwith these additions line .
slice slicing criterion c set of global.setinstructions globalsetinstrs set of brinstructions brinstrs use of stack locations uses use definition chains defs control dependences controldeps memory dependences memorydeps 1letslice 2letworklist c globalsetinstrs 3whileworklist do 4letinstr worklist 5worklist worklist instr ifinstr slicethen slice slice instr foruse uses instr do worklist worklist defs use worklist worklist controldeps instr worklist worklist memorydeps instr 12letsliceextension 13forinstr brinstrs do forinstr slicedo ifinstr controldeps instr then sliceextension sliceextension instr 17returnslice sliceextension algorithm slicing algorithm .
reconstruction phase the closure slice computed by the previous phase may not form avalidwebassemblyfunction.toillustratewhyandtoshowthe reconstruction s impact both before and after an instruction of the slice we usethefollowing codefragment.thefragment hastype i.e.
itdoesnotconsumeanythingfromthestacknorproduce anything onto the stack .
its constituent instructions have been annotated with their own types 1local.get i32 2i32.const i32 3i32.add i32 i32 i32 4calli32 i32 suppose this fragment is sliced with respect to line .
the instruction i32.const forms a closure slice on its own because it is not influenced by any other instruction in the fragment.
however this slice has type i32 while the type of the original fragment is .asthefragmentmayresideinawebassemblyconstruct suchasablockorafunction thatexpectsaspecifictype replacing the fragment by its slice will result in an invalid webassembly program.
toovercomethisissue reconstructionaugmentstheclosureslice withsyntheticinstructionsthatpreservetheoriginalstacklayout and thereby render the slice valid and executable.
adding these synthetic instructions is safe because they have no side effects on theprogrambehaviorregardingtheslicingcriterion.thesequence of synthetic instructions that is introduced must have the same authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa quentin sti venart david w. binkley and coen de roover typeasthesequenceofinstructionsitreplaces.thefragmentbelow illustrates the rewriting.
it includes type summaries in place of the instructionsthatarenotpartoftheslice.notehowthetypesofthe final two instructions i32.addand calli32 have been merged into a single type summary that has the same effect on the stack.
?
?
i32 2i32.const i32 ?
?
i32 i32 thegoalofthereconstructionphaseistoaddsyntheticinstructions thathavethedesiredtypesummary.ourreconstructionphaseuses i32.constwhen a summary pushes an i32value on the stack and dropto remove a value from the stack.
this process results in the following reconstructed slice which is of the same type as the original fragment.
1i32.const i32 2i32.const i32 3drop i32 4drop i32 while the reconstructed slice has the same type as the original fragment itisnotminimal i32.const drop isshorterandan equallyvalidslice.wehaveoptedtonotattemptaglobalminimum butratheronethatislocaltoeachsummary e.g.
drop drop is theminimalsetofinstructionswiththetype i32 i32 thatcan be inserted in place of the second summary ?
?
i32 i32 .
this design choice has the advantage of only requiring a single linear traversal of the fragment s instructions.
algorithm2depictsthereconstructionalgorithm.weusethe operator to concatenate sequences is and overloadittoinsertanelementbetweentwosequences is .auxiliaryfunction isinsliceidentifiestheinstructionsthat arepartoftheclosuresliceaccordingtoalgorithm1.auxiliaryfunctionreplacereturnsasequenceofsynthetic i32.constand dropinstructionssuchthatthetypeoftheentiresequenceisthesameasthe instructions being substituted.
for example replace i32.const i32.const i32.add returns i32.const because both sequences of instructions push a single value onto the stack.
function validslicereturns a type valid webassembly slice for a given sequence of instructions.
to produce an executable slice it is initially called with the body of the sliced function from which the result is built up recursively.
instructions that are part of the closureslicewillbeincludedintheresulttogetherwithsynthetic instructionsthatreplaceinstructionsthatarenotpartoftheslice whilepreservingtheirsummarytype.
thealgorithmmaintainsin itssecondargumentasequence removed ofinstructionsthatare not part of the closure slice and thus will be replaced by synthetic instructions.
if there are no instructions to process line meaning that the lastinstructionofasequencehasbeenprocessed anyremaining instructionsin removedarereplacedbyatype equivalentsequence of synthetic instructions line .
for instructions that contain sequencesofinstructions block loop thecorrespondingbody isfirstprocessedrecursively line7 .iftherearenoinstructions to keep inthe body the instructionitself is added tothe sequence ofinstructionstoremove line9 .otherwise itsbodyisreplaced with the sliced body line and the subsequent instructions are processed line .
the process for an ifinstruction is similar line13 exceptthatbothbranchesneedtobeprocessedandtheinstructioncanberemovedonlyifbothbranchesbecomeempty line .
for all other instructions if the instruction is part of the closure slice line21 thepreviousinstructionsthathavebeenremoved arefirstreplacedbytheirequivalentsyntheticinstructions then theinstructionisaddedtotheresultbeforetheresultsofprocessing the subsequent instructions line .
otherwise if the instruction is not part of the slice line it is appended to removed line and a recursive call is made on the remaining instructions.
as a result one obtains a valid executable webassembly program that is a superset of the closure slice that preserves the behavior of the slicing criterion and is thus executable.
isinslice instruction instr checks whether instris part of the slice replace sequence of instructions instrs returna sequence of dummy instructions that has the same type asinstrs validslice sequence of instructions instrs sequence of instructions removed 1ifinstrs angbracketleft angbracketrightthen returnreplace removed 3else 4letinstr head instrs 5letinstrs tail instrs ifinstr is a blockorloopinstruction then letbody validslice instr.body angbracketleft angbracketright ifbody angbracketleft angbracketrightthen returnvalidslice instrs removed instr else letinstr instrwith its body set to body return replace removed instr validslice instrs angbracketleft angbracketright else ifinstr is an ifinstruction then letthen validslice instr.then angbracketleft angbracketright letelse validslice instr.else angbracketleft angbracketright ifthen else angbracketleft angbracketrightthen returnvalidslice instrs removed instr else letinstr instrwith its branches set to then andelse return replace removed instr validslice instrs angbracketleft angbracketright else ifisinslice instr then return replace removed instr validslice instrs angbracketleft angbracketright else returnvalidslice instrs removed instr algorithm slice reconstruction algorithm evaluation weevaluateourapproachthroughthefollowingresearchquestions.
rq1 howdoesstaticstack preservingslicingbehaveonclassical slicingexamples?
theliteratureonprogramslicinghasproduced authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static stack preserving intra procedural slicing of webassembly binaries icse may pittsburgh pa usa several challenging examples which have each been studied extensively.
we manually translate these examples to webassembly and inspect the output of our slicer for each.
rq2 whatisthesizeofclosureslicesbuiltbyourslicingphase?
weapplyourapproachtothedatasetcollectedbyhilbigetal.
which consists of real world occurrences of webassembly from the web.
we use each instruction of each function in the dataset asaslicingcriteriontowhichweapplyalgorithm1.wepresent descriptive statistics about the size of the resulting closure slices.
rq3 by how much do slices need to grow in order to render them executable?
relyingonthesamedatasetasusedinrq2 wemeasure theincreaseinslicesizeaftertheclosureslicehasbeenrendered executable.
rq4 how much time is needed by each phase in order to compute an executable slice?
we measure the time needed by each phase when computing an executable slice.
rq5 how does static stack preserving slicing of webassembly binaries compare to slicing the original source code directly beforeits compilation to webassembly?
in cases where the source code ofawebassemblyprogramisavailable itmightbepreferableto slice the source code instead of the binary.
we compare the results of our approach to the static slices of c programs computed by codesurfer .
weconductedourevaluationonamachinewithanamdryzen threadripper 3990x core cpu .
ghz with hyperthreading and256gibofram running128slicingjobsinparallel oneper logicalcore .beforedetailingtheresearchmethodandresultsfor eachoftheseresearchquestions webrieflydescribeourimplementation.
.
implementation weimplementedtheapproachdescribedinthispaperontopofthe wassail framework using ocaml version .
.
.
its loader for webassembly binaries is based on the implementation that accompaniestheofficialwebassemblystandard.ourimplementation first conducts the data gathering phase described in section .
.
next itidentifiestheinstructionsoftheclosuresliceusingalgorithm before rendering the slice executable using algorithm .
ourimplementationsupportsmostofthewebassembly1.0core specification but has the following limitations the br table instruction is only supported when all its targetsexpectthesamestacklayout.thisisalimitationof the stack specification analysis.
codethatliesinacfgnodethatisdisconnectedfromthe cfgentrynodecannot be used astheslicing criterion becauseourimplementationofuse definitionchainsrequiresa path from the entry node of the cfg to the slicing criterion.
theselimitationsbothconcernthedata gatheringphase andwe leaveovercomingthemforfuturework.inourevaluationwitha real worlddataset weencounteredtheselimitationsin0.
of the slices where of the non supported slices are caused by unsupported uses of the br table instruction and by disconnected code.
.
rq1 behavior on classical examples wefirstperformaqualitativeevaluationofourslicingapproachon examplesthathavebeenstudiedintheslicingliterature namelythe scam mug example the montr al boat example wordcount andagrawal scontrolexamples .wemanuallyencodedeachprogramtowebassembly beforeapplyingour approach.allsourceprogramsandthecomputedslicesareavailable in our replication package.
ourfirstexampleisthescammugexamplepresentedinsection using line local.set as the slicing criterion.
key to understanding the challenge in this example is to realize thatthe value assigned to cdoes noteffect the value of xat line .
thus a minimal slice would exclude lines and .
however the expectedbehaviorofaslicerbasedontransitivedependenceisto includethese lines .our slicercorrectly producestheexpected slice including these lines.
the montr al boat example poses a similar dependence challenge.
being based on dependence closure our approach is unableto teaseapart the dependences.however itdoes correctly produce the expected non minimal slice.
thewordcountexample introducedbygallagherandlyle uses five different slicing criteria e.g.
a slice that computes justthe number of lines in the input .
after translating this exampleto webassembly we produced the five corresponding slices andmanually compared each to the expected result provided by gallagherandlyle translatedtowebassembly.ineachcaseourslicer produces the desired minimal slice.
the examples of agrawal demonstrate the need to treat unconditional jumps when slicing programs that use gotostatements.
wetranslatedtheexamplesfromfigures3and5oftheirpaperto webassembly along with the expected slices.
our slicer correctly includes the necessary unconditional jumps brinstructions .
it doesincludemoreinstructionsthanthetranslationofagrawal s slices.
this is due to the fact that purity assumptions that are made inagrawal sslicesregardingsomecalledfunctionsarenotmade by our slicer.
however our slicer produces correct slices.
rq1 while our approach shares the limitations of other static slicersonexamplessuchasthescammugandthemontr al boat examples it performs well on the more straightforwardexamples.
it is exact when computing the word count slices andtheslicesforeachofagrawal sexamplesmerelyincludeunwanted call instructions due to our over approximation of memory dependences.
.
rq2 closure slice size hilbigetal.
gatheredadatasetof8461uniquewebassembly programs.weusethisdatasetinourevaluationafterfilteringout the programs that could not be loaded.
for each of the functions in the remaining programs we use each instruction as a slicingcriterionyielding495204868slices.thisisakintorelated work whichusedeachsdgvertexasaslicingcriterion.weuse a timeout of hours per program.
the dataset our implementation and evaluation scripts and thedataresultingfromourevaluationforrq2 rq3 andrq4are available in our replication package.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa quentin sti venart david w. binkley and coen de roover the size of the initial functions and their closure slices are summarized in figure .
the mean size of the slices produced by algorithm1is oftheoriginalfunctionsize.thisismorethan the averages obtained by the c slicing techniques surveyed bybinkleyandharman .therearetwopotentialreasonsfor this.
first webassembly being lower level than c provides fewer semanticcuestotheslicer.second ourover approximationsregardingthememoryand global.setinstructionscanincreaseslicesize.
however our is lower than the average slice size reported bykissetal.whenslicingarmbinaries .inthiscasethe likely cause is webassembly s use of structured control flow.
rq2 our slicing algorithm algorithm computes slices that areonaverage52 ofthesizeoftheoriginalprogram whichis lowerthanrelatedworkonbinaryslicing butlargerthanthe results of source code slicers.
figure sizes of the slices on a real world dataset.
.
rq3 executable slice size wenowturntotheimpactofalgorithm2 whichproducesvalid executable slices from the closure slices studied by rq2.
as shown in figure the size of the slices increases from to .
as evidencedbytheoutliersinthelowergraph someexecutableslices arelargerthan theoriginalprogram.thisphenomenonislimited toahandfuloftheslices intotal itaffectsonly0.
oftheslices where an average of .
instructions are included per slice.
we manually investigated a statistically relevant sample slices2 of these cases to identify underlying causes.
the most common cause impacting of the manually investigated slices is when an instruction that removes two or more values from the stack that is not part of the closure slice gets replaced by two or more dropinstructions resulting in a positive net change to the numberofinstructions.forexample removinga calltoafunctionwith20argumentsreplacesthe callinstructionwith20 drop instructions thereby increasing the slice size by instructions.
2based on a population size of with a confidence level of and a margin of error of .three instructions remove two or more values from the stack in webassembly select whichpopsthreevaluesandpushesone store which pops two values and call which pops as many values as there are arguments to the function call.
in the worst case a function had callinstructions to a argument function resultingin352 dropinstructionsbeingadded.inourmanual investigation we encountered instances of this pattern due tocallorcall indirect instructions due to storeinstructions and9dueto selectinstructions.theonlyothercausewe encountered for an increase in the size of the executable slice is duetotypeconversions forexample the i32.wrap i64 instruction converts an i64into ani32in a single instruction while our slicer replaces it by two instructions drop i32.const .w e encountered this pattern only six times.
rq3 algorithm2 reconstruction hasasmallimpact onslice size which goes from an average of to .
.
rq4 time to produce executable slices we measured the time it takes for each phase in order to compute each slice and summarize the results in figure .
figure slicing time.
the mean time for the entire slicing process the data gathering phase followed by algorithms and is 4094ms.
only oftheslicestakemorethanasecondtocompute.lookingatthe breakdown between the different phases we observe that the time toproduceasliceisdominatedbythedata gatheringphase taking 3964ms on average and at most hours and minutes while algorithm1takes104msonaverage andatmost44minutesand seconds and algorithm takes ms on average and at most hours and minutes.
investigating the data gathering phase in more detail we observe that the time is dominated by the computation of the data dependences 1672ms the memory dependences 360ms andthestackspecificationanalysis 1811ms whilethetime required for the cfg construction 107ms the computation of the control dependences 13ms and listing the globals s remains small.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static stack preserving intra procedural slicing of webassembly binaries icse may pittsburgh pa usa regarding the outliers we observe that they concern slices of functionsofthousandsofinstructions.insomecases thecomputationofthedatadependenciestakesmostofthetime.however whenmanyinstructionsareremoved thereconstructionalgorithm may take the majority of the time.
for example the longest running time for the reconstruction algorithm is on a function that is reduced from 11k instructions to only .
rq4 it takes on average 4094ms to compute an executable slice.thistimeisdominatedbythedata gatheringphaseanditscomputationofthedataandmemorydependencesinparticular.
the time required to reconstruct an executable slice ms on average is only a fraction of the time required to construct the closure slice 104ms on average .
.
rq5 comparison to slicing c programs whenavailable itcanbebeneficialtoslicethesourcecodedirectly rather than its webassembly counterpart.
furthermore manualcomparison of source slices compiled to webassembly with our webassembly slices enables characterizing the impact of the overapproximations used by our slicer.
to investigate we selected a set of c programs originating from multiple sources.
these include programs from the slicing literature programs used to compare andevaluate wcetanalysis tools and programsdesigned to benchmark language implementations .
eachprogramwasfirstnormalizedbyprettyprintingitusing thepycparser pythonlibrary.afternormalizationtheseprograms rangefrom16to2988sourcelinesofcode sloc withanaverage of sloc according to the tool sloccount.
for each statement in these programs that modifies a scalar variable we produced a variantoftheprogramthatincludesa printfstatementthatprints the value of the variable which is used as the slicing criterion.
we sliced each variant with codesurfer and with our approach as follows we used codesurfer to produce a static closure slice of each cprogram.becausecodesurferdoesnotproduceexecutable slices weapplyquasi staticexecutableslicing qses which uses observation based slicing orbs to augment a codesurfer slice with the statements needed to make itexecutable .thisresultsincompilableslices.eachslice was then compiled to webassembly.
wealsocompiledeachvariantdirectlytowebassembly and applied our approach using the instruction corresponding to the added printfstatement as the slicing criterion.
in both cases the c programs were compiled to webassemblyusing clang .
.
with the o2 fno inline functions lm wl demangle wl export all flags.
we remove slices that encountered one of the limitations described in section .
as well as those whose codesurfer slices produce webassembly that cannot be loaded by our implementation.
in the end we obtain pairs of slices to compare.
we manually investigated a statistically relevant sample of slices3thatincludedtwoslicesfromeachprogram exceptforthree 3basedonapopulationsizeof1956 withaconfidencelevelof95 andamarginof error of .programsthatonlyhadoneslice inordertounderstandanydifferences.
as described below we identified three main root causes forthedifferencesininstructionsbetweeneachpairofslices.all oftheslicesaswellasthedetailsofourmanualinvestigationare included in our evaluation package.
memory over approximation.
the majority of the differences are due to our over approximation of the memory dependences.
as soon as the slice includes a callor a loadinstruction our approach will include in the slice all storeand callinstructions that may be previously executed according to the cfg.
in orderto encode the slicing criterion for codesurfer a call to the printf function is added to the code.
this means that all slices for thisrq include a function call and as a result our approach always includesmemorydependenciesintheslice.weencounteredthis pattern in of the investigated slices.
compileroptimizations.
theslicesproducedbycodesurfersometimesbenefitfromadditionalcompileroptimization.weencountered various patterns related to this root cause.
these differences canrenderthecodesurferslicesquitedifferent andreconstructing thecorrespondencewiththeoriginalprogramcanrequiresignificantmentaleffort.inthesecases preservingthecorrespondence between its slices and the input program is a desirable property of our approach.
the codesurfer slice sometimes produces fewer instructions to manipulate memory.
for example the following code shows the slice produced by our approach on the left and the slice produced bycodesurferontheright.the offsetoptionofa storeinstruction enables writing at a specific offset from the target address of the storeoperation.ourapproachpreservestheoffsetofthe storeinstruction from the original program while codesurfer can remove it.thisresultsin2superfluousinstructionsinourslice forpassingthewrittenaddressasargumenttothefunctioncallonthelastline.
1local.get local.get 2i32.const i32.const 3i32.store offset i32.store ... ... 5local.get local.get 6i32.const 7i32.add 8call call anotherinstanceofthispatternisthatthecontrol flowstructure of the program may be simplified but our approach does not applysuchrewritings.hereisanexcerptofadifferencebetween a slice produced by our slicer left which preservers the original control flow structure and the corresponding codesurfer slice right which has two fewer instructions blockand br1 .
1block local.get local.get i32.const i32.const i32.lt s i32.ge s if if br1 end loop loop ... ... end end end block end if authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa quentin sti venart david w. binkley and coen de roover in some cases clang inlines loops in the webassembly code resultinginanincreaseinsizeforthecodesurferslices.othercases fallingunderthisrootcauseincludetheuseoffewerlocalvariables by codesurfer when for example multiple local variables always havethesamevalueintheslice thereversingofaloopiterationorder when it is beneficial for code size or changing the type ofa function when its return value is not needed thereby avoidingextra instructions to return a value.
we have observed this root cause in of the manually investigated slices.
inter procedural vs. intra procedural.
codesurfer s computation of inter procedural slices has the impact that when fis recursive codesurfer includes code reached both directly in the current invocationof f andindirectlyviarecursivecallsto f.forexample iff s return value is used in a control flow decision upon which the slicing criteria is itself dependent codesurfer will preservethe computation of f s return value.
in contrast our approach never includes instructions required solely to support recursive calls.thisisarootcausethatweencounteredin20 ofthemanually investigated slices.
rq5 when the c source code of an application is available compilingacslicetowebassemblymayproducesmallerslices.
themaincausesofthisarethememoryover approximations madebyourslicerandtheextraoptimizationsenabledwhen compiling the simpler code of the slice.
on the other hand due tocompileroptimizations cslicescompiledtowebassembly may differ significantly from the corresponding portions of the directlyslicedwebassemblycode.thiscanhamperprogram comprehension of the resulting slices.
.
discussion the results of our investigation indicate that slicing webassembly programsdirectlycangreatlyreducetheirsize facilitatingapplicationssuchasreverseengineeringandprogramcomprehension.
moreover obtaining an executable slice only requires a small increase in slice size and can be done quite quickly.
weidentifytwomainpossibleimprovements.first regarding slice size having alias information would eliminate superfluous instructionsthatarecurrentlyincludedduetoourmemoryoverapproximation.
second regarding slice time effort should be spent on optimizing the data gathering phase in particular the computation of the data dependences.
finally weobservethatwhenthecsourcecodeofanapplication is available even though the slice sizes may increase it canbe beneficial in terms of program comprehension to slice at the webassembly level directly.
.
threats to validity toconcludeourevaluation weidentifythreatstovalidityaccording totheclassificationofwohlinetal.
.athreattointernalvalidity comesfromourevaluationsetuponthereal worlddataset.forsome of the programs it is infeasible to compute all of the slices thus werelyonatimeoutof4hoursperprogramandlettheslicer computeasmanyslicesaspossibleinthattime.wewereableto compute in total and the evaluation ran to completion without timeout on of the programs.our implementation has limitations that we described in section .
which form a threat to construct validity.
however we do not expect to observe a different outcome in our results if these limitations are lifted as we do not expect instructions within these disconnected sections or accessible from a br table instruction to be too different from other instructions in the code.
a threat to external validity is that among the programs usedinourevaluationofrq2andrq3 therecanbeduplicatefunctions across different binaries which we have not filtered out and couldthereforehavebeenslicedmultipletimes.thisismitigated by the high number of functions sliced in total which limits the potential impact of this threat on the results.
our dataset for rq5 is composed of c programs that we manually gathered.
being less varied than the first dataset of programs itformsathreattotheexternalvalidityforrq5.however weensured thediversity ofthis datasetby gatheringit from three different sources.
related work webassembly.
therehasbeeninterestfromtheresearchcommunityinwebassemblyonaspectssuchassecurity extensions to the language tooling and optimizations .
in terms of program analysis lehmann and pradel introduced a framework for dynamic analysis of webassembly wattetal.afirst orderprogramlogictoverifywebassemblyprograms and sti venart and de roover a static information flow analysis based upon a static analysis framework for webassembly .
our approach is entirely static and is based on that same framework.
per nyiandmidtgaardperformedproperty basedtestingofwebassembly runtimes .
the shrinking phase of their approach also faces the problem that the generated program needs to passthe validation requirement which is solved through a different rewriting phase.
binary slicing.
static slicing has been applied to binary executables with a focus on register based assembly languages whereas webassembly itself is stack based.
cifuentes and fraboulet perform intra procedural static slicing on an assembly language close to x86.
they argue that using basic blocks as the node granularity is more appropriate for binary executables as the number of instructions can be large.
unfortunately this approach is evaluated on a single example.
our approach in contrast operates on individualinstructions anditsevaluationonreal worlddatademonstratesthe feasibility of slicing at this level.
like ours their approach does not include any alias analysis.
inter procedural static slicing for binaries has been achieved by kiss et al.
and was later extended to include dynamic information during slicing .
special care is needed to handle indirect functioncalls whichisnotnecessaryforanintra proceduralap proach.
similarly the tool presented by mangean et al.
performs inter procedural static slicing .
ward et al.
combined dynamic andstaticslicingforanalyzingbinaries throughconditionedslicing withthegoalofanalyzingandmigratingassemblersystems.adynamicsliceisfirstcomputed beforebeingaugmented with information from a transformation based static slice.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static stack preserving intra procedural slicing of webassembly binaries icse may pittsburgh pa usa in terms of slicing stack based assembly languages there has beenrelated workon slicingjvmbytecode.umemorietal.present a static approach which requires the presence of the java source codealongsidethejvmbytecode whileourapproachdoesnot rely on the presence of the source code.
castaldo d ursi et al.
slice jvm bytecode after converting it to jimple code which eliminates theneedtodealwithstack basedbytecode .currently there exists no equivalent to jimple for webassembly and our approach therefore directly handles the stack based nature of webassembly.
zhaopresentsadependenceanalysisforjavabytecode withslicing asoneofitsapplication .however thehandlingofinstructions that manipulate the value stack is omitted from their description.
language independent slicing.
binkley et al.
present orbs a language independent slicing approach that observes the program output in order to build an executable slice which works at the line level .
we rely on the qses extension of orbs t or e constructexecutablecslicesfromcodesurferforourfifthresearch question.
orbs could in theory be applied to webassembly programs directly on the condition that the program is instrumented to capture the slicing criterion as part of the program s output.
we leave a comparison with the resulting dynamic slices for future work.
conclusion we introduced the first static intra procedural backward slicing approachforwebassemblybinaries.thisthree phasedapproach consists of a data gathering phase which computes all the nec essary information for slicing a slicing phase which constructsa closure slice that contains all instructions needed to preservethe behavior of the slicing criterion and a reconstruction phase which produces an executable slice from the closure slice.
this last phaseisneededbecausewebassemblyprogramshavetoadhereto a validity requirement to be executable.
we evaluated our approach on a real world dataset of programs.
we observed that our approach results in executableslices that are on average of of the original function.
the time needed to compute these slices averages 4094ms where most of that time is spent on the data gathering phase in particularin the computation of data dependences.
through a qualitative comparisonoftheslicesproducedbyourapproachwithexecutablecslicescompiledtowebassembly wefindthatincorporatingsome form ofalias analysis inthe slicingprocess should notablyreducethe average slice size.
this work forms an important stepping stone towards binary analysis applications such as reverse engineering and program comprehension.