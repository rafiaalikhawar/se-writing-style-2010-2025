when function inliningmeetswebassembly counterintuitive impacts onruntime performance alan romano ajromano usc.edu universityof southerncalifornia usaweihang wang weihangw usc.edu universityof southerncalifornia usa abstract thewebassemblystandarddefinesabytecodeformatservingas acompilationtargetforlanguagessuchasc c andrust.webassemblycompilersarebuiltontopofexistingcompilerinfrastructures such as llvm and newly developed compiler toolchains suchas binaryen handlingvariousnewfeaturesofthe webassemblylanguage.however weobservethatboththesenewandexisting infrastructures implicitly assume that the executionenvironments ofnativeandwebassemblyapplicationsarethesame ignoringthe presence of browser compilers in the webassembly pipeline.
this incorrectassumptionoftenmisguidesfunctioninliningoptimizations resultinginaslowerwebassemblymodulewhenfunction inliningisapplied.thispaperisthefirsttoinvestigatethecounterintuitive impacts of function inlining on webassembly runtime performance.
we inspect the inlining optimization passes of the llvmand binaryeninfrastructures usedin the emscriptenc c to webassemblycompiler.ourinvestigationon127c c samples from the llvm test suite shows that samples exhibit counterintuitive behavior dueto functioninlining particularly frominlining hotfunctionsintolong runningfunctions.wehopeourfindings motivate further work onrevising existingoptimizations with the unique characteristics ofwebassemblyenvironments inmind.
ccs concepts softwareanditsengineering compilers information systems webapplications .
keywords webassembly function inlining llvm binaryen emscripten acmreference format alan romano and weihang wang.
.
when function inlining meets webassembly counterintuitiveimpactson runtimeperformance.in proceedings of the 31st acm joint european software engineering conference andsymposiumonthefoundationsofsoftwareengineering esec fse december san francisco ca usa.
acm new york ny usa 13pages.
introduction webassembly abbreviated wasm is a low level statically typedlanguageaimingtoserveasauniversalcompilationtarget esec fse december san francisco ca usa copyright heldby the owner author s .
acm isbn .
the web.
it is designed to be fast to compile and run to be portable i.e.
language hardware andplatform independent and to have formal type and memory safety guarantees.
webassemblyissupportedonallfourmajorbrowsers i.e.
chrome firefox safari and edge and compiles from several programming languages including c c c rust and go .
recent studies have shown that one out of every websites use webassembly forpurposessuchasgames cryptography machine learning andmedical research .
webassembly compilers leverage the same compiler infrastructuresascompilersoftraditionallanguages.forexample theemscripten c c to webassembly compiler the rustc compiler and intel s oneapi compiler all use the llvm compilerinfrastructure.unfortunately weobservethatwebassemblycompilersleverageexistinginfrastructureswithoutconsidering the differences between webassemblyandnative applications.
liftoff turbofan execution pipeline javascript starts wasm modulemain thread f1 f2 javascript calls main2 main calls f24 main calls f15 f2 f1 f1 main main calls f13 f1 f1 main f2 f2 mainjavascript maincompilation threads figure1 chromiumtier upprocess.inthisexample function mainusestheliftoff generatedcodewhenfirstcalled asitistheonlycodeavailable.
maincalls f1whichonlyhas liftoffcodeready.
f2usestheturbofan generatedcodeas it is available at the first call.
on the second call to f1 its turbofan generated codeis availableand used forthe call.
oneofthesubstantialdifferencesisthatwebassemblyhasthe additional compilation layer at runtime running within browsers generatingthefinalmachinecodeforwebassemblyinstructions.
browsers suchaschromium andfirefox typicallyinclude atleasttwo webassemblycompilers afastcompileremittingunoptimized code and a slow compiler emitting highly optimized code.
browsers use both compilers to ensure the machine code for webassemblyfunctionsisavailableearlyandcanperformfaster oncetheoptimizedcodeisavailable.whentheoptimizedcodeis ready thecodeis tiered up onthefollowingfunctioncallinvocation by replacing the unoptimized code with the optimized code.
thetiering upprocessonlyoccursonafunctioncallbecausethe thisworkislicensedunderacreativecommonsattribution sharealike4.
internationallicense.
351when function inliningmeetswebassembly counterintuitive impactsonruntimeperformance esec fse december3 san francisco ca usa function e.g.
a heuristic on the function s code size to determine if it is beneficial to inline.
the middle end component passes the optimized ir to the codegen component to create a webassembly module.
next the module is passed to binaryen s wasm opt tool which applies binaryen s set of optimization passes to the module.
in binaryen function inlining is performed by the inlining optimizing pass.
similar to the inlinepass in llvm the inlining optimizing passmoves functioninstructionsinto thelocationoftheoriginalcallsiteifthecalculatedinliningcostislessthan athreshold value.
differences betweenthese passes include the ir structures thatare inlined asllvm can alsoinline its blockstructures.besides binaryencansupportpartialinliningofearly return conditionalstatements .figure3illustratesbinaryen sfunction inlining.
finally the compilation pipeline outputs the optimized webassemblybinary andjavascript support code.
.
webassembly execution pipeline thegeneratedwebassemblymoduleandjavascriptfilesarerun by a browser such as chromium or firefox which each have different internal compilers to generate machine code for the webassembly module.
for example chromium is powered by the v8javascriptandwebassemblyengine whichincludestwo compilationenginestogeneratemachinecodeforwebassembly.
the first compiler liftoff is a single pass compiler that emits machine instructions immediately after reading in a webassembly instruction at the expense of the number of optimizations that it applies.
as a result the liftoff code can perform sub optimally whenexecuted.thesecondcompiler turbofan isamulti pass compilerthatappliesseveraloptimizationpassestothemachine code.
while turbofan generates faster code this compiler takes muchlongertogeneratecodethanliftoff.tobalancestart upspeed with execution performance chromium first generates code for webassembly functions with liftoff and immediately starts the turbofan compilation.
when the turbofan code for a function is ready the function code tiers upby replacing the liftoff code with the turbofan code.
firefox uses the spidermonkey javascript and webassembly engine to handle webassembly execution.
similar to v8 spidermonkey contains two compilation engines for webassembly.thefirstcompiler wasm baseline performsafast translationofwebassemblyinstructionstomachinecodeforquick startup.
the second engine wasm ion applies optimizations on the emitted machine code.
spidermonkey follows the tiering up scheme by using wasm baseline to emit machine code quickly whilewasm ion generatesbetter performingmachine code.
counterintuitive inliningexample wedemonstratehowfunctioninliningcancounterintuitivelyimpactruntimebehaviorusingasamplebenchmarkingprogram random.cpp asanexample.wepresentitssourcecodeandcompiled webassembly code in figure .
we highlight the impact on two of thesample sfunctionswhenthefunctioninliningisenabledand disabled.figure a showsthec sourcecodeimplementationof the functions gen random andmain.gen random uses the constants im ia andicto generate a pseudo random number.
the mainfunction calls gen random in a long running whileloop performing400millioniterations making gen random ahotfunction.figure4 b showsthewebassemblycodeof wasm function and wasm function when function inlining is disabled.
the export sectiononline180showsthat wasm function implements main.
inspectingtheloopcodewithin wasm function showsthatit callswasm function with the value .
passed in as an argument meaningthat wasm function implements gen random .
figure4 c shows the webassembly code for the mainfunction wasm function producedwheninliningisenabled.inspecting figure4 b and figure c reveals that wasm function from figure4 b has been inlinedinto wasm function .
whenthechromiumbrowserrunsthiswebassemblymodule machinecodeforeachfunctionisfirstgeneratedusingtheliftoff compiler.oncethiscompilerfinishesgeneratingcodeforafunction thefunctioncanbeginexecuting.inthebackground theoptimizing turbofan compilerbegins generatingbetter performing machine code for that function.
when turbofan finishes generating the machine code the browser switches out the liftoff generated code for the turbofan generated code on the following function call.
however since mainin a c program is onlyinvoked once the browser does notswitchto theturbofan generated code.becausethe hot function gen random has been inlined into main gen random also usestheslowerliftoffcode andtheprogramruntimeperformance is negatively impacted.
this example shows how function inlining can cause counterintuitive runtimebehaviorinwebassembly.
methodology we aim to understand the counterintuitive effects of function inliningonwebassemblyprogramruntime.wedefinea counterintuitive effect as producing a binary with a slower runtime performance than if the optimization was disabled.
specifically we focus on the following researchquestions rq1 significance how often does function inlining counterintuitively impact webassembly modules and are the effects unique to webassembly?
rq2 function characteristics which characteristics of the inlinedfunctionscause the counterintuitive behavior?
rq3 quantification howdoesexcludingcertainfunctions from inliningimpact the counterintuitive effects?
toanswer thesequestions we use samples from thellvm test suitetoperformfivesetsofexperiments.next wediscussthec c sourceprograms andthe experiments indetail.
.
c c sourceprograms tomeasuretheruntimeperformanceimpactsofdifferentoptimization configurations we select c c samples totaling over 000linesofcode loc fromthellvmtestsuite .thetest suite contains benchmarking samples measuring llvm compilation performance.
we focus on the samples within the singlesource benchmarks directory listed in table as these samples aredesignedtotriggeroptimizationsandcanbecompiledbyemscripten without code changes.
we select this test suite for its inclusionofsamplesusedinpriorworksanditeaseofcompilation.
this test suite includes samples from the polybench benchmark suite whichwasusedbyjangdaetal.tocomparewebassembly 352353354355356357358359when function inliningmeetswebassembly counterintuitive impactsonruntimeperformance esec fse december3 san francisco ca usa discussion .
limitations ourinvestigationofwebassemblyperformancesuffersfromtwo main limitations.
first the precision of our custom built javascript measurementtoollimitsthedepthofourinvestigation.mostbrowsers limit javascript timers to millisecond resolution which is too coarsetomeasureatypicalwebassemblycall.asaresult wefocus on samples that have long running functions with runtimes in the magnitude of seconds.
we also focus on samples with a percent decreasegreater than5 to account for the lackofprecision.
our second limitation is that we only inspect two browsers chromium and firefox.
inspecting each browser adds additional manual work and we are limited by our budget of manual effort available.weacceptthislimitationaschromium basedbrowsers andfirefox account for ofthe browsermarketshare .
.
threatsto validity .
.
internal validity.
our study results are subject to possible errorsinthemanualinspectionprocesses.wemanuallyinspectthe emitted code to ensure that function inlining is present or omitted as per the tested configuration.
we use the average of runs to ensure changesare notcausedbysmall runtimevariations.multiplefactors suchashardware operatingsystem andsystemload makeitdifficulttoreproducetheexactruntimevalueswerecord.
however wedescribethestepsusedtoestablishourbaselineexperiment.
the counterintuitive behavior relative to the baseline should remainconsistent acrossdifferentexperimental setups.
.
.
externalvalidity.
weusebenchmarkingsamplesfromthe llvmtestsuite.asemscriptenisanllvm basedcompiler wefind thatthiscollectionofbenchmarkscuratedbythellvmdevelopmentteamiswell suitedtoassessthecompilationeffectscausedby the inlining passes.
the compiler benchmark samples also perform intensive computations an intendeduse caseofwebassembly.
.
.
construct validity.
we identify the runtime impacts of function inlining optimizations by measuring the program runtime through browser execution timing native execution timing and eventprofilingtools.thesemeasurementmethodsshouldhighlight changes causedbydifferentoptimizations usedinthe samples.
.
futurework our currentwork only investigates the counterintuitive behavior oftwoinliningoptimizationpasses.ourmeasurementsshowcases wherethesetwopassesalonecannotexplainthecounterintuitive behavior indicatingthatotheroptimizationpassesalsocausethe behavior.weplantostudytheotherllvmandbinaryenpasses for similar counterintuitive behavior.
our current analysis only focuses on a single metric for counterintuitive behavior runtime performance.
we plan to investigate possible counterintuitive changes in other metrics such as code size memory usage andenergy consumption.
related work compileroptimizations.
existingworkstudiestheimpactsofdifferent optimizations on specific processor architectures andhigh level synthesis .
some work proposes optimization frameworks improving simd performance .
other works leverage machine learning techniques on optimization selection .
theodoridis et al.
describe llvm inlining heuristics improvements in native applications .
to our knowledge our work is the first to study inliningperformance inwebassemblycompilers.
compiler studies.
previous compiler studies investigate the prevalenceofcompilerbugs andsurveydifferentcompilertesting approaches .otherstudiesdevelopcompilertestingtechniques suchasequivalencemoduloinputs andskeletalprogram enumeration .
webassembly performance measurements.
yan et al.
find evidence of optimizations causing counterintuitive effects.
jangda et al.
compare the performance of c programs compiled to webassembly and native code.
in contrast our work focuses on effectsoffunction inliningonwebassemblyapplications.
webassembly program analysis and security.
several works analyze webassembly execution and security.
hilbig et al.
report the use cases and statistics of real world webassembly binaries.
severaltoolsdynamicallyanalyzewebassemblyexecution identifymodulepurposes andrecoverhigh leveltypeinformation from the binaries .
prior work proposes specification and compilerextensionstoimprovesecurity .other worksidentifyvulnerabilitiesinwebassemblyapplications propose attack strategiesusing webassembly anddetectmaliciouswebassemblymodules .
conclusion functioninliningoptimizationsinwebassemblycompilersfailto consider the presence of multiple browser compilers leading to runtime performance issues.
we provide the first in depth investigationonthecounterintuitiveimpactthatfunctioninliningcan have on webassembly modules.
inlining can prevent hot functionality in the modules from leveraging optimized machine code if the functions are inlined into long running or seldomly invoked functions leading to noticeable performance degradation of the wholeapplication.
wefindthatthisbehavioreffects66out of127 samplesinthellvmtestsuiteandiscausedbytheinliningpasses in both the llvm and binaryen components of emscripten.
we hope our work highlights the need to revisit existing optimization techniques for optimal webassemblyusage.
data availability wemakeourexperimentresultsanddatacollectionscriptsavailable on zenodo at .
this artifact containsthemeasuredruntimeresultsforallofourexperiments andthe scripts usedto run the experiments.