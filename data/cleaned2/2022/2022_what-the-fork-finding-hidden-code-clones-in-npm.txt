what the fork?
finding hidden code clones in npmelizabeth wyssuniversity of kansaslawrence ks usaelizabethwyss ku.edulorenzo de carliworcester polytechnic instituteworcester ma usaldecarli wpi.edudrew davidsonuniversity of kansaslawrence ks usadrewdavidson ku.eduabstractthis work presents f indings and mitigations on an under studied issue which we term shrinkwrapped clones that isendemic to the npm software package ecosystem.
a shrink wrapped clone is a package which duplicates or near duplicates the code of another package without any indication or refer ence to the original package.
this phenomenon represents achallenge to the hygiene of package ecosystems as a clonepackage may siphon interest from the package being cloned or create hidden duplicates of vulnerable insecure code whichcan f ly under the radar of audit processes.motivated by these considerations we propose n.sc r.sc a.sc e.sc r.sc a mechanism to programmatically detect shrinkwrappedclones and match them to their source package.
n.sc r.sc a.sc e.sc r.scuses a package di erence metric based on directory treesimilarity augmented with a pre f ilter which quickly weedsout packages unlikely to be clones of a target.
overall ourprototype can compare a given package within the entirenpm ecosystem 061packages with20 452di er ent versions in72.85seconds and it is thus practical forlive deployment.
using our tool we performed an analysisof a subset of npm packages which resulted in f inding up to6 292previously unknown shrinkwrapped clones of whichup to207carried vulnerabilities from the original packagethat had already been f ixed in the original package.
none ofsuch vulnerabilities were discoverable via the standard npmaudit process.acm reference format elizabeth wyss lorenzo de carli and drew davidson.
.
whatthe fork?
finding hidden code clones in npm.
in44th internationalconference on software engineering icse may pitts burgh pa usa.acm new york ny usa pages.
introductionthe security and correctness of code stored in package reposi tories is an important concern because such repositories arecrucial to modern software infrastructure.
indeed language based package repositories such as npm pypi and rubygemscollectively serve billions of packages each week .
muchof the popularity of package repositories is due to the pack age manager frontend which allows a user to easily import apackage by issuing a simple install directive on the commandpermission to make digital or hard copies of part or all of this work for personalor classroom use is granted without fee provided that copies are not made ordistributed for pro f it or commercial advantage and that copies bear this noticeand the full citation on the f irst page.
copyrights for third party components ofthis work must be honored.
for all other uses contact the owner author s .icse may pittsburgh pa usa copyright held by the owner author s .acm isbn .
while seamless import of external code is convenient it also creates problems developers tend to assume code tobe reliable rather than vetting prior to import and once apackage is imported latent bugs and vulnerabilities becomepart of the f inal application.
importing the wrong packagemay cause signi f icant supply chain security issues .this work presents f indings and mitigations on an under studied issue within the npm package repository1 which wetermshrinkwrapped clones.
we use this term to refer to pack ages which are uploaded to a package repository and containcode that is identical or nearly identical to that of an existing legitimate package.
speci f ically we discover two types ofclones i identical clones which contain source code that isidentical to that of an existing package and ii close clones which make potentially signi f icant syntactic semantic changesto the code but generally localized to a small number of f iles we re f ine this de f inition in the following .
this phenomenonis characteristic to npm as this ecosystem lacks the notionof forks by which we mean copied code repositories that ex plicitly link back to their source repositories as is commonfor example in github .
instead shrinkwrapped clones innpm cannot be explicitly linked back their source packagessince npm lacks o cial mechanisms for forking packages.the phenomenon of shrinkwrapped clones represents achallenge to the hygiene of package repositories in particular it contributes to the problem ofconfusabilityof npm packages.npm contains more than .
million packages and while theecosystem provides a robust search interface it provides noassistance in choosing the most appropriate package to pro vide a desired functionality.
previous work on typosquattingattacks suggests that it is fairly common for developersto install a package di erent from the one they intended.clones exacerbate these problems.
most obviously a clonepackage causes confusion as clone packages are oftentimesnamed similarly to the original package and in many occasionsthey also reuse their metadata such as the package descrip tion .
users of the package repository may thus misattributethe provenance of a package giving credit to the wrong de veloper for creating a particular codebase.
however we also f ind that a non trivial number of clone packages are rarelymaintained and fail to include updates to the package beingcopied.
the users of the clone are thereby locked into olderversions of functionality and crucially forgo any bug f ixesthat are applied to the package being cloned.
in e ect the usersof the clone are subject to vulnerabilities which have alreadybeen patched.
moreover clones can exist deep within pack age dependency trees which means that installing a packagethat transitively depends on a clone also implicitly installs1we choose npm as our repository of interest because it is the largest and mostpopular.
ieee acm 44th international conference on software engineering icse icse may pi t tsburgh pa usaelizabeth wyss lorenzo de carli and drew davidsonthat clone via npm s automated dependency resolution mech anism.
for these reasons a user may be unaware that theyhave downloaded a clone wherein vulnerabilty disclosuresfail to propagate because there is no facility in npm to link aclone to the package that has been cloned.in this work we study the scope and impact of shrink wrapped clones.
detecting shrinkwrapped clones presentsseveral challenges.
first there is no agreed upon standard onwhat extent of code reuse constitutes a code clone .
second close clones i.e.
clones that makechanges to the original package exhibit local but complexsyntactic modi f ications e.g.
translating commonjs syntax toes6 .
thus they are incompatible with many existing clonedetectors which focus on the insertion and deletion of state ments we further review related work in section .finally in order to determine whether a package clones anyother the package must be compared to the entirety of npm which leaves limited to no time for any form of code analysis.we address these challenges with a parametrizable heuris tic designed for pairwise package comparison.
the heuristicde f ines shrinkwrapped clones via a tunable f ile granularitysyntactic distance threshold.
with this approach any twopackages whose distance is below the threshold are consid ered close clones or identical clones if the distance equals one2 we discuss strategies for tuning the threshold in section .the heuristic only considers whole f ile hashes and eschewstokenization and any form of lexical analysis making it com putationally e cient a package can be matched for clonesagainst the entirety of npm in a matter of seconds.
based onthis heuristic we propose n.sc r.sc a.sc e.sc r.sc a mechanism to detectwhen a package is a clone of another more popular package.explicitly linking a clone to the package from which it camehas several bene f its.
it enhances the provenance informationof packages restoring the connection to the originators of thepackage.
furthermore it allows users to avoid clone packages preventing them from unwittingly using a less maintainedcopy of a codebase and directing them to the original.
finally users can be made aware of any vulnerabilities that may havebeen reported in the original version of the package.
thus ourapproach constitutes a turnkey solution suitable for operatingover the package repository with no manual intervention.overall our work makes the following contributions we identify and characterize the problem of shrink wrapped clones in the npm package repository.
we propose n.sc r.sc a.sc e.sc r.sc a technique to check when apackage is a shrinkwrapped clone of any other package.
we evaluate n.sc r.sc a.sc e.sc r.scand f ind that it is e ective inpractice to identify shrinkwrapped clones with reason able time and space overhead the majority of packagescan be compared to the existing20mpackage set forclones in72.
secondsusing o the shelf hardware .
we report our f indings based on the analysis of a subsetof npm.
our analyses identi f ied up to6 292clones.
upto2159relied on vulnerable outdated dependencies.furthermore up to207clones directly incorporated2npm packages contain a unique per package metadata f ile which limits packagedistance to a minimum of .vulnerabilities which were not discoverable via the npmaudit process.additionally we publicly release our code and supportingdata freely distributed via the open science framework remainder of our paper is structured as follows.
sec tion reviews background material.
section provides tech nical details of the clone detection methodology.
we describeresults of our experiments in section and discuss our f ind ings in section .
we review related work in section andconclude in section .
background2.
npmnpm consists of a package manager and a repository for soft ware developed for the node.js environment.
npm is the largestonline language based software ecosystem it containsmillions of publicly available packages and weekly downloadcounts range from hundreds of millions to billions.
similar toother package management tools the primary goal of npmis to simplify third party code reuse by managing softwaredependencies.
when a user issues thenpm installcommand the front end constructs a tree of all required dependenciesand then installs each package within the tree without theneed for user involvement.
npm allows packages to be down loaded freely either directly or as dependencies of anotherpackage and allows new packages to be uploaded withoutany external moderation.
however the maintainers have asecurity team whose goal is to detect and remove explicitly ma licious packages either via internal analysis or by collectingexternal reports .
.
versioning and forkingdevelopment in npm is characterized by fast evolving codeand extensive code reuse via import of external dependencies even for trivial functionality .
to help prevent breakage in apackage due to the evolution of its dependencies npm automat ically freezes dependencies within a compatible version range and further allows developers to specify exact dependencyversions via a process known asshrinkwrapping.
using thisfeature guarantees that dependencies will always be fetchedat the version they were originally imported.
however npmo ers no o cial support for developers wishing to modify athird party package prior to importing it.
in other words thereis no explicit concept of aforkas in other ecosystems such asgithub .
as such developers seeking to modify an existingpackage must download alter and then republish the modi f iedpackage under a new name.
for this reason modi f ied packageson npm are di cult to detect to make matters worse when apackage is manually duplicated information attached to thatpackage is lost.
critically this lost information includes boththe original version history and any known vulnerabilities as sociated to the original package typically retrievable vianpmaudit .
thus the act of duplicating a package implicitly hides2416what the fork?
finding hidden code clones in npmicse may pi t tsburgh pa usaopts.log.http quotesingle.varfetch quotesingle.var grave.ts1 method.touppercase res.status res.url elapsedtime ms attemptstr cachestr grave.ts1 listing vulnerable code snippet present in unpatchedversions ofnpm registry fetchand in the most up to date version of evocateur npm registry fetchleturlstrtry const url require quotesingle.varurl quotesingle.var consturl newurl res.url if url.password url.password quotesingle.var quotesingle.varurlstr url.tostring catch er urlstr res.url opts.log.http quotesingle.varfetch quotesingle.var grave.ts1 method.touppercase res.status urlstr elapsedtime ms attemptstr cachestr grave.ts1 listing nonvulnerable code snippet present inpatched versions ofnpm registry fetchimportant information including authorship whether morerecent versions of the same package exist and any knownsecurity issues.
.
shrinkwrapped clonesthe goals of our work are i to measure how frequently de velopers duplicate and potentially modify third party pack ages into one of their packages ii to determine whether thisprocess can have negative security implications and iii todevise techniques for identifying the missing link betweenduplicate npm packages and the original package.
one ques tion wedo notinvestigate iswhydevelopers perform suchduplication as this would require making inferences or as sumptions about developers intentions and goals.
however we did observe that in many cases duplicates are exact copiesof the original package therefore including a duplicate ac complishes the same result as shrinkwrapping the originalpackage at the duplicated version.
it is for this reason that werefer to these packages asshrinkwrapped clones.
an exampleincludes the package redux form v6 which is an exact copyof redux form at version6.
.
.while we use shrinkwrapped clones as an umbrella term forall duplicates we also note that in some cases developers makemetricnpmtotal unique packages1 061total unique package versions20 452total size compressed tbtable statistics related to the size of the npm packagerepositorysmall functional changes to duplicate code prior to republish ing.
a manual review of such cases reveal that in the largemajority of cases the developer intends to remove function ality as in the case of cypress listr verbose renderer which is near identical tolistr verbose rendererbut dis ables logging or to implement programmer preferences xtuc ieee754is a clone ofiee754but reconstructed using com monjs syntax rather than es2015 syntax .the observation above warrants further analysis to whatextentshouldmodi f ications made to a package cause a dupli cate to not be considered a clone?
rather than addressing thequestion above which cannot be answered quantitatively we empirically de f ine a di erence metric and a threshold belowwhich two packages are labeled as clones.
we provide detailson metric and threshold in section and further discuss our f indings in section .
.
vulnerabilities introduced by clonesas described in section shrinkwrapped clones can carrylatent vulnerabilities from the time of their creation.
one suchexample is present in the evocateur npm registry fetchpackage which is a clone of thenpm registry fetchpack age.
versions ofnpm registry fetchprior to version .
.5contain a sensitive data exposure vulnerability in which pri vate information such as password values are written to stdoutand log f iles .
the vulnerable code snippet is depicted inlisting and the relevant patched code snippet that f ixesthe vulnerability is depicted in listing .
evocateur npm registry fetchcopied the codebase ofnpm registry fetchat version .
.
which contains the known sensitive data ex posure vulnerability.
although evocateur npm registry fetchhas received two minor updates since it was f irst pub lished none of these updates f ix the sensitive data exposurevulnerability that still remains in the package s codebase.
.
scale of npm analysistable describes the total size of npm in terms of packages versions and storage.
it is a nontrivial problem to individuallyanalyze millions of package versions accounting for over 13terabytes of package data in total.
as such we focus our e ortson caching metadata and applying heuristics to analyze suchmetadata at scale.
this metadata based approach is consis tent with ongoing industry e orts to analyze large scale opensource package repositories such as the package feeds and kritis projects.
we believe that our metadata basedapproach is e cient and su cient in detecting shrinkwrappedclones we describe our approach in detail in section and2417icse may pi t tsburgh pa usaelizabeth wyss lorenzo de carli and drew davidson figure work f low of u.sc n.sc w.sc p.sc p.sc from collection ofpackages to classi cationwe provide justi f ication for the e ectiveness of this approachin section .
unwrapper designbased on our observations described in section we design n.sc r.sc a.sc e.sc r.scto identify instances of shrinkwrapped clonesthat exist within npm.
in this section we describe our goalsfor this tool and how our design meets those goals.
.
u.sc n.sc w.sc p.sc p.sc assumptions and goalsat a high level we are interested in identifying instances ofpackages that aresimilarto another known package.
fur thermore we also intend to propose practical techniques toidentify these objects at ecosystem scale.
we assume that whilea developer may fail to explicitly acknowledge the source of ashrinkwrapped clone no attempt is made to obfuscate similar ity at the code level.
this assumption is based on the lack ofincentive to do so most npm package code is provided underpermissive licenses which allow reuse and there is nodirect negative consequences for code duplication.we envision n.sc r.sc a.sc e.sc r.scbeing used toretroactivelydetectshrinkwrapped clones that are already present in npm restor ing the provenance of the package code.
using n.sc r.sc a.sc e.sc r.scin this way allows users of npm to detect whether packagesthat they depend on are shrinkwrapped clones and to suggestthe original package that they may prefer.
we also envision n.sc r.sc a.sc e.sc r.scbeing used toproactivelydetect if a new packagebeing added to npm is a clone at the time it is published.the popularity of npm makes analysis challenging thenumber of existing packages already in the repository is sig ni f icant.
furthermore we observe that a key problem withshrinkwrapped clones is that they are clones of non currentversions of other packages.
thus n.sc r.sc a.sc e.sc r.scneeds to matchany package of interest against the entirety of the npm ecosys tem including all versions of all packages.
additionally ap proximately new packages are uploaded daily to npm .
n.sc r.sc a.sc e.sc r.scmust remain able to process all new packageswithout slowing down their deployment.
.
design overviewbased on the discussion above we design n.sc r.sc a.sc e.sc r.scwiththe goal of being able to scale with the growth of a repository it must be relatively fast and lightweight in its analysis and becapable of running in an environment separate from the repos itory itself.
the overall n.sc r.sc a.sc e.sc r.scpipeline is depicted infigure .
packages are initially acquired using an npm crawlerand listener module1in figure .
the task of determiningwhether a package is a clone of another is primarily carried bythe clone detector component module3 .
our approach toshrinkwrapped clone detection leverages the identi f ication ofdi erences between directory trees of candidate original clonepairs where each f ile node is labeled by its name and check sum and no other information about the f ile is considered.this approach does not require performing any code analysisother than checksum computation and is consistent with theassumption of non adversarial settings.however we found that while this approach is e cient it is too time intensive for live analysis of new package up loads.
thus we augmented it with a pre f iltering step module2 .
this pre f ilter sits between the package dataset and theclone detector and quickly weeds out packages unlikely tobe shrinkwrapped clones.
in the following we describe eachcomponent in detail.
.
npm interfacethe frontend of n.sc r.sc a.sc e.sc r.scinterfaces with npm to collectinformation from every version of every package that is cur rently available and analyzes new packages in a timely fash ion.
we accomplished package collection by implementingan npm crawler which downloads and stores each packageversion locally.
this approach allows packages to be accessedrapidly and without burdening the repository with analysisrequests.
since changes to packages are necessarily made asnew versions the package database remains accurate for allexisting package versions and only needs to be updated withnew versions as they are added to the repository.
to supportupdates we implement an npm listener that triggers when ever a new package or a new version of an existing package is added to the repository.
new entries are automaticallyadded to the local package database and queued for detectionas shrinkwrapped clones.
the listener uses the npm webhooksystem and is automatically noti f ied of updates without theneed for polling.
using this system means that new packagesand versions are added to the analysis queue in real time.
.
clone detectorthis component takes in a shrinkwrapped clone package can didate pair and evaluates their similarity by computing adomain speci f ic pairwise di erence metric which we term2418what the fork?
finding hidden code clones in npmicse may pi t tsburgh pa usacandidate clone package checksum computation score calculation p q p q td?
clone identificationcandidate original package checksum computationfigure operation of the clone detector u1d451 score.
more precisely the di erence between two packages u1d443and u1d444is de f ined as u1d451 u1d443 u1d444 u1d43c u1d448 u1d443 u1d448 u1d444 where u1d43cis the number of identically named f iles with dif ferent checksums amongst both packages and u1d448 u1d443 u1d448 u1d444are thenumber of f iles unique name wise to only one of the pack ages.
as such packages with a lower di erence score are moresimilar than packages with a higher di erence score and pack ages with a di erence score of one are semantically identical di ering only in their package.json metadata f ile which is guar anteed to be unique to each package.
a candidate package isconsidered to be a clone of the input package if their pairwise u1d451 score is less than a given threshold u1d447 u1d437acrossanyversionof either package.
we present the design of our clone detectorin figure .
.
.
difference threshold.we determine an appropriate dif ference threshold by manually building an initial dataset ofclone packages.
to do so we analyze the extent to which repos itory urls3are duplicated across the most popular npmpackages.
the initial analysis returned thousands of hits thelarge majority of such hits are caused by packages which aresub modules to other packages e.g.
thelodash.
getarraypackage is a sub module of thelodashpackage which exportsthegetarrayfunction fromlodash .
to f ilter out these sub module packages we removed packages that shared maintain ers with the packages that duplicated their repository urls.applying this f ilter left packages and manual review ofthese packages empirically showed all of them to contain code bases that were initially copied over from the packages thattheir duplicated repository urls originate from.we then examined the distribution of u1d451 scores within thesample of packages plotted in figure .
out of 38cloneshave u1d451 scores at or below .
conversely analysis of a set ofpackage pairs which do not include clones reveal u1d451 scores inthe tens or hundreds.
the four identi f ied clone packages with u1d451 scores greater than all made substantial changes to thecore functionality of the packages that they cloned and had u1d451 scores no less than .
thus to minimize false positives we3npm packages can optionally express a source repository url such as a githubpage as metadata we further analyze the e ectiveness of source repositoryurl duplication as a clone detection signal in section .
.figure distribution of difference scores across a sam ple of manually identi ed clone packagesclone file tree size u1d451 score threshold11223446586107 11table u1d451 score threshold by clone le tree sizeempirically choose11as the u1d451 score threshold below whichtwo packages are labeled as shrinkwrapped clones.this u1d451 score threshold is further tightened in cases wherepackages have very few f iles as to prevent small packagesfrom being falsely over reported as shrinkwrapped clones ofother small packages.
table depicts our determined u1d451 scorethreshold as a function of f ile tree size.
these thresholds wereselected empirically by measuring the u1d451 scores in cases wheresmall packages were falsely identi f ied as shrinkwrapped clonesof other small packages.
.
clone pre lterour design goal of supporting real time detection of shrink wrapped clones requires a scalable analysis that accounts forthe size and rapid growth of npm.
handling the scale of npmis a technical challenge in its own right.
our core similaritymetric requires a pairwise comparison against each packageversion of which there are over million at the time of thiswriting.
in recognition of this scalability challenge we imple ment a clone pre f ilter mechanism which rapidly determines ifa package is a candidate for pairwise similarity metric check ing.the f irst design goal for the pre f ilter is to speed up match ing against the pre existing package dataset.
furthermore itshould eliminate packages from consideration that are unlikelyto be marked as clones during the full clone detection pass.2419icse may pi t tsburgh pa usaelizabeth wyss lorenzo de carli and drew davidson figure functioning of the clone pre lterin service of speeding up matching in the pre f ilter we aimto precompute as much information as possible about knownpackages in the repository.
however given the scale of thenpm ecosystem it is also necessary to ensure that i precom puting the necessary information for the entire set of existingpackages does not become a signi f icant bottleneck and ii precomputed information has a memory footprint compati ble with o the shelf hardware.
we present a pre f ilter designmeeting those conditions below the approach is also depictedin figure .like the clone detector the pre f ilter uses folder structuresimilarity to identify potential clones however the similaritymetric is purely based on f ile names i.e.
it uses no informationconcerning f ile content .
speci f ically a package u1d443is repre sented as a f ingerprint u1d439 u1d443de f ined as u1d439 u1d443 uni210e u1d45d1 .
.
.
uni210e u1d45d u1d45b where each of u1d45d1 .
.
.
u1d45d u1d45bis a package f ile path and uni210e u1d45d u1d460 uni210e u1d44e256 u1d45d i.e.
the bit pre f ix of the sha256 hash of thepath4.
computing f ingerprints for 20m npm packages takes29.
hours.
the resulting f ingerprint set requires80.
gbofin memory storage.
therefore this design meets our practi cality requirements above.given a set of package f ingerprints the pre f ilter determineswhether a target package is a candidate clone for an existingpackage u1d443as follows.
first it computes u1d439 u1d436 u1d439 u1d443 i.e.
thedi erence in number of f iles in each packages.
if the result isabove a threshold u1d447 u1d446 the candidate is dropped.
second it com putes u1d439 u1d436 u1d439 u1d443 u1d439 u1d436 i.e.
the overlap between f ingerprintsnormalized by the number of f iles in the candidate clone.
ifthe result is below a threshold u1d447 u1d442 the candidate is dropped.additionally any packages that share maintainers with pack age are dropped this is to prevent submodule packages andmaintainer intended duplicate packages from falsely beingidenti f ied as clones and further if package contains nosource code f iles it is excluded from consideration this isto prevent trivial packages with no code from falsely beingidenti f ied as clones otherwise the candidate is forwarded tothe clone detector as depicted in figure .
based on roc curveanalysis we found that setting u1d447 u1d446 and u1d447 u1d442 .
results in agood balance of minimizing false negatives and false positives.in a production deployment these parameters can be furthertuned to satisfy the desired roc characteristic of the pre f ilter.4we use this hash function for convenience in our python prototype the func tioning of the pre f ilter is largely orthogonal to the choice of function.table .1pre lter performancemetricmin timemax timeavg timeadd a packageto pre f ilter0.
ms442 ms5.
mstest a packageagainst pre f ilter54.
s203.
s70.
stable .2clone detector performancemetricmin timemax timeavg timefirst test174 ms5 ms319 msadditional tests168 ms3 ms255 mstable performance metrics related to our shrink wrapped clone detector and pre lterthe rationale for choosing this particular combination oftests is based on the goal of approximating the u1d451 score compu tation which identi f ies packages as similar if they have mostof their f iles in common.
at the same time the pre f ilter ignores f ile content resulting in a vastly more e cient computation.
evaluationto evaluate the practicality and e ectiveness of our shrink wrapped clones detection pipeline we focus on answeringthree research questions rq1 is the pipeline s performance satisfactory in gen erating pre f ilter f ingerprints for the entire npm packagerepository?
rq2 does the pipeline o er real time performancecapable of scaling with the growth rate of npm?
rq3 is the pipeline e ective in discriminating shrink wrapped clones from novel packages?in the remainder of this section we detail our methodologyused to answer these research questions we discuss our results and we present an analysis of detected clone packages.
.
performancewe measure the minimum maximum and average time thatour shrinkwrapped clone detector and pre f ilter require to per form their operations and we present the measured perfor mance metrics in table .
all measurements are collectedacross independent trials on a centos linux serverwith an intel xeon gold processor operating at .
ghz.the rest of this subsection discusses the online and o ineperformance of our shrinkwrapped clone detection pipelineas laid out in rq1 and rq2.pre lter fingerprint generation since shrinkwrapped clonedetection relies on information about the f ile structure of ev ery version of every npm package our pipeline must be ableto retro f it the entire npm package repository with reasonableperformance.
from analyzing every package publicly availableon npm we f ind that there exists unique versions ofpackages on npm.
all of these unique package versions mustbe added to our pre f ilter s f ingerprint database in order for2420what the fork?
finding hidden code clones in npmicse may pi t tsburgh pa usaour shrinkwrapped clone detection pipeline to function.
ta ble .
row details the time to add a package to the pre f ilter.given that our pre f ilter can add a single package version to its f ingerprint database in an average time of .
ms generatinga f ingerprint database that contains every unique package ver sion across npm requires .
hours of cpu time.
to lessenthe required time this process of adding packages to our pre f ilter s f ingerprint database can be parallelized across multiplecpu cores to reduce the required time to a mere fraction of29.
hours.
with parallelization in mind we believe that thisperformance in generating pre f ilter f ingerprints for the entirenpm package repository is reasonable since retroactively gen erating the pre f ilter s f ingerprint database is a process thatonly needs to be done once.real time clone detection because of npm s rapid growthin packages per day real time shrinkwrapped clone detectionrequires performance that scales with the growth rate of npm.at the time of writing npm is growing at rate of just over850 new packages per day .
in order to keep up with anew package uploaded to npm our pipeline requires that thenew package is added to the pre f ilter and tested against thepre f ilter ref.
to table .
and then any positives reported bythe pre f ilter must be veri f ied with the clone detector.
table .2details the time for the clone detector to determine whethera package is a clone of another.
since a candidate clone istypically matched against multiple potential matches from thepre f ilter we report analysis times both for the f irst test andsubsequent ones.
subsequent tests are typically faster as f ilehashes for the candidate clone need only to be computed once.given the performance results listed in table our shrink wrapped clone detection pipeline can perform its requiredoperations on just a single cpu core within 850th of a dayas long as the pre f ilter reports fewer than positives onaverage.
in practice we f ind that the majority of packages canbe tested against our entire shrinkwrapped clone detectionpipeline within .
seconds.
we note that our shrinkwrappedclone detection process is highly parallelizable and could eas ily utilize multiple cpu cores if the growth rate of npm or thetotal positives reported by the pre f ilter were to increase.
assuch we consider the real time performance of our pipeline tobe more than reasonable with respect to the scale and growthrate of npm.
.
effectiveness of clone detectionwe now analyze the e ectiveness of our tools in detectingshrinkwrapped clones as described in rq3.clone detector due to the inherent lack of ground truthregarding whether a package is a clone of another package we rely on random sampling and manual vetting to verify thee ectiveness of our shrinkwrapped clone detector.
our truepositive veri f ication process is as follows we f irst collect arandom sample of packages that our clone detector positivelyidenti f ies as non identical clones of another package.
then both packages in the identi f ied original clone relationship aremanually examined in terms of their f ile tree structures and f ile contents.
lastly we mark identi f ied clone packages as falsepositives if their clone relationship cannot clearly be identi f iedfigure distribution of pre lter false positives acrossall tested clone packagesfrom their package f iles.
in a random sample of one hundredpackages that our detector reports as clones we f ind a totalof true positives and false positives.we f ind that the false positives reported by our clone detec tor share a set of common properties that increase the di cultyof clone detection.
they are all small packages with limitedfunctionality they contain very few f iles and they have shortand nondescriptive names such as copy merge and capitalize.as such these packages are similar to other small packagesthat provide independent implementations of similar function ality and our clone detector can misreport them as clones.despite the existence of these few false positives we believethat our clone detector s precision of is satisfactory inaccurately detecting shrinkwrapped clones.pre lter we utilize clone packages identi f ied by our detectoras the basis for ground truth in evaluating the e ectiveness ofour pre f ilter.
we randomly sample identi f ied clone pack ages test them against our pre f ilter and then record the totalnumber and kind of positives reported by the pre f ilter.
fromthis experiment we f ind that the recall of our pre f ilter i.e.
thepercentage of correctly identi f ied known clone relationships is .
.
we present the cumulative distribution function ofobserved false positives identi f ied by our pre f ilter in figure .from this distribution we f ind that the median number offalse positives reported by our pre f ilter is although thereexists a small portion of input packages that generate falsepositive quantities in the thousands.
this is consistent withthe pre f ilter design goal of maximizing recall at the cost ofprecision.
given that the pre f ilter is merely the f irst step in ourshrinkwrapped clone detection pipeline which involves veri fying positives using our clone detector we believe that thequality and quantity of reported positives is quite reasonable especially with the parallelizable performance of our clonedetector.2421icse may pi t tsburgh pa usaelizabeth wyss lorenzo de carli and drew davidson figure distribution of total weekly downloads overall identi ed clone packages.
the .
of clone pack ages right of the red line have more than weeklydownloads and are likely installed by real users4.
analysis of clone packageslastly we analyze packages that our pipeline identi f ies asclones in order to quantify and categorize the posture of shrink wrapped clones across the npm package ecosystem.quantifying total clones across the npm registry t oquantify how many clones potentially exist within the entirenpm package registry we collect a random sample of 000npm packages and test our shrinkwrapped clone detectionpipeline against those packages to estimate an upper boundof how many clones exist in the entirety of the npm packageregistry.
out of the randomly sampled packages ourdetection pipeline identi f ies or roughly .
of analyzedpackages to be clones of another npm package.
by extrapolat ing this ratio to the entire npm package ecosystem 061packages we estimate that as many as npm packagescould be shrinkwrapped clones of other packages or be clonedby other packages.
this sheer quantity of packages only am pli f ies the impact and dangers imposed by the existence ofshrinkwrapped clones.we further analyze the packages positively identi f iedas shrinkwrapped clones by our detection pipeline to quantifythe extent to which name similar clones likely exist withinthe npm package ecosystem.
clones that are similar in nameto the packages that they clone pose a more serious threatto the health of npm given that they lead to much greaterconfusability in package provenance.
we f ind that out ofthe identi f ied shrinkwrapped clones or approximately have package names such that the cloned package s name is asubstring of the clone package s name.
while there certainlyexists shrinkwrapped clones with dissimilar names we believethat focusing our analysis on the clones with the most potentialto cause harm is the right direction for this work.identical clones and close clones in this analysis wedistinguish between two distinct subsets of clones that ourpipeline detects identical clonesandclose clones.
identicaltable .1clone dependents on npmdependent typeidentical close total dependents3976 496dependents bysame maintainers1602 588dependents bydi erent maintainers2373 908table .2clone repository urlsurl typeidentical close copied url2103 153unique url1212 602no url17189table statistics categorizing identical clones and closeclonesclones are identical in contents character by character toa speci f ic version of another package although they may dif fer in metadata .
in contrast close clones make some sort ofmodi f ication or extension to the packages that they clone.from analyzing similarly named packages across the entirenpm package registry our shrinkwrapped clones detectionpipeline identi f ies identical clones and close clonesthat are publicly available on npm.clone popularity the relative popularity of packages canbe inferred from npm since the registry publicly provides theweekly download counts of all packages figure depicts thedistribution of weekly download counts across all identi f iedclone packages.
however weekly download counts do notaccurately represent the quantity of real users of a packagesince npm mirrors and bots routinely download packages forstorage and analysis.
the npm development team estimatesthat packages with fewer than f ifty downloads per day arelikely never installed by a real user .
from this metric of f ifty downloads per day we identify clones that have weeklydownload counts greater than as likely installed by realusers and clones that have fewer than weekly downloadsas low impact packages that are likely never installed by realusers.
we f ind that out of the identi f ied identical clonesand out of the identi f ied close clones have more than350 weekly downloads ranging from a few hundred to morethan ten million and are very likely to impact real users.clone dependents due to package dependencies acrossnpm it is possible that packages are indirectly installed andutilized as part of other packages.
as such we analyze the ex tent to which packages across npm depend on identi f ied clonepackages to further quantify the use of shrinkwrapped clones.table .
details npm packages that depend on identi f ied clonepackages.
we f ind that a total of packages depend on one ormore of the identi f ied identical clones and a total of 496packages depend on one or more of the identi f ied closeclones.
upon further examination we f ind that out of the397 identical clone dependents are packages that are addition ally developed by the same maintainers as the identical clone 2422what the fork?
finding hidden code clones in npmicse may pi t tsburgh pa usatable 5clone vulnerability popularityclone typeidentical close likely downloaded21399more vulnerable622 304likely downloaded and more vulnerable4148more vulnerable and vulnerabilities undetected by audit17190likely downloaded and more vulnerable and vulnerabilities undetected by audit08table measured popularity and vulnerability statistics of identical clones and close clones figure distribution of total package updates over allidenti ed clone packagesand out of the close clone dependents are packagesthat are also developed by the same maintainers as the closeclone.
this tendency for package maintainers to utilize theirown shrinkwrapped clone packages as dependencies in addi tional packages that they develop could suggest one reason asto why package maintainers create clone packages they in tend to use their functionality for development purposes.
dueto the existence of a large quantity of shrinkwrapped clonedependents the total impact of clone packages is increased since clone packages are installed unknowingly whenever auser installs a package that depends on a clone.clone maintenance packages that are rarely or never main tained pose issues of health to the npm package ecosystembecause it is less likely that their bugs and security vulnerabili ties are ever addressed.
we examine the update history of clonepackages to determine if these packages are well maintainedor published yet forgotten.
figure illustrates the distributionof total package updates across all identi f ied clone packages.we f ind that out of the identi f ied identical clones and2 out of the identi f ied close clones have never re ceived a single package update.
this lack of maintenance posesa serious threat to the health of the npm registry.latent vulnerabilities in clones the greatest danger thatshrinkwrapped clones pose is that they can contain old vul nerabilities with known exploits that used to be present inthe packages that they clone.
we analyze the extent to whichclones contain latent vulnerabilities by scanning the npm ad visory database for vulnerabilities in the clone s dependencies in the relevant version of the cloned package and in the cloneitself.
we f ind that out of the identi f ied identical clonesand out of the identi f ied close clones contain vul nerabilities that are not present in the most up to date versionof the cloned package.
most of the identi f ied vulnerabilitiesare located in outdated versions of clone dependencies andthese kinds of vulnerabilities could be resolvedifa user exe cutes an npm audit to f ix known vulnerabilities within theirinstalled packages.
however vulnerabilities that exist directlyin the code of a cloned package version will also exist in thecode of the corresponding clone and even an npm audit can not detect these vulnerabilities since the npm frontend lacksawareness of clone relationships.
we f ind that out of the 62more vulnerable identical clones and out of the morevulnerable close clones potentially contain these kinds of la tent vulnerabilities that are undetectable by standard auditingprocedure.because it is possible that a close clone package maintainercould independently discover and f ix a vulnerability copiedover from a cloned package we randomly sample of the 190close clones containing potentially unreported vulnerabilities and we manually verify whether the vulnerability found in thecloned package is still present in the clone package.
we f indthat in cases the vulnerability is present in the clone andundetected by an npm audit and we f ind that in cases thepackage identi f ied as a clone was falsely identi f ied as a clone.hence these previously undetected vulnerabilities are quiteprevalent and even a security conscious npm user cannot f ixthem with the auditing tools provided by npm.we also examine the intersection between clone packagepopularity and clone package vulnerabilities to determinewhether real users are likely impacted by these vulnerabilities.these intersecting subsets of identi f ied clones are describedin table .
we f ind that out of the identical clones withmore than weekly downloads and out of the closeclones with more than weekly downloads contain latentvulnerabilities not present in the most up to date version ofthe cloned package.
we further discovered that of the 148vulnerable close clones likely downloaded by real users alsocontain vulnerabilities that are not detected by an npm audit and one of these clones evocateur npm registry fetch has more than one million weekly downloads.
as such weconclude that clone vulnerabilities pose an imminent threatto the npm package ecosystem because they are exposing real2423icse may pi t tsburgh pa usaelizabeth wyss lorenzo de carli and drew davidsonusers to known exploits of old vulnerabilities and are evadingreasonable detection by security conscious users.clone repositories in npm package metadata often con tains a repository url pointing to where the package coderesides typically in the form of a github url.
we analyzewhether identi f ied clones copy the repository url of the pack age that they clone to determine if repository urls couldserve as a su cient signal in detecting shrinkwrapped clones.the breakdown of repository urls across identi f ied clonepackages is detailed in table .
.
because identical clones cande f ine their own distinct metadata we f ind that out of theidenti f ied identical clones copy the repository url ofthe cloned package have a unique repository url and 17do not provide a repository url.
out of the identi f iedclose clones we f ind that copy the repository url of thecloned package have a unique repository url and 189do not provide a repository url.
we compare these url ratiosto the npm registry as a whole where of packages providea repository url and of packages do not.
hence packagerepository urls can provide some good insight into validatingpackage clone relationships but they are not su cient as aclone detection signal.
discussion5.
disadvantages and bene ts of clonesthe existence of identical clones o ers no bene f it to the npmecosystem since npm already allows shrinkwrapping depen dencies where speci f ic versions of packages can be speci f iedas dependencies.
identical clones simply introduce more po tentially vulnerable and less documented packages to npm and in particular identical clones o er no functional bene f itover using a shrinkwrapped version of the cloned package.the existence of close clones o ers some bene f it to de velopers requiring modi f ied packages but npm lacks directsupport for this such as through forking packages.
this leadsto clones on npm being poorly documented prone to latentvulnerabilities and lacking maintenance.in both cases having a technique which can identify clonescan o er bene f its.
creators of identical clones can be redi rected to use the npm shrinkwrap feature instead.
clones withfunctional di erences can be explicitly linked to their originalpackages so that an auditing team discovering a vulnerabilityin one package can check whether the same exists in the other.
.
future workwhile this work focuses on the detection and classi f ication ofshrinkwrapped clones we identify several directions for fu ture work most notably in mitigating the dangers that shrink wrapped clones pose.registry integration of forking.we note that registry sup port for forking packages and tracking fork relationshipswould help to mitigate many of the ecosystem health con cerns introduced by shrinkwrapped clones.
with explicitlylabeled fork relationships package confusability would be re duced the update history and authorship of fork packageswould be transparent and vulnerabilities discovered in forkedpackages would also be detectable in fork packages.forking integration could be implemented directly into npmwith the assistance of registry maintainers or it could be im plemented independently in a mirror of the npm registry.
thegreatest challenge posed in accomplishing this integrationis in manually retro f itting existing clone packages as o cialforks.
we believe that our clone detection pipeline n.sc r.sc a.sc e.sc r.sc would aid greatly in this process although it is still achallenging problem of scale to tackle given the total size ofthe npm package registry.clone update patching.we consider the implementation ofpatching tools capable of applying security critical updates toclone packages to be another worthwhile direction for futurework.
with knowledge of clone relationships and critical up dates to cloned packages code patches for old vulnerabilitiesand bugs are identi f iable.
these patches can then be appliedto clone packages thus resolving critical issues that have pre viously been f ixed in their corresponding cloned packages.the greatest challenge posed by this approach is that pro gramatically altering code especially in highly dynamic pro gramming languages such as javascript is notoriously di cult.although many patches applied to packages are very straight forward in nature a patching tool will likely encounter manypatches that are di cult or impossible to programatically re solve.
as such we leave navigating this challenge as an avenuefor future work.
related workdetection of code clones there is a signi f icant body ofwork on the detection of code clones i.e.
instances where asoftware is duplicated without maintaining clear attribution ofthe original source code.
early e orts were based on extractionof lexical features as f ingerprints.
moss by schleimer etal.
is based on a winnowing algorithm to select small sectionsof source code which are then used as f ingerprints.
many sim ilar approaches utilize n grams to extract f ingerprints.
smithand horwitz propose a clone detection algorithm basedon the identi f ication of least frequent n grams.
kim et al.
use similarities in locality disjoint n grams for clone detec tion.
ishio et al.
propose a clone detection approach basedon identi f ication of minimum valued sets of n gram hashes.nil by nakagawa et al.
utilizes the longest commonsubsequence of n grams to detect clones with extensive modi f ications.deckard by jiang et al.
uses a novel ast clusteringalgorithm for identi f ication of similar code.
clever bynayrolles and hamou lhadj detects clones based on simi larities within code blocks modi f ied by commits in versioncontrol systems.
for a review of other similar works we referthe reader to merlo et al.
.
more recent work investigatesthe application of modern machine learning techniques to theproblem .many of the above techniques focus on clones that insertand delete statements of code yet within the domain of npmwe observe signi f icant clones that exhibit complex syntacticmodi f ications that lie outside the models of existing clone2424what the fork?
finding hidden code clones in npmicse may pi t tsburgh pa usadetectors.
in our work we eschew code based features formetadata analysis due to these domain speci f ic challengesand performance requirements in order to operate at scale.e ciently and e ectively integrating the techniques above forclone detection is an interesting direction for future work.provenance inference our work speci f ically attempts toaddress which package has been cloned as opposed to simplyclassifying a package as a clone.
in this regard our work hassome similarities to previous works that attempt to infer theprovenance of code.
a related problem in provenance inferenceis that of authorship attribution mapping a softwaresample either in binary or source code to thedeveloper who created it.
our work explicitly considers thee ect of similarity on the security and stability of the language based ecosystem in which the clone appears.
furthermore authorship information alone is not su cient to detect clones since an author may create numerous legitimate packages andmany packages are the result of many distinct contributors.characterization of package repositories previous re search has investigated the structure and evolution of variouspackage repositories .
however these works do notspeci f ically analyze or discuss their security.
unlike these pastworks our work seeks to characterize and address a speci f icsecurity relevant phenomenon present in the npm packagerepository which we believe generalizes to other repositoriesas well .security and stability of package repositories a numberof previously published works have investigated the e ect ofdependencies on the security and stability of software stored inpackage repositories chie f ly npm .other package managers have also been an object of study .
more generally poorly vetted dependencies representan example of supply chain security issue a topic that hasbeen discussed extensively and has recentlyreceived renewed attention .
finally some recently pro posed techniques aim at directly identifying malicious pack ages via code and or metadata analysis .
ratherthan analyzing existing dependencies and vulnerabilities ourwork focuses on identifying hidden relationships and thuspotential security issues between packages.
to our knowl edge our work is the f irst to identify the shrinkwrapped clonephenomenon as a cause of security and stability issues.
conclusionthe hygiene of package repositories is an important concernfor the usability of language ecosystems.
programmers rely onthe ecosystem to discern which packages are appropriate fortheir requirements to deliver patches to package code and tocommunicate vulnerabilities or bugs.
package maintainers relyon the ecosystem to credit their contributions appropriately.maintaining package provenance is key to these capabilities.in this work we describe a phenomenon that we call shrink wrapped clones.
this phenomenon threatens the hygiene ofthe repository by obscuring the provenance of individual pack ages weakening the security and usability of the entire lan guage ecosystem.
we analyze npm and show that shrink wrapped clones are observable.
we show the harms of shrink wrapped clones by reporting on instances that we found ofclone packages that present older vulnerable versions of otherpackages.
furthermore we discover cases in which obscur ing the provenance of these packages limits the reporting ofsecurity f laws and the deployment of patches in practice.to address these issues we have developed an analysis thatis capable of detecting shrinkwrapped clones and restoringthe provenance of a package.
we implemented our analysisin a prototype tool we call n.sc r.sc a.sc e.sc r.sc which is capable ofoperating e ciently in real time at the scale of the entirenpm repository.
tools such as n.sc r.sc a.sc e.sc r.scare a step towardsmitigating the threat of shrinkwrapped clones and improvingthe hygiene of language ecosystems.
acknowledgementswe thank the anonymous reviewers for their insightful feed back that greatly aided us in improving this work.
this workwas partially supported by a generous gift from the googleopen source security team.