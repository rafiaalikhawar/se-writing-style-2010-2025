accurate method and variable tracking in commit history mehran jodavi concordia university canada m jodavi encs.concordia.canikolaos tsantalis concordia university canada nikolaos.tsantalis concordia.ca abstract tracking program elements in the commit history of a project is essential for supporting various software maintenance comprehension and evolution tasks.
accuracy is of paramount importance for the adoption of program element tracking tools by developers and researchers.
to this end we propose codetracker a refactoringaware tool that can generate the commit change history for method and variable declarations with a very high accuracy.
more specifically codetracker has .
precision and recall in method tracking surpassing the previous state of the art tool codeshovel with a comparable execution time.
codetracker is the first tool of its kind that can track the change history of variables with .
precision and .
recall.
to evaluate its accuracy in variable tracking we extended the oracle created by grund et al.
for the evaluation of codeshovel with the complete change history of all variables and parameters declared in the methods comprising the grund et al.
oracle.
we make our tool and extended oracle publicly available to enable the replication of our experiments and facilitate future research on program element tracking techniques.
ccs concepts software and its engineering software maintenance tools software configuration management and version control systems .
keywords commit change history refactoring aware source code tracking acm reference format mehran jodavi and nikolaos tsantalis.
.
accurate method and variable tracking in commit history.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction developers routinely track code snippets in the commit history to facilitate various software engineering tasks.
codoban et al.
surveyed developers to find the motivations behind examining software history.
the most common reasons are to a recover the rationale behind a snippet of code b find the commits that introduced a bug c find who are the knowledgeable peers on certain permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
and patterns d reverse engineer requirements from code e keep up with how the code state evolves f apply changes from other branches into the main branch.
the surveyed developers also expressed some challenges with the usability of existing tools such as their inability to detect file moves and renames and their difficult configuration e.g.
setting up git bisect to find the commit that introduced a bug .
.
motivation grund et al.
conducted a survey with professional software developers and found that they prefer source code history information at the method function and class level rather than the file level.
moreover the tools used by the developers to inspect code history such as git log and intellij s history feature are unable to find the commit that actually introduced a method and deal with complex structural changes e.g.
method moves .
latoza and myers surveyed professional software developers at microsoft and asked them to list hard to answer questions that they had recently asked about code.
among the collected responses developers asked about where was this variable last changed?
when debugging when how by whom and why was this code changed or inserted?
when they want to find the code s creation in history to understand its context and motivation and finally how has it changed over time?
when they want to know the entire history of a block of code rather than its most recent change.
these findings motivate the need for developing tools that can track change history at a more fined grained level focusing on specific program elements such as methods functions and variables.
accurate code snippet tracking is also essential in many areas of software engineering research.
alencar da costa et al.
pointed out that bug inducing analysis algorithms e.g.
szz suffer from broken historical links due to file moves and renames.
this further affects the results of defect prediction techniques and empirical studies investigating the characteristics of bug introducing changes which rely on the original szz algorithm or its variants .
shen et al.
showed that automatic source code merging tools often fail to track the changed program elements correctly due to overlapping refactoring operations and thus are unable to perform the auto merging.
the automatic migration of client software to newer library and framework versions requires to track the updated api program elements i.e.
methods and fields from the source to the target version extract changes in the api signatures and adapt accordingly the api