imperative versus declarative collection processing an rct on the understandability of traditional loops versus the stream api in java nils mehlhorn independent consultant essen mail nils mehlhorn.destefan hanenberg paluno the ruhr institute for software technology university of duisburg essen germany stefan.hanenberg uni due.de abstract java introduced in version with the stream api means to operate on collections using lambda expressions.
since then this api is an alternative way to handle collections in a more declarative manner instead of the traditional imperative style using loops.
however whetherthestreamapiisbeneficialincomparisontoloopsinterms of usability is unclear.
the present paper introduces a randomized controltrial rct ontheunderstandabilityofcollectionoperations performedon20participantswiththedependentvariablesresponsetimeandcorrectness.astasks subjectshadtodeterminetheresultsforcollectionoperations eitherdefinedwiththestreamapiorwith loops .
the results indicate that the stream api has a significant p .
and large 2p .
mloop mstream positive effect on the responsetimes.furthermore theusageofthestreamapicaused significantlylesserrors.andfinally theparticipantsperceivedtheirspeedwiththe streamapihighercomparedtotheloop basedcode and the participants considered the code based on the stream api asmorereadable.hence whileexistingstudiesfoundanegative effect of declarative constructs in terms of lambda expressions on the usability of a main stream programming language the present study found the opposite the present study gives evidence thatdeclarative code on collections using the stream api based onlambda expressions has a large positive effect in comparison to traditional loops.
keywords programming languages lambda expressions declarative imperative java streams acm reference format nils mehlhorn and stefan hanenberg.
.
imperative versus declarative collection processing an rct on the understandability of traditional loops versus the stream api in java.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
introduction in programming the use of collections i.e.
lists or sets of values or objects is quite essential.
however different kinds of programming languages provide different means to operate on collections.
in imperative programming languages there are typically loop constructs thatpermit incombination withadditional operators toiterateoveracollectioninorderto forexample selectcertain elementsortomapthecollectiontosomeothervalues.atypical exampleofsuchanapproachisthefor loopthatcomesindifferent styles and syntaxes and that can be found in almost all imperative programming languages from basic over c up to java.
declarative programming languages on the other hand typically follow a differentapproachwheretheiterationoveracollectionishidden by someabstraction that receivesa condition that needs tohold on the results.
in functional programming languages such conditions are typically given using lambda expressions.
while rather imperative programming languages such as smalltalk supported lambda expressions right from the beginning popularlanguagessuchasjavaorc supportedlambdaexpressions relatively late.
in the case of java the alternative to the traditionalloopsappearedwithjava8in20132wherelambdaexpressions were introduced in addition to the stream api that made use of lambda expressions.
figure1illustratestwoalternativestofilterobjectsfromacollectionusingeitherloopsorthestreamapi.theloopimplementation requiresfirstadefinitionoftheresultcollection.then theinput collection is iterated and for each element it is checked via an if statement whether the age is or higher.
if this is the case the objectisaddedtotheresultcollection.forthestreamimplementation a stream has to be received from the collection by callingthe method stream .
then the filter method is invoked with a lambdaexpression representingthebooleanexpressionthathas to match each element of the result .
finally the result is collected in the example into a list .
in java the stream code is quite verbose because of the additional stream andcollect invokations which is the result of a strict distinction between the collection api and the stream api.
inotherlanguagessuchas forexample smalltalk thatprovides 1the theoretical background for functional programming is the lambda calculus that has lambda expressions as one of the core language features see for example forageneralintroductionintothelambdacalculusanditsapplicationformodeling programming languages .
2the language specification was published in .
3technically streamapidoesnotnecessarilyrequiretheapplicationoflambdaexpressions i.e.
it is also possible to use inner classes.
however it seems quite common not to use inner classes for in the stream api and use lambda expressions instead.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa nils mehlhorn and stefan hanenberg methodscomparableto filter injava theresultingcodewould be slightly shorter because the two mentioned method calls are not necessary.
collection person persons ... collection person a dults ... a traditional filter o peration using loops for person person persons if person.age adults.add person b filtering a collection using the stream api adults persons.stream .filter p p.age .collect collectors.tolist figure1 filteringobjectsfromacollectioninjavausing a loops and b the stream api.
ifwecomparethecodeusingloopsandthestreamapiinfigure thereisnolargerdifferenceintermsoflinesofcode weomitted thebracketsintheloopversionwhichwouldmakethecodeslightly longer .
but the more complex operations on collections are the longerseemstobetheloopcodeincomparisontostreamapicode.
although the usage of the stream api has some other technical implications such as a probably easier way to do iterations inparallel both ways to write the code coexist.
and it is unclear what way is preferable.
a first experiment that appeared in icse suggested that lambda expressions for iterating collections in c have problems when developers novices or junior developers need to write them while for senior developers at least no benefit was detected .
however thestudydidnottakeintoaccountthatlambdaexpressions once they have been finished have a potential positive effect on the understandability of the code.
the present paper studies the possible effect of declarative constructsfromadifferentangle insteadofwritingexpressions participantsreadcodethatoperatedonacollection eitherusingloops orusingthestreamapi andthendecided whattheresultofthe codeis.arandomizedcontroltrialthatreliedonthemeasurements of volunteers revealed with strong evidence p .
a large positive effect of the use of the stream api 2p .
it took the subjects on average longer to solve the tasks using loops incomparison to the stream api but the experiment also revealedthat the difference between loops and the stream api depends on the kinds of collectionoperations.
an additional questionnaire given to the participants revealed that participants perceived their ownspeedin understanding the code using the stream api higher than their speed with code using loops.
this indicates that thepositive effect ofthe streamapi isnot onlyan effectthatcan beseen in a larger study but an effect that developers can perceive via self observations.
background conceptually lambda expressions are anonymous functions i.e.
functionswithoutaname thatcanbepassedasparameters storedintovariablesorsimplyinvoked.lambdaexpressionsare andwere anessentialandcommonlanguageconstructinfunctionalprogram minglanguagessincedecades seeforexample andevensome non functionalprogramminglanguagessuchastheobject oriented language smalltalk had lambda expressions right from start.
but a number of main stream programming languages often didnot have lambda expressions in their initial designs.
we alreadymentionedthatjavareceivedlambdaexpressionsabout20yearsafterthereleaseofitsfirstversion.otherlanguagesevolvedinasimilar way.
for example python was originally released underthe version .
but the introduction of lambda expressions appearedoneversionlater inversion1 .c introducedlambda expressionsinversion11 c introducedlambdaexpressions in version php received them in version .
etc.
but although the concept of lambda expressions exists in differentlanguagesforyears therearestillanumberofdifferences between them.
examples of these differences are syntactical differenceseither betweenlanguages oreven specialsyntaxconstructs withinalanguageaswell.additionally lambdaexpressionsdiffer oftenwithrespecttotheirfunctionality accesstovariablesinouter scope non local returns4 etc.
.
stream person s ... s.filter p p.age s.filter p return p.age s. filter person p p.age s. filter person p return p.age figure syntactical differences of equivalent lambda ex pressions in java.
injava alambdaexpressionmightormightnothavetypedeclarations in its parameter list and the body might or might not have curly brackets.
if there are no curly brackets the body of a lambda expressionsconsistsofasingleexpressionwhichalsorepresents the return value.
in case a parameter list does not contain type declarations java infers the types etc.
i.e.
a developer is typically free to decide whether or not he declares the types for parameters in a lambda expression.
figure illustrates four equivalent lambda expressions passed to a stream s filter method and there are studiesthatindicatethatthedifferentsyntacticrepresentationshave an effect on readability see for example .
injava sstreamapilambdaexpressionsplayanessentialrole andanumberofmethodsinstreamsrequirelambdaexpressionsto be passed.5we mentioned in the introduction already the method filter thatrequiresa lambdaexpressionthatreturnsa boolean value in order to determine whether or not one object should be selected from a list.
comparable methods are anymatch or allmatch thatreturnabooleanvalueifforany orall element s 4see for example for a general explanation of local and non local returns.
5technically this is not correct because the stream api can be used with ordinary objects or anonymous inner classes as well.
however even java s standard documentation on the stream api proposes the use of lambda expressions.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
imperative versus declarative collection processing an rct on the understandability of traditional loops versus the stream api in java icse may pittsburgh pa usa inthecollectionthe passedlambdaexpressionreturnstrue.inaddition to that the stream api has methods for creating maps or groups or to convert a stream into a collection.
figure illustrates a more complex example that illustrates the moredeclarativenatureofthestreamapiincomparisontothetraditionalloops.intheexample acollectionofobjectsistransformed intoamapconsistingofanintegerkeythatistheageofaperson fromthecollectionandalistofallpersonsofthatage.usingthe stream api one declares with a lambda expression the grouping criterion p p.age whichdefinesthekeysinthemap.another lambdaexpressiondescribeswhatelementsshouldbestoredinthelist.thesamefigurealsocontainsanimperativeimplementationofthecodewherefirsttheresultmapiscreatedandtheneachelement in the original collection is iterated.
by using a conditional the list objectsarestoredintothemapandfinallyapersonobjectisstored in the list.
although both ways result into a comparable result the difference instyle seems obvious.still the question iswhether one way should be preferred over the other.
map integer list person m map construction using the stream api m personcollection.stream .
collect collectors .groupingby p p.age collectors .mapping p p collectors.tolist map construction using loops m newhashmap int eger list person for person p personcollection if !m.containskey p.age m.put p.age newvector person m.get p.age .add p figure3 mapconstructionfromalistusingthestreamapior using loops.
additional to the evolution of programming languages there were other movements towards a more declarative style using lambda expressions.
for example the ide intellij visualized java s anonymousinnerclassesalreadyin2009aslambdaexpressions.i.e.
althoughtheunderlyingsourcecodedidnotcontainsuchexpressions intellij smotivationwastoimprovethereadabilityofcode under the assumption that lambda expressions can be easier read than anonymous inner classes .
however despite of the wide adoption of lambda expressions inprogramminglanguagesoverthelastdecadeandtheresulting more declarative means to write programs in originally ratherimperative languages there is little empirical evidence on thebenefits of using such constructs despite the fact that there are indicatorsthatthemorefunctionalstyleisincreasinglyaccepted 6infact theresultisnotidentical becausetheiterativestyledefinesahashmapanda vectorofpersonswhiletheconcreteimplementationusedforthemapsandthelist are hidden inside the abstraction of the stream api.
developers see for example thestudy by mazinanian et al.
.
at least one controlled experiment on lambda expressions seemed to suggest the opposite .
experiment thegoalofthepresentworkistostudywhetheramoredeclarative way of operating on collections using the stream api has any influenceontheunderstandability.ourintentionwastodefinea randomized control trial where participants needed to understand operationsoncollectionsthatwereeitherdescribedusingthetraditional imperative style using loops or the rather declarative style using the stream api with lambda expressions.
.
initial considerations beforedesigninganexperimentanumberofconcernsneedtobe taken into account.
within subjectdesigns one generalconcern is whether the experiment should have within subject variables i.e.
the gen eral question is whether the experiment should be designed as acrossoverstudy see forageneralintroductionintocrossover trials .
one reason to apply crossover trials is to overcome to a certainextenttheso called10xproblem see whichdescribes in general for programming related tasks that one can assume ahigh deviation between participants.
8the analysis of a withinsubjectdesignpermitstomeasuredifferenceswithinasubject.this potentially compensates the effect of large deviations between subjectswhichisprobablythereasonwhyalargenumberofstudies insoftwareengineeringarecrossovertrials.9however crossover designsrequiretotakepossiblecarryovereffects respectivelyperi odiceffects intoaccount see p. suchaslearningeffects fatigueeffect etc.andthereisthenecessitytocheckintheanalysis whether the carryover effects actually occured see for example among many others .
deviation in the non iterating code the obvious way to studydifferencesinunderstandabilityistogiveparticipantscode withonetreatmentandcodewithadifferenttreatmentandthen ask questions about it.
the potential problem is the complexity of the code that is not in the focus of the present study.
such com plexity could be caused by the code that defines and initializes thecollections.ifsuchcodeistoocomplex thereisthepotential problemthatitisthemaincausefordeviationinthemeasurements andnotthedifferenttreatments whichpotentiallyhidestheeffect that should be studied such code needs to be read and understood beforeactuallyreadingandunderstandingthecodethatoperates on the collections.
hence we think there is a need to represent the code that is not in the focus of the study in a more easy way.
complexity of iterating code obviously there are infinite possible ways to do operations on a collection.
a simple code is afilteroperationwhereforexampleobjectsfromacollectionare selected because one instance variable of the object corresponds to a certain literal e.g.
person.age .
from our perspective more complexoperations aregrouping ormapping operations suchas 8the evidence that participants differ by factor is quite low see .
hence 10x should be rather understood as a methaphore that the deviation can be high.
9vegas et al.
analyzed studies in software engineering and found that more than1 3of of the analyzed studies were crossover trials .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa nils mehlhorn and stefan hanenberg table experiment source code tasks1 task stream api loop map string long f collection string words return words.stream .collect groupingby string tolowercase counting map string long f collection string words map string long groups new hashmap for string word words string lowercase word.tolowercase long count groups.getordefault lowercase 0l groups.put lowercase count return groups list employee f list long ids list employee employees return employees.stream .filter employee ids.contains employee.getid .collect tolist list employee f list long isa list employee employees list employee l new arraylist for employee employee employees if ids.contains employee.getid l.add employee return l boolean f collection result results return results.stream .allmatch r r.getpoints boolean f collection result results for result r results if r.getpoints return false return true map author book f collection book books return books.stream .collect tomap book getauthor book book maxby comparing book getsales map author book f collection book books map author book groups new hashmap for book book books book otherbook groups.get book.getauthor if otherbook null book.getsales otherbook.getsales groups.put book.getauthor book return groups list double f collection bankaccount accounts double rate return accounts.stream .filter account !account.isfree account.getbalance .map account double result account.getbalance if !account.isfixed double finalrate account.ispremium ?
rate rate result finalrate return result .collect tolist list double f collection bankaccount accounts double rate list double results new arraylist for bankaccount account accounts double balance account.getbalance if account.isfree balance continue double result balance if !account.isfixed double finalrate account.ispremium ?
rate rate result finalrate results.add result return results the one given in figure and they probably have an effect on the potential differences.
hence we see the need to study different kinds of operations on collections.
deviationintheiteratingcode weneedtotakeintoaccount thatespeciallyfortheloopsthereisnotoneuniquewaytowritedownacollectionoperation.ifweuseagainfigure3asanexample itis possible to defineadditional local variables thatstore for example the result of the expression person.age .
additionally oneneedstotakeintoaccountthatthenamingofsuchvariables authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
imperative versus declarative collection processing an rct on the understandability of traditional loops versus the stream api in java icse may pittsburgh pa usa table experiment source code tasks6 task stream api loop map string integer f list product products return products.stream .collect tomap product getdepartment product getprice minby integer compareto map string integer f list product products map string list product groups new hashmap for product p products string department p.getdepartment if groups.containskey department groups.get department .add p else list product group new arraylist group.add p groups.put department group map string integer computed new hashmap for map.entry string list product group groups.entryset integer c null list product departmentproducts group.getvalue for product product departmentproducts if c null product.getprice c c product.getprice computed.put group.getkey c return computed boolean f collection artwork artworks int discount return artworks.stream .anymatch a a.getprice discount boolean f collection artwork artworks int discount for artwork a artworks if a.getprice discount return true return false has an effect on the understandability of the resulting code.10our conclusion on this is that the loop code should be plausible where local variables should be used whenever the corresponding expressionsaretoocomplex.furthermore variablenamesshouldbeused that express best the content of these variables without actually announcing the semantics of the whole operation.
deviation in lambda expressions as states in section lambda expressions in java can be written in different ways and it is not clear whether the different styles have an effect on the understandability.
while it would be in principle possible to study the effect of different lambda styles as well we believe that it is quitecommoninthestreamapitouselambdaexpressionswithoutdeclaredtypesandmainlywithonesingleexpressionintheirbody whenever possible.
.
tasks altogether seven tasks were used in the experiment see table and table .
taking the initial considerations into account we 10for example the studies by binkley et al.
or by hofmeister et al.
showed that the style as well as the length of identifiers has an effect on readabilty.decided to give subjects code that consists of one single method whereallobjectsrequiredbyacollectionoperationarepassedto.
while one initial consideration was to give meaningful names this should not be the case of this single method if the semantics of themethodisalreadydescribedinthemethod sname participants would probably guess from the name the semantics of the code.
as a consequence we always gave the method the name f. but f s parameternamesaremeaningful i.e.theirnamesindicatewhatthe contentofthevariablesis.forthelocalvariableswithintheloop code we used meaningful names as all.
forexample thecodefortask1 withthenotmeaningulmethod name f receives a collection of words as input the parameter has the meaningful name words and returns a map that contains how oftenaword inlowercase occuredinthecollection.intheloop codewedecidedtogivethelocalvariablefortheresultobjectthe meaningful name groupsandwedecidedtostorethelowercase representationofawordaswellasthecounterincorresponding local variables with meaningful names .
inordertorepresentdifferentkindsofcomplexities weselected code snippets based on our personal perception.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa nils mehlhorn and stefan hanenberg figure application used for the data selection task with technique loop .
simple task weusedtwosimpletaskswhereonly one conditions needed to be checked either whether the condition holds for one or for all elements .
in both cases the loop contained a condition with a return statement as wellasanadditionalreturnstatementaftertheloopwhile for the stream api just the corresponding methods were invoked.forthesimpletasks wedidnotexpectanypositive effect of the stream api and possibly even a negative effect the loop code looks from our perspective quite trivial.
medium task1 we considered tasks with grouping criteria as medium.
we think that especially for loops the code is no longer that trivial to understand because one has to handle the definition of subgroups and the assign ment of elements to that group.
task and are from our perspectivespecialcases.intask4 theloopcodedefinesthe subgroups and the mapping the maximum in one step.
we were not sure whether it is easier for developers to define themappinginaseparateloop.hence task4and6differ mainly in the loop code where the mapping occurs either in one single loop task or in two loops task .
for both cases the stream api code is comparable.
complex task5 from our perspective a task is complex if the filter citerion and the mapping criterion cannot besimply defined by referring to an attribute.
task is fromour perspective such a task that contains a more complex definition of the mapping criterion even in the stream api the lambda expression passed to the mapcontains an additionalcondition.intheloopimplementation theloop sbody is from our perspective more complex due to the additional conditional.
notethatthepreviousclassificationisbasedonourpersonalpercep tionandonlyusedforexplainingthedifferentkindsoftasks.hence wedonotusethis fromourperspective ratherweakclassification as an independent variable in the experiment.
becauseoftheinitialconsiderations seesection3.
wedecided togivesubjectsamoregraphicalrepresentationoftheinputvariablesforthecode.figure4illustratestheapplicationweusedintheexperiment intheexamplefortask6inthelooprepresentation .
in the center of the screen the code isshown whose result it to be determined.onthelefthandside theinputdataisgiven ontheright hand side the possible output is given.
the input is a table wherethetable snamematchestheparameternameofthemethod.
additionally the table s column names represent the instance variables of the corresponding object.
for example the code in figure 4usesacollectionofproductswhereeachproducthastheinstance variables name department and price.
.
experiment design and layout the experiment was designed as a crossover design where each participant was tested under all treatments.
we divided the partici pants into two groups a and b .
both groups received the tasks in identicalorder task1 then again task1 butwithalternating techniques loopsvs.streamapi .forgroupa task1wasgiven inthelooprepresentation task2inthestreamapirepresentation task in the loop representation etc.
group b started with the streamapi.afterfinishingtheseventasks thetaskswereagain given thistimewiththeothertechnique i.e.
groupareceivedtask 1withthestreamapi task2withtheloop etc.
andwithdifferent inputs.theparticipantswerenotinformedabouttheexperiment design i.e.
the participants just knew that tasks had to be done.
foreachtask theparticipantswereaskedtoratetheirsubjective impressions from the task with respect to three criteria each rated on a point likert scale lowest highest overall performance i.e.
how good a participant from his perspective performed the task speed i.e.
how fast he was able to solve the task and readability how well from the participants s perspective the code reflected its intention .
the experiment studies the following hypotheses h0technique there is no difference in time for answering what the results of a loop based or stream api based source code are.
12actually the participants were asked to judge the code with respect to aesthetics insteadofreadability.weusethetermreadabilityhereinsteadtomaketheterminology more clear.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
imperative versus declarative collection processing an rct on the understandability of traditional loops versus the stream api in java icse may pittsburgh pa usa h0correctness there is no difference in the correctness of the given responses for a loop based or stream api based source code.
h0perception there is no difference in the participant s perception overallperformance speed and readability of source code based on loops or the stream api.
each hypothesis comes with three different response variables responsetime ratioscale thetimeittookaparticipant to answer a question.
correctness true false whether or not a response matched the actual result of the code.
perception ordinalscale theparticipant sperception of each task with respect t o overall performance speed and asthetics.
the independent variables in the experiment were task the concrete code given to the subjects task1 .
technique thetechniqueinwhichthecodewaswritten loop or stream api .
whilethevariabletimeandcorrectnessarefromourperspective the important response variables the participant s perception is interestingwithrespecttowhetherthepotentialoutcomesofthe experiment were also perceived by the participants.
thetimemeasurementstartedrightfromthemomentwhena taskwasshown.theparticipanthadtochose0 nelementsfrom the output table and then had to click on the submit button.
the applicationstopped thetime andassigns thecorrespondingtime to the task and asked the participant to fill out a questionnaire for the current task.
after finishing the questionnaire the participant explicitely needed to start the next task.
.
execution weselected20volunteers 10masterstudentsand10professionals and measuredeach one in an individualsession.
based on our subjective impression participants would be already enough todetectaneffect.theparticipantswerechosenbasedonpurposivesampling inthefollowingway13 theauthorscontacted professional developers and asked them whether they are familiar with the stream api and whether they are willing to participate.
once10developerswerefoundwerepeatedthesameprocessfor master students.
despitethefactthatallvolunteersstatedthattheywerefamiliar with the stream api we still gave each one a short introduction into the iteration of collections using loops and the stream api andemphasizedespeciallyforthestreamapispecificoperations to ensure similar levels of knowledge among participants.
this short refreshment training took about minutes depending on aparticipant spriorknowledgeanddependingonaparticipant s specific questions.
once the participant started with the experiment all tasks weredoneoneafteranotherbuttheparticipantwaspermittedto take a break between two tasks.
13purposive sampling is a non probability sampling technique that is quite often appliedinsoftwareengineering.thestudybybaltesandralph revealedthatabout of empirical studies in software engineering use purposive sampling.
results .
response times thedatawasanalyzedusingananovawithrepeatedmeasurements on the dependent variable time and the within subject variablestask andtechnique loop streamapi andthebetweensubject variable group a b .14table contains a more detailed description of the statistical results.
the variable group is not significant p .
and there is no interactionbetweengroupandtask p .
andgroupandtechnique p .
.
hence we found no indicator for carryover effects which indicates that the counterbalanced design worked out.
both main effects technique and task are significant both p .
with relatively large effect sizes both 2p .
.
but it turns out that there is a significant interaction effect between both variables p .
2p .
.
figure5illustratestheinteractionbetweentechniqueandtask includingthe95 confidenceintervals .thefiguresuggeststhat the differences between loop and stream api depend on the tasks whileforthreetasks and7 thedifferencesarerathersmall the difference is rather large for task task and task .
weneedtokeepinmindthattask6playedaspecialrole.we introduceditinadditiontotask4becausewewerenotsurewhether themappingintheimperativestylecouldbeeasierunderstoodif two loops are used.
taking the difference between task and in the imperative style into account we can exclude this possibility.
pairwise comparisons15of loops and the stream api per task show for all tasks a positive effect of the stream api16which is alsoillustrated inthe interactiondiagram foreachtask themean for the stream api is lower than the mean for the loop.
looking at the ratios of means we see that they vary from task up to task .
i.e.
the usage of loops required at least more time and at most .
due to the interaction it is valid to saythatapositiveeffectofthestreamapiexistsindependentofthetask buthowlargethedifferenceintimeactuallyisdepends on the tasks.
weshouldtakeintoaccountthatweintroducedtask6underthe assumptionthatusingtwoloopsforagroupingcriterionmighthelpunderstandingtheiterativecode.andthistaskrevealedthehighest difference between the streamapi and the loop.
including task theratiomloop mstreamis178 i.e.thelooprequired78 moretimeto understand.ifweexcludetask6 wereceivemloop mstream 114s 74s while all other results are comparable except the effect size for t tawhichiswithouttask6higherwith 2p .
.hence even if we remove one disputable task the loop variant still required moretime to understand.
andwe think itis noteworthy that even thevery simplytasks 3and showeda positiveeffect ofthe streamapialthoughweconsidereditaspossiblethatthestream api could have a negative effect.
consequently we reject h0 technique.
14all following analyses were done using spss v27.
15since the the tasks were significantly different p algorithm .
we intentionally did here a pairwise t test without a correcting the p value using for example bonferroni .
16for task and the difference is only significant for an alpha level of .
not for an alpha level of .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa nils mehlhorn and stefan hanenberg table3 anovaon20subjectsontheresponsevariabletime.wereporttheinteractiont taviapairwiset testsforeachtask such as 1for the comparison between loop and stream api for task instead of the values for all treatment combinations.
m ci95 and sd are rounded to full seconds.
dffp 2ptreatement nc i m sd ratios technique t .
.
.
loop140 mloop mstream stream api task ta .
.
.
.
omitted group .
.
.
omitted due to insignificant results t t a .
.
.
medium p .
91mloop mstream medium p .
20mloop mstream simple p .
15mloop mstream medium p .
129mloop mstream complex p .
106mloop mstream medium p .
97mloop mstream simple p .
27mloop mstream figure interaction task technique on response times in order to check whether the subject s background master student versus professional potentially influenced the results we repeat the previous anova with background as an additional dependentvariable beingawarethatthisreducesthesamplesizefor each treatment combination which potentially leads to thesituation that variables that were previously significant are nowinsignificant .
actually it turned out that background had a positiveeffectandstudentswereonaverage.91seconds respectively slower than professionals p .
2p .
m student .
mprof essional .
mstudent mprof essional .
.
and while the variable technique is still significant p .
2p .
the interaction between technique and task is no longer significant p .
2p .
.
however from our perspective the latter result is rather the effect of the previously mentioned reduced sample size per treatment combinationinsteadofanindidatorthattheresultdoesnotdepend on the tasks.
.
correctness becauseofthedifferentnatureoftheresponsevariablecorrectness whichsimplystateswhetherornotaresultwascorrect wecannot run an anova.
instead we run a 2 test first on the variables correctness and technique in order to check whether independent of the tasks the correctness of responses differed between the techniques.
altogether the participants gave incorrect answers loops stream api which is a statistically significant result 2 n .
p .
.
taking the results of the previous section into account it seems reasonable to run the test for each task in separation.
however only for tasks and the differences were significant incorrect answersweregivenfortask5 2 n .
p .
incorrect answers were given for task 2 n .
p .
.theonlytaskwherethenumberofincorrectanswersusingthestreamapiincomparisontoloopswashigherwastask1 butthedifferencewasnotsignificant p .
.forallothertasks thenumberofincorrectresponseswerehigherforloopsthanfor the stream api.
again removing task from the analysis leads to the same results.
hence we reject hypothesis h0 correctness .
.
subjective ratings in order to analyze the subjective ratings17we run again a repeated measures anova this time with the dependent variableratingandthewithin subjectvariablestask techniqueandquestion.18likewise to the time analysis all independent variables are significant p .
with different effect sizes 2p task .
2p technique .
2p question .
.additionally allcombinationsoftheindependentvariablesarestatisticallysignificant p .
.
17because of a technical error the subjective ratingsof subjects were not recorded.
hence the following analysis is based on the data of subjects.
18because of space limitations we do not provide the complete data of the anova here and report instead only the most essential results.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
imperative versus declarative collection processing an rct on the understandability of traditional loops versus the stream api in java icse may pittsburgh pa usa figure interaction question technique on ratings figure illustrates the interaction diagram for question technique.
it shows that participants always rated the stream api higher than the loops and the largest difference betweenbothtechniquesexistsforreadability.consequently we reject hypothesis h0 perception .
wethinkthatthesecondandthethirdquestionplaythemostimportant roles because the question on the speed indicates whether subjects were able to perceive the difference in time we detected insection4.1andreadabilitycoulddirectintothesamedirection althoughtheratingcriterionislessprecise .figure7illustratesthe interactionbetween thespeed ratingsandthetasks.foralltasks the means for the stream api are higher than for the loops.
we do notshowtheinteraction diagramforthequestiononreadability which looks similar to the interaction diagram of the speed ratings.
figure interaction task t echniqueon speedratings because of the similarities betw een speed ratings and time measurements it is plausible to run a multiple linear regression on the variables speed rating and technique to explain the response times.theresultingregressionequationissignificant f .
p .
withr .
.inotherwords thedifferencesintimewere not onlymeasured andmeasurable they werealso perceptible by theparticipants.repeatingthesameforthequestiononreadabilityresults forunderstandablereasons inaweakermodel f .
p .
with r .
the readability perception says less about the understandability in terms of times than thespeed perception.inotherwords whetherornotsomeoneconsiderssomepieceofcodemorereadableisratheraweakindicatorforthecode s understandability.
threats to validity experiments should document their potential threats to validity see for example and we see the following threats worth considering.
code representation the code given to the participants is obviously a threat and the code could be written in a different way.
for the stream api anonymous inner classes could have been used insteadoflambdaexpressions thedifferentexpressionscouldbe storedinlocalvariables etc.somethingsimilarcouldbedonefor the loops.
in all cases the corresponding names could more clearly express what they stand for.
to a certain extent a variable thatexpresses too precisely its meaning could be problematic for theexperiment becauseparticipantscouldjustrelyonthenamesin the code instead of the semantics.
chosentasks we think that there are much more complicated meanstospecifyoperationsoncollections andtheyhaveprobably an impact on the difference between the stream api and loops.
wethinkthatthedifferencesbecomelargerifmultiplegrouping operations are applied but the present study cannot give evidence for this statement.
trainingphase selectionofparticipants thesubjectswere chosen using purposive sampling which might or might not influencetheresults.however potentialparticipantswereaskedupfront whether they are familiar with the stream api in java.
actually wethinkthatjustaskingpeoplewhetherornottheyarefamiliar withacertaintecniqueispotentiallyproblematic because being familiar withsome technique could meandifferent thingsto participants.
we also think that the short refreshment into the stream api respectively into the iteration of collections has a potential effect onthe results butwe cannotestimate how largethis effect is or whether it existed in the present study at all .
measurements and measurement technique the experiment used a graphical representation for the input and output ofeachtask anditusedthemomentwhentheparticipantpressedthesubmitbuttonforthetimemeasurement.therepresentationof the input data was chosen to ease the reading of the code.
if this assumptionholds itmeansthatinapracticalsettingthedifferences betweenthe loopandstreamapi wouldbeprobablyless because thereadingoftheadditionalcodewouldcauseadditionaldeviation.
next the answers were given by clicking on the appropriate lines.
inprincipleonecanarguethatitwouldhavebeenabettermeasurementtostopthetimerecordingwhenthefirstmousebuttonwas pressed.butinpreliminaryexperimentswemadetheexperience that people do not start to choose answers when they know the wholeanswertoaquestion.fromthatperspective wethinkthat authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa nils mehlhorn and stefan hanenberg the chosen measurement technique is appropriate although it still contains some additional time for navigating with the mouse etc.
related work althoughthediscussionswhetherornotfunctionallanguagesin generalorfunctionallanguageconstructsarehelpfulinadditionto imperativelanguageconstructarevividsincedecades seeforexample among many others and while there are approaches avaible to translate imperative code into a more functional style see for example there is not much evidenceonthepossibleeffectsoftheusabilityoffunctionallanguageconstructsingeneral thecombinationoffunctionallanguage constructs into other kinds of language or even more particular theintroductionoflambdaexpressionsintotoday smainstream languages.
on the other hand the technical implications of for examplelambdaexpressionsincomparisontoexistingconstructs are often studied see for example .
uesbeck et al.
provided a controlled experiment on lambda expressionsforreplacingwhileloopswithlambdaexpressions in c .
in the study three tasks were designed and applied to participants from freshmen to junior up to senior developers who needed to write corresponding algorithms.
the response variables in theexperiment were correctness time and number ofcompilationerrors.theindependentvariablesweretechnique lambdaver susloop andtheparticipants experiencelevel.thestudyrevealedapositiveeffectofloopsincomparisontolambdaexpressionsonall responsevariables programmersusinglambdaswereonaverage about50 slowerandthesuccessrateofloopswashigher.theonly noteworthy exception were experienceddevelopers for whom no differences between lambda expressions and loops were detected.
one controlled experiment that compared a declarative style with a more traditional style although not explicitly related to loops was performed by salvaneschi et al.
where reactive programming whichis amoredeclarativestyleofprogramming see wascomparedtotheapplicationoftheobserverdesign pattern .
participants read the code of code snippets andansweredquestionsaboutthem.theresponsevariableswere reaction time and correctness.
it turned out that reactive code took lesstimeandincreasedthecorrectnessoftheanswers.additionally theparticipantsexpressedtheirperceptionofthetwoprogramming stylesandthereseemtobesomeagreementthattheparticipants considered reactive code as more desirable and more readable.
pankratius et al.
studied the possible impact of a rather functionalstyleincomparisontoaratherimperativestyleformulticore programming .thirteenprogrammersgenerated39javaand scala programs.
while the main focus of the study is on the technicalaspectsoftheprograms programmerswerealsoasked abouttheirperceptionoftheprograms.thedevelopersperceived the java programs more often readable than the scale programs.
additionally while allprogrammersconsidered thejavaprogramming model as easy this statement was only received from of the developers for scala.
other studies based on the analysis of code repositories also givefirstindicationsforacomparisonofdeclarativeandimperative programming languages.
for example the study by nanz et 19anenglishtranslationisavailableunder mainlybasedontheirtechnicalcharacteristics runtime memory consumption etc .
however the study also contains statements abouterrorsfoundintheprojectsandoneofthefindingswas that java programs were moreerror prone than for example programs written in the functional language haskell.
a comparable study by ray et al.
on a larger sample came to opposite results.
a study that focused on java was performed by lucas et al.
who compared the usage and usability of lambda expressions in comparison to anonymous inner classes.
the authors evaluatedcode snippets before and after the introduction of lambdas andasked developers about the acceptance of lambda expressions whereabout50 consideredtheintroductionoflambdaexpressions asanimprovementofjava.whiletheapplicationofreadabilityandunderstandabilitymetricsdidnotfindsignificantdifferences devel opersperceivedsomecodemigrationstowardslambdaexpressions negatively especially when for loops were replaced.
another study that focused on the acceptance of lambda expressions in java was performed by mazinanian et al.
who investigated the use of lambda expressions in open source projects.
they analyzedhowtheprojectsevolvedandappliedstaticsourcecode analyses while also interviewing developers in these projects.
halfoftheanalyzedprojectsshowedasignificantincreaseinadoption while core developers introduced more often lambdas than othersperloc.furthermore lambdaexpressionsweremostlyusedasareplacementforanonymousinnerclasseswheredeveloperperceived a better readability of lambda expressions over anonymous inner classes.
anotheranalysisoflambdaexpressionswasperformedbynielebocketal.
whoexamined2923open sourceprojectswrittenin c c and java with regard to the use of lambda expressions in concurrentcode.theirfindingsdidnotshowthatlambdaexpressionsareappliedmorefrequentlyinconcurrentcontextsthanin general rathertheopposite.additionally theyinvestigatedother use cases for lambda expressions and found them to be used above averageinuser interfaceandtestingcodeaswellasimplementations of generic algorithms such as sorting.
weranastudyonthereadabilityonlambdaexpressionsincomparisontoanonymousinnerclassesbefore .actually thatstudy wasmotivatedbythefactthatitwasuncleartouswhetherlambda expressionsshouldbeusedinthepresentstudy i.e.whetherlambda expressions should be used with or without type annotations or whether traditional java constructs such as ordinary objects respectivelyanonymousinnerclassesshouldbeused.intheprevious studyitturnedoutthatlambdaexpressionswithouttypeannotations improved the readability up to .
consequently we feltconvinced that the proposal found in oracle s stream api documentation where lambda expressions were used as parameters for the stream api was better suited than using any other alternative.
discussion and conclusion thepresentworkwasmotivatedbythetendencyofmainstream imperative programminglanguagestointegratedeclarativemeans vialambdaexpressionsinconjunctionwithcorrespondingapisthat permittheabilitytooperateoncollectionsinamoredeclarativewayinsteadofthetraditionalwayusingloops inconjunctionwithlocal authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
imperative versus declarative collection processing an rct on the understandability of traditional loops versus the stream api in java icse may pittsburgh pa usa variables conditions etc.
.moreprecisely wewereinterestedin whethertheapplicationofthestreamapi whichmakesuseofthe ratherdeclarativelambdaexpressions injavahadameasureable effect on the understandability of operations on collections.
thecontrolledexperimenton20participantsand7tasks where participantshadtodeterminetheresultofcode revealedthatoverall the stream api improved the understandability in terms of responsetimes loopsrequired78 moretime evenifweremoved a debatable task the effect was still .
on an individual basis onlyfortwotasksthedifferencewerenotsignificantonanalpha levelof.
buton analpha level of.
which leadsus tothegeneralizationthatforalltasksapositiveeffectofthestreamapiwas measured.itisnoteworthythattheparticipants whoconsidered thestreamapicodemorereadablethantheloopcode wereable toperceivethedifferencesintime.buttheuserperceptionalsosaid that the readability perception might be only a weak indicator for the understandability.
what makes this result interesting is that a different experiment intheliteraturealreadystudiedtheeffectoflambdaexpressionsoncollectionsandfoundarathernegativeeffectwhenparticipantshad towritecode .there onlyseniordevelopershadnonegative effect of the more declarative style.
hence the present experiment castsanewlightonthediscussionaboutwhetherornotfunctional languageconstructsmightbebeneficialinimperativelanguages.it might be the case that the application of lambda expressions mightbeharderthanthetraditionalapplicationofloops argument writability but that the resulting code with lambda expressions is more understandable argument understandability readability .
consequently thequestionofwhetherornotfunctionalconstructs are helpful in imperative languages could maybe not be simply answeredbya yes or not .itmightbethecase thatitisbeneficial forreadingandunderstandingcode buttheoppositeforwriting code but one should keep in mind that ide support might help in thelattercase .inadditiontothattheexperimentrevealedthatthedifferencebetweentheunderstandabilityofbothstylesdependson theconcretecodesnippetsunderinvestigation insomecasesthe benefit in understanding might be just in time in othercases much more up to respectively ignoring a disputable task more .
however we should not overgeneralize the results with respect tothe imperativeversus functionallanguagediscussion.
actually theintroductionoflambdaexpressionsintoanimperativelanguageisjustonewaytoconsideramoredeclarativestyle.otherlanguages suchassqlaredeclarativeaswell althoughtheirlanguagecon structsarequitedifferentfromlambdaexpressions.additionally oneshould keepin mindthat thesyntax oflambdaexpressions is quite differentbetweenlanguages although c java and python are object oriented languages where loops and method calls are syntacticallyquitesimilar theirnotationsorlambdaexpressions arequitedifferent.itispossiblethattheresultsofthepresentpaper depend much on the chosen lambda syntax in java taking into account that already the different notations of lambda notations in java have a measurable effect .
under theassumption thatlanguage designers considerunderstandabilityofcodeasvaluableoneneedstoaskwhycurrentmain stream languages evolved in a way as they did.
because the usageofamoredeclarativestyleinratherimperativeprogramminglanguagesisfarfrombeingnew.forexample thecollectionapi intheprogramminglanguagesmalltalk alanguagethatwasdesignedmorethan40yearsago alreadycontainedmethodsthat received lambdaexpressions asparameters theapi hasa number of parallels to the stream api we find today in java.
from that perspective itmakessensetosuggestthatlanguagedesignersandapi designersshouldapplyusabilitystudies rightfromthebeginning of the language design or api design process.
because such studies couldinfluencetheperspectiveoflanguageandapidesignerson the usability of certain language constructs or apis.
in addition to that we think that it is desirable to study in more detailtheroleoftypeinferenceinthestreamapi.wethinkthat onereasonthestreamapicodeismoreunderstandableisthequite simplesyntaxoflambdaexpressionsinjavawherenoteventype declarations are required.
although we are aware that there are studies in the literature that found a rather positive effect of static types seeforexample westillthinkthattherather compactsyntaxoflambdaexpressionsinjavawithouttypedeclara tions butstillstaticallytyped ishelpful whichrequiresadditionalstudies respectively therearealreadysomeinitialstudiesavailable that give evidence that code without type annotations is helpful .
and finally the present study might be used to think about whetherteachingofmainstreamlanguagecouldbeimprovedby focussing more on lambda expressions for iterations instead of traditional loops.
but especially in that case it is desirable to have more empirical data on the learnability of lambda expressions.
in general the present study could be considered as a contribution to the ongoing discussion about functional versus imperative programming languages and it could be used as an argument for a ratherfunctionalstyle.however wethinkthatthepresentstudy should be handled with care with respect to such an argument.because on the one hand the focus of the present study was juston operations on collections and on the other hand it would be desirabletohavealargerbasisofempiricalfactsforthatdiscussion.