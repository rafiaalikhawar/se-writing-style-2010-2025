afl non intrusive feedback driven fuzzing for microcontroller firmwar e wenqiang li state key laboratory of information security institute of information engineering chinese academy of sciences school of cyber security ucas beijing china liwenqiang iie.ac.cnjiameng shi department of computer science the university of georgia athens georgia usa jiameng uga.edufengjun li department of electrical engineering and computer science the university of kansas lawrence kansas usa fli ku.edu jingqiang lin school of cyber security university of science and technology of china hefei anhui china linjq ustc.edu.cnwei wang state key laboratory of information security institute of information engineering chinese academy of sciences beijing china wangwei iie.ac.cnle guan department of computer science the university of georgia athens georgia usa leguan uga.edu abstract fuzzing is one of the most effective approaches to finding software flaws.
however applying it to microcontroller firmware incurs many challenges.
for example rehosting based solutions cannot accurately model peripheral behaviors and thus cannot be used to fuzz the corresponding driver code.
in this work we present afl a hardware in the loop approach to fuzzing microcontroller firmware.
it leverages debugging tools in existing embedded system development to construct an afl compatible fuzzing framework.
specifically we use the debug dongle to bridge the fuzzing environment on the pc and the target firmware on the microcontroller device.
to collect code coverage information without costly code instrumentation afl relies on the arm etm hardware debugging feature which transparently collects the instruction trace and streams the results to the pc.
however the raw etm data is obscure and needs enormous computing resources to recover the actual instruction flow.
we therefore propose an alternative representation of code coverage which retains the same path sensitivity as the original afl algorithm but can directly work on the raw etm data without matching them with disassembled instructions.
to further reduce the workload we use the dwt hardware feature to selectively collect runtime information of interest.
we evaluated afl on two real evaluation boards from two major vendors nxp and stmicroelectronics.
with our prototype we discovered ten zero day bugs in the driver code shipped with the sdk of stmicroelectronics and three zero day bugs in the sdk of nxp.
eight this work is licensed under a creative commons attribution international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
have been allocated for them.
considering the wide adoption of vendor sdks in real products our results are alarming.
ccs concepts security and privacy embedded systems security .
keywords firmware security fuzzing microcontroller iot etm acm reference format wenqiang li jiameng shi fengjun li jingqiang lin wei wang and le guan.
.
afl non intrusive feedback driven fuzzing for microcontroller firmware.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction internet of things iot has become an integral part of our digital lives.
for example many people install smart thermostats to remotely control the temperature and humidity of their homes.
smart alarm systems are used to monitor home and workplace and raise alarms when detecting burglars.
fitness trackers and smart health bands are also widely used to continuously monitor personal health data such as heart rate and blood oxygen level.
the key component of many iot devices is the microcontroller unit mcu which is a tiny custom built and cost efficient system on chip soc .
the rapid evolution of the mcu ecosystem on the one hand has made our lives easier and more convenient than ever before on the other hand it also introduces a large number of vulnerable mcu products in the wild.
for example several high profile vulnerabilities have been reported recently for the esp8266 and esp32 communication and wifi co processors which have been adopted in millions of iot devices.
these vulnerabilities e.g.
eap client crash zero pmk installation andbeacon frame crash allow the adversaries to hijack or crash the session of esp32 esp8266 ieee acm 44th international conference on software engineering icse icse may pittsburgh pa usa wenqiang li jiameng shi fengjun li jingqiang lin wei wang and le guan products.
meanwhile vulnerabilities of the freertos tcp ip stack can be used to launch remote code execution and steal private information .
more recently badalloc leaves a large number of iot devices exposed to adversaries.
the compromise of an mcu product may lead to serious consequences such as privacy leakage financial loss or even human injury and death.
to prevent or mitigate such attacks extensive security testing during the development phase is imperative.
however existing firmware security testing approaches demonstrate their own limitations when applied to embedded firmware testing see table for an overview of the issues .
for example the emulation based rehosting technique with application to firmware analysis has been extensively studied in recent years but accurately modeling the behavior of diverse peripherals remains the main research challenge.
several approaches such as p2im dice laelaps pretender emu and jetset propose to learn an approximate peripheral model using the symbolic execution access pattern matching and machine learning techniques.
however the learned models are inaccurate in general.
with inaccurate models such rehosting approaches cannot boot firmware with complex peripherals such as usb.
when the execution trace is not exactly the same as that on the real device even though the firmware can be successfully booted it is inadequate for many security analysis tasks.
the emulation based rehosting technique is typically used to test hardware independent code after the target firmware has passed through the booting process.
another direction is to leverage the hardware abstraction layer hal available in mcu firmware to avoid modeling peripherals.
for example halucinator automatically detects hal libraries and replaces them with host implementations.
para rehosting provides common hal backend implementations to help port mcu firmware to native hosts.
however both approaches cannot test the peripheral driver which never runs.
finally some hardware in the loop hitl solutions run the firmware in the qemu emulator while forwarding peripheral i o operations to real devices .
although high fidelity is preserved these hitl based approaches require frequent and expensive switching and syncing between qemu and hardware incurring significant performance overhead.
for example the emulation speed is in the order of tens of instructions per second when frequent hardware interaction is needed .
as a result these approaches are typically used to analyze hardware independent code after the firmware is fully booted with the help of the forwarding mechanism.
to the best of our knowledge none of the existing hitl work supports firmware fuzzing.
in this work we propose a new fuzzing solution called microafl afl which is specifically designed for arm based mcu devices to assist developers in locating potential software bugs in the firmware.
while our approach can cover the entire software stack in this paper we focus on its use in testing the low layer code such as peripheral drivers which we believe is not properly supported by the existing work.
by running the target firmware directly on the target device our approach supports full stack testing with high fidelity.
afl requires developers to have access to the prototype development boards and jtag or swd based debug dongles which are essential hardware tools available and used in virtually every embedded system development environment.
afl is designed to be modularized and extensible so that existing mature fuzzers can be directly integrated e.g.
we adopt afl in our prototype implementation but any other fuzzers can be used as a drop in replacement .
to achieve this goal i afldecouples the execution engine from the rest of a fuzzer collectively called fuzzing manager in this paper .
specifically we run the target firmware on the real hardware and run the fuzzing manager on the pc that coordinates the fuzzing process with the help of the debug dongle.
the execution information is also streamed to the fuzzing manager where the analysis is conducted.
in this way we keep the fuzzing manager on the pc agnostic to the execution engine.
ii to enable communication between the development board and the pc we re purpose the debug dongles which have the highest level of control to the board.
therefore afl can efficiently and effectively feed the testcases over the board pull the run time execution status and start suspend stop the target.
iii finally to collect code coverage information of each testcase which is essential for grey box feedback driven fuzzers afl leverages a hardware feature called embedded trace macrocell etm that transparently generates the instruction trace.
the trace is streamed directly to the pc via five additional pinouts four for data and one for clock .
although etm incurs additional cost we adopt it in this work for two reasons.
first it enables transparent trace collection.
in other words no code instrumentation is required.
this feature makes our work free from rewriting the binary since most of the third party libraries are distributed as stripped binaries and no robust binary rewriting tool is available to facilitate instrumentation based trace collection.
second we argue that prototype development boards with etm pinouts are only needed in the development phase.
after the firmware has been fully tested the released products do not need to be equipped with these features.
this small investment at the development stage yields a good return on investment roi for manufacturers in the long term considering the expensive recalls that may happen later.
afl features two key components online trace collector and offline trace analyzer.
they collect etm data on the device and parse the results on the pc respectively.
when a testcase is available on pc generated by afl afl sends it into a reserved memory on the board via the debug dongle.
at the point where the testcase is consumed for the first time the online trace collector activates etm to collect the instruction trace and streams the data to the pc.
while collecting the etm stream the online trace collector also applies configurable filters via the data watchpoint and trace dwt unit to suppress unnecessary etm packet generation.
this not only reduces the amount of tracing data for transmission but also avoids analyzing useless packets on pc.
the offline trace analyzer runs on the pc and processes the raw etm data.
the result is provided to afl to maintain the bitmap of code coverage.
decoding the raw etm data to get the branch information is expensive since it needs to disassemble the firmware and align the instructions with the raw trace see rq1 in section .
we address this problem by using a kind of special basic block generated at runtime.
this allows us to directly use the raw etm data without disassembling but still retains path sensitivity needed to calculate code coverage.
the offline trace analyzer also uses a software based approach to filter out uninteresting etm packets that cannot be filtered by the online trace collector.
2 afl non intrusive feedback driven fuzzing for microcontroller firmware icse may pittsburgh pa usa table comparison with the state of the art solutions basic method solutionshar dware independent codedriv er codesupp ort fuzzingre quire source codere quire hardware rehosting halucinator p2im emu etc.
n n porting para r ehosting y n for warding hardware interactions a vatar avatar2 surrogates inception etc.
n y fully on device execution afl pr oposed n y theoretically these solutions support fuzzing the driver code.
however the significant overhead on state syncing renders fuzzing driver code impractical.
existing solutions leverage real devices to boot the firmware in qemu to a state where analyzing hardware independent code is possible.
we have implemented a prototype of afl using the segger mcu debugging solution .
then we used the prototype to test sdks from two major mcu chip vendors i.e.
nxp semiconductors and stmicroelectronics .
in particular we used the usb driver fuzzing as a case study in our evaluation.
at the time of writing we have uncovered bugs residing in the usb drivers that were not known previously.
all of them have been confirmed by the vendors and the patches have been released or scheduled with the newest sdk releases.
in summary our contributions are three fold we propose afl the first fuzzing tool that is applicable to the driver code of mcu firmware.
afl decouples the execution engine from the fuzzing manager so that existing fuzzing tools can be easily integrated.
we propose using arm etm for non intrusive feedback collection.
to improve performance afl adopts linear code sequence and jump lcsaj analysis to directly process raw etm data without expensive disassembling.
we have implemented and evaluated our prototype against two sdks from major mcu chip vendors.
we used the usb driver as a case study to show how our prototype can fuzz real world driver code.
the tool has helped us find previously unknown bugs with cves allocations.
the source code and the firmware samples used in the evaluation are available at for future research on this topic.
background .
american fuzzy lop afl fuzz testing is an automated testing technique used to discover coding errors and security vulnerabilities in software.
it involves inputting abnormal testcases to the software under test in an attempt to make it crash.
american fuzzy lop afl is one of the most successful fuzzing tools.
we roughly split it into two main components for easy presentation an execution engine and a fuzzing manager.
while the former is responsible for running a testcase with the target program the latter is responsible for generating new testcases by mutation based on a genetic algorithm coordinating the execution analyzing the execution information etc.
concretely afl first instruments the target program so when the program is executed the branch information can be generated and recorded.
the fuzzing manager then forks a new process as the execution engine to run the program with the current testcase.
during execution the instrumented target program consumes the testcase and records the collected branch coverage information into a local bitmap.
the fuzzing manager also aggregates all thelocal bitmaps into a global bitmap and compares the newly generated local bitmap to the global one to decide if a new path has been discovered.
a testcase that can increase branch coverage is considered interesting and will be used in the genetic algorithm to calculate the subsequent testcases.
to report a bug the fuzzing manager monitors the execution status of the target program and leverages crash information as indicators.
.
analysis of mcu firmware mcu is a special purpose system on chip that cares about realtime processing capability low power consumption and costs.
they are widely used in different application fields such as wearable smart home industrial automation etc.
the execution environment of mcu firmware is significantly different from the traditional oss making many existing binary analysis tools including afl inapplicable.
unlike traditional software which assumes an os layer that provides an abstract view of hardware mcu firmware runs on bare metal or only includes an os library e.g.
rtos for simple multitask management.
therefore it compiles the driver code of peripherals and the application code together to form a single address space program.
the peripheral i o operation is performed by accessing the memory mapped registers.
due to the diversity of peripherals dynamic analysis of mcu firmware is extremely challenging.
although the rehosting technique has made some breakthroughs to test the hardware independent part of the firmware no existing work can test the driver code.
.
hardware supported instruction trace collection program instruction trace is helpful in many program analysis applications such as performance profiling fuzz testing control flow integrity enforcement root cause analysis debugging etc.
compared with software instrumentation modern processors support capturing the instruction traces by hardware components to reduce the overhead.
for instance intel incorporates its hardware instruction trace feature known as processor trace or pt to all its core processors starting from broadwell.
the counterpart of arm is called embedded trace macrocell etm orprogram trace macrocell ptm .
these implementations are quite similar to each other.
both are designed to efficiently rebuild the whole instruction trace assuming that the corresponding machine code is available.
more specifically a dedicated hardware component emits a stream of control flow packets.
then a decoder 1etm and ptm are similar techniques for different arm processor lines.
we use etm to refer to both in this paper.
3icse may pittsburgh pa usa wenqiang li jiameng shi fengjun li jingqiang lin wei wang and le guan is used to reconstruct a unique execution path by matching the control flow data to the disassembled machine code.
.
.
trace collecting.
arm mcus can optionally implement a buffer for trace storage on the chip termed embedded trace buffer etb .
however based on our study etb is rarely supported on real chips.
alternatively arm also supports streaming the trace data to an external debugger via a physical parallel port called cortex debug etm connector .
this is the solution used by afl.
.
.
instruction flow reconstruction.
to reconstruct the execution flow a decoder is needed to interpret the trace packets and align them with the disassembled instructions.
control flow packets carry information about a whether a conditional branch is taken or not b the target of an indirect branch and c asynchronous events such as exceptions.
conditional branches.
arm etm uses one bit in the p header packet to encode whether the condition of an instruction is true encoded as eor or false encoded as nor .
true means the corresponding instruction is executed.
the reason for this design is that in arm almost all instructions can be conditionally executed.
taking the addeq instruction as an example the addoperation is conducted only if the zflag is set.
when this instruction is a branching instruction such as beq eindicates that the branch is taken whereas nindicates the branch is not taken.
indirect branches.
the indirect branch includes indirect calls and function returns.
since the target of an indirect branch can only be determined at run time arm etm emits a packet containing the target address when an indirect branch happens.
such information is encoded into a branch packet.
asynchronous events.
an asynchronous exception could change the control flow at any execution point.
since the current execution location can already be recovered by the p headers the branch source information is unneeded.
in particular the branch source is calculated by adding the length of executed instructions from the last branch determined by p headers to the base address of the last branch target determined by the previous branch packet .
etm encodes asynchronous events using existing branch packets but extends them with supplementary information.
for example it can indicate whether this branch is caused by an exception rather than a normal call instruction.
it also indicates the corresponding exception number if this is an exception.
moreover arm mcus re purpose existing instructions for exception returns.
put simply if an instruction results in a control flow transfer of a set of predefined values exc return then this is treated as a return from exception and the hardware is responsible for fetching the correct target instruction pointer from the exception stack.
etm further emits areturn from exception packet to encode such an event.
with this mechanism exception entries and returns can be properly paired.
direct branches.
with the aforementioned information the decoder can already recover the whole execution flow by aligning the trace data with the disassembled instructions.
note that the trace information about the direct branches is not needed since the target of a direct branch could be determined by checking the cmp etm trace with filtertestcase generatorrun with testcaseinteresting global bitmaplocal bitmaptrace decoderhash unitfuzzing manager pc execution engine board intact afl module s offline trace analyzer online trace collectordebug dongle6 7figure afloverview corresponding branch instruction.
however etm optionally supports emitting branch packets for direct branches making it easier to recover the instruction flow at direct branches.
.
.
trace filtering.
it is generally unnecessary to collect the entire instruction trace over time because an analyst might be only interested in a particular code region.
trace filtering allows for suspending trace collection under certain conditions.
arm etm supports event based filtering.
it defines a set of etm event resources that become active when the corresponding event occurs.
these events can be configured by different comparators provided by the hardware.
when there is a match the corresponding event becomes active.
for example when the instruction pointer matches the value in an address comparator the corresponding event resource is active.
the trace generation is controlled in three ways.
first when an event is active it can directly enable tracing.
when it is inactive the tracing is disabled.
second a code region can be included or excluded from tracing.
this is achieved by setting a pair of address comparators.
finally it can be controlled by the trace start stop block.
if an event happens tracing is started.
the tracing does not stop until the block receives a stop signal which is specified by another event resource.
unfortunately only the last method is supported by arm mcus .
worse the comparator resources which are provided by the dwt unit are very limited.
this poses a significant challenge for us to effectively filter the execution trace we care about.
3 afldesign in this section we begin with an overview of the aflarchitecture and then delve into the detailed design of two critical components the online trace collector and the offline trace analyzer as well as their interaction with the afl framework.
.
overview aflis a new fuzzing tool designed for mcu firmware with a focus on peripheral driver code.
the fundamental idea is to inherit the sophisticated genetic algorithm of afl while replacing its processbased execution engine with two critical components an online trace collector and an offline trace analyzer as shown in figure .
this design enables aflto test all the code in firmware including peripheral drivers and closed source libraries.
as illustrated in figure the host pc and target board communicate via a debug dongle a must have tool for embedded system development.
to begin with the host pc feeds the testcase via the 4 afl non intrusive feedback driven fuzzing for microcontroller firmware icse may pittsburgh pa usa debug dongle into a reserved memory on the target board and directs the target to begin execution .
once the target firmware has reached the point where testcase is firstly consumed the host pc sends the command to activate the etm function .
then while the firmware is executing the generated instruction trace is synchronously streamed to the host pc via the debug dongle .
after completing one round of execution the host pc sends another command to deactivate etm .
the collected trace information is then used to reconstruct the execution paths.
afl adopts a novel scheme for representing branch edges .
the final result is mapped into the bitmap to determine whether a new path has been discovered and guide the generation of new testcases following the same genetic algorithm of afl .
.
low level device control and fuzzing scheduling we use the jtag or swd interface for low level control of the target device.
through these interfaces the debug dongle can directly access the processor registers and the device memory including the memory mapped system configuration registers via the debug access port .
it also gives us the lowest control over the target device.
this is important because fuzzing often causes the target device to enter a non responsive state.
if this happens we can force a reset via the low level jtag swd command without human involvement.
we also need to send testcases to the target device.
depending on the generation algorithm the size of a testcase can be as large as several megabytes.
we leverage the segger rtt real time transfer protocol for high speed transmission.
under the hood rtt uses ahb ap advanced high performance bus access port to access memory in the background.
not only can it provide enough bandwidth but also enables parallel scheduling.
specifically we transmit the subsequent testcase in the background while the target is running against the current testcase.
moreover we conduct the analysis of the previous testcase on pc in parallel with the target execution.
by scheduling all the tasks in a pipeline afl achieves optimized performance.
.
online trace collector the online trace collector is responsible for collecting the etm instruction trace during the firmware execution.
it needs to solve two major challenges how to feed testcases to the target board from pc how to selectively collect a minimal but sufficient instruction trace of interesting code snippets.
.
.
testcase feeding.
we reserve two fixed arrays to hold testcases one for the current test and the other for the subsequent test which is transmitted in the background during the current test to improve parallelism.
the communication channel being used is segger rtt as mentioned before.
these arrays are declared in a noinit section so that the libc constructors will not interfere with them during initialization.
the size of arrays can be configured as needed.
.
.
trace collection and filtering.
to collect the execution trace we can instrument the firmware so that each basic block transition can be recorded and streamed to the pc.
however two challengesneed to be addressed.
a the instrumentation requires additional memory space and computing resources that resource restricted mcu chips may not afford and b the current binary rewriting techniques still face some fundamental technical issues e.g.
current disassemblers cannot disambiguate between