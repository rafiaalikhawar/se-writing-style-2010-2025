singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems fastklee faster symbolic ex ecution via r educing r edundant fastklee faster symbolic ex ecution via r educing r edundant bound checking of type saf e pointers bound checking of type saf e pointers haoxin tu singapor e management univ ersity hao xintu.
phdcs.smu.edu.sg lingxiao ji ang singapor e management univ ersity lxjiang smu.edu.sg xuhua ding singapor e management univ ersity xhding smu.edu.sg he ji ang follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the computer engineering commons citation citation tu hao xin ji ang lingxiao ding x uhua and ji ang he.
f astklee faster symbolic ex ecution via reducing r edundant bound checking of type saf e pointers.
.
proceedings of the 30th a cm joint european softwar e engineering conf erence and symposium on the f oundations of softwar e engineering singapor e no vember .
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
fastklee faster symbolic execution via reducing redundant bound checking of type safe pointers haoxin tu singapore management university singapore haoxintu.
phdcs.smu.edu.sglingxiao jiang xuhua ding singapore management university singapore lxjiang xhding smu.edu.sghe jiang school of software dalian university of technology dalian china jianghe dlut.edu.cn abstract symbolic execution se has been widely adopted for automatic program analysis and software testing.
many se engines e.g.
klee or angr need to interpret certain intermediate representations ir of code during execution which may be slow and costly.
although a plurality of studies is proposed to accelerate se few of them consider optimizing the internal interpretation operations.
in this paper we propose fastklee a faster se engine that aims to speed up execution via reducing redundant bound checking of type safe pointers during ir code interpretation.
our two key insights are the number of interpreted instructions can be tremendous and reducing the interpretation overheads of the extensively interpreted ones e.g.
read write could potentially accelerate the execution a large portion of the pointers in c programs can be statically verified to be type safe but existing se engines treat all the pointers equally which indicates that those engines may slow down the execution due to unnecessary bound checking.
specifically in fastklee a type inference system is first leveraged to classify pointer types i.e.
safeorunsafe for the most frequently interpreted read write instructions.
then a customized memory operation is designed to perform bound checking for only the unsafe pointers and omit redundant checking on safepointers.
we implement fastklee on top of the well known se engine klee and combined it with the notable type inference system ccured.
evaluation results demonstrate thatfastklee is able to reduce by up to .
.
on average as the state of the art approach klee in terms of the time to explore the same number i.e.
10k of execution paths.
fastklee is opensourced at a video demo offastklee is available at ccs concepts software and its engineering software testing and debugging symbolic execution performance .
keywords software testing symbolic execution performance type inference also affiliated with the school of software dalian university of technology.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
reference format haoxin tu lingxiao jiang xuhua ding and he jiang.
.
fastklee faster symbolic execution via reducing redundant bound checking of type safe pointers.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction symbolic execution se is a prominent technique that has been applied in many areas such as software engineering programming language and security .
the key idea of se is to simulate program executions by using symbolic values for inputs and then each execution path will be encoded as path constraints during execution.
a constraint solver e.g.
stp or z3 later is used to determine the feasibility of each path constraint and the solved paths are further explored.
among all the existing se engines the ir based ones e.g klee s2e or angr whose execution is conducted by interpreting the intermediate representations ir of the target program under test are prevalent and widely used.
typically traditional ir based se first transforms the program either source code or binary under analysis into ir and then it interprets the ir to execute the program which follows the design in routes 3in figure .
such a design can have manifest benefits from the implementation perspective.
instead of interpreting numerous instruction sets of popular cpu architectures irs typically represent program behavior at a high level with fewer instructions thus making it easier to implement an instruction interpreter for architecture independent instruction sets than manipulating complex instructions directly.
although the design of ir based se is convenient in terms of implementation existing studies point out that such a design carries out significant performance downsides and slows down the execution.
to mitigate such a problem two major flavors of studies are devoted to accelerating se.
based on the fact that ir code can be transformed by aggressive optimizations the first promote directions are dedicated to either selecting existing compiler optimizations that could help accelerate se or designing a stand alone customized optimization for program verification e.g.
symbolic execution .
apart from the ir optimization side other solutions such as reducing the number of paths to be explored or optimizing the constraint solving are considered for speeding up the execution process.
however most of the existing studies neglect the internal interpretation downside of ir based se in terms of performance.
that is ir code interpretation alone could slow down the performance of se engines.
in this study we propose fastklee a tool that aims to support faster se by reducing the interpretation overheads of redundantesec fse november singapore singapore haoxin tu et al.
figure overview of ir based traditional se and fast se bound checking of type safe pointers.
we design fastklee based on the following two intuitions.
first the number of interpreted instructions tends to be stupendous usually billions only in one hour s run and reducing overhead for the most frequently interpreted ones i.e.
read write could potentially accelerate the execution.
second type safe is an important property in the program for preventing certain errors such as memory out of bound assessing.
as proven by prior studies a large portion of pointers in c programs to be read write can be statically verified to be typesafe.
however most of the existing ir based se engines treat all the pointers memory addresses equally and perform the bound checking for every pointer when interpreting read write instruction.
thus a plethora number of bound checking performed during the interpretation is unnecessary which may induce performance downsides.
based on the above intuitions we propose fastklee to support faster se.
specifically in fastklee a type inference system is leveraged to perform type inference before executing the se engine which follows the design in routes in figure where the latter two are designed for faster se .
the type inference system i.e.
is first used to statically verify pointers to be safeorunsafe and produce a checking list checklist for unsafe pointers.
then during the execution in a customized memory operation is designed to perform bound checking only forunsafe pointers stored in checklist while safepointers are no longer needed to perform any redundant checking.
in this way fastklee could reduce the interpretation overheads of redundant bound checking of type safe pointers for faster se.
we implement fastklee on top of the well known se engine klee and the type inference system ccured .
to demonstrate the effectiveness of fastklee we compare it with the stateof the art approach klee over widely adopted gnu coreutils datasets.
the evaluation results demonstrate that fastklee is able to reduce by up to .
.
on average as klee in terms of the time to explore the same number i.e.
10k of execution paths.
in summary this paper makes the following contributions to our best knowledge fastklee is the first se engine that aims to accelerate ir based se by reducing interpretation overheads.
we leverage a type inference system to classify pointers and design a customized memory operation in the se engine to avoid redundant checking of type safe pointers thus facilitating the reduction of interpretation overheads for ir based se.
we open source the tool fastklee and demonstrate its usability and effectiveness.
we also discuss several important implications offastklee such as facilitating valuable path exploration.
organizations .
section describes the workflow of fastklee for end users.
section gives the most related works to our approach.sections and describe the design and implementation of fastklee.
section presents the evaluation results.
section discusses potential implications threats to the validity and limitations of our approach.
section concludes this paper with future work.
usage example users can execute .
setup.sh in the code repository to set up fastklee.
to prepare the test programs under test it is recommendable for users to follow the official instruction to get the llvm bitcode files of test programs to be analyzed e.g.
cat.bc utility in gnu coreutils .
after setting up the tool and the test program the following two major phases are considered to use fastklee through a command line interface.
.
phase i perform type inference in the first phase the target test program cat linked.bc under testing will be first instrumented to be a new bitcode file named cat linked.bc by invoking llvm tool chain llvm link .
then theccured pass will be applied on the cat linked.bc by invoking the tool opt.
after the type inference of interpreted pointers a text filecat checklist.txt will be produced in the current folder which will be used later in the next phase.
llvm link cat.bc neschecklib.bc o cat linked.bc opt load libccured.so nescheck stats time passes cat linked.
bc dev null .
phase ii conduct faster symbolic execution in the second phase users can utilize the same command line with the original klee to perform se upon the test program.
specifically users may follow the official document to opt for the applicable options .
during the running of fastklee the file cat checklist.txt will be loaded first and then will be used to guide the customized memory operation in fastklee .
fastklee .
cat.bc sym args sym args sym files sym stdout related work the most related work to us can be broadly divided into two categories compiler optimization based and compiler optimization agnostic.
in the former dong et.al study the influence of standard compiler optimizations on se and chen et.al further leverage machine learning based compiler optimization tuning to select a set of optimizations to accelerate se.
jonas et.al later design a stand alone optimization for optimizing programs for fast verification which includes accelerating se.
in the latter different approaches are proposed to reduce the number of paths to be explored or optimize the constraint solving in se thus speeding up the execution process.
unlike the existing approaches our goal is to make ir based se more efficient by reducing the internal interpretation overheads i.e.
we aim to reduce redundant bound checking of type safe pointers during ir code interpretation.
it is worth noting that our approach can be complementary to existing approaches and further boost faster se by combing them with our proposed approach.fastklee faster symbolic execution via reducing redundant bound checking of type safe pointers esec fse november singapore singapore algorithm type inference system in fastklee input a ir code file bc output a checking list of unsafe pointers checklist 1function typeinferencefunc bc checklist initialize a checking list instruction i processinst bc switch i getopcode do ... other instructions case instruction load do ptr classifypointer i ifptr.type !
safe then key generatekey ptr i checklist .append key case instruction store do ptr classifypointer i ifptr.type !
safe then key generatekey ptr i checklist .append key ... other instructions return checklist approach in this section we present the detailed design of fastklee .
as shown in routes 5in figure after obtaining the ir code fastklee first leverages a type inference system in to classify different kinds of pointers and store the unsafe pointers in a checking list i.e.
checklist .
then the checklist is passed to5and will be used in the customized memory operation in fastklee .
more specifically if a pointer under read write operation is in the checking list a normal bound checking is conducted.
otherwise fastklee omits the bound checking and continues to the interpretation.
in short the omitted portion of bound checking during memory operation is the weapon inside fastklee to make faster se.
next we describe the details of the type inference system and customized memory operation designed in fastklee .
.
type inference system the type inference system in fastklee is designed for classifying pointer types.
typically pointer types in a type inference system are in the following three forms safe pointer can only be null and only needs a null pointer check at runtime seq pointer can be null be interpreted as an integer or be manipulated via pointer arithmetic.
at runtime it needs a null pointer and bounds check and wild pointer cannot be statically typed and it needs null pointer bounds and dynamic type checks at runtime.
since most ir based se engines lack runtime information during execution i.e.
programs are not executed like native runs we categorize pointer types only into safe and unsafe i.e.
seq and wild in fastklee .
specifically the safepointers can be statically verified to be type safe so they do not need bound checking during interpretation while only the unsafe pointers are needed to be bound checked.
therefore the functionality of the type inference system in fastklee is given an ir code of the program under test it records the unsafe pointers when the pointer is performed inalgorithm customized memory operation in fastklee input a checking list of unsafe pointers checklist 1function memoryoperation state ki checklist inbound initialize a boolean value key generatekey ki ifchecklist.find key then inbound normalchecking state ki else inbound ... the following handling the read write operations.
when all the instructions are inferred a checking list checklist that stores all the unsafe pointers is returned.
such a checking list will be the guidance for reducing redundant bound checking of type safe pointers in fastklee .
algorithm presents the detail of the type inference system introduced in fastklee .
the function typeinferencefunc is responsible for classifying different types of pointers.
it takes an ir code file bcas input and outputs a checking list checklist .
inside the function it first initializes the checklist in line and accordingly processes instructions in the bcfile in line .
then when encountering a read line or write line instruction the pointer i.e.
the memory address under read write is classified by invoking the function classifypointer in line or .
later anif branch is performed to check whether the ptrunder handling is an unsafe pointer in line or .
if the answer is yes a keythat represents a unique pointer is generated by calling the function generatekey and will be stored in the checklist later in lines or lines .
finally the checking list is returned in line and will be used in the customized memory operation in fastklee .
.
customized memory operation the purpose of the customized memory operation in fastklee is to take the output i.e.
checklist from the type inference system and use it to guide the customized memory operation during interpretation.
algorithm describes the details.
first a boolean variable inbound is initialized in line and the keyis retrieved by calling the function generatekey in line when a read write instructions are interpreted.
then a checking of whether the key is in the checklist is performed in line to process either normal checking in traditional execution in line if the checking returns trueor assignment of inbound to in line if the checking returns false.
later the normal execution continues after line .
by equipping the type inference system and the customized memory operation fastklee is capable of reducing the interpretation overheads of redundant bound checking of type safe pointers.
implementation we implemented fastklee on top of klee version .
and combined it with the well known ccured type inference system .
specifically for the ccured system we implement it on top of datagrad .
in particular due to the unmapped ir information between analysis and original ir refers to an issue1for more november singapore singapore haoxin tu et al.
figure scatter plot of the improvement in speedups details we first use the debug information i.e.
file name function name the line number of instruction and column number of instruction inside the instruction to represent a unique key implemented in algorithm .
then we reuse the apis from datagrad to record store the unsafe pointers into a checking list checklist .
for the implementation of the customized memory operation in fastklee we modified klee s memory operation api to leverage the information i.e.
checklist from type inference analysis and decide whether the bound checking of a pointer is needed.
evaluation this section presents our evaluation setup and results.
specifically we demonstrate the benefits of fastklee in terms of the time spent on exploring the same number i.e.
10k of execution paths.
.
experimental setup benchmark.
we evaluate fastklee on the widely used gnu coreutils version .
benchmarks.
specifically we select programs in it and the excluded utilities can be categorized into the following types cause non deterministic behaviors e.g.
kill ptx and yes following existing studies exit early due to the unsupported assembly code or external function call and can not successfully explore 10k execution paths in hours i.e.
the timeout to run each test program we set in the experiment .
approach under comparison.
we adopt the notable se engine klee as our baseline as we built on top of it.
running settings.
we followed prior work to set symbolic inputs for gnu coreutils programs.
besides we use breadth first search to deterministically guide the path exploration in klee andfastklee .
the experiments are conducted on a linux pc with intel r xeon r w cpu .60ghz processors and 64gb ram running ubuntu .
operating system.
.
evaluation results to demonstrate the effectiveness of fastklee we run fastklee against klee in terms of the time spent on exploring the same number of explored paths over gnu coreutils .
we set a timeout of hours to run each program and count the time spent on exploring certain execution paths.
specifically we follow the formula below figure box plot of the improvement in speedups figure box plot of the time spent on type inference to calculate the speedups tbaseline ta tbaseline where tbaseline represents the time spent by the baseline klee on exploring 10k paths and tadescribes the time spent by our proposed fastklee on exploring the same number of paths.
the scatter plot in figure shows the distribution of the speedups achieved by fastklee .
the labels under the x axis correspond to the utilities used in our evaluation and the values on the y axis represent the number of speedups by percentage.
we can observe that most of the points in the scatter plot fall from to and the highest point is up to .
.
further in figure we present the box plot depicting the distribution of the percentage number of the speedups achieved by fastklee in detail over test programs.
we could confirm that for the majority of the packages the number of speedups ranges within .
we also calculate the average of the speedups which goes to .
over those test programs.
interestingly from figure it seems there is no discernible trend for the destruction of the speedups.
this is because the benefits gained under fastklee may differ based on different test programs.
specifically if a test program extensively checks safepointers during execution fastklee would be able to significantly reduce its checking overhead and greatly speed up the execution.
to further understand the overhead reduction achieved by fastklee we also evaluate the time used for the type inference in fastklee.
figure describes the trend of the time spent on ccured analysis over test programs.
we can see that the time speed of the analysis is within the range of which can be neglected compared with the whole time usually taking hundreds or thousands of seconds to explore the 10k execution paths .
discussion potential implications of fastklee .although we only show the performance benefits of fastklee in this paper fastklee can have other important implications for path exploration in se.
for example users can extend fastklee to assist se to explore only valuable execution paths due to the time limit or path explosion challenge.
the valuable paths can have at least two important forms.
first a path exploration strategy in fastklee can be guidedfastklee faster symbolic execution via reducing redundant bound checking of type safe pointers esec fse november singapore singapore by the results of type inferences meaning the paths that involve more unsafe pointers are more valuable i.e.
more likely to be buggy .
that is an unsafe pointer guided path exploration can be applied to explore valuable execution paths.
second instead of targeting exploring multiple buggy execution paths one may further leverage type inference results to explore the most valuable buggy path i.e.
paths that are more likely to be exploitable.
both the above implications can help improve the reliability and security of software systems.
we leave this direction as our future work.
threats to validity.
one threat lies in the implementation of fastklee .
we only implement fastklee on a source code based symbolic executor.
since it is feasible to introduce a type inference system into binary code we consider extending the support for other se engines e.g.
angr into fastklee in the future.
another threat comes from the test programs.
we only used selected utilities in gnu coreutils and these programs may not be representative enough for various software systems.
however those test programs have been widely used for evaluating se engines and we consider expanding the program sets for more extensive evaluation in the future.
limitation.
fastklee has a limitation in terms of implementation i.e.
we only implement fastklee on top of a source code based se engine klee.
other binary code based se executors such as angr are not supported yet for the time we submit the paper.
we plan to add the above support in future work.
conclusion and future work we present fastklee a tool that aims to reduce the interpretation overheads of redundant bound checking of type safe pointers for faster se.
in fastklee a type inference system is first leveraged to classify pointer types before interpretation.
then a customized memory operation is designed to perform bound checking only for unsafe pointers during interpretation.
evaluation results demonstrate that fastklee outperforms the state of the art klee in terms of the time spent on exploring the same number of execution paths.
for future work we are actively pursuing to extend fastklee to support more se engines and leverage the abilities infastklee to facilitate more comprehensive path exploration.
acknowledgment the authors would like to appreciate anonymous reviewers for their insightful comments.
this article is partially supported by the national research foundation nrf singapore and the national satellite of excellence in trustworthy software systems nsoe tss award number nsoe tss2019 .