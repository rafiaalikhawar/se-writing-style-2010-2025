peahen fast and precise static deadlock detection via context reduction yuandao cai the hong kong university of science and technology hong kong china ycaibb cse.ust.hkchengfeng ye the hong kong university of science and technology hong kong china cyeaa cse.ust.hk qingkai shi ant group shenzhen china qingkai.sqk antgroup.comcharles zhang the hong kong university of science and technology hong kong china charlesz cse.ust.hk abstract deadlocks still severely inflict reliability and security issues upon software systems of the modern age.
worse still as we note in prior static deadlock detectors good precision does not go hand inhand with high scalability their approaches are either contextinsensitive thereby engendering many false positives or suffer from the calling context explosion to reach context sensitive thus compromising good efficiency.
in this paper we advocate peahen geared towards precise yet also scalable static deadlock detection.
at its crux peahen decomposes the computational effort for embracing high precision into two cooperative analysis stages i context insensitive lock graph construction which selectively encodes the essential lock acquisition information on each edge and ii three precise yet lazy refinements which incorporate such edge information into progressively refining the deadlock cycles in the lock graph only for a few interesting calling contexts.
our extensive experiments yield promising results peahen dramatically out performs the state of the art tools on accuracy without losing scalability it can efficiently check million line systems at a low false positive rate and it has uncovered many confirmed deadlocks in dozens of mature open source systems.
ccs concepts software and its engineering software verification and validation .
keywords concurrency static analysis deadlock detection context sensitivity permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
reference format yuandao cai chengfeng ye qingkai shi and charles zhang.
.
peahen fast and precise static deadlock detection via context reduction.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction deadlocks continue to scourge modern software systems with a denial of service or even malicious attacks .
just in more than sixty open issues in firefox andlinux kernel were associated with deadlocks .
over the last decade many famous systems e.g.
apache android tensorflow have also fallen victims more than eighty cve ids have been assigned to the uncovered deadlock vulnerabilities therein .
thus it is still increasingly urgent to hunt deadlocks before the production runs.
this paper focuses on resource deadlocks arising when each thread in a set circularly waits for another thread to release an acquired lock or a single thread attempts to reacquire a non reentrant lock.
static analysis has the advantage of penetrating obscure program paths harboring deadlocks which however are difficult for dynamic analysis to reach .
yet despite the impressive strides for decades the fast and precise static deadlock detection for million line systems remains far from satisfactory.
specifically past research has strongly indicated that context sensitive deadlock detectors can suppress false positives against the context insensitive ones.
on the downside as we note the context sensitive detectors suffer considerably from the scalability penalties induced by the calling context explosion .
for instance the state of the art context sensitive detector even failed to analyze a few thousand lines of code within half an hour or gb of memory.
a crucial reason as we observe is that the traditional contextsensitive deadlock detection constructs a context sensitive lock graph through a pre computed context sensitive lockset analysis computing the locks held at each program location under different calling contexts.
a node in the graph represents a lock object while a directed edge labeled by the string of calling contexts indicates the order of lock acquisitions under certainesec fse november singapore singapore yuandao cai chengfeng ye qingkai shi and charles zhang calling contexts.
to disclose deadlocks the prior approaches traverse the lock graph to discover cycles that characterize cyclic lock acquisition orders.
again the results of the lockset analysis are leveraged to refine the detected cycles to check if the related lock acquisitions under the specific calling contexts can be executed concurrently i.e.
a common lock does not protect them.
yet we notice that the explosive calling contexts can exceedingly slow down the pre computed lockset analysis and blow up the lock graph with acquired edges thereby inevitably impeding the graph construction and deadlock cycle discovery.
to address the problem our key insight is that only a minority of the calling contexts are associated with deadlocks in practical programs.
as a result a conventional context sensitive detector could cause a great deal of redundancy in the pre computed contextsensitive lockset analysis which is oblivious of the related contexts around the deadlock cycles.
in this work to reduce the irrelevant calling contexts peahen decomposes the cost of reaching highfidelity by first efficiently constructing a context insensitive and smaller lock graph.
with the lock graph in hand peahen can focus on the context sensitive refinement effort around only a few calling contexts that are related to the deadlock cycles whereby saving much cost to deadlock irrelevant computation.
more specifically given the initially detected cycles in the contextinsensitive lock graph peahen employs three precise yet lazy refinements that effectively approximate three different necessary conditions of a deadlock a thread identification analysis to examine whether a deadlock is induced by a single thread or multiple threads.
a context sensitive non concurrency analysis to identify whether a multi threaded deadlock may concurrently occur.
a constraint solving process to validate the path feasibility of a deadlock with a costly smt solver.
surprisingly the refinement process itself is also efficient because the more precise refining results contribute to fewer deadlock cycles as well as less lazy computation.
one salient feature underpinning our context reduction is that our lock graph construction infers and offers the lock acquisition information to bootstrap the lazy refinements in close cooperation.
first our lock graph construction algorithm is compositional and faster than the previous context sensitive lockset analysis because it does not enumerate any exponentially possible calling contexts spanning across the lock acquisitions.
second our algorithm foreseeingly reasons and encodes the essential edge information on which threads acquire the locks and where the lock acquisitions take place which is integrated into the lazy deadlock refinements to be efficiently leveraged.
we have implemented peahen for c c systems where the non nested locks e.g.
pthread apis are extensively exploited.
like many modern static bug finding tools peahen is soundy sacrificing soundness in a few common cases for high fidelity.
the experimental results are highlighted below advancing the state of the art we compared peahen to two recent detectors cbmc context sensitive and infer context insensitive under the benchmarks .
it is noted that we refer to the static deadlock detector ascbmc throughout because it is maintained in a git branch of the cbmc project .
peahen achieves speed up versus cbmc and reasonably is slightly slower than infer .
peahen can reduce around .
and .
false positives against cbmc andinfer respectively.
in addition peahen can detect all the intentionally planted deadlocks in their benchmarks .
our context insensitive lock graph can reduce about .
acquired edges that are otherwise identified and added to a context sensitive graph.
moreover our lock graph construction and cycle detection process are about and faster than the ones in cbmc respectively.
effective on large systems we have used peahen to capture deadlock issues on a diverse set of real world widely used open source c c software systems.
peahen can effectively finish the checking of multi mloc code bases e.g.
firefox around hours at a relatively low false positive rate .
on average .
peahen has detected more than eighty confirmed deadlocks from dozens of famous open systems all told .
to sum up our contributions are as follows we advocate peahen a context reduction technique for fast and precise deadlock detection in large software systems.
we present a compositional algorithm to construct a contextinsensitive lock graph for non nested locks which is also collaborative with lazy deadlock refinements.
we conduct substantial experiments to show peahen s good scalability and precision versus the previous work.
2peahen in a nutshell we first utilize a buggy program in figure to clarify the concept of deadlock .
.
we then illustrate the shortcomings of the previous context sensitive solutions .
.
finally we highlight the essence of our more effective context reduction approach .
.
.
example illustration let the symbol ctxrepresent the calling context and sidenote the statement at line i. for the code snippet shown in figure there are two concurrent threads t1andt2 running the functions thread andthread respectively.
specifically the thread t1first executes the function foo holding a lock o1and then executes the function foo again with the lock o1released before.
similarly the thread t2executes the function bar twice one of which is protected by the common lock o1.
if we take a close look at the functions foo andbar there is an order inversion between the locks o2ando3.
that is a deadlock may be triggered when the thread t1acquires the lock o2ats8 waiting ats9foro3to be released but thread t2acquires the lock o3 ats21 waiting ats22foro2to be released and neither can progress.
however the function foo under the calling context ctx1and the functionbar under the calling context ctx3cannot be executed concurrently because they are protected by a common lock o1 also called a gate lock .
thus the two functions foo andbar under other compositional calling contexts such as foo atctx1peahen fast and precise static deadlock detection via context reduction esec fse november singapore singapore context insensitivelock graph construction1.
void thread1 thread t12.
lock v1 o13.
foo ctx14.
unlock v1 .
foo ctx26.
.
void foo .
lock v2 o29.
lock v3 o310.
x .
unlock v2 .
unlock v3 .
.
void thread2 thread t215.
lock v1 o116.
bar ctx317.
unlock v1 .bar ctx419.
.
void bar .
lock v3 o322.
lock v2 o223.
x .
unlock v3 .
unlock v2 .
o1 o2o3idcondition ctx1 s8 ctx1 s9 ctx2 s9 ctx1 s9 ctx3 s22 ctx3 s22 ctx4 s22 ctx3 s21 idcondition t1 s8 t1 s9 t1 s9 t2 s22 t2 s22 t2 s21 a b o2o3 o2o3 o2o3 o2o3 o2o3 might s9and s22not be guarded by a common lock?
o1 o2o3context sensitivelockset analysiscontext sensitivelockset analysis context sensitivelazy refinement figure figure a shows the previous context sensitive approach which uses a dual purpose context sensitive lockset analysis for both constructing a lock graph and identifying the gate lock.
figure b shows the context reduction approach which first constructs a context insensitive smaller graph and detects fewer cycles followed by the context sensitive lazy refinements.
andbar atctx4 can be executed concurrently and a deadlock bug could surface to bit bringing the program to a grinding halt.
to sum up there are two key steps for static deadlock detection.
first the lock acquisition orders in each thread should be identified to derive cyclic orders among locks.
second the initial results on reversed orders of lock acquisitions should be further refined such as context sensitively identifying the gate lock scenarios.
importantly the solutions should both be precise and highly scalable sieving through millions of lines of code in just a few hours.
.
the state of the art however to go for high precision the prior approaches could not scale up to large systems.
an essential reason is that they commonly employ a flow context sensitive lockset analysis which computes the locks held at each program point .
the precise precomputed lockset analysis can kill two birds with one stone it is capable of context sensitively identifying the lock acquisitions and the gate locks.
on the downside the explosive calling contexts in large programs can drastically slow down the lockset analysis and blow up the lock graph with acquired edges.
to illustrate in figure a the approach first constructs a contextsensitive lock graph using a context sensitive lockset analysis.
for instance the lockset analysis can tell that the lock o1is held at the statements8under the calling context ctx1.
therefore the thread t1 can hold the lock o1and acquire the lock o2ats8underctx1 resulting in a context sensitive acquired edge from o1too2.
every edge condition shown in the right table consists of the correspondingcalling context ctxof the lock statement sthat refers to the destination lock.
for example the condition on the edge is ctx1 s8 indicating that a thread t1 holds lock o1and then acquires lock o2 ats8under the calling context ctx1.
based on the context sensitive lock graph a cycle detection is performed to identify the context sensitive cycles on the graph.
as shown in figure a four context sensitive cycles are detected.
again the technique uses the context sensitive results of the lockset analysis to identify the gate lock scenarios.
for the detected cycle with the edges and thes9under the calling context ctx1and thes22underctx3are protected by a gate lock o1 so the statementss9ands22cannot be reached simultaneously under the corresponding calling contexts.
on the other hand the remaining three ungated cycles are reported to the developers warning of the calling contexts of foo andbar to trigger a deadlock bug.
we notice that the context sensitive acquired edges are unnecessary for identifying the lock acquisition orders in each thread.
for example the four detected context sensitive cycles indicate the same case i.e.
there is a cyclic waiting condition between lock o2at s22in threadt2and locko3ats9in threadt1.
on the other hand the refinements only target and identify whether statements s9ands22 related to a deadlock cycle can be concurrently executed which is oblivious to the pre computed lockset analysis.
.
our context reduction approach to ameliorate the aforementioned problems we introduce a contextreduction approach breaking down the prohibitive cost of beingesec fse november singapore singapore yuandao cai chengfeng ye qingkai shi and charles zhang context sensitive for all sub tasks.
that is peahen uses a fast algorithm to construct a context insensitive lock graph and the cycle detection to find the fewer context insensitive deadlock cycles.
the cycles are then successively and lazily refined for a few deadlockrelated calling contexts.
to illustrate in figure b peahen begins by constructing a smaller context insensitive lock graph.
apparently our lock graph saves two unnecessary edges.
the edge conditions are shown in the right hand table with the calling context removed extra edge information is introduced later .
in other words all the different calling contexts are reduced or merged into one.
armed with this smaller graph peahen efficiently performs a cycle detection algorithm to detect only one deadlock cycle.
the context insensitive cycle with edges and indicates that there is a cyclic waiting condition between lock o3ats9and locko2ats22without any known calling context information.
then a context sensitive gate lock analysis is queried by the question might s9ands22not be guarded by a common lock?
the answer is yes flagging they are not protected by locko1under three compositional calling contexts s9atctx1 ands22atctx4 s9atctx2ands22atctx3 as well ass9atctx2ands22 atctx4.
the context sensitive report is identical to the one in the previous approach by courtesy of the context sensitive refinements.
it is worth emphasizing that the final gate lock analysis in either the previous methods or peahen computes four conditions of calling contexts to identify the gate locks.
however we argue that the pre computed exhaustive lockset analysis unaware of any potential program points that might lead to deadlocks could miss many opportunities to avoid futile context sensitive computation.
comparatively our lazy refinements can work efficiently on the calling contexts around the identified deadlock cycles of interest.
this example briefly illustrates the distinction between the prior work and peahen .
in we further introduce the notion of our lock graph and the varieties of the deadlock cycles emphasizing which lock acquisition information is encoded in the lock graph cooperatively for the deadlock cycles refinements.
preliminaries in this section we elucidate the basic terminologies and notations and state the key technical challenges we aim to conquer.
language and abstract domain.
let the symbolv v v denote pointer variables while o o o indicate memory objects such as lock objects.
a thread id t t t represents a thread which corresponds to a context sensitive fork site and thus denotes a unique runtime thread.
following the common practice we use the method fork t f to uniformly represent the creation of the threadtexecuting a procedure f f f and the method join t to denote the destruction site of the thread t. meanwhile we create two threads with identical attributes but different thread ids for a fork site allocated in a loop.
we assume the locks are non nested and are not necessarily released in the reverse order in which they are acquired.
the implementation of pointer analysis is discussed in .
henceforth without losing generality we use method pt v to indicate the points to set of the pointer variable v. lock graph.
against the prior context sensitive lock graph we design a context insensitive lock graph to characterize the lockacquisition orders and to facilitate the cooperation with the lazyrefinements.
notably an identified cycle in the lock graph exposes the cyclic lock acquisitions manifesting a potential deadlock.
definition .
a context insensitive lock graph lg is a directed graphg n e c where n is a set of nodes each of which n corresponds to a lock objecto o o. thus we also use oto denote a node.
e n n is a set of edges.
the direction of an edge indicates the lock acquisition order.
an edge o1 o2 means that a thread holds a lock o1 the source lock node and then acquires another lock o2 the destination lock node.
c maps each edge e e to a tuple t s1 s2 the edge condition indicating that the thread tholds the source lock o1ats1and then acquires the destination lock o2ats2.
there are two noteworthy points.
first the above lock graph is context insensitive in the sense that each edge is no longer encoded with the corresponding call strings.
second to provide the crucial lock acquisition information for lazily refining the deadlock cycles for each edge o1 o2 two types of information are memorized.
particularly each edge condition t s1 s2 includes i the thread information the thread id t about which thread acquires the locks o1ando2and ii the program location information statements s1 ands2 where the acquisitions of locks o1ando2take place.
we show later how to leverage this information for refining deadlock cycles discovered in the lock graph.
deadlock cycle.
with the lock graph we define four varieties of deadlock cycles.
in a single threaded deadlock due to reacquiring a non reentrant lock a thread t1acquires a lock o1ats1and proceeds to acquire the same lock o1ats2.
thus it suffices to identify whether there is a detected cycle with only one edge and the number of involved nodes equal to one reacquiring the same lock .
such cycles are called single threaded cycles .
in a multi threaded deadlock in the case of two threads a thread t1first acquires a lock o1ats1and waits for another lock o2to be released at s2while a thread t first acquires the lock o2at s 1and waits for the lock o1to be released at s .
more complex cases involving more than two threads resemble the above.
thus it suffices to identify the cycles with all the acquired edges labeled with different thread ids which we call multi threaded cycles .
definition .
a deadlock cycle discovered in an lg is termed a single threaded cycle if the cycle has only one edge and one node.
meanwhile a cycle is termed a multi threaded cycle if the cycle has multiple edges labeled with distinctive thread ids.
in addition for the above example of a multi threaded cycle whether the lock statements s2ands 2can be concurrently executed by the threads t1andt2should be precisely identified to eschew any bogus deadlock warnings.
such a multi threaded cycle is called a concurrent cycle .
note that a single thread cycle has no use for accounting for the concurrency semantics.
definition .
a multi threaded cycle is termed a concurrent cycle if the related statements referring to the destination lock nodes in different threads can be concurrently executed.
finally for both single threaded and multi threaded cycles they should be path feasible i.e.
the related statements should be pathreachable simultaneously which we call path feasible cycles .peahen fast and precise static deadlock detection via context reduction esec fse november singapore singapore stage twostage onelock graph constructionsingle multi threaded cyclesconcurrent cyclespath feasiblecyclesprogram ir reports figure the workflow of peahen .
definition .
a single threaded or multi threaded cycle is termed a path feasible cycle if the related statements involving the cycle are path reachable with the feasible path conditions.
there are three points to note.
first concurrent cycles and pathfeasible cycles are the stronger conditions than single threaded cycles or multi threaded cycles to be genuine deadlocks.
second identifying path feasible cycles is generally more expensive than identifying concurrent cycles because the former should validate the path conditions via constraint solving.
third to our knowledge thus far no prior deadlock detector has taken the non nested locks statements concurrent execution relations and statements pathfeasibility into account at once .
problem statement .
after introducing the basic notions we next state two technical challenges we aim to address.
how to design an efficient algorithm for constructing the context insensitive lock graph and in the meantime encoding the lock acquisition information on related edges.
how to synergize multiple lazy analyzes to incorporate such edge information into progressively refining the discovered deadlock cycles to regain high precision.
before introducing our algorithms in we give an outline of our solutions against the above two challenges.
we present an inter procedural compositional algorithm for constructing the context insensitive lock graph.
it is sensitive to threads and encodes the lock acquisition information on edges for the coming refinements.
.
we present three precise yet lazy refinements to progressively improve the precision of the initially detected deadlock cycles by successively identifying single multi threaded cycles concurrent cycles and path feasible cycles.
.
4peahen in detail in this section we follow the peahen s workflow as illustrated in figure to unravel our algorithms.
peahen has two symbiotic stages subsuming the context insensitive lock graph construction .
and three precise yet lazy deadlock cycle refinements .
.
.
context insensitive lg construction this part delves into our inter procedural algorithm to construct the context insensitive lock graph defined in .
constructing the context insensitive lock graph is non trivial.
first in the non nested locks the loose correlation between the lock statements and unlock statements across complex deep calling contexts makes inter procedural analysis hard.
many detectors for java programs are limited to the nested locks .
second despite not being sensitive to the different call sites encoding the threadinformation on edges should characterize different threads so as to distinguish which threads acquire the locks.
to conquer the first challenge a context independent function summary is devised particularly for the decoupling non nested locks which enables compositional analysis and avoids repetitive functional computation.
second to distinguish which threads acquire the locks we create clones of the lock acquisitions in the related functions that are invoked by different threads and encode the related edges with the different thread identification.
lock summary.
our idea of a function summary is to capture the additional locks at the exit relative to the entry that are acquired and released therein in sequence.
while analyzing any of its callers for identifying the lock acquisitions the reusable summary can thus tell which locks can be additionally acquired and which locks can be released therein in the control flow orders.
example .
.
figure shows a buggy program.
there are two concurrent threads t1andt2 both running the function foo and bar .
intuitively a function summary for bar should indicate that at the exit relative to the entry the lock o1is first released at s7and subsequently the lock o1is acquired at s10.
when analyzing any callers of bar we do not need to analyze bar anymore.
formally a summary for a function f called a lock summary denoted asls f is a finite sequence i.e.
ls f l0 lk each of which is a set li i .
all the lock summaries can be denoted as a set ls i.e.
f f ls f ls.
notably first each element liin the sequence ls f is a set because each statement lock v may refer to more than one lock and the lock behaviors on different branches are joined flow sensitively.
in other words the lock summaries are path insensitive.
second the order between li 1andliindicates the control flow orders which matters for analyzing the non nested locks.
formally for each element li li r o s b whereli r o s b r b .
first every plus tuple o s b inlidenotes that lock omay be acquired via executing a statement s lock v .
whether the lock ohas been released in the current function fis indicated by a boolean value b. second every minus tuple o s b inliindicates that the lock o would definitely be released via executing a statement s unlock v .
whether the unlock statement shas released the lock o previously acquired in the current function f is also indicated by b. below is an example for readers to comprehend the domain b. note that a lock may be acquired at statement swhile a lock must be released ats which are resolved by the pointer information.
this manner isesec fse november singapore singapore yuandao cai chengfeng ye qingkai shi and charles zhang .
void thread1 t!
.
fork t thread2 .
foo .
join t .
.
void bar .
unlock v!
o!
.
x .
lock v!
.
.
void thread2 t .
foo .
.
void foo .
lock v!
.
lock v o .
bar .
unlock v .
unlock v!
.
a b c idcondition s!
s!
s!
s!
o2o1 o2o1t t t!t!cloning thread1thread2foobar figure figure a is a buggy code using non nested locks b is its call graph and c illustrates the cloning process.
identical to the prior work for identifying all the lock acquisitions in common practice .
example .
.
back to figure the lock summary ls bar is computed as o1 s7 o1 s10 .
first the tuple o1 s7 indicates that the lock o1must be released at s7 and its value ofbis implying that the lock o1is acquired from callers not therein.
second the tuple o1 s10 shows that the lock o1 may be acquired at s10 in fact in this case it is definitely acquired and has not been released in the function bar indicated by b .
compositional algorithm.
at a high level algorithm identifies the acquisitions and releases of locks in a bottom up fashion by tracking and updating the lock summary for each function.
during the process the lock graph is incrementally constructed.
the intra procedural analysis is fairly standard dataflow analysis that explores every statement of the intra procedural control flow graph cfg in the reversed post order.
at callsites the callees summaries are used to answer which locks are acquired and released therein.
the dataflow result the lock summary at the exit of the function is recorded and other intermediate results are removed.
for handling loops we devise the join operators to handle merge nodes in cfg to guarantee termination.
recursive functions are iteratively recomputed to reach fixed point results.
there are three key intra procedural steps for computing ls f and updating lg.
handling a lock statement s lock v lines first the produced acquired edges at sshould be identified.
peahen connects an edge o o tolgfrom each previously acquired yet not released lock i.e.
o s b inls f to each lock that may be acquired at s. second the possible acquired locks at sshould be tracked in the summary ls f .
thus peahen adds each lock othat may be acquired at lock v i.e.
o s tols f .
handling an unlock statement s unlock v lines first peahen obtains the definitely released lock oby identifying the variable vfrom the pointer information.
if there is no must information it skips the next steps.
second whether the lock previously acquired in f is released atsshould be tracked in ls f .
that is if there is alock o s inls f o o that is released at s we update the tuple o s to o s .
third the summary ls f should track the released lock at s. that is ifshas released the lock opreviously acquired in the fon the last step o s is added to ls f .
otherwise o s is added tols f .
example .
.
we havels bar o1 s7 ats7.
ats10 because there is no previously acquired lock o1indicated in ls bar we directly have ls bar o1 s7 o1 s10 .
when analyzingfoo ats16 we havels foo o1 s16 .
next ats17 we havels foo o1 s16 o2 s17 .
there is a previously acquired lock o1inls foo so we need to add an edgee o1 o2 tolg which is initially encoded with c s16 s17 .
handling a call site s y callfoo x lines first the inter procedural acquired edges produced should be identified.
it connects an edge o o inlgfrom each currently acquired yet not released lock o s inls f to each acquired lock r o s b inls foo .
second the summary ls f should track whether some locks would be released in foo.
therefore it updates the valuebof the locks acquired in fbut released in foo from to .
finally it updates ls f by including the callee s ls foo in the control flow order.
other kinds of statements do not affect the acquisitions and releases of locks and thus are not analyzed.
example .
.
in figure recall that the computed ls foo ats17is o1 s16 o2 s17 andls bar is computed as o1 s7 o1 s10 .
when analyzing the callsite bar ats18 the analysis enumerates the ls bar to check each tuple.
when it is a released lock like o1 s7 and the lock o1 also exists in ls foo the analysis sets its boolean value to i.e.
o1 s16 becomes o1 s16 to indicate that the lock o1has been released in bar .
when it is an acquired lock like o1 s10 the analysis adds an edge to the lock graph from the acquired but unreleased lock in the current ls foo i.e.
from o2inls foo too1inls bar .
we thus succeed in identifying an inter procedural acquired edge o2 o1 .
finally we add the summary ls bar tols foo sols foo ats18becomes o1 s16 o2 s17 o1 s7 o1 s10 .
note that locks o2acquired at s17ando1acquired at s10would be released ats19ands20 respectively.
selective cloning.
after analyzing each function f if the functionfis invoked by different threads and is a root function peahen clones the acquired edges created in fand distinguishes which threads acquire the locks by encoding the thread identification on edge conditions.
lines for example in figure the two threadst1andt2both run the function foo that callsbar and foo is the root shared function.
we only need to clone the edges in the root function like foo to avoid repeated edges because the edges ofbar are included in the ones of foo .
for the non sharing functions we encode the edges with a unique thread id.
example .
.
following the bottom up order of the call graph in figure b our algorithm first analyzes the bar as well asfoo peahen fast and precise static deadlock detection via context reduction esec fse november singapore singapore algorithm context insensitive lg construction 1cg construct a call graph for a multi threaded program p 2foreach unvisitedfin reverse topological order of cg do initializels f foreachsin reverse post order of cfg of fdo handleeachinstandpropagate s addls f at the exit program point of ftols foreacht the threadtinvokingf t tdo foreache the edgeecreated infdo clonee update its condition cwith thread id t 10return a context insensitive lock graph lg 11procedure handleeachinstandpropagate s ifs lock v then foreach o s b li i ls f do foreacho pt v do add an edge e o o withc s s tolg add o s o pt v tols f else ifs unlock v then 18o pt v ifo o o s b li i ls f then o s o s add o s tols f else add o s tols f else ifs y callfoo x then retrievels foo l ... fromls foreach o s li i ls f do foreach r o s b l j j ls foo do ifr then add edgee o o c s s tolg else ifr o o then o s o s addls foo tols f and updates the lock graph with two corresponding acquired edges o1 o2 and o2 o1 .
then since the foo is the root function invoked by two different threads t1andt2 the analysis clones the two edges with two different thread identifiers t1andt2to distinguish which threads acquire these locks.
armed with the lock graph peahen can start by detecting the deadlock cycle.
remark.
in algorithm a key step that is omitted to reach context insensitive is aggressively cloning the edges of lock acquisitions in a function on all its call sites and labeling the edges with the respective calling contexts.
instead we selectively clone for a function invoked by different threads and encode the lockacquisition information on each edge.
this is because peahen is only concerned with the cyclic lock acquisitions in each thread.
this way the lazy refinement can incorporate such information into lazily refining deadlock cycles around a few calling contexts of interest thereby bypassing premature calling context explosion.
summary.
the effectiveness of our lg construction is twofold.
first it is compositional efficiently analyzing each functionindependently of its callers and bypassing the enumeration of all the calling contexts.
the context insensitive lock graph is smaller yet characterizes threads which is judiciously encoded with the essential lock acquisition information for lazy refinements.
second the smaller graph empowers fast cycle detection and less memory space to store.
in the subsequent phase our refinements can focus on the computation effort around the fewer calling contexts related to the context insensitive cycles to regain high precision.
.
collaborative lazy deadlock refinements once the lock graph is in hand peahen conducts a cycle detection algorithm to identify an initial over approximation set of deadlock cycles.
then it performs the following three analyses that approximate the different necessary conditions of being deadlocks dedicatedly refining these initial cycles.
readers can review the cycle definitions in .
single multi threaded cycle computation .
.
concurrent cycle computation .
.
path feasible cycle computation .
.
note that every stage exploits the edge information on each cycle refines the cycles from the preceding one in a lazy fashion and avoids any futile computation to acyclic edges.
.
.
single multi threaded cycle computation .at this stage the set of the initial cycles denoted as c c is refined as the set c1 the union of single threaded cycles c1 1and multi threaded cycles c1 .
let the function t return the set of all thread ids on edges in a cycle n return the set of all nodes involved in a cycle ande return all the edges in a cycle .
c1 c e n c1 c t1 t2 t t1 t2 c1 c1 c1 indeed owing to the encoded thread information on edges foreseeingly by the lg construction this first refinement is simple by efficiently checking the edge conditions and the number of nodes .
.
.
concurrent cycle computation .at this stage the multithreaded cycles c1 are refined by identifying and retaining concurrent cycles which together with c1 are denoted as c2.
we perform non concurrency analysis to reveal given a multithread cycle whether the statements that refer to the destinationlock nodes can be executed concurrently arising from the fork join and lock unlock synchronizations.
at a high level our basic idea is to lazily collect the thread ids referred by the join statements and the unreleased locks referred by the lock statements before an interesting statement sunder the related calling contexts.
specifically each join statement join t witnesses the destruction of thread tbefores and thus any other statements in the threadtcannot be concurrent with s. similarly an unreleased lock oreferred by a lock statement lock v reveals that the lock oprotects the statement s. therefore any other statements also protected by the common lock ocannot be concurrent with s. peahen performs a backward search from any interesting statements following the inter procedural context sensitive controlflow graph to collect the set of joined thread ids jt s ctx and theesec fse november singapore singapore yuandao cai chengfeng ye qingkai shi and charles zhang .
void thread2 t214.
lock v!
.
lock v .
if !
.lock v .
x .
unlock v .
.unlock v .
unlock v!
.
.void thread1 t12.
fork t thread2 .
lock v!
o14.
lock v o25.
if !
.
lock v o37.
x .
unlock v .
unlock v .
unlock v!
.join t .
idcondition t!
s s t s!
s!
a b o2o3 figure an example for the three lazy refinements.
set of unreleased locks ul s ctx reachable from the related calling contexts ctx.
the search and collection processes themselves are similar to the previous lockset analysis but are performed lazily.
this is because we are aware of the related statements where the destination locks are acquired owing to the edge information.
formally let the d return all the lock statements that refer to the d estination locks in a cycle .
c2 s1 d ctx t1 jt s1 ctx t1 t c2 s1 s2 d ctx ctx ul s1 ctx ul s2 ctx c2 c1 c2 c2 c1 setc2 1indicates that at least a thread t1involved in a multithreaded cycle is destroyed.
the set c2 2indicates that at least two statements s1ands2 refer to the destination locks involved in a multi threaded cycle are guarded by a common lock.
a multithreaded cycle with either of these circumstances is then removed.
.
.
path feasible cycle computation .finally peahen performs path validation to identify path feasible deadlock cycles.
our basic idea is to validate whether the related statements involved in a cycle are path feasible simultaneously.
let p s p p be all the intra procedural paths leading to a statement sand p indicate the path conditions on p. let function s return the encoded lock statements referring to the source lock and the destination lock on acquired edges in an interesting cycle .
c3 c2 s s p p s p true while validating path feasibility is expensive in general due to the need for smt solving we observe that for deadlock detection it can be efficient because of the following observations.
first the number of deadlock cycles to be proved path feasible is much fewer owing to the successive sieving by the previous two stages.
second we observe that expensive solving for the full program paths is not necessary for practical deadlock detection so peahen only solves the intra procedural paths for high efficiency also discussed in the evaluation .
example .
.
figure shows an initially detected cycle with edges and because there is a reversed order between the locks o2ando3.
it is a multi threaded cycle since it is induced by different threadst1andt2through analyzing the conditions on edges.
in nonconcurrency analysis peahen starts to collect the join statements before statements s6ands17to find the joined threads which areempty.
then peahen collects the common unreleased lock before statementss6ands17that iso1.
thus the cycle is not a concurrent cycle.
it is also not a path feasible cycle due to the contradicted path conditions between s6ands17.
however we do not solve the constraints thanks to the preceding non concurrency analysis.
summary.
our refinements confer two salient advantages to our deadlock detection.
first our refinements are lazy which are aware of the interesting calling contexts around the initially detected cycles and thus avoid performing pre computed whole program context sensitive computation.
note that it is the result of the synergy between the lg construction and the lazy refinements that ensures the effectiveness of peahen .
second our refinements are precise regaining the high precision for the initial context insensitive deadlock cycles.
more importantly as the refining deadlock cycles become more and more precise fewer cycles lead to less lazy computation.
previous work does not consider the path feasible deadlocks which is taken into account by peahen .
evaluation to evaluate peahen we consider the following research questions q1how efficient and effective is peahen compared to the previous static deadlock detectors?
.
q2canpeahen scale up to million line systems?
can peahen detect genuine deadlocks?
.
all the experiments are performed on a computer with two core intel r xeon r cpu e5 v4 .20ghz and 256gb physical memory running ubuntu .
.
implementation.
peahen is implemented for c c programs on top of the llvm compiler infrastructure and the z3 smt solver.
for precision we implemented on demand field flow and contextsensitive pointer analysis .
following many well known bug finding tools our implementation is soundy which means that our tool is mostly sound aside from a few wellidentified reasonable unsound choices for achieving higher precision.
particularly there are two sources of the unsoundness in our implementations.
first our pointer analysis shares the same unsoundness sources as the one we use.
for instance it does not correctly handle the pointer arithmetic array accesses containers and so on.
second our lock graph construction ignores the locks that are inside blocks of the assembly code as the prior deadlock detectors .
.
q1 comparing with previous techniques this experiment aims to show that the prior context sensitive approach is unscalable while the context insensitive one is imprecise.
comparatively peahen provides a better sweet spot in the trade off between precision and performance.
we compared peahen against two recent and relevant tools for the non nested non reentrant locks cbmc and infer .
cbmc is context sensitive constructing a context sensitive lock graph through a pre computed context sensitive lockset analysis and using the results of the lockset analysis again to refine the deadlock cycles discovered in the lock graph.peahen fast and precise static deadlock detection via context reduction esec fse november singapore singapore peahencbmc10 1time logscale subject id order by time of cbmc 30peaheninfer10110 3time logscale subject id order by time of infer peahen peahencbmc10 3subject id order by time of cbmc time logscale 110130peahen memory logscale peahen peahencbmcsubject id order by memory of cbmc 110124peahen peaheninfer10 2101memory logscale subject id order by memory of infer peahencbmcmemory logscale 1subject id order by memory of cbmc a c e b d f figure a b c d shows the time min and memory gb comparison in entire deadlock detection among peahen cbmc andinfer .
e f shows the time min and memory gb comparison in lg construction among peahen cbmc andpeahen .
infer is an abstract interpretation based context insensitive deadlock detector reasoning locks by syntactic expressions.
we use this version for supporting pthread apis.
benchmark.
to reduce the subjectivity the chosen benchmarks are collected from cbmc .
the benchmarks consist of diverse programs from the debian gnu linux distribution e.g.
fuse glfw libmicrohttpd ranging in size from a few kloc to kloc with a total of .
mloc .
additionally they intentionally planted eight programs with deadlocks .
following their evaluation memory and time are restricted to gb and minutes per program respectively.
.
.
scalability.
we check whether each tool can successfully analyze all programs within the time and memory budget.
first cbmc spent about .
minutes around hours with programs out of time and programs out of memory.
comparatively peahen succeeded in checking within .
minutes around hours achieving speed up.
second infer finished checking all these programs within .
minutes around .
hours which is slightly faster than peahen .
in detail shown in figure a b for the programs analyzed by cbmc with more than one minute and one gb peahen significantly outperforms cbmc .
it demonstrates our approach is efficient for large programs.
shown in figure c d compared to infer peahen is also competitive with many projects finished at slightly more memory and time cost.
this cost is reasonable since peahen is more precise with context sensitivity as shown below.
.
.
precision.
the experimental results show that infer cbmc and peahen report and issues respectively.
to sum up peahen can reduce around .
and .
of false positives compared to cbmc andinfer respectively.in detail we manually checked each generated report and made three conclusions.
first we found that the bugs flagged by peahen are also detected by cbmc andinfer .
second cbmc andinfer generate excessive spurious bugs.
specifically after checking the bugs generated by cbmc andinfer that are not detected by peahen we found that they are false positives.
for bugs generated bypeahen only of them are deemed to be false after manual confirmation.
third peahen can detect the eight intentionallyintroduced deadlocks which suggests that the precision of peahen is achieved without sacrificing the recall.
peahen is more precise owing to two reasons.
first peahen conducts more precise refinements against infer andcbmc .
for example figure shows a false positive in pdsh detected by infer andcbmc where the cyclic lock acquisitions between the locks src anddstare on the contradictory paths and cannot be simultaneously path feasible.
hence when multiple threads execute the function cbuf copy a deadlock could not occur.
second in practice the lock objects could be derived from structures as fields passed in as parameters and reassigned at different locations of control flow.
the pointer analysis we implemented is field flow and contextsensitive which can aid in preventing certain false positives.
.
.
effectiveness on two collaborative stages.
compared tocbmc we study the effectiveness of peahen to reach contextsensitive through two collaborative stages the context insensitive lock graph construction and the precise yet lazy refinements.
lock graph construction.
first we compare each program s time and memory cost to construct the lock graph.
to evaluate our context reduction technique and exclude the side effects from different implementations of pointer analyses we implemented peahen which constructs a context sensitive lock graph byesec fse november singapore singapore yuandao cai chengfeng ye qingkai shi and charles zhang 1012intcbuf copy cbuf tsrc cbuf tdst intlen int ndropped lock cbufsin order of lowest memory address to prevent deadlock.1035if src dst 1036cbuf mutex lock src 1037cbuf mutex lock dst else 1039cbuf mutex lock dst 1040cbuf mutex lock src figure a false positive detected by other tools.
cloning the acquired edges for all the calling contexts during our compositional algorithm algorithm .
the results are illustrated in figure e f with the programs running out of time during the pointer analysis of cbmc removed.
figure e shows that the proposed algorithm in peahen is consistently faster than peahen andcbmc achieving about and speed up on average respectively.
for this reason peahen does not enumerate any exponentially possible calling contexts spanning across the lock acquisitions.
figure f illustrates that dealing with the programs analyzed bycbmc andpeahen with more than one gb peahen significantly outperforms peahen andcbmc in terms of memory cost saving about gb memory at most.
we manually checked these programs and found they intensively use locks so that a contextsensitive lg is expensive to construct.
finally we studied the number of acquired edges on the buggy programs.
this reveals that our context insensitive lock graph can merge about .
edges on average that would otherwise be identified and added to the context sensitive ones of peahen andcbmc .
moreover the results also reveal that the cycle detection algorithm ofpeahen working on the context insensitive lock graph achieves about speed up on average.
lazy refinements.
next we study the effectiveness of the refinements.
it is disclosed that our refinements can prune away deadlock cycles in about minutes reducing about .
of false warnings.
three refinements can progressively prune away about and false warnings respectively.
answer to q1 armed with our context reduction approach peahen achieves higher precision without sacrificing good scalability versus the state of the art approaches.
.
q2 checking large scale projects we evaluate the effectiveness of peahen for large programs.
we set a high bar and selected four additional real world projects based on two principles.
first the project should be million line and widelyused in practice.
second the projects should be using mutex locks intensively.
as a result the projects we chose comprise four real life open source c c projects shown in table ranging in size from around .
mloc to nearly mloc.
.
.
scalability and precision .for evaluating the scalability we checked how much time and memory is spent conducting the entire deadlock detection.
the results are shown in table suggesting that peahen succeeded in checking firefox with nearly mloc in around two hours and within of gb memory.idproject namesize kloc deadlock detection bug report memory gb time min all tp mariadb .
.
ffmpeg .
.
mysql .
.
firefox .
.
table q2 experimental results on large programs.
for precision we manually checked each error generated by peahen and then identified its false positive rate.
the results show thatpeahen generated deadlock warnings with false positives resulting in a .
false positive rate.
this process may be subjective and pose threats to the validity of its precision.
therefore we also sought the confirmation from the original developers and sent the patches to ease their work.
at the time of writing seven of the bugs have been confirmed by them.
thanks to its precise refinements peahen can prune away numerous false warnings.
for false positives a portion of them is induced by the imprecise pointer alias relations e.g.
infeasible paths function pointers inducing the imprecise lock acquisitions.
another source comes from ignoring other uninterpreted synchronizations e.g.
waits notifies ad hoc synchronizations inducing the imprecise concurrent execution relations.
to overcome these limitations peahen needs to adopt more precise pointer analysis and characterize more synchronizations.
.
.
confirmed real world deadlocks .we have been using peahen to scan open source projects extensively and continuously.
at the time of writing there were already more than eighty confirmed deadlock bugs from dozens of the famous systems despite many of which are consistently and intensively undergoing bug checking.
most of the bugs have been fixed in the recent release versions of the software making them more reliable and robust.
next we study two real deadlocks in figure .
a deadlock is detected in freeipa the upstream project for red hat identify management.
if we take a closer look the bug pattern is quite simple where the statement at line should be an unlock statement.
however this bug has been missed by the developers users as well as dynamic testing and has existed for about eight months.
the developers were very concerned with this bug noting that this code is used quite frequently by freeipa.
why have we not seen a problem with it until now.
it demonstrates that static analysis matters and of course scaling up to this large program is also critical which is addressed in this paper.
a deadlock is uncovered in aml a memory management library for high performance computing applications.
a deadlock occurs when a thread t1reaches line while another thread t2reaches line relating to the path conditions of lock statements.
with the path sensitive analysis peahen can precisely uncover it.
answer to q2 peahen is efficient for million line systems flagging deadlocks at a low false positive rate.
in terms of real world impacts it has found many confirmed deadlocks.peahen fast and precise static deadlock detection via context reduction esec fse november singapore singapore 82intaml active sched num tasks structaml sched sched if condition1 pthread mutex lock s workq lock pthread mutex lock s doneq lock structaml task aml active sched wa structaml sched data data pthread mutex lock sched doneq lock 263if condition2 264pthread mutex lock sched workq lock 2149staticvoidcheck replicas are done cleaning cleanruv data data if !slapi is shutting down pthread mutex lock notify lock .
.
.
pthread mutex lock notify lock figure real deadlocks in freeipa and aml respectively.
related work ensuring the reliability of concurrent programs is an important problem .
as integral parts deadlock detection prevention and fixing are diverse directions among which we focus on surveying detection.
.
static deadlock detection detectors for java code typically rely on balanced locking.
this work targets java libraries and constructs a global contextsensitive lock graph.
in general their tool can report the false positives due to the non concurrency and path infeasible deadlocks.
jade is object sensitive which breaks down the problem into several context sensitive sub tasks including reachability may happen in parallel non reentrant and non guarded analyses.
jade focuses on two thread deadlocks and could report spurious path infeasible deadlocks.
brotherston et al .
propose a contextinsensitive incremental detector for android java detecting deadlocks in an abstract interpretation style and analyzing code changes with respect to the unchanged portions.
their tool may induce excessive false positives without context insensitive analyses.
detectors for c code do not expect balanced locking which significantly complicates static deadlock detection .
locklint is not fully automatic such that it requires annotations from users to specify the lock acquisition orders.
racerx reaches context sensitive by caching lockset results at the function level which may lead to ill scalability in large systems.
in addition compared to peahen racerx uses the syntactic and type information to reason pointer aliasing require annotations and employs some unsound heuristics to reduce false positives.
kroening et al.
proposes a detector for pthread apis which conducts the context and thread sensitive lockset analysis for the lock graph construction and the cycle refinements.
however as mentioned before context sensitive exhaustive lockset analysis and lock graph construction are expensive.
some work targets for the programs using data centric synchronizations and requires the manual annotations to identify the ordering between atomic sets.
.
dynamic deadlock detection many testing approaches and model checkers can manifest deadlocks .
we focus on investigating recent predictive analysis which has been applied to detect a variety of concurrency bugs such as data races and deadlocks.
specifically deadlock prediction can be categorized into two classes in terms of soundness i.e.
the absence of false positives .
unsound deadlock prediction may induce false positives due to for instance ignoring happens before relations.
thus they commonly need to be integrated with other techniques via scheduling a real deadlock or identifying and solving execution constraints .
at the core of the prediction they construct a lock graph by tracking the lock acquisition history from just a single execution and identify the cycles.
to relax the deadlock prediction overhead many seminal approaches have been proposed.
the latest one airlock speeds up the online cycle discovery via first finding simple cycles without considering any execution information e.g.
threads and then constructing deadlock cycles by taking full execution information into account.
note that peahen andairlock have similar flavors in the sense of reducing lock graphs by simplifying the edges and efficiently discovering cycles.
nevertheless peahen addresses many challenges that are unique to static deadlock detection thereby differing in many aspects.
for example instead of constructing the lock graph from one execution peahen addresses the calling context explosion induced by over approximating all possible executions.
in addition unlike airlock peahen is armed with the refinement process to validate the feasibility of deadlocks e.g.
considering the happens before relation whereby embracing high fidelity.
another category of sound work never induces false positives with the theoretical guarantees.
specifically dirk uses request events and a new form of execution constraints to disclose real deadlocks via solving all these constraints.
seqcheck models the program branches in the execution traces and predicts the feasibility of event sequences for sound deadlock detection.
conclusion we have introduced peahen a context reduction technique making static deadlock detection more scalable and precise.
peahen is quite promising having already pinpointed many previouslyunknown deadlocks on a dozen of well known software systems.
we believe that context reduction is a big step forward in static deadlock detection which ameliorates the major current pain point in the practical deployment of deadlock detectors.
we expect that peahen can provide interesting insights into aiding in other static analyses to become more scalable with high precision for industrialstrength software.
finally we plan to extend our approach to communication deadlock detection.