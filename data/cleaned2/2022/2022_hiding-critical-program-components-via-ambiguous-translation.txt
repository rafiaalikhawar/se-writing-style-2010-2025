hiding critical program components via ambiguous translation chijung jung university of virginia charlottesville va cj5kd virginia.edudoowon kim university of tennessee knoxville knoxville tn doowon utk.eduan chen university of georgia athens ga ac24057 uga.eduweihang wang university at buffalo suny buffalo ny weihangw buffalo.edu yunhui zheng ibm research yorktown heights ny zhengyu us.ibm.comkyu hyung lee university of georgia athens ga kyuhlee uga.eduyonghwi kwon university of virginia charlottesville va yongkwon virginia.edu abstract softwaresystemsmaycontaincriticalprogramcomponentssuchas patented program logic or sensitive data.
when those components are reverse engineered by adversaries it can cause significantly damage e.g.
financiallossoroperationalfailures .whileprotecting critical program components e.g.
code or data in software systemsisof utmostimportance existingapproaches unfortunately havetwomajorweaknesses theycanbereverse engineeredvia various program analysis techniques and when an adversary obtains a legitimate looking critical program component he or she canbe sure that it is genuine.
in this paper we propose ambitr a novel technique that hides critical program components.
the core of ambitr is ambiguous translator thatcangeneratethecriticalprogramcomponentswhen theinputisacorrectsecretkey.thetranslatorisambiguousasit canacceptanyinputsandproducesanumberoflegitimate looking outputs making it difficult to know whether an input is correct secretkeyornot.theexecutionsofthetranslatorwhenitprocesses thecorrectsecretkeyandotherinputsarealsoindistinguishable makingtheanalysisinconclusive.ourevaluationresultsshowthat static dynamicandsymbolicanalysistechniquesfailtoidentifythe hiddeninformationinambitr.wealsodemonstratethatmanual analysisof ambitris extremely challenging.
ccsconcepts securityandprivacy softwaresecurityengineering software reverse engineering.
keywords program translation software protection reverse engineering introduction software systems often contain critical program components such asclassified sensitive orproprietarycodeordata whichwecall this work is licensed under a creative commons attribution international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
program components orcpc .
for example patented program logic is an example of cpc.
if an adversary steals or copies a competitor ssoftwaresystem spatentedtechnology itwouldcause significant financial loss.
similarly in a warfare software system e.g.
software in a drone a cpc can be a piece of code containing itsoperationalprocedures includingthetargetsandplans.since an adversary can reverse engineer a software system to reveal various critical operational secrets e.g.
targets of the military system and target operation date which can be used against the victim protecting cpcs is an essential requirement.
there are a few techniques that can be leveraged to hide critical program components obfuscation packing and encryption .
code obfuscation techniques syntacticallytransformtheoriginalprogram scodeintoanotherformof code makingitdifficulttobeanalyzedmanually.
dataobfuscation techniques changethevalueofdatainawaythatdoesnot changetheoriginalsemanticofthedatawhilemakingitdifficulttoknowtheoriginalvalue.however bothobfuscationtechniquespreserve critical semantics meaning that they only delay the analysis butcannotprotectthecriticalcomponents.apackercompresses orencryptstheprogramcodeanddata andstorestheminadata section of the packer s loader program.
however it is not suitable for hiding cpcsbecause it always decompresses or decrypts the originalprogram code and data at runtime.
tounderstandtheeffectivenessoftheexistingtechniquesinhidingcriticalprogramcomponents weanalyzeapproachesthatcanbe used against theobfuscation packing and encryptiontechniques.
specifically weobservethatobfuscationtechniquesandpackers canbeeasilytracedandanalyzedbydynamicanalysis .
whileencryption basedtechniquesarechallengingtobreakcryptographically the execution of the decryption function can be traced to extract the decrypted data i.e.
the genuine critical program components .tothisend weconcludethatwhilethetechniques certainly raise the bar in analysis i.e.
making the analysis chal lenging it is practically feasible for a persistent and determined adversarytoobtainthecriticalprogramcomponentprotectedby existing techniques.
more importantly since there is no ambiguity in decoding and uncompression processes the adversary knows thatthecpcis undoubtedly correct when obtained.
inthispaper weproposeanoveltechnique ambitr thataimsto hide critical program components against adversaries with access ieee acm 44th international conference on software engineering icse icse may21 pittsburgh pa usa chijungjung doowonkim anchen weihangwang yunhuizheng kyuhyunglee andyonghwikwon tothetargetprogram.specifically wehidecriticalprogramcomponents e.g.
program codeordata byencodingthe components toacomplexstate machine.givenacorrectsecretkey thestatemachinegenerates thegenuinecritical program components e.g.
program code or data .
the key difference between ambitr and existingtechniquesisthatambitrcantaketheincorrectsecretkey asinput andgeneratelegitimate lookingcpcs making itdifficult todeterminewhetherthegiveninputisthecorrectsecretkeyor not.unlikeatypicalstate machine ambitr sstate machineallows a transition on any inputs even if it does not match the transition s input i.e.
atypicalstate machinewillraiseanerrorifitdoesnot match .
the differences between the state transition s input and the given input are then used to generate output different from the statetransition s output.this significantly enlarges theinput outputspaceofastatetransitioninambitr.withthestate machine ambitr introduces a unique challenge to the adversary ambiguity meaningthateveniftheadversaryidentifiesalegitimate looking outputfromambitr theadversarydoesnotknowwhethertheoutputisthegenuinecriticalprogramcomponent.tothisend with the sophisticated construction of our state machine the critical programcomponenthiddenbyambitrisextremelychallenging to be identified.
moreover even when some possible outputs are identified one cannot know which output is the genuine cpc.
ourcontributionsare summarized as follows weanalyzelimitationsofexistingtechniquesaimingtohideprogramcode andinvestigateapossibilityofaddinganewchallenge ambiguity.
weproposeambitr whichcanhidecriticalprogramcomponents cpcs throughasophisticatedtranslationtechniquethataccepts any inputs and generates multiple plausible cpcs that are not distinguishablefrom the genuine cpc.
we perform a thorough evaluation using state of the art dynamic static and symbolic analysis tools to demonstrate ambitr s resilience to reverse engineering attempts.
positioning and background .
definition critical program component cpc .
we define critical programcomponentasapieceofcodeordatathatcontainscritical programlogicorinformation whichisnotdesirabletobeknownto theadversary.itisimportanttomentionthat inourcontext while the adversary knows that there is a cpc hidden in the program he or she does not know what the cpc should be.
in other words givenasetofplausiblecpcexamples theadversarydoesnotknow which one is the correct cpc.
in this paper we aim to prevent the adversary from identifying and pinpointing the correct cpc.
.
positioning typical usage scenario.
figure illustrates how ambitr operates under a typical usage scenario of our research.
specifically in a target program we use our ambiguous translator to hide a criticalprogramcomponent.atruntime itreceivesaninputfroman externalsourcesuchasnetwork andfeedsittotheambiguous translator whichgeneratesoutputsaccordingtotheinput.if the input is the correct secret key the genuine cpc is generated .
on other inputs our ambiguous translator still produces valid outputs without failing.
in particular on certain specialized inputs decoycpcsthatareindistinguishablefromthegenuinecpcare generated .
finally the outputs i.e.
cpcs are processed or executed if its type is an executable code .
ambiguous translator secret input non secret input genuine cpc critical program comp.
g decoy cpc target program secret i adversary network inputs non secret input decoy cpc access to inputsaccess to program codeindistinguishable outputs ... ... processing or executing58indistinguishable execution figure assumed scenario and scope of the research.
adversarymodelandscope.
in this work we assume the adversaryhasaccesstopreviousinputsandthetargetprogram scode including our ambiguous translator s logic .
the adversary can also run the program with any inputs including the obtained previousinputs.thegoalof ambitristo preventthe adversaryfrom identifying the secret input that can generate the genuine cpc without a doubt .
to achieve the goal ambitr can generate outputs including the genuine cpc and decoy cpcs that are indistinguishable from each other .
the execution of the ambiguous translator when it generates the original or decoy cpcs is also indistinguishable as well as the processing or execution of the generated cpcs .
weassumethatthepreviousinputsmightexistinanetworklog and are available to the adversary.
however the adversary does not know what is the secret input from the obtained previous input.someof the inputs may generate decoy cpcs.
we assume that target program s behaviors and execution for processing and executing the cpcs are not distinguishable.
otherwise the code canbetracedtoidentifywhichinputgeneratesthegenuinecpc.if the original target program should execute different program code suchcode shouldbeincludedin theexecutablecpc.
we assume the adversary can leverage various static and dynamic analysis techniquestoanalyzeourambiguoustranslator.weconsiderour approach is successful if the adversary fails to pinpoint the genuine cpc even if many or even all valid cpcs are identified .
.
existing techniques for hiding cpc a few techniques can be leveraged to hide a cpc in a program.
specifically thecolumnsintable1presentthetechniqueswhile each row of the table shows program analysis approaches that can be used to identify cpcs.
symbols represent the effectiveness of theprogram analysis approaches against each technique.
1121hidingcriticalprogramcomponentsviaambiguoustranslation icse may21 pittsburgh pa usa table effectiveness of existing techniques and ambitr againstprogram analysis approaches.
obfuscators packers crypters protectors ambitr static analysis1 symbolicanalysis1 dynamicanalysis forced execution ineffective lesseffective effective against analyses .
static symbolic analysis techniques have difficulty handling advanced obfuscators with multiple layers of obfuscations due to state explosion whilethey can handle simple obfuscators.
static analysis may handle known crypto algorithms while it may not genericallyhandlethem hence half filled circled meaning that effective on some but not all .
.
.
obfuscators.
obfuscation techniques aim to make the original code difficulttoanalyzebyleveragingtechniquesincludingopaquepredicates code insertion replacement andhardware primitives .
limitations.
obfuscation techniques that transform code into semanticallyequivalentformsoraddnon essentialcode e.g.
opaque predicatesanddummycode canbe handledbyautomaticallyrevertingorremovingthemodified added code via program analysis techniques .
dependingontheobfuscationtechniquesused staticandsymbolic analysismaysufferfromthecomplexityoftheanalysis meaning that they might not be always effective as described in table .
typically dynamic analysis including forced execution techniques are highly effective in handling the obfuscation techniques.
while data obfuscation techniques change the values of data theircriticalsemanticsarepreservedandcanbetracedand identified by both static and dynamic analysis .
.
.
packers crypters.
packers primarilyaimtohinder static analysis.
specifically they create a program containing compressed original program asdata that uncompresses and executes the original program at runtime.
crypters are essentially advancedpackersusingcryptotechniquestohidetheprogramdata and code.
due to the complexity of compression and encryption staticandsymbolicanalysisarenoteffectiveasshownintable1.
in particular symbolic analysis suffers from state explosion due to thecomplex computations of encryption schemes.
limitations.
since a packer generated program seamlessly unpacks and executes the original code at runtime dynamic analysis i.e.
executing the binary and extracting the uncompressed program canobtaintheoriginalprogram.
.
.
protectors.
protectors areessentiallyadvanced packers cryptersequippedwithevasiveanti analysistechniques suchasterminatingtheexecutioniftheydetectreverse engineering attempts e.g.
running the program with a debugger .
similar to packers crypters since the program itself is compressed and encrypted staticandsymbolicanalysesarenoteffective asdescribed in table .
specifically symbolic and concolic analyses can be used to avoid the evasive techniques by extracting and solving the evasivepredicateconditions.however theyaredifficulttoscaletothe programsgenerated byprotectors.moreover dynamicanalysis is ineffective because of the evasive techniques.limitations.
forcedexecutiontechniques aim tohandleevasivetechniquesbyforciblyexecutingbranchesregardless of the predicate conditions.
most protectors can be handled by the forced execution techniques.
note that since the forced execution techniques forcibly execute program code regardless of the predicateconditions theymayfailtohandleanadvancedprotector which uses predicate conditions for both evasive techniques and decryption i.e.
decryption logic is dependent on the predicate conditions .however byobservingthepredicateconditionsand executions of the program it is straightforward to tune the analysis technique to handle such advanced protectors e.g.
one can selectivelysolvesuchacriticalpredicatewithsymbolicexecution to handle the limitation .
.
desirableproperties wepresentfourdesirablepropertiesofacpchidingtechniques evasiveness complexity context sensitivity andambiguity .
fromexistingliterature.
for the first three properties we identifyandsummarizethemfromexistingliterature.notethatprior literature does not explicitly present the properties.
they are only implicitlymentionedindividually e.g.
evasivenessin complexityin context sensitivityin .wesystematicallystudied priorliteraturetoestablishthedesirableproperties.inparticular from program analysis papers we mainly focus on the challenges e.g.
state explosioncausedbycomplexity theypointed out.fromanti programanalysistechniques we pay attention to the approaches proposed by them to hinder the analysis e.g.
evasivetactics .webelievethefourproperties thoroughlycover the core properties across the literature.
new desired property ambiguity.
we introduce a new desirablecharacteristic ambiguity details in section .
.
.
.
.
evasiveness.
programsthatarehighlyevasive e.g.
programs with a number of evasive predicates impose significant challenges to symbolic and dynamic analysis.
for dynamic analysis knowing a number of concrete inputs that can cover all the evasive predicates is challenging.
for symbolic analysis an excessive number of predicates and complex predicate conditions cause the scalability problem i.e.
taking too much time making the technique practicallyunusable .
.
.
complexity.
static and symbolic analyses have difficulty analyzing programs with complex operations.
typical examples arepacked encryptedprograms.staticandsymbolicanalysescan reverse engineer the uncompression decryption process.
however they fail to scale complex algorithms e.g.
a crypto algorithm .
.
.
context sensitivity.
someprogramshavecontext sensitive code meaning that their behaviors are dependent on a particular program execution path.
since there are a large number of program paths it is common for static analysis to conduct contextinsensitive analysis.
symbolic analysis aims to discover various execution contexts hence often suffers from the excessive number of program execution paths causing the path explosion.
forced execution solvesthe pathexplosion problemby forcibly executing code guarded by branches .
however due to the ignored branch outcomes which lead to incorrect context the results of the execution may notbe precise.
1122icse may21 pittsburgh pa usa chijungjung doowonkim anchen weihangwang yunhuizheng kyuhyunglee andyonghwikwon decoding decryption error decrypted key key error key adversary error errorthere is only one correct key that can successfully decrypt wrong keys always lead to errors figure existing techniques are notambiguous.
.
.
ambiguity.
when an adversary obtains a successfully decoded decryptedcpc iftheadversarycancertainlysaythecpc isgenuine weconsiderthetechniqueis notambiguous.inother words if the adversarycannot determine whether the cpc iscorrect or not we consider the technique has the ambiguity property.
specifically obfuscators do not go through a decoding process meaning that executing the obfuscated program would expose the criticalprogramcomponents.packers crypters protectorstypically storethecompression encryptionkeyforthecriticalprogramcomponent in the programs.
hence running the program without any particular input would expose the cpc.
advanced crypters protectors often store the key for cpc in a separate place making it challenging to decrypt.
similar to ambitr an application may receive the key via the internet.
assume that an adversary obtains a few keys from the network traffic logs and try them to the program.
figure describes an example scenario with three different keys where key is correct andkey2and3areincorrect.unlikeambitr existingcrypters protectors are not ambiguous meaning that the decoding decryption will be only successful with key and all other keys e.g.
key and will result in errors.
as a result observing any successful decryption with a key implies that the decrypted cpc are genuine.
table properties in existing techniques and ambitr.
obfuscators packers crypters protectors ambitr evasiveness1 complexity2 context sensitivity3 ambiguity high medium low no.
protectors have medium evasiveness because while they detect the environment to avoid e.g.
vm debugger their detection is not sophisticated.
obfuscators packers crypters protectors use various encoding crypto algorithms with varying complexity determining the complexity property.
both simple and complex algorithms are used leading to the medium.
very few protectors are context sensitive e.g.
using a context sensitive variable as a decryption key.
summary of desirable properties.
table shows the desirable properties in existing techniques and ambitr.
as discussed noneofexistingtechniqueshastheambiguityproperty.moreover ambitrismoreevasive complex andcontextsensitive than existing techniques.
design .
overview and intuition ambitr leverages a specialized state machine to translate input to cpcs.thestatemachineisdesignedtoacceptanyinputvaluesand generatethegenuinecpcor decoy cpcs depending on the input.
the state machine achieves evasiveness andcontext sensitivity since without knowing the particular secret key i.e.
the secret input forthegenuinecpc executingthestatemachinewithother inputs does not produce the genuine cpc.the state machine contains a number of states for decoy cpcs achieving complexity .
finally thedecoycpcsandtheexecutionof ambitrarenotdistinguishableto the genuine cpc achieving ambiguity .
.
.
ambitrversusatypicalstatemachine.
atypicalstatemachineonlyacceptsinputthatcanmakestatetransitionsfromthe currentstate.hence tounderstandallpossibleinputs andcorrespondingoutputs onecancollectallthestatetransitions inputs andcomeupwiththepermutationsofthem.
unliketraditionalstate machinethatshouldhaveanacceptingstate ambitrdoesnothave the acceptation state.
it terminates when it has consumed all the inputs.note thatambitr soutput isgeneratedwhena transition happens notattheacceptingstateasatraditionalstate machine does.
figure a shows an example state machine.
circles and arrows represent states and state transitions including input and output of each transition in and out .
a traditional state machinecanonlyacceptinputsthatmatchthestatetransitions inputs.
for instance from a it only accepts two inputs blinding and reference that make transitions to bandc respectively.
the restrictiononacceptedinputsessentiallylimitstheinputandoutput space.
figure b shows all possible inputs and outputs of the traditionalstatemachinefrom atodande.thiscanbedone by identifying all possible state transitions and inputs because any otherinputs e.g.
the last row of figure b result in errors.
inputs for cpcs is implicit in ambitr.
figure c shows inputs and outputs that can be handled by ambitr using the state machine in figure a .
note that it can handle all the inputs in the same way the traditional state machine handles.
the first row shows an example.
ambitrallowsacpctobedecodedbyinputsthatdonotmatch thestatetransitions inputs.thesecondrowshowsanexample.the firstinput pywudh doesnotmatchanytransitioninputsfrom a blinding for band reference for c. however as shown in the third column it makes a transition to b since the distance in asciicodevalueofeachbyte betweenthegiveninputandthestate transition s input of bis closer than the state transition s input of c. when it produces an output it also uses the measured distance between the input and the state transition s input to compute a newoutputvaluethatisdifferentfromthestatetransition soutput.
by so ambitr s state machine does not have restrictions on the inputs it can take meaning that any inputs can be accepted.
moreover outputs that ambitr s state machine can produce are notrestricted as well.
thesecond third andfourthrowsinfigure3 c showexamples of legitimate looking decoy cpcs i.e.
meaningful executable code but not the genuine cpc from inputs that do not match any state 1123hidingcriticalprogramcomponentsviaambiguoustranslation icse may21 pittsburgh pa usa abin blinding out elements c a state machine ... represents omitted states input output state transitions blinding control codes ele ments extended code a g198b g198d blinding corresponding elements interchanging a g198b g198e reference illustration materials manipulation a g198c g198e reference bell control code s materials ring extended code a g198c g198b g198d reference bell corresponding materials ring interchanging a g198c g198b g198e reference code materials error a g198c g198 error b traditional state machine s state transitionsd e... ...in reference out materials in control codes out extended code in corresponding out interchanging in illustration out manipulation in bell out ring input output state transitions blinding control codes ele ments extended code a g198b g198d pywudh vatxf.ar3r i system get a g198b g198d rnpjmf c i4b unlink file a g198b g198d re l 1kb !
0prm h mail to t msg h a g198c g198e c a mbitr s state transitions figure traditional state machine vs. ambitr.
transitions inputs.thethreeinputshavedifferentsizes andthe fourth row s input leads to different state transitions atocand e fromtheothertwo.notethatmanymoreinputscangenerate legitimate looking outputs and one can brute force inputs e.g.
tryingallpossiblestringsforinput toenumeratethem.weexplain thedetailsof the state machine in section .
.
.
.
.
ambiguityinambitr.
ambitrintroducesambiguityintwo aspects ambiguity in input output and execution.
ambiguous input output.
the input of ambitr is ambiguous becauseitcantakeanyinputsevenifitdoesnotmatchanystate transition inputs as shown in figure c .
when the input does not match any state transitions ambitr finds a transition that has the closest input to the provided input in terms of ascii code valueofeachbyteofinput .observethatambitr soutputcanalso differ from the state transition s output and is dependent on input meaningthattheoutputis also ambiguous.
theambiguityoftheoutputsmakestheanalysisinconclusive.
for example in figure c the second third and fourth rows outputs are all legitimate executable code.
hence it is challenging to conclude which one is the genuine cpc.
ambiguous execution.
one may use dynamic analysis to trace the execution of ambitr to understand whether there are any execution differences while processing different inputs.
if such a differenceexists itcanbeusedtoinferthegenuinecpc.asshown in algorithm that describes the algorithm of ambitr s state machine will be explained in section .
.
there are no predicates and computations that behave distinctively.
hence tracing the executionof ambitrdoes not help to identify the genuine cpc.algorithm1 algorithmof ambiguous translator input instr arrayof tokenized input string.
output outstr outputstring.
1procedure statemachine instr assign the initial state i.e.
init .
2statecur init 3whileuntilit consumes all the tokens of instr the current token is instrcurdo find the matching or closest transition from the current state.
statenext tran in tran out findtransition statecur instrcur change the current state statecur statenext outcur compute output according to the distance between the input and transition sinput foreach byte tiand tointran in andtran out do is a string concatenation operator.
outcur outcur round to ti outstr outstr outcur 10returnoutstr 11procedure findtransition statecur instrcur 12minscore 13foreach transition trfrom state curdo score tr foreach byte btof input of transition tr and each byte bi from instr curdo score score bt bi char converts a number to a string concatenates strings.
tr tr char bt bi finding the matching or closest transition.
ifminscore is 1or min scorethen minscore score tran in tr trnextrepresents the next state of the transition tr statenext trnext troutrepresents the output of the transition tr tran out trout 24returnstatenext tran in tran out .
composing ambitr ambitr consists of two components ambiguous translator whichisapieceofsoftwarethatprocessesinputaccordingtothe statemachinedefinitiontogenerateacpc section3.
.
and definition of the state machine that the ambiguous translator operates section .
.
.
.
.
ambiguoustranslatorruntime.
thecoreof ambitristhe runtimeofambiguoustranslator.ithastwouniquecharacteristics.
first regardless of the current state and input it always transits to anotherstate eventheinputdoesnotmatchanytransitions c1 .
notethat inatypicalstatemachine astatetransitiononlyhappens whenthereisatransitionthatcanacceptthecurrentinput.second when ambitr takes inputs that do not match the existing transitions the output generated by ambitr is also different from the transitions outputs c2 .
specifically the final output is computed 1124icse may21 pittsburgh pa usa chijungjung doowonkim anchen weihangwang yunhuizheng kyuhyunglee andyonghwikwon ab cin unemploymentbenefit out reassuringinvestors a automaton b output translation results... ... input output state trans.
l18mibthay.g1 t c predict a g198b sjwmq o hsp passthru cmd a g198b x p bzltd y r urldecode str a g198b swvq1g hn fwrite f cnt a g198c phvw v y r chroot dir a g198c ozhm qhyyysl bzdecompress d a g198c d output computation l18m ibthayunemploymen c input delta computation in term conditions out generateoutputs .g1 tbene 7027527166t fit c predictreassuringi 2nvest ors figure4 examplesofdynamicoutputtranslation.computations i.e.
b and c are on ascii code values.
basedonaconcreteinputatruntime.thissignificantlyenlargesthe search space of input and output.
algorithm shows its algorithm andwe will use it to explain the details of the two characteristics.
makingtransitionsonanyinputs c1 .
ambiguoustranslator makestransitionsfromanystatesonanyinputs.specifically forall nextreachablestatesfromthecurrentstate itcalculatesthedistance by subtracting values from each byte offset and accumulating the results as shown in figure between the current input and the transitions inputs findtransition in algorithm .
lines inalgorithm1essentiallycomputethedistance score .then it selects a transition with the smallest distance if there are multiple ties we pick the first one to make it deterministic as shown in lines19 23in algorithm .
dynamicoutputtranslation c2 .
whenambiguoustranslator makes a transition on an input that is not exactly matched with the transition s input it generates output that is different from the currentstatetransition soutput.
specifically it computes the new outputby applyingthedifferences betweenthecurrent inputand the current state transition s input.
this makes the output space significantly large as the output can vary as much as the input varies.
in algorithm one of the return values of findtransition line4 is tran in whichrepresentsthedistancebetweenthecurrentinputandthecurrentstatetransition sinput.
findtransition alsoreturnsthecurrent i.e.
selected transition soutputas tran out.
then at lines it computes the new output by subtracting each byteoftran in i.e.
ti fromthetransition soutput tran out i.e.
to .notethatthereisthe roundfunctionatline8 whichessentiallyrounds the computed value to be in the visible ascii code value range i.e.
.
example.
figure a shows an automaton of a state machine whereinputsandoutputsoftransitionsareillustratedaboveand below the arrows.
figure c describes an example computation of distances i.e.
delta between the transition s input e.g.
unemploymentbenefit and the given input at runtime e.g.
l18mibthay.g1 t .specifically foreachcharacter itsubtractsasciicodevaluesofthecharacters.theresultsareshownat thebottomlineoffigure4 c .wethensubtractthevaluestothe transition s output to derive the final output i.e.
c predict as shown in figure d .
figure4 b presentssixexamplesofinputandoutputpairsfrom a three for a band the other three for a c .
the first example is the one that is illustrated in figure c and d .
the second and third examples show inputs for generating function calls passthru and urldecode .thethreeexamplesshowthatthe same state transition a b with different inputs can generate completely different outputs i.e.
cpcs making the translation ambiguous.
thenextthreeexamplesaregeneratedviathetransition a c.again dependingonthegiveninput itgeneratescompletely different outputs and those outputs are all legitimate executable code making it difficult to know which one is the genuine cpc.
.
.
composing automaton.
ambitr s ambiguous translator operateson anautomaton wherethe definitionofautomaton isnot particularly different from the traditional automaton.
the automaton consists of states and transitions between the states where the transitionshave inputs and outputs.
states and transitions for the genuine cpc.
we first create statesandtransitionsthatcangeneratethegenuinecpc.specifically givenacpc wetokenizethecpctoobtainasequenceof shortstrings e.g.
stringsof5 10lengths .thenweaddastatethat can translate each token and connect the individual states.
the resulting automaton is the minimum automaton that can generate acpc.wechoosetheinput outputofstatetransitionsbyusinga dictionary e.g.
anenglishdictionary .specifically werandomly pick two words for input win and output wout of a transition.
then tomakesurethatthetransitioncangenerateadesiredtoken of cpc tokencur we obtain an input candidate for cpc by computing win wout tokencur which is essentially rev ersing the translationprocess.
figure5showsanexample.giventhesamestatetransitionused infigure4 wechooseinputandoutputfromadictionary.inthis example weconcatenatetwowords unemployment and benefit for input and reassuring and investors for output as shown in figure a .
then given a token string to translate shown in figure5 b wefirstcompute wout tokencurasshowninfigure5 c .
we compute win wout tokencur as shown in d .
the outcomeisthesecretkeythatcangeneratethecpctokenstring tokencur .finally wealsorunourambiguoustranslatortocheck whetherthesecretinputcangeneratethecpctoken.notethatdue totheroundinginthetranslationprocess line8inalgorithm1 somesecretkeysobtainedbytheaboveprocesscannotgeneratethe cpc token string.
if this happens we choose another input output pairand repeat the process until it succeeds.
1125hidingcriticalprogramcomponentsviaambiguoustranslation icse may21 pittsburgh pa usa a bin win unemploymentbenefit out wout reassuringinvestors a automaton d secret input computation l18m ibthayunemploymen78 c delta computation .g1 tbene7027527166 t fit187356 c predictreassuringi 2nvest ors b cpc token string c predict figure identifying secret key for a cpc token.
unnecessary states and transitions.
we then add extra states and transitions between all states to hinder analysis attempts of thestatemachine.dummytransitionsconnect allstates notonly dummy states making ambitr more difficult to analyze.
note thatthedummystatesandtransitionsareusedtotranslatedecoy i.e.
fake cpcs.
inputs outputs of the transitions to the dummy states are chosen in a way that the inputs of all transitions look similar makingitchallengingtoknowwhichtransitionsareforthe genuinecpc.specifically foreachnewlyaddedtransition itsinput is derived by choosing a similar word i.e.
synonyms antonyms in dictionaries to its neighboring transition s input.
evaluation in this section we present various experimental results to show theeffectivenessof ambitrincomparisonwithexistingstate ofthe art techniques and analysis tools.
in particular we evaluate ambitr in terms of evasiveness via dynamic analysis tools in section .
.
complexity via static analysistools in section .
.
andsection .
.
and the context sensitivity section .
.
.
implementation.
we implement our ambitr creator in python loc .
it generates ambitr written in php loc excludinglinesforthetransitioninputsand outputs .
ambiguous translator configuration.
for the evaluation ambiguoustranslator isconfiguredtocreatebinarysampleswithat leastmore than nodes and each node has at least edges.
table ambitrinstancesstatistics.
sizeof of avg.
size of avg.
of avg.
of cpcs avg.
samples ambitr states transitions 10kb .
kb .
kb .
.
kb .
kb .
kb .
.
kb .
kb .
kb .
.
kb .
kb .
kb .
.
kb .
kb .
kb .
.
.
applicability tounderstandwhetherambitrcanbecreatedbyvariousinput output pairs we collect code snippets and programs from popular repositories .
note that for ambitr those inputcpcs are simply strings and values of the inputs do not affect ambitr s performance.
we successfully generate ambitr instances for all collected samplesasshownintable3.giventhesecretinput theyallsuccessfully generate cpcs as expected.
we categorize them by the samples sizes withanintervalvalueof10kb .thesizesof ambitrarelargerthantheoriginalsamples weapplycompression e.g.
gzip to reduce the size of ambitr .
except for the first group the size of ambitr is about times larger than the original sample.
.
automated analysis of ambitr we compare ambitr with state of the art obfuscation protector techniquestoshowambitreffectivelyhidescpcs.inparticular we use a forced execution technique malmax as it can effectively expose cpcs hidden by existing techniques see table .
obfuscators protectorsselection.
fourstate of the artphpobfuscators and two crypters protectors are chosen based on their popularity.obfusactorsincludephpobfuscator yakpro best php obfuscator and simple online php obfuscator .
crypters protectorsincludezendguard andphpencoder .
result.asdiscussedinsection1 obfuscatorsdonotrequireany particularinputorenvironmenttodecodeandrunthegenuinecpc.
evenwithouttheforcedexecutiontechnique malmax weobserve the cpc s execution by simply running them.
for zend guard and php encoder it requires the encryption key to be accessible via network.weuse malmaxtorun theprogramsprotected byzend guardandphpencoder withoutencryptionkeyaccess.initially theyallfailtoexecute.then wetryanincorrectkeybycreating anotherkey fromzendguard andphpencoder.the wrongkey isessentiallyakeyforanotherprogram.asexpected thewrong key results in failed executions for all samples because the existing techniques are not ambiguous as shown in figure .
then weuseacorrectkey obtainedbytracingnetworkcommunicationswhenitrunswithouterrors .werunmalmaxagain with the correct key and all samples are successfully decrypted and expose cpcs.
as discussed in section .
.
the fact that it can successfully execute indicates that the identified cpcs are genuine.
wealsousemalmaxtoanalyzeambitrprotectedsamples.however malmaxfailstoexposeanyofcpcsfromthesamples.this is because malmax focuses on executing all statements without precisely identifying the key secret inputs.
simply executing all statements of a target is not sufficient for analyzing ambitr.
moreover while the execution of ambitr under malmax is incorrect ambitr does not cause any errors or observable behavior differences.
some generated outputs are not valid while there are still many seemingly valid outputs looks like cpcs causing ambiguity in analysis.
even one can observe the genuine cpc e.g.
having a networktraceoftheinputleadingtothegenuinecpc knowing whethertheobserved cpc is the original is not verifiable.
.
reverse engineering ambitr we evaluate ambitr from a reverse engineer s perspective in terms of how difficult to reveal the genuine cpc using various program analysis tools manually.
in the following subsections we 1126icse may21 pittsburgh pa usa chijungjung doowonkim anchen weihangwang yunhuizheng kyuhyunglee andyonghwikwon 20for i i ... i define st i i define cur state define input define output define next state state tbl array array current state input of the transition output of the transition next state array st0 states urdonk st1 array st0 prince drunks st2 array st1 celestiala 7gz mp3.es st3 array st1 systematia 83s png.ez st3 array st3 costinfisco wxp.zwl st2 array st2 fiscaltable ubuntu 0f st3 ... cur state st0 while tran find transition state tbl cur state input cur state state tbl result.
dynamic translate state tbl state tbl input function dynamic translate in out cur in for i i strlen cur in i ret.
chr ord out ord in ord cur in return ret function find transition state tbl cur state in foreach state tbl as next transition for j j strlen in j d abs ord state tbl ord in return index min delta 40st0 st1 st2 st3in states out urdonk in prince out drunks in systematia out 83s png.ez in celestiala out 7gz mp3.es in costinfisco out wxp.zwl in fiscaltable out ubuntu 0f b state machine red arrows are the transitions generate the genuine cpc.
st0 is an initial state a source code of the exam ple ambiguous translator figure simplified source code of ambiguous translator in php .
assumethatthereverserobtainsasampleof ambitrwithoutknowingtheintended input that generates output.
.
.
dynamicanalysis.
weassumeascenariothatthereverser attempts to use xdebug to monitor its execution.
xdebugis a php debugging extension providing various debugging primitives such as step debugging i.e.
single stepping variable dumps and stacktraces.specifically ittracesvariablesthatareusedtocompute outputsfrom inputs similar to program slicing .
analyzing executed statements.
the reverser traces all statements that read and write inputs and values that are computed from inputs i.e.
values that are data dependent on the inputs .
unfortunately as a state machine is implemented as a loop that makes transitions according to the current input e.g.
as shown in figure a the resulting traces include most of the statements regardless of whether the execution delivers an attack or not.
analyzingvaluesfromexecutedstatements.
thereverseralso dumps all the values of the variables used in the executed statements.however astheexecutiondoesnotdeliverthegenuinecpc analyzingthevaluesdoes not help.
.
.
staticanalysis.
staticanalysistoolscanbeusedtoanalyze ambitr to identify possible output values that can be generated byambiguous translator .
specifically the reverser uses static taint analysis tools to find out the data flow of ambiguous translator .
further staticanalysistoolsthatcanconductavalue setanalysis e.g.
are used to infer possible values of a few key variables.
simplified source code of ambiguous translator .figure a showsasimplifiedversionof ambiguoustranslator writtenin php.
lines define constants.
lines build a state transition tablethatis essentially an array of state transition rules including current state input output of the transition and next state line .it hasaloop lines22 thatrepeatedly findsatransition according to the input line makes the transition line and dynamically creates an output according to the input line .
the dynamictranslationisdoneinafunction lines29 .theresult is essentially a concatenated string of the dynamic outputs line .figure6 b showstheground truthof ambiguoustranslator showninfigure6 a .ithasfourstates st0 st3 andthereare multipletransitionsamong st1 st2and st3.figure data dependency graph by taint analysis.
backward data slicing via taint analysis.
there are several php static analysis tools that support taint analysis pixy eir taint em all and taintphp .
note that most of them do not properly propagate taint tags through array and array index operations.
hence we reimplement figure without usingarrayssothattheycaneffectivelyanalyzeambitr.moreover taintphp doesnotsupportinter procedureanalysis hencewe inlineallfunctions e.g.
dynamic translate inambitrand feedittotaintphp.tothisend thereverserleveragestheabove four taint analysis tools to obtain a data dependency graph shown infigure7.itessentiallyshowsthatthevalueof result iscomputedby outthatisagain dependentonallthevariables including input state tbl arrays tran and cur state .
while this isaccurate theresultistoocoarse grained.specifically itshows allthe state tbl arraysarecontributingthevalueof result.
itdoesnotprovideaparticularorderofstatetransitionswhichis critical in revealing attack delivering inputs.
note that one may improvetheanalysistobettersupportarrays i.e.
array sensitive analysis .
however while array sensitive analysis can improve the granularity of the analysis i.e.
identifying data dependencies at anelementlevel itstillprovidesthesameinformationanddoes nothelp identifythereal cpc.
value set analysis.
thereverserusesthreestaticanalysistools for php phpstan psalm and weverca .
the tools 1127hidingcriticalprogramcomponentsviaambiguoustranslation icse may21 pittsburgh pa usa table value set analysis result for key variables.
variable value set tran ... cur state st0 st1 st2 st3 ... ret urtonk drunks 7gz mp3.gs 83s png.gz wxp.zy 3f ubuntu 0f ... result combinations of values of ret implement a data flow analysis technique that can be used to build value setanalysis whichidentifiesasetofpossiblevaluesavariable can have during the execution .
the reverser leverages them to infer potential values that each variable can hold in the ambitr instance shown in figure a .
table shows the result of the value set analysis on each key variable in figure a .
in short the result is not an effective way to expose the genuine cpc due to two reasons.
first while the analysis reveals all possible inputsfor retand result it simply dumps all the outputs of the transitions in ambiguous translator .
to analyze ambiguous translator onehastounderstandtheorderofoutputsgenerated by transitions rather than a set of outputs.
second even for the revealed outputs stated in ambiguous translator as shown in table they are misleading.
those outputs are not the ones that will be generated when an attack delivering input is provided.
for instance theambitrinstanceinfigure6 a candeliveracodesnippet unlink tmp .found.txt when a sequence of inputs spines tea and aegtconfine areprovided.theinputs dynamically transform the outputs annotated on the transitions i.e.
urdonk 7gz mp3.es and wxp.zwl into the code snippets i.e.
unlink tmp .fo and und.txt respectively .
.
.
symbolicexecutiontools.
inthissection thereverseruses symbolic execution tools to reverse engineer the genuine cpc translation logic of ambitr.
specifically four symbolic execution tools thaps phpscan kphp andsymex ar e used.
the tools aim to identify all possible inputs that can lead tonewprogramexecutionpathsorstates.notethatanon array versionof ambitrisused asthesymbolicexecutionsfailtosupport arrayproperly.
state explosion.
none of the symbolic execution tools we used finishes the analysis in a week due to state explosion .
specifically for each state ambiguous translator has multiple transitions to the next states.
hence the number of possible transition pathsgrowsexponentially.forinstance supposetheinputhas x wordsrequiring xstatetransitions therewillbe5xpossibletransition paths leading to state explosion.
kphp crashed after running7hours17minutesduetoinsufficientmemory.further we createasimplifiedversionof ambitrthathasasingletransition witha4 byteinputforeachtransition.thefoursymbolicexecution tools failed to finish the analysis within a week as well.
experiments with enhanced phpscan.
since the vanilla versions of symbolic execution tools failed to analyze a very small instance of ambitr with a single transition we manually optimizephpscan anduseittoanalyzeambitr.specifically we modifyphpscansothatitcan cacheandreusesolvedconstraints and merge and reduce multiple constraints into fewer constraints .
we use a machine with intel i7 8550u .
ghz and gb ramto run this experiment.
we conduct two experiments.
we prepare ambitrinstanceswith differentnumbersoftransitionswhere eachtransitionwilltake3 byteinputand asingletransitionbut withdifferentinputlengths.
different numbers of transitions as the number of transitions increases thenumberofstatestoexploreisincreasedexponentially.
for instance with a single additional transition the number of statesbecomes10timeslarger.wepreparesimplifiedversionsof ambitr that have and transitions where each transition takes characters long input.
we use phpscan to analyze them.
it takesabout3hours 2days and4weekstofinishtheanalysisof ambiguoustranslator with4 and6transitions respectively.note that the input length currently is a root cause of state explosion.
in this example we set it for each transition.
differentinputlengths dynamicoutputtranslationalsocauses the state explosion.
to understand its impact on the number of statesduringthesymbolicexecution wecreateasimplifiedversion of ambitr with input lengths of and .
analyzing a single transitionfortheinputlength6 i.e.
6charactersinput takesabout 15hours30minutes.inputlengths7and8 whicharetypicallengths of inputs in our samples take more than .
days and days to finishthe analysis respectively.
this shows that analyzing even a singletransition is time consuming.
optimization causing under approximation.
symbolic analysis inpractice usesanoptimizationstrategythataimstofind one input that drives the execution to a particular point instead of enumeratingallpossibleinputs.asaresult ev enthereverserreachesa particular state the identified input is unlikely an attack delivering input.forexample infigure a the array fnrepresents a function name.
before it s invoked at line it is constructed at lines after satisfying multiple path conditions at line .
symbolic analysis encodes the pathconditions and gets one solution shown infigure8 b fromtheunderlyingconstraintsolver.theexecution successfully goes into the truebranch and invokes the function f. however itinvokesfunction uniqidinsteadoffunction unlink thatconstitutesthegenuinecpcasshowninfigure8 c .given thisbranchhasbeensuccessfullyexplored thesymbolicanalysis will not try other solutions satisfying the path condition and thus cannotdiscover the genuine cpc.
a source code b resolved fn and f c intended fn and f fn array ... if fn fn fn fn fn fn foreach fn as c f f.chr c f strtolower f f ... variable value fn f uniqid variable value fn f unlink figure symbolic execution exploring a single input.
describingconstraints.
althoughthereversercanuse symbolic analysistomodelthepathpredicatesasconstraintsanddrivethe execution to a particular program location it is challenging to explicitlyencodethe criteriaofthegenuine cpcasconstraints e.g.
constraints that describe the cpc .
in other words he may not even know what exactly he is looking for and how to describe the logicinawaytheunderlyingconstraintsolvercanunderstand.for 1128icse may21 pittsburgh pa usa chijungjung doowonkim anchen weihangwang yunhuizheng kyuhyunglee andyonghwikwon example itischallengingbecauseanyvalidstatementsandfunction names can be potentially cpc.
as a result the satisfiable solutions to the incomplete constraints may lead to a place of interest but willnotreveal the genuine cpc.
empiricalexperimenton the state explosion.
to understand how difficult to analyze ambitr with symbolic execution techniques in detail we run experiments with phpscan which usesthez3solver forconstraintsolving.notethattheoriginal version of phpscan was too inefficient.
it failed to finish the analysis on a very small ambitr sample e.g.
a single transition of 4characterslonginput output in24hours.hence wemanually improvethephpscan sperformancebymodifyingitto cache and reuse already solved constraints and merge and reduce multiple identical constraints into fewer constraints.
we run the enhancedversionofphpscanonamachinewithinteli7 8550u4.
ghzand16 gb ram.
table shows the experiment results.
as shown in the automaton size columns we created different sizes ambiguous translator .
the size is defined as a pair of the length of input charactersandthenumberofthetransition.forinstance 6chars.
trans.
meansa ambiguoustranslator thathasasingletransition between two states and the transition input output is characters long.anexamplecanbeasubstate machineoffigure9between st 0and st 1 input states output urdonk .the const.
columnspresentthenumberofconstraintsthatshouldbeexplored byphpscan.the time columnsshowtherequiredtimeforthe analysis.
note that as the ambiguous translator gets bigger the number of constraints increases exponentially.
in many cases i.e.
the gray cells the experiments did not finish even after days.
forthosecases weestimatetherequiredtimebasedonthenumber ofprocessedconstraintsandremaining alsoestimated constraints.
observe that the enhanced version of phpscan takes more than days to analyze ambiguous translator instances with more than 3transitionsof5charactersinput output whichismuchsmaller thantypical ambiguous translator we generated and used .
figure consists of transitions and its average input outputsizeis9.
whichismuchlargerthanthelargest ambiguous translator presentedintable5 4transitionsof7characterslong input output .notethateveniftheanalysissuccessfullyfinishes the analysis results e.g.
inputs to make all possible transitions do notexpose the genuine cpc.
table phpscan on different sizes of ambitr automatonsize oftimeautomaton size oftime input trans.
const.
input trans.
const.
4chars.
trans.
k .
m chars.
trans.
m .
h chars.
trans.
k .
h chars.
trans.
m .
d chars.
trans.
m .
d 6chars.
trans.
.2b .3d 4chars.
trans.
61m121d6chars.
trans.
12b .7y 5chars.
trans.
k .
h chars.
trans.
m .
d chars.
trans.
.
m .
h 7chars.
trans.
.5b .3d 5chars.
trans.
31m37.8d7chars.
trans.
49b .6y 5chars.
trans.
315m1.4y7chars.
trans.
498b 20y graycellsindicatethattheexperiments did not finish in days.
the times presented forthemare estimated based on the performance measured in the first ten days of execution.
.
.
source code and input analysis.
we aim to show how the reverser would make manual reverse engineering attempts to findst 0 st 1 st 2in states out urdonk in prince out drunks st 3in celestiala out 7gz mp3.es st 4 in fiscaltable out ubuntu 0f in financially out linuxmint in costinfisco out wxp.zwl in contingent out provisional in pigeonhole out discompose in astronomia out w95.vb abc st 5in speeds out ugrind in securityprivacy out responsibility in reality out mage rv st 6in constant value out definite tonk figure9 simplified ambiguous translator usedintheinput analysis.
input output transitions initial inputstates celestials costeffective fiscal yearurdonk 7gz mp3.e wxp.
nl 0ive ubuntu5c3 st 0 g198st 1 g198st 3 g198st 2 g198st 3 first trialrealm celestials costeffective fiscal yearswgmmp4tz mp4.g dekj mlwl ok sklm33azrst 0 g198st 5 g198st 6 g198st 1 g198st 2 second trialprovincecelestials costeffective fiscal yeardr vq iely int boo jevwzw zaak5ylarst 0 g198st 2 g198st 5 g198st 4 g198st 1 third trialstates planetarycosteffective fiscal yearurdonk avpug u ios7ofsmsive ei q iwxust 0 g198st 1 g198st 2 g198st 5 g198st 4 fourth trialstates astronomical cost effective fiscal yearurdonk w95.vb abeal prtv jhpe pivezcizearst 0 g198st 1 g198st 4 g198st 0 g198st 2 figure inputs used during the input analysis.
out the secret input leading to the genuine cpc in ambitr by manuallyinspectingsourcecodeandguessinginputs.weassume the reverser obtained a sample of ambitr and reverse engineered ambiguous translator as shown in figure .
then the reverser executesthe sampleand identifiesinput thatthe sampleretrieves.
the input are shown in the first row of figure initial input .
as expected the input does not lead to the genuine cpc.
to this end thereversertriestoguessinputsleveragingknowledgegained from manual source code inspection.
thereversermodifiesthefirstinputbyguessingapossiblealternative word.
specifically realm is chosen as it is a synonym forstates the original input.
note that all other inputs remain unchanged.however sincethefirstinputleadstoadifferenttransition st 0 st 5 all the subsequent transitions shown in the last column are different from the transitions for the initial input resultinginacompletelydifferentoutput.inthesecondtrial thereverser changes the first input to province which is another synonym forstates.
again the output and the transitions are changed significantly leaving no particular hints for the next trial.
from the thirdtrial thereverserstartstoguessthesecondinput.specifically planetary isused.observethatthefirstoutputwordremainsthe same whileallthesubsequentoutputsandtransitionsarechanged.
while this shows that the first input is related to the first output it is not useful in reverse engineering the attack delivering the input.
thefourthtrialissimilar.changingasinglewordintheinputleads to all subsequent output words and transitions being changed.
1129hidingcriticalprogramcomponentsviaambiguoustranslation icse may21 pittsburgh pa usa discussion generality.
whileweimplementourprototypeinphp theideais general and can be implemented in other programming languages.
to support executable cpcs one needs to implement dynamic codegenerationandexecutionprimitivessuchas eval .script languages such as javascript and python support them by default.
in other programming languages such as c c one may leverage jit compilation techniques .
handlingnon ascii inputsandoutputs.
forbetterreadability we only discuss example cases when inputs and outputs are asciicharacters.however ambitrseamlesslysupportsnon ascii inputsandoutputs.specifically iftheinputisoutofrangeofascii characters ambitrcalculatesthedistanceofprovidedinputand the state transition s input without converting them to ascii code value.
similarly ambitr computes the output directly from the distance values and state transition output without considering theirasciivalues.
threatstovalidity.
theexperimentsinsection4.2areconducted by two individuals who have sufficient background in computer science using state of the art open source tools.
specifically the experimentpresentedinsection4.
.3isconductedbyacomputer science ph.d. student with sufficient program analysis and security background.
the work in section .
.
is done by an expert in software engineering and security holding a ph.d. in computer science .inaddition twoundergraduatestudentsmajoringincomputerscience focusingoncomputer security have repeated the experimentsandreachedthesameconclusions.notethatallparticipantsdidnotknowtheproposedapproachpriortotheexperiment.
theanalysisresultsmaydifferdependingonthetools capability andtheanalysts expertise.
related work hidingprogramcode.
thereexistsalineofworkinobfuscation tohideprogramcodeleveragingopaquepredicates code insertion replacement encryptions hardware primitives and sub tree embedding .
however opaquepredicates can be detected and removed via advanced program analysis techniques .
dummy code snippets inserted into anexistingprogramcanbeidentifiedandremovedviadependency analysissuchastaintanalysis .
anti analysis techniques.
recently presentsasystematic studyofmultiplemethodstohindersymbolicexecutiontechniques.
specifically it inserts additional code to increase the number of feasible paths.ambitr s ambiguous translator not onlyincreases the number of feasible paths but also provides many more additionalchallengessuchasambiguityviadynamicoutputtranslation.
transformsprogramcodesnippetsintoasubabstractsyntax tree ast and injects the tree into the ast of a program.
however dynamic analysis and symbolic analysis tools can detect such injected code.
data obfuscations e.g.
encrypting code sections and decryption them at runtime are easily handled by dynamic analysis .
approaches that require particular hardware support are difficult to be used in real world program as many systemsmaynotsatisfythehardwarerequirement.unlikethem ambitrischallengingtobeanalyzedbystatic symbolic anddynamic analysis tools as shown in section .
it does not require any particularhardware or software.
conclusion protecting critical program components e.g.
patented program logic or sensitive data is an important requirement in software systems.inthis paper we present ambitr anovel technique that hidescriticalprogramcomponentsviaasophisticatedstatemachine basedtranslatorcalled ambiguoustranslator .itimposesfundamentalchallengestostate of the artprogramanalysistechniquesby addinganewdimensionofthechallenge ambiguity.ourevaluation ofthecomparisonwithadiversesetofstate of the artanalysistechniques includingdynamic static andsymbolicexecution shows that ambitris effective in hiding critical program components.