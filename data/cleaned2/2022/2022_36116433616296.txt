semantic debugging martineberlein humboldt universit tzu berlin berlin germany martin.eberlein hu berlin.demariussmytzek cispa helmholtz center for informationsecurity saarbr cken germany marius.smytzek cispa.dedominicsteinh fel cispa helmholtz center for informationsecurity saarbr cken germany dominic.steinhoefel cispa.de larsgrunske humboldt universit tzu berlin berlin germany grunske hu berlin.deandreaszeller cispa helmholtz center for informationsecurity saarbr cken germany zeller cispa.de abstract whydoesmyprogramfail?wepresentanovelandgeneraltechnique to automatically determine failure causes and conditions usinglogicalproperties overinputelements theprogram fails if andonlyif int length len payload holds thatis thegiven length is larger than the payload length.
our avicenna prototype uses modern techniquesfor inferringpropertiesofpassing andfailinginputsandvalidatingandrefininghypothesesbyhaving a constraint solver generate supporting test cases to obtain such diagnoses.
as a result avicenna produces crisp and expressive diagnoses even for complex failure conditions considerably improving over the state of the art with diagnoses close to those of human experts.
ccsconcepts softwareanditsengineering softwaretestinganddebugging theory of computation grammars and context free languages oraclesand decision trees active learning.
keywords program behavior debugging behaviorexplanation testing acm reference format martineberlein mariussmytzek dominicsteinh fel larsgrunske andandreaszeller.
.semanticdebugging.in proceedingsofthe31stacmjoint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa 12pages.
.
introduction when software fails one needs to debugit find the error in the code that causes the failure and fix it.
before digging into the code however one must first identify the circumstances under which the failure occurs.
such circumstances give important hints on esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
0x1 length payload padding heartbeat response 0x2 length payload padding length int payload u1d716 byte payload padding u1d716 byte padding figure syntax of tlsheartbeatexchanges thefailurecause andthushowandwheretofixthebug provide insights into how severe the problem is and help producing exact fixes preventing patches that only fixapart of the problem.
let us illustrate the role offailure circumstancesreferringtothe well known heartbleed problem.inversionsbetween2012and2014 tlsserverswerevulnerabletotheheartbleedattack inwhichan attackercouldextractinternalmemorycontentsfromaserver.the attackwasbasedonthe tlsheartbeat protocol inwhichaclient checks whether a server is still alive by sending it some payload stringandexpectingthe same payloadto be returned.
the elementsofaheartbeat clientrequest and serverresponse are shown in figure .
the client sends a 0x1byte followed by the length of the payload and then the payload itself extra padding bytes are used toextendthe request tothe data frame length.
the server responds with a 0x2byte followed by the same payload indicatingthat it has receivedthe request.
theheartbleed attack now consisted of having the declared payloadlengthdiffer from the actualpayloadlength.aftersendinga length valueof say andafive characterpayloadof hello theserverwouldreplywith hello butfollowedbyanother3 995bytesthatwouldhappentoresideinitsmemorybehind the payload string.
such over read bytes can contain arbitrary information about the server state including sensitive information such as unencryptedpasswords andcertificates.
heartbleed wasfoundby fuzzing tlsserversin2014 .indeed simplyfeedingthegrammarfrom figure1intoanygrammar based fuzzer e.g.
immediately produces a request where length andthe length of the payload differ say attack request 0x1 0x0123 hello 0x0 ... sending attack request to a server with a memory sanitizer enabled would instantly reveal the invalid memory access.
the vulnerability has been present since and administrators all overthe world rushedtopatch andupdatethe serversoftware.
thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa martineberlein marius smytzek dominic steinh fel larsgrunske andandreas zeller failing program inputsin2determine relevant input elementslearn failure related patternsfailure circumstancesnegate constraintsgenerate new inputs to refine theory input grammar pattern catalogue machine learningisla z3 smt solveravicenna in1 out figure how avicenna works.
starting with an input grammar in1 and a failing input in2 avicenna automatically determines the failure circumstances.
then avicenna iteratively refines its failure hypothesis through repeated experiments.
to learn the failure inducinginputconstraints avicenna leverages bothgenerativemodelsand predictivemodelsto satisfy constraints over grammar elements and to detect relations of input elements respectively.
ultimately avicenna obtains a theory ofthefailure circumstances out that explains andpredicts whenthebehavior inquestionoccurs.
to fix the problem we need to know the exact circumstances under which the problem occurs in our case something along the lines of the given payload length is different from the actual payload length such that we can characterize locate and fixthefailure.recently twonovelapproachesforobtainingsuch circumstances automatically have been presented alhazen by kampmann et al.
uses repeated experimentstodeterminewhetherspecific properties ofinputelementscorrelatewithfailure.thesetofpropertiesisfixed to existence length maximal code point and numeric interpretation and alhazen candoagoodjobifaconjunction of individual properties causes a failure.
alhazen however does not check for relationships between properties such as length and the length of payload .
the failure circumstances produced by alhazen therefore only relate to the payload length inisolation len parenleftbig payload parenrightbig whileequation the failure occurs if the payload has less than characters is a correct necessary condition if payload is longer the data frame becomes invalid it is notsufficient forthefailuretooccur.nordoesitgivehints onhowto fixthe failure.
islearndescribed by steinh fel and zeller learnssemanticproperties overinputelementsthatholdforallinputs observed.forthispurpose itchecksinputsfor patternsof these properties that match all observed inputs.
in our example the pattern int parenleftbig parenrightbig len parenleftbig parenrightbig instantiatedwith length and payload applies toallfailingheartbleed inputs and would be returned byislearn as acommon inputproperty int parenleftbig length parenrightbig len parenleftbig payload parenrightbig equation precisely captures the failure circumstances.
however itisburiedinhundreds1ofadditional coincidentalinstantiationsthat alsoholdfor thegivenfailinginputs such aslen parenleftbig padding parenrightbig len parenleftbig payload parenrightbigorlen parenleftbig padding parenrightbig int parenleftbig length parenrightbig.
in contrast to alhazen islearn has no mechanismto refine diagnosesthroughexperiments.
inthispaper wepresent avicenna2 aprecise general andextensibleapproach to determine failure circumstances automatically figure2 .avicenna buildsontheideathatonecandecomposethe inputintoindividualelementsusingagrammarandthatproperties oftheseinputelementscanpreciselycapturefailurecircumstances.
in addition avicenna makes three novel contributions extending the state ofthe art quickly determining relevant elements.
to narrow down the search space inthe potentially large set of inputelements avicenna usesshapley values a mechanism used to explain ai decisions to determine which input elements and derivedpropertiescontributemosttotheoccurrenceoffailures.
only these are considered for deriving failure hypotheses allowing for efficient use even of complex patterns.
in our example avicenna quickly determines that length andlen parenleftbig payload parenrightbigcontribute most to failure occurrence.
payload byitselfcontributeslittle otherthanforitslength padding notatall.tothebestofourknowledge avicenna 1450in ourexperiments see table .
2ibns n a latinizedas avicenna wasoneofthemostsignificantphysicians astronomers philosophers and writers of the islamic golden age.
he was one of the earliest proponents of the scientific method of experimentation in his book of healing kit ab al shif a on science and philosophy he explained that the ideal situation is when one finds that a relation holds between the terms which would allowfor absolute universalcertainty.
439semanticdebugging esec fse december3 san francisco ca usa is the first debugging approach to determine the relevance of inputelementsforthefailureusingtechniquesfromexplainableai.
reasoningoverpassingandfailingruns.
avicenna makesuse ofislearntoinferfailure inducingpatterns.
avicenna however makesuse ofboth passingandfailinginputs and thus learns input properties that hold for failing runs but notfor passing runs.
hence coincidental input properties that hold forallinputs are eliminated in the first place narrowing downthesetofcandidatepropertiestowardsthoserelated to failures including equation .
to the best of our knowledge avicenna is the first debugging approach to detect arbitraryfailure related patternsin inputs.
logical refinement.
tofurtherassessdiagnosiscandidates avicennauses the alhazen approach to generate additional testcases.
but while the alhazen generatoris limited to its four hard coded input properties avicenna makes use of the islaconstraint language and solver allowing to expressandsolveevencomplexconditionsoverinputelements.
this way avicenna can generate hundreds of test inputs satisfying the candidate diagnoses learned by islearn.
only equation reliablyproducesinputsthatcausethefailure andisthereforeretained theother coincidental properties donot andare thus eliminated.
tothebestofourknowledge avicenna isthefirstdebugging approach to determine diagnoses by logical reasoning and experimentation over input elements.
we therefore call avicenna asemantic debugging approach in contrast to lexical syntactical approacheslikeinputreduction andml based approacheslike alhazen .
theheartbleed failurecircumstanceasisolatedby avicenna and validatedbyhundredsoftest inputsthus reads int parenleftbig length parenrightbig len parenleftbig payload parenrightbig thisfailurecircumstanceis100 precise the heartbleed failure as amemoryoverread occursifandonlyifthisconditionismet.it couldalsobeusedbyan inputsanitizer topreciselypredictandpreventheartbleed attacks.
this is in contrast to alhazen s diagnosis inequation whichcannotseparateattacksfromlegitimaterequests and the islearn diagnosis embedding the correct property inamyriad ofcoincidental properties.
with this singlefailure condition andthe test cases avicenna providesimportanthints onthe nature ofthe problem makessure that any fixwillbe well testedandvalidated suppliesacondition for inputcheckers to detectattacks ensures agreatstartfor locating andfixing the fault.
to achieve all this avicenna leverages recent advances in input specification inputgeneration andinputinference notably the isla language and input generator which generates inputs satisfying constraints over grammar elements and the islearn inputinvariantlearner whichdetectsislapropertiesingiven inputs.butwhileislaandislearnweredesignedtoproducesemanticallyvalidinputs avicenna showsthattheyalsoenablepowerful automated debugging approaches.
in our evaluation avicenna determines crisp failure conditions that are much shorter yet moreprecise than alhazen or islearn closely matching diagnoses collected from human experts.
avicenna and all experimental data is available as open source section .
backgroundand related work automateddebugging collectivelyreferstolocalization understanding explaining and fixing a faulty system.
automatedtoolsthatguidedeveloperstowardcorrectingerroneous program behavior can significantly reduce the cost of software developmentandimprove the overallquality of the software.
.
programslicing oneofthefirstseminalautomateddebuggingtechniquesis program slicing introducedbyweiser .asliceisthesetofprogramstatementsthatcanbeinfluencedfromagivenstatement forwardslice orthatmayhaveinfluencedaspecificstatement backwardslice thenullvalueinline20comesfromline18 whichexecuted becauseoftheconditioninline10.
indebugging abackwardslice from a failing statement helps narrow down possible causes in the program code also by eliminating those parts that could nothave contributedto thefailure.
program slices however explainfailures intermsofprogramcode notas input circumstancesthatexist independently ofstatements andvariables.
.
statistical debugging statistical debugging techniques identifyexecution featuresthatcorrelatewithfailure suchasindividualcodelinesmostly executed in failing runs lines and are executed only in failingruns.
the resulting statistical models thusexposerelationshipsbetweenspecificprogrambehaviorandeventualsuccessor failure.however theremaybemultipleexecutionfeaturescorrelating with failures and then the developer must determine which of these may be in error.
also to prevent overfitting statistical debuggingmayneed comprehensivesets ofpassingandfailingruns whichmaynot exist inpractice.
.
deltadebugging automated debugging techniques can be made much more precise if they can generateadditional inputs to narrow down possible failure causes.
one seminal example of such experimental techniques is delta debugging a strategy to effectively reduce failure inducing inputs the failing input can be reduced to the two characters .
and x .
delta debugging assumes an automated testthat determines whether a reduced input still produces the failureandwhoseoutcomethusguidesthereductionprocess.in contrast to the above techniques its result does not refer to the code but instead areducedinputthat stillreproduces the failure.
.
leveraginginput syntax knowing the input structure can make experimental debugging techniques far more efficient and also provide better diagnoses.
to describe input languages context free grammars cfgs are themostpopularformalism well studiedintheoreticalcomputer science compilerdesign andlinguistics .usinginputgrammars 440esec fse december3 san francisco ca usa martineberlein marius smytzek dominic steinh fel larsgrunske andandreas zeller onecanextendreductionto structured inputswithperses creduce hdd andhddr .allthesearesignificantly faster andoften more precise thanlexical delta debugging.
while the above approaches still reduce a given failing input into ashorterfailing input the ddsetalgorithm aimsto find a patternthatcharacterizesthefailure.inthepattern nonterminals describe sequences that can take any value as defined by the grammar thusabstractingoverspecificcontents thefailureoccursfor any inputofthe form expr expr .
.
learning relevant input properties alhazen requires a setoflabeledinputsto determinethe circumstances of a program s failure automatically.
it uses a grammar to parse the inputsinto individual syntactical features such as the length of an element or the presence of specific elements.
to form the first debugging hypotheses alhazen needs at least one initial failing input.
this hypothesis is shaped by first deconstructing the initial inputs into features with the help of the grammar and utilizingthesefeaturestolearna decisiontree.
next alhazen usesthe treetolearn associations betweentheinputfeaturesandprogram failure.
then alhazen attempts to refine the first hypothesis in aniterative process the decision tree representing the current explanatorytheory andthegrammarareusedtoconstructnew inputs toprobe theprogram.thesenew samplescanthen beconsideredto refine the hypothesisinthe decision tree.
eventually alhazen presents its final theory relating input featureswith thefaulty program behavior the failure occurswhenever thelength of the command line elementexceeds264 .
this way alhazen extends the state of the art beyond ddset not only generalizingthesyntacticpartsoftheinputbutalsodetermining whichinputfeatures contributeto the failure.
.
dynamicinvariants duringdebugging havingaspecificationofthecorrectbehaviorof theprogramisbeneficial.ifsuchaspecificationis formal automated debuggingtechniquescanleverageittoguidetheprocess.formally specified pre andpostconditions as well as data invariants can significantlyreducedebuggingeffort ifoneknows forinstance thatduringanexecution thepreconditionofsomefunctionwas satisfied butnotitspostcondition thenwecannarrowdownthe searchto the executionofsaid function.
afterall howcanweobtainsuchspecifications?oneseminal workinspecificationminingisthe daikondynamicinvariantdetector whichtakesasetof passing runsandforallfunction arguments and returns determines from a pattern library whether there are specific properties that hold for these arguments and returns.
if a function y sqrt x for instance is always called with positive values of x it can deduce the invariants x y and even x y y. today s program synthesis techniques extendover daikonbysynthesizingcomplex formulas thatcapture relationships between inputandoutputvariables.
however onedownsideofallsuchdynamictechniquesisthat theminedspecificationsmay overfittothegivenruns.assuming thatx 0is a valid argument for sqrt x for instance the above invariants overspecialize.
only if daikonand the like see an invocation sqrt will we get the correct invariants x 0andy .
one may attempt to mitigate this problem by generating test inputs.still thenwerunintotheproblemofpotentiallyviolating the very preconditions we want to mine in the first place from aninvocationof sqrt daikonandthelikemayhavelotsof undefinedbehaviorfrom whichto learn.
.
input invariants recently theconceptsofspecifyingandlearninginvariantswere extended to the systemlevel which allows expressing pre and postconditions over system inputs.
the isla language combinesacontext freegrammarwith constraints aspredicatesover nonterminals.
given the grammar in figure for instance the islaconstraint int parenleftbig length parenrightbig len parenleftbig payload parenrightbig expressesthatthe length fieldshouldholdthelengthofthe payload field.thisway isla leverages the simplicity of cfgs while significantly extending theirexpressiveness.
theislatoolallowsto producevalidinputsthatsatisfythegiven constraints using an smt solver .
it can also checkgiven inputs againstanislaspecification mutateinputswhilemaintainingvalidity andrepairinputs to make them valid.
the constraint language allowsaddressinggrammarelementswithuniversalandexistential quantifiers relatingtheir positionswithstructuralpredicates and constrainingtheirvaluesusingsmt libformulas makingislaa robust systemfor test generationandblack box fuzzing.
.
learning input constraints alongwithisla theauthors also describe islearn apatternbasedapproachforminingconstraintsfromexistinginputs.islearn follows the daikonapproach using a configurable catalog of common constraint patterns.
it instantiates these over all inputs and inputelements retainingthosecandidatesthatholdforallgiven inputs in allinputsseen len parenleftbig payload parenrightbig 16357holds.
in contrast to daikonand like dynamic specification miners however islearncanmakeuseof generatedinputs inthefirstplace leveragingislaasaproducer.hence evengivenonlyapartialspecification say only the grammar one can first run isla to produce amyriadofinputsandthenhaveislearninfertheconstraintsonly from the validinputs that are accepted by the program under test.
this pipeline of test generation and specification mining works at the system level because programs are expectedto explicitly reject invalid inputs which specification mining can then ignore an assumption that does not hold at the unit level.
so far neither isla norislearn has been usedfor debuggingpurposes.
approach inthissection wepresent avicenna ourprecise general andextensibleapproach to determine failure circumstances automatically.
thekeyideaistoleveragebothgenerativeandpredictivemodelsto satisfyconstraints overgrammar elementsand todetectarbitrary subject to the catalog patterns relations of input elements.
for this avicenna makesuse of fourbuilding blocks isla sspecification language allowsavicenna to express even complex failure circumstances as predicates over input elements.
the islearn toolallowsavicenna to learn input properties that are common acrossallfailinginputs.
441semanticdebugging esec fse december3 san francisco ca usa the isla toolallowsavicenna toproducevalid inputs notably inputs that fulfillpotential failure inducing properties thus allowing for systematic experimentation.
finally avicenna follows alhazen in using a feedback loop to narrow down failure causes with systematic experiments.
thecombinationoflearningandgeneratingtechniquesenables avicennatoproducea precisepredicatethatpinpointsthecircumstances underwhichaprogramfails.
avicenna starts with a program a grammar for the input format and a set of initial inputs figure u1d456 u1d45b1 u1d456 u1d45b2 .
to locate and determine the root causes of a program s crash avicenna requires at least one failinginput.avicenna will automatically generate additionalfailinginputstostrengthenitshypothesizeddiagnosis.the grammarallowsustoassociatesyntacticalfeaturesandsemantic propertieswiththe observedprogram behavior.
to detect arbitrary failure related explanations of the failure circumstances we proceedinfoursteps wedeterminethemostrelevantinputelementsoftheprogram s failure section .
.
we instantiate patterns that capture arbitrary relations of the observedfailure section .
.
weproducenewinputstorefineandstrengthenourhypothesis section .
and we repeat this procedure until a stopping criterion is met section .
.
.
determiningrelevant input properties in contrast to approaches like alhazen avicenna checks passing andfailinginputsfor patternsoverinputelementsandproperties.
we use these patterns to capture arbitrary relations between input elements and the circumstance of the program s failure.
avicenna retains those patterns that apply to all or at least the majority of failinginputs yetnottothepassinginputs andthusmakesa diagnosis candidate.
however instantiating dozens of patterns with hundreds of input elements and derived values means checking manycombinations.thus tonarrowthesearchspaceandthenumberofpossiblepatternmatches avicenna automaticallyfocuses onlyonthefailure inducinginputs essentialcharacteristics.our toolachievesthisbytrainingamachine learningmodelandexplaining its decisions with shapley values .
this mechanism allows us to determine which input elements and derived properties contribute most to a machine learning model s prediction i.e.
the failure of a program.
only those that contribute most are considered during patterninstantiation allowingfortheefficientuseevenofcomplex patterns figure activity1 .
avicenna starts bydecomposing eachinput into its syntactical constituentsbasedonthegrammar.theresultingfeaturevectors andtheinformationiftheinputisfailure inducingarethenusedto trainamachinelearningmodel.themodeleventuallyassociates the program s failure with the occurrence of specific derivation sequences particularly non terminals .
to determine the features thatcontribute mostto thefailure in question avicenna employs shap a game theoretic approach explaining the output of a machinelearningmodelbasedonshapleyvaluesfromcoalitional game theory.
the goal of shapis to interpret the model s outcomebycomputingthecontributionofeachfeaturetothefinalprediction.thefinal shap valueforafeaturerepresentshowmuchthe model spredictionchangeswhenweobservethatfeature.using these values as an indicatorof non terminalsthat contribute most totheoccurrenceofafailureallowsustoexcludeirrelevantcharacteristics.thisproceduregivesusatremendousadvantageover state of the artapproacheslike islearn.
returning to our example avicenna can quickly determine that length and payload contributemosttothefailureoccurrence.
payload int and byte bythemselvescontributelittle other thanfor its length padding not at all.
.
learning failureconstraintswith pattern matching avicenna learns failure related constraints via pattern matching.
steinh fel et al.
showed that input invariants can be mined from existing inputs.
building upon their original pattern based learnerislearn we derivecomplex semanticconstraints thatcapture the observed failure.
we reduce the computational complexity of the pattern matcher by only considering the most relevant input elements for the instantiation of pattern candidates such as length and payload .
figure2showsthatthelearningandcandidategenerationphase activity2 instantiatesselectedpatternsfromaprovided pattern catalogbasedonthegiveninitialinputs.inthefirststep thepatternmatcher instantiates non terminal placeholdersin quantifiers and matchesexpressionplaceholderarguments e.g.
len num u1d456 with length or payload .thispatternstatesthatthefailureoccurs whenever the length of the matched non terminal is larger thansomenumber u1d456.thecandidatesaftereachinstantiationphase are approximatelyfilteredusing an islearn checkerforschematic formulas.
whenever most failure inducing inputs satisfy an instantiatedpattern avicenna retains that pattern.
letusreconsiderourinitial heartbleed example.using avicenna afirstfailurediagnosisbasedontheinitialinputsmaybesimilar to the following simpleconstraint len parenleftbig payload parenrightbig thisconstraintstatesthatwheneverthe payload ofarequestis largerthan 6characters theprogramfailureoccurs.atthisearly stage the pattern int parenleftbig length parenrightbig len parenleftbig payload parenrightbigand the above constraintareequivalentregardingtheircapabilitiestopartition theinitialinputs into passing and failing ones.
to improve this initial diagnosis and learn the best failure related constraint we needto conduct more experiments with more inputs.
.3validatinghypothesesthroughexperiments the failure related constraints computed initially may be far from perfect.becauseofthelimitedsetofinitialinputs avicenna can onlymakebasicobservations oftenresultinginextremeoverfitting to the given inputs.
to refine or refute the initial candidates we generatenewinputs tostrengthenthelearnedconstraints.
avicenna generates new inputs according to the mostpromisingextracted failurehypotheses i.e.
constraintsthatbestseparatefailingfrom passing inputs.
using the extracted hypotheses allows us to efficiently guide the generation process and focus on the relevant 442esec fse december3 san francisco ca usa martineberlein marius smytzek dominic steinh fel larsgrunske andandreas zeller aspects of the failing inputs.
avicenna is based on the scientific method it tries to refutethe initial diagnosis hypothesis by actively generating new inputs that satisfy the constraints but do not result inthe program s failure.
to this end avicenna additionally negatesthe candidate constraints to i explore the boundaries ofthe inputelements ii expand the set of relevant input properties and iii refine the surroundings of the input elements.
for instance if both the presence andtheabsenceoftheinputelement padding resultinthefailure of the program then the relevance of padding is diminished figure activity .
thus we generate additional inputs bothfrom theoriginalandnegatedconstraintsandassignthemtothecategoriesfailingandpassingbasedontheprogram sbehaviorunder test.
note that we do not refine the current set of constraints by direct manipulations.
instead we refine our data set of passing and failinginputs whichallowsusto i concretizethesetofrelevant inputelementsand ii infermorepreciseinstantiationsinthenext inference step.
to efficiently produce new inputs satisfying constraints we use the recently introduced isla fuzzer figure activity .
isla not only allows us to producenew inputs but also to validatecomplex constraints.
inourrunningexample westrengthenourinitial hypothesisby deriving andaddingthe following negatedconstraint len parenleftbig payload parenrightbig hence withthehelpofisla avicenna willnowproduceinputs thatwillhaveapayloadofeither lessoreuqal than6 forpassing inputs or morethan6 forfailinginputs characters.however as the length of the payload is only failure inducing in combination with thestated length value avicenna quicklygenerates inputs that donot satisfy the initialfailingdiagnosis.
.
refining hypotheses in afeedbackloop torefinetheinitialdiagnosis failure relatedconstraints werepeat the procedure of determining the most relevant input elements learning constraints and generating additional inputs.
by learning andgeneratinginputsalternately wecan infer verify andgeneralize relations between input elements and properties.
most notably by also considering the negation of the constraints we generate adversarialinputs tofalsifyourcandidateconstraintspossibly.after only three iterations of the feedback loop avicenna derives the correctfailure constraintfor the heartbleed example int parenleftbig length parenrightbig len parenleftbig payload parenrightbig in general the ideal instantiation will always be among the possible candidate instantiations from the beginning if it could be derived from avicenna s patterns .
it will receive a significantly betterrankingwiththe generationofadditionaltest inputs.
implementation avicenna withthedeterminationoftherelevantinputelements andthefeedbackloop isimplementedinpython.we usethelatest versionsofislaandislearntogenerateandinstantiatenewfailing patterns.inaddition toreducethecomputationalcomplexityofthe patternmatcher wepassislearnasetofnon terminalsthatshould not beconsideredduringthepattern instantiation.we obtainthistable subjectsand grammars subject grammar subject grammar heartbleed figure pysnooper.
custom calculator calculator pysnooper.
custom genson json cookiecutter.
custom find.07b941b1 find cookiecutter.
custom find.091557f6 find cookiecutter.
custom find.dbcb10e9 find fastapi.
custom find.ff248a20 find fastapi.
custom grep.3220317a grep fastapi.
custom grep.3c3bdace grep fastapi.
custom grep.5fa8c7c9 grep youtube dl.
custom grep.7aa698d3 grep youtube dl.
custom grep.c96b0f2c grep youtube dl.
custom exclusionsetbydeterminingthemostrelevantinputelementsby trainingagradientboostingtreebasedonthexgboost extreme gradient boosting framework an optimized distributed gradient boosting library.
then we use the shaplibrary providing a fast implementation supporting xgboost to extract the failureinducing input elements.
we consider both the presence and the absenceofinputelementsasnecessary.furthermore weusethe grammar based fuzzer from the fuzzing book .avicenna and allexperimental data isavailable as open source section .
evaluation let us assess how well avicenna fares both in comparison to humandiagnoses aswellasincomparisontothestateoftheart.
we addressthe following research questions rq1 howdoes avicenna compareagainstdiagnosesprovidedby humanexperts?
rq2 howdoes avicenna compareagainst alhazen intermsof diagnosis complexity andaccuracy?
rq3 how does avicenna compare against islearnin terms of diagnosis complexity?
.
evaluationsetup .
.
evaluation subjects.
to examine the effectiveness of avicenna we evaluate our tool s diagnoses on a set of test subjects similartothoseinitiallycoveredbykampmannetal.with alhazen.
intotal weevaluate 24bugsfrom ninedifferentprojectsofdifferent complexity namelythe heartbeat protocol acustom calculator the gensonjson parser the command line utils grepandfindfrom dbgbench andpysnooper cookiecutter fastapi andyoutube dl selected from the tests4py benchmark .
tests4py leverages the bugs present in bugsinpy and extends themwiththe capability to verifyinputsonasystemlevel which makesitidealforevaluating avicenna .moreover eachsubjectof tests4py comes with a grammar specifying the input format we can leverage.
if a subject of tests4py does not provide a cli for directlyaccessingtheprogram tests4pyalreadyprovidesaharness asaccessforexecution.
dbgbenchprovidesthemeanstocompile andexecuteoldversionsofgrepandfindanddocumentthebugs in those old versions.
for the calculator grep andfind we used the 443semanticdebugging esec fse december3 san francisco ca usa grammar provided by alhazen.
forgenson we adapted the grammar found in the github repository for antlr grammars .
the handwritten grammars for grepandfinddescribe complete shellcommandsconsisting ofan input alistofenvironmentvariables andaninvocationoftherespectivecommandlineutility.the subjects bugs andusedgrammarare describedin table1.
.
.
datasets.
toanswer rq2 similartotheevaluationof alhazen we require sets of test inputs to evaluate the prediction capabilitiesof avicenna sandalhazen sfailurediagnosis.togeneratethesevalidationinputs weusethek pathcoverageguided grammar aware mutation fuzzer provided by islearn.
with the fuzzer we automatically generate unique validation inputs for eachsubject 50passingand50failure inducingtestcases.however asthefailureconditionsforthe findbugsareincrediblynarrow we could not obtain failing inputs within one hour.
thus we reduced the validation set for the findsubjects to passing and failing inputs.
we measure the respective predictive power of the failure diagnosesbasedonthesevalidation inputs.
in contrast to the alhazen evaluation we evaluate avicenna s performancewithaninitialinputcorpusoftwoinputsonly one bug triggering and onepassinginput.
this decision follows the idea that we want to know if our extended learning process and thefeedbackloopcangeneratemeaningfuladditionalinputsand thus improve its accuracy and precision.
the two initial inputs onepassingand onebug triggering were provided by alhazen dbgbench andtests4py.
.
.
researchprotocol.
toanswertheresearchquestions weproceededasfollows i first we started avicenna foreach subject with the respective grammarand the twoprovided initialinputs.
ii then we performed at most iterations of the learning and refinement process.
we stopped if we did not generate new inputs inaniterationor avicenna couldnotfinishthe20iterationswithin onehour.
for rq1 weanalyzed avicenna sfailurediagnosesfor heartbleed and the dbgbench subjects.
we compare the individual failureconditionsofeachdiagnosistothebugreportprovidedby experts.weexcludedthecalculator genson andtests4pysubjects as we do not have an expert diagnosis for these bugs.
all of avicenna sdiagnoses alongwithdetailsoftherespectivefailures are available as part ofthe avicenna experimental data section .
toanswer rq2 wecomparedthepredictivepowerof avicenna s diagnosesto alhazen andproceededasfollows i first wegenerated the evaluation data sets with the mutation fuzzer.
ii then weranavicenna andalhazen withthesamestartingconditions i.e.
with the same grammar and initial inputs .
iii finally we measuretheperformanceofthefinaldiagnosisforeachsubjectand approach.
withthe same starting conditions rerunning avicenna andalhazen did not change their diagnoses.
finally to answer rq3 weassessed avicenna sfeedbackloopanditsperformance effectsoverislearn.wecomparethenumberofreturnedfailure diagnosesto answer this researchquestion.
.
rq1 avicennavs.
human diagnoses let us start with our first research question pitching avicenna against human experts.
for a substantial subset of bugs in our evaluation setup we have diagnoses by human experts availablecollected in the dbgbench study in which practitioners would debug real world bug reports for the findandgreputilities.
as part of their task these practitionerswere asked to determine the exact circumstances under which the bug would occur as part of a simplified bug report the exact problem that avicenna is set to address.inourevaluation wecouldthuscomparetheexpertbug reportswiththe avicenna diagnosesandassesswhether avicenna wouldproducetoomuch toolittle orevenmisleadinginformation.
table2relatesthe avicenna diagnoses usingislasyntax against thesummariesprovidedbyhumanexperts.fragmentsmarkedin boldrelate to concepts referred to in both the avicenna diagnoses andtheexpertdiagnosis matchingconceptsareshowninthesame colorandlinkedwithaline.fragmentsmarkedwith italicsrelate to unmatched concepts and thus indicate failure conditions missed byavicenna .
evenwithoutcompleteknowledgeofisla thefactthatalmostall conceptsofexpert diagnosesexist inthe avicenna diagnosesand viceversaisstriking.althoughindependentlyobtained thenatural language diagnoses read as translations of the formal avicenna diagnoses whereasthe avicenna diagnosesreadasaformalization ofthenaturallanguagediagnoses.inalmostallcases thesemantics are identical.
failurecircumstancesas produced by avicenna are verycloseto thosedetermined byhumanexperts.
avicenna took about minutes on a regular pc to produce a diagnosis for findandgrep this is slightly slower than it took thedbgbench participants to debug things .
however in the dbgbench study only of patches were correct in the sense that they addressed all failure circumstances.
we conjecture that if developers are aware of the exact bug circumstances as avicenna provides them and able to test their fixes automatically for instance byhavingislaproducetest casesfrom thediagnoses the qualityoffixes mayvery muchincrease.
.
rq2 avicennavs.
alhazen let us now compare avicenna against state of the art tools.
alhazen pioneered the concept of automatically determining failure circumstances leveraging and producing decision trees that expressfailureconditions.wefirstcomparethe complexity ofdiagnosesproducedby avicenna andalhazen respectively.from table we already have seen that a typical avicenna diagnosis contains conditions each referring to one property of an input element the average number of conditions across our entire set of subjects is .
which is not the case for alhazen diagnoses though.
as listed in the average alhazen decision tree has19.
nodes each one expressing a condition over input elements.we therefore conjecturethatthe avicenna diagnoses are muchcrisper.
avicenna diagnoses are only 8as long as alhazen diagnoses.
however a shorter and thus more general failure condition mightalsoresultinless accuracy possiblyflagginginputsasfailureinducingthatarenot.we therefore evaluatetheaccuracyof avicennavs.alhazen.foreachsubject testinput andtool weassess whetherthetoolflagstheinputasfailure inducingandhowthat 444esec fse december3 san francisco ca usa martineberlein marius smytzek dominic steinh fel larsgrunske andandreas zeller table avicenna diagnosesvs.humandiagnoses bug avicenna diagnosis using islasyntax expertbug description heartbleed str.to.int length str.len payload attackers can send heartbeat requests with the value of the length field greater than the actual length of the payload grep.7aa698d3exists utf8 in lc all utf8 utf and exists ignore case in general options ignore case i if grepconducts a case insensitive search i on an input that contains multibyte characters andthe locale is utf8 thengrep printsamatchofincorrect length.
grep.5fa8c7c9exists patterns in command patterns and exists utf8 in lc all inside utf8 lc all and exists fixed string in cmd 1 inside fixed string cmd 1 searching with grep ffor anempty string in amultibyte locals wouldfreeze grep.
note fixed string expandsto fand fixed strings grep.c96b0f2cexists regex in patterns regex and exists ignore case in matching control inside ignore case matching control or exists line no in output line prefix control inside line no output line prefix control options iand nwillnotworkwhenappliedtoan empty line note ignore case expandsto iand ignore case line no expandsto nand line number grep.3c3bdaceexists extended regex in matcher selection inside extended regex matcher selection and exists repetition in patterns repetition coredumpwithpattern note extended regex expands to eand extended regexp grep.3220317aexists bracket expr in first expression inside bracket expr first expression and exists utf characters in bracket char inside utf characters bracket char segmentationfault on multibyte character classes note bracket expr expands to in a regular expression utf characters occur within bracket char i.e.
the characterswithin bracket expr find.07b941b1exists match opts in find expression match opts regex and exists character expr no minus in first expression character expr no minus .
find segfaults when using regex for instance .
find regex .
find.091557f6exists file properties in find expression file properties type f and exists directory name in starting dir list inside directory name starting dir list assertion failure on symbolic link loop let s say we accidentally create a symlink loop mkdir tmp cd tmp and ln s a b ln s b a andusefindtofindfilesandfollow symlinksinsidethe tmp folder .. find l type f find.dbcb10e9exists digit in last modified inside digit last modified and exists numeric arg in find command inside numeric arg find command mtime produces segmentation fault e.g.
.
find mtime2 note last modified expandsto mtime find.ff248a20exists ln file in ln ln file al ln s .
link and exists find expression or empty in command find expression or empty follow infiniteloopwith follow e.g.
mkdir testingfindagain ln s .
testingfindagain symlink .
find testingfindagain follow for details onall dbgbench bugs includingexpertbugdescriptions visit .
for the heartbleeddescription see .
445semanticdebugging esec fse december3 san francisco ca usa table3 precision andrecallofthe produced failure conditions avicenna vs.alhazen subjectavicenna alhazen precision recall precision recall heartbleed calculator genson find.07b941b1 find.091557f6 find.dbcb10e9 find.ff248a20 grep.3220317a grep.3c3bdace grep.5fa8c7c9 grep.7aa698d3 grep.c96b0f2c pysnooper.
pysnooper.
cookiecutter.
cookiecutter.
cookiecutter.
fastapi.
fastapi.
fastapi.
fastapi.
youtube dl.
youtube dl.
youtube dl.
average classification compares against the ground truth given by the respectiveprogramandoracle.ahigh precision meansthatoutputs flagged as failure inducing actually induce failures a high recall meansthatinputsthatinducefailuresareidentifiedassuch.our resultsaredetailedin table3.weseethatdespitehavingshorter and more general failure conditions the precision of avicenna is at leastonparwiththe state of the art alhazen .
theaverage precision of avicenna diagnoses is onparwith alhazen diagnoses.
inadebuggingcontext however precisionisnotthatimportant as false positives can easily be identified by them not causing a failure.
of much larger interest are the false negatives as they indicate that the diagnosis may misssome failure conditions which in turnmayleadtoincompletefixes.thisisactuallywhere avicenna surpasses alhazen in22ofthe24subjects leveragingitscapability to identifymore generalfailure circumstances.
theaverage recall of avicenna diagnoses surpasses therecall of alhazen diagnoses.
generallyspeaking the alhazen diagnosesfollowtheoriginal failure inducinginputmuchcloserthanthemoregeneral avicenna diagnoses whichis a reasonableapproach.
diagnosesofprevious techniqueslikesyntacticinputreductionalsostayclosetotheoriginalfailinginput stillprovidingbenefitsforprogrammers.however avicenna does a better job in exploring the surroundings of the originalfailingtestcase thusinferringgeneralizationsthatstateof the artapproacheslike alhazen miss.withthisinmind wesee thatalhazen archives slightly better results for find.dbcb10e9 and avicenna alhazengrep.7aa698d3 grep.7aa698d3 figure3 avicenna vs.alhazen diagnosesfor grep.7aa698d3 .
find.ff248a20 .wearguethatthisisduetotheirextremelynarrow failing conditions.
consequently the validation set is similar to the original failing input thus overspecializing to the failure inducing inputs is beneficial for alhazen s prediction even though the diagnoses are not as general as those producedby avicenna .
this property is even further highlighted if we take a closer look at for instance the diagnoses for grep.7aa698d3 .
we show the differences bytranslatingthedecisiontree producedby alhazen to an equivalentislaformula figure .
bycomparingthisdiagnosisto avicenna andtheexpertdiagnosis wequicklyrealizethattheproducedformula and thus the equivalent decision tree not only overspecializes to the failure inducing inputs but is also more complex than the explanation produced by avicenna .
even with the shorter diagnosis avicenna capturesthecircumstancesofthefailurebetterbynot overspecializing to the singleunicode character u .
.
rq3 avicennavs.
islearn inthelastpartofourevaluation wepitch avicenna againstislearn the input invariant learner .
as discussed earlier avicenna makes extensive use of islearn gradually refining the detected inputinvariantsinafeedbackloop.isthisfeedbackloopnecessary anddoes avicenna improveoverislearn?toanswerthisquestion we compared the number of invariants produced by islearn to the numberof invariants obtained atthe end of an avicenna run.
for islearn weonlyconsideredinvariantswithrecallandspecificity estimates of from islearn s point of view all reported invariantshaveanequivalentquality.
table4summarizesourresults.
we see that running islearn on its own is not aviable alternative producing hundreds to tens of thousands of invariants.
additionally islearn was not able to produce any invariants for cookiecutter withinonehour n a .avicenna canreducethisnumber toasingle invariantinallcases solelybyrefiningtheseinvariantsthrough additionalexperiments.
theavicenna feedbackloopis crucial for providing crisp failure circumstances.
446esec fse december3 san francisco ca usa martineberlein marius smytzek dominic steinh fel larsgrunske andandreas zeller table invariantsproduced by avicenna vs.islearn subject avicenna islearn subject avicenna islearn heartbleed 1451pysnooper.
calculator pysnooper.
genson 1777cookiecutter.
1n a find.07b941b1 cookiecutter.
n a find.091557f6 1361cookiecutter.
1n a find.dbcb10e9 fastapi.
find.ff248a20 1620fastapi.
grep.3220317a fastapi.
grep.3c3bdace 4fastapi.
grep.5fa8c7c9 youtube dl.
grep.7aa698d3 youtube dl.
grep.c96b0f2c youtube dl.
.
threatsto validity our evaluation has the following threatsto validity internal validity.
thethreatstointernalvalidityrelatetothecorrectness of avicenna s implementation and the correctness ofourexperiments.
avicenna has4 000linesofcodeintotal and formally proving its correctness would be cumbersome at least.
however the results in table 2strongly suggest basedonfacevalidity that avicenna operatesasintended.
concerningourexperiments wecanruleoutmajormistakes due to the tuning of parameters since avicenna does not relyontuningparameters.additionally weperformedthe experiments with realistic settings more precisely we set theupperboundforthenumberof avicenna iterationsto and used a one hour time limit for the experiments to showthe practical valueof avicenna .
externalvalidity.
the threats to external validity are mainly related to the selection of the programs and bugs in our study.
we have used dbgbench a common debugging benchmark andtests4py abenchmarkcomprisedofmany different projects as sources of programs and real bugs.
the heartbleed calculator andgensonsubjects show that avicennacanproduceadiagnosisforauthenticbugs.consequently we would argue that the results of our study are transferable andgeneralizable to otherprograms andbugs.
limitations despiteitsadvances avicenna isnotaperfectdiagnosistool as therearefundamentallimitations.toillustratethechallenge letus havealookatthe grep.7aa698d3 bug forwhich avicenna misses the fact that the input contains multibytecharacters table2 .
ifgrepconductsacase insensitivesearch i onaninputcontaining multibyte characters and the locale is utf8 then grep prints a match of incorrect length.
when conducting the caseinsensitivesearch execute fct firstconvertstheinputtolowercase search.c .
the length of the match is computed for the match in the lower case input search.c .
however a multibyte character can take byte less in lower case the lengths of the normal case and lower case inputs differ.
the computed match size value could be half the expected value grep.c the match in the normal case input is printed with incorrect length grep.c .a perfectfailure condition wouldthus read len parenleftbig utf parenleftbigupper parenleftbig arg parenrightbig parenrightbig parenrightbig len parenleftbig utf parenleftbiglower parenleftbig arg parenrightbig parenrightbig parenrightbig which incontrasttotheactual avicenna diagnosis table2 would be accurate.
whycan avicenna notsynthesizesuchadiagnosis?theproblem is twofold.
first avicenna needs an appropriate vocabulary eventoexpress thefailure conditions inourcase functionslike utf and upper .
second we are facing a combinatorial complexityproblem asthere canbe an arbitrarynumberofcombinations ofpredicates functions operators andnonterminalstoconsider whenderivingadiagnosis.eventually theproblemcanbeframedas aprogramsynthesis problem wewantaformula orprogram that exactlypredictswhenaninputcausesafailure which ofcourse resembles the haltingproblem andthus isundecidable ingeneral.
however an undecidable problem may still be solvable under specific often common conditions our results illustratethis.possible waysto obtain even more comprehensive diagnosesinclude domain specificvocabularies.
adding catalogs with domainorprogram specificpatterns predicates andfunctionswould allowavicenna todetectthesefailureconditionsinthefirst place.ifasignificantportionof grepbugs forinstance were relatedtoutf 8handling thenaddinganappropriatevocabulary would allow avicenna to detect and express related failure causes.
program analysis.
staticanddynamicprogramanalysiscouldreveal important functions and properties directing the search toward a meaningful diagnosis.
in grep.7aa698d3 for instance a data flow analysis could reveal that the input is subject to utf 8and case transformations thus guiding the searchto vocabulariesrelatedto theseproperties.
documentation.
thegrepdocumentationrelatesthe ioption to case sensitivity which in conjunction with the current avicenna diagnosis table2 could again guide the search.
expert interaction.
guidance such as above could also be provided by a human expert starting with the initial avicenna diagnosisandgiving hints onwhere to search further.
program synthesis.
finally program synthesis could provide furtherinspirationtosynthesize higher ordercombinators recursive functions or even relational queries .
in the extreme a tool like avicenna would thus not only produce a single predicate but synthesize a program that wouldprecisely characterizeandpredict failure conditions.
conclusion and futurework withavicenna we introduce a technique to fully automatically determine failure circumstances expressed as logical properties over input elements.
the approach is general and uses an extensible vocabulary a powerful constraint solver and a refinement loop to conduct additional experiments resulting in crisp and to the point diagnoses matching the precision of human experts.
furthermore by formulating the failure diagnosis problem as finding a predicate overinputelements avicenna opensupawealthoffutureresearch opportunities.notably eachofthediagnosescanbeinstantiated into a myriad of test cases for exploring the surroundings of a bug 447semanticdebugging esec fse december3 san francisco ca usa validatingfixes andpreventingregressions.allthisisgoodnews for the future ofautomateddebugging.
besidesgeneral improvementsregardingperformanceand generality our future work willfocusonthe following topics locationconditions.
besidesfailurevs.success avicenna can determine the circumstances of arbitrary execution predicates forinstance the input circumstancesunderwhich aparticularlocationisreached whichnotonlyhelpswith understandingcode.notably solvingthecircumstancesof acodelocation u1d43fyieldsinputsthatspecificallytarget u1d43f a greatfeature for test generators.
resource consumption.
anotherinterestingclassofexecution predicates to apply avicenna on arenon functional properties such as resource consumption under which circumstances does this program require more than one gb of memory?
or more than one second for a request?
extendingavicenna withnumericalapproximationalgorithmscan precisely narrowthesecircumstances.
faultlocalization.
avicenna diagnosesallowgeneratinganunlimitednumberofpassingandfailingruns thisshouldenable a much more precise fault localization than with only a few failingruns.
we want to evaluate this.
automated repair.
theavicenna diagnosesprovideimportant hints on how to repair code automatically.
we want to map input elements to variables and relate their properties to synthesizefixes that exactly capture failure conditions.
data availabilitystatement our evaluated avicenna artifact is publicly available .
the current versions of our avicenna prototype can be downloaded from