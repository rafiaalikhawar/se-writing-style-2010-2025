snr constraint based type inference for incomplete java code snippets yiwen dong david r. cheriton school of computer science university of waterloo waterloo ontario canada y225dong uwaterloo.catianxiao gu alibaba group china tianxiao.gu gmail.com yongqiang tian david r. cheriton school of computer science university of waterloo waterloo ontario canada yongqiang.tian uwaterloo.cachengnian sun david r. cheriton school of computer science university of waterloo waterloo ontario canada cnsun uwaterloo.ca abstract code snippets are prevalent on websites such as stack overflow and are effective in demonstrating api usages concisely.
however theyareusuallydifficulttobeuseddirectlybecausemostcodesnippetsnotonlyaresyntacticallyincompletebutalsolackdependency information andthusdonotcompile.forexample javasnippets usuallydonothaveimportstatementsorrequiredlibrarynames only6.
ofjavasnippetsonstackoverflowincludeimportstatements necessary for compilation.
thispaperproposes snr aprecise efficient constraint based technique to automatically infer the exact types used in code snippets and the libraries containing the inferred types to compile and thereforereusethecodesnippets.initially snrbuildsaknowledge base of apis i.e.
various facts about the available apis from a corpus of java libraries.
given a code snippet with missing import statements snrautomatically extracts typing constraints from the snippet solves the constraints against the knowledge base andreturns a set of apis that satisfies the constraints to be imported into the snippet.
we have evaluated snron a benchmark of code snippets fromstackoverflow.
snrsignificantlyoutperformsthestate of thearttoolcoster.
snrcorrectlyinfers91.
oftheimportstatements which makes73.
of the snippetscompile compared to36.
of the import statements and .
of the snippets by coster.
ccs concepts software and its engineering automated static analysis software notations and tools theory of computation type structures .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
type inference constraint satisfaction automated repair datalog acm reference format yiwen dong tianxiao gu yongqiang tian and chengnian sun.
.
snr constraint based type inference for incomplete java code snippets.
in 44thinternationalconferenceonsoftwareengineering icse may21 pittsburgh pa usa.
acm new york ny usa pages.
https introduction a code snippet is a small region of source code which is usually incomplete and thus not compilable e.g.
a list of statements alone injavawithoutbeingputinamethodorclass.codesnippetsare useful and commonly found from well used q a websites like stackoverflow so wheresmallcodesnippetsareoftenusedto ask questions or illustrate answers concisely.
however whendevelopersfindacodesnippetonsotobeuseful andwouldliketouseitintheirprojects itisnoteasytodirectlyuse thecodesnippet.infigure1 ajavacompilersuchas javaccannot resolvethetypesusedinthesnippet e.g.
date days dateformat to their definitions which can be from third party libraries.
it takes developersboth timeand effortsto manuallyrepair codesnippets to be compilable a challenging task which requires the developers to figure out the exact types used in the code snippet e.g.
what exact types do dateanddatetime refer to and the exact libraries that provide the definitions of the used types.
a techniqueto automatically repaircode snippets byrecovering the missing types and dependent libraries for compilation will greatly save developers time compilable code snippets carry more semanticinformationthanuncompilableonesandthereforesuch atechniquecanpotentiallyenableresearcherstoextendexisting research on so .
technicalchallenges.
generally therearethreetechnicalchallenges of automatically repairing and compiling code snippets.
challenge lack of import statements.
in java a class type has asimplename e.g.
date andapackagename e.g.
java.util its fully qualified name fqn is the combination of its package name andsimplename e.g.
java.util.date whichuniquelyidentifies the class type.
to make java code concise the simple name of a ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yiwen dong tianxiao gu yongqiang tian and chengnian sun 1dateformat formatter newsimpledateformat mm dd yyyy 2date some date newdate 3date today calendar.getinstance .gettime 4try 5somedate formatter.parse catch parseexception pe 7system.out.println parser exception 9intdays days.daysbetween newdatetime somedate new datetime today .getdays 10system.out.println days betw een somedate today days figure formatted code snippet in so post .
class type can be used in java code directly and the class type s fqnisdeclaredbyanimportstatement.withthehelpofimport statements a java compiler can identify the exact class type from a simple name during compilation.
previous work showed that only .
of javacodesnippets on so included import statements that specified the fqns of the types used in the code snippets.
oneexampleisfigure1 thejavacompilerisnotabletoinferthe fqns from the simple names such as date daysanddateformat because the code snippet does not have any import statements.
challenge lack of library dependencies.
acodesnippetusually does not carry information about the libraries.
these libraries are needed for the java compiler to compile the code snippet as they contain the type definitions used in the snippet.
the example infigure1requiredthejoda timelibrary.notethatevencorrect fqns do not guarantee that we can find the correct library to depend on because different libraries of different purposes may containtypeswiththesamefqn.forexample theandroidruntime library and the java runtime library both define a class for java.text.dateformat.
challenge combinatory candidates.
to compile a code snippet weneedtohavethecorrectfqnforeachsimplename andthe correct library for each fqn.
however a simple name may correspond to multiple different fqn and each fqn may correspond to multipledifferentlibraries.thesearchspaceisallthecombinations of candidates for each simple name which defines a computationally expensive problem.
for example in figure the simple name datehas five matching classes in the java development kit jdk alone intotal thesearchspaceforthiscodesnippetis384different combinationsofclassesfromthejdkandfiveotherpopularjava libraries used in our benchmarks.
priorwork.
existingtechniquesattemptedtoaddresstypeinferenceforcodesnippetsindifferentmanners csnippexisbasedona setofheuristics bakerextractsconstraintsfromcodesnippets andusesanaiveconstraintsolvingalgorithmtoinferfqns both stattype and coster build statistical models from existingcompilablesourcecodetopredictfqnforcodesnippets.
however these techniques do not address all three challenges and suffer from inherent imprecision of the used heuristics proposedconstraintsolvingalgorithm orthetrainedstatistical models especially neither of them tackles challenge when multiple libraries contain different types with the same simple names.
our approach.
wepropose snr anovel constraint basedapproachtoautomatically preciselyinferfqnsandrequiredlibrariestocompileandreusecodesnippets.
snrbuildsaknowledgebase fromavailablelibraries byextractingfactsofthetypesdefinedin these libraries e.g.
fields methods signatures inheritance relations.
given an incomplete code snippet snrextracts constraints fromthecodesnippetthatcapturetherelationbetweentypesusedin the snippet then snrresolves these constraints by querying the knowledgebase and outputs arankedlist ofsolutions whereeach solutionisasetoftypesthatsatisfytheconstraintsandlikelymake the code snippet compile.
compared to the prior work based on either heuristics or statistics snrleverages the type system built into programming languages and models the problem of inferring types for incom plete code snippets as a constraint satisfaction problem csp .
without being affected by the randomness approximation and un interpretability from which prior work suffer snrcan deterministically precisely infer types with explicit explanation how and why the types are inferred.
wethoroughlyevaluated snragainstthestate of the arttool coster .
we used an established benchmark called stattypesoconsistingof267codesnippetsmanuallycollectedfromstack overflowposts .snrsignificantlyoutperformedcosterinterms ofaccuracyoftypeinferenceandlibraryrecommendation circlecopyrtinthe taskofinferringtypesforapielements includingsimplenames field accesses and method calls as defined in snrachieves highprecisionof98.
andrecallof79.
comparedtoprecision of .
and recall of .
by coster.
circlecopyrtin the task of inferring theimportstatementsrequiredforcompilingcodesnippets snr is able to correctly infer .
of the import statements compared to .
by coster.
circlecopyrtsnrcan accurately recommend libraries for snippets with f1score of .
compared to .
by coster.
notably snrrecommendedtheexactlibrariesfor183ofthe267snippets compared coster with .
circlecopyrtas a result of the high accuracy in typeinferenceandlibraryrecommendation snrcanmake73.
of the code snippets compilable in total compared to .
by coster.
contribution.
this paper makes the following contributions novelty weproposed snr anovelconstraint basedapproach to automatically precisely infer fqns recommend libraries and create import statements for code snippets.
soundness andsignificance we conducted extensive evaluations on real world code snippets in stattype so and the results demonstrate that snrsignificantly outperforms the state of the art in various type inference tasks.
verifiability we made a replication package available at background .
motivating example we use the code snippet in figure as a motivating example to illustrate main shortcomings of existing techniques particularly in addressing challenges and .
eclipse a prevalent integrated development environment has a powerful utility quick fix to fix common syntactical errors repair partial statements and insert missing import statements.
however quick fix is inadequate for inferring the types in figure circlecopyrtit is imprecise due to its heuristic based nature.
for example bothjava.sql.date andjava.util.date arerecommended authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
snr constraint based type inference for incomplete java code snippets icse may pittsburgh pa usa table1 thetop 3candidatesoutputby snrforfigure1.the first row is the correct solution.
the fqns in italics are implemented in multiple libraries.
name library fully qualified name dateformat jdk java.text.dateformat simpledateformat jdk java.text.simpledateformat date jdk java.util.date parseexception jdk java.text.parseexception datetime joda org.joda.time.datetime1 days joda org.joda.time.days 2dateformat android java.text.dateformat simpledateformat android java.text.simpledateformat date android java.util.date parseexception android android.net.parseexception datetime joda org.joda.time.datetimedays joda org.joda.time.days 3dateformat jdk java.text.dateformat simpledateformat jdk java.text.simpledateformat date jdk java.util.date parseexception gwt org.w3c.flute.parser.parseexceptiondatetime joda org.joda.time.datetimedays joda org.joda.time.days byquickfixeventhough calender.getinstance .gettime only returns the latter.
circlecopyrtit only works with libraries and types on the class path and cannot fix errors related to unknown types.
for example if the joda timelibraryisnotontheclasspath thenquickfixcannot create import statements for datetime which is a type defined in joda time.
circlecopyrtitcannotrecommendnewlibrariestobeaddedtotheclasspath.
therefore quick fix cannot recommend the joda time library to developers.
recent research attempted to address circlecopyrtand2 circlecopyrtusing simple constraints ormorerecently statistics .weaimedtoimproveuponprevioustechniquesandtackle circlecopyrt.previoussolutions did not consider the same fqn being implemented by multiple libraries and did not recommend libraries as part of their inference.
in the stattype so benchmark of six libraries alone both the jdk andandroidlibrariesprovideimplementationformanystandard apis.
in the real world we may want to include different versions of the same library e.g.for supporting both java and apis.
intable1 weshowasamplesolutionby snrforthemotivating problem figure .
the large number of fqns with multiple implementation shown in italics demonstrates the need for a new techniquethatcanrecommendcorrectlibraries.includingmultiple librariescanleadtodependencyconflictsandcreateseriousruntime bugs .
to address the shortcomings of prior solutions we strive to devise a technique to infer the correct fqns from code snippetswhileminimizingtheconflictofrecommendedlibraries.
thisisincontrasttocosterwhichrecommendsalllibrariescontaining the inferred fqns.expr colonequalname literal this expr op expr type expr expr expr.simplename exprinstanceof referencetype expr.simplename expr newclasstype expr newtype name colonequalfqn simplename fqn colonequalname.simplename literal colonequalnull numberliteral stringliteral op colonequal !
type colonequalprimitivetype referencetype referencetype colonequalclasstype arraytype parameterizedtype primitivetype colonequalint float boolean classtype colonequalname arraytype colonequaltype parameterizedtype colonequalclasstype classtype figure2 partofasimplifiedgrammaroftheexpressionsin java.
denotes that the enclosed term occurs zero or more times.
.
java program this paper specifically works for java but the proposed methodologyisgeneralizabletootherstatically typedprogramminglanguages.thissectionlistsminimaljavaconceptswhicharenecessary to illustrate our approach.
a java program consists of a set of compilation units each of which is a java source file and defines one class along with any number of inner classes.
generally a java class has the following components which are used bysnrfor type inference.
nameeach type e.g.
class interface annotations has a fully qualified name which is the combination of its package name may be empty and simple name .
syntactically an fqn is a sequence of simple names joined by dots.
super class each class has a single super class except the class java.lang.object objectforshort .thedefaultsuperclassof a class is objectif theextendsdeclaration is absent.
interfaces each class can have a set of interfaces as supertypes.
annotations each class can have a set of annotations.
fieldseach class can have a set of fields.
each field has a type and a name and can be optionally initialized with an expression.methods eachclasshasasetof methods.eachmethodhasa name an optional sequence of parameters and a return type.
methods contain statements and expressions in them.
figure shows a simplified version of the grammar of expressions injava.wewillusethisgrammarandthelanguageconstructslisted abovetoillustratehow snrinfersrequiredtypesandlibrariesfor incomplete java code snippets.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yiwen dong tianxiao gu yongqiang tian and chengnian sun program colonequalfact program rule program fact colonequalrelation constant .
rule colonequalatom natom natom .
natom colonequalatom !atom atom colonequalrelation term term colonequalconstant variable a simplified datalog grammar.
the terms relation andvariable arenamesfordefiningrelationshipsdeclaringandreferencingvariables.constant iseitheranumericalorstringliteral.
denotesthat the enclosed term occurs zero or many times.
a b c b dependency graph 1reachable s t node s node t edge s t .
3reachable s t node s node m node t edge s m reachable m t .
c datalog program 1node a .
2node b .
3node c .
4edge a b .
5edge b c .
d datalog program input representing the dependencygraph1reachable a b .
2reachable a c .
3reachable b c .
e successful query for the reachablerulegiventheinputin figure 3d figure3 dataloggrammarandadatalogexampleprogram.
.
datalog our technique leverages datalog a declarative logic programming languagewhichemergedfromdatabasesystemsin1980s .in recent years datalog has found use in a whole range of applications in particular program analysis .
a simplified version of the datalog grammar is shown in figure 3a.
a datalog program consists of a list of facts and rules representingsetsofrelations.factsareknownrelationsgivento a datalog program and rules are used to derive relations using facts and other rules as specified by the program.
relations can be queried to return all satisfying constants.
figures3b 3euseadependencygraphasanexampletoillustrate the various facets of a datalog program.
the dependency graph in figure3bhasthreenodes a b andcwhereadependson bandb depends on c. the information of this dependency graph can be representedasthedatalogfactsshowninfigure3d.torecursively query the reachable node pairs in this dependency graph we write ademonstrationdatalogprogramconsistingoftworulesasshown in figure 3c.
when we query for the reachable relation all the reachable node pairs are returned by a datalog solver as seen in figure 3e i.e.
a b a c and b c .
methodology template based repair type inference import repair snippet ast ast typescompilation unit libraries figure4 theoverallworkflowof snrtorepairacodesnippet to a compilable compilation unit.
figure shows the overview of snr.
given an incomplete code snippet as input snraims to output a compilable compilation unit which is the input to a java compiler i.e.
a java source file and contains circlecopyrtthecodesnippet circlecopyrtthenecessaryskeletoncode e.g.
a classdefinitionandamethoddefinitiontoenclosethecodesnippet to make the compilation unit syntactically valid and circlecopyrtinferred required import statements together with the libraries defining the imported types.
to achieve this objective the workflow of snrhas the following three major procedures.
template based repair.
given a code snippet cconsisting of a list of statements snrfirst attempts to create a minimal code skeleton based on pre defined templates to enclose c so that the skeletonand ctogetherformsasyntacticallyvalidcompilationunit.
ourapproachissimilartothatoutlinedbyterragnietal .
.after the repair the abstract syntax tree ast of the unit is generated for the following procedures.typeinference.
giventheast snrleveragesthetypeinference engine to analyze and extract the constraints.
these constraints encode the typing relations among types used in the ast.
thensnrrefines the knowledge base pre built from a set of libraries with concrete types to replace the generic types previously stored.
lastly the refined knowledge base and constraints are given to datalog to solve giving us a list of solutions for the next step.
importrepair.
inthethirdstep snrinterpretsthelistofconstraintsatisfying solutions creates import statements and inserts them into the code skeleton.
to validate the results snrleverages the javacompilertocompilestheresultingcompilationunit.ifthecompilation succeeds the compilation unit together with the import statements and the required libraries are output as the final result.
typeinferenceisthemostcriticalstepin snr.figure5describes the internal components in the type inference engine.
in the remainder of this section we describe these components in detail.
.
knowledge base given a set of libraries we build the knowledge base which can be queried to resolve ambiguities .
when gathering constraints and solving constraints .
.
.
.
content.
a simplified schema for our knowledge base is described in figure .
for each type the knowledge base stores the fqn supertype super interfaces fieldsandmethods.generictypes are stored as is in the knowledge base.
for example list.get in theknowledge basehas thetype twhichwill be refinedbefore being given to datalog when solving constraints discussed in .
.
notethattheschemainfigure6issimplifiedtoeasepresentation withtheassumptionthattherearenomultipleclasseswiththesame authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
snr constraint based type inference for incomplete java code snippets icse may pittsburgh pa usa gather constraints solve constraints knowledge baseast ast types figure type inference process in snr.
class fqn supertype generics field fqn name typesuper interface fqn interface name method fqn name return type argument typesnumber of arguments figure simplified version of the knowledge base schemaassuming there are no classes with the same fqn.
each boxrepresents a table with a table name in blue and a numberof column names.
the underline denotes the primary keyor keys that uniquely identify a row of data.
the columnnames in parenthesis are foreign keys which are linked toprimarykeysinanothertable.anedge representsaoneto many relationship between the two connected tables.
fqn.moreover libraryinformation e.g.
whichlibrarydefinesa type isalsoomittedinfigure6.therealknowledgebasein snr handles both with additional database table columns.
.
.
queryfunctions.
wedefinethefollowingqueryfunctions to retrieve information from the knowledge base.
each function representsaretrievalcriterionandtheparametersparameterizethecriterion.eachfunctionreturnsasetoftypes i.e.
classes interfaces andannotations thatsatisfythespecifiedretrievalcriterion.table2 lists the query functions used in this paper.
table query functions to retrieve types from knowledge base.
query function description simplename name returns the types with the given simple name fqn name returns the types with the given fully qualified name field name returns the types that have a field called the given name method name num args returns the types defining a method with the given name which takes num args number of parameters besides querying normal types simplename has specialized support forquerying inner types e.g.
innerclasses inner interfaces .note that an inner type can have multiple simple names.
consider aninnerclass builderwithanouterclass java.util.calendar .
it is possible to reference this type with either of the two simplenames calendar.builder orbuilder using import statements java.util.calendar orjava.util.calendar.builder respectively.
simplename supportsquerieswithdifferentformsofsimplenames.
in the example above this query function can be called with either simplename calendar.builder or simplename builder .
.
type inference extracting constraints given an ast snrtraverses it and extracts the constraints capturingtherelationsamongthetypesusedintheast.specifically snr concentrates on type elements defines as below definition .
type elements .
type elements in an ast refer to the nodes that define new types or use types i.e.
type declarations e.g.
class interface and annotation declarations explicitly used types statements and expressions.
note that prior work uses a different term api elements whichisasubsetoftypeelementsandfocusesononlyexplicitly used types i.e.simple names field accesses method calls.
for highprecision type inference snrinfers not only explicitly usedtypes but also implicitly used types in expressions e.g.variables method arguments method returns.
all the ast nodes used by snrfor type inference constitute type elements in this paper.
.
.
creating type variables.
for each type element snrfirst createsoneormore typevariables torepresentthetypesdefinedor used in the type element or in the components of the type element forsimplicity weuse todenoteatypevariable.giventhetype element a statement below date today calendar.getinstance .gettime snrcreates four type variables type variable description 1 the type of date 2 the type of calendar 3 the return type of calendar.getinstance 4 the return type of calendar.getinstance.gettime .
.
extractingconstraints.
basedon thetypevariablescreated fromatypeelement snrfurtherextractsconstraintsfromthetype element to capture the relations among the type variables.
table listsallthetypesofconstraintsusedin snr andtable4liststhe concrete rules to create type variables and constraints for type elements.
take the class declaration for an example.
the rule with the name declaration in table specifies that for a class declaration c snrgeneratesatleasttwotypevariables forcand 1forthe super class of c and a list of type variables vec 2 vec 2can be empty for the interfaces vect2ofcwith each type variable iin vec 2representing the type of one interface.
then snrcreates one constraint extend 1 to capture the typing relation between candt1 and oneinterface i for each implemented interface.
snrmakes extensive uses of the subtype constraint in order to model implicit type conversions of both primitive and reference authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yiwen dong tianxiao gu yongqiang tian and chengnian sun table3 constraintsusedinthispaper.eachconstraintspecifies some property that a type variable should have or some relation among multiple type variables.
constraint description simplename name has the given simple name fqn name has the given fqn name field name field has a field with given nameof the type field method name vec arg ret hasamethod withgiven name argumenttypes vec argand return type ret paramtype vec arg param with parameter vec argbuilds the parameterized type param arraytype arr an array of is type arr subtype parent child childcan be implicitly converted to parent extend super extends super interface interface implements the interface of interface annotation is an annotation type innerclass inner is has an inner class type of inner types allowed in java e.g.in assignments or when passing method arguments andtoconstraincertainknowntypesintheast e.g.
the conditional in an if statement is a boolean .
anexample.
followingtherulesoutlinedintable4 snrcreates thefollowingconstraintsoverthetypevariables 1 2 3and 4of the example statement in .
.
.
constraints description simplename 1 date 1has the simple name date simplename 2 calendar 2has the simple name calendar method 2 getinstance 3 2hasamethodnamed getinstance thattakes no arguments with the return type of 3 method 3 gettime 4 3has a method named gettime that takes no arguments with the return type of 4 subtype 1 4 1has a subtype 4because of the assignment .
type inference resolving ambiguities from the constraint generation rules laid out in table inner classes qualifiednamesandfieldexpressionscanbringambiguities into the process of extracting constraints.
for example java.util.collections.empty list for the first identifier javain this expression there are four broad categories of possible interpretations circlecopyrtjavais a variable defined locally in the current code snippet e.g.
a local variable a method parameter a class field.
circlecopyrtjavaisaclassdefinedlocallyinthecurrentcodesnippet e.g.
an inner class.
circlecopyrtjavaisthenameofatype e.g.
aclassoraninterface which is defined externally but not in the current code snippet.
circlecopyrtjavaisapartofapackagename andthepackagenameisused to form a fqn.
theremainingidentifiersarethenpotentiallyamixofpackages classes inner classes and field