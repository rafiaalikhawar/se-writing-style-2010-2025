propr property based automatic program repair matth as p ll gissurarson chalmers university of technology gothenburg sweden pallm chalmers.seleonhard applis tu delft delft netherlands l.h.applis tudelft.nlannibale panichella tu delft delft netherlands a.panichella tudelft.nl arie van deursen tu delft delft netherlands arie.vandeursen tudelft.nldavid sands chalmers university of technology gothenburg sweden dave chalmers.se abstract automaticprogramrepair apr regularlyfacesthechallengeof overfitting patches patches that pass the test suite but do not actuallyaddresstheproblemswhenevaluatedmanually.currently overfit detection requires manual inspection or an oracle makingqualitycontrolofapranexpensivetask.withthiswork we want to introduce properties in addition to unit tests for apr to address the problem of overfitting.
to that end we design and implement propr a program repair tool for haskell that leverages bothproperty basedtesting viaquickcheck andtherichtypesystemandsynthesisofferedbythehaskellcompiler.wecomparethe repair ratio time to first patchandoverfitting ratiowhenusing unit tests property based tests and their combination.
our results showthatpropertiesleadtoquickerresultsandhavealoweroverfit ratiothanunittests.thecreatedoverfitpatchesprovidevaluable insight into the underlying problems of the program to repair e.g.
in terms of fault localization or test quality .
we consider this step towardsfitter or at least insightful patches a critical contribution to bring apr into developer workflows.
ccs concepts softwareanditsengineering search basedsoftwareengineering automatic programming functional languages source code generation.
keywords automatic program repair search based software engineering synthesis property based testing typed holes acm reference format matth as p ll gissurarson leonhard applis annibale panichella arie van deursen anddavidsands.
.propr property basedautomaticprogram repair.in 44thinternationalconferenceonsoftwareengineering icse may pittsburgh pa usa.
acm new york ny usa pages.
the first two authors contributed equally to this paper .
this work is licensed under a creative commons attribution international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
introduction haveyoueverfailedtobeperfect?don tworry sohaveautomatic programrepair apr approaches.aprfacesmanychallenges someinheritedfromsearch basedsoftwareengineering sbse likeoverfitting predictive evaluation in search and duplicate handling .otherchallengesareuniquetothedomainitself such as deriving ingredients for a fix and producing valid programs .
consequently apr has open research in all of its core aspects search space search process and fitness evaluation.
the researchcommunityisshiftingitsfocustowardsothersolutions either leaving behind boundaries of search space using generative neuralnetworks orbyempiricalevidencethatfixesare oftenrelatedtodependencies notthecodeitself .fixesare usually validated byrunning against the test suiteof the program assuming that a solution that passes all tests is a valid patch.
however legouesetal.
showedthatprogramrepaircan overfit i.e.
thatafixpassesthetestsuitedespiteremovingfunctionality or just bypassing single tests.
usually generatedpatchesareevaluatedagainstaunittestsuite of the buggy program .
the fitness is defined as the number of failing tests in the suite making a fitness of zero a potential fix.
the problem is the quality of the tests often not all important cases are covered and the search finds something that passes alltestsbutdoesn tprovideallwantedfunctionality .thisis consideredan overfitrepairattempt.aparticularlygoodexample for this is the kali approach that removes random statements of a program.
in a later study martinez et al.
showed that out of of the repair attempts that passed the tests only one was a realfix.oneapproachbyyzetal.
toaddressoverfittingwas to introduce testsgenerated with evosuite to havea stronger test suite reporting only an improvement in speed not in found solutions.unfortunately evosuiteintroducesanewproblem ifthe programwasfaulty whichprogramsthatwearetryingtorepair are an automatically generated test suite may assert the faultybehavior and make test based repairs unable to ever produce acorrectprogram despitepassingthe generated testsuite.thus currentautomatedtest casegenerationisnotthebe allandend all for overfitting in apr.
this work aims to improve apr with addressing the overfitting problembyintroducingproperties inadditiontounittests.a softwarepropertyisanattributeofafunction e.g.
symmetry idempotency etc.
that is evaluated against randomly created instances ofinputdata.well writtenpropertiesoftencoverhundredsof unit tests making them attractive candidates for fitness evaluation.
ieee acm 44th international conference on software engineering icse icse may pittsburgh pa usa matth as p ll gissurarson leonhard applis et al.
we argue that properties can be an improvement to the overfittingchallengeinapr.whileproperty basedtestingframeworks exist for a range of languages the practice is particularly natural for functional programming and widely used in the haskell community.therefore weimplementatoolcalledpropr which utilizes properties for haskell program repair and evaluate the repair rates and overfitting rates for different algorithms random search exhaustivesearch andgeneticalgorithms .ourfixesfollow a genprog like approach of representing patches as a set of changestotheprogram withthemajordifferencethatourpatch ingredients mutations are sourced by the haskell compiler using amechanismcalled typedholes .atypedholecanbeseenas aplaceholder forwhichthecompilersuggestselementsthatproduce a compiling program.
as these suggestions cover all elements inscope notonlythoseusedintheexistingcode weovercome tosomedegreetheredundancyassumption i.e.
theconcept thatpatchesaresourcedfromexistingcodeorpatterns whichis common to genprog like approaches.
our results show that properties help to reduce the overfit ratio from85 to63 andleadtofastersearchresults.propertiescanstill leadtooverfitting andtheuniontestsuiteofpropertiesandunit testsinheritsbothstrengthsandweaknesses.wethereforeargue tousepropertiesifpossible andsuggesttoaimforthestrongest testsuiteregardlessofthetest type.thepatchesfrom propr can produce complex repair patterns that did not appear within the code.
even patches that are overfit can give valuable insight in the test suite or the original fault.
our contributions can be summarized as follows introducing the use of properties for fitness functions in automatic program repair.
showinghowtogeneratepatchcandidatesusingcompiler scope partially addressing the redundancy assumption.
performing an empirical study to evaluate the improvement gained by properties with a special focus on manual inspection of generated patches to detect eventual overfitting.
anopensourceimplementationofourtoolpropr enabling future research on program repair in a strongly typed functional programming context.
providing the empirical study data for future research.
the remainder of the paper is organized as follows section introducesproperty basedtestingandsummarizestherelatedwork in the fields of genetic program repair as well as background on typedholes whichareakeyelementofourpatchgenerationmethod.
insection3wepresenttheprimaryaspectsoftherepairtooland theirreasoning.section4presentsthedatausedintheempirical study anddeclaresresearchquestionsandmethodology.theresults of the research questions are covered in section and discussed in section6.afterthethreatstovalidityinsection7wesummarizethe work in section .
the shared artifacts are described in section .
background and related work .
property based testing property based testing is a form of automated testing derived from random testing .
while random testing executes functions and apis on random input to detect error states and reach high code coverage property basedtestingusesadeveloperdefinedattributesprop 1 double test prop 1x sin x sin x prop 2 double test prop 2x sin x sin x prop 3 test prop 3 sin prop 4 test prop 4 sin0 0unit 1 test unit 1 sin sin unit 2 test unit 2 sin0 unit 3 test unit 3 sin unit 4 test unit 4 sin sin double double bool n m abs n m .0e figure comparison of properties and unit tests for sin calledproperties offunctionsthatmustholdforanyinputofthat function .randomtestsareperformedforthegivenproperty if an input is found for which the property returns false or fails with an error the property is reported as failingalong with the input as a counter example .
some frameworks will additionally shrinkthe counter example usinga previously supplied shrinking function to offer better insight into the root cause of the failure .
there are some variations on property based testing e.g.
smallcheck which performs an exhaustive test of the property .
quickcheckapproximates thisbehavior witha configurablenumber of random inputs by default random samples .
figure providesanexamplecomparisonofpropertiesandunittestsofa sine function.
the properties require an argument double test and must hold for any given double.
on any single quickcheck run 202testsareperformed formingamuchstrongertestsuitefor a comparable amount of code.
aremainingquestioniswhetheronecannotjustreproducethese tests by unit tests.
for a single seed this is doable but it is a special strength of properties that the new tests are randomly generated on demand.
we hope this addresses the problem of overfitting asthereareno fixedteststofitonaslongastheseed changes.
furthermore we stress that maintaining properties is easier than maintaining repetitive unit tests.
.
haskell ghc typed holes haskell.haskellisastaticallytyped non strict purelyfunctional programminglanguage.itsdesignensuresthatthepresenceofside effectsisalwaysvisibleinthetypeofafunction anditistypical programmingpracticetocleanlyseparatecoderequiringsideeffects fromthemainapplicationlogic.thisfacilitatesamodularapproach totestinginwhichprogrampartscanbetestedinisolationwithout needing to consider global state or side effects.
haskell s rich type system and type classes allow tools such as quickcheck t o efficiently test functions using properties where the inputs are generatedbyquickcheckbasedonageneratorforagivendatatype.
valid hole fits.
our tool is based on using the glasgow haskell compiler ghc whichiswidelyusedinbothindustryandacademia.
ghchasmanyfeaturesbeyondthehaskellstandard includinga 1769propr property based automatic program repair icse may pittsburgh pa usa featureknownas typedholes .a hole denotedbyanunderscore character allows a programmer to write an incomplete program where the hole is a placeholder for currently missing code.
using a hole in an expression generates a type error containing contextual information about the placeholder including most importantly itsinferredtype.inadditiontocontextualinformation ghcsuggestssome validhole fits .validholefitsarealistof identifiers in scope which could be used to fill the holes without anytypeerrors.asasimpleexample considertheinteractionwith the ghc repl shown in figure .
ghci letdegreestoradians double double degreestoradians d d interactive error found hole double in the expression d valid hole fits include d double bound at interactive pi forall a. floating a a imported from prelude figure example code with a hole and its valid hole fits herethedefinitionof degreestoradians containsahole.there are just two valid hole fits in scope the parameter dand the predefined constant pi.
ghc can not only generate simple candidates such as variables and functions but also refinement hole fits.
a refinement hole fit is a function identifier with placeholders for its parameters.
in this way ghc can be used to synthesize more complex type correct candidate expressions through a series of refinement steps up to a given user specified refinement depth .
for example settingtherefinementdepthto1willadditionallyprovide among others the following hole fits negate double frominteger integer in this work we use hole fitting for program repair by removing a potentially faulty sub expression leaving a hole in its place and using valid hole fits to suggest possible patches.
hole fitplugins.
bydefault ghcconsiderseveryidentifierin scope as a potential hole fit candidate and returns those that have atypecorrespondingtotheholeashole fits.however usersmight wanttoaddorremovecandidatesorrunadditionalsearchusing a different method or external tools.
for this purpose ghc added hole fit plugins which allows users to customize the behavior ofthehole fitsearch.whenusingghcasalibrary thisalsoallows usersto extractan internalrepresentation ofthe hole fits directly from a plugin without having to parse the error message.
.
genprog genetic program repair patch representation search basedprogramrepaircenteredmostlyaroundtheworkof le goues et al.
in genprog which provided genetic search for c program repair.
one of the primary contributions was the representationofapatchasachange addition removal orreplacement of existing statements.
genetic search is based around the mutation creation and combination of chromosomes the basic building bricks of genetic search.
a chromosome of apr is a listofsuchchangesratherthanafullprogram ast makingtheapproach lightweight.
utilizing changes is based on the redundancy assumption i.e.
assuming that the required statements for thefixalreadyexists.thecodemightjustusethewrongvariable or miss a null check to function properly.
this assumption has been verified by martinez et al.
showing that the redundancy assumption widely holds for inspected repositories.
we adopted thepatch representationinourtool butwereabletoweakenthe redundancy assumption see section .
sincegenprog muchhasbeendoneingeneticprogramrepair mostlyforjava.particularlyastor enabledlotsofresearch duetoitsmodularapproach aswellasreal world applications .
this modularity mostly the separation of fault localization patch generation and search is a valuable lesson learned by the community that we adopted in our tool.
compared to this body of research our scientific contributions lie within the patch generation and the search space see section .
.
.
repair of formally verified programs program synthesis another field of research dominant in functional programming is formal verification in which mathematical methods are used to prove the correctness of programs.
due to its strengths it has beenwidelyappliedtovarioustasks suchashardware verification cryptographic protocols or lately smart contracts .
but formal verification has also been applied to the domain of program repair and synthesis and some languages can arguablybeconsideredsynthesizersaroundconstraints e.g.prolog .
using specification based synthesis in combination with a sat solver can be effective however the accuracy is closely tied to the completeness of the post condition constraints .
for haskell these approaches revolve around liquid types which enrichhaskell stypesystemwithlogicalpredicatesthatarepassed ontoansmtsolverduringtypechecking .theexistingapproaches focusprimarilyonthesearch aspects of program synthesis due to the infinite search space and often perform a guided search similar to proof systems.
the approach used in the lifty language is especially relevant lifty is a domain specific data centric language in which applications can be statically and automatically verified to handle data specified asperdeclarativesecuritypolicies andsuggestprovablycorrect repairs when a leak of sensitive data is detected.
their approach differs in that they target a domain specific language and focus on type drivenrepairofsecuritypoliciesandnotgeneralproperties.
another interesting approach is the tygar based hoogle api discoverytool whereuserscanspecifyprogrammingtasksusing eitheratype asetofinput outputtests orboth andgetalistof programs composed from functions in popular haskell libraries andexamplesofbehavior .itishoweve rfocusedonapidiscoveryandnotprogramrepair althoughincorporatinghoogle into proprisaninterestingavenueforfuturework.theapproachby leeetal.
isinmanywayssimilar theyalsooperateonstudent data and find very valuable insights from repair and identical challenges.
the approach they developed fixml exploits typed holes toalignbuggystudent programswithagiveninstructor program based on symbolic execution.
fixml is different as it requires a 1770icse may pittsburgh pa usa matth as p ll gissurarson leonhard applis et al.
goldstandard andsynthesizesbytype enumerationaftersymbolic execution.
to some degree this is similar to our implementation of an exhaustive search.
semantics based repair using symbolicexecution like that of angelix can be very effective in fixing real world bugs and uses symbolic expressions similarly to our typed holes.
ho wever there are some scalability concerns for symbolicexecution andwhiletheycanbemitigatedusing acarefully chosen number of suspicious expression and their derived angelic forests they can also be mitigated using genetic algorithms andthemorelightweightproperty basedanalysis motivatingtheir usageinpropr.comparedtoprogramsynthesis programrepair is better able to take advantage of a reasonable baseline program from the developers.
intermsofutilizingspecifications theprimarybenefitofquickcheckistheeasyadoptionforusers whereasformalverification comes with a high barrier of entry for most programs and requires dedicated and educated developers.
to some degree we utilize formalverificationduetothetype correctness constraintthatalready greatlyshrinksthesearchspace whileweassertthefunctional correctness with tests and properties.
a full formal verificationsuite might produce better results but we ease the adoption of our approach by utilizing comprehensive properties and tests.
technical details propr failing properties targetshaskell program coverage ghc pluginfault involved expressions candidate fixessource quickcheck search algorithmfixesproperties diffapply fixes hole fit synthesisperforated expressionsperforation candidate selection candidate evaluationinspect bindings fault localizationtest properties rebind in properties1 figure the propr test localize synthesize rebind loop to investigate the effectiveness of combining property based tests with type based synthesis we implemented propr.
propr isanautomatedprogramrepairtoolwritteninhaskell andusesghc as a library in conjunction with custom written hole fit pluginsasthebasisforparsingsourcecode synthesizingfixes asfor instrumentingandrunningtests.propralsoparametrizesthetests so that local definitions can be exchanged with new ones which allows us to observe the effectiveness of a fix.
to automate the repair process propr implements the search methods described in section .
to find and combine fixes for the whole program repair.
anoverviewoftheproprtest localize synthesize rebind tlsr loopisprovidedinfigure3.thecirclednumbers ninthissection refer to the labels in figure .
len int len lenxs product map const int xs prop abc bool prop abc len abc prop dup bool prop dup x len x x len x figure4 anincorrectimplementationoflength.we mapover the list and set all elements to int and take the product of the resulting list.
this means that lenwill always return foralllists.anexpectedfixwouldbetotakethe sumofthe elements which would give the length of the list.
as a running example imagine we had an incorrectimplementation of a function to compute the length of a list called len with properties as seen in figure .
.
compiler driven mutation to repair a program we use ghc to parse and type check the source into ghc s internal representation of the type annotated haskell ast.
by using ghc as a library we can interact with ghc srichinternalrepresentationofprogramswithoutresorting to external dependencies or modeling.
we determine the tests to fix by traversing the ast for top level bindings with either a type testtree orname prop thatindicatesitisatest .weuseghc s abilitytoderivedatadefinitionsforalgebraicdatatypes andthe lenslibrary togenerateefficienttraversalsofthehaskellast.
todeterminethefunctionbindingstomutate wetraversetheasts of the properties and find variables that refer to top level bindings in the current module .
we call these bindings the targets.
in our example both prop abc andprop dup use the local toplevel binding lenin their body so our target set will be len .
parametrized properties.
to generalize over the definition of targetsinthepropertiesandtests wecreatea parametrizedproperty fromeachofthepropertiesbychangingtheirbindingtotakeanadditional argument for each of the targetsin their body.
this allows prop abc int bool prop abc f f abc prop dup int bool prop dup fx f x x fx figure the parametrized properties for len 1771propr property based automatic program repair icse may pittsburgh pa usa abc prop bool abc prop prop abc length dup prop bool dup prop prop dup length figure the parametrized properties applied to a different implementation of len the standard library length ustorebind i.e.
changethedefinitionof eachofthetargetsbyprovidingthemasanargumenttotheparametrizedproperty .once the parametrized property has received all the target arguments it now behaves like the original property with the target bindings referring to our mutated definitions.
we show the parametrized properties for the properties in figure in figure .
the new properties in figure abc prop anddouble prop will now behave the same as the original prop abc andprop dup but with every instance of lenreplaced with length abc prop length abc double prop x length x x length x thisallowstocreatenewdefinitionsof lenandevaluatehowthe properties behave with the different definitions.
fault localization.
propr uses an expression level fault localization spectrum to which we apply a binary fault localization method touchedornottouchedbyfailingproperties .anotable difference to other apr tools like astor is that we can perform fault localization for the mutatedtargets.
this enables propr to adjust the search space once a partial repair has been found i.e.
one that passes a new subset of the properties.
since fault localization is expensive by default we only perform it on the initial program similarly to astor .
ghc s haskell program coverage hpc can instrument haskell modules and get a count of how many times each expression is evaluated during execution .usingquickcheck wefindwhichpropertiesarefailingand generate a counterexample for each failing property .
for properties without arguments essentially unit tests we do not need any additional arguments so we can run the property as is the counterexampleisthepropertyitself.byapplyingeachproperty to its counterexample and instrumenting the resulting program with hpc we can see exactly which expressions in the module are evaluated in a failing execution of property .
the expressions evaluatedinthecounterexampleofthepropertyarepreciselythe expressions for which a replacement would have an effect nonevaluatedexpressionscannotcontributetothefailingofaproperty.
we call these the fault involved expressions .
these will be allthe expressionsinvolvedinfailingtests properties andcoversevery expression invoked when running counter examples.
in our simple example only prop dup requires a counterexample for which quickcheck produces a simple non empty list .
when we then evaluate prop abc andprop dup only the expressions in the non empty branch of lenare evaluated the empty branch is not involved in the fault.
perforation.
for the targets we generate a version of the ast with a new typed hole in it in a process we call perforation .
when we perforate a target we generate a copy of its ast for each faultinvolvedexpressioninthetarget wheretheexpressionhasbeenreplaced with a typed hole .
the perforated asts are then compiledwithghc.sincetheynowhaveatypedhole thecompilation will invoke ghc s valid hole fit synthesis .
we present a few examples of the perforated versions of lenin figure .
len lenxs len lenxs map const int xs len lenxs product len lenxs product const int xs ... figure a few perforated versions of len.
n.b.
the empty branch is not perforated as it is not involved in the fault .
fixes afixisrepresentedasamap lookuptable from sourcelocations in the module to an expression representing a fix candidate.
merging two fixes is done by simply merging the two maps.
candidate fixes in propr come in three variations hole fit candidates expression candidates andapplication candidates .
hole fitcandidates.
usingacustomhole fitplugin weextract thelistofvalidhole fitsforthathole andnowhaveawell typed replacement for each expression in the target ast.
foundhole int inan equation for len len xs map const int xs validhole fits include head a last a length foldable t ta int maximum foldable t orda ta a minimum foldable t orda ta a product foldable t numa ta a sum foldable t numa ta a validrefinement hole fits include foldl1 int int int ... figure hole fits for a perforation of len where producthas been replaced with a hole wederivehole fitcandidatesdirectlyfromghc svalidhole fits asseeninfigure8 givingrisetothefixesinfigure9.thesetake the form of an identifier e.g.
sum or an identifier with additional holes e.g.
foldl1 for refinement fits.
sincewesynthesizeonlywell typedprograms wecannotuse refinement hole fits directly the resulting program would produce a typed hole error.
to use refinement hole fits we recursively synthesizefitsfortheholesintherefinementhole fitsuptoadepth 1772icse may pittsburgh pa usa matth as p ll gissurarson leonhard applis et al.
interactive head interactive last interactive length ... interactive sum figure candidate fixesderived fromthe validhole fits in figure .
the location refers to productinlen configurable by the user.
this means that we can generate e.g.
foldl1 when the depth is set to and e.g.
foldl1 flip foldl1 flip for a depth of etc.
by tuning the refinement level and depth we could synthesize most haskell programs exceptingconstants .however inpracticalterms theamountof work grows exponentially with increasing depth.
tobeabletofindfixesthatincludeconstants e.g.
stringorint orfixesthatwouldotherwiserequireahighanddeeprefinement level we search the program under repair for expression candidates .theseareinjectedintoourcustomhole fitpluginandchecked whether they fit a given hole using machinery similar to ghc s valid hole fit synthesis but matching the type of an expression instead of an identifier in scope.
in our example these would include int x x andmore.foreachexpressioncandidate we thencheckthatallthevariablesreferredtointheexpressionsarein scope andthattheexpressionhasanappropriatetype.wealsolook atapplication candidates of the form x wherexis some expressionalreadyintheprogram and isfilledinbyghc svalidhole fit synthesis.thisallowsustofindcommondatatransformationfixes such asfilter not.null .
regardless of technical limitations this approach can be considered a form of localized program synthesis exploited for program repair.byusingvalidhole fits wecanutilizethefullpower ghc s type checker when finding candidates and avoid having to model ghc s ever growing list of language extensions.
this allows us to drastically reduce the search space to well typed programs only.
.
checking fixes oncewehavefoundacandidatefix weneedtocheckwhetherthey work.weapplyafixtotheprogrambytraversingtheast andsubstituting the expression found in the map with its replacement.
we len1 len1xs head map const int xs ... len3 len3xs length map const int xs ... len7 len7xs sum map const int xs figure10 newtargetsdefinedbyapplyingthefixesinfigure to the original len dothisforalltargets andobtainnewtargetswherethelocationsof the holes have been replaced with fix candidates.
for the given len example the fixes in figure give rise to the definitions shown in figure10.
wethen constructa checking programthat appliesthe parametrizedpropertiesandteststothesenewtargetdefinitionsand compile the result.
a simplified example of this can be seen propr mapm sequence quickcheck prop abc len1 quickcheck prop dup len1 quickcheck prop abc len2 quickcheck prop dup len2 quickcheck prop abc len3 quickcheck prop dup len3 ... quickcheck prop abc len7 quickcheck prop dup len7 evaluates to figure checking our new targets from figure infigure11 thoughwedoadditionalworktoextracttheresults in propr.
it might be the case that the resulting program does not compile as our synthesis is based on the types we might generate programsthatdonotparsebecauseofadifferenceinprecedence precedence is checked during renaming aftertype checking in ghc .
we remove all those candidate fixes that do not compile obtaininganexecutablethattakesasanargumentthepropertytorun andreturnswhetherthatpropertyfailed.werunthisexecutablein a separate process running it in the same process might cause our ownprogramtohangduetoaloopinthecheck.byrunningina separate process we can kill itafter a timeoutand decide thatthe given fix resulted in an infinite loop.
after executing the program we have three possible results all properties succeeded the program did not finish due to an error or timeout or some properties failed8.
in our example we see in figure that len3andlen7 passalltheproperties meaningthatreplacing productwithlength orsumqualifies as a repair for the program.
.
search withinpropr weimplementedthree differentsearchalgorithms random search exhaustive search andgenetic search .
allthreealgorithmsshareacommonconfiguration theyallhave atimebudget measuredinwallclocktime afterwhichtheyexit and return the results if any that they ve found.
forthegeneticsearch proprimplementsbestpracticesand algorithmscommontoothertoolssuchasastor orevosuite .
a mutation consists of either dropping a replacement of a fix or adding a new replacement to it.
the initial population is created as picking nrandom mutations.
the crossover randomly picks cut points within the parent chromosomes and produces offspring by swapping the parents genes around the cut points.
we support environment selection with an elitism rate for truncation.
elitismmeansthatwepick thetop x percentofthe fittestcandidatesforthenextgeneration fillingtheremaining x with other randomindividualsfromthepopulation.wechooserandom pairsfromthelastpopulationasparentsandperformenvironment selection on the parents and their offspring.
our manual sampling ofrepairs in progressonthedatapointsshowedthatgeneticsearch requireshigh churninordertobeeffective changingasingleexpressionoftheprogramusuallyfailedmorepropertiesthanitfixed.
hence the resulting configurations for the experiment have a low elitism and high mutation and crossover rate.
withinrandom search we pick up to a configurable size evaluated holes at random and pick valid hole fits at random with 1773propr property based automatic program repair icse may pittsburgh pa usa which to fill them.
we then check the resulting fix and cache it.
the primary reason for using random search is to show that the geneticsearchisanimprovementover guessing.nevertheless qiet al.
showedthatrandomsearchsometimescanbesuperiorto genetic search further motivating its application.
besides random search is a standard baseline in search based software engineering to assess whether more intelligent search algorithms are needed for the problem under analysis.
forexhaustivesearch wecheckeachhole fitinabreadth first manner first all single replacement fixes then all two replacement fixes and so on until the search budget is exhausted.
exhaustive searchisdeterministicapartfrominherentrandomnessinquickcheck.
we use exhaustive search to demonstrate the complexity of theproblem andtoshowthatsearchisbetterthanenumeration.
the deterministic search pattern of exhaustive search would be ideal for a single fix problem such as our example.
the fitness for all searches is calculated as the failure ratio number of failures number of tests with a non termination or errors treated as the worstfitness1andafitnessof0 alltestspassing marksacandidate patch.suchpatchesareremovedfrompopulationsingeneticsearch and replaced by a new random element.
within the test localize synthesize rebind loop figure we perform one generation of genetic search per loop and after the selectionofchromosomestheprogramisre boundandcoveragereevaluated.
the authors observed that this is a bit over engineered for smallprograms the faultlocalization did notgreatly change whentheprogramshadonlyasinglefailingproperty.asanoptimization we added a flag to skip the steps 5to7in the loop to speed up the actual search.
this configuration was enabled during experiments presented in section .
the exhaustive and random search do not perform any rebinding.
.
looping and finalizing results looping.
if thereare stillfailing properties afteran iterationof the loop we apply the current fixes we have found so far to the targetsandenterthenextiterationoftheloop repeatingthe processwiththenewtargetsuntilallpropertieshavebeenfixed or the search budget runs out.
finalizing and reporting results.
after we have found a set of valid fixes that pass all the properties we generate a diff for the originalprogrambasedontheprogrambindingsandthemutated targets constituting the fix .
this way the resulting patches can be fed into other systems such as editors or pull requests.
empirical study .
research questions given the concepts presented in section research interests are twofold how well does the typed hole synthesis perform for apr andwhatistheindividualcontributionofproperties.aswithinthe integralapproachof propr theeffectscannottrulybedissected the only contributions that we can separate for distinct inspection istheuseofproperties underwhichwewillinvestigatethepatches generated by propr.diff git a interactive b interactive a interactive b interactive len len len xs product map const int xs len xs length map const int xs diff git a interactive b interactive a interactive b interactive len len len xs product map const int xs len xs sum map const int xs figure the final result of our repair for len wefirstwanttoanswerwhetherpropertiesaddvalueforguiding thesearch.ideally propertiesshould improvethe repair rate speed and quality regardless of the approach which we address in rq1 research question towhatextentdoesautomaticprogramrepairbenefitfrom the use of properties?
given that properties do have an impact for better or worse we want to quantify its extent on configuration and selection of searchalgorithms.forexample weexpectthattheuseofproperties helpswithfitnessandsearch butwillincreasethetimerequiredfor evaluation thiswouldmotivatetoconfigurethegeneticsearchto havesmallbutwellguidedpopulations.toelaboratethiswedefine rq2 as follows research question howcanweimprove andconfigure searchalgorithmswhen used with properties?
withthelastresearchquestionwewanttoperformaqualitative analysisontheresultsfound.previousresearchshowedthat just maximizing metrics is not sufficient.
with a manual analysis we lookfortheissueofoverfittingandtrytoinvestigatenewissues and new patterns of overfitting.
research question to what extent is overfitting in automatic program repair addressed by the use of properties?
.
dataset thenoveldatasetstemsfromastudentcourseonfunctionalprogramming.
withinthe exercise thestudents had toimplement a calculatorthatparsesatermfromtext calculatesresultsandderivations.whiletheoverallnotionisthatofaclassroomexercise the problem nevertheless contains real world tasks asserted by realworld tests.
the calculator itself is a classic student exercise but 1774icse may pittsburgh pa usa matth as p ll gissurarson leonhard applis et al.
table parameters for grid experiment parameter inspected values tests unit tests properties unit tests properties search random exhaustive genetic termination minute search budget seeds 5seeds thesubtaskofparsingisbothcommonanddifficult representing avaluablecaseforapr.intotal wecollected 30programs that all fail at least one of properties and one of unit tests .
the programs range from to lines of code excluding tests and haveatleast5topleveldefinitions.theseare commonfile sizesfor haskell e.g.
propr itself has an average of loc per file.
the faults are localized to one of the three modules provided to propr.
themostviolatedtestsareeitherrelatedtoparsingandprinting especially of trigonometric functions also seen in figure or about simplification seen in figure which are core parts of the assignment.
the calculator makes a particularly good example for properties as attributes such as commutativity associativity etc.
are easy to assert but harder to implement.
hence we argue that the calculator exercise makes a case for typical programs that implement properties i.e.
they are not artificially added for apr .
data points were selected from the students submissions if they fulfilled the following attributes ait compiled bit failed the unittestsuite andtheproperty basedtestsuiteseparately.an errorproducing test is considered as a normal failure.
we selected them by these criteria to draw per data point comparisons of properties to unit tests and their unison.
we consider a separate investigation of repairing unit test failing programs versus properties failing programs and their overfitting future research.
prop simplify idempotency expr bool prop simplify idempotency e simplify simplify e simplify e figure a property asserting the idempotency of simplify the anonymized data is provided in the reproduction package.
.
methodology experiment design to evaluate rq1 and rq2 we perform a grid experiment on the dataset withthe parameters presentedin table1.
for everyof the 45configurationswemakearepairattemptoneverypointinthe dataset.
the genetic search uses a single set of parameters that wasdeterminedthroughprobing.weutilizedockerandlimitevery container to vcpus .6ghz and 16gb ram the container s lifetime is exactly one data point .
further information on the data collection can be found in the reproduction package.
giventhisgridexperiment wecollectthefollowingvaluesfor each data point in the dataset time to first result number of distinct results within minutes the fixes themselves the search budget starts after a brief initialization as propr loads and instruments the program.
we round the measured timestotwodigitsasrecommendedbyneumannetal.andremovetype1 clones identical up to whitespace from the results .
to answer rq1 we check every trial whether at least one patch was found whether it was solved .
we then perform a fisher exact test to see if the entries originate from the same population i.e.
if they follow the same distribution.
we consider results with a p value of smaller than .
as significant.
to answer rq2 we perform a pairwise wilcoxon ranksum test on the data points grouped by their test configuration.
the wilcoxon test is a non parametric test and does not make any assumptionondatadistribution.initspairwiseapplication wefirst comparetheeffectofunittestsagainsttheeffectofproperties then unittestsagainstcombinedunittestsandpropertiesetc.wechoose a significance level of .
afterwehaveseenwhetherpropertieshaveasignificantimpact on program repair we can quantify the effect size by applying the vargha delaney test to the given pairs of configurations.
in thevargha delaneytest avalueofe.g.
.7meansthatalgorithm bisbetterthanalgorithmain70 ofthecases estimatingasimilarprobabilityofdominanceforfutureapplicationsonsimilarly distributed data points.
note that a result of .
does not mean there was no effect the groups can still be significantly different without being clearly better.
rq3 can to the best of our knowledge only be answered by humanevaluation.existingresearchonautomaticpatch validation byqi requiresanautomatictest generationframework which isnotavailableforhaskell aswellasagold standardfixtoworkas anoracle.theyusedexistinggit fixesasoracles butweexpectsome data points to be correct despite not matching the sample solution.
similarly workbynilizadehetal.
utilizesformalverification to automatically verify generated patches but unfortunately no specificationswereavailableforourdataset.instead weperform the analysis manually similar to and .
as there are too many results to manually inspect we sampled fixes1and let two authors label them as overfitornot overfit .
the authors do so based on their domain knowledge and in accordance with a given gold standard.
on disagreement the authors provide a short written statement before discussing and agreeing on the fix status.
theconclusionofthediscussionisalsodocumentedwithashort statement.
the manual labels as well as the statements are shared within the replication package.
results the following section answers the research questions in order and presents general information gained in the study.
rq1 repairrate.
intotal proprmanagedtofind patchesfor of programs of the dataset.
in table we show the detailed results of these programs.
we found patches in total with amedianof3patchespersuccessfulrun .avisualizationofthe results can be seen in figure and figure .
foreveryentry weperformedafisherexacttestbasedonthe repairperseedofeverytestsuite.thecontingencytablesarebased on whether the specific seed found patches for the test suite.
it 1the threshold of has been calculated after seeing patches being generated which is sufficient sample for a p value of .
at an error rate of 1775propr property based automatic program repair icse may pittsburgh pa usa table number of independent runs that produced at least one patch for genetic search programs e01 e02 e03 e04 e05 e07 e08 e09 e12 e13 e14 e18 e25 units p r o p s both showedthat4ofthe13repairedentriesweresignificantlybetterin producingrepairswithproperties e1 e3 e4 ande14fromtable2 .
aglobalfisherexacttestandwilcoxon ranksumtestshowed nostatisticalsignificantdifferencebetweenthetestsuites p values of .
whether properties are beneficial is a highly specific topic and we expect it more to be a matter whether the bug is properly covered by the test suite.
we argue that properties can producestrongertestsuitesthanunittests butwhethertheyare applicableandwellimplementedisultimatelyuptothedevelopers.
figure solved entries per test suite and algorithm figure14showsgeneticsearchoutperformingexhaustivesearch in any test suite configuration and most effectively for properties.
nfiguration an dmost effect figure venn diagram of solved entries per suite figure shows the overlap of solvedentries by test suite.
it shows that four entries were uniquely solvable by using only properties and one entry was uniquely solvable by the combined test suite.
all entries solved by unit testshave also been solved by the properties.thisdoesnotnecessarilyimplythatpropertiesare better the patches can still be overfit and are to be evaluated in rq3.
summary rq1 propertiesdonotsignificantlyhelpwithproducingpatches.
inourstudy propertiesfounduniquepatchesthatunittests didnotproduce.thedifferencebetweenresultsingeneticand exhaustive search were greatest for the properties.rq repair speed.
we grouped the results per seed and compared the median time to first result for each test suite.
all twowayhypothesis testsreportedasignificantp valueoflessthan0.
proving that there are significant differences in distributions.
in particular we performed a test2whether properties are faster than unit tests in finding patches which was the case with a pvalueof0.
.thevarghaanddelaneyeffectsizetestshowedan estimate of .
which is considered a medium effect size showing that properties are faster than unit tests.
an overview of the time to first result can be seen in figure .
we would like to stress that similar to some results of rq3 the test suites speedseemstobehaveinsuchawaythattheslowestand hardest test determines the magnitude of search.
properties do not haveasignificant overhead bydesign whichispositivelysurprising.
thecostoftheirexecutioniscompensatedbythespeedupinsearch.
figure distribution of time to first patch per entry summary rq2 geneticsearchfindspatchesfasterforpropertiesthanforunit tests.
the combined test suite also yields combined search speed.
rq manual inspection.
from the sample of patches the authorsagreedon49tobeoverfitand21tobefit.giventheoverall population of and an error rate of we expect to of total patches to be correct.
this results in a total non overfit rate of27 to33 .inparticular patchesinthesamplefoundforunit testswereoverfitin85 ofcases butthepropertieswere overfit in of cases .
the combined test suite overfit in cases.
thesearenotevenlydistributed someprogramsareonlyrepairedoverfitwhileothersarealwayswellfixed.hence wededuct thatofthe13entriesthathavefixes 3to4havenon overfitrepairs.
thisestimatesaneffectiverepair rateof10 orrespectively13 which performs similar to the rates reported by astor 2wilcoxon ranksum with less 1776icse may pittsburgh pa usa matth as p ll gissurarson leonhard applis et al.
and better than genprog .
arja reports an effective repair rate of which we slightly outperform.
atypicalexamplefoundbymanualinspectionwasaddingspacestripping to the addition case of showexpr as seen in figure .
diff git a input expr units.hs b input expr units.hs a input expr units.hs b input expr units.hs showexpr num n show n showexpr num n show n showexpr add a b showexpr a showexpr b showexpr add a b showexpr a filter not .
isspace showexpr b showexpr mul a b showfactor a showfactor b showexpr sin a sin showfactor a showexpr cos a cos showfactor a showexpr var c figure a propr patch showing overfitting on a unit test prop unit showbigexpr bool prop unit showbigexpr strip showexpr expr strip res where res sin .
x .
.
x .
strip filter not .isspace arg expr.sin add mul num .
x num .
expr add add add mul num .
x num .
arg figure the unit test corresponding to the fix in figure thereisasingleunittest seefigure18 toassertaprintedaddition without spaces.
within the patch only the case gets repaired thisisduetotheprecedenceoftheexpressionwhichiscorrectly pickedup.hitherto thechangeintheadditionactuallyremovesall white space and correctly passes the test.
this actually solves the unittestasexpectedandisthereforearguablynot trulyoverfitting.
nevertheless adeveloperwouldperformthestring strippingonall cases notonlyontheaddition.hereweseeashortcomingofthe test suite this would have not been possible if we had a property prop showexpr printnospaces or if we simply had unit tests for all cases.
in other data points where the showexpr had a unified toplevel expression not an immediate pattern match the repair was successful by adding top level string stripping.
we would also like to stress the quality of the patch generated despite overfitting it draws4elements filter tolower isspace .
whichwerenotin the code beforehand and applied them at the correct position.
anotherissueobservedwereemptypatches theseappeared whenthequickcheckpropertiesexhibitedinconsistentbehavior.
wesuspectapropertythattestsfortheidempotencyof simplify seeninfigure13 whichrequiresarandomlygeneratedexpression.
the property is meant to assert that e.g.
x 0gets reduced to 0and not to x .
whether this case or similar ones are tested depends on the randomly created expressions which makes it aninconsistenttest.theseareissues withthetestsuitethatwere uncovered due to the hyper frequent evaluation.
the only way to mitigate this is to provide a handful of unit tests or write a specific expression generatorusedfortheflakyproperty.welabeledempty patches to be overfit as we do not consider them proper repairs.summary rq3 adding propertiesreduced theoverfit ratiofrom to doubling the number of goodpatches.
the resulting effective repairrateof10 to13 iscomparabletoothertools.overfitting appeared despite the use of properties but generally less due to an overall stronger test suite.
discussion overfitting on properties.
similar to the overfitting of empty patches shown in rq3 we had cases of patches where one or more failing properties exhibited inconsistent behavior and an overfit patch was considered a successful patch.
we observed an example that changed the simplification of multiplication to return whenever a variable was in the term.
this satisfies the prop multwith0 always0 propertyand shouldfailotherproperties suchasmultiplicativeassociativity but inrarecases quick check produced examples for the other properties that also evaluate to .
this overfitting shows that a test suite is not betterjust because it is utilizing properties.
apr fitness is still only as good as the test suite properties help define better test suites and well written properties positively influence apr.
exploitableoverfitting.
anoticeablesideeffectofthetoolisthat if the repair overfits it produces numerous bad patches as can be seen from the number of generated proposals.
however the repairs output is not useless despite the overfitting thesuggestedpatchesclearlyshowtheshortcomingsofthe test suite.
the proposed overfit patches help developers with fault localizationandimprovingthetestsuite.inparticular asproperties and unit tests are not exclusive developers can consider a testand repair drivenapproach wheretheyadjustthetestsuiteand program iteratively assisted by the repair tool.
we consider this approach attractive for class room settings where the programs areoflowercomplexityandallowforfastfeedback.whilewedon t expect propr to be enough to solve the tasks forthe students it clearlyshowswheretheproblemsinthetestsorcodeare.exploring class room usage is an interesting direction for future work.
drastically increased search space.
due to the novel approach to finding repair candidates the search space drastically increased as compared to using existing expressions or statements only.
this can be seen with the absence of random search findings.
other studiesshowedatleastsomeresultswithrandomsearch sometimes reportingrandomsearchasmostsuccessful .aswefind many patcheswithexhaustivesearch theproblemsaregenerallysolvable withsmallchanges.thisimpliesthattheonlyreasonforrandom search to yield no results is the increased search space.
this finding motivates further investigating the genetic search anditsoptimizationformorecomplexproblemsthatdonotachieve timelyresultswithexhaustivesearch.weconsideritworthwhile to revisit existing datasets that were not solvable due to the redundancyassumptioninmostrepairtools usingatypedholeapproach.
transferencetojava.
asjavaisthemostprominentlanguagefor apr it begs the question of which results can be transferred from haskellintomoremainstreamapproaches.propertiesaresupported 1777propr property based automatic program repair icse may pittsburgh pa usa byjunit plugins3andcaneasilybeaddedtoanycommontestsuite and build tool.
the positive effects of properties as presented in section only require java programs with sufficient properties.
however the current java ecosystems are not utilizing properties even less sophisticated junit features such as parametrized tests are not widely adopted.
this is in starkcontrast to functional programming communities where tools like quickcheck are popular.
the hole fitting repair approach cannot be easily reproduced for java the javac unlike ghc is not intended to be used as a library.nevertheless javaisstrictlytypedandthebasichole fittingapproach can be integrated using meta programming libraries like spoon .
many challenges remain as java s methods are not pure functions they cannot be just transplanted .
side effects can wreak havoc and just on a technical level polymorphism that is oftenonlyresolvabledynamically bareshugefollow up challenges.
butnotallislostforthejvm repairapproachesthatfocuson the bytecode can easier adapt hole fitting.
in particular one could imagine a tool that produces holes for bytecode and introducesthehole fitsutilizingmorestrictjvmcompilerssuch as closure or scala.
we consider this extension a hard but valuable track for further research.
future work.
the primary research challenge we see is to combineexistingapproacheswiththenewlyintroducedproprholefitting.
a hybrid approach that could produce high churn with techniquesfromastor orarja incombinationwiththe fine grained changes produced by propr could solve a broader range of issues.
specific to haskell is the need to introduce lefthand side definitions i.e.
new pattern matches or functions.
these could be provided by generative neural networks and either beusedasmutationsorasaninitialpopulationofchromosomes.
representingmultipletypesofchangesisonlyamatterofrepresentationwithin thechromosome theremainingsearch fitness and fault localization can be kept as is.
for fault localization we currently use allthe expressions involved in the counter examples.
however it should be possible tousethecoverageinformationandthepassingandfailingtests forspectrum basedfaultlocalizationtonarrowthefault involved expressionsfurthertosuspiciousexpressions ratherthanallthe expressions involved in the failing test.
intermsoffurtherevaluation thenextstepsareusersurveysand experimentsonrealworldapplicationssuchaspandoc4oralex5.
in particular we envision a bot similar to sorald that provides patch suggestions on failing pull requests.
we would like to ask maintainers and the public community to give feedback on the quality of repairs and whether the suggested patches contributed tofaultlocalizationorimprovementsofthetestsuiteevenifnot added to the code.
threats to validity internal threats.
we addressed the randomness in our experiments by running runs with different seeds according to the suggestionsofarcuriandfraser .thetoolusedinourexperiment could contain bugs.
we ve published it under a foss license gain further insights and suggestions from the community.
the experimentanddatasetmaycontainmistakes whichweaddressby providing a reproduction package and open source the experiment and data.
the package also contains notes on the data preparation for the experiment.
external threats.
the dataset is based on student data which could be considered artificial.
we stress that student data has been usedinliteratureforprogramrepairpreviously .a real world study on program such as pandoc is part of future work.
pandoc a popular haskell document converter is rich in properties that test e.g.
for symmetry over conversions.
conclusion the goal of this paper is to introduce a new automatic program repairapproachbasedon typesandcompilersuggestions inadditiontoutilizingpropertiesfor repairfitnessandfaultlocalization.
to that end we implemented propr a haskell tool that utilizes ghcforpatch generationandcanevaluatepropertiesaswellas unittests.weprovidedadatasetwith30programsandtheirunit tests and properties.
on this dataset we performed an empirical studytocomparetherepairratesfordifferenttestsuitesandsearchalgorithms and manually inspect the generated patches.
our analysis of patches show that we reach an effective repair rate of comparable to other state of the art tools buthaveareducedrateofoverfitting from85 to63 whenapplying properties .
the novel approach for patch generation produces a greatly increased search space and promising patches on manual inspection.
we observed that properties did not increase the numberofprogramsforwhichpatcheswerefound butsolutions werelessoverfitandfoundfaster.overfittingbasedonunittests persisted into the combined test suite.
similarly we have observed that properties can produce cases of overfitting too.
ourresultsattesttothestrongerutilizationoflanguage features for patch generation to overcome the redundancy assumption i.e.
only reusing existing code.
using the compiler s information on types and scopes the created patches are semantically correct and comeinamuchgreatervariety whichwasreportedasamissing feature for many apr tools.
our manual analysis motivates to use the generated patches if not directly applicable as guidance for fault localization or to improve the test suite.
online resources propr isavailableongithubundermit licenseat com tritlo propr.thereproductionpackagewhichincludesthe data evaluation and a binary of propr is available on zenodo