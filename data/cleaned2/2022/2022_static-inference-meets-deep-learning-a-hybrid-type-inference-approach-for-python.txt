static inference meets deep learning a hybrid type inference approach for python yun peng thechineseuniversityofhongkong hong kong china ypeng cse.cuhk.edu.hkcuiyun gao harbin institute of technology shenzhen china gaocuiyun hit.edu.cnzongjie li harbin institute of technology shenzhen china lizongjie stu.hit.edu.cn bowei gao harbin institute of technology shenzhen china hit.edu.cndavid lo singapore management university singapore davidlo smu.edu.sgqirun zhang georgia institute of technology united states qrzhang gatech.edu michael lyu thechineseuniversityofhongkong hong kong china lyu cse.cuhk.edu.hk abstract typeinferencefordynamicprogramminglanguagessuchaspython is an important yet challenging task.
static type inference techniques can precisely infer variables with enough static constraints but are unable to handle variables with dynamic features.
deep learning dl based approaches are feature agnostic but they cannot guarantee the correctness of the predicted types.
their performance significantly depends on the quality of the training data i.e.
dl models perform poorly on some common types that rarely appear in the training dataset .
it is interesting to note that the static and dl based approaches offer complementary benefits.
unfortunately toourknowledge precisetypeinferencebasedonboth static inference and neural predictions has not been exploited and remains an open challenge.
in particular it is hard to integrate dl models into the framework of rule based static approaches.
this paper fills the gap and proposes a hybrid type inference approach named hityper based on both static inference and deep learning.specifically ourkeyinsightistorecordtypedependencies among variables in each function and encode the dependency informationin typedependencygraphs tdgs .basedontdgs we can easily integrate type inference rules in the nodes to conduct static inference and type rejection rules to inspect the correctness of neural predictions.
hityper iteratively conducts static inference and dl based prediction until the tdg is fully inferred.
experimentsontwobenchmarkdatasetsshowthathityperoutperforms state of the artdlmodelsbyexactlymatching10 morehuman corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
anincreaseof morethan30 oninferringraretypes.consideringonlythestaticpartof hityper itinfers2 moretypesthanexistingstatictypeinferencetools.
moreover hityper successfully corrected seven wrong human annotations in six github projects and two of them have already been approved by the repository owners.
introduction dynamically typed programming languages such as python are be comingincreasinglyprevalentinrecentyears.accordingtogithuboctoverse2019and2020 pythonoutranksjavaandc c and becomes one of the most popular programming languages.
the dynamic features provide more flexible coding styles and enable fast prototyping.however withoutconcretelydefinedvariabletypes dynamically typedprogramming languagesface challengesin ensuringsecurityandcompilationperformance.accordingtoarecent surveybyjetbrains statictypingoratleastsomestricttype hints becomes the top desired feature among python developers.
to address such problems some research adopts design principles ofstaticallytypedprogramminglanguages .forexample reusingcompilerbackendofthestaticallytypedlanguages and predicting types for most variables .
moreover python officially supports type annotations in the python enhancement proposals pep .
type prediction is a popular task performed by existing work.
traditional static type inference approaches and typeinferencetoolssuchaspytype pysonar2 andpyre infer cancorrectlyinfertypesforthevariableswithenough static constraints e.g.
for a 1we can know the type of ais int but are unable to handle the variables with few static constraints e.g.mostfunctionargumentsordynamicevaluationssuch aseval .
with the recent development of deep learning dl methods w e canleverage moretypehints suchasidentifiers andexistingtype annotationstopredicttypes.manydl basedmethods havebeenproposed andtheyshowsignificantimprovement ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yun peng cuiyun gao zongjie li bowei gao david lo qirun zhang and michael lyu comparedwithstatictechniques .whiledl basedmethodsare effective they face the following two major limitations i noguaranteeofthetypecorrectness.pradel etal.
findthat thepredictionsgivenbydlmodelsareinherentlyimpreciseasthey returnalistoftypecandidatesforeachvariable amongwhichonlyonetypeiscorrectunderacertaincontext.besides thepredictionsmadebydlmodelsmaycontradictthetypingrules leadingtotype errors.
even the state of the art dl model typilus generates about10 ofpredictionsthatcannotpassthetestofatypechecker.
thetypecorrectnessissuemakesthedl basedmethodshardtobe directlydeployed intolarge codebaseswithout validation.recent work leverages a search based validation in which a type checkerisusedtovalidateallcombinationsoftypesreturnedbydl models and remove those combinations containing wrong types.however these approaches cannot correct the wrong types but only filter them out.
ii inaccurate prediction of rare types.
rare types refer to the typeswithlowoccurrencefrequenciesindatasets .low frequency problem has become one of the bottlenecks of dl based meth ods .
for example typilus s accuracy drops by more than for the types with occurrence frequencies fewer than100 comparedtotheaccuracyofthetypeswithoccurrence frequencies more than .
more importantly rare types totally account for a significant amount of annotations even though each of them rarely appears.
we analyze the type frequencies of twobenchmarkdatasetsfromtypilus andtype4py andfind along tail phenomenon i.e.
the top types in the two datasets alreadyaccountfor54.
and67.
ofthetotalannotations and more than and types in two datasets are rare types with frequency proportions less than .
.
they still occupy .
and25.
oftotalannotationsforthetworespectivedatasetsand become the long tail of type distributions.
toremedythelimitationsofthepreviousstudies thispaperproposesahybridtypeinferenceframeworknamedhityper which conducts static type inference and accepts recommendations from dl models static dl .
we propose a novel representation named type dependency graph tdg for each function where tdgrecords the type dependencies among variables.
based on tdg we reformulate the type inference task into a blank filling problem where the blanks variables are connected with dependencies so thatbothstaticapproachesanddlmodelscanfillthetypesinto blanks .
hityper infers the blanks in tdg mainly based on static type inference which automatically addresses dl models rare type prediction problem since static type inferencerules are insensitive to type occurrence frequencies.
hityper extends the inference ability of static type inference by accepting recommendations from dl models when it encounters some blanks that cannot be statically inferred.
different from the search based validation by pradel et al.
hityper builds a series of type rejection rules to filter out allwrongpredictionsontdg andthencontinuestoconductstatic type inference based on the reserved correct predictions.
we evaluate hityper on two public datasets.
one dataset is released by allamanis et al.in the paper of typilus and the other is manytypes4py one large dataset recently released forthistask.experimentresultsshowthathityperoutperforms bothsotadlmodelsandstatictypeinferencetools.compared figure1 typedependencygraphoftheparse fromcode.
.
withtwosotadlmodelstypilusandtype4py hityperpresents a boost on the performance of overall type inference a n da6 boost on the performance of certainkinds of type inferencesuchasreturnvaluetypeinferenceanduser definedtypeinference.withouttherecommendationsfromneuralnetworksand onlylookingat thestatictypeinference part hitypergenerally outputs more annotations with higher precision than current static type inference tools pyre and pytype .
hityper can also identify wrong human annotations in real world projects.
we identify seven wrong annotations in six projects of typilus s dataset and submit pull requests to correct these annotations.
two project owners have approved our corrections.
contributions.
our contributions can be concluded as follows to the best of our knowledge we are the first to proposea hybrid type inference framework that integrates static inference with dl for more accurate type prediction.
we design an innovative type dependency graph to strictlymaintain type dependencies of different variables.
we tackle some challenges faced by previous studies and design aseries of typerejection rules and atype correction algorithm to validate neural predictions.
extensiveexperimentsdemonstratethesuperiorperformance of the proposed hityper than sota baseline models and static type inference tools in the task.
motivating example listing illustrates an example of code snippet from the webdnn project.1resultsofseveralbaselines includingstatictypeinference authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static inference meets deep learning a hybrid type inference approach for python icse may pittsburgh pa usa techniques pytypeandpysonar2 andstate of the artdlmodelstypilus are depicted in table .
src graph transpiler webdnn graph shape.py 2def parse text normalized text normalize text text tmp ast.literal eval normalized text shape placeholders for i t in enumerate tmp if isinstance t str pt placeholder label t placeholders pt elif isinstance t int pt t shape.append pt return shape placeholders listing a function from webdnn.
static inference.
according to table we can find that the static type inference techniques fail to infer the type of the argument textsince the argument is at the beginning of data flow withoutanyassignmentsordefinitions.onecommonsolutionto infer the type is to use inter procedural analysis and capture the functions that call parse .
however tracing the functions in programs especially in some libraries is not always feasible.
as for the returnvalue by analyzingthe data flow anddependencies betweenvariables staticinferencecaneasilyidentifythat shape line5 and placeholders line6 consistofthereturnvalue.
it can recursively analyze the types of the two variables and fi nally output the accurate type of the return value.
indeed both pysonar2andpytypecancorrectlyinferthatthereturnvalueisa tuple containing a list and dict.
dl approach.
the dl model typilus accurately predicts thetypeas straccordingtothesemanticsdeliveredbytheargument textandcontextualinformation.thecaseillustratesthatdl modelscanpredictmoretypes thanstaticinference.however typilusfailstoinfer thetypeofthereturnvalueof parse .current dl models cannot maintain strict type dependencies between variables.
therefore typilus only infers the type as a tuple but cannot accuratelypredictthetypesinsidethetuple.whenaddingatype checkertovalidatetypilus spredictions itsargumentpredictionis reserved since it does not violate any existing type inference rules.
however forthereturnvalue its2ndand3rdtypepredictionsin table1bytypilusarerejectedsincethereturnvalueof parse explicitlycontainstwoelementswithdifferenttypes.the1stprediction is also rejected because it contains the type optional that does not appear in the return value.
in this case the model does not produce any candidate type for the return value.
static dlapproach.
forthecodeexample wefindthatstatic inference is superior than dl models when sufficient static con straintsordependenciesaresatisfied whiledlmodelsaremore applicable for the types lacking sufficient static constraints.
given the code hityper first generates the tdg of it as shown in fig.
and tries to fill all nodes in tdg with corresponding types blank filling .fortheargument text hityperidentifiesthatthetype cannotbeinferredbystaticinference itdoesnothaveanyinput edges andasksdlforrecommendations.hityperdoesnotdirectly output thepredictions from dlas final typeassignments.
instead table1 predictionresultsofdifferentbaselinesforlisting1.
approach baseline argument return value groundtruthstrtuple dict staticpysonar2 ?
tuple dict pytype ?
tuple dl typilus .
str1.
tuple optional tuple any .
tuple .
tuple static dlhityper typilus strtuple dict hitypervalidatestheprediction scorrectnessandacceptstheresultonlyifnotypeinferencerulesareviolated.whenpredicting the return value hityper captures its type dependencies based on the tdg it connects with two input nodes and directly leverages staticinferencetoinferthetype.forthiscase dlpredictionsare not required largely avoiding the imports of wrong types.
hityper in thissection wefirst introducethe definitionsused in hityper and then elaborate the details of hityper.
.
definition of types fig.
shows the definitions of different types according to the official documentation of python and its type checker mypy .
note that we remove the objecttype and anytype since they are not strict static types.
in general all types can be classified into built in types and user defined types.
built in types are predefined inthelanguagespecificationofpythonwhileuser definedtypes are created by developers.
developers can define the operations or methodssupportedbyauser definedtypeandoverwritesomebuiltin operations for their user defined types.
for example developers candefinean add methodinaclasssothattwotypesderived from this class can be directly added together using the built in operator .
the operation is called operator overloading.
we create a subcategory for user defined types with operator overloading behaviors since they have different type inference rules.
the type categories showed in fig.
are widely used in most static type inference techniques .
differently dl based studies generally categorize the types into common types andraretypes basedonapre definedthresholdofoccurrencefrequencies e.g.
in .
for a fair comparison we also follow this definition for evaluation.
by analyzing the rare types in two publicdatasetstypilusandmanytypes4py wefindthat79.
and .
ofraretypesactuallyareuser definedtypes.becausestatic inference technique is frequency insensitive and cannot recognize rare types we mainly add supports for user defined types on static inference side of hityper.
.
overview hityper accepts python source files as input and outputs jsonfiles recording the type assignment results.
fig.
illustrates its authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yun peng cuiyun gao zongjie li bowei gao david lo qirun zhang and michael lyu type dependency graph generatorblank type dependency graph tdg forward type inference patially inferred tdgtdg with hot type slots deep neural network recommended tdg type dependency graph generation static type inferencefinal output fully inferred tdgsimilarity based type correction backward type rejection source files hot type slots finder neural type prediction figure2 overallarchitectureofhityper.blacksolidnodes hollownodes rednodesandyellownodesinthetypedependency graphsrepresentinferredtypeslots blanktypeslots hottypeslots andthetypeslotsrecommendedbydlmodel respectively.
type u none type elementary type int float str bool bytes generic type a list tuple dict set callable generator union b builtin type b u user defined type u all classes and named tuples in code o overloading user allclasseswith defined type o operator overloading in code figure types in python.
overall architecture.
hityper includes three major components typedependencygraphgeneration statictypeinference andneural type prediction.
the static type inference component comprisestwo main steps i.e.
forward type inference and backward type rejection.
typedependencygraph tdg generation.
specifically given apythonsourcefile hityperfirstgeneratestdgsforeachfunction andidentifiesalltheimporteduser definedtypes sec.
.
.tdg transformseveryvariableoccurrenceandexpressionintonodesandmaintainstypedependenciesbetweenthemsothatstaticinference and dl models can work together to fill types into it.
static type inference forward type inference.
to maintainthecorrectnessofpredictionresults hityperfocusesoninferring types using static inference.
given a tdg hityper conducts forwardtypeinferencebywalkingthroughthegraphandimplementing the type inference rules saved in each expression node sec.
.
.however duetothelimitationofstaticinference inmost cases hityper can only infer partial type slots i.e.
variables indicated as blacksolid nodes in the partially inferred tdg in fig.
whiletheblanknodesdenotethetypeslotswithoutsufficientstatic constraintsandremainingunsolved.tostrengthentheinference ability of hityper we ask dl models for recommendations.
neural type recommendation.
through the hot type slot finder hityper identifies a key subset of the blank nodes as hot type slots marked as red nodes in fig.
for obtaining recommendations from dl models.
hityper also employs a similarity basedtype correction algorithm to supplement the prediction of userdefined types which are the primary source of rare types sec.
.
.
the types recommended by the neural type prediction component are filled into the graph resulting in the recommended tdg.
statictypeinference backwardtyperejection.
hityper utilizestyperejectionrulestovalidatetheneuralpredictionsinhot typeslots sec.
.
.thenittraversesthewholetdgtotransmit therejectedpredictionsfromoutputnodestoinputnodessothatall nodesintdgcanbevalidated.finallyhityperinvokesforward type inference again to infer new types based on the validated recommendations.
the interactions between forward type inference and backward type rejection could iterate until the tdg reaches a fixed point i.e.
the types of all nodes do not change any more.
meanwhile theiterationsbetweenstaticinferenceandneuralpredictioncan repeat several times until all type slots are inferred or a maximum iteration limit is reached.
.
type dependency graph generation this section introduces the creation of type dependency graph tdg whichdescribesthetypedependenciesbetweendifferent variablesinprograms.fig.4presentsthesyntaxofalltheexpressions that generate types in python where each expression correspondstoanodeintheast abstractsyntaxtree .giventheast of a program hityper can quickly identify these expressions.
the expressionnodesconstituteamajorpartoftdg.wedefinetdg as below.
definition.
wedefineagraph g n e asatypedependency graph tdg where n ni is a set of nodes representing all variables and expressions in source code and eis a set of directed edgesofni njindicatingthe typeof njcanbe solvedbasedon thetypeofnibytypeinferencerules.wealsodenote niistheinput node ofnjandnjis the output node of nihere.
the tdg contains four kinds of nodes symbolnodes represent all the variables for which the types needtobeinferred.wealsouse typeslots toindicatesymbol nodes in the following sections.
expression nodes represent all the expressions that generate types as shown in fig.
.
branchnodes represent the branch of data flows.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static inference meets deep learning a hybrid type inference approach for python icse may pittsburgh pa usa e expr v c eblope enumope ecmpope ebitope e ... e e e ... e e e ... e eforeine e efore eine eforeine e e ... e e e.v v variables all identifiers in code c constants all literals in code blop boolean operations and or not numop numeric operations add sub mult div mod uadd usub bitop bitwise operations lshift rshift bitor bitand bitxor floordiv invert cmpop compare operations eq noteq lt lte gt gte is isnot in notin figure the syntax of expressions for typing in python mergenodes represent the merge of data flows.
hityper creates a node for every variable occurrence instead of every variable in tdg because python s type system allows variables to change their types at run time.
similar to static single assignment ssa hityper labels each occurrence of a variable with the order of occurrences so that each symbol node in the tdg has a format of name order lineno to uniquely indicate avariableoccurrence.forexample infig.
wecreatethreesymbol nodes pt0 pt1 pt2 for variable ptas it appears three times in listing line and .
importanalysis.
beforeestablishingtdgforeveryinputfunction hityper first conducts import analysis to extract all userdefined types so that it can distinguish the initialization of user defined types from regular function calls.
hityper first collectsall classes in source files which constitute the initial set of user defined types.
then it analyzes all local import statements such as frompackageimportclass andaddstheimportedclassesinto the user defined type set.
for all global import statements suchas import package hityper locates the source of this package and adds all the classes and named tuples in the source into theuser defined type set.
for each imported class hityper solves thelocationofexternalsourcefilesandcheckswhetheroperator overloading methods exist in this class.
type dependency graph generation.
given the ast of inputcodeandalltheuser definedtypesextractedbyimportanalysis hityper creates tdg for each function based on the main logicshown in alg.
.
hityper first locates all the variables and expressions in the code by traversing the whole ast.
specifically to visit each ast node hityper employs the astvisitor provided by python smodule ast .hityperidentifiesexpressionsaccording to the definitions of expression nodes in python as depicted in fig.
andrecordseveryvisitedexpressionnodeusinganexpression stack.
whenever hityper identifies an expression node linealgorithm type dependency graph generation input the ast of given function func ast output type dependency graph of the given function tg initialize an expression stack ex stack initialize a variable stack var stack for allnode func ast nodeis not visited do handle expression nodes ifnode.type expressions then ex stack.push node ex node new ex node visit node .operands ex stack.pop node ifnotex stack.empty then tg.addedge ex node ex stack.top end if tg.addnode ex node end if handle symbol nodes ifnode.type ast.name then sym node new symbol node ifnode.ctx write then tg.addedge ex stack.top sym node else tg.addedge var stack.top sym node tg.addedge sym node ex stack.top end if var stack.push sym node tg.addnode sym node end if handle branch and merge nodes ifchecktypebranch node then branch node new branch node tg.addnode branch node ctx1 ctx2 branch ctx visit node .left ctx1 visit node .right ctx2 end if ifchecktypemerge node then merge node new merge node tg.addnode merge node ctx merge ctx1 ctx2 end if end for it builds a same node in the current tdg and pushes it into the expressionstack.hityperwillthenrecursivelyvisitstheexpression soperandstocapturenewexpressionnodesuntilitencounters a variable node line which is the leaf node of the ast.
hityperbuildsasymbolnodeintdgforeachvisitedidentifier node of ast and maintains a variable map to record all the occurrencesofeachvariable.theastalreadyindicatesthecontextof each variable occurrence i.e.
whether readorwrite.
i if the variable context is read hityper will obtain the last occurrence of the variable according to the maintained variablemap under the current context.
it then creates an edge from the symbolnodeofthelastoccurrencetothesymbolnodeofthecurrent variable line .
ii if the variable context is write hityper will fetch the value from thelast expressionin theexpression stackand buildan edge authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yun peng cuiyun gao zongjie li bowei gao david lo qirun zhang and michael lyu connecting from the expression node to the symbol node of the current variable line .
analogous to regular data flow analysis hityper also checks whether the data flow branches line or merges at certain locations line .
in tdg each symbol node keeps a list of candidate types while each expression node includes type inference rules and type rejection rules.
when hityper walks through tdg the rules will be activated to produce new types.
thus types can flowfrom arguments to return values.
by traversal hityper obtains the types of each symbol node and outputs the type assignment.
the leveraged typeinferencerulesandtyperejectionrulesaredetailedinthenext subsections.
.
static type inference thissectiondescribesthetypeinferenceandrejectionrulesintegrated in expression nodes which are the key component of our statictypeinference.fig.5denotesallthetypeinferenceandrejection rules used in static type inference.
each rule consists of some premises contentsabovetheline andconclusions contentsbelow the line .
they obey the following form turnstilelefte .
inthisform iscalledthecontext whichincludesliststhatassign typestoexpressionpatterns.
eistheexpressionshowedinfig.
andweusee1 ... e ntorepresentdifferentexpressions.
isthetype showed in fig.
.
we use 1 ... nto represent different types.
a rule under this form is called a type judgement ortype assignment.
ourgoalistogetthecontext thatassignstypestoallthevariables in code.
the premises of each rule in fig.
are the types of input nodes 1 2 ...that constructs an expression and the valid type set tildewide for thecurrentoperation.usuallytypeinferencerulesonlyhaveone conclusion whichistheresulttypeofcurrentexpression.however aswealsoinvolveneuralpredictionsintdgandusetyperejection rulestovalidatethem theconclusionsofeachruleinfig.5have twoparts theresult typeof currentexpressionnode and2 the validatedtypesofinputnodes.
somerulesmaynothavethesecond part because they accept any input types.
theresulttypeofthecurrentexpressionnodeiswhattraditional statictypeinferencetechniquesusuallyinfer.wedenoteitas forwardtypeinference.however thereexisttypesthatarenotallowedtoconductcertainoperations whichareguidedby typeconstraints.
whenatypeconstraintisviolated e.g.
addinganintegertoastring traditionalstaticinferencetechniques throwtypeerrors.
for the wrongly predicted cases hityper does not directly throw a type error since it accepts recommendations from dl models.
to sanitize the recommendations from dl models we create type rejection rules to validate and remove the wrong predictions in input nodes.
we call this as backward type rejection.
forward type inference.
hityper starts forward type inferencewith thenodes thatdo nothaveinput nodesin tdg.itgraduallyvisits allnodes inthe graphandactivates correspondingtype inferencerulesiftheirpremisesaresatisfied i.e.
allinputnodesare fully inferred.
this is the forward traversal of tdgs.
as forward type inference in hityper is similar to traditional static type inferencetechniques weonlydiscussthe ruleforwhichhityperhasaspecialstrategy.thepremiseofthe rulerequiresthe typeofcallees whichisbeyondthescopeofcurrentfunctions.this premiseisonemajorbarrierformoststaticinferencetechniques to fully infer a program due to a large number of external apisin python programs .
hityper only focuses on inferring thetypes offunctionswith explicitimplementationin thecurrent source code in which the tdgs of the functions are connected.
hityperdoesnotinferexternalcallsfortworeasons dlmodels perform well on predicting the types of commonly used apis that frequently occur in the training set python maintains a typeshed project to collect the type annotations of frequently used modules so hityper can directly access the types.
backward type rejection.
an input type in an expression must fulfill two constraints before it can conduct the expression it must be the valid type to conduct a certain expression it must have a valid relationship with other input types.
hityperrejects the input types that violate these two constraints.
it firstchecks whether the type is valid for an expression.
we indicates valid types for each expression as tildewide in fig.
.
for example in in notin rule thetypesof e2mustbeiterableso intisnotallowed and should not be in the valid type set tildewide .
then hityper checks whether the relationships between all inputs are valid.
apart from valid types for a certain operation some operations also require theinputstosatisfyacertainrelationship.forexample in rule the two operands must have the same type.
for types of two inputs intandstr eventhoughtheyareinthevalidtypesetof this operation they are still rejected because they are not the same type.
therefore in the rule the final valid input types are the intersection of all input type sets 1 2and valid type set tildewide .
typerejectionrulescanvalidateandrejecttheinputtypesof an operation.
however the input types are the results of previous operations sothetyperejectionprocesswillalsoaffecttheinput types of previous operations.
to thoroughly removethe influence of wrong types hityper also rejects the input types that resultin the rejected types according to forward type inference rules.
hitypergraduallyvalidatesalltypeslotsbystartingfromthetype slots without output edges and producing the rejected input types.
then it traverses other slots until the whole tdg is visited.
this is the backward traversal of tdgs.
correctness.
different from the dl based approaches hitypercanalwaysguaranteethecorrectnessofitstypeassignmentsbasedonstaticinference.accordingtothearchitectureof hityper in fig.
the type assignments generated by hityper have two cases if the static inference can successfully handle a program hityper does not need to invoke dl models to give type recommendations.
consequently the type assignments fully based on the inference rules are sound because they are collected from the python official implementation cpython and if thestaticinferencecannotfullyinferaprogramandthedlmodels areinvokedtoprovidetyperecommendations sec.
.
hityper utilizestyperejectionrulestovalidatetherecommendationsand then calls the type inference rules again to infer the remainingtypes.
in this case our rejection rules thoroughly eliminate the influence of wrong recommendations and the final results are also producedbystaticinference.therefore hityperalwaysmaintains the type correctness.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static inference meets deep learning a hybrid type inference approach for python icse may pittsburgh pa usa v dom turnstileleftv variable turnstileleftc constant turnstilelefte turnstilelefte.v .v attribute turnstilelefte1 1 turnstilelefte2 2 tildewide bool int o turnstilelefte1bitope2 tildewide turnstilelefte1 1 tildewide turnstilelefte2 2 tildewide lshift rshift turnstilelefte1 1 tildewide bool int float o turnstilelefte2 2 prime getmoreprecisetype 1 tildewide 2 tildewide turnstilelefte1numope2 prime turnstileleft 1 tildewide turnstileleft 2 tildewide numeric operations turnstilelefte1 1 tildewide 1 int bool turnstilelefte2 2 tildewide 2 list tuple o turnstilelefte1numope2 2 tildewide 2 turnstilelefte1 1 tildewide 1 turnstilelefte2 2 tildewide 2 mult turnstilelefte1 1 turnstilelefte2 2 tildewide list tuple o turnstilelefte1cmpope2 bool turnstilelefte1 1 2 tildewide turnstilelefte2 1 2 tildewide lt lte gt gte turnstileleftu e1 ... e n u class instantiation turnstilelefte1 1... turnstileleften n turnstileleft e1 ... e n tuple turnstileleft list turnstileleft e1 ... e n set tuple list set turnstilelefte tildewide a str bytes prime getelementtype tildewide turnstileleftforvine prime turnstilelefte tildewide comprehension turnstileleftforvine1 1 turnstilelefte2 2 turnstileleft e2 forvine1 generator generator turnstileleftforvine1 1 turnstilelefte2 2 turnstileleft forvine1 list turnstileleft e2 forvine1 set list set comprehension turnstilelefte1 1 turnstilelefte2 2 turnstilelefte1blope2 union boolean operations turnstilelefte1 1 turnstilelefte2 2 tildewide bool int set o turnstilelefte1bitope2 tildewide turnstilelefte1 1 tildewide turnstilelefte2 2 tildewide bitor bitand bitxor turnstilelefte1 1 turnstilelefte2 2 tildewide list tuple o turnstilelefte1numope2 tildewide turnstilelefte1 1 2 tildewide turnstilelefte2 1 2 tildewide add turnstilelefte1 1 turnstilelefte2 2 tildewide set o turnstilelefte1numope2 tildewide turnstilelefte1 1 2 tildewide turnstilelefte2 1 2 tildewide sub turnstilelefte1 1 turnstilelefte2 2 turnstilelefte1cmpope2 bool eq noteq is isnot turnstilelefte1 1 turnstilelefte2 2 tildewide str bytes list tuple set dict generator turnstilelefte1cmpope2 bool turnstilelefte2 2 tildewide in notin turnstilelefte turnstilelefte1 1... turnstileleften n tildewide callable prime getreturntype tildewide turnstilelefte e1 ... e n call turnstilelefte1 1... turnstileleften n turnstileleft e1 e2 ... e n en dict dict turnstilelefte1 1 turnstilelefte2 2 tildewide 1 dict prime getvaluetype 1 tildewide 1 turnstilelefte1 prime turnstilelefte1 1 tildewide 1 subscript turnstileleftforvine1 1 turnstilelefte2 2 turnstilelefte3 3 turnstileleft e2 e3 forvine1 dict dict comprehension turnstilelefte1 1 turnstilelefte2 2 tildewide 1 a str bytes tildewide 2 int bool prime getelementtype 1 2 turnstilelefte1 prime turnstilelefte1 1 tildewide 1 turnstilelefte2 2 tildewide 2 slice figure type inference and rejection rules of expressions in python .
neural type recommendation hityper conducts static type inference based on type inference rules when static type inference can fully infer all the variablesin tdg.
however some variables are hard to be statically typedso that hityper only gets a partially inferred tdg.
in this case hityper asks dl models for recommendations.
the neural typerecommendation part of hityper includes two procedures hot type slot identification and similarity based type correction.
hot typeslot identification.
somevariablescanimpactthe types of many other variables because they locate at the beginning of the data flow or possess type dependencies with many variables.
wecallthesevariablesas hottypeslots.giventhetypesofhottypeslots static type inference techniques can infer the remaining type slots.therefore tooptimizethetypecorrectnessof hityper dl models are only invoked on the hot type slots instead of all the blank type slots.
toidentifythehottypeslots hityperfirstremovesslotsalready filled by static type inference and obtains a sub graph with allthe blank type slots.
then hityper employs a commonly useddominator identification algorithm semi nca to capture all dominators in the sub graph.
a node xdominiating another node yinagraphmeansthateachentrynodeto ymustpassx.thus ifa type slotxdominates another type slot y y s type can be inferred fromx stype.
hitypergraduallyremovesthetypeslots yfrom authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yun peng cuiyun gao zongjie li bowei gao david lo qirun zhang and michael lyu table comparison with the baseline approaches.
top of hityper means it accepts candidates from deep neural networks in type recommendation phase.
the neural network in hityper is the corresponding comparison dl model.
dataset type category approachtop top top exact matchmatch to parametricexact matchmatch to parametricexact matchmatch to parametric manytypes4pyargumentnaive baseline .
.
.
.
.
.
type4py .
.
.
.
.
.
hityper .
.
.
.
.
.
return valuenaive baseline .
.
.
.
.
.
type4py .
.
.
.
.
.
hityper .
.
.
.
.
.
local variablenaive baseline .
.
.
.
.
.
type4py .
.
.
.
.
.
hityper .
.
.
.
.
.
allnaive baseline .
.
.
.
.
.
type4py .
.
.
.
.
.
hityper .
.
.
.
.
.
typilus s datasetargumentnaive baseline .
.
.
.
.
.
typilus .
.
.
.
.
.
hityper .
.
.
.
.
.
return valuenaive baseline .
.
.
.
.
.
typilus .
.
.
.
.
.
hityper .
.
.
.
.
.
allnaive baseline .
.
.
.
.
.
typilus .
.
.
.
.
.
hityper .
.
.
.
.
.
algorithm type correction of user defined types input variable name name valid user defined type set s type string recommended by deep neural networks t penaltyaddedforname typesimilaritytoalignwithtype type similarity penalty output corrected type of current variable ct ift sor isbuiltin t then ct t else largest sim largest type none tw bpe t namew bpe name foreachpt sdo ptw bpe pt ifsim ptw tw largest sim then largest sim sim ptw tw largest type pt end if ifsim ptw namew penalty largest sim then largest sim sim ptw namew largest type pt end if end for ct largest type end if thesub graphuntilnotypeslotscanberemoved.inthesmallest sub graph each type slot is not dominated by other type slots and alltheslotsarehottypeslots.forthesetypeslots hityperaccepts type recommendations from dl models.
similarity basedtypecorrectionforuser definedtypes.
dl models provide one or more type recommendations for eachhot type slot depending on the strategy top or hityper uses.
some dl models treat user defined types as oov tokens and do not predict the types while other models directly copy user defined types from the training set but fail to predict those never appearing in the training set.
we propose to complementtherecommendationofuser definedtypesusingthe similarity basedtypecorrectionalgorithmshowninalg.
.note that hityper only focuses on replacing the explicitly incorrect user defined types i.e.
those never imported or defined in current source file with the most similaruser defined types collected by import analysis.
specifically iftherecommendedtypedoesnotbelongtobuiltin types hityper checks whether the type appears in the userdefinedtypesetcollectedfromimportanalysis line1 .ifthecheck result is false the type will be regarded as explicitly incorrectand should be corrected.
for these incorrect user defined types hityperreplacesthemwiththemostsimilarcandidateintheuserdefinedtypeset.hityperemploysword2vec toembedtwo types and the variable name into word embeddings and calculates the cosine distance as the similarity of the two types line .
for the oov tokens hityper splits them into subtokens using the bpe algorithm line .
finally hityper chooses the type candidate with the largest similarity to fill the user defined type line .
evaluation in the section we answer the following research questions rq1 how effective is hityper compared to baseline approaches?
rq2 can hityper well predict the rare types?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static inference meets deep learning a hybrid type inference approach for python icse may pittsburgh pa usa table type distribution in the test set.
rare indicates rare types and user indicates user defined types.
category total rareuser argreturn local typiluscount prop.
type4pycount prop.
rq3 what is the performance of the static type inference component in hityper?
.
experimental setup dataset.
we used the two python datasets mentioned in sec.
forevaluation.oneisthe typilus sdataset releasedbyallamanis et al.
and the other one is manytypes4py released by mir et al.
with the number of different types in the test set and more detailed statistics shown in table and sec.
respectively.
evaluation metrics.
following the previous work we choose two metrics exact match andmatch to parametric for evaluation.thetwometricscomputetheratioofresultsthat exact match completely matcheshumanannotations.
matchto parametric satisfy exact match when ignoring all the type parameters.
forexample list andlist areconsideredasmatched under this metric.
baseline approaches.
to verify the effectiveness of the proposedhityper wechoosefivebaselineapproachesforcomparison anaivebaseline.itrepresentsabasicdata drivenmethod.we buildthisbaselinefollowingthework whichmakespredictions by sampling form the distribution of the most frequent ten types.
pytype andpyreinfer .theyaretwopopularpython static type inference tools from google and facebook respectively.
typilus andtype4py .typilusisagraphmodelthatutilizes code structural information.
type4py is a hierarchical neural network that uses type clusters to predict types.
implementation of hityper the entire framework of hityper is implemented using python which contains more than 000linesofcode.weobtainalltypingrulesandrejectionrules frompython sofficialdocumentation anditsimplementation cpython2.weuseword2vecmodelfromthegensimlibrary as the embedding when calculating the similarity between two types.wetraintheword2vecmodelbyutilizingalltheclassnames andvariablenamesinthetrainingsetoftypilus.thedimension of the word embeddings and size of the context window are set as and respectively.
due to the small training corpus for word2vec wechooseskip gramalgorithmformodeltraining .
wechoosetypilusandtype4pyastheneuralnetworkmodelfrom which hityper accepts type recommendations.
we choose the exact hyper parameters for typilus and type4py used in the original papers.
we run all experiments on ubuntu .
.
the system has a intel r xeon r cpu .4ghz with32gbramand2nvidia titan v gpus with 12gb ram.
.
rq effectiveness of hityper weevaluatetheeffectivenessof hityperconsideringdifferenttype categories including arguments local variables and return values.
the results are depicted in table .
thenaivebaselineachieveshighscores regardingthetop 5exactmatchmetricfordifferenttypecategories some of which are even close to the performance of dl models.
sincethenaivebaselineonlypredictstypeswithhighoccurrence frequencies in the dataset the results indicate the challenge ofaccurately predicting rare types.
typilus and type4py mitigatethe challenge by using similarity learning and type clusters and achieve .
regarding the top exact match metric.
hityper furtherimprovesthemetricby11 and15 comparedwithtypilus and type4py respectively.
hityper also enhances the top match toparametricmetricby17 and11 comparedwithtypilusand type4py respectively.theimprovementindicatestheeffectiveness of hityper in accurate type prediction.
besides hityper presents better performance than the respectivedl models regarding thetop metrics demonstrating that hityper infers new results based on the static type inference rules instead of just filtering out or reordering the predictions of dl models.
type categories.
both type4py and typilus perform better on the argument category than the return value category which may reflect the difficulty of predicting the types of return values.
by building upon type inference rules and tdgs hityper can handle the complicated type dependencies of return values and thereby improvetype4pyandtypilusby22 and39 respectively w.r.t.
the top exact match metric.
hityper also slightly meliorates thepredictionoftheargumentcategoryby7 and5 compared with type4py and typilus respectively.
the improvement may be attributed to thetype correction for user definedtypes.
moreover hityper outperforms type4py by for predicting local variables.
answertorq1 hitypershowsgreatimprovement onoveralltypeinferenceperformance andthemostsignificant improvement is on return value inference .
.
rq prediction of rare types rare types are defined as the types with proportions less than .
among the annotationsin the datasets andwe observe that .
and .
of rare types are user defined types in manytypes4pyand typilus s dataset respectively.
table illustrates the predictionresultsofraretypesanduser definedtypes.wecanobserve that the naive baseline barely infers rare types and user defined types.
besides the performance of type4py and typilus drops significantly for the two type categories which indicates that typeoccurrence frequencies can impact the performance of dl mod els.
hityper shows the best performance on predicting the two type categories.
specifically for inferring the rare types hityper outperforms type4py and typilus by and respectively w.r.t.
the top exact match metric.
regarding the prediction of user definedtypes hityperincreasestheperformanceoftype4py and typilus by and respectively.
answertorq2 hityper greatly alleviates the prediction issue of rare types faced by dl models by achieving a boost taking the advantage of the static type inference component.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yun peng cuiyun gao zongjie li bowei gao david lo qirun zhang and michael lyu table comparison with the baseline dl approaches.
dataset type category approachtop top top exact matchmatch to parametricexact matchmatch to parametricexact matchmatch to parametric manytypes4pyuser defined typesnaive baseline .
.
.
.
.
.
type4py .
.
.
.
.
.
hityper .
.
.
.
.
.
rare typesnaive baseline .
.
.
.
.
.
type4py .
.
.
.
.
.
hityper .
.
.
.
.
.
typilus s datasetuser defined typesnaive baseline .
.
.
.
.
.
typilus .
.
.
.
.
.
hityper .
.
.
.
.
.
rare typesnaive baseline .
.
.
.
.
.
typilus .
.
.
.
.
.
hityper .
.
.
.
.
.
table comparison with static type inference tools.
datasettype categoryapproachexact correct match annotations manytypes4pyargumentpytype pyre infer .
hityper .
return valuepytype .
pyre infer .
hityper .
allpytype .
pyre infer .
hityper .
typilus s datasetargumentpytype pyre infer .
hityper .
returnvaluepytype .
pyre infer .
hityper .
allpytype .
pyre infer .
hityper .
the number of correct annotations when including local variables.
.
rq performance of the static type inference component inthisrq weevaluatetheperformanceofthestatictypeinferencecomponentinhitypercomparedwithpopularstatictypeinference toolspytype andpyre .theresultsareshownintable5.
we only consider the type categories of argument and return value forcomparison sincepyre andpytypedo notinfer typesforlocal variables.weusethemetric numberofcorrectannotations toreplace the metric match to parametric that is usually used to evaluate dl models considering that the results of static inference are exact and not recommendations.
as shown in table the exact match scores of all the static tools are greatly high and hityper achieves the best performance.
the results indicate the effectiveness of the static type inference component in hityper.
we also find that there remains of the results inconsistent with human annotations in the datasets.by using python s official type checker mypyto check these results weobservethatallthetypesannotatedbyhityperdonotproduce type errors which reflects the correctness of the proposed hityper.
after manual checking of these inconsistent types wefind this inconsistency is caused by subtypes we further discussthem in sec.
.
besides mypy s results indicate very few inconsistent cases are caused by incorrect human annotations.
to test whether hityper can rectify the incorrect annotations we replace the original annotations with the results inferred by hityper and inspectwhethertheoriginaltypeerrorsarefixed.wefinallycorrect annotations on github repositories including memsourcewrap matasanocrypto metadata check coach cauldron growser andsubmitpullrequeststotheserepositoryowners.theownersofmatasanocryptoandcauldronhave approved our corrections.
whilepytypeandpyrepresenthighexactmatchscores thenumbers of variables they can accurately infer are small.
table shows thathitypergenerallyoutputs2xargumenttypesand3xreturn value types compared with them in both datasets which suggests hityper sstrongerinferenceabilitythanpyreandpytype.such improvementsattributetohityper simportanalysisand rule on supporting the inference of user defined types and inter procedural analysis on supporting the inference of class attributes and functions.
answer to rq3 only considering the static inference part hityper still outperforms current static type inference tools by inferring more variables with higher accuracy.
discussion inference of subtypes.
although hityper achieves promising resultsfortypepredictionandpassesthecheckof mypy itisstill unabletoinfersomevariabletypes around10 .thefailuremainly occurs in the inference of subtypes.
file miyakogi.wdom wdom node.py human annotation abstractnode typilus foreachclausenode hityper node 4def append element self node abstra ctnode abstractnode ifnode.
parentnode node.
parentnode.removechild node self.
children.append node node.
parent self authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
static inference meets deep learning a hybrid type inference approach for python icse may pittsburgh pa usa return node 10def append child self node if not isinstance node node raise typeerror ... return self.
ap pend element node listing an example hityper fails to infer.
listing shows an example for which hityper s result is inconsistent withthe original annotationsbut stillpasses the check ofmypy.
the return statement at line indicates that the type ofreturnvalueisthesameasthetypeofargument node.typilus predicts the type as foreachclausenode which is invalid since it isnotimportedinthecodeandisfromotherprojectsinthetraining set.hityperinfersthetypeas xml.dom.node becausethefunction is called by another function named append childin the same file and the caller transmits a variable with type node.
however developersannotatethevariableas abstractnode theparenttype.
such behavior is common in practice and poses a challenge for accurate type prediction.
related work static and dynamic type inference.
existing static type inferencetechniquestowardsdifferentprogramminglanguages suchas java javascript ruby python or using different static analysis techniques and inference tools used in industry suchas pytype pysonar2 andpyre arecorrectbydesignwithrelativelyhighaccuracyonsomesimplebuiltin types and generic types but due to the dynamic feature o f programminglanguages theycanhardlyhandleuser definedtypesandsomecomplicatedgenerictypes.hityperextendstheinference abilityofstaticinferencetechniquesbyconductingimportanalysisandinter proceduralanalysistohandletheuser definedtypes classattributesandfunctionsincode.dynamictypeinferencetech niques andtypecheckerssuchasmypy pytype pyrecheck pyright calculatethedataflowbetweenfunctions and infer types according to several input cases.
they can moreaccuratelypredicttypesthanstatictypeinferencetechniques but have limited code coverage and large time consumption.
thus they encounter difficulties when deployed on large scales of code.
machine learning in type inference.
traditional static and dynamic type inference techniques employ rule based methods andgivetheexactpredictedtypeforeachtypeslot.xu etal.
introduceprobabilistictypeinference whichreturnsseveralcandidatetypesforonevariable.hellendoorn etal.
regardtypes as word labels and build a sequence model deeptyper to infertypes.
however their model treats each variable occurrence as anew variable without strict constraints.
dash et al.
introduce conceptual types which divide a single type such as strto more detailed types such as url phone etc.
pradel et al.
design separate sequence models to infer function types in python.
they also add a validation phase to filter out most wrong predictionsusing type checkers.
allamanis et al.
propose a graph model torepresentcodeanduseknntopredictthetypes.themethodenlarges type set but still fails when the predicted types are notoccurring in the training set.
although dl models have showngreat improvement in this task it still faces the type correctnessand rare type prediction problem hityper addresses these twoproblems by integrating dl models into the framework of static inferencesincestaticinferenceisdata insensitiveandimplemented on type inference rules that are sound by design.
despite efforts onpythontypeinference therearealsoabunchofworkontype inferenceofotherdynamicallytypedprogramminglanguages.wei et al.
propose a neural graph network named lambdanet to conduct probabilistic type inference on javascript programs.
jesse et al.
propose a bert style model named typebert that obtains better performance on type inference of javascript than most sophisticated models.
conclusion inthework weproposehityper ahybridtypeinferenceframeworkwhichiterativelyintegratesdlmodelsandstaticanalysisfor type inference.
hityper creates tdg for each function and validatespredictionsfromdlmodelsbasedontypingrulesandtype rejectionrules.experimentsdemonstratetheeffectivenessof hityperintypeinference enhancementforpredictingraretypes and advantage of thestatic type inference component in hityper.
hityperisopen sourcedat