inputinvariants dominicsteinh fel cispa helmholtz center forinformationsecurity saarbr cken germany dominic.steinhoefel cispa.deandreaszeller cispa helmholtz center forinformationsecurity saarbr cken germany zeller cispa.de abstract howcanwegeneratevalidsysteminputs?grammar basedfuzzers are highly efficient in producing syntactically valid system inputs.
however programs will often reject inputs that are semantically invalid.we introduceisla a declarativespecificationlanguagefor context sensitive properties of structured system inputs based on context free grammars.
with isla it is possible to specify input constraints like a variable has to be defined before it is used the filename blockmustbe100byteslong or thenumberofcolumns in allcsvrows mustbe identical.
such constraints go into the isla fuzzer which leverages the power of solvers like z3 to solve semantic constraints and on top handles quantifiers and predicates over grammar structure.
we show that afew islaconstraints suffice toproduce100 semanticallyvalidinputswhilestillmaintaininginputdiversity.islacan alsoparseandprecisely validateinputsagainstsemanticconstraints.
islaconstraintscanbe minedfromexistinginputsamples.for this our islearn prototype uses a catalog of common patterns instantiatestheseoverinputelements andretainsthosecandidates thatholdfortheinputsobservedandwhoseinstantiationsarefully acceptedbyinput processing programs.the resultingconstraints can then againbe usedfor fuzzingandparsing.
ccsconcepts softwareanditsengineering softwaretestinganddebugging specificationlanguages constraintandlogiclanguages syntax semantics parsers softwarereverseengineering documentation theory of computation grammars and contextfree languages formalisms .
keywords fuzzing specification language grammars constraintmining acm reference format dominicsteinh fel andandreaszeller.
.input invariants.in proceedingsofthe30thacmjointeuropeansoftwareengineeringconferenceand symposium onthe foundationsofsoftware engineering esec fse november14 18 singapore singapore.
acm newyork ny usa 12pages.
esec fse november 14 18 singapore singapore copyright heldby theowner author s .
acm isbn .
introduction automatedsoftwaretestingwithrandominputs fuzzing effectively finds bugs in programs.
pure random inputs can quickly discover errors in input processing.
yet if a program expects complex structured inputs e.g.
c programs json expressions or binary formats the chancesof randomlyproducing validinputs thatare acceptedbythe parserandreach deeperfunctionalityare low.
language based fuzzers overcome this limitation by generating inputs from a specification of a program s expected inputlanguage frequentlyexpressedasa context freegrammar cfg .thisconsiderablyincreasesthechanceofproducinganinput passingtheprogram sparsingstageandreachingitscorelogic.yet whilebeinggreatfor parsing cfgsareoftentoocoarsefor producing inputs.
consider e.g.
the language of xml documents without document type .
in xml the identifiers of opening and closing tags have to match each other as in name text name .
such matchingcannotbeexpressedinacfg.eventhoughacfgcan be used for parsing cf.
fig.
using it as a producer for fuzzing willtypicallyyieldnon matchinginputslike o l cmv b7 p .
such invalid inputs are still useful for testing the parser but hardly everreach functionalitybeyondinputrejection.
to allow for precise production we can switch to a different formalism .
however existing solutions all have their drawbacks.
usinggeneral purpose code to produce inputs or enriching grammars with such code is closely tied to an implementation language anddoes notallow for parsingandrecombining inputs whichisa commonfeatureof modernfuzzers.
unrestricted grammars canin principlespecifyany computable inputproperty but we see them as turingtar pits inwhich everythingispossible butnothing of interest is easy just try for instance to express that some numberis the sum oftwoinputelements.
in this paper we bring forward a different solution by introducing a programming andtarget language independent declarative specification language named isla inputspecification language forexpressing semanticconstraintsovercfgs .byenrichingexisting grammars with constraints we leverage the simplicity of cfgs while significantly extending their expressiveness.
isla is designed as ageneral purpose formalism to specify the format even of highly complex program inputs.
it can be used to producesuch inputs automatically making isla a highly effective fuzzer that can pass all validation steps and it can be used to parseinputs and validate constraints makingislaan effective validator of inputs.
to formalize an input format in and for isla one starts with the definitionofacfg.
if agrammaris not alreadyavailable itis possibletoextractitfrominputs andprograms .then one iteratively strengthens the definition by adding more and more isla constraints until the represented language is a sufficiently close approximation of the target language an invariant over all inputs.
thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse november14 18 singapore singapore dominic steinh fel andandreas zeller xml tree colonequal xml openclose tag xml open tag inner xml tree xml close tag inner xml tree colonequal text xml tree inner xml tree inner xml tree xml open tag colonequal id id xml attribute xml close tag colonequal id xml openclose tag colonequal id id xml attribute xml attribute colonequal id text xml attribute xml attribute id colonequal id no prefix id with prefix id no prefix colonequal id start char id char id with prefix colonequal id no prefix id no prefix figure1 acontext free grammarforxml.lexerrules for thecapitalized nonterminals are omitted.
xml tree .
xml open tag .
id xml tree .
xml close tag .
id listing isla constraintforwell balanced xml.
forall xml tree tree id opid inner xml tree id clid instart opid clid listing core isla constraintforwell balanced xml.
togetanideaofislaconstraints considerlisting referring to the grammar in fig.
.
the constraint expresses that the id s of opening and closing tags in allxml trees that are not selfclosing are equal.
programmers write such constraints in the simplifiedlayer of the isla language.
our solver translates it to the core isla constraintinlisting .thecore islaversion explicitly quantifies over all xml tree elements binds its constituents to variables using patternmatching and expressesthe equalityusing thesmt lib formula opid clid .
this is typical for an isla constraint it first identifies derivation tree elements and then posesconstraints over these elements.
during fuzzing isla then wouldproduce matching pairsofopening andclosing id s. theresultingvalidinputscanbeusedas seedinputs formutationalfuzzerslikeafl.theislasolvercanbeintegratedintothe fitness function of evolutionary fuzzers guiding their mutations towardsemanticallyvalidinputs thesolvercanquicklyrejectinvalid inputswithouthavingto run actual tests.
yet where would isla constraints come from?
testers can write isla constraints manually thus ensuring input validity and add additionalconstraintstofurthercontroltheinputsgenerated.however they can also mine constraints from existing inputs.
to this end ourislearntool uses a catalog of common constraint patterns instantiatestheseoverallinputsandinputelements andretains those constraint candidates that hold for all inputs.
the catalog holdspatternstoidentifymatchingelements lengthrelations arithmeticrelations checksums andmore.islearnissimilarinspiritto thedaikonfunction level invariant detector .
on top islearn canverifyandrefineconstraint candidatesbyhavingthe program undertest checkwhether derivedconcrete inputsare valid.
after illustrating isla by example section this paper makes the following contributions aspecification language forinput constraints.
weproposea formalism isla for augmenting existing context free grammars with context sensitive constraints.
isla has a rich declarativelayer separatingsemanticproperties constraints from syntactic properties the grammar .
we formally define its syntaxandsemanticsinsection .tothebestofourknowledge islaisthe firstformalismtoexpresscontext sensitiveconstraints forthegeneration ofsysteminputs.
semanticfuzzing.
we describe an efficient procedure to generate inputs satisfying isla constraints and their grammars and discuss our implementation section .
to the best of our knowledge islais the first fuzzer and checker to make use of suchconstraints givingusersunprecedentedmeanstospecify whichsysteminputsshould be generated.
mining input constraints.
we introduce islearn a system for automatically mining input constraints in conjunctive normal form based on a configurable pattern catalog section .
to thebestofourknowledge islearnisthefirstapproachto infer suchinvariantsfrom givensysteminputs.
islaanditsconstraintsareeffective.inourevaluation section weformalizesemanticpropertiesfromdiverselanguages namely xml a subset of c restructuredtext csv files and tar archives.
our results demonstrate that already a few lines of isla specificationssufficetogenerate precise inputswhilemaintaining diversity.ontop ourconstraintminer islearncan extract precise invariants about icmp packets dot graphs and racket programs.
after discussing related work section section 8closes with conclusion and future work.
our electronic appendix provides further formalizations explanations examples andproofs.
isla by example let us illustrate the expressive power of isla by detailing our xml example.whenrandomlyfeedinganxmlprocessor e.g.
python s xml.etree package withinputsgeneratedfromthexmlgrammar in fig.1using a grammar fuzzer we obtain not only one but three kindsoferrors mismatchedtag duplicateattribute and unbound prefix.
by adding isla specifications to the xml grammar wecansubstantiallyincreasetheportionofvalidxml we pass to the processor.
moreover these specifications document xmlfeatures relevantto the parser of our test target.
since isla is closed under conjunction we can incrementally refinethespecificationsimplybyaddingindividualinputconstraints until we are satisfied with the quality of the generated inputs or the valueofthe specification as adocumentation measure.
fromtheinvalidinputsgeneratedfromthexmlgrammar about are invalid due to a mismatched tag and about because of an unbound prefix.letusaddress these.
.
matchingtags theislaconstraintsinlistings 1and2addressestheproblemof mismatched tags by enforcing that the two ids match.
the coreisla version listing uses auniversal quantifier forall over allsubexpressionsoftype xml tree whichisthespecifiedtype oftheboundvariable tree.typesarenonterminalsfromthereferencegrammar herethexmlgrammarinfig.
orthespecial typeintfor quantifiers over numbers.
the present quantifier uses 584input invariants esec fse november14 18 singapore singapore patternmatching .islaonlyconsidersmatchesconformingtothe pattern in quotation marks in the case of a successful match not only the quantified variable treebut also the variables opid andclidin the pattern in curly braces are boundto the correspondingpartsofthematchedinputsegment.matchexpressions may contain optional elements in square brackets to capture multiple expansion alternatives.
the core of the forallformula is an smt lib s expression stating that opidandclidare equal.
since islaextendsthesmt liblanguage itsupportsallitsstring constraints.a core islaconstraint containsexactlyone constant symbol which determines the type of described inputs.
by default this is a symbol startof type start which can be customized by adeclaration constname type before the actual constraint.
simplified isla.
isla s simplified language layer allows us to writethisconstraintmuchmoreconcisely.listing 1isthesimplifiedversionofthecore islaconstraintinlisting .insimplified isla we can use the more common mathematical infixsyntax for binaryexpressions i.e.
x y insteadof x y .
furthermore theforallquantifiercanbeomitted.instead wedirectlyuseits type xml tree intheequation.thisimplicitlyaddsa forallquantifier over xml tree elements.
to access immediate children of xml tree elements we use a notation inspired by the xpath abbreviatedsyntax .forexample xml tree .
xml open tag referstothe first xml open tag elementamongthechildrenofan xml tree element inaderivationtree if any.
insimplifiedisla instart inquantifiersisadefaultandcan beomitted.furthermore variablenamesinquantifiers suchas var in forall type var ... ... can be omitted if we are onlyinterestedinthevariablesboundbythematchpattern.simplifiedandcore islasyntaxcanbe mixedinthesameconstraint.
in the end allconstraintsare translated to core isla .
since isla constraints are closed under conjunction and and disjunction or it is easy to refine or relax constraints.
isla is thuswellsuitedfor targetedtesting or e.g.
fordescribinga specific classofinputs thattriggerabuginadebuggingscenario.thanks toitsdeclarativenature itcanalsobeusedforformulatinghumanreadablespecifications ofthe expectedinputsofasystem.
.
bindingprefixes next wespecifyapropertyavoiding unboundprefix errors.an unbound prefix error is raised when tag or attribute identifiers in xmldocumentscontaina namespaceprefix suchasns1andns2in ns1 tag ns2 attr ... whichisnot declaredinthesame or an outer tag.
this is an example of a def useproperty that is alsocommoninprogramminglanguages a usedidentifiermustbe definedinsomeouterscopeoratsomeprecedingposition.oneadds theattribute xmlns ns1 some text todeclarenamespace ns1 where frequently the quoted text contains a url.
the property we aimfor isexpressedmoreprecisely as forallidentifiers with a prefixp there isasurrounding xml tree tsuch that there is an attribute xmlns pinthe attributes list of t s opening tag.
we emphasizedwordscorrespondingtoislalanguageelements.there isonesubtlety though wehavetodistinguishprefixesinattribute and tag identifiers since the special attribute xmlnsdoesnothave to be declared as itisusedprecisely to declare othernamespaces.again wecanexpressbothcasesinisolationtoincrementally refine thespecification.here we regardthe slightly more complicated case of prefixes in attribute identifiers.
listing 3shows the islaspecification for this case.
1forall xml attribute attr id no prefix prefix use id no prefix maybe def text 2notprefix use xmlns implies 3exists xml tree outer tag id xml attribute a cont inner xml tree id 5inside attr outer tag and 6exists xml attribute xmlns id no prefix prefix def text ina cont notprefix def xmlns andprefix use prefix def listing isla constraint for binding prefixes in attribute identifiers referencegrammar fig.
the isla code closely resembles the natural language specificationwedescribedpreviously exceptthatwespecializedittoonly quantify over attributes line1 and generally permit the xmlns prefix line usingan implication onlyiftheprefixis notxmlns itmustbe explicitly defined.
.
targeted testing withislaspecifications wecangobeyondconstraintsforsemantic validity for application specific targeted testing .
imagine an xml processor that allows associating tags with urls defined using dedicated attributes web baseurl andweb query for base urls andquerystrings.wecanenforcetheexistenceofatagusingboth oftheseattributes somewhere inany producedsysteminput exists xml attribute attributes exists xml attribute attrinattributes attr.
id web baseurl and exists xml attribute attrinattributes attr.
id web query the xml processor performs some input validation and rejects allinputswherethevaluesoftheseattributesexceedalengthof100 characters.
we force all generated inputs to respect this constraint byaddingthe following specification forall xml attribute web id no prefix text text str.len text afterparsinganxmlfile theprocessorassemblesacomplete url by joining the base url and the query string.
however let us assume its input validation is buggy the result is stored in a character array of length and we thus get a buffer overflow whenthebaseurlandthequerystring togetherexceedalength of characters.
we can then explicitly generate inputs triggering this bug by encoding this property as an isla constraint.
such inputs would be valuable for developers or security researchers as aregressiontest validating afixfor apotentialexploit forall xml attribute attrs forall xml attribute attr 1 web baseurl text t1 inattrs forall xml attribute attr 2 web query text t2 inattrs str.len t1 str.len t2 .
miningconstraints constraints like the ones described above can alsobe minedfrom existing inputs.
to mine constraints such as the xml constraint in 585esec fse november14 18 singapore singapore dominic steinh fel andandreas zeller listing2 we create a schematic version of itthat is independentof thechoiceofaparticulargrammar forall ?nonterminal ?matchexpr opid clid opid clid this pattern can be added to the catalog of our islearn system enablingthesystemtoinfersimilarconstraintsforadifferentgrammar.
the placeholder ?nonterminal represents any nonterminal in that grammar ?matchexpr opid clid represents any suitable match expression for an instantiation of ?nonterminal containingtwononterminaloccurrencesthatareboundtovariables opidandclid.
islearn generates candidate instantiations from suchpatternsandthenfiltersthosethatholdforasetofgivenor automatically generated sample inputs.
hence given a set of xml inputs islearn can easily learn the constraintinlisting .
toavoidoverspecializationtowardasmallsetofinputs islearn can automatically validateconstraint candidates by generating furtherinputsfromthemandcheckingwhethertheseinputswould beacceptedbytheprogram.thisalsoworksin debugging scenarios ifwehaveasetofinputsforwhichaspecificpropertyholds say the length of some input element exceeds some constant islearn will not only learn that constraint but can also ensure that further instantiationsofthe constraintreproduce the failure.
.
summary with these examples we have demonstrated how islaconstraints precisely characterize input classes associated to some program behavior.developerscanusethesedescriptionstoobtain semantically validinputs describethe conditions of discovered bugs and for targetedtriggering ofsuchbugs.givenexistinginputs islearncan determine constraintsthat precisely characterize input properties andprogram behavior.
note that withoutisla and islearn implementing any of these constraintscanbeatiresomeexperience.whileahandwrittengenerator can easily ensure matching xml tags or usage of tags from a dictionary proper handling of namespaces is already a challenge andsolvingarithmeticconstraintsovermultipleelementswillbe increasingly difficult.
extending such a generator to be composableandusable as a parser for checking or mutating inputs will requireaneffortcomparabletoimplementingmostof isla but the resultingtoolwillnot be nearly as versatile.
isla syntax and semantics islaconstraintsarebuiltfroma signature ofgrammar predicate and variable symbols.
we first formally define cfgs following chapter afterward we introduce islasignatures.
definition3.
context freegrammar .
acontext freegrammar cfg isatuple g n t p s of asetof nonterminalsymbols n asetof terminalsymbols tdisjointfrom n asetof productions pmapping nonterminals n nto an expansion alternative .
an alternativeisastringofterminalornonterminalsymbols.formally p n n t and adesignated startsymbol s n. by convention we surround nonterminal symbols with angular brackets e.g.
start .
signatures contain a special nonterminal symbol int fornumericvariablesrepresentingderivationtrees whose stringrepresentations correspondto anaturalnumber.definition .
isla signature .
asignature is a tuple g psym vsym ofagrammar g n t p s asetofpredicate symbolspsymof strictly positive arity and a set of typed variable symbols vsym.
the type vtype v ofv vsymis a symbol n n int int n. wenowdefinethesyntaxofcore islaformulas.weassumeunderspecifiedsets trmbool vars ofbooleansmt libtermswithfree variables vars.
these sets contain the constants trueandfalse and s expressions fa1... an wherefis ann ary function symbol of boolsort and the aiare smt expressions of suitable sort.formulas in trmbool vars may contain uninterpretedstring constants whose names coincide with the names in vars.
for the precise definition of smt lib terms we refer to the smt lib standard andtherepositoryofsmt libtheories .apartfrom smt libexpressions quantifiers andbooleancombinators isla usespredicate formulas with predicate symbols from psym.
while ourdefinitionofcore islaformulasisparametricin psym theisla solver comes with a set of predefined predicates such as inside fromlisting .foralistofisla sbuilt inpredicates werefertoour electronicappendix andthe islalanguagespecification .
definition3.
core islaformulas .
thesetfmlofislaformulas for a signature g psym vsym withg n t p s is inductivelydefinedas fmlif trmbool vsym .
p v1 ... vn fmlfor each predicate symbol p psym witharity nandvi vsym.
not and or are infmlfor fml.
foralltypexiny andexiststypexiny areinfml forx y vsym vtype x type n int and fml.
foralltypex mexp iny anditsexistentialcounterpart existstypex mexp iny are infmlifx y vsym vtype x type n and fml andmexpis a string consistingofsymbolsin n t non nestedlists of such symbols optionalsymbols and variables