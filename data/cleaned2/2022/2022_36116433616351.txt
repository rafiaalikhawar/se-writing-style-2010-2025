learning program semantics for vulnerabilitydetection via vulnerability specific inter procedural slicing bozhiwu singaporemanagementuniversity singapore bozhiwu smu.edu.sgshangqing liu nanyangtechnologicaluniversity singapore shangqingliu666 gmail.comyang xiao chineseacademy ofsciences china xiaoyang iie.ac.cn zhiming li nanyangtechnologicaluniversity singapore zhiming001 e.ntu.edu.sgjunsun singaporemanagementuniversity singapore junsun smu.edu.sgshang weilin nanyangtechnologicaluniversity singapore shang wei.lin ntu.edu.sg abstract learning basedapproachesthatlearncoderepresentationsforsoftwarevulnerabilitydetectionhavebeenproventoproduceinspiring results.
however they stillfailtocapture complete andprecisevulnerabilitysemanticsforcoderepresentations.toaddressthelimitations in this work we propose a learning based approachnamely snapvuln which f irstutilizesmultiplevulnerability speci f icinterprocedural slicing algorithms to capture vulnerability semantics of various types and then employs a gated graph neural network ggnn withanattentionmechanismtolearnvulnerabilitysemantics.
we compare snapvuln with state of the art learning based approachesontwopublicdatasets andcon f irmthat snapvuln outperformsthem.wefurtherperformanablationstudyanddemonstrate that the completeness and precision of vulnerability semantics capturedbysnapvuln contribute tothe performance improvement.
ccsconcepts security and privacy software security engineering .
keywords vulnerability detection programsemantics code representations.
acm referenceformat bozhi wu shangqing liu yang xiao zhiming li jun sun and shangwei lin.
.
learning program semantics for vulnerability detection via vulnerability speci f ic inter procedural slicing.
in proceedings of the 31stacmjoint europeansoftwareengineeringconferenceand symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa 13pages.https introduction software security is crucial in practice and thus has attracted widespread attention from academia and industry.
although various alsowithnanyang technologicaluniversity.
corresponding author.
esec fse december sanfrancisco ca usa copyright held bytheowner author s .
acm isbn979 including symbolic execution data f low analysis andfuzztesting havebeenproposedto improvesoftwaresecurity itisstillafarfrombeingsolved.speci f ically symbolic executionaims at traversingall execution paths to f indthevulnerabilitiesbutsuffersfrompathexplosionproblems.
staticanalysissuchasdata f lowanalysismayresultinexcessive false positives while fuzz testing will result in high false negatives.
inspired by the great success of deep learning techniques many learning based approaches have been proposedtobuildanautomatedvulnerabilitydetectionsystemand achieveencouragingresults.themainideaoflearning basedapproaches is tolearneffective coderepresentations from programs that can reveal vulnerability patterns for vulnerability classi f ication.forexample russelletal.
utilizeconvolutionalneural network cnn and gated recurrent unit gru to learn vector representations from lexical tokens of source code for vulnerability detection.
to obtain comprehensive code representations devign f irst extracts four kinds of graphs from the source code includingabstractsyntaxtree ast controlflowgraph cfg data flow graph dfg and naturalcode sequence ncs and learn code representations from these graphs using graph neural network gnn for vulnerability detection.
but the extracted programsemanticsarenotallaboutvulnerabilities.inordertocapture the precise vulnerabilitypatterns vuldeepecker applies slicing techniques on data dependency graph ddg to extract program semantics of vulnerable parts and leverage blstm to generate the f inal code representationsforvulnerability classi f ication.
however existing learning based approaches still suffer from the following two limitations which prevent them from obtaining precise program semantics of vulnerable parts for code representationgeneration.inthispaper werefertotheprogramsemanticsof vulnerable parts as vulnerability semantics .
limitation1 the extracted vulnerability semantics are incomplete.
some works utilize neural networks to detect vulnerabilities for a single function.
one well received work devign constructed a code property graph to extract program structures and utilized graph neural networks gnns to learn program semantics for vulnerability detection.
although it producedinspiringresults itonlyfocusesonsingle functiondetection while the semantics of callee functions are missed because the implementationsofthesecalleefunctionsarenotconsideredinthe proposed approach.
in practice vulnerabilities may span across thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa bozhi wu shangqing liu yang xiao zhimingli jun sun andshang weilin multiplefunctions i.e.
betweenafunctionanditscalleefunctions .
hence thesetechniquestargetingsingle functiondetectioncannot capture complete vulnerabilitysemantics.
limitation2 the extracted vulnerability semantics are imprecise.
other works leverage program slicing algorithmstoextractvulnerabilitysemanticsstartingfromvarious vulnerableprogrampoints e.g.
dangerousapicallsorvariables for code representation generation.
however these slicing algorithmscannotdiscriminatethesinkorsource andeverystatement that depends on the vulnerable program points will be included.
thisproblemhasalsobeenstatedinpreviousresearchwork .
therefore statementsunrelatedtovulnerabilitieswillbeintroduced intothesliceasnoise makingtheextractedvulnerabilitysemantics imprecise.
besides these slicing algorithms perform slicing on ddg or program dependence graph i.e.
pdg without considering cfg that reveals the program execution order.
this would leadtofailuretocatchthesemanticsofvulnerabilitiescausedby incorrectexecutionorder suchas useafterfree whichistriggeredwhentheoperation use occursaftertheoperation free .in summary theprogramslicingalgorithmsusedinpreviouslearningbasedapproachesareinsufficienttocaptureprecisevulnerability semantics.
to address the aforementioned limitations in this work we proposesnapvuln a learning based approach that applies multiple vulnerability speci f ic inter procedural algorithms that identify the sourceandsinktocapturepreciseprogramsemanticsofvariousvulnerability types for vulnerability detection.
speci f ically we extract theinter proceduralgraph ig fromthesourcecode whichcan beregardedasacombinationofpdg cfgandcallgraphs cg .
then we design multiple vulnerability speci f ic slicing algorithms for different vulnerability types to capture precise vulnerability semantics which identify source and sink and further operate on the inter proceduralgraph.inthiswork weimplementvulnerabilityspeci f icslicingalgorithms forsix common vulnerability types in c c .
to learn better code representation for different vulnerabilitytypes weemployasubmodelforeachvulnerabilitytype which utilizes a gated graph neural network ggnn with an attention mechanism andagnnmodelforvulnerabilitiesnotcoveredbythe slicingalgorithms.afterthat weensemblethesubmodelsandgnn model to predict vulnerabilities.
for instance given an example snapvuln extractssixtypesofsubgraphsfromigaspotentialvulnerabilitysemanticsaccordingtotheprogramslicingalgorithms.
eachtypeofsubgraphisthenfedintothecorrespondingsubmodel whichcapturethestructuralsemanticsinthesubgraphsanddynamically learn different weights for different subgraphs to generate bettercoderepresentations.theigisfedintothegnnmodelto capturecomprehensiveprogramsemantics.finally weensemble the output of the six submodels and the gnn model to obtain a comprehensive prediction.
todemonstratetheeffectivenessof snapvuln weconductextensiveexperimentsontwopublicdatasetsandcompare snapvuln with sevenstate of the artbaselines.theexperimentalresultsshowthat snapvuln outperforms these baselines.
we further perform an ablationstudytodemonstratethatthecompletenessandprecisionof our learned vulnerability semantics contribute to the improvement of vulnerability detection.
in summary our main contributions are as follows 1intsmb2 write ... ... req sync hdr.processid cpu to le32 io parms pid ... cifs small buf release req ... if rc trace smb3 write err xid req persistentfileid ... cifs small buf release req ... 14voidcifs small buf release void buf to free ... mempool free buf to free cifs sm req poolp ... 19voidmempool free void element mempool t pool ... pool free element pool pool data a use afterfree from commit 6a3eb33 1intdtls1 buffer message ssl s intis ccs hm fragment frag ... frag dtls1 hm fragment new s init num if !frag return memcpy frag fragment s init buf data s init num ... frag msg header.msg len s d1 w msg hdr.msg len frag msg header.seq s d1 w msg hdr.seq frag msg header.type s d1 w msg hdr.type ... item pitem new seq64be frag if item null dtls1 hm fragment free frag return0 ... b null pointer dereference from commit 7a9d59c figure two real world examples from github opensource projects.
the lines starting with indicates that these lines of statements have security risks and they are f ixed by thestatements marked with .
we propose dedicated slicing algorithms for six common vulnerability types in c c to achieve precise vulnerability semantics.
to the best of our knowledge we are the f irst to design vulnerability speci f icslicingalgorithmstocaptureprecisevulnerability semantics based on different vulnerability characteristics.
we incorporate the attention mechanism into the gated graph neural network ggnn to ensure that the model can learn to assigndifferentweightstosubgraphsproducedbyslicingalgorithms soastohelpthemodellearnbetterrepresentationsfor vulnerabilitydetection.
weanalysethelimitationsofexistingdeeplearning basedworks for vulnerabilitydetection andshow that thecompletenessand precision of vulnerability semantics is vital for automated vulnerability detection byextensive experiments.
we conduct extensive experiments to compare snapvuln with seven state of the art baselines including f ive learning based vulnerabilitydetectionbaselinesandtwopre trainedapproaches on two public datasets.
experimental results show that snapvuln outperformsthesebaselinessigni f icantly.wehavemadeourcode anddata publicat our website for reproduction.
motivation the key to learning based vulnerability detection is to learn better code representations for the detection.
to achieve this program semanticsaboutvulnerableparts herereferto vulnerabilitysemantics should be well captured for representation.
therefore in ordertoinvestigatehowwellexistinglearning basedapproaches capture vulnerability semantics we conduct an in depth analysis and discover two important aspects on which learning based approachesshould improve.
1372learning program semantics forvulnerabilitydetectionviavulnerability specificinter proceduralslicing esec fse december3 san francisco ca usa g2g1 samplepdgs cfgs cgsinter procedural graph generationvulnerability specific program slicing submodel architecture igggnn ...subgraph subgraph ksubgraph 2attention fc layer ...g1 g2 gkbo subgraphs...prediction a gk...a1 a2 ak ... ml subgraphs ... df subgraphs ... igoutputsubmodel 1 ... ensemble gnn modeltraining testing gnn model architectureggnnig fc layerg outputsubmodel 2 submodel 6sample k subgraphs sample k subgraphs sample k subgraphs figure the overview of snapvuln .
table line number of statements captured by different slicing approachesfortheexample infigure b .
linenumber groundtruth vuldeepecker sysevr deepwukong snapvuln enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc enc finding inter procedural analysis should be introduced tocapturethecompletevulnerabilitysemantics.
inthereal world itis common for avulnerability to span multiple functions.
forexample asshowninfigure a thepointer req isusedagain online8afterbeingfreedonline5 whichtriggers useafterfree vulnerability.thisvulnerabilityspansthreefunctions.ifonlythe function smb2 write isconsidered asinput the function mempool free thatcontainstheimportantsemanticsofreleasingmemorywillbelost andconsequently themodelwillbeunabletolearn coderepresentationwellforvulnerabilitydetection.however existinglearning basedapproachessuchasdevign reveal and draper detect vulnerabilities for a single function.
therefore aninter proceduralanalysisshouldbeintroducedtocapture completevulnerabilitysemanticsacrossmultiplefunctionsforcode representation generation.
finding2 slicingalgorithmsshouldbedesignedtocapture precise vulnerability semantics.
we investigate how existing learning based approachesobtain vulnerability semanticsfor code representation generation and discover that most of them can not capture precise vulnerability semantics.
speci f ically vuldeepecker performedprogramslicingonddgbasedonlibrary api functioncalls whilesysevr anddeepwukong performed program slicing on pdgs.
on one hand these slicing algorithms do not capture the control f low information i.e.
cfg in the code whichmakesthemimpossibletorevealsomevulnerabilitiescaused by wrong execution order such as use after free .
on other hand theseslicingalgorithmsmayincludestatementsthatarenotrelated to vulnerabilities since somestatements that are not related to vulnerabilitiesmayalsodependonvulnerability relatedstatements.
we take the null pointer dereference sample in figure b as an example and follow theslicingalgorithms in these approachestoobtainthecorrespondingresultsshownintable .weassume thattheseapproachestakeline4asaslicingcriterion wherethe function dtls1 hm fragment new iscalled.theresultsshowthat theyobtain160 morestatementsthanrealvulnerabilitysemantics which are imprecise.
we can infer thatslicing algorithms should be improvedto capture precise vulnerabilitysemantics.
approach motivated by the aforementioned f indings we propose a learningbased approach namely snapvuln .
it applies vulnerability speci f ic inter proceduralslicingalgorithmstocapturecompleteandprecise vulnerability semantics of various vulnerability types in c c and leverages a ggnn with an attention mechanism to learn good representations for vulnerabilitydetection.
we present the details ofsnapvuln below.
.
overview figure2showstheoverviewof snapvuln whichmainlyconsistsof threecomponents inter proceduralgraphgeneration vulnerabilityspeci f ic program slicing and the well designed models.
in the f irst component we extract cfgs pdgs and call graphs from each sample and utilize them to construct an inter procedural graph to representthecompleteprogramsemanticsforeachsample.thesecond component utilizes the vulnerability speci f ic inter procedural slicing algorithms to extract the precise vulnerability semantics from the complete program semantics.
as a result multiple sets ofsubgraphsareextractedfromtheinter proceduralgraph each containingthepotentialvulnerabilitysemanticscorrespondingto itsspeci f ictype.thethirdcomponentemploysmultiplesubmodelsandagnnmodeltoindividuallycapturethedistincttypesof vulnerability semantics for vulnerability detection.
speci f ically the novel submodel that customizes a ggnn with an attention mechanism is proposed to capture the vulnerability semantics of speci f ic typefromthecorrespondingsetofsubgraphsindividually.moreover toaddressvulnerabilitiesthatarenotcoveredbytheslicing algorithms we utilize a gnn model to capture the comprehensive program semantics of the sample from the inter procedural graph.
thisgnnmodelcanbeconsideredasasubmodelwithoutanattentionmechanism allowingittoidentifyandpredictthoseunhandled vulnerabilities by the slicing algorithms.
finally the predictions from the multiple submodels and the gnn model are ensembled to 1373esec fse december3 san francisco ca usa bozhi wu shangqing liu yang xiao zhimingli jun sun andshang weilin generatethe f inalpredictions.thisensembleapproachcombines theoutputsof each model resulting in more accurate and reliable predictions for vulnerabilitydetection.
process in the training phase snapvuln constructs the interprocedural graphs for all training data and extracts six sets of subgraphsforeachsample.thesixsetsofsubgraphscontainpotential vulnerability semantics of speci f ic types.
since a sample may generate an arbitrary number of subgraphs we randomly sample u1d458subgraphs from each set to represent the vulnerability semantics corresponding to its speci f ic type and de f ine them as g u1d4541 ... u1d454 u1d458 .afterthat eachsetofsubgraphs g corresponding to a speci f ic vulnerability type is individually fed into a submodel fortraining.thesesubmodelsaredesignedtolearnandcapturethe speci f ic vulnerability semantics associated with each vulnerability type.
furthermore the inter procedural graphs are used to train a gnn model which aims to capture vulnerabilitysemantics that arenothandledbytheexistingslicingalgorithms.allthesemodels are trained independently.
if a new slicing algorithm is introduced for other vulnerability type a new submodel can be added and the subgraphsextracted by thenew slicing algorithmcan be used to train the submodel.
this modular approach provides scalability by allowing the incorporation of new slicing algorithms and the expansion of therange ofvulnerability typesthat can be detected.
inthetestingphase sixsetsofsubgraphsandaninter procedural graphareextractedfromeachsample.foreachsetofsubgraphs u1d458subgraphsaresampledtorepresentthevulnerabilitysemantics of its speci f ic type.
after that the six sets of subgraphs along with the inter procedural graph are then individually fed into the corresponding well trained submodels and gnn model.
finally snapvuln ensembles the outputs of the submodels and gnn model to make a f inal prediction for eachsample.
.
inter procedural graphgeneration in order to capture the complete vulnerability semantics the interprocedural analysis should be utilized in the data preprocessing stage.
therefore we utilize the popular static analysis tool joern toextractcodepropertygraphsandfurtherbuildaninterproceduralgraph for eachsample.
de f inition.
in this paper an inter procedural graph i u1d43ais a directedgraphconsistingofasetofnodesandedgeswhereeachnode representsonestatementinthesampleandeachedgerepresents the relationship between two statements including control f low data controldependency andfunctioncall.theinter procedural graphi u1d43ais a combination of cfgs pdgs and call graphs i.e.
cgs which exposes a variety of program semantics for vulnerability detection.
speci f ically pdgs reveal the data and control dependency of the program which can be utilized for detecting somespeci f ictypesofvulnerabilities.forexample withdetailed datadependenciesonthetargetpointerandsomecontroldependencies we can intuitively infer whether the program lacks the operation of releasing memory or not.
cfgs further supplement someother typesof vulnerabilitiessuch as use afterfree since cfgs revealthe explicitexecution orderof statements we candetect whether the memory is used after free on cfgs.
cgs can be usedtoenrichinter proceduralgraphstoallowforinter procedural analysis.therefore weextracttheinter proceduralgraph ig to ensure that complete vulnerabilitysemantics are captured.
cfg ddg cdg cg 223figure ig offig.
a .
5source sinkedges vulnerability semanticsstatements program semanticsfigure4 vulnerabilitysemantics.
generation process.
to build inter procedural graphs we f irst employ the popular static tool joern to extract cfgs pdgs and cgs from the source code where pdg consists of data dependencies ddg and control dependencies cdg .
speci f ically through the call graphs generated by joern we identify the call edge between caller function and callee function soas to connect cfgs and pdgs of different functions and get the inter procedural graph for the sample.
in this way the inter procedural graph contains the complete programsemantics and is able tosupport interprocedural analysis.
we illustrate an inter procedural graph for the example of figure a in figure .
speci f ically cfg ddg and cdg in the functions smb write cifs small buf release and mempool free are extracted f irst.
then according to the call graph thefunction cifs small buf release iscalled in statement 5ofthefunction smb write .therefore weestablishacalledge between statement of the function smb write and the function cifs small buf release .
similarly a call edge is established betweenthefunction cifs small buf release andthestatement of line in the function mempool free .
finally we obtain the inter proceduralgraph infigure .
.
slicing algorithms byconstructingtheinter proceduralgraphforeachsample wecapturethecompleteprogramsemantics.however programsemantics are not equal to vulnerability semantics.
as shown in figure vulnerabilitysemanticsareonlyapartofprogramsemantics.therefore we need to further extract precise vulnerability semantics for code representationgeneration.inspired byprevious work on slicingalgorithmsnamedchopping whichidenti f iesthestatementsthatcausethede f initionsofthesourcetoaffect theusesof the sink we propose vulnerability speci f ic inter procedural slicing algorithmsforvariousvulnerabilitytypes whicharewell designed by identifying sources and sinks based on the characteristics of eachvulnerabilitytype.
keyidea.
thekeyideaofvulnerability speci f icinter procedural slicing algorithms is to locate the vulnerability relevant part of thewholeinter proceduralgraphandsliceitouttorepresentthe vulnerability semantics.
in detail snapvuln locates the source i.e.
where it comes from and sink i.e.
where it ends of potential vulnerabilityinthecode andtakesthepathsfromsourcetosinkto constructasubgraphasarepresentationofvulnerabilitysemantics.
since different vulnerability types have different causes leading to different sourcesand sinks we propose speci f ic slicing algorithms accordingtothecharacteristicsofdifferentvulnerabilitytypesto captureprecisevulnerabilitysemantics.inthispaper weimplement slicing algorithms for six common vulnerability types in c c .
weillustratethecorrespondingalgorithmsforeachvulnerability type indetails.
1374learning program semantics forvulnerabilitydetectionviavulnerability specificinter proceduralslicing esec fse december3 san francisco ca usa define bufsize 2intmain intargc char argv 3char buf 4buf char malloc sizeof char bufsize 5strcpy buf argv a buffer over f low1char getblock intfd 2char buf char malloc block size 3if read fd buf blk size !
blk size 4returnnull 5return buf b memoryleak1voidmain 2structhostent hp ... 4hp gethostbyaddr addr 5strcpy hostname hp h name c null pointer dereference 1intmain 2intc 3inta 4intb 5c a b d integer over f low1char ptr char malloc size 2if err 3abrt 4free ptr 5if abrt 6logerror operation aborted ptr e use afterfree1char ptr char malloc size 2if abrt 3free ptr ... 6free ptr f double free figure simple examples ofsix vulnerability types.
type buffer over f low bo .
a bufferover f lowoccurswhen the program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the outputbuffer.an example isshowninfigure a .
source ingeneral therearetwotypesofbufferover f low i.e.
stackbasedandheap based whereover f lowoccursonarrays stack and pointers heap respectively.therefore wetaketheallocationof arrays and pointers as potential sources.
for example line in figure5 a isthe source.
sink the sink of buffer over f low is a statement that invokes function calls or assignments to manipulate pointers or arrays.
the function callincludes strcpy memcpy andso on whilethe assignment is various where any statement that assigns value to memory that pointer points to or array with index are all included.
for example line5infigure a isthe sink.
algorithm snapvuln takes sinks in the target program as the slicingcriterionandperformsbackwardslicingoninter procedural pdg to obtain the statements that affect the sinks until all the sourcesintheinter proceduralpdgarereached.notethatwedo notperformforwardslicingbytakingsourcesasaslicingcriterion because it will include those statements that are affected by the sourcebutnotrelatedtothevulnerability.wepresentthedetails inalgorithm .
algorithm slicingfor bufferover f low input inter proceduralpdg u1d456 u1d45d u1d451 u1d454 output vulnerabilityfeatures u1d463 u1d450 1retrieve all expression statements thatwriteto arraysor pointers assinks u1d458 u1d460 2initialize u1d463 u1d450 3for u1d458 u1d458 u1d460do u1d460 backwardslicing u1d458 u1d456 u1d45d u1d451 u1d454 u1d454 constructgraph u1d460 u1d456 u1d45d u1d451 u1d454 u1d463 u1d450 u1d463 u1d450 uniontext.
u1d454 7return u1d463 u1d450 type memory leak ml .
a memory leak occurs when the program does not sufficiently track and release memory after it has beenused.
itconsumes theremaining memory.
an example is showninfigure b .
source the source of memory leak vulnerability is an assignment statementthatallocatesmemoryspacetoapointer.forexample in thesourcecodeoflinuxkernel theprogrammaycallstandardfunction i.e.
malloc calloc directly or call wrapper functions i.e.
cifs buf get acquirequantuminfo .thesewrapperfunctions can be found by analyzing the call graph of the program.
for example cifs buf get calls mempool alloc and mempool alloc calls pool alloc therefore cifs buf get can be taken as source.sink accordingtothecharacteristicsofthememoryleak itwill betriggeredifthememoryhasnotbeenreleaseduntiltheendof theprogram.therefore wetaketheendoftheprogramasasinkif there are nostatements that free the memory.
algorithm snapvuln takesthesourcesasaslicingcriterionand performs forward slicing on inter procedural pdg to obtain the statementsthatareaffectedbythesourcesuntiltheendoftheinterprocedural pdg or free functions are found.
the slicing process is showninalgorithm .
algorithm slicingfor memoryleak input inter proceduralgraph u1d456 u1d45d u1d451 u1d454 output vulnerabilityfeatures u1d463 u1d450 1retrieve all statements thatassignto pointers andinvokefunctioncallsassources u1d452 u1d460 2initialize u1d463 u1d450 3for u1d452 esdo u1d460 forwardslicing u1d452 u1d456 u1d45d u1d451 u1d454 u1d454 constructgraph u1d460 u1d456 u1d45d u1d451 u1d454 u1d463 u1d450 u1d463 u1d450 uniontext.
u1d454 7return u1d463 u1d450 type null pointer dereference np .
a null pointer dereference occurs when the program accesses a pointer that expects to be valid but is null instead.
figure c shows an example of a null pointer dereference.
source similartomemoryleak thesourceofnullpointerdereferenceisalsoanassignmentstatementthatinvokesapifunction callssuchas malloc and calloc toallocatememoryspacefora pointer.
sink according tothe characteristics ofnull pointerdereference we conclude that it will be triggered when the null pointer is used forthe f irsttime.therefore wetakethe f irststatementusingthe pointer as the potential sink.
for example line in figure b is a sink instead ofline9to line11.
algorithm slicingfor null pointer input inter proceduralgraph u1d456 u1d454 output vulnerabilityfeatures u1d463 u1d450 1let u1d456 u1d45d u1d451 u1d454be theinter proceduralpdg in u1d456 u1d454 2let u1d456 u1d450 u1d453 u1d454be theinter proceduralcfgin u1d456 u1d454 3retrieve statements that assign the return value of function calls to pointers as sources u1d452 u1d460 4initialize u1d463 u1d450 5for u1d452 u1d452 u1d460do u1d460 u1d451 forwardslicing u1d452 u1d456 u1d45d u1d451 u1d454 u1d460 u1d450 forwardslicing u1d452 u1d456 u1d450 u1d453 u1d454 u1d453 u1d460 computefirststatement u1d452 u1d460 u1d451 u1d460 u1d450 9choose path from u1d452to u1d453 u1d460asslice u1d460 u1d454 constructgraph u1d460 u1d456 u1d45d u1d451 u1d454 u1d463 u1d450 u1d463 u1d450 uniontext.
u1d454 12returnvc algorithm for null pointer dereference snapvuln takes statementsthatassignthereturnvalueoffunctioncallstopointersas 1375esec fse december3 san francisco ca usa bozhi wu shangqing liu yang xiao zhimingli jun sun andshang weilin sources i.e.
slicing criterion .
to locate the corresponding sinks i.e.
the f irststatementusingthepointersinsources snapvuln f irst performsforwardslicingstartingfromslicingcriterionontheinterproceduralgraphandobtainsallstatementsthataredata dependent onthepointersaccordingtopdg aswellastheexecutionorder accordingtocfg.withdatadependenciesbetweenstatementsand correspondingexecutionorder wecandeducethe f irststatement usingthepointersinsources.aftercollectingthesourcesandsinks snapvuln selects the path from sources to sinks as vulnerability semantics.
the processispresentedinalgorithm .
type integer over f low io .
an integer over f low occurs whenanintegervalueisincrementedaftercalculationtoavalue thatistoolargetostoreintheassociatedrepresentation asdepicted inthe example offigure d .
source thesourceofintegerover f lowisthestatementthatassigns valuetoavariable whosetypemaybeint long short andsoon.
the type indicates the range ofvariables.
sink based onthe characteristics ofinteger over f low those statements that perform arithmetic operations e.g on the variablemaytriggerintegerover f lowvulnerability.therefore snapvuln takes such statements as sinks.
algorithm slicingfor integerover f low input inter proceduralgraph u1d456 u1d45d u1d451 u1d454 output vulnerabilityfeatures u1d463 u1d450 1retrieve all statements thatcontain arithmetic operators assinks u1d458 u1d460 2initialize u1d463 u1d450 3for u1d458 u1d458 u1d460do u1d460 backwardslicing u1d458 u1d456 u1d45d u1d451 u1d454 u1d454 constructgraph u1d460 u1d456 u1d45d u1d451 u1d454 u1d463 u1d450 u1d463 u1d450 uniontext.
u1d454 7return u1d463 u1d450 algorithm snapvuln performsbackwardslicingoninter procedural pdgbytakingsinksasaslicingcriterionuntilthesourceisreached.
similar to the buffer over f low snapvuln does not perform forward slicing by taking the sources as a slicing criterion since it will also includestatementsthatdependonthesourcesbutarenotrelated to the vulnerability.the detailedprocessislistedinalgorithm .
type5 useafterfree uaf .
heapmemoryisexplicitlyallocatedtopointersthroughapifunctioncalls suchas malloc .
oncetheheapmemoryisusedagainafterrelease a useafterfree vulnerability occurs.
figure e displays an example of use after free vulnerability.
algorithm slicingfor use afterfree input inter proceduralgraph u1d456 u1d454 output vulnerabilityfeatures u1d463 u1d450 1let u1d456 u1d45d u1d451 u1d454be theinter proceduralpdg in u1d456 u1d454 2let u1d456 u1d450 u1d453 u1d454be theinter proceduralcfgin u1d456 u1d454 3retrieve all statements thatassignto pointers andinvokefunctioncallsassources u1d452 u1d460 4initialize u1d463 u1d450 5for u1d452 u1d452 u1d460do u1d460 u1d451 forwardslicing u1d452 u1d456 u1d45d u1d451 u1d454 u1d460 u1d450 forwardslicing u1d452 u1d456 u1d450 u1d453 u1d454 u1d460 u1d459 computelaststatement u1d452 u1d460 u1d451 u1d460 u1d450 9forward sliceon u1d456 u1d454from u1d452to u1d459 u1d460 andobtainslice u1d460 u1d454 constructgraph u1d460 u1d456 u1d454 u1d463 u1d450 u1d463 u1d450 uniontext.
u1d454 12return u1d463 u1d450 source similartomemoryleakvulnerability thesourceofuseafter free vulnerability is also an assignment statement that allocates heap memory space to a pointer including standard functions and wrapper functions.sink basedonthecharacteristics auseafterfreevulnerabilitywill be triggered when a program uses memory again after it has been freed.
therefore the sink should be the f irst statement that utilizes thepointerafterthefreeoperation.however determiningwhich statements perform the free operation can be challenging since theymaybewrappedwithinuser de f inedfunctions.toaddressthis we propose capturing the sink by considering the last statement that uses the pointer as the end of the slicing which can ensure that the sink andthe free operation are includedinthe slice.
algorithm foruseafterfree thekeyistolocatethelaststatement that usesthe pointersin sources whichensures theslice contains thesink.toachievethis snapvuln f irstperformsforwardslicing starting from the source on the inter procedural graph and obtains allstatementsthataredata dependentonthepointersaccordingto pdg aswellastheexecutionorderaccordingtocfg.withdata dependencies between statements and corresponding execution order wecandeducethelaststatementthatusesthepointers.after collectingthesourceandsink snapvuln performsforwardslicing fromsourcetosinkontheinter proceduralgraphandgetstheslice as vulnerability semantics.
the details of the slicing algorithm are showninalgorithm .
type double free df .
if the same heap pointer is released twiceormoreinaprogram adoublefreevulnerabilityoccurs as showninthe example offigure f .
source similar to use after free vulnerability the source of double free vulnerability is an assignment statementthat allocates heap memory spaceto apointer.
sink thesinks ofdoublefree aretwo ormore freeoperations on pointersinsources.similartouseafterfree identifyingstatements usedforfreeoperationscanbechallenging.therefore wealsotake the last statementthat uses the pointers as the end of slicing.
algorithm unlike use after free double free is not related to execution order.
the vulnerability semantics of a double free issue areassociatedwithhowmanytimesapointerisfreed.therefore we perform forward slicing on inter procedural pdg from the sources tothelaststatementthatusesthepointersofthesources.inthis way we can track all statements that manipulate the pointers to capturethevulnerabilitysemantics.theprocessissimilartouse after free in algotirhm .
the only distinction is that in steps and10 thealgorithmreplaces u1d456 u1d454with u1d456 u1d45d u1d451 u1d454fordoublefreeanalysis.
consequently we do not present the detailedalgorithm.
.
model design snapvuln f irstemployssixsubmodelsandagnnmodeltolearnvulnerabilitysemanticsfromsixsetsofsubgraphsandinter procedural graph respectively and then ensemble the outputs of these models to make a f inal prediction.
in particular the novel submodel customizesaggnnwithanattentionmechanism whichmakes it effectively capture the structural information within each subgraph and learn distinct weights for the subgraphs within each set to generate representations.
the six submodels are designed to independently capture the vulnerability semantics associated with a speci f ic vulnerability type.
for the gnn model it can be seen as a submodel without attention mechanism aiming to learn comprehensiveprogramsemanticsfrominter proceduralgraphfor vulnerability detection.
this enables snapvuln to detect vulnerabilitiesthat are not coveredbythe slicing algorithms.
1376learning program semantics forvulnerabilitydetectionviavulnerability specificinter proceduralslicing esec fse december3 san francisco ca usa subgraph subgraph ... subgraph k75153 subgraph35 edges nodesh30 h50 h70 h150 node initializationh30 h50 h70 h150sum gru hop 1h31 h51 h71 h151sum gru hop 2h3t h5t h7t h15t 1sum gru hop t...h3t h5t h7t h15tmax pooling hg graph embeddingattention ...hg1 hg2 hgk a...hg1 hg2 hgka1 a2 akhgfc layer sigmoid ggnnpsub figure anexample offigure 3to illustratethepipelineofthe submodel.
.
.
submodel.
each submodel learns vulnerability semantics from a set of subgraphs g u1d4541 ... u1d454 u1d458 per sample.
the submodel f irst transforms nodes and edges in each subgraph u1d454 u1d456into vector representations and then utilizes a ggnn to learn graph representation u1d489 u1d454 u1d456for each subgraph.
after that the submodel leverages the attention mechanism over the graph representations of a set ofsubgraphs gsothatitcanlearntoassigndifferentweightsfor eachsubgraphandobtainthevector u1d489gbytheweightedsummationofeachgraphrepresentation u1d489 u1d454 u1d456.finally wetake u1d489gwitha fullyconnectedlayertogeneratetheoutputofthesubmodel.we describe each componentin the submodelin details below and use anexampleinfigure 3toillustratethepipelineofthesubmodel as showninfigure .
node initialization.
for each subgraph u1d454 u1d456 g it can be represented as u1d454 u1d456 v e where the node u1d463 vin u1d454 u1d456consists of a code statement and the edge u1d452 erepresents different relations betweennodesincludingdata controldependencies control f low and function calls.
since the node u1d463consists of a code statement i.e.
asequenceofmultipletokens toobtainthenodeinitialvector representation we sum up each token vector initialized by a learnable embedding matrix u1d46c r u1d45a u1d451in the code statement where u1d45a is the length of the vocabulary set and u1d451is the dimensional length.
thenodeinitialvectorrepresentationcanbeexpressedas u1d4890 u1d463 r u1d451.
graphembedding.
foreachsubgraph u1d454 u1d456 g weutilizeggnn astheencodertolearnthegraphrepresentation u1d489 u1d454 u1d456.speci f ically for node u1d463in u1d454 u1d456 weutilizea f ixednumberofhops i.e.
u1d447 topropagate theinformationalongtheedges.ateachcomputationhop u1d461 where u1d461 u1d447 we utilize the summation function to aggregate the neighboring node features computed from the previous hop and this processcan be expressedas follows u1d489 u1d461 u1d441 u1d463 sum u1d489 u1d461 u1d462 u1d462 u1d441 u1d463 where u1d441 u1d463 is a set of neighborhood nodes that are connected to u1d463.
then a gated recurrentunit isused to updatethefeature of u1d463 whichcan be formulatedas follows u1d489 u1d461 u1d463 gru u1d489 u1d461 u1d463 u1d489 u1d461 u1d441 u1d463 aftera f ixednumberofhops i.e.
u1d447 weobtainthe f inalnode representation u1d489 u1d447 u1d463forthenode u1d463.wefurtherapplythemax pooling overallnodes i.e.
u1d489 u1d447 u1d463 u1d463 v ofsubgraph u1d454 u1d456toobtainthegraph representation u1d489 u1d454 u1d456as follows u1d489 u1d454 u1d456 maxpool fc u1d489 u1d447 u1d463 u1d463 v wherefc isafullyconnectedlayer.foreachsubgraph u1d454 u1d456 g weobtainitscorrespondinggraphrepresentationdenotedas u1d46e u1d489 u1d4541 ... u1d489 u1d454 u1d458 where u1d46e r u1d458 u1d451.attention.
wefurtheraddanattentionmoduletoensurethat the model learns to assign different weights of subgraphs gfor the prediction.
speci f ically we add an extra token with its initial vector u1d489clsand concatenate it with u1d46eto obtain a new representation u1d46e u1d489cls u1d489 u1d4541 ... u1d489 u1d454 u1d458 where u1d46e r u1d458 u1d451.
inspiredbyselfattention weusescaleddot productattentionto obtaindifferentweightsforsubgraphs ganditcanbeexpressed as follows u1d468 so f tmax u1d478 u1d472 u1d447 u1d451 u1d489g u1d458 summationdisplay.
u1d457 u1d44e u1d457 u1d489 u1d457 where u1d46e u1d478 u1d472 u1d482 r u1d458 1is the vector of the index token in the matrix u1d468 r u1d458 u1d458 u1d44e u1d457is the value of the u1d457 th indexfor thesubgraph u1d454 u1d457inthevector u1d482 u1d489 u1d457 r u1d451isthevectorof the index u1d457in u1d46e r u1d458 u1d451and u1d451is the dimensional length.
the vector u1d482isconsideredastheweightedvectorlearntbythemodel for differentsubgraphs.
prediction.
wetaketheweightedrepresentation u1d489gfollowed byafully connectedlayer for the prediction psub sigmoid fc u1d489g wherepsubdenotes the probability computed by the activation functionsigmoid.
.
.
gnn model.
the gnn model can be considered as a submodelwithoutanattentionmechanism sharingthesameggnn moduleasthesubmodelinfigure .byutilizingtheggnnmodule thegnnmodelconvertstheinter proceduralgraphintoagraph representationdenotedas u1d489i u1d43a.subsequently wemapthegraph representation u1d489i u1d43ato the predicted probabilities in the prediction module describedas follows pig sigmoid fc u1d489ig .
.
ensemble model.
through the above feature learning process we obtain predicated probabilities from the six submodels andgnnmodel.the f inalstepistoensemblethelearnedresults fromthesemodelsforthe f inalprediction.therearemultipleways toachievethisgoal.inthiswork werefertoasimilarpaper whichensemblestwomodelstoidentifysecurity relatedpatches anduseaweightedcombinationofthesemodelsoutputasensemble model whichcan be describedas follows prob u1d6fc psub1 psub2 ... psubi pig 1377esec fse december3 san francisco ca usa bozhi wu shangqing liu yang xiao zhimingli jun sun andshang weilin where u1d456 6and u1d6fc u1d456 .theclassi f icationresultis0for prob less than0.
and1for the others as below prediction braceleftbigg1 ifprob .
ifprob .
evaluation todemonstratetheeffectivenessof snapvuln weconductextensive experiments to investigate the following fourresearchquestions.
rq1 can snapvuln outperform state of the artbaselines?
rq2 can the completeness of the extracted vulnerability semantics affectthe performance invulnerabilitydetection?
rq3 can the precision of the extracted vulnerability semantics affectthe performance ofvulnerabilitydetection?
rq4 what is the memory usage and execution time of snapvuln indetecting vulnerabilitiescomparedto the baselines?
.
evaluationsetup .
.
dataset.
tostudytheaboveresearchquestions weshould choose a dataset containing multi function samples for evaluation since the impact of vulnerability semantic completeness can be revealed by comparing the vulnerability detection performance onsamplesofthesingle functionversionandthecorresponding multi function version.
we search the papers from to for vulnerability datasets in c c and f ind several public datasets includingdevign draper fan d2a andjuliet .
intheend wechooseareal worldvulnerabilitydatasetd2aand awidelyusedsyntheticdatasetjulietasevaluationdatasetssince they are datasets containingmulti function samples.
preprocessing weconductthefollowingstepstopreprocessthe datasets for the evaluation wecollectthesamplesofsixcommonvulnerabilitytypesin c c fromd2aandjuliet and f ilteroutthosesamplesthatcannot beparsedintocodepropertygraphsbyjoern.finally wegetthe f inaldatasetforevaluation asshownintable .sincesamplesin juliet contains tokens with obvious vulnerability meanings such as sink source good and bad wenormalizethemto norm andmapalluser de f inedfunctionnamestosymbolicnames e.g.
func0 .
tosupportthestudy weneedtoobtaintheevaluationdatasets ofthesingle functionversionandthecorrespondingmulti function version.sincethesamplesintheoriginaldatasetsaremulti function we only need to obtain the corresponding single function version.
speci f ically givenamulti functionvulnerability weselectthefunction that triggers the vulnerability as the corresponding singlefunctionversion.fortheexampleinfigure a useafterfree is triggered at line of function smb2 write .
therefore we choose the function smb2 write as the single functionversion.
formodeltrainingandtesting wesplitthedataofeachvulnerability type with the ratio of and then fuse the divideddataofeachvulnerabilitytypeasthetrain validation test setfor evaluation.
.
.
baseline.
toevaluate snapvuln weselect f ivestate of theartlearning basedvulnerabilitydetectionapproachesandtwopopular pre trained approachesasbaselines.
speci f ically the existing f ive vulnerability detection approaches can be divided into twotable the statisticsofthe used datasets.
datasetjuliet d2a samplesloc tokens samplesloc tokens min max avg min max avg min max avg min max avg bo io np ml df uf non vuln total categories function leveldetection i.e.
detectingvulnerabilitiesatfunctiongranularity suchasdevign andreveal .
multi function leveldetection i.e.
detectingvulnerabilitiesat thegranularityofmultiplefunctions suchasvuldeepecker sysevr and deepwukong .
since the pre trained modelsachievepromisingresultsinmanycode relatedtasks we also compare snapvuln with two popular pre trained models i.e.
codebert andgraphcodebert .weusetheirimplementation if available i.e.
reveal sysevr and deepwukong codebert and graphcodebert and re implement the approaches otherwiseaccording to their papers i.e.
devign vuldeepecker .
.
.
metrics.
following previous works we select thewidelyusedmetricsofaccuracyandf1 scoretoevaluatethe vulnerability detection performance of different approaches.
accuracy is the ratio of the number of correct predictions to the total number of input samples which indicates the correctness of identifying both vulnerable and non vulnerable samples.
f1 score is the harmonic mean between precision and recall and indicates the balance between them where precision implies the correctness of predictedvulnerablesamplesandrecallimpliestheeffectivenessof vulnerabilityprediction.
.
.
modelse t ting.
wesettheembeddingsizeoftokensto128 andthebatchsizeto16fortraining.thehopissetto4.thenumber of subgraphs u1d458is set to and on d2a and juliet respectively.
notethatwewillintroducewhyandhowwechoosethenumber ofsubgraphsinsection .
.
.weadopttheadamoptimizerwith a learningrate of .001to train themodel onnvidia rtx a6000 with10 epoch patience for early stopping.
the modelsettings are validatedto achieve the optimal performance viagrid search.
.
.
evaluationprocedure.
forrq1 wecompare snapvuln with baselines on d2a and juliet respectively.
for rq2 to verify the completeness of vulnerability semantics on the detection performance we conduct comparative experiments on the datasets of themulti functionversionandthecorrespondingsingle function version.
fora fair comparison we disable the slicingcomponent and just utilize interprocedural graph to conduct experiments i.e.
snapvuln single snapvuln multi .
for rq3 to evaluate the precision of extracted vulnerability semantics on the detection performance we f irstperformanablationstudyon snapvuln bydisablingtheslicingcomponenttoverifytheeffectivenessofslicing algorithms i.e.
snapvuln multi .
then we compare our proposed slicing algorithms with three typical slicing algorithms respectively proposed by vuldeepecker sysevr and deepwukong for further veri f ication i.e.
snapvuln vuldeepecker snapvuln sysevr andsnapvuln deepwukong .
speci f ically deepwukong extracted subgraphs from pdgs by taking api function calls or arithmetic operationsas aslicing criterion while vuldeepecker and sysevr 1378learning program semantics forvulnerabilitydetectionviavulnerability specificinter proceduralslicing esec fse december3 san francisco ca usa table the evaluationresults on twoopen source datasets.
approachd2a juliet io bo np overall io bo np ml df uf overall acc f1 p r acc f1 p r acc f1 p r acc f1 p r acc f1 p r acc f1 p r acc f1 p r acc f1 p r acc f1 p r acc f1 p r a cc f1 p r devign .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
reveal .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
vuldeepecker .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
sysevr .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
deepwukong .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
codebert .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
graphcodebert .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
snapvuln .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
snapvuln single .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
snapvuln multi .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
snapvuln vuldeepecker .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
snapvuln sysevr .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
snapvuln deepwukong .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
sliced a sequence of code statements on ddgs and pdgs respectively.since snapvuln takesgraphsasinput wetransformthecode statements extracted by vuldeepecker and sysevr into graphs by connectingthestatementsbasedonddgsandpdgs.inthisway we can compare the performance of slicing algorithms of different approacheswithauni f iedmodel snapvuln .
.
evaluationresults .
.
comparisonwithstate of the artapproaches rq1 .
the f irst two rows of table 3present the results of baselines on d2a and juliet.
we observe that snapvuln outperforms baselines on the overalltestset ofd2a andjuliet interms ofaccuracyandf1.
as seen in table snapvuln outperforms vulnerability detectionbaselines f irstrow byat least11 absolutedifferences and surpasses pre trained models second row by atleast interms ofaccuracyandf1ontheoveralltestset whichshowstheeffectivenessofsnapvuln.furthermore formosttypesofvulnerabilities i.e.
buffer over f low memory leak and use after free snapvuln also has higher accuracy except for integer over f low io and double free df on juliet testset.
for these cases the pre trained models achieve higher accuracy.since the samples from juliet are syntheticand simple which leadsto powerfulpre trained models easily capture the inner features among the samples.
in contrast snapvuln outperformsthepre trainedmodelsond2adataset indicatingthat snapvuln ismoreeffectiveforreal worldvulnerabilities.
we attribute this to the vulnerability speci f ic inter procedural slicing algorithms that are designed to capture precise vulnerability semantics.
analysis .we conclude that in most cases snapvuln achieves the best performance for vulnerability detection especially on the real world d2a testset.
it is attributed to the complete and precise vulnerability semantics capturedby the slicing algorithms and the attention mechanismusedinthemodeltodynamicallyassigndifferent weights for subgraphs.
the shortcomings of the baselines aretwofold.ononehand thebaselinessuchasdevigncapturethe vulnerability semantics on the single function which are incomplete for vulnerability detection.
on other hand some approaches such as vuldeepecker sysevr and deepwukong propose the generalslicingalgorithmswithoutconsideringthecharacteristicsof differentvulnerabilitytypesforvulnerabilitydetection which are imprecise.furthermore althoughthepre trainedapproachescan achieve better performance compared with the aforementioned vulnerabilitydetectionbaselines theyare limitedby learningprecise vulnerability semantics that snapvuln does for vulnerability detection.answertorq1 theoverallperformanceof snapvuln outperformsexistingapproachesonthereal worlddatasetd2aandthe syntheticdataset juliet.
.
.
the completeness of vulnerability semantics rq2 .
the resultsofsnapvuln singleand snapvuln multiarepresentedintable3 we can observe that the overall detection performance on multi function datasets is better than single function datasets in terms ofaccuracyandf1 ond2a andjuliet.
inparticular theaccuracyformulti functionversionare2.
and .
higher than that of single function version on the overall testsets of d2a and juliet.
furthermore we f ind that the performance of each vulnerabilitytype is improved when using multi function datasets d2a and juliet.
in addition the magnitude of the improvement on d2a is smaller than juliet.
for example the vulnerability type integerover f low ond2aincreasesby2.
inaccuracywhile juliet increasesby9.
.
analysis .weattributetheimprovementstotheversionofthe multifunctiondatasetconsistingofthecompletevulnerabilitysemanticstohelpthemodellearnmorevulnerability relatedfeatures comparedwiththesinglefunctionforvulnerabilitydetection.however wealsoneedtopointoutthatwhenintroducingmulti function fordetection wealsointroducesubstantialnoise i.e.
vulnerabilityirrelevant semantic information for the model especially in the real world dataset d2a.
in contrast the juliet dataset is a synthetic datasetthatcontainsfewercodestatementsunrelatedtovulnerabilities.hence theirrelevantinformationislessthand2aonthe version of multi function datasets which provides more noticeableimprovements.italsoindicatesthatthecompletevulnerability semantics are not sufficient for the model to obtain good performanceandsomeslicingalgorithmsareneededtoextractprecise vulnerabilitysemantics for the detection.
answertorq2 thecompletenessoftheextractedvulnerability semanticsaffects theperformance ofvulnerability detection.
although some vulnerability irrelevant semantic information is introducedatthesametime itcanstillimprovedetectionperformance.italsoindicatesthatpreciseslicingcriteriaaredemanded to reduce the noiseandfurther improve the performance.
.
.
the precision of vulnerability semantics rq3 .
the experimentalresultsofdifferentslicingalgorithmsthatbaselinesused arepresentedinthelastrowoftable .first comparingtheresults ofsnapvuln withsnapvuln multi we can f ind that the improvementsaresigni f icant whichdemonstratesthatslicingisaneffective approach to remove vulnerability irrelevant information for 1379esec fse december3 san francisco ca usa bozhi wu shangqing liu yang xiao zhimingli jun sun andshang weilin vulnerabilitydetection.furthermore bycomparingtheresultsof differentslicingalgorithmswith snapvuln we f indthat snapvuln achieves better performance in terms of vulnerability detection which demonstrates that our slicing algorithm is effective in extractingrelevantvulnerabilitysemantics.
speci f ically whenusingtheslicingalgorithms theaccuracyof snapvuln on the overall testset of d2a and juliet increases by .
and .
respectively.
furthermore the accuracy of each type ofvulnerabilityond2aandjuliethasalsoimproved.inaddition compared with other slicing algorithms snapvuln achieves .
.
.
higheraccuracythanvuldeepecker sysevranddeepwukong on the overall testset of d2a and .
.
and .
on juliet.
analysis .the improved performance by snapvuln can be attributed to the precise vulnerability semantics captured by the proposed slicing algorithms for the six most dangerous vulnerability types.
through the vulnerability speci f ic inter procedural slicingalgorithms snapvuln isabletoextractfeaturescontaining precisevulnerabilitysemanticsasthemodelinputfromsamples thus improving the effectiveness and accuracy of snapvuln.
on the contrary the baselines either perform slicing on ddg to obtain allstatementsthataredata dependentonapifunctioncalls e.g.
vuldeepecker orsliceonpdgtogetrelatedstatements e.g.
sysevranddeepwukong asvulnerabilitysemantics withoutconsidering the characteristics of different vulnerability types.
therefore theyinevitablyintroducestatementsirrelevanttovulnerabilities as modelinput resultinginpoorperformance.
answer to rq3 the precision of the extracted vulnerability semanticsisvitaltotheperformanceofvulnerabilitydetection.
compared with other slicing approaches we con f irm that our slicing algorithms extractmore precise vulnerabilitysemantics.
.
.
performance analysis rq4 .
in this rq we f irst conduct experiments to determine the optimal value of u1d458that achieves the best performance while keeping training feasible.
based on this selected u1d458 we further analyze snapvuln and baselines with respect to the time spent on constructing and analyzing a sample and memory requirements for training andtesting.
choice of k .the value of u1d458 i.e.
the number of sampled subgraphs per set in each sample may affect the memory requirement and vulnerability detection performance since a larger u1d458requires more memoryformodeltrainingandtesting whileasmaller u1d458valuemay causethelossofvulnerabilitysemanticsoflargesamples resulting indetectionfailure.weexperimentwithdifferent u1d458todetermine the optimal value.
as depicted in figure a and figure b we observethat valuesbelow u1d458 16and u1d458 4showworse resultsin d2a and juliet respectively.
additionally increasing the values of u1d458does not result in consistent improvement.
hence setting u1d458to for d2a and for juliet can be considered a reasonable sweet spot betweencapturingsufficientinformationforvulnerabilitydetection andkeepingtrainingfeasibleinthegpu smemory.furthermore from the table in figure a and figure b we can f ind that the average number of subgraphs per set is and in d2a and juliet respectively.
setting u1d458above in d2a and above in juliet may be bene f icial forsomelarge samples.
however in most cases subgraphs in d2a and subgraphs in juliet contain sufficient a d2a b juliet figure the impact of u1d458on accuracyand f1.
table time andmemory spenton the twodatasets.
datasetd2a juliet time s memory gb time s memory gb constructing analyzing cpu gpu constructing analyzing cpu gpu devign .
.
.
.
.
.
.
.
reveal .
.
.
.
.
.
.
.
vuldeepecker .
.
.
.
.
.
.
.
sysevr .
.
.
.
.
.
.
.
deepwukong .
.
.
.
.
.
.
.
codebert .
.
.
.
.
.
graphcodebert .
.
.
.
.
.
snapvuln .
.
.
.
.
.
.
.
informationforvulnerabilitydetection whichmaybeattributed to the overlap between thesesubgraphs.for example somesmall subgraphsmaybepartofthoselargersubgraphs sincetheymay be sliced from branches of those larger subgraphs.
this may result inthesesubgraphs containingduplicatevulnerabilitysemantics.
time and memory .all approaches with the exception of the pretrainedmodels i.e.
codebertandgraphcodebert arerequired to construct graphs for vulnerability detection.
considering the varioustimerequiredforgraphconstructionandanalysisacross different samples we calculate the average time across all samples torepresentthetimespentbyeachapproach.fromthetable we can observe that snapvuln spends more time than the baselines especiallythetimespentonconstructingthegraphs.thatcanbe attributed to the incorporation of inter procedural graph construction and the execution of multiple slicing algorithms.
however in practice we reduce the time toless than .5secondpersample by multiprocessing making the time spent by snapvuln acceptable.
furthermore regarding memory usage werecordthe maximum memoryconsumedbyeachapproach.since snapvuln employsmultipleindependentlytrainedsubmodels wetakethelargestmemory consumed by these submodels as its f inal result.
as can be seen fromtable snapvuln consumesmore memory in cpuand gpu compared to the baselines during model training except for the pre trainedmodelsonjuliet especiallyinthereal worlddataset d2a.however comparedtodevignusingthesameggnnnetwork the gpumemoryusage of snapvuln hasonlywitnessedaminor increase with an additional .
gb.
this can be attributed to the preciseslicingalgorithms whichgreatlyreducesthesizeofeach subgraph.
as a result despite the utilization of multiple subgraphs per sample for vulnerability detection the memory requirement remains relatively stable and does not experience signi f icant increase.hence snapvuln provedtobeacceptableintermsoftime andmemory requirements.
answer to rq4 snapvuln is optimal with u1d458of on d2a and on juliet.
although snapvuln takes more time and memory than baselines itprovedto be acceptable.
1380learning program semantics forvulnerabilitydetectionviavulnerability specificinter proceduralslicing esec fse december3 san francisco ca usa discussion when scaling snapvuln to real world industry databases it may encounter challenges of the diversity of vulnerability types and sample size.
vulnerability types .
vulnerabilities in real world codebases are diverse and the slicing algorithms in snapvuln may not coverevery single case.
in thiswork we employmultiplesubmodels and a gnn model to individually capture the distinct types ofvulnerabilitysemanticsforvulnerabilitydetection.ononehand the gnn models can capture comprehensive program semantics to detect those vulnerabilities that are not handled by slicing algorithms.ontheotherhand thismodularapproachenables snapvuln to easily accommodate other vulnerability types by simply adding new slicing algorithms and submodels without the need to retrain existing submodels.
furthermore it helps prevent the aggregation of all subgraphs into a single model thereby mitigating the substantialincreaseingpumemoryrequirements.
samplesize .
when dealing with large samples such as entire programs that can spanthousandsoflinesofcode snapvuln mayfacechallengesin processing and analyzing them effectively.
to scale snapvuln to those samples with immense lines of code we may increase the value of u1d458or employ methods to divide them into smaller pieces for testing.for instance thesamplesare constrainedto functions at the f ile level orwithin the three calllevels.
threats to validity internal validity some samples may be mislabled in the datasets i.e.
d2a and juliet .
on one hand we trust most oftheirlabelingresults sincejulietismaintainedbythedomain experts in nist and d2a is collected through differential analysis andenhancedwithanindustrial strengthstaticanalysistool.on the other hand we manually validate both datasets and remove thosemislabeledsampleswefound.
thetool joern mayfail togeneratethecorrectinter proceduralgraphsforsomesamples.
to avoid this problem we delete those samples that are incorrectly parsedby joern .
snapvuln leveragesaggnntocapturevulnerability semantics for vulnerability detection.
however different models may be suitable for different vulnerability types.
for example gnns whichcanencodecodestructureinformation maybe better suited for vulnerability types involving complex logic while pre trainedmodelsmaybebettersuitedforsmall sampleorsimple vulnerabilitytypes sincetheylearnalotofbackgroundknowledge from a large code corpus with huge model parameters.
more research should be conducted to study how to choose appropriate modelsforspeci f icvulnerabilitytypes.
inrq3 were implement the slicing algorithms from the baselines in snapvuln by following their provided implementation as outlined.
the reproduced algorithms mayhave somedifference from the originalones.
externalvalidity snapvuln isdesignedtodetectvulnerabilities in c c program.
to support other programming languages it is necessarytodesignslicingalgorithmstailoredtothevulnerabilities speci f ic to those languages.
furthermore vulnerability datasets for thoselanguagesare alsorequiredto retrain the models.
related work program slicing techniques.
program slicing is a useful decompositiontechniqueforextractingprogramstatementsrelevanttosome special computation starting from a subset of program behaviourandslicingthatprogramintoaminimalformthatstillproducesthatbehavior .itwas f irstproposedbyweiser in1979 which supports intra procedural program slicing.
after that many studiesrelatedtoprogramslicingsareproposed suchasextensions ofthealgorithmproposedbyhorwitz computing efficiency and sdg construction .
program slicing has been applied to many aspects of the software development life cycle includingsoftwaremaintenance softwaremeasurement and software debugging .
it has also been used to capture program semantics to generate coderepresentationsinlearning basedvulnerabilitydetectionapproaches .however theseprogramslicingalgorithms include vulnerability unrelated statements for code representation generation.
in this paper referring to the inter procedural chopping which identi f ies the statements that cause the de f initions ofthesourcetoaffecttheusesofthesink weproposevulnerabilityspeci f ic inter procedural slicing algorithms to capture precise vulnerability semantics for code representation generation.
gnnsforsoftwareengineering.
sincegraphneuralnetworks gnn cancaptureextensivestructureinformationincode ithas becomeincreasinglypopularforvarioustasks insoftwareengineering.forexample fortypeinference task allamanis et al.
propose modeling the type information foroptionally typedlanguagesbyembeddinganabstractsyntax tree and data f low analysis based graph with a gated graph neural network ggnn for code summarization task attempts has been madetoincorporatesynacticalandsematiccodeinformationleveraginggraphneuralnetworks whichempiricallydemonstrates superior performance than sequence based models.
for vulnerability detection graph neural networks are widely used to leveragestructureinformationsuchascontrol f lowandprogramdependencyinthecodetogeneraterepresentations .
therefore inthispaperweleverage graphneuralnetworktocapture vulnerability semantics in the code for vulnerability detection.
conclusion we propose snapvuln a novel learning based approach which employs vulnerability speci f ic inter procedural slicing algorithms for different vulnerability types inc c to capture complete and precise vulnerability semantics for code representation generation andincorporatestheattentionmechanismtothegatedgraphneural network ggnn to ensure the modelassign different weightsfor subgraphstolearnbetterrepresentations.extensiveexperiments on two public datasets demonstrate that snapvuln outperforms seven state of the art baselines.
we also conduct an ablation study todemonstratethatthecompletenessandaccuracyofvulnerability semantics contributeto the performance improvement.