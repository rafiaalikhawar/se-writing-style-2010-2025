on the benefits and limits of incremental build of software configurations an exploratory study georges aaron randrianaina univ rennes cnrs inria irisa umr f rennes france georges aaron.randrianaina irisa.frxhevahire t rnava univ rennes cnrs inria irisa umr f rennes france xhevahire.ternava irisa.fr djamel eddine khelladi univ rennes cnrs inria irisa umr f rennes france djamel eddine.khelladi irisa.frmathieu acher univ rennes cnrs inria irisa umr institut universitaire de france iuf f rennes france mathieu.acher irisa.fr abstract softwareprojectsusebuildsystemstoautomatethecompilation testing and continuous deployment of their software products.
as softwarebecomesincreasinglyconfigurable thebuildofmultiple configurations isa pressing need but expensive andchallenging to implement.
the current state of practice is to build independently a.k.a.
clean build a software for a subset of configurations.
while incremental build has been studied for software evolution and relatively small changes of the source code it has surprisingly not been considered for software configurations.
in this exploratory study we examine the benefits and limits of building softwareconfigurations incrementally rather than always building them cleanly.
by using five real life configurable systems as subjects we explore whether incremental build works outperforms a sequence of clean builds is correct w.r.t.clean build and can be used to find an optimal ordering for building configurations.
our results show that incremental build is feasible in of the times in four subjectsandin78 ofthetimesinonesubject.inaverage .
oftheconfigurationscouldbebuiltfasterwithincrementalbuild while also finding several alternatives faster incremental builds.
however only of faster incremental builds are correct.
still whenconsideringthosecorrectincrementalbuildswithcleanbuilds we could always find an optimal order that is faster than just a collection of clean builds with a gain up to .
.
ccs concepts softwareanditsengineering softwareproductlines software configuration management incremental compilers keywords configurable software systems build systems configuration build permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
reference format georges aaron randrianaina xhevahire t rnava djamel eddine khelladi andmathieuacher.
.onthebenefitsandlimitsofincrementalbuildof softwareconfigurations anexploratorystudy.in 44thinternationalconferenceonsoftwareengineering icse may21 pittsburgh pa usa.
acm newyork ny usa 13pages.
introduction building software is a crucial activity for developers and maintainersofprojects.variousartifactsareassembled compiled tested and thendeployed presumablysuccessfully.theemergenceofcontinuous integration ci has accelerated this trend with the integration ofbuildservicesintomajorcodeplatforms e.g.
github gitlab .
the goal is to continuously ensuresome quality assurance of software products whether in terms offunctionality or non functional properties e.g.
security executiontime .althoughwidelyadopted buildingsoftwareisincreasinglycomplexandexpensiveinterms of time and resources .
software configurations are adding further complexity to the problem of building software.
different variants of the artifactscan be assembled e.g.
due to conditional compilation directives ifdef s in the source code.
different external libraries can be compiled and integrated as well.
the way the build is realized can alsochange e.g.
withtheuseofdifferentcompilerflags.developers andmaintainersofaprojectwanttoensurethat throughoutthe evolution alloratleastasubsetofsoftwareconfigurationsbuild well.
as most of today s software is configurable in order to fit constraints functionalandperformancerequirementsofusers itis notsurprisingtoobservethatmanyorganizationsbuilddifferent softwareconfigurationsoftheirprojects.forinstance initiatives like kernelci or day build thousands of default or random linux configurations each day .
another example is jhipster a popularwebgenerator thatbuildsdozensofconfigurationsateach commit involving different technologies docker maven grunt etc.
.
thecurrentstateofpracticeistobuildindependentlyasubset of configurations i.e.
in a fresh and clean environment.
this paper proposes and explores an approach called incremental build of configurations.
the idea is simple instead of starting from scratch and cleaning the build s artifacts a configuration can be built from an existing and already completedconfiguration build incrementally .
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa randrianaina et al.
the hope is to reuse artifacts of previous configurations build and thus save some computations resources and time.
this is just a hunch therealquestionistoquantifyhowmuchandwhenyoucan gain or lose compared to a more conventional build.
moreover the approach is not without risk an incremental build may not work or may be incorrect compared to a conventional clean build.
thebuildsystemmayforgettorecompilesomenecessaryartifacts for example.
in fact it is a hypothesis that needs inquiry.
another unknown is about the strategy to order the incremental build ofconfigurations.
given a configuration to build with which other configurations should the incremental build be carried out?
should incrementalbuild beusedall times?there arenumerouspossible orderings possibly with different effects on the correctness andoverall build time.
our goal is to explore these hypotheses and address tothebestofourknowledge new open questions rq1 is incremental build simply possible in real world configurable systems?
rq2 doesincrementalbuildoutperformcleanbuild?
rq3 istheresultofincrementalbuildthesameasthatofcleanbuild?
rq4 is there an order of configurations that brings an optimal overall incremental build time?
novelty.surprisingly whileincremental build issupported and hasactuallybeendesignedforrelativelysmalledits ithasnotbeen explored for software configurations.
a possible reason is that the usualcompilationworkflowandbuildprocesstargetssmall local modifications e.g.
modification of one source file .
building severalconfigurationsinvolvelargemodificationsthatspannumerous sourcefiles thuschallengingbuildsystems.therearenumerous works in the software product line community about variabilityaware analysis .
the idea is to process theconfigurablecodebase exploitingsimilaritiesamongindividualvariantswiththegoalofreducinganalysiseffort.incremental build shares the same principle and aims to leverage similarities amongconfigurations build.however weareunawareofworks thatconsidertheactualbuildofconfigurationsinanincremental way.tothebestofourknowledge investigatingthebenefitsand limits of incremental build at the configuration level has not yet been considered.
significance of the problem.
the promise is to reduce the cost of building software a stressing topic when you think about the environmentalandfinancialcoststhatcompaniesandpublicorgani zationsshouldhavetobear .societyreliesonsoftware but building software has an enormous cost we aim to mitigate thistrend.beyondlinuxandjhipsterexamplesalreadymentioned numerous real world software projects are configurable and actuallybuildseveralconfigurations.thebuildisanecessarystepto checkthecorrectnessofthecode todynamicallytestthesystem toobservenon functionalproperties e.g.
executiontime security tosynthesizeperformancemodels .
owingtothecostandthefrequenciesofsoftwarebuilds anyimprovement is more than welcome for developers and organizations.
practical scenarios.
incremental build is mainly intended to be part of a continuous integration.
with each commit rather than buildingconfigurationsseparately anorderingstrategycanbeused to reduce build time or to build much more configurations given a budget.oncethe optimal orderoftheconfigurationsisestablished the benefits can be obtained several times during the evolutionof a software project.
of course the ordering can be updated incase of major modifications.
out of an order the distribution of incremental build of software configurations on different machines is also possible but out of the scope of the paper.
methodology.
this paper designs and performs the first study about incremental build of configurations the purpose is to understand the challenges and practices in a real world setting and togenerate hypotheses about other similar contexts .
our contribution is limited to the study of incremental build on existingand real projects.
on the other hand this study opens new perspectives and brings insights that can be used to design new build systemsorschedulingheuristics.ourdatasetcoversfivesubject systems namely x264 sqlite xz curl and xtermcoveringdifferentdomains respectively video encoding database compression utility network communication and terminal emulator.
though allwritteninclanguage theirbuildprocesshighlydiffers more details in the paper .
we explore whether incremental build works i.e.
produces somethingwithouterrors whetheranincremental strategy outperforms a sequence of clean builds whether the re sult is correct w.r.t.clean build and what an optimal ordering of configurations brings in terms of build time.
significanceoftheresults.
ourresultsshowedthatincremental build is feasible in of the times in four subjects and in of the times in the xzsubject.
on average .
of the configurations could be built faster with incremental build while also findingseveralfasteralternativeincrementalbuilds.however only of faster incremental build are correct.
still when considering thosecorrectincrementalbuildswithcleanbuilds wecouldalways find an optimal order that is faster than just a collection of cleanbuilds with a gain up to .
.
overall our results suggest that incremental build of configurations can be beneficial.
owing to the importance and increasing cost of build systems in the field of software engineering it is worth addressing the open issues for fully realizing the potential of incremental build.
the main contributions of this paper are the idea of incremental build of configurations thedesignofanexploratorystudytoinvestigatethepotential benefits and pitfalls of incremental build a quantitative and qualitative analysis of empirical results adiscussionontheimpactsofourworksondevelopers build systemsdesigners andresearchersinconfigurablesystem or continuous integration a link to our publicly available data set for reproducibility.
therestofthepaperisstructuredasfollows.section2givessome background about build systems and introduces incremental build.
section3describesthedesignofourexperiments.section4reports on empirical results and answers research questions.
section 5discusses the impacts of our study and results.
section reportson threats to validity.
section reviews related work.
section formulates research directions after a short summary.
background and motivation thissectiongivesabackgroundonthetoolsandtheprocessthatare commonlyusedtobuildac based configurablesoftwaresystem whicharethesubjectsofthisstudy.then wemotivateourwork with an example taken from the xtermterminal emulator subject.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on the benefits and limits of incremental build of software configurations an exploratory study icse may pittsburgh pa usa configure.ac makefile.amautoconf automakeconfigure makefile.in.
configure makefile figure the workflow of autotools utility .
autotools installing a software package requires having its dependencies e.g.
utilities and libraries available in the current environment.
in addition thepackageneedsalsotoknowwhicharetheavailable features ofthe currentoperating system inorder tobe configured andbuiltaccordingly.withthehighdiversityofoperatingsystems their features and even local hacks by the users it is impossible to manage the configuration script for every possible environment.
for this reason the gnu project introduced the autotools utility to automatically generate configuration and build scripts to fit to the machine it is built upon.
thepresentedc basedprojectsinthispaper assubjects mainly use the gnu autotools with the utilities of autoconf andautomake asshowninfigure1.specifically autoconftakesas inputafile configure.ac inwhichthedeveloperhasspecifiedthe packages to check and to determine which ones can be used or are missing.thenitgeneratesa configure file whichcontainsascript tochecktheavailablepackagesandfeaturesofthecurrentmachine and a script to configure the project given the user s configuration.
ontheotherhand whilewritingasoftwarewithalargeamountof files it is complicated to keep track and specify how to build each one of them.
therefore the developers of c based projects mainly use a makefile to describe how to build the project.
but the makefilesupportisdifferent dependingonthecomputerenvironment.
thisiswhydevelopersrelyontheautomakeutility.specifically adeveloperfirstspecifiesthestructureofthecurrentprojectand how to build it.
then automake generates a makefile.in that has the previous build rules with compatibility on the current machine s environment.
once the configure andmakefile.in are generated theuserneedstorunonlythe configure scriptinorder toconfiguretheproject.the configure scriptcanusedifferentoptionsfromtheuser whicharewell knownascompile timeoptions andgeneratesthe makefile accordingly.afterthisconfiguration step the users need to run the makecommand in order to build the given project.
this entire process is also sketched in figure .
usually autotools is installed on the developer s computer but notontheuser senvironment.thus the configure makefile.am andmakefile.in oftenareshipped withinthecompressedfolder that contains the project s sources.
in this case the user simply needs to execute the configure make make install commandinordertoconfigure build andinstallthatgivenproject.
.
make and incremental build makeisawell knownbuildsystem .makereads makefiles which contain the build rules to build the current software package.
alisting makefile rules illustrated in figure 1util.o util.h util.c cc c util.c 3main.o util.h main.c cc c main.c 5main util.o main.o cc util.o main.o o main figure2 filedependency left andincrementalbuild right makefile can be either generated by using autotools or written by thedevelopersthemselves.toshowhowmakeworks figure2gives an illustrative example of a makefile for a toy project its sourcefiles are not included here .
it is a borrowed example from with the build rules presented in listing .
in the lines of listing is defined the rule util.owhich depends on the header file util.handutil.c.
in its line is described how to build it by using a cccompiler the flag cand the file to compile util.cin order to produce an object file util.o.
thesamethingisdonebythenextruleof main.oinlines3 .the lastmainrule in lines specifies how to build the final main product.
in this case it simply links the util.oandmain.ofiles.
from this makefile make can build a dependency graph like the one shown in figure left .
during the compilation for the firsttime asnothinghas beencompiledyet make willbuildeach of the described rules in the makefile in order to build the final product.
building a project from scratch and from its clean basis is well known as a clean build.
but ifadevelopermodifiesevenafile thenmakewillrebuild only the rules that depend on this file.
to build only the necessary rules makecheckstheirtimestamp.arulemustberebuildifoneofitsdependenciesismorerecentthanit.forinstance ifthedeveloper modifies main.c make will only build the rule that depends on it thatis the main.orule.then therulethatdependson main.o the main andsoon.as util.odoesnotdependon main.c makewill not update it.
these updated rules by make are also highlighted in blue color in figure right .
this process where the build system doesonlytheminimumworkwithoutrebuildingtheunmodified targets is well known as the incremental build.
the incremental build process of make is meant for file changes ofasinglesoftwareconfiguration.however wecanleverageitto apply on files changes that are triggered by different compile time configurations options in a c based system.
indeed configuration optionsareenabledinthecodethroughfileadditionorcpreprocessor directives.
inclusion of more files in a rule forces its update.
moreover additionsofblocksofcodethroughcpreprocessordirectives changes the file s timestamp to a more recent one hence it forces again the rebuild of the targets depending on it.
thus make will only recompile the necessary targets during an incremental build of configurations.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa randrianaina et al.
table example of clean build cb and incremental build ib on four random configurations of xterm c1 options c2 options c3 options c4 options disable active icon disable ansi color disable ansi color disable ansi color diabel color disable direct color disable color disable direct color disable color disable color disable direct color disable color disable color enable broken osc disable color enable broken osc disable broken st disable bold color disable blink cursor disable c1 print other options other options other options other options cb .
seconds .
seconds .
seconds .
seconds ib .
seconds .
seconds .
seconds diff n a .
.
.
total cb .
seconds ib .
seconds diff .
.
motivating example letusconsider xterm astandardterminalemulatorforthexwindowsystem.
xtermhas63compile timeoptions whichmaylead tolessthan263configurations theexactnumberiscertainlylower duetoconstraintsamongoptions .buildingall orevenasubset ofitsconfigurationsiscostlyandtime consuming.itiswhereincremental build can play a positive role.
table shows the build results for four configurations randomly generated for xterm.
the topof table1givesthe optionsofthe fourdiverseconfigurations and the bottom of table gives the build time for clean build of eachconfigurationseparately andtheincrementalbuildofthefour configurations c1 c2 c3 c4.
note that in the incremental build thefirstconfigurationmustbebuiltfromscratchwithaclean build.
only then we can start building incrementally the rest of configurations.
from table we observe that the total sum in time seconds of thecleanbuildsofthefourconfigurationis45 .90seconds.whereas thetotalsumintimeoftheincrementalbuildis41 .42seconds that is thesumofthecleanbuildof c1 hencethe foritsincremental build and of the incremental builds of c2toc4.
this represents a total gain of .48secondsand .
of time difference.
we also observeindividualgainforeveryincrementalbuildofthethreelast configurations respectively .
forc2 .
forc3 and .
forc4.
this gain is only on four configurations and can potentially bemoresignificantthebiggerthenumberofconfigurationsthat needto bebuild.to thebestof ourknowledge no studyexistson exploring the benefits and limits of incremental build on configurablesoftware.therestofthepaperdesignsandreportsonour exploratory study.
experimental approach this section details incremental build experimentation.
we first present the used research questions to address the goal of our experiment.
then we describe the used subject systems with their configurations andtheusedbuildapproachinourexperimentation.
.
research questions the goal of this study is to explore the feasibility efficiency optimization and correctness of incremental build in real life con figurable software systems.
hence we define the following four research questions.table2 subjectsystemswiththeirrespectiveanalysedcommit tag id loc lines of code considered compile time options range of options within configurations and batches system commit tag id loc opt.
range batches x264 ae03d92 .
x sqlite version .
.
.
x xz e7da44d .
x curl curl 7 78 0 .
x xterm xterm .
x rq1 feasibility is incremental build possible in each configurablesystem?
wefirstexplorewhetherthebuildstatus of each of our subject software systems is successful during theincrementalbuildinitsallconsideredsetofconfigurations in some of them or in none of them.
rq2 efficiency does incremental build outperform clean build?to this end we propose a build approach to measure andcomparethecleanbuildandincrementalbuildtimeof each subject system in its respective set of configurations.
rq3 correctness is the result of incremental build the same as that of clean build?
to this end we compare whethertheresultingexecutablebinarysizeanditssymbols arethesameaftertheincrementalandcleanbuildofeach respective configuration in five subject systems.
rq4 optimal ordering is there an order of configurations that brings an optimal overall incremental build time?by using our build approach we analyse whether itexistsanorderofconfigurationssuchthatthesystemwithagivenconfigurationcanbeincrementallybuildfasterwhile being correct.
.
subject systems theobjectsofthisexperimentarefivereal lifesoftwaresystems seetable2 .toselectthem wehadinconsiderationseveralcriteria.
namely the fact that the system is an open source and availableproject it has compile time configuration options is a popular project andcoversadifferent application domain.asaresult we selectedfivec basedsoftwaresystemsassubjects.wefirstselected thecommand linevideoencoderof x264 whichhasbeenwidely studied among the highly configurable systems .
then we selected the widely used sql database engine sqlite the generalpurposedatacompressionsoftwareof xz thelibraryof curl which supports a wide range of data transfer protocols with urls and xterm which is the standard terminal emulator for the x window system.
to reason on a project s popularity we mostly used as a proxy the recent number of stars from to .6k commits from to 27k and contributors in its git repository.
.
variables ourexperimentaimstostudytheincrementalbuildofagivenconfigurable system in contrast to its clean building.
hence the incrementalandcleanbuildofconfigurationsisthe independentvariable wecontrolled.toanswerourresearchquestions weobservedthree dependentvariables namely the buildtime ofaconfiguration the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on the benefits and limits of incremental build of software configurations an exploratory study icse may pittsburgh pa usa system with cb c1 c2...cn c2c3...cnc1c3...cnc1c2...cn 1dv1 dv2 dvn dv12dv13dv1ndv21dv23dv2ndvn1dvn2dvnn 1clean build incremental build figure experimentation workflow.
where cbis the system s baseline configuration and c1 cnare its random generated configurations.
the dvnanddvnmare the measured dependentvariables buildtime executablebinarysize etc.
system s executablebinarysize andthesystem s objectfiles inits build resulting folder after both the clean and incremental builds.
.
build approach to be able to explore the qualities of incremental build in configurablesystemsandanswerourresearchquestions wedesignthe following build approach and apply it in the five subject systems.
given a configurable system with compile time options o o1 o2 ... o m wherem n we first create a sample of configurationsc c1 c2 ... c n for that system.
where n in this study and each ci c has a varying size with a random list of generated options from o .
in figure is given an overview of our build approach.
first it should be noted that each configurable system has a default configuration to which we will refer in the following as the baseline configuration cb .
the system with its cb isattherootofourbuildapproach.then weapplytwomainbuild steps named clean build andincremental build as in figure .
cleanbuild.
inthis step thebaseline systemisbuild witheach configuration ci c from scratch.
during this clean build we measureandrecordthedependentvariables dvi ofci namely the build time the executable binary size and the generated files.
incremental build.
then over each clean build configuration cf.
c1tocninfigure3 weincrementallybuildthesameconfigurations except the current previous applied configuration during the clean build.
for instance over the clean build of cnwe incrementally buildallotherconfigurationsfrom c1uptocn 1exceptthe cnitself.
weassumethattheincrementalbuildof cnafteritscleanbuildwill provide the same results hence it will be insignificant to study.
listings and show an illustrative example taken from the first subject system of x264with two of its used configurations calledc1andc2.
in listing the x264 s baseline system is first build with c1 lines that is it is clean build and then it is incrementally build with c2 lines over the previous build.
similarly in listing3 the system is firstclean build with c2 lineslisting x264 s clean build with c1and incremental build with c2 clean build with c1 .
configure disable interlaced bit depth chroma format disable bashcompletion time make ls l x264 0m20.262s rwxr xr x x264 incremental build with c2 after the clean build with c1 .
configure disable asm disable gpl disable thread disable interlaced time make ls l x264 0m2.256s rwxr xr x x264 listing x264 s clean build with c2and incremental build with c1 clean build with c2 .
configure disable asm disable gpl disable thread disable interlaced time make ls l x264 0m2.422s rwxr xr x x264 incremental build with c1 after the clean build with c2 .
configure disable interlaced bit depth chroma format disable bashcompletion time make ls l x264 0m19.658s rwxr xr x x264 andthenitisincrementallybuildwith c1 lines9 .itshould benotedthatafterthefirstbuild inline9oflistings2and3 instead ofcleaningthedirectorywith make clean wedirectlyconfigure the system tohost the new configuration this is what we referto as an incremental build.
hence we incrementally build the next configuration on top of the previous clean build configuration.
further during each clean and incremental build process we measure the buildtime and the executable binary size of thesystem lines and11 .
moreover we save the state of thebuild system s directory after each build.
in this way we can retrieve usefuldatasuchasthebinary configurationlogsandobjectfiles for further analysis.
.
experiments settings by using the presented build approach we conduct an experiment with the five subject systems.
specifically we build each system by usingtwobatcheswith20randomgeneratedconfigurationseach.
in this way we perform clean builds and incrementalbuilds orintotal800buildsofeachsystem.tocorrectly handleallofthem weusedalocalgitstructurewhereeachsystem buildis savedin anew gitbranch.
theresultinggit structureof a system with all its builds has the same view as in figure .
togeneratetherandomconfigurations weusetherandomproductgeneratorinthefeatureideframework .itshouldbenoted thattherangeofoptionswithinthesampleofconfigurations cf.
column range intable2 changesquiteproportionallywiththe numberofconsideredoptionsamongthesubjects cf.
column opt.
in table .
whereas for their comparison we take two batches with sample of configurations in all five subjects.
further to ensure that the generated set of configurations is diverse enough we looked at the distance between each pair of configurations within abatch.
bydistance we meanthepercentage ofcommonoptions authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa randrianaina et al.
table3 thebuildtimeandbinarysizeofsubjectsfortwobatches b1andb2 with20configurationseach.legendofcolorsis in table .
cb clean build ib incremental build mib minimum ic cib currect ib failed build and no value system c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 c16 c17 c18 c19 c20x264 b1 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c3 c4 c11 c17 c4 c11 c4 c20 c3 c7 c3 c8 c5 c12 c11 c4 c8 c4 c6 c18 ib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.83x264 b2 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c15 c8 c18 c3 c3 c14 c3 c16 c13 c1 c16 c3 c17 c1 c3 c3 c3 c15 c3 c17 ib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.64sqlite b1 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c7 c4 c15 c7 c7 c3 c4 c14 c3 c3 c15 c4 c4 c8 c8 c7 c5 c2 c8 c3 cib tn .
mib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.62sqlite b2 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c3 c16 c4 c1 c15 c20 c8 c3 c3 c9 c4 c3 c5 c4 c5 c2 c6 c12 c3 c16 cib tn .
.
.
mib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.70xz b1 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c18 c18 c18 c10 c9 c8 c5 c18 c17 c18 c13 c20 c18 cib tn .
.
.
.
.
.
.
.
mib tn .
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.01xz b2 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c13 c17 c2 c2 c7 c5 c9 c2 c6 c3 c1 c8 c17 c18 c15 c5 c17 c2 cib tn .
.
.
.
.
.
.
.
.
.
.
.
.
mib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.01curl b1 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c5 c16 c1 c16 c9 c5 c6 c5 c3 c5 c16 c5 c16 c16 c16 c11 c1 c9 c18 c16 cib tn .
.
.
.
.
.
.
.
.
.
.
.
.
mib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.01curl b2 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c13 c11 c11 c11 c11 c13 c11 c13 c13 c11 c13 c13 c11 c13 c11 c13 c13 c13 c13 c11 cib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.89xterm b1 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c3 c1 c10 c2 c1 c3 c2 c1 c18 c2 c20 c2 c1 c1 c2 c1 c15 c1 c1 c2 ib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.89xterm b2 cb tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ib cm c3 c1 c2 c5 c3 c2 c10 c10 c2 c2 c9 c7 c6 c3 c5 c3 c5 c2 c2 c5 ib tn .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bs .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
00x264 b1 x264 b2 sqlite b1 sqlite b2 xz b1 xz b2 curl b1 curl b2 xterm b1 xterm b2 figure the distance between different generated configurations per batch in five subject systemsbetween configurations.
hence the distance between two configurationsci cj c indicates that the sets of compile time options in these two configurations are disjoint sets.
whereas the distance of1indicatesthat ciisthesameoratleastasubsetof cj.figure4 showstheoverallcalculateddistributionofthedistancebetween all pairs of configurations in our five subject systems.
the median distancevariesbetween33 .
inthesecondbatch b2 ofx264and .
in the second batch b2 o fxterm indicating that in each subjecttheconsideredconfigurationswithinabatcharediverseformorethan50 onaverage.wealsoobserved82configurationsof0distancein x264 b1andb2 andin sqlite b2 thatis completely different.then in x264 b1andb2 thereareonlythreecaseswith distance that is entirely included in another one.
we conducted the experiments on a linux workstation running fedora with intel core i7 10610u cpu and .
gib of memory.
to prevent side effects all experiments are run twice using docker andsequentially astheonlyprocessesintheworkstation.moreover authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on the benefits and limits of incremental build of software configurations an exploratory study icse may pittsburgh pa usa thedockerfileofeachsubjectsystemismadeavailable1andcanbe used toreproduce the experiments.at the sameplace we provide the build configurations in all systems with their generated data.
results we now discuss the results with regard to our research questions.
.
feasibility of incremental build rq1 in order to measure and compare the build time and system correctness after an incremental build we first had to ensure thatthe system is successfully building during the clean build of itsconfigurations that is it has a build status and an executablefile is created.
in cases when the system threw an error during thecleanbuildofaconfiguration weanalysedthedependencies between compile time options and resolved the error by removing oneoftheconflictingoptions.forexample weencounteredsuch option sdependenciesintheconfigurationsof xterm.asaresult inourexperimentwithfivesystems thecleanbuildofeachoftheir configurationsissuccessful.putdifferently inallourcleanbuild cases thesystem sbuildstatusis0andasystem sexecutablefileis created.
despitethesuccessfulcleanbuildofallconfigurations wenoticed that some configurations in some systems have a failed build statusduringtheirincrementalbuild.findingoutwhethertheincrementalbuildisfeasibleinasystemornotwashardtodeduceby simplyinspectingitsmakefile.therefore weincrementallybuild all pairs of configurations in five systems and observed their build status includingthepresenceoftheirexecutablefile.asaresult all of the configurations in x264 sqlite curl and xtermare successfully incrementally build.
but there are configurations in xz thathaveafailedbuildstatusduringtheirincrementalbuild.these cases are marked with a dash prime prime in table for batches b1and b2.forinstance byincrementallybuilding xzwithconfiguration c3overanyotherconfiguration in b1 itresultedinafailedbuild status and without an xz s executable file.
based on our experiments with five subjects a successful clean build configurationis not necessarilybuild successfully duringits incrementalbuild.ourinitialobservations basedonlyonthebuildstatusandthecreatedsystem sexecutable arethattheincremental buildis feasiblein ofconfigurations in4systems namelyin x264 sqlite curl and xterm.
whereas the incremental build in xzis feasible in of its configurations.
this indicates that the rest of configurations in xzalways require to clean build.
rq1insights our results show that between in the case of xz and in the case of x264 sqlite curl and xterm ofconfigurationscanbebuiltincrementally.hence instead of always clean building the incremental build of configurations is feasible on highly configurable systems.
.
incremental vs. clean build time rq2 to answer the second research question we recorded the clean build time of each configuration and the incremental build timeof their all paired combinations.
for this purpose we follow the figure the of configurations per system that have a faster slower andfailedincrementalbuild thancleanbuild described build approach in section .
.
in table is given the resultingcleanandincrementalbuildtimeofeachconfiguration fortwobatches b1andb2 ineach subject system.allbuildtimes are expressed in seconds.
specifically the row cb tn shows the obtained clean build time per configuration.
for instance the cleanbuildtimeof c10intheb2ofcurlis50.13seconds.therow mib tn showstheminimumincrementalbuildtimeofconfiguration n from its all paired incremental builds.
for instance the fastest time toincrementally build c2ofb1inxzis .28seconds.
the next row ib cm shows which is the clean build configuration for which the incremental build of a given configuration is faster.
in the case ofxz thec2inb1is incrementally build faster after the clean build ofc18.
to easily notice whether the incremental build of a given configuration is faster than its clean build then the fastest incremental build is colored in green given in the row of mib tn .
otherwise when it is slower it is colored in red.
for instance the incremental build of c1in theb2ofx264is .95seconds o r .14secondsfaster than its clean build therefore it is colored in green.onthecontrary the c12intheb2ofx264is64.56seconds or .12secondsslower than its clean build hence it is in red.
from table it can be observed that in four systems namely inx264 b1 sqlite b1 b2 curl b1 b2 and xterm b1 b2 there is always a pair combination of configurations for which the incremental build of a given configuration is faster.
however in x264 b2 there are from configurations for which the incremental build is always slower than the clean build.
similarly there are7from20casesin xz b1 b2 thatalwayshaveaslowerincrementalbuildthancleanbuild.infigure5isgiventhepercentage of configurations per system that resulted in a faster slower or failedbuildduringtheirincrementalbuild.specifically ofthe configurationsin sqlite curl and xtermhaveatleastonecase where they are incrementally build quicker than during their clean build.further .
oftheconfigurationsin x264and60.
of theconfigurationsin xzhaveafasterbuildduringtheirincremental building.inaverage forallfivesystems .
oftheconfigurations are built faster during their incremental build than duringtheir clean build.
then only .
of them are built slower and .
have a failed built during the incremental building.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa randrianaina et al.
20x264 b1x264 b2sqlite b1sqlite b2xz b1xz b2curl b1curl b2xterm b1xterm b2 figure the number of configurations with a faster incremental build ib than clean build cb in each system in cases when a configuration showed a quicker incremental build we went further and wondered whether it has more than one pair combination for which it is faster than its clean build.
for instance c1in theb1ofxtermis incrementally built over all other 19cleanbuildconfigurations thatis overthecleanbuildconfigurations ofc2toc20.
when it is built over c3 given in the row ib cm itisfasterfor0 .18secondsthanduringitscleanbuilding.but we noticedthattherearealsocasesforwhichthe c1isincrementally built faster which cases are not shown in table .
therefore wecount all these cases and show them summarized in figure .
itresulted that except in two case in sqliteandcurl all their configurations in two batches show a faster incremental build time in all pair combinations with the other configurations.
in the b1 ofx264 there are between and pair combinations for which configurations are incrementally built faster.
in the contrary intheb2ofx264thereareless between1and13pairsofcombinations.
quite similarly in xzthere are configurations that have faster incremental build in up to and pairs of combinations per batch respectively.in xtermthereisalsoalargenumberofcases forwhichaconfigurationcanbeincrementallybuildfaster upto and cases per batch.
hence in the majority of the cases one can find more than one pair combination to incrementally build a configuration faster than in its clean build.
inaddition incaseswhentheincrementalbuiltconfigurations arefaster wethenwonderedforhowmuchtheyare.inthisway we want to find out for how many minutes or seconds one can benefit by incrementally building instead of clean building a configuration.
to analyse it we calculated the difference between the clean build timeandthefastest thebest incrementalbuildtimeofeachconfigurationinallsystems.the obtainedresultsareshowninfigure7.
the gained time by incrementally building a configuration in x264 is between and .34seconds.
quite similarly in xzis between and .82seconds.i nxtermis the smallest gain between .
and .58seconds.
whereas in sqliteis the largest gained time between54 .44secondsupto1minute and 45seconds.thisseems to be related also with the taken time to build the system itself.
forinstance xtermhas the smallest build time less than secondsin all cases.
hence the gained time during the incremental build is thesmallestin xterm.theoverallgainedtimeforanincremental build configuration in all systems is between i.e.
it is the same time as in the clean build and almost minutes.
00x264 b1 x264 b2 sqlite b1 sqlite b2 xz b1 xz b2 curl b1 curl b2 xterm b1 xterm b2 figure the gained time in seconds by the incremental build of configurations instead of their clean build these findings show several things.
first in the majority of the cases .
the incremental build of a system s configuration is fasterthanitscleanbuild.asuccessfulcleanbuildconfiguration may have a fail incremental build in .
of the cases .
thirdly in order to benefit on time during the incremental build the order of buildconfigurationsmaymatter.then dependingonthesystem one can find more than one pair combination of configurations between and to quickly build a given configuration.
the gained time per configuration is quite large from secondsto 1minute and 45seconds .
benefiting in terms of seconds can be significant forexample incaseswhenthesystemneedstobeoften build and regarding several configurations.
rq2insights theincrementalbuildofagivenconfiguration canoutperformitscleanbuild butthegaindependsonthe configuration that was previously built.
our results show that inaverage .
ofconfigurationscanbebuildfaster with incremental build.
.
system correctness rq3 the observations in the second research question show that in themajorityofcasestheincrementalbuildofasystem sconfiguration is faster than its clean build.
for instance the clean build time of the configurations in sqliteis between .45secondsand 1minute and 45seconds whereas their fastest incremental build time is always .01seconds.
similar examples can be observed also inxzandcurl.hence weraisedthequestionwhethertheresulting incremental build systems in these cases are also correct.
that is whetherthesystemaftertheincrementalbuildandcleanbuild is exactly the same.
to reason about a system s correctness we first defined the correctness of an incremental build based on somepropertiesofitsproducedbinary.itshouldbenotedthatcomparing the binaries of the same clean and incremental build configuration bit by bit can give inaccurate results.
this happens because the incrementalbuildisnotexpectedtobeanexactreproductionofthe clean build in the binary level.
still two binaries that are produced bythesameconfigurationsharesomesimilarities suchasthebinary size and symbol table.
hence we chose these two properties of a binary i.e.
binary size and symbol table to ensure the system correctness.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on the benefits and limits of incremental build of software configurations an exploratory study icse may pittsburgh pa usa table the percentage of correct systems after their incremental builds based on their binary size bs and symbols legend x264 b1 x264 b2 sqlite b1 sqlite b2 xz b1 xz b2 curl b1 curl b2 xterm b1 xterm b2 fast same bs fast same bs fast same bs fast same bs overall same bs same symbols same symbols in the row of bs in table is given the executable binarysize inmegabytes mb ofeachcleanbuildsystemforeach configuration.thesevaluesaresummarized inthefirstfourrows in table .
as it can be observed we encountered the four possible cases.specifically ofconfigurationsinallsystemshaveafaster incrementalbuildandtheresultingsystemhasthesameexactbinary size as in the clean build.
then .
of their configurations haveaslowerincrementalbuild butstilltheirsystemhasthesame exact binary size.
on the other hand there are .
of configurations inall systems thathave a fasteror slower incrementalbuild buttheirresultingsystemhasalwaysadifferentbinarysize.hence basedonthebinarysize in67 .
ofthecasesthesystemsthatare built incrementallyare correct whereasin .
of the casesthey areincorrect.thesecasescanalsobeeasilyidentifiedintable3by using the legend of the colors given in table .
besides we compared the system s executable symbols after the clean and incremental build of each configuration in all five subjects.
the obtained results are summarized in the last two rows in table .
it can be observed that x264andxtermafter each built configurationsarecorrect thatis in100 ofthecasestheyhave thesamebinarysizeandsymbols.intheothersystems sqlite xz andcurl therearelessnumberofconfigurations between2 and thathavethesamesymbolsduringtheircleanandincremental builds.
in all systems there are .
of configurations for which the resulting system has the same symbols in both build scenarios.
based on these results in almost all incrementally build cases x264andxtermare correct.
after investigation we noticed that the incremental build in these systems is actually not performed by design.
in both cases the configure script is generating a configuration file config.h andxtermcfg.h respectively on which alltheotherfilesdependon.hence aftereachconfiguration everythingisrebuiltfromscratch.therefore theincrementalbuild that we were expecting is actually equivalent to a clean build in these two systems.
in the contrast in xzwe had incremental build issues.
we were getting a same specific linker error telling thatsome symbols are undefined in some libraries.
the reason of the error is that some libraries were supposed to be rebuilt during the incremental build of a configuration but they were not.
further thereasonforwhich curlandsqlitewereincorrectisthesame.
whenevertwoconfigurationssharedthesamefilesandgenerate the same object files then even when the content in these filestable results for the optimal ordering systemtotal clean buildtotal optimal orderingof incremental buildgainreduced n ofclean builds x264 b1 .
.
.
x264 b2 .
.
.
sqlite b1 .
.
.
sqlite b2 .
.
.
xz b1 .
.
.
xz b2 .
.
.
curl b1 .
.
.
curl b2 .
.
.
xterm b1 .
.
.
xterm b2 .
.
.
changes by a configuration they are not rebuild and updated.
consequently theincorrectbuildsinthesesystemsreturnawarning message notifying that there is nothing to build.
rq3insights after anincremental build of configurations configurable systems are likely to be correct in .
of the cases but not always.
specifically the resulting binariesarecorrect w.r.t.theirexecutablebinarysizefor67 .
ofconfigurationsand w.r.t.theirsymboltablefor48 .
of configurations.
.
optimal ordering rq4 nowthatwefoundthatincrementalbuildcanbefasterandcorrect thequestionistowhatextentcanweleverageonthattooutperform clean build of all configurations.
to answer this research question we use our whole data and not only the minimum time that we report in table that is all measured times for the different combinations of incremental build.
for this reason we searched for an optimal ordering of configurations based on build time.
to do that wefirststartbybuildingadirectedgraph g v e wherevertices vareallconfigurationsandedges eareincrementalbuildsbetween configurations2.
we add an edge only when the incremental build issuccessfulandiscorrect.eachedgehasasaweighttheminimum timeofincrementalbuild.theseinformationcomesfromtable3.
then we add a root vertex that is linked with all other vertices by edgesweightedwiththeirrespectivecleanbuildtimes.thisisessen tialforconfigurationsthatcannotbebuiltincrementally.afterthat we run a minimum spanning tree directed graph algorithm .
inthisway wecalculatetheoptimalorderofconfigurationsthat leverages to the best possible time on incremental build.
table shows our obtained results after running our algorithm on all incrementally build configurations for two batches on five subjectsystems.fromthecolumn gain wecanobservethatindeed we are able to find an optimal ordering that allows us to correctly buildallconfigurationswhilebeingfasterbyperformingincrementalbuilds.thegainvariesfrom0 .
to11 .
.furthermore we could observe that we were always reducing the required number ofcleanbuildsinasystem whichvaryfrom1 17to19 times.
where meaning one necessary clean build upon which the 2the graphs are available in our companion page.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa randrianaina et al.
restofconfigurationsareincrementallybuilt and19whereonly one incremental built was possible.
in particular xterm x264 and curldid not need many clean builds and used several incremental builds contrary to sqliteandxz.
for example in the optimized orderfor xtermb1wehadonly1cleanbuildandtherestwasatree ofincrementalbuildsfortherestoftheconfigurations.whereas sqliteb2used only incremental builds and clean builds.
rq4insights itispossibletofindanorderofconfigurations forwhich allincrementalbuildconfigurationsinthisorder arecorrect theoverallincrementalbuildtime withfew cleanbuildsinthemiddleoftheorder isalwayssmallerthan the overall time when configurations are only clean built.
discussion this section discusses the impacts of our results on three actors.
for developers.
from our experiments we observe that rq2and rq4highlightthebenefitsofincrementalbuild while rq1andrq3 highlight its limits.
nonetheless we see that the benefits overcome the limits in particular when finding the correct optimal ordering.
hence developers can already benefit from incremental build.
a current limitation is that the optimal order is specific to a set of configurations and deserves an upfront computational investment.however thereareseveralprojectsthathaveapredefinedor fixed set of default configurations to build e.g.
jhipster .
furthermore the investment can pay for itself with the frequency of commits and thus the use of incremental builds several times throughout the continuous evolution.
besides developers should take into account the specifics of theirprojectsandpossiblyfixtheirbuildartifactstofullyrealizethe potential of incremental build.
for instance the case of xz cf.section .
is challenging a critical library on which the build ofconfigurationsdependsmustbeforcedtorebuild.indeed itisspecifiedthatthebuildrulerelatedtothelibrarymustberebuilt each time allowing it to propagate the build to its dependency and update the new configuration.
this rebuild is unnecessary and the build could be done once and for all.
therefore developers of configurablesoftwarecanmissopportunitiesofrelyingonincremental build due to mismanagement of their build scripts.
forbuildsystemdesigners.
numerousbuildsystemshavebeen recentlydesignedanddevelopedtosupportthespecificneedsof organizations .thedesignspaceofbuildsystemisstill tobeexploredandthecaseofconfigurationsaddsanewdimension.
designers should give an interface between the build rules written bythedeveloperandthebuildsystem sback endwhichisbuildingtheproject.inthecaseofmake theissuesobservedwhenaimingtoincrementallybuildinourcasestudiescannotbeonlyspottedbythe developerinchargeofwritingbuildrules.hence configurationsaware build systems are still to be designed and developed.
we believe the limits and insights of our study can help.
forresearchers.
ourresultscallformoreresearchonthetopicof incremental buildofconfigurations.
researcherscan evaluatethe incrementality of existing build systems most have been designed tosupportvariabilityintime evolution notvariabilityinspace configurations .
we encourage researchers to assess the feasibility correctness and performance of build systemswith the novel scenarioofbuildingsuccessivesoftwareconfigurationsaswedidin thestudy.ingeneral thereisstillalackofevaluationonawider scopeofincrementalbuildofconfigurationswithvariousbuildsys tems .researcherscandesignfurtherempiricalstudies e.g.
confirmatorystudies togainfurtherinsightsorvalidatesome hypothesesofourwork.amajorspecificityofincrementalbuildof configurations is that there is an order to define.
intuitively given a set of configurations the order of their incremental build canbe defined given according to their distance and closeness.
how ever this notion of distance has to be defined precisely.
it can be based on the difference of activated options within configurations or on the relation between options and their implementation oreven include the impact on the build.
therefore understanding whycertain pairs of configurations benefit more from incremental build is an immediate research direction.
it would be interesting to propose heuristics to find an order before the actual build based onconfigurationsimilaritiesandbuildrules.inotherwords how can we automatically find the optimal orders in rq4?i ti sa no pe n problem that deserves much more research e.g.
choice and definitionofametric correlationofdistancewithbuildtime thorough evaluation .
threats to validity internalvalidity.
tomeasurethebenefitsandlimitsofincremental build we had to build several pairs of configurations.
to reduce theriskofinterferencewithotherrunningsoftware weisolated the build environment.
to do so we created one docker image per system with the needed build tools and only needed dependencies.
themachineweusedwasdedicatedtotheexperiment.however someosprocessesandserviceswerestillrunningonthecomputer thatcanbringmeasurementsnoises.nevertheless aswedockerized similarly every run of our experiments we expect that the noiseswouldbesimilar inparticular thatwedidnotlaunchany other task in parallel.
we only run twice the experiments owingto the cost of computations.
moreover there is a threat related tothesamplingusedtogenerateconfigurations.wedeliberately used random sampling to diversify our data sets of configurations.
however we observe from figure that our configurations are relativelydisjoint.nevertheless foreachsamplebatch werepeat theexperimentprocess2times.finally tocheckforthecorrectness ofanincrementalbuild wecomparedthesizeandsymbolsofthe produced binary with the one produced with a clean build.
externalvalidity.
weexperimentedonfivesubjectsthatarecbasedconfigurablesoftwaresystemswiththemakebuildsystem.
although we think that the incremental build would be applicable in other build systems and software technologies we cannot generalize our results.
further experimentation is necessary.
conclusion validity.
our experimentsshowed promising results for incremental build of configurations by accelerating the buildtime.
we also show limits when it comes to correctness.
eventhough we could still find faster and correct incremental builds whichweusedtofindtheoptimalorderingofconfigurations.to have more insights and statistical evidence further evaluation is needed on more subject systems and larger set of configurations.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
on the benefits and limits of incremental build of software configurations an exploratory study icse may pittsburgh pa usa related work buildsystems.
manyworksexistonincrementalbuildsystems e.g.
but without handling a set of configurations.incaoetal .
theauthorsforecasttheduration ofincrementalbuildjobsforover2thousandofcommitsinglib library and vtk visualisation toolkit .
while incremental build jobs vary in terms of duration they propose a tooled approach buildm t o to forecast how long a job will take based on the dependencygraphextractedfromafirstcleanbuildusingmakao .
buildm t o can estimate the build time of a project after some modifications in its files.
however it is considering only the evolutionofoneconfigurationoftheprojectandnotdiverseoneslikeour preliminary study.
in cser p and fekete they introduce a way todetectonlythenecessaryfilestobuildbyparsingthewholecodebase.
instead of parsing every file from scratch each time which takesanimportantamountoftime theyuseincrementalparsing.
inaddition theyalsocheckthebuildrulesmodificationsassociated withthefiles.hence afiletorebuildisafilethathasbeeneither modifiedorforwhichabuildrulehaschanged.by do not check the binaries metadata such as timestamps like make does and thus avoid issues we present in section .
.
maudoux andmens presentintheirpaperthatincrementalbuildhelps to save time on local builds.
however it is not available yet on continuous integration ci platforms.
indeed incremental build is not brought on ci because of some factors such as the correctness of the produced binary.
in our paper we show that the correctness of incremental build with real world projects based on gnu build system is not ensured due to the make s strategy to perform incremental build over configurations.
further konat et al .provide a dsl to increase the effectiveness of writing build scripts by using theirproposedlanguageofpie .withsuchexpressivebuild scripts analysisanderrordetectioncouldbepreventedbeforehand.
they also introduce a build system that takes track of files and focus only on the part that changed to avoid having too much informationinmemoryandperformstrictlytheminimumwhile being effective.
several empirical studies on build systems have been performed e.g.
.
for instance a case study at google reported a large corpus of builds and build errors mainly focusing on static compilation problems .
beller et al .
performed an analysisofbuildswithtravisciontopofgithub.about ofbuilds show different behavior when different environments are used.inourcase weareconsideringdifferentconfigurationsratherthanenvironments.tothebestofourknowledge incrementalbuild for software configurations has received little attention.
software product line spl and variability.
the spl community develops numerous methods and techniques to manage a familyof variants or products .
configurations are used to build vari ants and are subject to intensive research.
formal methods and programanalysiscanidentifysomeclassesofconfigurations defects leadingtovariability awaretestingapproaches e.g.
.thegeneralprincipleistoexploit the commonalities among variants mainly at the code level.
for instance variability aware execution instruments an interpreter of the underlying programming language to execute the testsonlyonceonallthevariantsofaconfigurablesystem.nguyenet al.implemented varex a variability aware php interpreter to testwordpressbyrunningcodecommontoseveralvariantsonly once .reisneretal .useasymbolicexecutionframeworktoevaluate how the configuration options impact the coverage of the systemgivenatestsuite .staticanalysisandnotablytype checking has been used to look for bugs in configurable software and can scale to very large code bases such as the linux kernel .
though variability aware analysis is relevant in many engineering contexts ourinterestdiffersandconsistsinstudyingthepractice of concretelybuilding asample of representative configurations with an unexplored approach incremental build.
there are several empirical studies about the build of spls and configurablesystems.forinstance halinetal .
reportonthe endeavortobuildallpossibleconfigurationsofanindustry strength open source configurable software system jhipster a popular code generator for web applications.
we are unaware of studies that consider incremental build of configurations.
conclusion inthispaper weconductedanovelstudyinvestigatingthebenefits and limits to incrementally build software configurations as opposed to always cleaning as in conventional build.
by considering fivereal life configurablesoftware systems weexplored whether incrementalbuildworks outperformsasequenceofcleanbuilds iscorrectw.r.t.cleanbuild andcanbeusedtofindanoptimalordering of building configurations.
our results suggest that incremental buildofconfigurationscanreducebuildtimewithouttradingcorrectness.
developers and maintainers can already benefit from this simple approach.
owing to the frequencies of buildin continuous integrationandtheirincreasingcost weencouragethesoftware engineering community build system designers researchers etc.
to further investigate incremental build of configurations.
asafuturework weplantoreplicateourstudywithotherbuild systemsandmorebatchesofconfigurationsamples.wealsoplan to investigate the possibility of having a heuristic for finding automatically the optimal ordering.
this is challenging as it requires to inferaprioritheunknowndistancesamongconfigurations.finally we aim to synthesize knowledge of patterns and anti patterns of incremental build to increase benefits and reduce limits.