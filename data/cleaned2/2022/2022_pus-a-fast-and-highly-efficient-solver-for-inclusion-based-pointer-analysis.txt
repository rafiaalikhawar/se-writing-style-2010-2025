pus a fast and highly efficient solver for inclusion based pointer analysis peiming liu texas a m university college station usa peiming tamu.eduyanze li texas a m university college station usa yanzeli tamu.edu brad swain texas a m university college station usa brad tamu.edujeff huang texas a m university college station usa jeff cse.tamu.edu abstract a crucial performance bottleneck in most interprocedural static analyses is solving pointer analysis constraints.
we present pus a highly efficient solver for inclusion based pointer analysis.
at the heart of pus is a new constraint solving algorithm that significantly advances the state of the art.
unlike the existing algorithms i.e.
wave and deep propagation which construct a holistic constraintgraph ateachstagepusonlyconsiders partialconstraints that causally affect the final fixed point computation.
in each iteration pus extracts a small causality subgraph and it guarantees that only processing the causality subgraph is sufficient to reach the same global fixed point.
our extensive evaluation of pus on a wide range of real world large complex programs yields highly promisingresults.pusisabletoanalyzemillionsoflinesof codesuchas postgresqlin10minutesonacommoditylaptop.onaverage pus is more than faster in solving context sensitive constraints and more than faster in solving context insensitive constraints compared tothe stateof theart waveand deep propagationalgorithms.moreover pushasbeenusedtofindtensofpreviousunknownbugs inhigh profile codebasesincluding linux redis andmemcached.
keywords static analysis pointer analysis causality subgraph acm reference format peiming liu yanze li brad swain and jeff huang.
.
pus a fast and highly efficient solver for inclusion based pointer analysis.
in 44th internationalconferenceonsoftwareengineering icse may21 pittsburgh pa usa.
acm new york ny usa pages.
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
introduction pointeraliasanalysisisafundamentaltechniqueinanenormous amountofprogramanalysisapplications suchasvalue flowanalyses deep bug detectors memory leak detectors etc.itisalsotheprerequisiteofmanycompiler optimizations suchas loop optimization and deadcode elimination.
althoughpointeranalysishasbeenafocusofresearchfordecades it remains an open challenge to scale pointer analysis to large complex codebases.
a crucial performance bottleneck is in solving the pointer analysis constraints.
while precise pointer analysisis known to be undecidable any practical solution must over approximate the exact answer.
a state of the art approach is theandersen style inclusion basedpointeranalysis inwhich pointer assignments are constrained by inclusive relations.
for example a simple assignment q pfrom pointer ptoqproduces the contraint pts p pts q meaning that the points to set of p denoted as pts p is a subset of points to set of q. for a complex assignment involving pointer dereference q p it produces v pts p pts v pts q .
these inclusive constraints while ensuring valid may alias results provide significantly higher precisionthanunification basedapproaches e.g.
steensgaard style .
as real world programs often produce a huge number of constraints quadratic to the number of pointers the key challenge remainedishowtoefficientlysolvetheseconstraints.therewasasignificant effort over a decade ago by pereira hardekopf pearce .
in their work a na ve fixed point algorithm is improved by separatingcomplexconstraintsandpropagatingthepoints toinformationintotwostages byapplyingdifferentstronglyconnected component scc detection strategies e.g.
lazy cycle detection and hybrid cycle detection to reduce the size of the constraintgraph or by sorting the constraint graph topologically to avoidredundantcomputation .morerecently leietal.
proposeanefficientalgorithm dea forhandlingpositiveweight cycles in field sensitive pointer analysis.
liu et al.
propose an incrementalpointeranalysis d4 thatonlyanalyzestheupdated code changes tododge the performance overhead introduced by a whole programpointeranalysis.whiletheseapproachesfurther improvethestate of the artinsomespecificaspects theirfundamental solving algorithm remains the same e.g.
dea still relies on wp to solve the constraints .
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa peiming liu yanze li brad swain and jeff huang a c b o1 o2 o1 o2 z o1 o2 causal nodea c b o1 o2 z o1 o2 iteration n iteration nb figure an example to illustrate the causality subgraph with new edge inserted after iteration n node c is identified as a causal node in iteration n. inthispaper wetacklethistremendouschallengewithanew fundamental solving algorithm.
unlike previous algorithms our new algorithm partial update solver pus only processes a partial constraint graph in each iteration yet still guarantees the same globalfixed point.
the key insight behind our approach is that duringtheconstraintsolvingprocessineachiteration onlyaverysmall causality subgraph is subject to change due to the updates made in previousiterations.withthecausalitysubgraph pusprunesthe constraintgraphtoonlyoperateonasmallsubsetoftheconstraints in each iteration which eliminatesredundant computation across iterations resulting in a much faster algorithm.
compared to prior approaches that apply general graphprocessingtechniquestopointeranalysis pusismoreefficientbecauseitleveragestwouniquepropertiesofpointeranalysis first thesparsityoftheconstraintgraph whichleadstoour definition of causality subgraph second the interconnections between different solving iterations provide the necessary information to minimize the set of causal constraints in the next iteration.
asillustratedinfig.
supposeanewedge a cisinsertedin the previous iteration due to complex constraints cis identified as acausalnode because the points to information carried by a willtakeeffect oncinthecurrentiterationinordertosatisfythe inclusiveconstraints.however bisnotacausalnodebecauseits points to information is not affected by the new edge.
our empiricalresultsshowthat onaverage thecausalitysubgraphincludes less than of the nodes and edges in the full constraint graph indicatingadramaticperformanceoptimizationopportunity the formaldefinitionofcausalitysubgraphisgivenby definition4.
.
fig.
shows an overview of pus.
at a high level pus adopts a similar workflow to the existing two phase constraint solving algorithms in which the constraints are processed iteratively betweentwostages forprocessingsimpleconstraintsandcomplex constraints respectively .
ho wever unlike the existing algorithms whichrepeat thecomputationoverthewhole graphineach iteration pus interactively invokes the two processing phases such that the first phasecomputes a causality subgraph and selectively propagatesthepoints toinformationwithinthecausalitysubgraph based on the information provided by the second phase .
meanwhile asnewpoints toinformationispropagated thefirstphase also collects a subset of all the complex constraints to be processed inthesecondphase.ineachiterationof pus onephaseprovidescausal complex constraintscausal copy b constraintscausal graph computationpoints to propagationprocess simple constraints process complex constraintsselective complex edges processinginserting new edges figure an overview of pus partial update solver.
necessary information for the other to infer a small set of causal constraints to be processed.
in principle the time complexity of andersen stype pointer analysis is bounded by o n2max xd x ne on ak sparseprogram wheremax xd x is the maximal number of statements dereferencingapointer x n eisthenumberofnodes edgesinthe constraintgraph.thevalueof max xd x isboundedbyaconstant k i.e.
max xd x k forreal worldapplications.thefirstportion o n2max xd x summarizes the complexity for handling complexconstraintsandthesecondportion o ne summarizesthe complexityforpropagatingpoints toinformationontheconstraintgraph.aspuspropagatespoints toinformationonlyonthecausality subgraph it reduces the second portion to o n2max xd x n e wheren e is the number of nodes edges in the causality subgraph.
in practice this reduction leads to significant perfor mance improvements because typically n lessmuchnande lessmuchein real world programs.
in summary this paper makes the following contributions we propose pus a novel constraint solving algorithm forinclusion based pointer analysis.
pus identifies a minimal causalitysubgraphtomaximizeperformancewhileensuring that the same global fixed point is reached.
wehaveprovedthecorrectnessof pus.formalproofsare provided in the supplementary materials.
we conduct extensive experiments and show that pus ismore than faster than the state of the art wp wave propagation and dp deep propagation algorithms i n solvingcontext sensitivepointeranalysis andmorethan2 faster in solving context insensitive pointer analysis.
pushasenabledacommercialstaticanalyzerandusedin to find tens of previous unknown bugs in large complex systemsincludinglinux redisandmemcached seehttps coderrect.com openscan .
background in this section we introduce the background of inclusion based pointer analysis.
inclusion based pointer analysis.
the inter procedural inclusionbased pointer analysis abstracts different program statements into the constraints listed in table .
it first scans the target program authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pus a fast and highly efficient solver for inclusion based pointer analysis icse may pittsburgh pa usa table constraints for inclusion based pointer analysis category type statement constraints base address taken v1 o loc o pts v1 simple assignment v1 v2 pts v1 pts v2 simple phi assignment v v1 v2 ... pts v pts v1 pts v2 ... simple call assignment r f v1 v2 ... returnvi nf x1 x2 ... pts r pts v pts x1 pts v1 pts x2 pts v2 ... complex load v1 v2 v pts v2 pts v1 pts v complex store v1 v2 v pts v1 pts v pts v2 complex offset v s.field v pts s loc v.field pts v 1loc o denotes the memory location of object o. a wpvisited node skipped node preexisting edge new edgex y v1 vnx y v1 vn b pus c dp d pusupdated node traversing order figure the comparison between pus wpanddp.
a the solving process of wp the entire graph need to be revisited b the solving process of pus only marked node need to be visited c the solving process of dp v1...vnare visited twice d the solving process of pus v1...vnare only visited once .
and generates three types of constraints base simpleandcomplex .
it then abstracts the target program into a constraint graph definition.
.
.inclusion basedpointeranalysiscanthen be solved by computing the transitive closure of the constraint graph such that for every pair of nodes v1 v2 v if there is an edgee v1 v2 e thenpts v1 andpts v2 are the minimal points to sets that ensure pts v1 pts v2 .
theglobal fixedpoint isreached whenall complexconstraints and simple constraints are satisfied complex constraints are satisfiedbyinsertingnewedgesintotheconstraintgraph foreach load constraint v1 v2 and every v pts v2 we added a new edgev v1into the constraint graph for each store constraint v1 v2 andevery v pts v1 weaddedanewedge v2 vinto the constraint graph and for each offset constraint v s.field and every v pts s we insert loc v.field intopts v .
definition.
.
the constraint graph cg of a program is an attributedgraph g v e pts inwhich visasetofvertices each ofwhichcorrespondstoavariable vintheprogram e v v isa setofdirectededges constraints betweenverticesin v eachofwhich represents a simple constraint between two nodes in the following text the word edge and constraint are used interchangeably and pts v p o wherep o is the power set of the set of objects createdbymemoryallocationoperationsintheprogram isafunction fromv vtos p o that maps a node pointer to its points to set.
limitation of the existing methods we divide the existing constraint solving algorithms for inclusionbased pointer analysis roughly into two categories and summarize their limitations as follows respectively.
methods that process constraints in topological order performing a topological sorting on the constraint graph ensures that con straints are processed in the optimal order by guaranteeing thatthe points to sets of all the predecessors of a node nhave been updatedbeforeprocessing n.inthisway thepoints tosetsofthe predecessorsarethemostrecentlyupdatedbeforepropagatingto the noden.
many algorithms adopt the topological sortingapproachtoboosttheconstraintsolvingtime.despiteof the benefits performing sccdetection and topologicalsorting on largeconstraintgraphsitselfistime consumingandcouldeasily become a bottleneck that slows down the solving process.
fig.
a and fig.
b shows the solving process of wp and pusontheexampleconstraintgraphrespectively asanewedge isinserted wprevisitstheentiregraphagainintopological order on the other hand pus computes the same result by only visiting the three nodes in the causal subgraph marked in grey .
methods that process constraints in undetermined order methods that do not enforce scc detection and topological order on theconstraint graph e.g.
deep propagation dp lazy cycle detection lcd andhybridcycledetection hcd ateach authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa peiming liu yanze li brad swain and jeff huang iteration unavoidablywaste resources on redundantcomputation due to a suboptimal order of constraint processing.
fig.
c andfig.
d showthesolvingprocessofdpandpus on the example constraint graph respectively.
when both pts x andpts y areupdated dpadoptsadepth firstsearchtopropagate fromx vnand from y vnseparately.
as a result the nodes and constraints between v1 vnare visited twice.
however pus shows that when analyzing the graph in topological order i.e.
x v1 y v1and thenv1 vn every constraint only needs to be visited once.
the comparison between the existing two categories of algorithms reveals the dilemma of current algorithms on one hand full scc detection and topological sorting are desired to eliminate redundant computation and to reduce the number of nodes by collapsingnodesinthesamesccintheconstraintgraph ontheother hand applying a complete scc detection on a large graph itself can introduce an unbearable overhead.
we found that the common problem for those works is that they all take a holistic view towards constraint graphs.
instead pus works on causality subgraphs.
by only working on a small subgraph ineach iteration pus can enjoythe benefitbroughtbytopological sorting without introducing too much performance overhead.therationalebehindcausalitysubgraphsandtheuniqueinterconnectionbetweendifferentphasesofthesolvingprocessare summarized as follows constraint graphs for real programs are by nature sparsely connected.
the sparsity of constraint graphs is a result of modularization of modern software thus fewer connections betweendifferentmodules aswellasthe locality1ofprogram statements thus fewer connections between different statements .asconstraintgraphsareabstractedfromprograms anupdateononespecificnodeintheconstraintgraph willlikelyonlyaffectalimitednumberofneighboringnodes.
thus in each iteration during the solving process and with limited nodes whose points to sets are updated only a very small subset usually according to our experiments of thenodes casualnodes arerequiredtobeprocessed whichmeansthattopologicalsortingandpoints tosetpropagation only need to be done on a small causality subgraph of the entire constraint graph in each iteration.
being ableto precisely infer a smallsubgraph in each iteration pusdiscoversanothermemoryoptimizationopportunity oneof the most widely adopted optimization techniques used in existing methods and frameworks e.g.
wala is to maintain a cached points to set for every node in the constraint graph wave prop agation even requires an additional cached points to set for everyedgeinthegraph .thecachedpoints tosetisusedtofilter outnon causalnodes whosepoints tosetsdonotgetupdatedinthe currentiteration andtoonlyprocess diffedpoints toinformation.
however if the causality subgraph can beaccurately inferred and most of the constraints in the subgraph are effective i.e.
by processingwhich thepoints tosetwillgetupdated thenthecached 1the locality here has different meaning from the spatial temporal locality in computerarchitecture.here itisusedtoexplainthatmostofthestatementsinthe program are irrelevant e.g.
a andb .points to set can be optionally eliminated to improve the memory efficiency without causing significant performance overhead.
algorithm in this section we describe the detailed algorithm for pus.
we first presenttheoverallstructureof pusinalgorithm1 wethenexplain eachcomponentseparatelyindetailinalgorithm2 algorithm3 and algorithm .
for simplicity we describe pus under the context offield insensitive pointeranalysis.puscanbeextendedforfieldsensitive pointer analysis as we implemented for experiments by adding another type of constraint i.e.
the offsetconstraint into complex constraints similar to the previous work .
.
structure of the algorithm atahighlevel pushasasimilarstructuretowp thatseparates the insertion of new constraints handling complex constraints fromthepropagationofpoints tosets handlingsimpleconstraints .however pus distinguishes itself by connecting the two constraint solving phases using two separate work lists lcopy e a subset of simple constraints that is used to compute the causality subgraph used in following stages.
algorithm partial update solver input a unsolved constraint graph g v e pts result the points to information for every pointer in theprogram 1lcomp 2lcopy 3for each v vdo 4ifpts v then nodes with address taken constraints have non empty points to set 5ccopy v.getcopyconstraints get simple constraints started from the node and insert them into lcopy 6lcopy.insert ccopy insert the node into lcomp 7lcomp.insert v 8end 9end 10whilelcopy do scc collapse on subgraphs of gbased on lcopy 11scc collapse and toposort on subgraphs of g algorithm 12lcomp partially process simple constraints algorithm 13lcopy.clear 14lcopy partially process complex constraints algorithm 15lcomp.clear 16end authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pus a fast and highly efficient solver for inclusion based pointer analysis icse may pittsburgh pa usa lcomp v a subset ofnodes onwhich thecomplex constraints need to be recomputed.
at a high level algorithm can be divided into initialization phase fromline 3to9 scc detectionandtopologicalsortphase line simple constraint processing phase line and complex constraint processing phase line which are explained in detail inthefollowingsections.wealsoreliesonthefollowingconventions to describe our algorithm we refer to any edge e lcopy used in algorithm as an essential edge and refer to any node v lcompused in algorithm as an unsaturated node .w eu s e dst e to denote the set of destination nodes for all edges e e we usesrc e to denote the set of source nodes for all e e w e usein n to denote the set of incoming edges to node n w eu s e out n todenotethesetofoutgoingedgefrom n w eusepred n wherenisanode todenotethe setofpredecessornodes of n w e usesucc n to denote the set of the successor nodes of n. .
detailed algorithm in this section we describe the detailed algorithms of all subcomponents that are used in algorithm .
algorithm scccollapseandtoposortonsubgraphs ofg input a constraint graph g v e pts a list of starting edges lcopy e output a toposorted vector vof sccs that are reachable from at least one of e lcopy 1v prime 2e prime 3pts prime pts 4g prime v prime e prime pts prime prune the graph gto a subgraph g prime 5whilelcopy do 6e lcopy.pop 7ifvisited e then continue skip covered edges 9end 10setvisited e 11e prime.insert e add source and destination nodes of einto g prime 12v prime.insert e.src e.dst 13e prime.insert e prime e prime v.outgoing edges reachable e.dst v true 14v prime.insert v prime reachable e.dst v true 15end perform scc detection on the subgraph g prime also sort the graph internally 16v tarjan g prime return the toposorted vector v 17return v subgraph scc detection asshowninalgorithm2 thescc detection is performed on the subgraph g primeinstead of the original graphg.
the set of edges and nodesin g primeis computed according to the reachability from the constraints in lcopy.
the node set n primeofg primeconsists of the sourceanddestination nodes of every constraints in lcopyand all the nodes that are reachableforatleastoneofthe destination nodesoftheconstraints inlcopy.theedgeset e primeofg primeconsistsof alltheedgesin lcopy and all the outgoing edge of node nthat are reachable from a least one of the destination nodes of the constraints in lcopy.
after scc detection a vector of nodes in topological order is returned by algorithm and used as one of the inputs for algorithm .
note that although algorithm presents the computation ofg primeasaseparatestep g primecanbecomputedalongwithsccdetectionutilizingthedfstraversalperformedbytarjan salgorithm internally.
propagatingpoints tosetonthecausalitysubgraph algorithm3describestheprocedureforprocessingsimpleconstraints.
algorithm3takesasubgraph g primeofgandatopologicallysorted algorithm partially process copy constraints input a constraint graph g prime v prime e prime pts prime a sorted vector of sccs v n a list of effective copy constraints lcopy output a set of node swhose complex constraints need to be processed 1lcomp 2while v.isnotempty do 3n v.pop 4for eache src dst n.getcopyconstraits do ife src dst lcopy src lcompthen changed propagatepointsto src dst ifchangedthen lcomp.insert dst end else prune the graph skip unchanged subgraph continue end 13end 14end 15returnlcomp process a simple constraint between src and dst return true if the points to information is updated 16function propagatepointsto src dst 17pts dst pts dst pts src 18ifdst.changed then returntrue 20end 21return false 22end function authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa peiming liu yanze li brad swain and jeff huang figure4 furtherpruneontheconstraintgraphduringsimple constraints processing phase.
vector of nodes as the inputs.
the topologically sorted vector of nodes ensures that simple constraints are processed in the optimal order to avoid redundant computation.
lcopyis also passed in and usedatline5toperformfurtherpruningonthecausalitysubgraph.
therearetwoimportantdetailsthatareworthnotinginalgorithm during the points to set propagation the algorithm also computesandeventuallyoutputsalistofnodes lcomp to be used in algorithm which contains all the nodes on which the complex constraints need to be processed.
atline11 thealgorithmperformsanotherpruningonthe causality subgraph to further reduce the number of constraints processed by pus.
the computation on lcompis straightforward algorithm simply inserts a node into lcompif the points to set of the node has been updated during the current iteration.
thegraphprocessedbyalgorithm3definesthecausalitysubgraphsineachiteration.inaddition weintroducedthefollowing definition to formally define the causality subgraph.
algorithm partially process complex constraints input the constraint graph g v e pts nodes with effective complex constraints lcomp output a set of processed lcopy 1whilelcomp.isnotempty do 2v lcomp.pop 3foreach l v v.getloadconstraints do process load constraints 4newedges processload l v 5lcopy.insert newedges 6end 7foreach v r v.getstoreconstraints do process store constraints 8newedges processstore v l 9lcopy.insert newedges 10end 11end 12returnlcopy definition.
.
given a constraint graph g v e pts and asetofessentialedges e e theessential edge covered graph g prime v prime e prime pts prime isasubgraphof g wherev prime v1 src e andv1 v s dst e visreachablefroms e prime e e e out n n v1 andpts prime pts.
definition .
given an essential edge covered graph g prime v prime e prime pts prime anditscorrespondingessential edge set e e prime the setofineffectiveedges e andthesetof ineffectivenodes v are determined dynamically during the points to set propagation process.
for noden i f p pred n pts p does not get updated in the currentiteration then n v .similarly e e e out n n v e e .
definition .
given an essential edge covered graph g prime v prime e prime pts prime and a setof ineffective edges e thecausality subgraphg v e pts whichisprocessedbypus isasubgraph ofg prime wherev v prime v e e prime e andpts pts prime.
intuitively definition .
defines the set of nodes and edges that are pruned in algorithm at line and the causality subgraphisdefinedbyexcludingtheprunednodesandedgesfromthe essential edge covered graph.
fig.
offers an example that explains therationalebehindthegraphpruning.infig.
thegreynodesand solid edges are within the essential edge covered graph g primefor the currentiteration.thecorrespondingpoints tosetismarkedbesideeach node.
in this example the incoming update o1 t obep r o p agated within the causality subgraph is already included in pts c duetob c.tofurtherpropagatethepoints tosetfrom cdoes not make any update to c s successors dandein the example thus the causality subgraph can be pruned by skipping c dand c e. in algorithm since nodes are processed in topological order and all the nodes whose points to sets have been updatedin the current iteration are in lcomp the test on src lcompat line returns true only when pts src gets updated in the current iteration.fornode dst ifallthepredecessorsof dstarenotincluded inlcompand thus have not been updated the outgoing edges of dstwill be pruned.
by the end of the computation algorithm outputs lcompafter drainingtheinputtednodevectorandpasses lcomptoalgorithm4.
processingcomplexconstraints algorithm4providesdetailed information on how pus handles complex constraints.
the algorithmtakes lcomp the listofnodes providedbyalgorithm and locatesallthe nodesonwhichthecomplex constraintsneedtobeprocessed.
the processing of the complex constraints follows a standard procedureasdescribedinsection2byinsertingnewedgesintothe constraint graph.
algorithm inserts all the newly added edges intothelcopyandeventuallypasses lcopytobothalgorithm2and algorithm .
note that whether or not a cached points to set should be maintainedsothatpusisabletoprocessonlythediffedpoints toset for complex constraints can be optionally applied.
we omit thecached points to set in our algorithm description as well as our implementationforbettermemoryefficiencyandourexperimental results show that pus is still much faster than techniques which apply the cached points to set optimization.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pus a fast and highly efficient solver for inclusion based pointer analysis icse may pittsburgh pa usa .
proof of correctness weprovethatpuswillreachtheglobalfixedpointbytheendof the computation in this section.
definition.
.
wesaythataconstraintgraph g v e pts is points tosaturated orreachesa points tosaturatedstate ifffor anypairof nodes v1 v2 v if there isapathfrom v1tov2 wehave the minimal sets for pts v1 andpts v2 andpts v1 pts v2 .
definition.
.
wesaythataconstraintgraph g v e pts isconstraint saturated or reaches a constraint saturated state iff for any node v v if there is a load constraint p v o nv then there is an edge e v prime p efor everyv prime pts v and if there are store constraints v p on v then there is an edge e p v prime efor everyv prime pts v .
by definition the global fixed point is reached when the constraint graph is both points to saturated and constraints saturated.
lemma .
given an acyclic constraint graph it will reach a points to saturated state after processing the nodes once in topological order.
square lemma4.
theineffectiveedgeset e isemptyduringthefirst iteration in algorithm .
square theorem .
at every iteration in algorithm the constraint graph ispoints tosaturated afterprocessingsimpleconstraints line and isconstraint saturated after processing complex constraints on unsaturated nodes line .
square proof we prove the theorem by induction.
for the first iteration.
b ylemma .
the first iteration processestheentire essential edge coveredgraph g prime v prime e prime pts prime withanessentialedgeset e e e out n pts n .by lemma .
the subgraph g primewill reach a points to saturated state after simple constraints processing.
to prove the whole graph g will also be points to saturated it is equivalent to show that for nodesn v prime pts n bycontradiction ifthere existsa node n v prime o pts n by the transitivity of constraint graph thereexistsapathfromaddresstakennodeof otonoden.however sincee includesalltheaddresstakennodes outgoingedges node nshould also be included in v primeby definition which contradicts withn v prime.
according to algorithm the unsaturated node setv v pts v after processing simple constraints at line13.itisobviousthatthegraphreachesa constraintsaturated stateafter processing complex constraints on v as no edge needs to be inserted for node nwhose points to set is empty.
combining and theorem .
holds at the first iteration.
suppose theorem .
holds for the n th iteration.
for then th iteration.
we denote the constraint graph at n thiterationbeforeinsertingnewedgesas gn vn en ptsn theconstraintgraphatcurrentiterationbeforeinsertingnewedges asgn vn en ptsn andthecausalitygraph processed at current iteration as g n v n e n pts n accordingtoalgorithm1andalgorithm4 theessentialedge sete n en en.
to prove that a points to saturated state will be reached we prove the following two conditions hold for nodev v n v n ptsn v ptsn v and thus need not to be processed and the pruning on g n 1by removing ineffective constraints in e n 1is sound.
for assumethereexistsanode v vn v n 1and n ptsn v ptsn v .
by the transitivity of constraint graph foro n there exists a path from the address taken node o primeto v denoted as a set p o prime v1 v1 v2 ... v x vy vy v .
case ifforevery e p e e n thene en.byinduction hypothesis the n th iteration reached the points to saturated state thuso ptsn v sincethereisapath pbetweeno primeandv whichis contradictory to the assumption o n .
case if there exists a e p ande e n then by definition v v n 1andvis in the causality graph which is contradictory to the assumption v vn v n .
for assume there exists an edge e e n 1and by processing it whichistocompute ptsn e.dst ptsn e.src ptsn e.dst n ptsn e.dst ptsn e.dst .
since by definition ptsn e.src ptsn e.src aseis an ineffective edge.
to satisfy n we have ptsn e.src notsubseteqlptsn e.dst .
however sincee e n by definition e e n which equals en en.
we can conclude that e en.
by induction hypothesis we have ptsn e.src ptsn e.dst ande.dstis reachable from e.srcby e e nandgis points to saturated which is contradictory to the assumption ptsn e.src notsubseteqlptsn e.dst .
accordingtoalgorithm3andalgorithm1 thesetof unsaturatednodes v n v ptsn v ptsn v .itisobviousthat the algorithm will reach constraint saturated state after processing v v n .byinductionhypothesis inthepreviousiterationafter inserting new edges the constraint graph is constraint saturated and thus for v prime v ptsn v ptsn v they need not to be processed in the current iteration.
combining and theorem .
holds at the n th iteration provided that theorem .
holds in n th iteration.
theorem .
algorithm guarantees the global fix point.
square proof wedenotetheconstraintgraphinthefinaliterationbefore inserting new edges as gf vf ef pts f and the constraint graph in the final iteration after inserting new edges as g prime f vf e prime f pts f sincealgorithm1returnswhenthe essentialedge sete f e prime f ef no edge is inserted by processing new complex constraints.
thus gf g prime f. by theorem .
gfispointsto saturated andg prime fisconstraint saturated and since gf g prime f the final output g prime fare both points to saturated and constraint saturated.
evaluation wehaveimplementeda context sensitive field sensitive pointeranalysis for c c .
the implementation is based on the llvm frameworkandworksatllvmirlevel.inourevaluation wecompared pus with wave propagation wp and deep propagation dp .thetwostate of the artalgorithmsarewidelyadopted in the most recent pointer analysis works .
in our implementation we adopted the sparse bitvector to store points tosetinformation.wedidnotcomparepuswithsomeother authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa peiming liu yanze li brad swain and jeff huang table benchmarks and the constraint graph metrics pointer object and assign shows the number of pointers objects and assignment statements in the tested program respectively .benchmark loc pointer object assign memcached .9k .2k .8k .0k darknet .1k .3k .0k .1k flatbuffers .1k .2k .5k2659.5k nfs ganesha .5k .1k .5k .6k curl .2k .0k .1k .5k sqlite3 .4k .3k .6k1024.4k keydb server .1k .9k .0k .1k vim .9k .9k .1k1826.9k cpython .9k .5k .2k1770.0k postgresql .0m .7k .3k .6k recent techniques e.g.
d4 and dea in our evaluation as theyaresolvingorthogonalissuestopus.infact webelievethat pus can be incorporated with these techniques to provide a faster underlying solving algorithm.
for instance dea used wp in its implementation which can be directly replaced with pus.
thegoalofourevaluationistoanswerthefollowingresearch questions.
rq1 how much reduction can pus achieve by only processing the causality subgraph in each iteration?
in other words how large is the causality subgraph for real world applications when compared to the entire constraint graph?
rq2 intermsofperformance howmuchfasterispuswhen comparedwithstate of the artalgorithms namelywpand dp?
all our experiments are conducted on a commodity personal desktopembeddedwithaninteli7 9750hprocessorwith6cores .6ghz and 128gb ram.
benchmarks weselected10representativeopen sourcedrealworldlargeprojectsasthebenchmarkstoevaluatepus.manyof them have also been studied for the similar purpose in previouspublications .
and they are all popular open source projects varyinginsize.metricsofthosebenchmarksandtheirconstraint graphs are listed in table .
the selected benchmarks are mediumto large sized projects with sizes ranging from .9k to .0m lines of code.
.
rq1 reduction achieved by pus to answer the first research question we ran context insensitive pusonthebenchmarksintable2andcollectedstatisticsaboutthe sizeofthecausalitysubgraphprocessedbypusineachiteration.
the detailed report is listed in table .
table compares the size of different causality subgraphs and analyzes the relative sizes of the causality subgraphs compared with the entire constraint graph.
we report the minimal maximum andaveragenumber of nodes and edges processed by pus to summarize the characteristics ofthe causality subgraph because a different causality subgraph is computed by pus in each iteration.as shown in table on average a causality subgraph only containsaround3 ofthenodesand2 .
oftheedgesintherespective whole constraint graph.
for most of the benchmarks the size of the causality subgraph can be as small as just or nodes and edges evenforlargebenchmarks e.g.
cpythonandpostgresql withmorethan500knodesand300kedges.theminimalcausality subgraph is usually observed in the last few iterations whenthe points to sets of most of the nodes in the constraint graphare saturated.
the result gives us more confidence on the performanceimprovementcanbeachievedbypus asalgorithmslikewp wouldstillneedtore sorttheentireconstraintgraphevenwhen the number of effective nodes can be as low as .
the result also shows that for most of the benchmarks even the largest causality subgraph usually contains no more than of thenodesand30 oftheedgesinthecompleteconstraintgraph.
more importantly according to our observation large causality subgraphs do not occur frequently which is also why the average table3 thesizeofthecausalitysubgraphsprocessedbypus ratiocomparesthesizeofthecausalitysubgraphwiththe whole constraint graph .benchmarkcausality subgraph node ratio edge ratio memcachedmin .
.
max .
.
avg.
.
.
darknetmin .
.
max .
.
avg.
.
.
flatbuffersmin .
.
max .
.
avg.
.
.
nfs ganeshamin .
.
max .
.
avg.
.
.
curlmin .
.
max .
.
avg.
.
.
sqlite3min .
.
max .
.
avg.
.
.
keydb servermin .
.
max .
.
avg.
.
.
vimmin .
.
max .
.
avg.
.
.
cpythonmin .
.
max .
.
avg.
.
.
postgresqlmin .
.
max .
.
avg.
.
.
avg.
.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pus a fast and highly efficient solver for inclusion based pointer analysis icse may pittsburgh pa usa a the footprint of curl b the footprint of sqlite3 new indirect targets resolved new indirect targets resolved figure5 thefootprintofthesizeofthecausalitysubgraphs processed by pus at each iteration when analyzing curland sqlite3.
numberofnodesandedgesinthecausalitygraphisstilllowdespite the existence of some relatively large subgraphs.
our experiments showsthatlargecausalitygraphsnormallyoccurinthefirstfew iterationsatthebeginningofthecomputationand orafterindirect calls areresolvedand newnodes areinserted.
theseobservations are validated in fig.
and will be elaborated in the following paragraphs.
inordertogaininsightsintotheentire lifetime ofthecausality subgraphsandtounderstandhowit evolves astheanalysisproceeds we include two complete also typical footprints that show how the sizes of causality subgraphs fluctuate in each iterationof the whole solving process.
the two data sets are collected byevaluating pus on curlandsqlite3and are visualized in fig.
a and fig.
b respectively.
it is clear that fig.
a and fig.
b exhibit several common patterns the size of the causality graph normally increases greatly as new indirect calls are resolved.
this is because each time when an indirect call is resolved the newly resolved targetfunctionsintroducemanyunprocessednodesandconstraints into the constraint graph.
those unprocessed nodes arelikelytoinvalidatealargeportionoftheconstraintgraph which in turn increases the size of the causality subgraph for the next iteration.
afternewnodesareinserted thesizeofthecausalitysubgraph normally reduces sharply after several iterations.
the size then remains small until another set of new indirectcalls get resolved.
this indicates that the solving process convergesquicklyafterafewiterationsonmostofthenodes table4 performanceof puscomparingwithwavepropagation wp anddeeppropagation dp whenrunningcontext insensitive pointer analysis shows the speedup .
benchmark puswp dp time time memcached .04s .35s775.
.1s150.
darknet .34s .82s435.
.00s194.
flatbuffers .9s195.72s .
.87s .
nfs ganesha .17s .83s327.
.48s137.
curl .45s .45s .
.29s .
sqlite3 .48s .77s125.
.73s .
keydb server .84s .58s56.
.76s19.
vim .17s .81s .
.70s .
cpython .66s .55s .
.91s .
postgresql .2s .9s .
.6s .
avg.
.
andthengraduallyapproachthefixedpointbyonlyprocessing a very small number of nodes at each iteration.
table and fig.
provide strong evidence to support our key observation thesizeofcausalitysubraphsaresmallandupdateson the points to information of certain nodes only affect very limited setofneighboringnodes.fromtheseexperiments wecaneasily understandwhypusisabletoachievesuchadramaticreductionbyanalyzingsmallcausalitysubgraphsinsteadoftheentireconstraint graph at each iteration.
.
rq2 the performance improvement achieved by pus puswasevaluatedinbothcontext insensitiveandcontext sensitive k callsite with k settings.
and compared with wp and dp.
the experimental results are elaborated in section .
.
when running context insensitive analysis and section .
.
when running context sensitive analysis .
.
.
improvement when running context insensitive pointer analysis.inthe context insensitivesetting theexecution timeof each algorithm when running on different benchmarks is given in table .
in summary pus achieves a significant performance improvement compared to wp and dp with more than speedup on average.
for certain benchmarks namely memcached anddarknet puscanbe4 asfasterthan wp.whencomparedwith dp pusis fasteronmorethanhalfofthetestedbenchmarks namely memcached darknet nfs ganesha vimandsqlite3 .
even in the worst cases pus can still be more than faster than dp and wp.
to understand how long ittakes for pus to finish one iteration wealsocollectedtheanalyzingtimespentbypusandwponevery iteration.thevisualizedgraph whenanalyzing curl isshownin fig.
.
from fig.
it is clear that pus is faster than wp in every iterationas pus only processes a small causality subgraph.
note that dp is omitted in fig.
.
it is because while pus and wp usea similar two phases structure and their solving processes can be easilyalignedandcompared.dpadoptsadifferentsolvingstrategy authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa peiming liu yanze li brad swain and jeff huang figure comparison between the running time in ms of pus and wp that is spent on every iteration when runningoncurl.
3rlqwv wr 6hw rqvwudlqwv 2emhfwv 3rlqwhuv figure7 thememoryusagebreakdownforpus dpandwponflatbuffers inmb .
which makes the comparison between pus and dp meaningless when just looking at one iteration.
inourexperiments wealsomadeasimilarobservationasfound in the original wp and dp paper .
the original paper observes that wp has an advantage over dp when analyzing relatively large programaswpisfasterthandpon sqlite3 vim andcpythonanddp isfasterthanwponrelativelysmallerprogramssuchas memcached redis server andnfs ganesha.
the one exception is flatbuffer which has a relatively small number of lines of code .9k while itscorresponding constraint graph is nearly as big as that of largeprograms such as vim.
however unlike wp and dp which have different advantages when analyzing programs of different scales pusoutperformsbothwpanddponallthetestedbenchmarkswiththesizesrangingfrom18 ktoover1mlinesofcode.puscanbe8 faster and achieves at least a speedup.
the fact that pus is able to outperform both wp and dp on benchmarks of varying sizes both large and small indicates that pus is a much more general algorithm that can be applied to all kinds of programs.
inadditiontotheperformance wealsoevaluatedthememory efficiencyof puswhencomparedtodpandwp.fig.7showstypical memory usage breakdowns for pus dp and wp.
as mentioned in section pus can greatly reduce the memory consumptionbecausepusdoesnotrelyonacachedpoints toset toavoidredundantcomputation.thememoryusagebreakdown in fig.
indicates that for both wp and dp the memory used to storepoints tosets includingcachedpoints tosets accountsfortable performance of pus comparing with wave propagation wp and deep propagation dp when running kcallsite sensitive k pointer analysis shows the speedup .
benchmark puswp dp time time memcached .08s .68s708.
.26s210.
darknet .09s .36s484.
.33s389.
flatbuffer .39s .5s .
.8s .
nfs ganesha .28s367.97s .
.54s .
curl .58s266.98s .
.3s587.
sqlite3 .44s .64s .
.3s754.
keydb server .38s .51s .
.66s290.
vim .62s .1s .
.1s .
cpython .33s .9s .
.7s .
postgresql oom oom oom avg.
.
.
themajorityofthememoryusedtoanalyzeaprogram.sincewp requiresanextracopyofthepoints tosetforeverynode andevery edge it requires the largest sized memory to analyze the same program.
dp is more memory efficient when compared to wp as it only requires an extra cached points to set for each node but even for dp the memory used to store the points to set still accountsfor the largest portion of entire used memory.
interestingly the memoryusedbydptostorethepoints tosetaloneislargerthan the entire memory consumption needed by pus.
this shows the greatadvantageof pusovercomparedmethodsasitcanachieve significant performance improvement while consuming much less memory.
.
.
improvement when running context sensitive pointer analysis.in the context sensitive setting k callsite with k the executiontimeofeachalgorithmwhenrunningondifferentbenchmarks is given in table .
surprisingly pus even achieved much higher speedups when solving context sensitive constraints when compared to contextinsensitiveconstraints.theresultsshowsthatonaverage pusis almost7 and9 fasterthan wp and dprespectively.
forcertain benchmarks pus can be more than faster than wp and dp ganesha and more than25 fasterthan dp python .on allbenchmarks pus is at least2 faster than both wp and dp.
the result indicates that pus has a great potential to be adopted widely as thecomputingpowerbecomesstrongerandstrongerandmoreprecise pointer analysis is desired in the future.
thereasonwhypusisabletosignificantlyoutperformthestateof the art algorithms especially when solving context sensitivepointer analysis is still rooted in our key insight that constraint graphsare sparselyconnected.thispropertybecomesevenmoreessential in context sensitive pointer analysis as one node in contextinsensitive pointer analysis can correspond to multiple nodes in context sensitivepointeranalysisbecausethesamevariableisnow analyzed separately under different contexts.
this makes the constraint graph sparser.
thus the effect brought by the update of one node becomes more localas it can only affect nodes under some authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pus a fast and highly efficient solver for inclusion based pointer analysis icse may pittsburgh pa usa particularcontextswhereasonenodecanaffectmanyneighborsin context insensitive pointer analysis even when the neighboring nodes represent variables in a mismatched context.
despiteallkindsofoptimizationsmadewhendesigningpus we stillfounditchallengingtoruncontext sensitivepointeranalysis onextremelylargebenchmarksusingonlycommodityhardware.
asthek limitingforcontext sensitivepointeranalysisincreases thecomplexityofthealgorithmandthesizeoftheconstraintgraph grows exponentially which makes the algorithm hard to scale on large benchmarks.
during the experiments we observed that more than million nodes were created in the constraint graph for postgresql inthefirst5minutes whichrapidlydrainsthememory ofourmachine.amorepowerfulmachineisneededforevaluating pus onpostgresql.
related work pointer analysis is a fundamental building block for static program analyses and compiler optimizations.
as such precise and scalable pointeranalysishaslongbeensoughtafterasaholygrailthatmight unlock all secrets in the program analysis universe.
unfortunately such apointer analysis algorithm hasyet to befound.
all existing implementation of pointer analysis must make some trade off.
across the decades andersen s inclusion based pointer analysis hasemergedasthemostpopularpointeranalyses .manyworks have been proposed to improve the base andersen s analysis.
most ofthe previousresearchabstractspointer analysisasaconstraint graphandpropagatesthepoints toinformationuntilaglobalfixed point.
heintze et al.
introduced a way to avoid the cost of computingthefulltransitiveclosureoftheconstraintgraph.instead a dynamic transitive closure is computed on demand and graph reachabilityqueriesareusedtoresolvepoints tosets.asaresult cycle detection is achieved essentially for free as a result of the graph reachability queries.
however this technique also introduces the potential for redundant work across reachability queries.
later works topologically sort the constraint graph to reduce redundant points to set propagation.
pereira et al.
p r o po s eda newconstraintsolvingalgorithm wavepropagation byseparating the algorithm into three phases collapsing of cycles points topropagation and insertion of new edges.
these three phases areperformed as a wave and repeated until a fixed point is reached.
pusadvancesthestate of the artbyperformingsccdetectionand points to set propagation on the causality subgraph thus avoiding redundant computation in each iteration.
as the difficulty in developing an efficient constraint solving algorithmremains researchersrecentlyturnedtheirattentionto tackle the problem at new angles.
d4 first introduced an incremental algorithm for inclusion based pointer analysis to enable differential pointer analysis on code changes.
the algorithm of d4 is orthogonal to ours and pus can be efficiently integrated with d4 to speed up its bootstrapping constraint solving process.
dea introduced a faster algorithm to deal with positive weight cycle in field sensitivepointeranalysis whileitstillreliesonwavepropagation to compute the fixed point.
anotherlineofresearchformulatespointeranalysisasacflreachability problem.
reps et al.
modelled the flow insensitive pointeranalysisintoacfl reachabilityproblem.spathetal.
proposedaflow andcontext sensitivedemand drivenpointeranalysis that models the pointer analysis as an ifds problem whichthen can be solved by cfl reachability.
this line of research isorthogonal to pus and pus is more efficient when applications frequently query pointer analysis results.
graphsimplificationtechniquescanbeappliedtobothconstraintgraph based and cfl reachability based approaches to improve theirscalability.fahndrichetal.
firstshowedthatcollapsingscc components in the constraint graph can significantly improve the performance of inclusion based pointer analysis.
pearce et al.
introduced an algorithm for online cycle detection.
by keeping the constraint graph topologically sorted cycle detection need only be run when a new edge violates the existing topological ordering.
since detecting cycles upon edge insertion was proven to be too costly pearce et al.
introduced an efficient field sensitive pta thatoccasionallychecksforandcollapsescyclesintheconstraint graph.hardekopfetal.
introducedlazycycledetection lcd andhybridcycledetection hcd .lcdreducesruntimeoverhead even further by selectively triggering cycle detection only whenidentical points to sets are discovered during transitive closure computation.
hcd introduces an offline linear time graph preprocessingstagethatallowstheonlinepointeranalysistodetectcycles withouttheneedforgraphtraversalatall.pusextendstheabove techniquesbynotonlyapplyinggeneralgraphoptimizationtechniques but also leveraging unique properties of constraint graph to only performing the scc detection on causality subgraph.
thus puscandynamically pruneoff themostineffective edgestoavoid redundant points to set propagation.
recent work by li et al.
proposed to simplify the input labeled graph in a cfl reachability problem by eliminating use less graph edges.
pus is similar to this work from a very highlevel.however thisworkprimarilyoptimizethelabeledgraphin cfl reachability problems while pus focuses on simplifying the constraint graphs in pointer analysis.
besides improving the solving algorithm researchers have also proposedtousedatalog forfastandeasypointeranalysis implementation.
while the experimental result indicates a greatpotentialalongthedirection fullycustomizedpointeranalysissolversarestilldesiredandusedbymanyofthemostrecent works as they are easier to be extended and tailored for different needs.
conclusion we have presented partial update solver pus a new constraint solving algorithm for inclusion based pointer analysis.
pus significantlyadvancesthestate of the artinreducingthetimecomplexitybyaquadraticfactor.thekeyinsightisthatonlyasmallportionof theconstraintgraphiseffectiveforthepoints tosetpropagation which can be extracted efficiently into a subgraph called causality subgraph.
we have formally proved the correctness of pus and extensivelyevaluatedtheperformanceof pusonawiderangeof real world large complex programs.
our experimental results indicate that pus is high scalable and significantly more efficient than the state of the art wp dp algorithms.
pus achieves more than speedups when comparing to wp dp in solving contextsensitive and context insensitive pointer analyses respectively.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa peiming liu yanze li brad swain and jeff huang