controlled concurrency testing via periodical scheduling cheng wen csse shenzhen university shenzhen chinamengda he scedt teesside university tees vally ukbohao wu csse shenzhen university shenzhen china zhiwu xu csse shenzhen university shenzhen chinashengchao qin huawei hong kong research center hong kong china abstract controlledconcurrencytesting cct techniqueshavebeenshown promising for concurrency bug detection.
their key insight is to control the order in which threads get executed and attempt to explorethespaceofpossibleinterleavingsofaconcurrentprogramtodetectbugs.however variouschallengesremainincurrentcct techniques rendering them ineffective and ad hoc.
in this paper we propose a novel cct technique period.
unlike previous works period models the execution of concurrent programs as periodical execution andsystematicallyexploresthespaceofpossibleinterleavings where the exploration is guided by periodical scheduling andinfluencedbypreviouslytestedinterleavings.wehaveevaluatedperiodon10real worldcvesand36widely usedbenchmark programs and our experimental results show that period demonstratessuperiorityoverotherccttechniquesinbotheffectiveness and runtime overhead.
moreover we have discovered previously unknown concurrency bugs in real world programs.
ccs concepts softwareanditsengineering softwaretestinganddebugging formalsoftwareverification securityandprivacy formal methods and theory of security.
keywords concurrencytesting concurrencybugsdetection multi threaded programs systematic testing stateless model checking acm reference format cheng wen mengda he bohao wu zhiwu xu and shengchao qin.
.
controlled concurrency testing via periodical scheduling.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
.
corresponding authors shengchao qin and mengda he.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
introduction to make the best of the computing power brought with modern multiprocessorhardware concurrent programmingisnow prevalent.
however it is difficult to ensure that a concurrent program is bug free as unlike sequential programs whose behavioural nondeterminism mainly comes from their input.
the behavior of concurrent programs isalso subjectto howtheir threadsinterleave thus leavingmoreopeningsforconcurrencybugs .testingis usuallyaneffectivewaytoensuresoftwarequality howeverthe same issue of scheduling nondeterminism renders na ve concurrencytestinginsufficientinpractice .indeed testinga concurrentprogramwithoutanyschedulingcontroloftencovers onlyaportionoftheschedulespace failingtoexploretheothersin whichthe bugsmayreside even iftheprogramis testedoverand overagain.noticethatdetectingdataraceisanotherwidelyused solution to find concurrency bugs as data races are widely considered as a cause of concurrency bugs.
but a data race may not be sufficient or necessary to trigger a concurrency bug.
as shown in of data races are benign.
and a concurrency bug can happen in a concurrent program that is race free .
therefore controlled concurrency testing cct techniques utilizingcontrolled scheduling have been intensively studied .
cct usually inserts scheduling points in the target program in front of some key points steps i.e.
instructions that are key to the program s observable behavior such as the instructions accessing shared memory locations or synchronization primitives and controls these key points from various threads to execute in different orders.
when a bug is triggered during execution thescheduling decisions i.e.
the order in which instructions from various threads are executed can be logged and used to deterministically reproduce the buggy execution .
a key practical challenge for cct is how to achieve controlled scheduling.
usually the target program is put in a serialized execution thatis onlyonethreadispickedtoexecuteatatime when the execution hits a scheduling point the scheduler may decide to carryonthecurrentexecutionortopickanotherthreadtoexecute i.e.
a context switch is made .
existing works tend to enforce context switches via preemptions sleeping delay or even dynamic thread priority modifications .
however these scheduling techniques can have pathological interactions with the synchronization operations in the target program.
for example introducing preemptive synchronization e.g.
preemption lock mayleadtoafalsedeadlockthatwasnotoriginallyexhibitedinthetarget programs and injecting different sleeping delays before any key point may have unpredictable results and significantly ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa cheng wen et al.
slowdowntheexecutions peed.moreove r simplyserializingthe executionofthetargetprogram e.g.
disallowingparallelism could introduceundesirablyhighoverhead.thismotivatesustofinda more efficient and effective solution to control scheduling.
anotherkeychallengeis howtoeffectivelyexploretheschedule space.noticethatthesizeofaprogram sschedulespacegrowsexponentiallywiththenumberofschedulingpointsinitsthreads.itisoften practically infeasible to exhaustively iterate the schedule space for real world programs.
schedule bounding techniques are often employed.
the idea behind schedule bounding is that many real world concurrency bugs have a small bug depth that is the number of context switches needed to expose the bug .
therefore controlled scheduling techniques could bound the numberoftheirschedule interferingactivitiesandtremendouslyshrink the schedule space to ideally a space composed of only schedules with context switches no more than a designated number.
existing works explore the schedule space in either a randomized orsystematicway.
randomized testing e.g.
pct and ppct employ a randomizer to generate schedules but they could only provideprobabilisticguaranteesoffindingbugs.systematictesting e.g.
ipb andidb alsoknownasstatelessmodel checking explore all possible schedules within a limited number ofpreemptions or delays but they tendto go througha larger schedulespacethanneeded requiringmoreoverheadormissing somebugs.therefore amoreeffectivewaytoexploretheschedule space is still badly needed.
inthispaper weproposeanovelcontrolledconcurrencytesting technique called period to achievecontrolled schedulingand to effectivelyexplorethespaceofpossibleinterleavings.inperiod the execution of a concurrent program is modeled as periodical execution wherein context switches can be achieved via period switchesnaturally.thatis periodusesaseriesofexecutionperiodstohosttheexecutionofthetargetprogramandkeypointsassigned to anexecution periodonly getto beexecuted whenthe previous periodisfinished.periodicalexecutioncanbeenforcedbydeadline task scheduling without any preemption or sleeping delay.
parallelization i.e.
concurrentexecution canbereadilyachieved byallocatingkeypointsfromdifferentthreadsintothesameperiod in our implementation we put them in the last period .
period employs a period bounding technique to explore the possibleinterleavings.ittakesapresetperiod numberupperbound pandaimstodetectbugswithbug depthlessthan p.theschedule explorationprocessworksasfollows.itstartswiththesmallestpossible period number i.e.
for bugs with bug depth .
for a given period number p period explores schedules systematically in a quasi lexicographicalorderonthecorrespondingthreadidentifiers.
once all schedules of the current period number pare explored itincreasestheperiod number pby1tocarryonexploring until eitherallpossibleschedulesareexploredortheperiod number p reachesthepresetbound p.meanwhile weexploretheschedule space gradually targeting at feasible interleavings.
for that weintroduce dynamic key point slice to represent the key points of each thread that are covered by a dynamic run of the target program.
specifically we statically generate all possible schedules for astartingdynamickeypointslice whereinonlyonekeypointis assumedto be coveredfor eachthread.
duringtheexecutions of thegeneratedschedules somenewdynamickeypointsliceswouldbefound onwhichtheexplorationcontinues.toguidetheexploration on the newly found slices schedule prefixes are constructed based on historical executions.
in addition allowing parallelism enablesustohugelyreducetheschedulespacetoexploreandboost the performance.
we have implemented period and performed a thorough evaluation of period on real world cves and widely used benchmarkprograms.forcomparison wehaveselected6well known andrepresentativeccttechniques i.e.
ipb idb dfs pct maple andthecontrolledrandomscheduling .
our experimental results demonstrate that period substantially outperformsexistingccttechniquesintermsofbugfindingability and runtime overhead.
moreover we have discovered previously unknown concurrency bugs in real world programs.
notice that period focuses mainly on bugs caused by thread interleavings e.g.
user specifiedassertionfailure af use after free uaf doublefree df null pointer dereference npd deadlock dl etc.
our main contributions are summarized as follows wemodeltheexecutionofconcurrentprogramsasperiodicalexecution which uses non preemptive synchronization to achieve controlled scheduling and allows parallelism.
we propose a novel systematic schedule generator that works for eachdynamic key pointsslice of aconcurrent program.the proposed schedule generator allows parallelism and is equipped with a feedback analyzer that uses schedule prefixes to guide further schedule generation hugely reducing the schedule space needed to explore.
we have implemented period and our experimental evaluation confirmsthesuperiorityof periodoverexistingccttechniques.
overview in this section we give a high level overview of period through a simple motivating example selected from the cves .
.
motivating example to illustrate our technique fig.
shows an example simplified fromcve .
two threads t0 t1concurrentlyinvoke thefunction once andaresynchronizedwiththehelpofthree variables i.e.
lock done waiters .
the variable lock allocated inthemainthread ln.
andreleasedinthechildthread ln.
isusedtoprotect the criticalsection ln.
.thevariable done will be set to once the critical section is completed ln.
.
threads created after a thread finishes the critical section would returndirectly ln.
.thevariable waitersindicatesthenumber ofthreadswaitingtoenterthecriticalsection ln.
.theexpectedbehavioristhatonlythelastthreadshouldrelease lock ln.
.
note that all statements except for return in function once either access shared memory locations or contain synchronization primitives therefore are considered as key points.
this program demonstrates three kinds of concurrency bugs namely null pointer dereference npd use after free uaf and double free df all of which have been detected by period.
in moredetail ifthe lockissettonullin t0atln.16before t1uses thelockatln.
anpdwilloccur.auafcanbetriggeredatln.
where thread t0releases the lockat ln.
andthread t1uses the lockatln.
.adfcanbetriggeredatln.15whereboththreads authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
controlled concurrency testing via periodical scheduling icse may pittsburgh pa usa 1static pthread mutex t lock 2static long waiters 3static int done 5void once void if done return waiters pthread mutex lock lock do some thing ... if !done done pthread mutex unlock lock if !
waiters free lock lock null 19void main lock malloc sizeof pthread mutex t pthread t t0 t1 pthread create t0 null once null pthread create t1 null once null pthread join t1 null pthread join t0 null figure an example simplified from cve .
t0andt1trytoreleasethe lock.allthesebugsareactuallyhard totrigger astheyeachrequireaspecificsequenceofoperationson variable done waiter and lock.
we have tested this example with several existing cct techniques.
maple can detect npd but misses uaf and df as it heuristically steers thread scheduling to attempt to force a set of predefinedinterleavingidioms whichdoesnotincludetherequired interleaving idioms of such uaf and df in the example.
pct reliesonarandomizertoexploretheschedulespaceoftheexample.
the probability for finding npd is high but the probabilities for finding uaf and df are very low which are respectively about .
and in our experiment.
ipb and idb are two representative systematic techniques.
both ipb and idb can detect npd and uaf but miss df whose bug depth is i.e.
requiringat least context switches to expose the bug .
the reason is that theytrytoiteratetheschedulingdecisiononeachkeypoint going through a largeschedule space.
moreover their bounds couldnot faithfully reflect the context switch bounds in that they often require potentiallyalot morecontextswitchesthanthedepthofthe bugs they try to expose.
these results demonstrate the limitations of current cct techniques as shown in .
letusnowillustrateourapproachwiththisexampleandexplain how period detects all three bugs.
.
approach overview theworkflowofourproposedcontrolledconcurrencytestingtechnique period is shown in fig.
.
it comprises three main components schedulegenerator circlecopyrt periodicalexecutor circlecopyrt andfeedback analyzer circlecopyrt .
the schedule generator systematically generates schedules for a dynamic key point slice of the target program and feeds them to the periodical executor.
the periodical executor controlsthethreadinterleavingsofthetargetprogramthroughperiodicalexecution followingtheschedulesgeneratedbytheschedule generator.theperiodicalexecutorisalsoresponsibleforcollecting figure the workflow of period.
the runtime information such as the error information and the activatedkeypoints.thefeedbackanalyzermakesuseofhistoricalexecutioninformationtoguidetheschedulegeneratortoeffectively generate legal schedules to cover more untested interleavings.
consideringthemotivatingexampleinfig.
letusstartwith the period num and the starting dynamic key point slice dkps s0 t1 where the integers denote the line numbers ofthestatementsinfig.1andonlythefirstkeypointisassumed to be covered.
the first step is to generate the schedules with periodsforthisdkps.ascheduleisaseriesofexecutionperiods andisrepresentedas ... ... ... ... where ... represents aperiodcontainingthekeypointsthatwouldbeexecutedinthis period.byassigningonethreadtoaperiod weobtaintwoschedules t0 t1 and t1 t0 .
indeed a scheduler is concerned onlywiththenumberofkeypointsfromvariousthreadsandthe ordertheyinterleavein.sowecanomitkeypointssafelyandordertheabovetwoscheduleslexicographically t0 t1 and t1 t0 .
inthesecondstep guidedbytheabovetwoschedules wewould like to control the thread interleavings via periodical execution.fig.
a gives the execution guided by the first schedule wherethe extra key points of thread t0are put in the last period of threadt0 in this case there is only one period namely period allocated for t0 hence all key points of t0are put in period .byanalyzingtheruntimeinformation weobtainanewdkps s1 t1 new key points are colored gold in fig.
a .
likewise we obtain another different dkpss2 t1 seefig.
b for the second schedule.
if a dkps obtained by an execution is previously uncovered we consider the dkps as an interesting new behavior.
a new dkps indicates there may be some other uncovered feasible schedules of the target program.
to explore these schedules we create a new explorationjobtohandleit.sotwoschedulejobs1arecreatedfor the above newly obtained dkpss s1ands2 respectively.
moreover to guide the target program running into the new behavior we introduce scheduleprefixes.intuitively aprefixisapartialschedule thatcontainscontextswitchesneededtoreachanewdkps.the 1actually s1ands2are symmetric to explore one of them would be sufficient.
in the following we omit the exploration on s2.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa cheng wen et al.
if done waiters mutex lock lock if !done done mutex unlock lock if !
waiters free lock lock null if done return period period a t0 t1 if done waiters mutex lock lock if !done done mutex unlock lock if !
waiters free lock lock null if done return b t1 t0 if done waiters mutex lock lock if !done done mutex unlock lock if !
waiters free lock if done return lock null period c t0 t1 t0 if done waiters mutex lock lock if !done done mutex unlock lock if !
waiters if done return free lock lock null d t0 t1 t0 if done waiters mutex lock lock if !done done mutex unlock lock if done return if !
waiters free lock lock null e t0 t1 t0 if done waiters mutex lock lock if !done if done waiters done mutex unlock lock if !
waiters mutex lock lock if !done mutex unlock lock if !
waiters free lock lock null f t0 t1 t0 if done if done waiters mutex lock lock if !done done mutex unlock lock if !
waiters free lock lock null waiters mutex lock lock if !done mutex unlock lock if !
waiters free lock lock null g t0 t1 t0 if done waiters mutex lock lock if !done if done done mutex unlock lock if !
waiters waiters mutex lock lock if !done mutex unlock lock if !
waiters free lock lock null lock null free lock h t0 t1 t0 t1 if done waiters mutex lock lock if !done if done done mutex unlock lock if !
waiters free lock waiters mutex lock lock if !done mutex unlock lock if !
waiters free lock lock null lock null i t0 t1 t0 t1 t0 if done waiters mutex lock lock if !done if done done mutex unlock lock if !
waiters waiters mutex lock lock if !done mutex unlock lock if !
waiters free lock free lock lock null lock null j t0 t1 t0 t1 ... figure3 eachsub figureisanexecutionofthecve 1972program andtheircaptionsarethegeneratedscheduletheyattempttofollow.
schedule prefixes for the s1ands2are respectively indicating thatthet0mustbechosentorunfirst and .ingeneral aschedule s prefix is in the form of ... ... ... where the periods incurlybracketswillbeliterallypreservedintheexplorationjob following this prefix.
the prefix s last period in square brackets indicates that only key points from tican be scheduled to this period while the key points number can be changed.
afterexploringtheonly2schedulesfor s0theexplorationjob fors0is concluded.
however we still need to explore the job for s1with prefix .
we omit its less interesting period schedules and jump to the period phase where there are schedules toexplore namely t0 t1 t0 ... a n d t0 t1 t0 .the executionsofthefirstthreeschedulesareshowninfig.
c fig.
d and fig.
e respectively.
on the fifth period schedule for s1 we find a new dkps s3 seefig.
f whichcontains7keypointsin t0and8keypoints int1.
a new exploration job will be created for s3associated with the prefix t0 needed to lead us to s3.
meanwhile we continuewiththejobfor s1andeventuallywhenwegettoschedule t0 t1 t0 the npd bug will be triggered see fig.
g .
now we focus on the exploration job for s3with the prefix t0 .weskiptheinconsequentialschedulesandhaveaclose lookattheschedule t0 t1 t0 t1 fig.
h wherea newdkps s4isdiscoveredanditsprefixis t0 t1 .again weskipsomeschedulesandconsidertheexplorationonthenewlyfound dkps s4.
as shown in fig.
i one of its period schedules t0 t1 t0 t1 t0 triggers the uaf bug.
next we continue the exploration on s4with period number .
by using the schedule t0 t1 t0 t1 t0 t1 weareableto triggerthedfbug asshowninfig.
j .
thesefindingsillustrate the effectiveness of period.
finally westoptheexplorationwhenalltheobtaineddkpssare explored within the preset period number bound.
in this example theperiod numberboundissettobe6 oranylargernumber so that the npd uaf and df can be found.
methodology wehave illustratedhow periodworkswith anexample.we shall now present some essential technical details.
.
the top level algorithm given a concurrent program progwithnthreads2 we assume the inputofthetargetprogramisgiven sotheonlynondeterminism in execution would be caused by thread interleaving.
differentinterleavings may lead the execution to divergent paths that is different parts of the program get executed activated.
only the interleavingsofthekeypointsareinteresting soweabstractthe 2weassumethenumberofactivethreads ndoesnotchangeindifferentexecutions for simplicity though our model allows changing number of threads.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
controlled concurrency testing via periodical scheduling icse may pittsburgh pa usa active parts of the program as a dynamic key point slice dkps or slice for short which is represented as a list with nelements whereinthe ithelementisalistconsistingofeveryencounteredkey pointsinthread ti sexecutioninthechronologicalorder.sincea dkps naturally reflects that there must be some feasible schedules to activate it period aims to systematically detect all slices and test each of them with all possible schedules.
periodmodelstheexecutionofconcurrentprogramsasperiodical execution wherein context switches can be achieved via periodswitchesnaturally see .3formoredetail .motivatedbythestudy thatshowsmanyreal worldconcurrencybugshaveshallow depths period employs schedule bounding techniques as well and requires the period numbers of the generated schedules to be withinapresetbound p targetingatallpotentialbugswithdepths less than p. the top level algorithm of period is illustrated in alg.
which takesaninstrumentedprogram progwithnthreadsandapreset period bound pas input and returns a set of bugs and their corresponding schedules.
note that the target program is instrumented so that it follows our schedules and we can collect the runtime information.wecreate jobs forslicestobeexploredin prog with each job represented by a pair consisting of a dkps and a scheduleprefix.thescheduleprefixisusedtoleadtheexecutionofthetargetprogramtothedkpsaspossible.theinitialjobisdenotedasapairconsistingofthesmallestapproximationassumingthereisonlyone activekeypointineachthreadandanemptyscheduleprefix ln.
.
indeed this smallest approximation is used to allow different possible orders for various threads to start running.
each schedule job is performed with the period number from i.e.
context switchtargetingatthebugdepth1 tothepresetperiodbound p ln.
.
specifically for each job joband each period number p we fisrt generate all schedules ln.
by invoking our schedulegenerator .
.notethataschedulerisconcernedonlywith the number of key points from various threads and the order they interleave.
we test the target program guided by each generatedschedule ln.
via our periodical executor .
and log bugs captured by our executor ln.
.
our executor also captures the dynamic key point slice of the execution ln.
.
therefore thefeedbackanalyzer .
candecidewhetheranewjobshouldbe createdtoexplorethenewlyfoundsliceornot ln.
.noticethat wemaybeunabletogenerateschedulesforsomejob ln.
.for instance if pwere greater thana job s total number of key points thensomeperiodswouldbeleftemptyandwasted.inthiscase wesay the job is finished that is the exploration of the corresponding slice is done and we remove it from jobs ln.
.
.
schedule generator our schedule generator focuses on scheduling key points of a slice.
to seehow our periodical schedule generatoris designed we first introduce the serialized scheduler which lays the foundation ofour method and then present the key optimization that allows concurrency in our schedules and that greatly reduces the number of schedules needed to expose bugs.
without loss of generality we name the threads in a dkps as t0 t1 ...tn wheren dkps .
.
.
serialized scheduler.
periodmodelsprogramexecutionin aseriesofexecutionperiods thatis aschedule andrepresentsitalgorithm period systematic concurrency testing input an instrumented program prog number of worker threads n and a bound pfor the maximum periods output a setlogrecording bugs and their corresponding schedules 1log 2jobs n 3p the period number starting from 4whilep pdo 5foreachjobinjobsdo schedule generator generates all schedules for job with the current period number p schedules schedgen job.dkps p job.prefix ifschedules then the current job is done jobs jobs job remove it from the jobs continue foreachs schedules do dkps errors run prog s periodical executor log the bugs and the current schedule log log s e e errors feedback analyzer prefix getprefix s jobs update jobs dkps prefix 15ifjobs then all feasible schedules explored break 17p p to explore schedules with one more period as ... ... ... ... where ... denotes an execution period and is a multi set that contains thread identifiers.
note that keypoints are omitted as our scheduler is concerned only with thenumber of key points from various threads and the order they interleave.
for example the schedule with three execution periods t0 t0 t1 t0 indicatesthatthread t0cantaketwokeysteps inthefirstexecutionperiod thenitis t1 sturntotakeonekeystep in the second execution period before t0takes another key step in the last execution period.
we use tx n fornoccurrences of tx appearing in a period.
foranydkps wecancreateserializedschedulesbyimposing the following rules rule .each period only hosts key points from the same thread.
rule2.keypointsintwoadjacentperiodsshouldbelongtodifferent threads.
rule .no execution period is left empty.
rule .threadtiappears exactly dkps times in a schedule.
these rules define the space of serialized periodical schedules fortheslice.consideraschedulejobonaslicedkpswithaperiodnumberp.
to iteratively generate schedules within the space of dkps with p we first introduce schedule patterns skeletons of schedulesandrepresentedas ... where denotes that only tidican be scheduled into the corresponding period.
all the possible patterns would be generated in a lexicographical order on the thread identifiers.
then for each possiblepattern we generate all schedules in order by allocating the key points to their corresponding periods.
in this way we can systematically explore all schedules on dkps with period number pin a quasi lexicographical order.
in the following we illustrate our explorationof4 periodschedulesfortheslice dkpsthathas3key points in t0 key points in t1and key point in t2.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa cheng wen et al.
thread thread thread thread ... thread 9 a if !
a b a b assert b a a a b b b figure a buggy interleaving of program reorder 10 bad.
firstly letusconsiderthefirstpossiblepattern wetake t0for the first period.
due to rule we could not use t0again for the second period.
by lexicographical order we take t1for the second period and then t0again for the third period.
for the last period wenotice t1isthesmallestcandidate.buttaking t1wouldmake t2 leftunscheduled violatingrule4.sowehavetotake t2forthelast period yieldingthefirstpattern .byreplacing some period with a next larger one and reinitializing the periods after it we can constructthe other patternsin order.
forexample the next pattern after the first one would be .
oncethepatternsaredecided wecanthenallocatethekeypoints totheircorrespondingperiods.firstofall byrule3 weputonekey point into each period.
we only need to arrange the remaining key points whichmighthavedifferentways.taking forexample theremaining t1canonlybeputinthesecondperiod while the t0could be put in either the first or the third period yielding two different schedules t0 t1 t0 t2 and t0 t1 t0 t2 .likewise wecangenerateallschedules inorderforagivenpatternbyexploringallpossiblewaystoarrange the key points.
.
.
the parallel scheduler.
althoughitsystematicallyexplores theschedulespaceofaslice ourserializedschedulercouldbecostly forsliceswithmanythreads.intheworstcasescenario toexposea d depth bug in an n thread slice dkps we will have to explore the serializedschedulespacewith d n 1periods.wecanalsoestimate the size of the space as n k d n wherekis the maximum number of key points in a thread in dkps.
apparently it couldbe too huge if nis big.
for instance the program in fig.
takes context switches between t0and any another thread to trigger the assertion error.
but our serialized scheduler has to generate scheduleswith11periodsduetorule1andisunabletotriggerthis error within schedules see table .
in our definitive scheduler which is termed as the parallel scheduler weaddressthisproblemelegantlybyallowingsome threadstobeexecuted inparallel.specifically ata timewepicka setofthreadsundersurveillance.weonlyserializethese chosen threadssowecancheckhowtheyinteract.alltheotherthreadsare neglected for now and left to run freely in the last period.
forinstance assuming t0andt1arechosen a3 periodschedule t1 t0 t1 t2 ... t10 is able to trigger the assertion error in fig.
.
so to allow parallelism we loosen rule rule1 .eachperiod apartfromthelastone onlyhostskeypoints from the same thread.
note that we do not impose any controls over the threads scheduled in the last period but for consistency we write them in the lexicographical order.itispossiblethatsomebugsmaybeintheneglectedthreads.this isnotan issueaswesystematically following thelexicographical order choose threads and would eventually reveal bugs caused by anythreadcombination.particularly whenproducingthe p period schedules we choose all to min p n thread combinations.
for every thread combination using only the chosen threads and their keypoints wefirstgenerateserializedschedulesasthemid product andthenforeverysuchserializedscheduleweaddtheneglected key points in its last period to produce a complete schedule.
allowingparallelismputseveryperiodinusetocreatemeaningful contextswitches.with theparallel schedulerfor any n thread program slice n no matter how big nis we can always start with period number instead of n and can trigger a d depth bug withnomorethan d 1periods insteadof d n 1intheworst case .
thisprocesscanbefurtherguidedbyaschedule prefix see .
.
aprefixisintheform tid0 n0 ... tidi ni ... .
we say a schedule satisfies such a prefix if its first iperiods are exactlythesameastheprefix sfirst iperiodsanditsnext jperiods havethesamepatternasthatisgivenintheprefix.ourschedule generator function schedgen dkps p pfx generates all p period schedules for a slice dkps satisfying the prefix pfx.
.
periodical executor after schedule generation we would like to enforce the schedules intheexecutionsofthetargetprogram.specially weuseaseriesofexecutionperiodstohosttheexecutions called periodicalexecution and impose the following rules i key points assigned to a period only get to be executed when the previous period is completed ii eachperiodhasalifetime whichshouldbelongenoughtocover the key points hosted in any period assuming they are executable and iii a period is completed if the lifetime is over.
weimplementtheperiodicalexecutorbasedonlinux sdeadline task scheduling which isoriginally designed for real time systems thatneed tasksto be done periodically.
for our purpose we adapt deadline task scheduling for our use by putting all threads under the deadline tasking scheduling with the same period length andstarttime sotheexecutionperiodsforallthreadsarealways synchronized and can be used to fulfill our period based controlled execution.wealsoinstrumentthetargetprogramwithascheduling point in front of every key points.
fig.5givestheperiodicalexecutionfortheschedule t1 t0 t1 t2 ... t10 where sched yield is triggered at the scheduling point to hang the current thread s execution until the next period.let run p s denotetheperiodicalexecutionofthetarget programpguided by a periodical schedule s. ourperiodicalexecutorisalsoresponsibleforcollectinginformationfromtheexecution i theerrorinformation errors fr om which we can know if a bug is triggered and ii the activated slicedkps whichisfedtoourfeedbackanalyzer .
todecide whether a new schedule job should be created.
in other words our periodical executor returns a pair dkps errors .
note that the slicenewlyactivatedbyaschedulemaynotbethesametotheone that generates the schedule.
this is due to the fact that differentinterleavings may cause conditional key points to take different branches.forinstance theschedulesshowninfig.
e andfig.
f authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
controlled concurrency testing via periodical scheduling icse may pittsburgh pa usa cm ?
cm ?
cm ?
n c ?
td g?
f t kjdio n c ?
td g?
k mdj?
n c ?
td g?
f t kjdio n c ?
td g?
n c ?
td g?
k mdj?
f t kjdio f t kjdio k mdj?
f t kjdio figure the execution of t1 t0 t1 t2 ... t10 aregeneratedfrom thesamedkps but theycause if done in threadt1to take different branches yielding two different dkpss.
.
feedback analyzer as explained in .
the newly activated slice may be different from the original one.
our feedback analyzer can handle this situation.
for that we introduce the supported relation between dkpss dkps1issupported bydkps2if the number of key points for each thread in dkps1is not larger than the corresponding one indkps2.
from the periodical executor s point of view dkps1 is supported by dkps2 indicates that the schedules generated by dkps2provide enough space of periods to hold their key points fromdkps1for each thread.
considering the motivating example thes4is supported by the s3 just skipping unneeded key points or periods.
when a previously uncovered slice dkps is discovered our feedback analyzer first checks if it is supported by the original one.
if not we will consider to create a new job for it.
to guide the exploration on dkps we make full use of the history execution information.
we compare the current schedule with its immediate previous schedule3and locate the first different key point let us say it is a key point from ti.
we can assume the difference here leads us to the new slice so we construct a schedule prefix bykeeping everything before it literally and then adding a pattern period .forinstance theschedule t0 t1 t0 inthe motivating example fig.
f gives us a new slice.
to calculateits prefix we compare it with its immediate previous schedule t0 t1 t0 andlocatethefirstdifferentkeypoint which isthefifthkeypoint t1ofthescheduleinfig.
f whereitsprevious schedule has t0.s ow ek ee pt h e t0 before this key point and connectitwitha togettheprefix t0 .notethatthere mayalreadyexistajobonthisslicedkps.ifso weupdatetheprefix of the existingjob as the common prefixof the newly constructed one and the original one.
otherwise a new job consisting of dkps andthenewlyconstructedprefixiscreatedandputintothejoblist jobs.
the procedure is denoted as update jobs dkps prefix .
intuitively one could explore the schedule space on the slice containingallthekeypointsofthetargetprograminstead.however thisspacecouldbetoohugeandsuffersfromlotsofuseless schedules.consideringthemotivatingexampleagain anyschedule satisfyingthatatleast5keypointsfromthread t0havebeenexecutedpriortotheexecutionofthefirstkeypointofthread t1would make thread t1return directly.
there are too many such schedules 3ifitisthefirstscheduleinourexploration wesayitsimmediatepreviousscheduleis an empty schedule .but only one is sufficient.
moreover during our exploration thenumber of generated schedules grows rapidly as the size of theslice increases.
thanks to the schedule prefix again it helps us significantly reducing the schedule space via avoiding some duplicatedschedules.asinthemotivatingexample whenexploring s3 weusetheprefix t0 whichwillguidetheexecutionto s3.
without prefix schedules like t0 ...would be allowed leading the execution back to s1instead of s3 fig.
c e .
finally concerningthecompleteness sinceourschedulersystematically exploresallschedulesonallinterestingdkpsswithperiod number from to p we argue that most of the possible interleavings of various threads bounded by pcontext switches will be touched by period.asillustratedinfig.
allthebranchesofthreeconditional statementscanbecoveredandeachconditionalstatementcanbe shuffled in any possible position if period number pis enough.
evaluation wehavebuiltaprototypeforperioduponthellvmframework svf andsched deadline .inparticular theperiodical executor and the feedback analyzer rely on instrumentation based on the llvm framework.
we have implemented a static analysiscomponent whichstaticallyidentifiedkeypointsofthegiven concurrentprogram ontopofsvf .theunderlyingimplementation of the periodical execution uses the existing cpu scheduler sched deadline available in the linux kernel as the implementation vehicle.
wehaveconductedthoroughexperimentstoevaluateperiod withasetofwidely usedbenchmarks andcompareditwithvarious existingtechniques.
withtheseexperiments weaimto answerthe following research questions rq1.how capable is our proposed parallel scheduler in reducing the schedule space compared to the serialized scheduler?
rq2.howcapableisperiodintermsoffindingconcurrencybugs compared to other techniques?
rq3.what runtime overhead is incurred by period?
.
evaluation setup .
.
benchmark programs.
toevaluateperiod wemakeuseof asetofwidely usedbenchmarksandreal worldcves writtenin c c for the linux pthreads platform including programsfrom sctbench and all programs from the cve benchmark .
the cve benchmark contains programs that have various concurrency bugs and each program corresponds to a real world cve.
the sctbench collects concurrency bugs from previousparallelworkloads andconcurrencytesting verification works .
note that we exclude programs in sctbench as of them fail to compile on the llvm platform and the bugs in the other programs can be exposed of the time.
.
.
baselines.
weusedexistingimplementationsofcompared baselines when available.
based on the category of cct techniques we select systematic cct techniques ipb idb and dfs and non systematic cct techniques pct maple andacontrolled random scheduler random thatrandomlychoosesathreadtoexecuteatatime.forcomparison we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa cheng wen et al.
table descriptive statistics and detection results on cve benchmark systematic testing non systematic testingcon.
bug detectordata race detector period serial ipb idb dfs native pct random maple bug id programsbug typebug depth schedules to bug 1st schedules buggy schedules schedules to bug 1st schedules buggy schedules schedules to bug 1st schedules buggy schedules schedules to bug 1st schedules buggy schedules runs to 1st bug buggy runs schedules to bug 1st buggy schedules schedules to bug 1st buggy schedules founds?
schedules convul ufo ufo npd fasttrack helgrind tsan cve linux .
.
rc6 npd enc enc enc enc enc enc cve linux .
.
npd enc enc enc enc enc enc cve linux .
.
npd enc enc enc enc enc enc enc cve linux .
.
npd enc enc enc enc enc enc enc npd enc enc enc enc enc enc triangle enc triangle uaf enc enc enc enc enc enc triangle enc triangle cve firefox .
df enc 37l enc enc 37l enc enc enc enc enc enc enc enc triangle enc triangle npd enc enc enc enc enc enc enc enc enc enc enc cve firefox .0uaf enc 37l0 enc 37l0 enc 37l0 enc enc enc enc enc enc enc enc enc cve linux .
.
npd enc enc enc enc triangle enc triangle enc triangle cve linux .
.
df enc enc enc enc triangle enc enc triangle cve linux .
.
uaf enc enc enc enc enc enc enc enc enc enc enc enc npd enc enc enc enc enc enc enc enc enc enc triangle enc triangle enc triangle uaf enc enc enc enc enc enc enc enc enc enc triangle enc triangle enc triangle cve linux .
.
df enc 37l enc 37l enc 37l enc enc enc enc enc triangle enc triangle enc triangle total bugs found buggy programs allthesub threadnumbersofprogramsare2.npd uaf anddfareshortfornull pointer deference use after free anddouble free respectively.
l denotesourschedulelimit10 000isreached.
enc denotes that no bug was found.
denotes an inapplicable case.
triangledenotes that a race detector reports a race on the related variables of the concurrency bug.
also include the version of period equipped with our serialized scheduler we call this version of period as serial and the native execution native wherein schedules are uncontrolled.
.
.
configuration parameters.
in our experiments the schedule bounds for all the cct techniques are set to check bugs with bugdepthnomorethan5onthecvebenchmark resp.3onsctbench asthemaximumbug depthforknownbugsinthecve benchmark resp.
sctbench is resp.
.
each invocation of a cct technique has a budget of exploring up to schedules.
for the other non ccttechniques weadoptedtheirdefault configurations.for each compared technique we invoke tests run for each program times and collect their results.
all our experiments have been performedonaworkstationwithanintel r xeon r silver4214 processor installed with ubuntu .
gcc .
llvm .
.
.
improvement of parallel scheduler rq1 thedescriptivestatisticsanddetectionresultsonthecvebenchmark and sctbench are shown in table and table respectively.
each column denotes the experimental results of atechnique.
the schedules to bug 1st schedules and buggy schedulesdenote the number of schedules that were explored up to and including the detection of a bug for the first time the total number ofschedules exploredby atechnique and thenumberof explored schedules that exhibited the bug.
these figures can demonstratehow capable and how quickly each technique finds the bugs on these benchmark programs.
as shown in table the results for period which uses the parallel scheduler and serial on the cve benchmark are exactly the same.thisisbecause asdiscussedin .
.
theschedulespacesizes for serial and period to explore on programs with nthreads and ad depthbugarerespectivelyover approximatedas n k n d and n k d and all the thread numbers of programs in the cve benchmark are so that both space sizes are exactly the same.
whiletheirresultsonsctbencharedifferentandhighlightedinblueintable2.allthedifferencesareduetothethreadnumbers arelargerthan2.infact whentestingprogramswithalargethread number serial could require a larger schedule space than needed to detect bugs resulting in missing some bugs even the ones with depth2.while thankstoparallelization periodcanalwaystrigger ad depth bug with no more than d periods.
table shows that period reports more bugs than serial with an improvement about .
.
moreover allowing parallelism greatly improves the schedule space.forexample serialgenerates30 384and5040schedulesfor the3 threads threads and5 threadsversionsof cs.reorder bad cs.reorder 3 bad cs.reorder 4 bad andcs.reorder 5 bad respectively.whenthethreadnumbergrowsto10 cs.reorder 10 bad serial requires a particularly large number of schedules which quicklyexceedsthebudgetlimit.whileperiodrespectivelygenerates27 and225schedulesforthe3 threads threads and threads versions and still performs well schedules still lots ofremainingbudgets onthe10 threadsversion.thisindicatesthat as the thread number increases the improvement of the parallel schedulerwouldbemoresubstantial.inaddition allowingparallelismalso enablesperiodtodetect bugsmore quickly.asshown in table period always requires fewer schedules to detect the same bug for the first time compared with serial.
ourparallelschedulersignificantlyimprovesserializedonein terms of the schedule space enabling us to detect more bugs.
.
bug finding ability evaluation rq2 in table period has successfully identified all programs from the cve benchmark as buggy ones while other cct techniques i.e.
ipb idb dfs pct random maple have identified only buggy ones.
notice that the native execution i.e.
no control on schedules could identify only buggy programs.
in terms of bugs authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
controlled concurrency testing via periodical scheduling icse may pittsburgh pa usa table descriptive statistics and detection results on sctbench systematic testing non systematic testing period serial ipb idb dfs native pct random maple programssub threadsbug typebug depth schedules to bug 1st schedules buggy schedules schedules to bug 1st schedules buggy schedules schedules to bug 1st schedules buggy schedules schedules to bug 1st schedules buggy schedules schedules to bug 1st schedules buggy schedules runs to 1st bug buggy runs schedules to bug 1st buggy schedules schedules to bug 1st buggy schedules founds?
schedules cs.account bad af enc cs.bluetooth driver bad af enc enc cs.carter01 bad dl enc cs.circular buffer bad af enc enc cs.deadlock01 bad dl enc cs.lazy01 bad af enc cs.queue bad af l l 1l enc cs.reorder 10 bad af enc 37l0 enc 37l0 enc enc 37l0 enc enc enc cs.reorder 20 bad af l enc 37l0 enc 37l0 enc 37l0 enc 37l0 enc enc enc cs.reorder 3 bad af enc enc cs.reorder 4 bad af l l enc enc cs.reorder 5 bad af l enc enc 37l0 enc enc cs.stack bad af l enc enc cs.token ring bad af enc enc cs.twostage 100 bad af l enc 37l0 enc 37l0 enc 37l0 enc 37l0 enc enc enc cs.twostage bad af enc 37l0 enc 37l0 enc 37l0 enc enc enc enc cs.wronglock 3 bad af l l enc cs.wronglock bad af enc 37l0 enc 37l0 l enc 37l0 enc enc cb.aget bug af l enc cb.stringbuffer af enc enc bof enc enc enc enc enc enc enc npd enc enc cb.pbzip2 uaf 2483l 4982l 49023l 30532l enc enc chess.wsq af l l enc 37l0 enc enc chess.iwsq af l enc 37l0 l enc enc enc bof enc enc enc enc enc enc enc enc 37chess.swsq 3af 1630l13 enc 37l0284l1222l1 enc 37l0 enc enc bof enc enc enc enc enc enc enc enc 37chess.iwsqws 3af 1663l13 enc 37l0284l1222l1 enc 37l0 enc enc inspect.qsort mt af l l enc 37l0 enc enc inspect.boundedbuffer af l l enc 37l0 l enc 37l0 enc misc.safestack af enc enc 37l0 enc 37l0 enc 37l0 enc 37l0 enc enc enc enc splash2.barnes af l l l l l enc splash2.fft af l l l l l enc splash2.lu af l l l enc radbench.bug2 af l l enc 37l0 enc 37l0 enc 37l0 enc enc enc radbench.bug3 af l l enc 37l0 enc 37l0 enc 37l0 enc enc enc radbench.bug4 af l l enc 37l0 enc 37l0 enc 37l0 enc enc radbench.bug5 dl enc 37l0 enc 37l0 enc 37l0 enc 37l0 enc 37l0 enc enc enc enc radbench.bug6 dl enc 37l0 enc total bugs found buggy programs af bof and dl are short for assertion failure buffer overflow and deadlock respectively.
the marker l and enc respectively denote our schedule limit is reached except program cs.twostage 100 bad using as schedule limit and that no bug was found.
periodandserialidentified15bugsinthecvebenchmark performingthebest.intheprogramofcve periodreports anull pointer dereference npd bug ause after free uaf bug andadouble free df bug.whileallothersystematicccttechniquesfailtoreportthesethreebugs andonlytwonon systematic cct techniques i.e.
randomand maple can identifynpd or df.
in particular the df bug in the program of cve canbe found only by period which is also an undocumented bug.
moreover two concurrency vulnerabilities detectors i.e.
ufo and convul and three data race detectors i.e.
fasttrack helgrind and tsan are considered whose results are includedintable1aswell.however mostoftheirperformances exceptforconvul areworsethanccttechniques convuland ufoidentify9and3buggyprograms respectively andthethree dataracedetectorscanidentifyatmost2bugs.theaboveresults figure the number of bugs found after xschedule.
demonstrate the effectiveness of our systematic schedule exploration in terms of execution periods for both period and serial.
onsctbench asshownintable2 periodidentified38bugs and buggy programs in total performing the best.
in particular periodperformsthebestonabouthalf 20outof40 bugsinterms authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa cheng wen et al.
ofschedulestobug 1st andrequiresfewer schedules thanothersystematictestingtechniquesonabout83.
30outof36 programs due to our efficient exploration of schedule space.
moreover our serial identified bugs performing better than the other ccttechniques except for pct .
due to the larger thread numbers serial still missed bugs of which are also missed by ipb and idb.
however about of these missed bugs can be identified by our parallel version period.
the last two lucky bugs missed by all the techniques are misc.safestack andradbench.bug5.
we had a manualinspectiononthesetwobugs.
misc.safestack isanimplementationofalock freestack whichrequiresatleast5context switches.while theschedule boundfor thecct techniques isset to3.inaddition asshowninapriorevaluation misc.safestack isverydifficulttodetect sincealltechniquesin failtodetect it.radbench.bug5 was unable to reproduce in our experiments despite that we followed the instructions in the document.
tofurthercomparetheccttechniques wepresentacumulativeplotinfig.6withaschedulelimitof10 whereeachline represents a technique and is labeled by the name of the technique andthenumberofbugsfoundbythetechnique andapoint x y representsthat yconcurrencybugsareexposedbythetechnique usingxschedules.onthewhole periodhasalargergrowthtrend indicatingthatperiodrequiresfewerschedulestofindthesame numberofbugsorcanfindmorebugsinthesamenumberofschedules.
forexample more than 40bugs could beexposed by period using lower than schedules while the others would require to schedules.
the above results signify that period is more effective than the other techniques.
there are two main factors that contribute to theeffectiveness.firstly asdemonstratedbytheperformancesof our serial and period the proposed gradual exploration in terms of execution periods guided by schedule prefixes is effective in detectingconcurrencybugs.secondly asshownin .
allowing parallelism can significantly improve our serialized scheduler.casestudies .todemonstratethereasonsbehindperiod ssuperiority we present two case studies.
the first case is the program in cve whichsuffersfromthenpd uafanddfbugs.withthehelpoffeedbackanalyzer periodonlygenerates573schedules and successfully finds all the bugs.
a brief introduction for howperiod find the uaf and df bugs have been given in which demonstrates our effective exploring strategies.
however both ipb anddfsgeneratedmorethan10 000schedulesbutfailedtofindthe df bug.
the program cs.reorder 10 bad from sctbench contains an assertion error.
as illustrated in fig.
two context switchesbetween t0and any other thread can trigger the error.
but most of the cct techniques except for our technique period and pct were unable to detect it.
similar to serial with no supports of parallelization existing systematic techniques have to explore a much larger schedule space than needed causing schedule budget runningout quickly especially forprograms witha largenumber of threads.
on the other hand although pct can expose this error theprobabilitytotriggeritisextremelylow about9 .
in our experiment .
period significantly outperforms existing cct techniques in terms of concurrency bug finding ability.
figure7 averageexe cutionspeedof ccttechniquesrelativetonative execution.
lower is better.
.
overhead evaluation rq3 toevaluatetheruntimeoverheadrequiredforachievingcontrolled scheduling we use programs from the sctbench with various numbersofthreadsandalltheprogramsfromthecvebenchmark.fig.7showstheaverageexecutionspeedduringtestingachievedby period ipb idbandpctrelativetonativeexecution wherethe numberinsidetheprogramnamerepresentsthenumberofthreads.
on all benchmark programs the runtime overhead incurred by period is lower than other techniques i.e.
ipb idb and pct .
in detail periodrequiresonly2to30timesofexecutionslowdown over native execution while the others require to times.
as the number of threads increases the effect of execution slowdown can be weakened for all techniques.
the reasons for the low overhead of period could be i the periodical execution achieves control scheduling with non preemptive synchronizations thusavoiding false deadlocks and starvation and ii period allows parallelism inperiodicalexecution instead of serializing execution which can boost the performance.
period incurs some noticeable runtime overhead which is significantly lower than that of ipb idb and pct.
.
discussion additional experiments.
theaboveexperimentsshowthatperiod is effective and efficient in finding concurrency bugs.
notethat it is possible that a technique gets lucky and finds a bug quicklyduetothesearchorder.forthat weconsiderthe worst case bug findingability intermsofthetotalnumberofnon buggyscheduleswithinthebound thatis thedifferencebetween schedules and buggyschedules.theresultshowsthatperiodperformsthebest in out of all programs.
since period allows parallelism in periodical execution which could be accelerated by multi cores w e also evaluate the runtime speedup with different cpu cores.
for aprogram with and threads period respectively provides and speedups on the cores configuration compared to the single core one.
in addition we have tested open source programs with source lines of code ranging from to233 431lines.periodsuccessfully identified5previouslyunknown concurrency bugs e.g.
au a fi n lrzip buffer overflow in pbzip2 invalid address dereference in ctrace .
these concurrency bugs were notpreviouslyreportedandwehaveinformedthemaintainers.all extra experimental results are available on our website4.
threatstovalidity.
weselectedavariantofexistingbenchmarks andreal worldprogramstoshowthecapabilitiesof period and 4period s website authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
controlled concurrency testing via periodical scheduling icse may pittsburgh pa usa compareditagainstotherccttechniques.however ourevaluation datasetmaystillincludeacertainsamplebias.furtherstudieson morereal worldprogramscanhelptobetterevaluateperiod.period uses static analysis to identify key points.
in practice if some key points are missed it could result in some bugs being missed.
thus the static analysis for identifying key points should be an over approximation.
our static analysis is currently built on top of svf and it works well for all the benchmark programs in our evaluation.amorepowerfulstaticanalysismayhelptoimprove period further.
moreover this work assumes that the inputs to the program are predetermined for example by an existing test suite anddonotvarybetweenruns asitistypicalinotherwork in the literature on cct.
adopting some test case generation techniques e.g .
fuzzingandsymbolicexecution mighthelpmitigate this threat.
finally this work doesn t handle weak memory models wmms and probabilistic programming models .
we are seeking solutions to further improve period.
related work thereisawiderangeofresearchproposedintheliteratureontesting and analysis of concurrent programs.
here we briefly describe the related work and compared it to period.concurrency testing.
controlledconcurrencytestinghasbeen thesubjectofextensiveresearch giventheelusivenatureofconcurrency bugs.
chess showed the effectiveness of iterativepreemption bounding ipb andlateriterativedelay bounding idb forfindingbugsinmulti threadedsoftware.pct andits parallelized variation ppct set thread priorities that are used by the scheduler of the underlying operating system or runtimeto schedule the threads exactly as required by the testing algorithm showcasing the power of randomized scheduling .
maple employsacoverage drivenapproach basedonageneric set of interleaving idioms for testing multi threaded programs.
rpro isaradius awareprobabilistictestingfortriggeringdeadlocks whereitselectsprioritychangingpointswithintheradiusofthetargeteddeadlocksbutnotamongallevents.tsvd dynamicallyidentifiespotentialthread safetyviolationsandinjectsdelays todrivetheprogramtowardsunsafebehaviors.ql improves cct by leveraging classical q learning algorithm to explore the spaceofpossibleinterleavings.severaltechniquesarealsodeveloped for distributed systems including dbug modist samc spider andmorpheus .
the presenceof such a largenumberoftechniquesclearlyindicatestheimportanceofcct.ourproposedperiodachievecontrolledschedulingbyanovelperiodical executions which is non preemptive and allows parallelism anditsystematicallyexploretheschedulespaceofeachdkpswith the guidance of schedule prefixes.
dynamic partial order reduction dpor computes persistent sets during testing to identify equivalent interleavings so someinterleavingscanbeskippediftheirequivalentsarealready tested.
some recent research has achieved considerable improvementsoverdpor .itwouldbeinterestingforfuture work to combine dpor techniques into period.
several other techniques leverage fuzzing to find test inputs exposing bugs in concurrent programs .
challenges caused by test inputs are orthogonal to this work as we focus on finding buggy interleavings.staticanalysisapproaches.
staticanalysisaimstoapproximate concurrentprograms behaviorswithoutactuallyexecutingthem .
for example locksmith uses existential types to correlate locks and data in dynamic heap structures forrace detection.
goblint relies on a thread modular constant propagation and points to analysis for detecting concurrency bugs byconsidering conditionallocking schemes.dcuaf statically detects concurrency use after free bugs in linux device driversthrough a summary based lockset analysis.
fsam p r o poses a sparse flow sensitive pointer analysis for c c programs usingcontext sensitivethread interleavinganalysis.canary conductsinterference awarevalue flowanalysisforcheckinginter threadvalue flowbugs achievingbothgoodprecisionandscalabil ityformillionsoflinesofcode.thestaticapproachesmayproducefalsepositives.inperiod thestaticanalysiscomponentiscurrently builtontopofsvf butcanbereplacedbyamorepowerfulstatic analysis if available.dynamic analysis approaches.
there is a line of work using dynamicanalysistofindconcurrencybugs .
the two fundamentalsare happens before model and lockset model .
the happens before model reports a race condition when two threads read write a shared memory arena in a causally unordered way while at least one of the threads writes into this arena.
the lockset model conservatively considers a potential race if two threads read write a shared memory arena without locking.ft andhelgrind aretwowell knownhappens before basedracedetectors.moderndetectorssuchastsan applya hybridstrategytocombineboththehappens beforemodel and thelocksetmodel .predictiveanalysis collects tracesconsistingofdifferenttypesofeventsandthenpredictsbugsoffline based on the dependencies of events or known bug patterns.
ufo applies an extended maximal causality model topredictconcurrencyuafsbasedonasingleexecutiontrace even though the uafs may not happen in the observed execution.
convul predictsconcurrencyvulnerabilitiesbyjudgingwhether twoeventsareexchangeablebasedonthehappens beforemodel.
convulpoe enhances convul by introducing partial order reduction.period sfocusisnotonimprovingdynamicdetection ofconcurrencyviolation instead itcanemploythesetechniques as bug detectors to work with the periodical scheduling.
conclusion in this paper we present a novel controlled concurrency testing technique period.
period models the execution of concurrent programsasperiodicalexecution andsystematicallyexploresthespace ofpossibleinterleavings guidedbyperiodicalschedulingandthe historyexecutioninformation.ourevaluationhasdemonstrated period shows superiority over state of the art cct techniques in terms of both bug finding effectiveness and runtime overhead.