modx binary level partially imported third party library detection via program modularization and semantic matching can yang1 zhengzi xu hongxu chen4 yang liu3 xiaorui gong1 baoxu liu1 yangcan iie.ac.cn zhengzi.xu ntu.edu.sg chenhongxu5 huawei.com yangliu ntu.edu.sg gongxiaorui iie.ac.cn liubaoxu iie.ac.cn school of cyber security ucas1 institute of information engineering cas2 school of computer science and engineering ntu3 huawei technologies co. ltd. abstract withtherapidgrowthofsoftware usingthird partylibraries tpls has become increasingly popular.
the prosperity of the library usagehasprovidedthesoftwareengineerswithahandfulofmethods to facilitate and boost the program development.
unfortunately it also poses great challenges as it becomes much more difficultto manage the large volume of libraries.
researches and studies have been proposed to detect and understand the tpls in the software.however mostexistingapproachesrelyonsyntacticfeatures whicharenotrobustwhenthesefeaturesarechangedordeliberatelyhiddenbytheadversarialparties.moreover theseapproaches typically model each of the imported libraries as a whole therefore cannotbeappliedtoscenarioswherethehostsoftwareonly partially uses the library code segments.
to detect both fully and partially imported tpls at the semantic level weproposemodx aframeworkthatleveragesnovelprogram modularization techniques to decompose the program into finegrained functionality based modules.
by extracting both syntactic andsemanticfeatures itmeasuresthedistancebetweenmodulesto detectsimilarlibrarymodule reuseintheprogram.
experimental resultsshowthatmodxoutperformsothermodularizationtoolsby distinguishingmorecoherentprogrammoduleswith353 higher module quality scores and beats other tpl detection tools with on average better in precision and better in recall.
keywords third party library detection program modularization semantic matcing acm reference format can yang1 zhengzi xu hongxu chen4 yang liu3 xiaorui gong1 baoxu liu1 .
.
modx binary level partially imported third party library detection via program modularization and semantic matching.
in44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
https permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
introduction with the rapid development of commercial software third party library tpl reusehas becomemore andmorepopular toensure high program quality and reduce the unnecessary development costs.
according to over of organizations leverage tpls inapplicationdevelopment.
bothgithub andsonatype r eportthatover80 ofmostapplications codecomesfromlibrary dependencies.
however as the size of the software grows bigger andmorelibrarieswithdifferentdependenciesareinvolved itisdifficult to track all the imported tpls accurately.
the massiveuse of the uncontrolled libraries will result in issues in the areas such as code auditing licence violations malware affection and unexpected vulnerability introduction .
understandingwhichlibrarieshavebeenimportedhasbecomethekeyto address these issues.
as a result tpl detection works have been proposed which extractfeatures from known libraries andmatch them in the target software.
for example bat searches the reliableconstantsandstringsintheprogramtodetecttpls.osspolice alsoleveragestheinvariantliteralstodetecttplswitha hierarchicalindexingscheme.moreover works have been proposed to improve the tpl detection ability on android applications with package dependency identification.
however existing feature matching based approaches have two limitations.first theyembedfeaturesfromtheentiretpls.ifthe programonlyimportspartofthelibrary thedetectionalgorithm may fail due to the lack of fully matched features.
to detect the partiallyimportedlibraries onepossiblesolutionistomatchthe library at a more fine grained level.
the only existing ready to use fine grainedunitintheprogramisthefunction.methods have been proposed to match the similar functions between theprogramsandlibrariestodetectthetplusage.however the matchingalgorithmsarenotrobustatbinarylevel.itisbecausethe functions are very likely to be changed due to different compilersettings .
therefore choosing a matching unit which is not subject to change becomes the key in partial library detection.
the program module as a conceptual unit fits this need well duetothefollowingreasons.first itconsistsofseveralfunctions whicharecombinedtogethertoachieveacommonfunctionality.
sincetheprogramreusesthelibrarybyimportingthefunctionality groups themodulecanberegardedasthebasicfine grainedunit.
second sincewithinamodule thefunctionsareconnectedtoeach otherto formacallgraph themoduleitselfwill beenrichedwith corresponding author.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa can yang1 zhengzi xu hongxu chen4 yang liu3 xiaorui gong1 baoxu liu1 moresemanticgraphicalfeatures whichareunlikelytobechanged bycompilation.ithelpstomakethemodulematchingmoreaccurate and robust in the practical real world tpl detection.
however to our best knowledge there are only few works on binary level program modularization.
bcd is the state of the art static approach to decompose the binary executables into modules.
however themodulesitgeneratedusuallycontainisolatedfunctions whichwillhinderthetpldetectioninthelaterstep.therefore the first challenge of this work is to divide the given program into meaningful and practical modules.
the second limitation of the existing works is that they rely too muchonsyntacticfeatures especiallythestrings todetecttpls sincestringsoftenbringdirectindicationofthelibraryinformation.however thiskindoffeaturesmaybedeliberatelymodifiedbyothers to hide the libraryinformation .
especially within modern malware strings obfuscation has been one of the most commonly used evasion techniques .
to overcome the drawbacks of using puresyntacticfeatures plentyoffunctionmatchingandcodeclone detection researches have been proposed to embrace more semantic features.
h owever these works focus onfunctionlevelfeatures whichmaynotbeaccurateinmeasuring module similarity.
also the module possesses unique features that can help to distinguish themselves which are not capturedby existing works.
thus the second challenge of this work is to accurately measure the semantic level similarity between the modules by extracting suitable features.
to this end we propose modx a framework which utilizes a novel modularization technique to decompose the program and libraryintomodulesandtosemanticallymatchthemtodetecteither fully or partially imported tpls.
inspired by the community detection algorithms firstly modx defines the module qualityscoretoassessthecoherenceofthefunctionclusters.then for a given program or a library it starts to group individual functionstoformmoduleswhilemaximizingtheoverallmodulequality score.
after the programs and libraries have been modularized modx extracts both syntactic and semantic features from interandintra modulelevelsandmeasuresthesimilaritybetweenthe modules.
based on the similarity modx will match and detect the presenceoflibrarymodulesintheprogramsothatitcanfindthe fully partiallyimported tpls.the experimentalresultsshow that modxachieves90.
precisionand78.
recallintpldetection of self crafted programs and .
precision and .
recall in real world software which outperforms other tpl detection tools.
moreover sincethemodularizationalgorithmisastand alonetechnique italsohasgreatapplicantsbesidestpldetection.wealso test its possibilities in different software engineering tasks such as reverse engineering and attack surface detection.
in summary our main contributions are as follows weproposeabinarylevelprogrammodularizationalgorithm todecomposeaprogramintofunctionality basedmodules and develop metrics to assess the module quality.
we propose a semantic measurement algorithm to calculate the similarities between modules.
we conduct tpl detection experiments on real worldprojects in which modx outperforms the state of the art tools over in accuracy on average.
weevaluatethepotentialapplicationsoftheprogrammodularization algorithm such as reverse engineering and attack surface detection.
background .
motivating example inthissectionweillustrateourmotivationwithareal worldexample.watcher isamalwareusedasasecretimplantformonitoring network traffics.
we collect and upload the binary of watchervarianttotheonlineplatformvirustotal whichperformsmalware detectionvia60anti virusengines.theresultshowsthatonly7outof60leadingsecurityvendorssuccessfullydetectthemalware .
therestfailtodetectthemalwarevariantbecauseitchangesthe binary instructions and the string literals to obfuscate itself.
topreciselydetectthemalware securityexpertscanusecomponent analysis to determine the tpls used by this malware as an indicator of the malware presence.
h owever after the malware has been detected and its signature has been recorded in the anti virus database watcheralsostartstoevolveandhideitself.itremoves all the strings inside the program since it does not need them tocarry malicious activities.
also instead of using the entire pcaplibrary or dynamically linking it it only uses export functions the entire pcap library has export functions .
however after the evolution existing tools fail to find the library.
according toour experiment the state of the art tpl detection tool bat outputsseveralfalsepositives.thus themalwaresuccessfullyhides the pcap library and escapes from the anti malware detection.
weproposetheprogrammodularizationtechniquetodividethe pcaplibraryinto16modules.wematchthemodulesinthemalwarebinaryanddetectthatitreuses3ofthemodules.therefore wehave provided a strong evidence to confirm the binary to be watcher.
theapproachismorerobustsincethemalwarecannotlivewithout thesupportofpcap.nomatterwhatchangesthemalwaremakestohidethelibrary aslongasitdoesnotchangethefunctionsemantics our tool can still find the trace of the library pcap.
.
background information in this section we briefly discuss about some software engineering concepts used in our paper.
.
.
third partylibrary.
tplisareusablesoftwarecomponent beingdevelopedbysomepartiesotherthantheoriginaldevelopmentvendor.itisdistributedfreelyorundercertainlicencepolicies.
it is used to avoid the repeating development of software with the samefunctionalitiessothatitcansavetimeandresources.however duetolackofsupportfromthethirdparties usingitalsointroduce dependency issues and security concerns.
.
.
communitydetection algorithm.
ina complexrelationnetwork nodestendtobegatheredtoformcommunitystructures.the communitydetectionalgorithmaimstorevealthehiddengrouping information of the communities which are frequently used in distributed network systems.
it partitions the network graph intosmallclustersanddetectsthecommunities.inthiswork the entire program or library can be regarded as a graph network with thefunctionsrepresentingthenodes.programmodularizationis authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
modx binary level partially imported third party library detection via program modularization and semantic matching icse may pittsburgh pa usa similartothecommunitydetectionalgorithm whichtriestogroup functions into different communities modules .
.
.
binarycodeclonedetection.
binarycodeclonedetection triestofindsimilarfunctionsinthebinaryexecutables.itisoften usedtoauditthesoftwareoriginalityandtosearchforrecurring software bugs caused by code reuse and sharing.
the traditional algorithmsextractdifferentfeaturestorepresentthecodeandmeasurethecodesimilaritybasedonthesefeatures.inthiswork weaim topropose algorithms tomeasurethesimilarity betweenmodules rather than functions so that it can be more robust to detect tpls.
we follow a similar approach as the traditional clone detection but with a different feature set.
methodology .
overview figure1showstheworkflowof modx.itconsistsoftwophases namely binary modularization and tpl detection to predict tpls from a binary program.
in the first phase it proposes a module quality metric which is based on community detection algorithm with program specific adjustments.
then it leverages a novel algorithmwithheuristic biasestodecomposethe binaryintomodules based on the metric.
in the second phase modx performs the tpl detection by matching program modules with tpl modules.
it extracts syntactic features graph topology features and function levelfeaturestomeasurethesimilaritybetweenmodules.afterthe matching it also introduces module and library importance scores to help improve the library detection accuracy.
.
.
assumptions.
first inthiswork weassumethatthemodules of the program do not overlap with each other.
for example if moduleaandbboth call the function f thenfwill have a high chancetobedividedintoaseparatedmodule c.fwillnotbelongto eitheraorb.
second we assume that the content of each tpl will notchangesignificantly.sincemodxaimstomatchtplsacross differentversionsusingsemanticfeatures ifthesemanticsofthe library have been changed significantly modx will fail to produce accurate results.
.
binary program modularization inourpaper theprogrammodularizationtechniqueconsistsoftwo components the module quality metric and the actual modularization algorithm.
the module metric aims to measure the quality gain from grouping functions into clusters and the modularization algorithm combines the functions in the way which will maximize the overall module quality score.
.
.
module quality assessment design.
the program consists of functionswhichareconnectedwitheachotherthroughfunction calls.
the relationships can be represented by a call graph with functions as the nodes and calls as the edges.
functions with similar functionalities are likely to appear close to each other to form a communityinthegraph.theprogrammodularizationprocessaims to find these communities which is very similar to the community detection in a network.
therefore to design a sound and practi cal module quality assessment metric we adopt the communitydetection quality metrics as the baseline.
then we modify the metricswithsoftwarespecificheuristicstofitinthespecificprogram modularization task.girvan newman algorithm inspiredbythecommunitydetection algorithm we choose girvan newman modularity quality gn mq as the baseline metric since it has a good approximation on the program structure.
it is the first algorithm proposed formodularityoptimization andhasfar reachingimpactsonfollowing researches .
basically given a network which has been divided into multiple clusters the metric counts the connectededgesbetweeneachpairofnodesfromthesameclustersand sums the number of such occurrences with adaptive weights based on node degrees.
if there is no connection between the nodes in the same cluster the weight will be assigned with negative values whichdecreasestheoverallqualityscore.specifically thequality is calculated according to the equation q 2m summationdisplay.
i j aij kikj 2m ci cj whereiandjdenotesthe ithnodeandthe jthnodeinthegraph respectively aijdenoteswhethernode iandjareconnectedornot whichhasavalueeither1or0 kidenotesthein andout degreeof nodei mis thenumber ofedgesin thegraph ciis thecommunity wherenode ibelongsto ci cj standsforwhethernode iand jbelong to the same cluster which has a value either or .
as shown in this equation if the nodes iandjbelong to the same clusterandtheyareconnectedtoeachother thenthequalityscore willincrease.otherwise ifthetwonodesfromthesameclusterare notconnected thescorewillbedecreasedsince aijwillbesetto 0andtheterm aij kikj 2mwillbecomenegative.therefore in this metric the high quality score reflects that the high coherence among the nodes within the cluster.
moreover due to the negative term kikj 2m nodes having less in and out degree will have moreweightsthanothers.therefore themetricalsodiscourages the connectivity between nodes from different clusters.functionvolumeadjustment.
besidestheconnectivitybetween nodes the program modules have unique features that can be used asthemodulequalityindicators.functionvolumeisoneofthem which is specified by the number of statements in the function.
in the program functions that have large volumes tend to perform somecorefunctionalities whereas smallfunctionswilllikelybetheutilityfunctions .acompleteandcoherentprogrammodule will consist of a small group of large volume functions to perform thecorefunctionalitiesandsomesmall volumefunctions which are around the core group to provide useful utilities.
therefore we propose thefunction volume weight propagation algorithmto addtheweightadjustmenttothemetricsothatitcanfavourthe complete and coherence modules.
the aim of the propagation algorithm is to assign different weights to each of the functions based on its volume and connectivity.
it functions in a way that is similar to the pagerank algorithm in website ranking.
for programs that have hierarchi cal structures the functions at the top levels tend to control the behaviourofthelow levelfunctionsviafunctioncalls.thepropagation algorithm guarantees that the top level functions will receive more attention compared to the low level ones which results in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa can yang1 zhengzi xu hongxu chen4 yang liu3 xiaorui gong1 baoxu liu1 module matching topology featuressyntactic features function featuressimilar scores binary modularizationtpl detection ranking sorting matchestpl modules database lib lib lib 2nd lib21st lib1 3rd modules program specific adjustmentsclustering with heuristic biases function call graphs figure overall workflow of modx more weights being assigned to the top level functions.
therefore whenwemodularizetheprograms weareabletobeginwiththese heavy weighted functions to avoid generating modules with only small utility functions.
thedetailedstepsareasfollow first eachfunctionisinitialized withitsownvolumevalue e.g.thenumberofstatements .then wechecktheout degreeofeachfunctionandlookfortheendnode which has out degree.
since the end node does not call other functions its weight will not be affected by the rest of functions in thepropagation.next theweightoftheendnodewillbepropagated backwardtoitsparentnode thecallerfunction .weidentifythe number of function calls in the parent and adjust the weights by normalizingthemagainstthenumberofcalls.thepropagationis defined as equation fv prime u fv u c summationdisplay.
v e u fv v cv wherefvreferstothefunctionvolumeweight uandvrepresent thefunctionnodeswith ucallsv.e u isthesetoftheendnodes whichucalls.cvdenotes the number of caller functions of v.cis a factorusedfornormalization.the fvofthetoplevelnode uwill beupdatedbyaddingtheweightsofthelowerlevelnodes.after the propagation we remove the end node and the edges which connecttoitfromthecallgraph.ifthereareloopsinthecallgraph wemergethefunctions intheloopintoonenodeand removethe branch edge to generate a new end node.
we repeat the process to propagatetheweightsandremovetheendnodesuntilthereareno more nodes in the graph.
modified quality metric besides adding in the volume size adjustment wealsochangethemetricfrommeasuringtheindirect graph to directed graph since the function calls have directions from caller to callee function .
therefore when calculating the term kikj 2mof equation we modify it to incorporate the directioninformation.specifically weonlymeasuretheout degree of the parent node and in degree of the child node so that we cannotavoidthenoisefromotherirrelevantcalledges.thedirected graphmodelqualitymetricwith volumeadjustmentiscalculated according to the equation q 2w summationdisplay.
i j wij kout ikin j 2w ci cj wherewijrepresents the weight of the edge between function i andj which has the value equal to the function volume weight ofj.wdenotesthesumofalltheweightforeachoftheedgesin the graph kout iandkin jspecify the weighted out degree of node i and the weighted in degree of node j the rest of the notationsare the same as equation .
with the modified quality score the functionwithalargevolumewillbemorelikelytobegroupedfirst since grouping them will output a higher quality score due to their higherweights.therefore theresultingmodulesaremorecoherent than the modules generated by treating all the functions equally.
.
.
modularizationalgorithm.
basedontheproposedmodule qualityscore westarttogroupfunctionsintheprogramtogenerate modules.
we regard each function as an individual cluster and repeatedlycombinetwoclustersusingthefastunfoldingalgorithm while maximizing the overall quality score.
moreover to make the generatedmodulesmoreintuitive weaddintwobiasestoguide the modularization process.fast unfolding louvain algorithm.
to boost the modularizationspeed wechoosefastunfoldinglouvain whichisagreedy optimization algorithm to guidethe groupingprocess.
thealgo rithm is adapted to optimize the qin equation .
the modified louvainalgorithmworksasfollows.first itassignseachnodein the network to an individual module.
then it tries to merge any modulerwith its neighbor module s. the merging will change the module quality by qin equation .
qr s ein r s eout r s ein s r eout s r ain r ains aout r aout s where ein r s summationdisplay.
i r summationdisplay.
j skin ikout j 2w eout r s summationdisplay.
i r summationdisplay.
j skout ikin j 2w ainr summationdisplay.
ses r r s aout r summationdisplay.
ser s r s where the equation and can be derived from the previous work .
the notations are the same as equation .
the algorithmwillmergethecommunity rands ifthemergingincreases authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
modx binary level partially imported third party library detection via program modularization and semantic matching icse may pittsburgh pa usa theoverallmodulequalityscorethemost.thealgorithmwillrepeat thesamesteptogreedilymergethenodesuntilthereisnomore mergingoperationcouldbeapplied.thecoremechanismof fast unfolding is the calculation of the change to the global modularity quality q for each merging operation.
to give higher priorities tothenodesthatshouldbefirstlyclusteredaccordingtoexperts experience weintroducetwobiasestothe q.themodified q calculation is as follows q q prime bl be where q primeis the basic qcalculated in equation .
the blandbe arelocalityandentry limitbiasintroducedtoguidethemodularization procedures.
locality bias.
during program development functions that are designed to perform the same task are likely to be placed together e.g.
in the same source file .
as a result after being compiled into binary executable these functions will be placed one after anothercontinuously.withthisheuristics modxintroducesthe localitybiastothemodularizationalgorithm.thekeyideaisthat weexpecttogroupfunctionswhichareclosetoeachothersince they have a higher chance to perform the same task.
to achieve this eachfunctionisassignedwithanindexingnumberbasedon itslocationsequenceinthebinary.consequently eachmodulewillhaveanaveragevalueofthefunctionindexing.then wedefinethe dispersion scope dsof a module as the summation of the distances from each of the functions indexing to the average value.
whenmerging the two modules we can update the new values of the average indexing and the ds.
we limit the maximum dsto be the numberoffunctionsintheentireprogramdividedby100.ifthenew dsexceedsthelimit themergingalgorithmwillbediscouragedby tocombinethetwomodules.last wescaletheencouragement and discouragement to the range naming it blas the first biasto q.inequation7 the q primewillbeexpandedbythe blfrom0 to300 .inthisway weaddinthebiastoletthealgorithmconsiderthenearerfunctionsfirstratherthanreachingtofunctionsthatare very far away.
moduleentrylimitbias.
accordingtothesingle responsibility principle each method or module should have a single functionality which should be encapsulated by it.
we would like the moduletohavelimitedentriestoensurethesingleandencapsulated functionality.therefore weintroduceanentrybias betoduring themodularization.inthiswork themoduleentryisdefinedasa function node that only has its caller functions outside the module.
the entry quality eq score is the number of entries of a particularmodule.whencalculatingthe qr scombiningmodule rand modulestogether the eqrsis defined as the difference between theeqof the new module and the average value of eqrpluseqs.
afterhaving eq wecalculatethebias beaccordingtoequation8.
the bewill encourage to merge modules that could decrease the number of entries and in otherwise discourage to them.
be eq .
third party library detection after modularizing the program and the tpls we propose the similarity measurement algorithm to match the modules based on syntacticandsemanticfeaturesanddetectthetplsintheprogram.syntactic similaritygraph similarityfunction similaritymodules for detecting tf idf adjustmentfunc func func funcfunc func func funcfunc embedded vector readable strings constant numbers greedy matching data behaviors switch tables3 anchor pointsmodules from librariesmodule similarity similarity scoresmi scoresno.
of modules li scoresno.
of libraries matched modulecorresponding libraries figure module matching overview figure2showstheoverviewofthetplsdetectionprocedurevia module matching.
.
.
module similarity measurement.
syntactic features.
inspired by syntactic feature based library detection works we incorporatesimilarfeaturesinourmodulesimilaritymeasurement.
specifically we use the strings literal and constant numbers as the syntacticfeatures.stringliteralisthemostsignificantfeaturesince itusuallyhasuniquevalues whichcanbeeasilydistinguished.if two functions in two modules have the same string literal they haveahighchancetobethesamefunction.however thereareonly asmallportionoffunctionswhichhavestringliterals.therefore strings can only help us to accurately match some of the functions andmodules.comparedtostringliteral theconstantswillhaveless uniqueness.
for example we can detect a constant which is used in the branching comparison.
meanwhile constant can be also usedtofreethememoryspace.therefore thiskindofconstantmaynotcarryusefulinformationforsimilaritymeasurement.toaddress it weadoptthetf idf algorithmtoassignmoreweightsto moreuniqueconstants whichusuallyappearlessfrequentlyinthe module than the rest.graph similarity features.
the module consists of functions which call each other to form a call graph.
we use propagation graph kernel algorithm to measure the call graph similarity.
the algorithm tries to measure the graph and sub graph structure similaritybetweentwographs.formorefine grainedfeatures suchaseachedgeofthecallgraph weadopttheedgeembeddingmethod from roualign to measure the edge similarity in the topology.
roualignpromotesarobustwaytoembedfeaturesoffunctioncallgraphs with the method the edges of a particular module could be embeddedintovectors.andthenwecouldfigureoutwhichpart of the graph is similarby vector searching which is time efficient and scalable.functionsimilarity features.
thesefeaturesmeasurethesimilaritybetweenfunctionsinthemodules.sinceamoduleconsists ofmultiple functions thescorewill beaggregatedtomeasure the modulesimilarity.tocalculatethescore weneedtoaddresstwo problems.
first given two functions how to measure their similarity.second howtochoosethetwofunctionsfromthetwomodules authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa can yang1 zhengzi xu hongxu chen4 yang liu3 xiaorui gong1 baoxu liu1 tocomparewith.forthefirstproblem weleverageastate of the art binary function matching tool gemini to produce a similarity score between two given functions.
the main idea of gemini is to embed the function control flow graph into a vector and calculate thevectordifferencestodeterminethefunctionsimilarity.basedon ourexperiment geminihasarelativelygoodperformancewhich can save the time in the feature generation step.
amodulemayconsistoffunctionswithdifferentfunctionalities.
for example a module may have functions to perform the core operation functions to do the error handling and functions tocommunicate with other modules.
therefore we would like to compare functions with similar functionality rather than the ones withdifferentfunctionalities whichwillgivealowsimilarityscore.
moreover since each module will consist of multiple functions calculating the pairwise function similarity takes time.
therefore forthesecondproblem weadoptadrill downapproachtoselect function pairs.
as discovered in similar functions usually use a common group of data or they will be referred to by the same pointers.
therefore to selectively measure the similarity we identifytwotypesofanchorpointswithinthemodulestohelpustolocatefunctionsthatarelikelytohavethesamefunctionalities.first inonemodule ifwedetectmultiplefunctionsaccessingthedatain the same memory space we will mark it as the anchor point type and wetry to detectthe similar anchor pointin other modules andmeasurethesimilarityamongtherelatedfunctions.second we accessing the dispatch table in the module if it exists.
the dispatch table is a table of pointers or memory addresses referring to the functions.
we will use these functions as the anchor point type .
we will compare the similarity among the functions that belong to the same type of anchor points.
.
.
tpldetection.
modxperformstpl detectionby checking whetheramodulefromthetargetprogramcouldbematchedtoany ofthemodulesinthesignaturetpls.foreachmoduleinthetargetprogram modxmatchesitagainstallthemodulesgeneratedinthe signaturetpldatabasebysummarizingthesimilaritiesbetween each feature discussed in section .
.
.
modx ranks the candidate modules by the similarity score and selects the modules with high and distinguishable similarity.
however the matching result may contain false positives due tothefollowingreasons first someofthelibrariesmaycontainsimilar modules.
it is difficult to distinguish from which library themodulecomes.thiswillhappenespeciallywhenthemodules aresmallinsize whichwillconsistofsimplestructureswithfew functions.
second the tpls are in different sizes which will bring unfairnessduringthematching.forexample libbz2libraryhas only modules with functions while libcrypto library has over modules with functions.
therefore if modx detects a module of library libbz2 we may have high confidence that the library is reused in the program.
on the contrary detecting onlyonemoduleoflibrary libcrypto maysuggestthatitisafalse alarm.
to further improve the accuracy we adopt two adjustments.
first we introduce the module importance mi score to select the modules which are considered to be more important.
in the heuristics webelievethatthebiggerthemodulesize themoreimportant the module would be.
it is because that bigger modules tend tohave more unique structures which may not be miss matched withothermodules.therefore miisspecifiedinequation9 where mk denotesthetotalfunctionsinthe k thmodule nisthetotalnumber of modules.
second for a library its importance ought to havepositive correlations with the reference frequency and negative correlationwiththenumberofthemodulesthatitcontains.the morefrequentlyonelibraryisneededbyotherbinaries andthelessnumberofmodulesthelibraryhas themoreimportantitshouldbe if its modules are detected in the program.
the equation shows the library importance li for library h where the lh denotes the number of modules in the h th library the lh denotes the timesthelibrary lhisreferredto.itisdifficulttodeterminewhether a module is used in the detected binary but the module usage frequencycouldbeapproximatedbythelibraryusagefrequency.
withthisassumption wegivethematchingconfidence mc by equation to the module kof the library h. a higher mc score meansthemorecreditablethedetectiononthemodule.finally we combine thesimilarity scoresin section3.
.
with themc togivethe final results of the tpl detection.
mi k mk summationtext.1n i mi n lih log lh lh mck mik lih evaluation in the experiments we aim to answer the following research questions rq1 what is the quality of the modules generated by modx compared to other program modularization works?rq2 whatistheaccuracyof modxindetectingtplsinbinary programs compared to related works?rq3 whatisthebreakdownperformanceof modxinmodularization and library detection?rq4 whatarethereal worldusecasesofpartiallibrarydetection?
rq5 what are other possible applications of program modularization in software engineering and security?
.
module quality evaluation rq1 module quality metrics selection.
to evaluate the quality of the generated modules by modx we have selected metrics from different aspects.first since theprogrammodularization process is very similar to the community detection process we choosethe commonly used community quality metrics to measure the modules.
promotes the orign mq which measures the quality for an unweighted and undirected network.
moreover since the programcallgraphisdirectedandwehaveassignedweightstothegraph wealsoselected directedmq andweightedanddirected mq astheevaluationcriteria.second wehavereviewedthe source code level program modularization works and selected metricsusedinthestate of the arttools evaluation namely bunch mq andturbo mq .
the bunch mq is designed to reward the creation of highly cohesive clusters and to penalize excessive coupling between clusters.
turbo mq is a lightweight metric that includes edge weights.
last from the program analysis authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
modx binary level partially imported third party library detection via program modularization and semantic matching icse may pittsburgh pa usa table the modularization results for several metrics .
metrics modx bcd ar modularization orign mq .
.
.
directed mq .
.
.
weighted and directed mq0.
.
.
bunch mq .
.
.
turbo mq .
.
.
no.
of entries .
.
.
no.
of isolated clusters1.
.
.
the denotes that the score is of the best performance out of the three.
pointof view we wouldexpect thatfor eachmodule thereshould beasfewentrypointsaspossible.lessentrypointssuggestthatthe module can be used called in less different ways which ensure the module coherence.
moreover we would like the clustering results to be smooth which means that there should be as few isolated clusters as possible.
therefore we count the average number of entriesandthenumberof isolatedclusters withineachmoduleas the last two metrics.relatedworkselection.
wehavechosentwoalgorithmstocompared withto evaluatethe modulequality.
first as faras wehave reviewed bcdisthestate of the artbinarylevelprogrammodularizationtoolintheliterature.therefore wehavecomparedmodx withbcdonthe7metrics.second theprogramdeveloperwilltend to place functions with similar functionalities into the same file atsourcecodelevel.wecanregardeachofthefilesasaprogram module so that the program is modularized naturally during the development.usually thistypeofprogramwillbecompiledinto archive files .a as suffix which consists of many object files .o assuffix .wemeasurethequalityofthemodulesgeneratedaccord ingtotheobjectfileboundaries denotedas armodularization and compare it with modx.module quality assessment.
we have selected commonly used binaries compiled by nix and run modx and bcd on them.forarmodularizationtechnique sincenotallthebinaries are compiled into archive files we only tested it on systemlibrary binaries which have the archive files.
table shows theaverage scores for each of the metrics of modx bcd and armodularization respectively.
in table1 the first five metrics are modularity metrics.
among them four metrics are used in related works .modularity measuresthestrengthofdivisionofagraphnetworkintomodules.thelasttwometricsare heuristic statistical metrics.
they measure the readability and reasonableness of the modules.
generally our method reaches higher module quality scores than other modularization methods and has less entries and isolated clusters per module.
the only metric that armodularizationbeatsmodxisthe weightedanddirectedmq.it is becausethat when calculating themetric the finalscore will be normalizedagainstthetotalweightsoftheprogram.theprogramsusedtomeasurethequalityforarmodularizationtendtohaveless weights than the programs used to test modx and bcd.
therefore ar modularization has a higher score even if its module quality is lower than other tools.human labeled modularization comparison we have collaborated with a big software vendor name anonymized which has greatinteresttothesoftwarestructureunderstanding.therefore itemployssoftwareengineeringexpertstomanuallymodularizeglob filename glob dir to array dequote pathname xdupmbstowcsglob pattern p xstrmatchstrmatchglob vector glob testdir wmatchlenmatch pattern char match pattern wchar wcsmatch rangecmp umatchlen xmbsrtowcs a manually labelled module remove pattern remove upattern match pattern char strmatch rangecmpumatchlen extmatchmatch upattern find string in alist find index in alist wcsmatch internal wcsmatch internal wcsmatch 0xstrmatch xdupmbstowcsinternal strmatch internal strmatch 0 gmatch patscan patscan wcextmatch wcparse collsymgmatch wc parse collwsym b modx generated module figure3 comparisonbetweenmanualandmodxmodular ization results a real world project bash which is a commonly used program for commandprocessing.
we alsocompare theresults of modx with it.inthisexperiment thesourcecodebashversion4.
.0has2761 functions.theexpertsmanuallydecomposethesoftwareinto13 modules.
then we compile the source code into binary and apply modx to generate modules.
toevaluatetheresults weproposeametrictomeasuretheoverlapping between the generated modules and the human labelledmodules.weselectall thefunctionsin onemodulegeneratedby modx and count the number of modules that the same set of functions appear in the manually labelled modules.
for example if agenerated module contains three functions a b and c. function a belongs to labelled module i while function b and c belong to labelled module ii.
therefore the overlap metric score will be2 .
the average overlap score for each generated module is .
which suggests that the modules generated by modx have ahighoverlapratiowiththehumanlabelledmodules.therefore modx will be a good solution to save the manpower to produce precise modules automatically.
moreover figure3 a and b showstheconcreteexampleofthe modulesgeneratedbyhumanexpertsandbymodxrespectively.
since human experts group the source files to form the modules there may be some isolated functions in each module.
as shown in a there are6 isolatedfunctionswith 4beingmarked indifferent color boxes.from thenames weknow thatmost ofthe functions inthismodulehavethesimilarfunctionalitytoprocesswild cast strings.forthegeneratedmoduleinfigure3 b modxhasgrouped the4isolatedfunctions markedinthecolorboxes intoabigger authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa can yang1 zhengzi xu hongxu chen4 yang liu3 xiaorui gong1 baoxu liu1 module with some additional related functions.
from the function names we can notice that most of the functions are with the same functionality which suggests that modx has produced a more complete module than the manually labelled approach.
answering rq1 compared to the state of the art program modularization work the average ratio in which modx outperforms in modularity quality mq metrics is .53times.moreover thegeneratedmodulesaresimilarto the modules decided by human experts.
.
library detection accuracy evaluation rq2 binaryprogramandtpldataset.
weevaluatedourtoolontwo setsofbinaries.first weleveragethepackagemanager nix tocollect programswiththeir buildingdependenceon linux.nix has provided a service to automatically build binaries with both static linked and dynamic linked libraries.
we built all available programs under the category applications on nix packages store andsuccessfullygained106binarieswithgroundtruthasthetesting data set.
second since nix does not guarantee to include all therequired libraries in the binaries according to our inspection togenerate the data set with the real ground truth we manuallybuild a set of binaries on ubuntu .
.
specifically we choose commonly used programs and build them with statically and dynamically linked tpls.
to detect the tpls in the aforementioned binaries we have alsobuilta tpldatabase.wehavecrawledallthe 278librariespresented in ubuntu .
.
we prune off the duplicate libraries with different architectures and versions and filter out the libraries that cannot be statically linked with the help of dpkg package manager.
we order the remaining libraries and choose the top frequently used libraries to form the testing tpl database.
tpldetectiontoolscomparison.
toevaluatethetpldetection accuracy of modx we choose two state of the art tools bat and osspolice to compared with.
we run the three tools over the data sets built in the previous step.
since both bat and osspolice are designed to detect third party packages which contain multiple libraries we choose to compare the accuracy of both li brary detection and package detection among the three tools to ensure the fairness.
table and table show the precision and recall results for thetpldetectiontoolsovernixgeneratedbinariesandmanually compiled binaries respectively.
for table osspolice stands for detection results based on our implementation and experiment whereasosspolice standsforresultsclaimedintheirpaper.bat andbat havethesamemeaning.fromthetable2 wecan notice that modx has .
precision and .
recall in package detection and .
precision and .
recall in tpl detection which are the highest among the three tpl detection tools.
in table we list detailed library detection results for the manually crafted ubuntu binaries.the first two columnspresent the binary namesandthenumberoftplsineachofthem.therestoftable3 showsthenumberoftruepositives tp falsepositives fp and falsenegatives fn forthethreetools.asshowninthetable modxtable tpl detection on real world programs.
modxosspolice osspolice bat bat package detection precision .
.
.
recall .
.
.
library detection precision .
.
.
recall .
.
.
table partial library detection on ubuntu binaries.
binary libsmodx osspolice bat linked tpfpfntpfpfntpfpfn ssldump vim busybox tcpdump openvpn sqlite3 openssl total performance summary modx osspolice bat precision recall precision recall precision recall .
.
.
.
.
alsoachievesthehighestresultswithprecision .
andrecall .
on average.
discussion.
in the experiment most of the binary libraries are partially imported since the modern linkers will only link the used portion of the tpl by default .
the modx has better accuracy comparedwithothertools becausethemodulesnaturallyconsistofthefunctionsthatperformthesimilarfunctionality.whendetectingpartialusageofthelibrary thefeaturesofmoduleswillkeepstable without being demolished.
fp.thebottleneckiscausedbythecollisionofthemodulefeatures.
theremayexistmoduleswithsimilarstructuresandfunctionalities across different libraries.
the feature extractedfrom these modules may not be distinguishable enough to separate them.
therefore mistakenlymatchingamodulewithsimilaronesinotherlibrary signatureswillresultinthedecreaseoftheprecision.modxadapts the semantic information into features which adds in additional featurespacestoincreasedifferencesbetweenmodules sothatit can produce higher precision in the evaluation.fn.
sincesomeofthelibrariesaretinyinsize whichonlyconsists of few modules it is difficult to extract distinguishable features fromthelimitednumberofmodules.thus thelackoffeaturesin smalllibrariesisthemainreasontopulldowntheoverallrecallfor modx.
same as many other tools the modx will perform better when the versions between the signature library and library in the target function are closer.
answering rq2 compared to the state of the art tpl detection works modx has better on average precision and recall on both real world and manually crafteddatasetindetecting100commonly usedtpls.the semantic module matching and partial library detection capability enable modx to outperform other works.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
modx binary level partially imported third party library detection via program modularization and semantic matching icse may pittsburgh pa usa table program modularization time comparison data set set a set b set c total file size kb .
.
avg.
size kb .
.
.
.
no.
of binaries avg.
func.
.
.
.
.
avg.
modularization time seconds modx .
.
.
.
bcd .
.
.
.
table tpl detection time comparison time average detecting time s modx osspolice bat set a kb .
.
.
set b kb .
.
.
set c kb .
.
.
average .
.
.
.
performance evaluation rq3 table gives the average time used to modularize a given program of bcd and modx.
since the time used to modularize the program isproportionaltotheprogramsize wedividethetestingprograms into three size ranges in the experiment.
as shown in the table in allsizesofbinaries modxoutperformsbcd.itisbecausemodx uses locality scores to guide the rapid modularization.
but in bcd the locality information is represented as edges between nodes which makes the graph complicated and slows the process.
table shows the average time used to detect tpls in given programs.
since osspolice and bat only use syntactic features such as strings which can be indexed they have better performance than modx.
modx extracts semantic features from graphs and measures function similarities which are mainly unstructured data.
therefore we do not have a better way to store and index thesefeaturesquickly.wehavetoloadandcomparethefeatures one by one in the detecting procedure which lowers the perfor mance.
a higher accuracy of modx is guaranteed and is worth the cost of time.
thus in practice we recommend using modx as a complementary process after syntactic approaches to produce more accurate results.
answering rq3 modx takes on average seconds to modularize binary program which outperforms bcd.
however it costs seconds to finish the tpl detection which is slower compared to other approaches.
.
use case study rq4 real world malware programs usually share only partial codes between variants.
this would be a challenging case to evaluate the partial tpl detection ability of modx.
we manually collected a family of malware from virusshare to perform a use case study.
the malware is from a famous botnet program family called mirai whichhasbeenopen sourcedsince2016.ittargetsatvarious kindsof networkingdevicesand mutatesrapidly.there areover mirai variants according to microsoft collections .
we have selectedtheoriginalmiraiasthesignaturetodetectthemalware appearancein15variantssubmittedfrom2016to2020 4variantsindifferentarchitectures 3variantsintherecentyear2020 and8other variants .
specifically we build the malware binary from its sourcetable malware variants detection detections total modx bat osspolice different architecture variants at other versions total summary precision recall code and add the features into our library database.
we regard the malware as a tpl named libmirai.
for each collected malware variants wedetecttplusagewithmodx batandosspolice.if libmiraiis detected in the variants binaries we count as a correct malware prediction.
table6showsthemalwaredetectionresults.overall ourmethod has the best accuracy in detecting out of malware variants.
thesecondrowintable6showsthatmodxcouldcatchthesemanticaccuratelyevenacrossarchitecturessincethesemanticbased signaturescanresistmanykindsofmodificationandmutation.the third row shows that modx is reliable in detecting small partial codereuse whileothertoolsfail.batusesstringsasthesignature whichisnotstableacrossvariants.osspoliceisnotgoodathandling binary signatures leading to the lowest accuracy performance.
answering rq4 modx has the best malware variant detectionaccuracy whichsuggeststhatitcandetectpartial codereusewiththehelpofmatchingmodulesinsteadof the entire program.
.
applications rq5 inthissection weshowotherpotentialapplicationsoftheprogrammodularizationtechnique.besidesdetectingthetpls modxoffers themodularizationresultsforotherprogramanalysisworkssuch as reverse engineering and attack surface detection.reverse engineering with module tagging.
themodulescan reveal high level semantic information which is very helpful for reverse engineering.
as the proof of the concept we assign tags to the module by extracting the common strings from the function namesitcontains.then wematchthemoduletodetectthesimilarmodulesinotherprogramsandcheckifthedetectedmodulesshare similar tags.
table shows an example of two matched modules withthefunctionnamesindetail.eventhoughthefunctionsoftwo modulesaredifferent thetagsextractedaresimilar whichsuggests that their functionality at high level are also similar.
we manually verifythiscasetofindthatbothofthetwomodulestrytodealwith the connection between the server and the client.
therefore if we managetocollectdifferentmoduleswithtagsasthesignatures we can match the modules in the target program.
then we can obtain hints about what kind of functionalities the target program has which is critical in the reverse engineering tasks.attack surface detection.
vulnerabilityisaspecialtypeofprogramflawwhichcanleadtosecurityissues.todetectithelpsto improvetheoverallsoftwaresecurity.accordingto functions which contains the vulnerabilities follow certain patterns.
therefore we would like to use the modularization technique to help to identify the attack surface which aims to determine the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa can yang1 zhengzi xu hongxu chen4 yang liu3 xiaorui gong1 baoxu liu1 table module tagging results module.
functions ssl find cipher ssl set server random ssl process server session id sslx print certificate sslx print certificate ssl process client key exchange sslx print dn decode handshaketype serverkeyexchange decode handshaketype certificateverify decode handshaketype clientkeyexchange decode handshaketype finished .sprintf ssl decode opaque array decode handshaketype serverhello decode handshaketype certificatemodule.
functions tls check ncp cipher list helper client server options postprocess verify ce options postprocess helper keepalive notnull helper tcp nodelay clone route option list clone route ipv6 option list new route option list init key type push option alloc connection entry check file access rol check alloc 0 pre pull save 0 .access check file access chroot plat form access rol check alloc ifconfig pool verify range pre pull save cipher kt get proto is net print topology print opt route print netmask print str int print opt route gateway verify common subnet common tagscipher type client print server verify conclusion in high level some cryptography handshake between serverandclient verifying the identity of the peer.
table distribution of vulnerabilities in modules binutils libxml2 openssl freetype tcpdump basic information.
functions modules vulnerabilities information.
no.
of cves distribution of cves.
of modules 11. .
.
.
.
of funcs inmodules 27. .
.
.
.
of cves inmodules 85. .
.
.
.
modulesthataremorelikelytohavevulnerabilitiesovertheothers.
thesecurityanalysisworkscanbenefitfromitsincetheycanfocus on the vulnerable modules attack surface to save time.
to test the attack surface detection ability we have collected all thecves e.g.commonlyknownprogramvulnerabilities from5 real world projects binutils libxml2 openssl freetype and tcpdump .weusemodxtodecomposethe5projectsintomodules and plot the cves to the modules that they belong to.
in the experiment wefocusonthemodules whichcontainatleastonecve named modules .
table shows the allocation of the cves in modules foreachoftheprojects.thefirstfewrowsshowthebasic information of the projects and their vulnerabilities.
the 8th to 10throwsshowthepercentageofthenumberofmodules overall modules the percentage ofthenumberof functionsinmodules overallfunctionsintheprogram andthepercentageofthenumber of cves the modules has against all cves respectively.
accordingtotheresult wecanseeaclearindicationthatmodules s only account for a small portion of all the modules but they containthemajorityofthecves.forexample inopensslproject .
modules with .
functions have .
cves.
therefore themodularizationtechniquehasthepotentialtoaidthesecurity analysis by providing modules which contain more vulnerabilities and are worthy to be further studied.answering rq5 program modularization has impactful applicationsinsoftwareengineering.experimentsshow that it helps to understand the program in reverse engineering and detects attack surfaces in security analysis.
discussion threats to validity.
our work relies on reasonable modularizations on the program.
if the program module semantics changed greatly our method would lose its effectiveness in matching them.
therefore twocommonthreatsare heavyobfuscationonthe binaries.
significantsemanticchangesfromthebottom.weacknowledge that these challenges are still difficult to handle and are hot topics in the recent literature.
limitations future works.
first as mentioned in section .
modxhasmoreoverheadcomparedtoothersyntacticfeaturehash matching based approaches.
the overhead is mainly introduced by the time to extract features during module matching.
one possible solutionistoleveragelightweightsyntacticmatchingtofilterout obviously irrelevant cases and use modx to confirm the results in a much smaller candidate space.
second the software researchers have not reached a common consensus about verifying the correctness of the result of binaryprogram modularization.
we have tried our best via proposing our ownmodule metric tomeasure the qualityand evaluating the modulesagainststandard communitydetectionmetrics.however it is difficult to prove that the metrics themselves reflect the real modulequality.inthefuture weaimtoperformanempiricalstudy ontheimpact ofmetricschoseninprogram modularizationsince different applications may require different customised metrics for module quality measurement to produce better results.
last thetpldetectionisthedirectapplicationofprogrammodulization.webelievethatthistechniquehasgreatpotentialinmany other areas.
we have evaluated some of the possibilities such as attacksurfacedetectioninsection4.
.inthefuture weplantoextend the work to facilitate other analyses in program understanding.
related work inthissection wediscusstherelatedworksintheareaofprogram modularization tpl detection and code clone detection.programmodularization.
theprogrammodularizationisahelpful technique looking insight into a software system which is now welldevelopedinsourcecodesanalysis.bunch modularizes source files of the program into clusters by module dependencygraph mdg .
following studies improve the clustering torealize theautomation andthe architecturerecovery.
some later studies can perform modularization more close to human experts.
it is still challenging to modularize a c c binary program and little progress has been made according thenewestsurvey .c c binariesstripthethestructuralinformation of modules after compilation which in very different from otherprogramslikejavaapplications .bcd introduces communitydetectionmethodstodecomposeabinaryintomodules andcansuccessfullyrecoverspecificc classes.followingstudies concludesthatthemodularizationinbinaryprograms authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
modx binary level partially imported third party library detection via program modularization and semantic matching icse may pittsburgh pa usa isamoresemanticapproach andisusefulindetectingsmallpieces of binary code.
these works focus on analyzing the program structures with the modularization.
whereas modx tries to provide a complete solution to modularize the program and measure the similarity between them.
manyideas ofprogram modularizationcome fromcommunity detection algorithms.
we briefly introduce the algorithms based onthemodularitythatbenefitus.theoriginalideawasgivenby girvanandnewman withanimprovementtoperformfasterat large communities .
later fast unfolding was proposed to achieve rapid convergence properties and high modularity output.
afterslightmigrationonthedesign variantmethods intended for directed and weighted networks were proposed which are more suitable for the program modularization task.
tpl detection.
tpl detection aims to find the code reuse in software.
approaches are proposed to extract the features from source codeandmatchthetplsinthebinaryprogram.binaryanalysis tool bat isarepresentativemethodbasedontheusageof constants.
bat extracts the constant values from both sources and binaries and then utilizes a frequency based ranking method to identify the presence of third party packages.
this kind of method is scalable in firmware analysis .
osspolice introduces a hierarchicalindexing schemeto makebetter useof theconstant andthedirectorytreeofthesources.
bcfinder makestheindexinglightweightandmakesthedetectionplatform independent.
osldetector builds an internal cloning forest to reduce the efficiency of features duplication between libraries.
b2sfinder makes a well study on the features before and after compilation givingmorereliablethird partycodedetectionresults.thesemethods are designed feature based rather than semantic based for efficiency.
other approaches try to use binary level features to detect tpls whichareoftenusedinmalwareanalysis.nativeideaslike bindiff andbinslayer trytodirectlymatchtwobinaries viagraphmatching.libdx isatypicaltoolintpldetection with a gene map to overcome the duplication of features where featuresaremainlyconstantsforscalability.asforjava binaries manymethods leveragemodularizedstructuresto achieve fast and accurate tpl detection.function level clone detection.
there are also many works identifying function level clones in a binary.
the early methods takethebytescodeatthefunctionbeginning whichisknownas ida flirt.
the latter ones extract many internal function features such as operation codes control flow graphs sequencesofbasicblocks collectionsoflibrarycalls symbol executionconstraints and simulateresults .recently thestate of the artsworks utilizemachinelearningtechniques to achieve the automation in features extraction and clones identification.
many clone detection methods have been proved usefulinrealistictasks likevulnerabledetection .theseworks focusonprovidingfunctionlevelfeatures.ourworklearnsfrom themtoproposeunique androbustfeaturesforprogrammodules.
conclusion insummary weproposemodxtodetecttplsinsoftwareviasemanticmodulematching.withthenovelmodularizationalgorithm it divides the target program and the signature library into fine grained functionality based modules.
then it extracts syntactic andsemanticfeaturesfrommodulesandmeasuresthesimilarity amongthemtodetectthepresenceoftpls.experimentsshowthat modxoutperformsothermodularizationtoolswith353 higher module quality scores and outperforms the state of the art tpl detectiontoolswith17 lesserfalsepositives.moreover thebinarylevelprogrammodularizationtechnique asthestand alonemethod alsohasapplicationssuchasreverseengineeringandattacksurface identification which provides new research opportunities.
acknowledgement we appreciate all the anonymous reviewers for their invaluable commentsandsuggestions.
thisresearchissupported bythekey laboratoryofnetworkassessmenttechnologyofchineseacademy of sciences and the beijing key laboratory of cyber security.
this research is partially funded by the strategic pilot science and technology project of the chinese academy of sciences category c dc02040100 and the natural science foundation of china no.
no.
.thisresearchissupportedbytheministry of education singapore under its academic research fund tier moet32020 .
any opinions findings and conclusions or recommendations expressed in this material are those of the author s and do not reflect the views of the ministry of education singapore.
this research is partially supported by the nationalresearch foundation singapore under its the ai singapore programme aisg2 rp the national research foundation prime ministers office singapore under its national cybersecurity r d program award no.
nrf2018ncr ncr005 nrf investigatorship nrfi06 the national research foundationthroughitsnationalsatelliteofexcellenceintrustworthy software systems nsoe tss project under the national cybersecurityr d ncr grantawardno.nrf2018ncr nsoe003 .
this research is partially supported by the ntu desay sv research program .