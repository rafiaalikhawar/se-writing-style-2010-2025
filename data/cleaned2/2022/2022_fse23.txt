ppr pairwise program reduction mengxiao zhang school of computer science university of waterloo canada m492zhan uwaterloo.cazhenyang xu school of computer science university of waterloo canada zhenyang.xu uwaterloo.cayongqiang tian school of computer science university of waterloo canada yongqiang.tian uwaterloo.ca yu jiang school of software tsinghua university beijing china jy1989 mail.tsinghua.edu.cnchengnian sun school of computer science university of waterloo canada cnsun uwaterloo.ca abstract program reduction is a practical technique widely used for debugging compilers.
to report a compiler bug with a bug triggering program one needs to minimize the program by removing bugirrelevant program elements first.
though existing program reduction techniques such as c reduce and perses can reduce a bug triggering program as a whole they overlook the fact that the degree of relevance of each remaining token to the bug varies.
to this end we propose pairwise program reduction ppr a new program reduction technique for minimizing a pair of programs w.r.t.
certain properties.
given a seed program ps a variant pvderived from ps and the properties psandpvexhibit separately e.g.
pvcrashes a compiler whereas psdoes not ppr not only reduces the sizes of psandpv but also minimizes the differences between psandpv.
the final result of ppr is a pair of minimized programs that still preserve the properties but the minimized differences between the pair highlight the critical program elements that are highly related to the bug.
to thoroughly evaluate ppr we manually constructed the first pairwise benchmark suite from real world compiler bugs bugs in gcc and llvm bugs in rustc and bugs in jerryscript .
the evaluation results show that ppr significantly outperforms the baseline dd a variant of delta debugging.
specifically on large and complex programs ppr s reduction results are only .
of those by dd w.r.t.
program size.
the sizes of the minimized variants i.e.
pv byppr are also comparable to those by perses and c reduce but ppr offers more for debugging by highlighting the critical bug inducing changes via the minimized differences.
evaluation on rust and javascript demonstrates ppr s strong generality to other languages.
corresponding author also affiliated with hong kong university of science and technology.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
concepts software and its engineering software testing and debugging .
keywords program reduction delta debugging bug isolation acm reference format mengxiao zhang zhenyang xu yongqiang tian yu jiang and chengnian sun.
.
ppr pairwise program reduction .
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
.
introduction compilers are fundamental system software to build all software including compilers themselves any bug in compilers may incur significant profound damages.
thus it is crucial to detect and fix compiler bugs promptly.
in recent years researchers have devoted dedicated efforts to random compiler testing .
among all compiler testing techniques one major widely used type of techniques is mutation based testing which generates new test programs referred to asvariants by applying random mutations to existing programs referred to as seeds in hopes of provoking compiler bugs.
program reduction.
upon finding a program pthat triggers a compiler bug program reduction an important and highly demanded category of techniques for compiler validation and debugging aims to minimize pby removing code elements that are irrelevant to compiler bugs the minimized program is used to facilitate diagnosing and fixing bugs.
most reduction techniques reduce a program as a whole and assume that every part of the minimized program is equally relevant to the bug but overlook the fact that the degree of relevance of each program element to the bug varies.
for instance though the state of theart technique c reduce can minimize the original bug triggering program of llvm to tokens as shown in figure 1a it can still take compiler developers large efforts to debug as the critical bug triggering tokens are not highlighted.
in this example certain tokens are indeed more relevant to the bug than the others the bug is triggered by code highlighted in figure 1c which modifiesesec fse december san francisco ca usa mengxiao zhang zhenyang xu yongqiang tian yu jiang and chengnian sun the same variable bin multiple basic blocks and is more relevant to the bug than statements such as function calls to divandid.
program isolation.
as shown above isolating failure inducing program elements can facilitate debugging.
to the best of our knowledge there are two prior program isolation techniques.
dd dd is a variant in the delta debugging algorithm family.1given p it does not only reduce pbut also highlights the key failure inducing elements in p. it returns a pair of programs the minimized bug triggering program referred to as variant reduced from pand the maximized non bug triggering program referred to as seed grown from an empty program.
however dd does not respect the syntactical constraints of programs and thus does not perform well on programs the reduction time can be excessively long because of generating large numbers of syntactically invalid programs and the results are usually too large for debugging .
moreover dd does not use the original seed program from which pis derive to find the failure inducing program elements and thus the difference between the seed and variant is usually irrelevant to the root cause of the bug.
figures 1d and 1e show the reduced result by dd for llvm dd highlights that if the function call fn is removed from the variant then the bug disappears.
though the bug is indeed triggered by certain code in fn the highlighted difference by dd is far less informative than the difference in figure 1c.
moreover in the reduced variant by dd fnhas tokens which contains excessive irrelevant information and thus complicates debugging more details are in .
spirv fuzz spirv fuzz is a testing technique for spir v intermediate representation .
given a seed program ps it applies a sequence of random mutations on psto generate a variant for testing spir v processors.
different from classical mutation based testing spirv fuzz intentionally makes each mutation as small and independent as possible.
once a variant pvfinds a bug ddmin is used to reduce the sequence of mutations that is applied on psto generate pv so that the bug irrelevant mutations can be removed in the end pvand the sequence of bug relevant mutations are included in the bug report to facilitate debugging.
although spirv fuzz can highlight the critical changes and has been adopted at google several weaknesses limit its application to testing other language implementations and motivate this work.
first spirv fuzz relies on a special mutation base technique the mutation operations need to be small and independent and the sequence of mutations applied to a seed needs to be recorded modifiable and replayed.
second it can merely minimize the differences between the seed and variant but is not capable of reducing the common part the authors also acknowledged this limitation and that large seed programs might diminish the comprehensibility of the bug reports as quoted from the comprehensibility of these bug reports and regression tests depends on a reasonably small original program .
despite the importance of program reduction and program isolation in debugging there is no technique yet that synergistically 1zeller et al.
proposed two algorithms dd and ddmin in .
dd aims to isolate failure inducing changes by narrowing the difference between a given list that has a property and an empty list ddmin removes from the given list the elements that are irrelevant to the property.reconciles both.
to this end we propose pairwise program reduction ppr a novel and effective program reduction technique considering both program reduction and failure inducing change isolation at the same time.
specifically ppr compares a seed psand a bug triggering variant pvgenerated from ps and then reduces thecommonalities and the differences ofpsandpvsimultaneously.
the reduction result includes a minimized seed p sand a minimized bug triggering variant p vwith the differences between p sandp v minimized as well.
we strongly believe that ppr addresses the shortcomings of dd and spirv fuzz and is practical in at least the following two aspects for developers of compilers.
debugging compiler bugs is arduous especially debugging miscompilation faults.2the minimized differences between p sand p vhighlight the minimal required changes from a passing program to a bug triggering one to induce the bug.
such minimal changes together with the minimized bug triggering program offer a good starting point to compiler developers for fault localization and analysis.
for researchers on mutation based compiler testing.
isolating the critical changes provides insights to researchers on compiler testing who frequently need to analyze the efficacy of mutations e.g.
which mutation operator is more effective in triggering compiler bugs to understand and tune their fuzzing techniques.
prior mutation based research work indeed conducted such analysis though manually.
for example researchers distilled and posted critical code mutations that contributed to a bug in their paper.
however such manual efforts are often labor intensive and error prone and more importantly can be automated.
we have conducted extensive evaluations of ppr showcasing its practicality and superiority over dd.
first we evaluated ppr on large real world c compiler bugs.
on average the number of tokens involved in bug triggering changes is reduced from to only and the overall input size is narrowed from to tokens.
this result is remarkably small compared to tokens from dd and even comparable to results of the state of the art reduction techniques i.e.
perses and c reduce .
for efficiency ppr is faster than dd on average.
besides c c programs further evaluation shows ppr s generality to other languages.
contributions.
we make the following major contributions.
we propose the novel general concept of pairwise program reduction for program reduction and failure diagnosis.
it complements classical program reduction approaches by identifying critical bug triggering differences.
we propose the first algorithm for pairwise program reduction including three effective and general reducers to reduce both differences and commonalities between a pair of programs.
to comprehensively evaluate the performance of ppr we designed benchmarks ranging from small programs via simple mutations to large programs via complex fuzzing techniques.
to enable future research on this line of research we released the source code of ppr and the benchmarks publicly .
2a miscompilation is a category of compiler bugs where the buggy compiler silently compiles a well defined program into a binary that has unexpected semantics.ppr pairwise program reduction esec fse december san francisco ca usa include stdint.h 2uint8 t g 3int16 t div int16 t a int16 t b return b ?
a b 6int64 t id return 7int8 t fn a int32 t d uint8 t b for uint16 t c id b g if div c div b g else d a b g 21int main fn a by c reduce.
include stdint.h 2uint8 t g 3int16 t div int16 t a int16 t b return b ?
a a b 6int64 t id a return a 7int8 t fn a uint8 t b for uint16 t c 65532ul id b g if div c div 0x2faal 65535ul a 1l 21int main fn b seed byppr.
include stdint.h 2uint8 t g 3int16 t div int16 t a int16 t b return b ?
a a b 6int64 t id a return a 7int8 t fn a uint8 t b for uint16 t c 65532ul id b g if div c div 0x2faal 65535ul b g else a 1l b g 21int main fn c variant byppr....... int8 t fn ...... ...... int main ...... fn d seed by dd.
...... int8 t fn ...... ...... int main ...... fn e variant by dd.
figure reduction results by c reduce a ppr b and c and dd d and e for llvm .
the differences between the seed and variant are highlighted in blue .
all programs are slightly adjusted and aligned for clarity.
we simplify results from dd for illustration due to the large size of the original version.
motivation we use llvm as a motivating example to illustrate the benefits of using ppr for analyzing compiler bugs compared to classical program reduction and the program isolation technique dd.
llvm is a bug in llvm .
.
.
the original bug triggering variant contains tokens in total and provokes an infinite loop when being compiled by clang .
.
with the o2flag.
as explained in the bug report the optimization pass foldopintophi folds certain instructions into phi nodes for intermediate analysis in ssa form .
when processing a variable in a basic block it tries to invoke itself if the next reachable block has the same variable.
when foldopintophi encounters two mutually reachable basic blocks modifying the same variable like b g on line and line in figure 1c an infinite recursion occurs.
classical program reduction c reduce .
in this example the variant is reduced to tokens by c reduce shown in figure 1a.
while this outcome seems favorable at first glance with over of the code removed there still remain slightly more than a hundred tokens.
consequently it becomes challenging for developers to determine which part of the code is more suspicious than the rest.
pairwise program reduction.
by contrast ppr not only minimizes bug triggering program in figure 1c but also provides its corresponding minimized seed for comparison in figure 1b as well as a minimal set of changes.
in this case reduced seed variant has tokens comparable to the result by c reduce w.r.t.
size.
more importantly the reduced differences reveal that the change of control flow and multiple assignments to the same variable are relevant to the bug as highlighted in figure 1c.
ppr detects all critical changes successfully offering developers with a better starting point for fault diagnosis.
dd.
results from dd in figure 1d and in figure 1e achieve smaller difference size than ppr the only difference is deleting froma function call fn in the variant .
however such a difference only indicates that the bug is caused by calling fn which provides far less information than ppr.
moreover reduced seed and variant given by dd tokens are several orders larger than those from ppr tokens the final result still has tens of thousands of tokens and thus are difficult to be used for debugging.
this example demonstrates the benefits of ppr in both bugtriggering program reduction and critical changes isolation compared to c reduce ppr achieves a similar reduction size but provides extra information to ease debugging compared to dd ppr finds out small program pairs with differences closer to reveal the essence of the bug.
.
practicality besides the motivating example several facts on compiler testing inspire our work and make the concept of ppr practical and general.
first in mutation based testing the seed from which a bug triggering variant is derived is always available.
regardless how drastic the seed is mutated there are still unchanged code snippets making differencing algorithms applicable.
second many changes by mutation are superfluous and irrelevant to the bug and removing them has no impact on reproducing the bug.
third the generated variants are usually syntactically valid and thus can be reduced efficiently and effectively with tree based program reduction algorithms .
spirv fuzz used at google is another strong demonstration of the practicality and significance of minimizing failure inducing changes for debugging language implementations.
different from spirv fuzz ppr generalizes to any programming language and is fuzzer independent it can be generalized to new languages and does not require a customized mutation based testing technique to work.
moreover spirv fuzz cannot reduce the commonality andesec fse december san francisco ca usa mengxiao zhang zhenyang xu yongqiang tian yu jiang and chengnian sun can only minimize the sequence of mutations applied on the seed program which hinders its usefulness if the seed is large.
in contrast ppr can minimize the seed the variant and the differences between the seed and variant in a single reduction process.
preliminaries and formalization this section introduces necessary background and formalizes the problem of pairwise program reduction.
.
classical program reduction given a program pthat has a property let pdenote the universe of all possible programs that are derivable from pby deleting certain tokens p pas we can delete zero tokens from p .
let b true false then the property of pcan be defined as a predicate p b for any program p p e.g.
p p p true ifp exhibits the property otherwise p false .
as formally defined by perses the number of tokens in a program pis denoted as p .
the goal of program reduction is to find a program pthat satisfies the property and has the fewest tokens in p arg min p p p p p p x p. x p x program reduction is an np complete problem and all existing algorithms are based on heuristics.
typical such algorithms are ddmin.
ddmin takes as input a list of elements and a property that the list has and returns a new list by removing the elements that are irrelevant to from the input list.
when applying ddmin to reduce a program with we can convert the program into a list of lines tokens or characters and let ddmin to remove the irrelevant elements.
however ddmin does not consider the syntactical constraints of programs during reduction making it less effective and less efficient than tree based program reduction.
tree based program reduction.
different from ddmin syntaxguided program reduction converts the program under reduction into a parse tree w.r.t.
the formal syntax of the program.
such algorithms traverse the tree in a certain order and repeatedly apply ddmin to reduce a list of tree nodes each time.
due to this tree representation of programs tree based program reduction algorithms usually run faster than ddmin and yield smaller results.
c reduce.
c reduce is a widely used reduction tool customized for c c programs.
it translates a program into ast with clang and performs a series of source to source transformation via libtooling to simplify the bug triggering program.
c reduce can also reduce other programming languages but many transformations are well crafted only for c c .
.
differences between a pair of programs program differencing algorithms compute the differences between a pair of programs.
based on how programs are represented for differencing there are mainly two types of differencing algorithms list based and tree based .
list based differencing.
a list based differencing algorithm denoted as l l1 l2 takes as input two lists and outputs a list of edit operations i.e.
insert delete and replace to edit and transforml1tol2.
for instance given two programs l1 l2 l l1 l2 deduces and returns a list of the following four operations delete unsigned insert after b insert cafter b and replace 1with .
tree based differencing.
a tree based differencing algorithm denoted as t t1 t2 infers the differences between two programs by representing programs as trees.
it takes as input two trees t1and t2 and returns a list of operations that converts t1tot2.
for example given two programs in figure edit operation list delete decl insert stmt replace bwith aonexpr1 is returned.
more details can be found in .
patching.
patching is an important step to convert a program to another based on differences computed by aforementioned algorithms.
given d l l1 l2 patching is the inverse function converting l1tol2with the difference d i.e.
patch l1 d l2.
this algorithm is applicable in two scenarios.
first given d a reduced version of d patch l1 d returns l closer to l1than the original l2.
second if l 1is a subset of l1 i.e.
certain tokens are deleted patch l d returns l 2with those tokens removed and differences applied.
the patching process for tree based differences is similar.
.
pairwise program reduction pairwise program reduction is akin to the classical program reduction but considering a pair of programs.
let psandpvbe the original seed and variant programs that exhibits property sand vseparately ps andpv be the universe of all possible programs derivable from ps and pv by deleting certain tokens.
let dbe the difference between seed and variant programs dbe the search space over d i.e.
dincludes all possible differences by removing edit operations from d .
d refers to the number of edit operations ind.
the goal of pairwise program reduction is defined as ppr ps pv ps ps pv pv s ps v pv x pv.
x pv x s.t.
pv patch ps d d arg min d d d pv patch ps d means applying difference d to a program ps to derive a new program pv.
the goal is to minimize both pvand d. given that this is a multi objective optimization problem for clarity we prioritize reducing dtod and then minimize pvwith a minimal d in the definition and implementation.
approach this section describes ppr in detail.
algorithm shows the general workflow of ppr to reduce the seed psand the variant pvw.r.t.
properties sand v. specifically psexhibits a property s e.g.
ps is a well defined program without undefined behaviors and does not trigger a compiler bug.
by contract pv derived from psvia mutation exhibits another property v. for example gcc crashes when compiling pv.
the output of ppr is the minimized p sandp v derived from psandpvrespectively with s p s v p v .ppr pairwise program reduction esec fse december san francisco ca usa int a int b if b print a a p1int a if a a print a b p2translationunit decl initdecl int a decl initdecl int b ifstmt if expr b stmtlist stmt print a c t1 the parse tree of p1.translationunit decl initdecl int a ifstmt if expr a stmtlist stmt a stmt print a d t2 the parse tree of p2.
figure two programs and their tree based difference.
insert delete and replace from seed and variant are highlighted in blue redtoyellow separately while the common part is black.
algorithm ppr ps pv s v input ps the seed that does not trigger the bug.
input pv the bug triggering variant derived from ps.
input s p b the property to be preserved by ps.
input v p b the property to be preserved by pv.
output p s p v the minimized seed and variant with minimal differences.
1repeat monotonically minimize the size of ps pvand the differences between the two programs.
2p s ps p v pv minimize tree based differences.
ps pv mintdiff ps pv s v minimize list based differences.
4pv minldiff ps pv v minimize the commonality between psandpv.
ps pv mincommonality ps pv s v 6until ps p s and pv p v 7return p s p v ppr iteratively and monotonically reduces psandpvuntil neither of them can be further reduced.
in each iteration on line line ppr reduces the programs in the following three steps ppr calls the reducer mintdiff i.e.
algorithm on line to minimize the tree based differences between psandpv.
ppr calls the reducer minldiff i.e.
algorithm on line to minimize the list based differences between psandpv.
ppr calls the reducer mincommonality i.e.
algorithm on line to reduce the common parts of psandpv.
the first two steps are to minimize the differences between psand pvso that the bug irrelevant differences can be removed the third one is to remove the bug irrelevant program elements on ps and remove the corresponding part on pvindirectly.
a single iteration of calling the three reducers usually cannot reduce the programs to the minimality since the deletion of some elements may create new reduction opportunities to remove other elements.
for example if all the invocations of a function have been deleted then it is possible to delete the definition of this function in other words the definition of a function can be deleted only if there is no call to the function.
since all the three reducers monotonically decrease the size of programs the loop is guaranteed to terminate when neither psnorpvcan be further reduced.
to exemplify how the three reducers work in figure we use code snippets in gcc to demonstrate how ppr reducesthem step by step.
this crash bug in gcc .
.
is discovered with a mutation based testing technique .
as shown in figure 3a the original changes include tokens but after applying ppr the deletion of break statement is proved to be the only critical change highly relevant to the bug as highlighted in figure 3d.
algorithm mintdiff ps pv s v input ps the seed program.
input pv the variant program.
input s p b the property to be preserved by ps.
input v p b the property to be preserved by pv.
output p s p v the seed and variant program with minimized tree based differences.
1d t ps pv 2p s ps p v pv 3foreach edit ddo switch editdo case delete a subtreetfrompsdo minimize t on ps as t is unique on ps.
p s minsubtree p s s t case insert a subtreettopvdo minimize t on pv as t is unique on pv.
p v minsubtree p v v t case replace a subtreetwith another subtree sdo undo the replacement on pv.
p v p v s t if v p v thenp v p v 12return p s p v .
minimizing tree based differences algorithm minimizes the tree based differences between psand pv.
in this process ppr first deduces the sequence of tree based edit operations dfrom pstopvon line and then reduces the subtree involved in each edit operation in don line line .
ppr processes edit operations differently based on their types.
line delete a subtree tfrom ps ppr attempts to remove nodes of tfrom psby calling minsubtree p s s t so that the unique subtrees from pscan be minimized.
in figure 3b e andf g onpsare removed by this step.
line insert a subtree ttopv similarly ppr attempts to remove subtrees of tfrom pvto minimize the unique subtree of pv.
in figure 3b while b onpvis removed by this step.esec fse december san francisco ca usa mengxiao zhang zhenyang xu yongqiang tian yu jiang and chengnian sun seed.c 2for a a !
a int32 t b 7l int32 t c 0x2474afadl int32 t d 4l e f g if b break variant.c for a a !
a int32 t b 7l int32 t c 0x2474afadl int32 t d 4l while b if b a original programs.
1for a a !
a int32 t b 7l int32 t c 0x2474afadl int32 t d 4l e f g if b break for a a !
a int32 t b 7l int32 t c 0x2474afadl int32 t d 4l while b if b b after calling mintdiff .
1for a a !
a int32 t b 7l int32 t c 0x2474afadl int32 t d 4l e f g if b break for a a !
a int32 t b 7l int32 t c 0x2474afadl int32 t d 4l while b if b c after calling minldiff .
1for a a !
a int32 t b 7l int32 t c 0x2474afadl int32 t d 4l e f g if b break for a a !
a int32 t b 7l int32 t c 0x2474afadl int32 t d 4l while b if b d after calling mincommonality .
figure the process of ppr reduces a code snippet of gcc66691 step by step.
deletion and insertion of tokens are highlighted in redand blue separately.
tokens overlaid by gray are those deleted by ppr.
line replace a subtree twith sinpv ppr attempts to undo the replacement by replacing the subtree swith the subtree t. minimizing a subtree.
given a program p the property ofp and a subtree ofp the function minsubtree removes the descendant nodes of subtree that are irrelevant to .minsubtree is similar to existing tree based reduction techniques such as hdd and perses .
the major difference is that both hdd and perses start the reduction process from the root node of p whereas minsubtree starts the reduction process from the root node of the given subtree .minsubtree can be implemented by extending hdd or perses to start reduction from a specified tree node.
.
minimizing list based differences algorithm describes how ppr minimizes list difference between psandpv.
at first the list based difference dare inferred on line .
then ppr uses ddmin to minimize d. note that we simplify this step by enumerating all possible deletions by ddmin for illustration purpose on line .
ddmin splits the list into partitions tries deleting each partition or its complement and splits each partition into halves for finer grained deletion.
the actual procedure is that every time ddmin removes some elements patch is applied to verify whether the remaining differences still generate bug triggering variant and thus dynamically determine the next step.
although both tree based and list based difference reduction aim at minimizing difference between psandpv they complement each other.
the former is more efficient by leveraging the formal syntax the latter adopts ddmin which is less effective but simpler and more general.
in the example pairs of redundant curly brackets and inserted to pvare removed figure 3c .
such changes are neglected by tree differencing algorithms due to the limitation of the used tree differencing algorithms.
algorithm minldiff ps pv v input ps the seed program.
input pv the variant program.
input v p b the property to be preserved by pv.
output p v v p v a variant with minimized difference from ps.
1d l ps pv 2p v pv diff candidates sorted by size in ascending order.
3candidates all possible deletions by ddmin 4foreachd candidates do 5p v patch ps d if v p v then break 8returnp v .
minimizing commonality of psand pv algorithm shows how ppr reduces the common part of psandpv synchronously.
the intuition is to preserve list based difference d reduce pstentatively and patch dto each reduced seed candidate to derive the corresponding reduced pvcandidate and check them against property separately.
the difference d i.e.
the edit sequence from pstopv is deduced and kept on line .
the root node of psis added to worklist on line and then is traversed and reduced on line line .
ppr uses workflow of tree based program reduction algorithm to search for smaller candidates of p son line .
similar to algorithm we enumerate all possible candidates for simplification.
each time a p sis generated ppr patches the precomputed donto it to derive a corresponding p von line .
if both psandpvsatisfy the property ppr updates the best results obtains the remaining components rest and pushes them into worklist for future traversal.
in figure 3d the common part is reduced including bug irrelevant statement if b and unused variables b c and d.ppr pairwise program reduction esec fse december san francisco ca usa algorithm mincommonality ps pv s v input ps the seed program must be parsable.
input pv the variant program.
input s p b the property to be preserved by ps.
input v p b the property to be preserved by pv.
output p s p v the directly minimized seed and variant.
1d t ps pv 2p s ps p v pv 3worklist root node of ps 4while worklist 0do 5t pop worklist seed candidates sorted by size in ascending order.
candidates all possible deletions on t foreach p s rest candidates do 8p v patch p s d if s p s v p v then p s p s p v p v push worklist rest break 13return p s p v evaluation in this section we evaluate the effectiveness and efficiency of ppr.
specifically we investigated the following research questions.
rq1 effectiveness of ppr on reduction and isolation.
rq2 efficiency of ppr on reduction and isolation.
rq3 effectiveness of each individual reducer in ppr.
rq4 the impact of the order of reducers in ppr.
.
experimental setup we implement ppr based on top of perses .
all experiments are conducted on an ubuntu .
server with intel xeon gold cpu .00ghz and 384gb ram.
benchmark ppr.since there is no existing benchmark suite for pairwise program reduction we constructed benchmark ppr to answer the above questions.
we collected pairs of seed and variant programs from previous mutation based c compiler testing studies .
according to these studies these seeds are generated by csmith and the variants were derived from the seed programs using a sequence of mutations.
table shows the information of benchmark ppr.
the columns bug id shows the bugs that are triggered by the variant programs.
the columns original under seed size variant size anddifference size show the original size of seed variant and their difference.
these variants triggered different types of bugs in gcc or llvm including crash hang and miscompilation.
moreover cases in this benchmark suite involve diverse mutations.
for instance llvm25900 and gcc were generated by merely inserting code snippets gcc was derived via deletion.
cases like llvm22382 involves insertion deletion and modification.
additionally the similarity between a seed and a program varies.
in gcc only of the program is mutated while in llvm the final variant only shares in common with the seed.
baseline.
we use dd as the evaluation baseline since it is the only existing tool having the same target as ppr.
spirv fuzz is notsuitable for this benchmark suite as it is customized for a low level language and it only reduces the difference.
although reducing a pair of programs constraint by differences in between is harder than reducing a single one we still compare ppr with state of the art classical program reduction algorithms i.e.
perses and c reduce to demonstrate ppr s performance is still acceptable.
.
rq1.
effectiveness of ppr we measure the effectiveness of the ppr using the reduction rate r i.e.
the ratio of tokens in seed variant difference that are removed in the reduction.
a higher rfor seed variant and difference programs is preferred as it indicates more bug irrelevant elements are removed to facilitate debugging process.
columns ppr of table show the effectiveness of ppr on benchmark ppr.
on average the size of seed and variant is reduced from tokens to tokens and from tokens to tokens respectively.
meanwhile the average difference between seed and variant is reduced from tokens to only tokens.
the corresponding reduction rates rofppr for seeds variants and differences are .
.
and .
respectively.
these results demonstrate that ppr are effectively in reducing the seed variant and their differences.
to show the effectiveness of the main loop in algorithm we also measure ppr with only single iteration.
as shown in columns pprs reducing only one iteration produces larger programs and differences compared to multiple iterations .
we also compare ppr with classical program reduction tools i.e.
perses and c reduce.
the size of reduced variant by ppr is tokens on average varying from tokens to tokens while the average size of variant by perses and c reduce are and respectively.
in and out of cases ppr even generates smaller programs than perses and c reduce respectively.
this shows that the sizes of variant reduced by ppr are comparable with the ones by classical program reduction such as perses and c reduce.
in other words ppr does not sacrifice the reduction effectiveness on the bug triggering programs i.e.
variant programs when effectively reducing the difference between seed and variant programs.
columns ddof table show the effectiveness of dd.
on average dd only achieves .
reduction rate on variant programs.
for seed and difference dd cannot produce acceptable results and reduction rate is not applicable.
our explanation is that dd performs binary search to delete certain consecutive tokens from the variant to derive a subset seed that does not trigger the bug i.e.
final seed and differences do not stem from the original ones.
besides programs with highly nested structure in benchmark ppr cannot be effectively handled by dd.
specifically in out of cases the difference between the seed and variant programs are reduced to a few tokens but the size of seed programs are still more than hundreds of thousands of tokens making it impossible to comprehend and debug.
for the other cases the seed programs are still zero token.
in other words by removing consecutive tokens from the variant dd cannot always find a syntactically valid seed that does not trigger the bug.
in summary the usefulness of dd in pairwise program reduction is limited since a small difference provides insights only if the whole program is small and comprehensible .
by contrast ppresec fse december san francisco ca usa mengxiao zhang zhenyang xu yongqiang tian yu jiang and chengnian sun table the effectiveness of ppr pprs dd perses and c reduce on benchmark ppr including final size and reduction rate.
the cells with under dd of seed size indicate that the reductions did not finish in 24h and thus failed to find out a seed.
in the last line reduction rate r does not apply to seed and difference under dd as they are all derived from variant and thus there is no original version to compare to.
seed size token variant size token difference size token bug idoriginal ppr pprs dd original ppr pprs dd perses c reduce original ppr pprs dd llvm llvm llvm llvm llvm llvm llvm llvm llvm llvm llvm gcc gcc gcc gcc gcc gcc gcc gcc gcc mean mean r .
.
.
.
.
.
.
.
.
can effectively reduce the seed and variant programs and minimize the difference between them.
rq1 ppr generates programs several orders of magnitude smaller than dd and has a comparable performance to the state of the art tools i.e.
perses and c reduce in terms of the sizes of the reduced variants.
.
rq2.
efficiency of ppr to answer this research question we measured the time of ppr in reduction and isolation on benchmark ppr as shown in table .
to provide developers in time results short reduction time is preferred.
in all cases ppr are able to finish the reduction and isolation in hours ranging from .
hour to .
hours.
on average it takes ppr .
hours to finish the reduction.
by contrast the execution times from dd are particularly polarized.
some cases are finished in a few minutes while in five cases dd cannot finish the reduction in hours.
this is because removing consecutive tokens blindly from the variant to search for a seed is risky it may happen to find an appropriate seed and terminate quickly result in tiny differences but huge seed programs it may also unluckily fail to find any syntactically valid seed in reasonable time.
more importantly no matter fast or slow dd always generates unacceptably large programs making it infeasible to debug with.
we also measured to what extent do ppr brings time overhead than classical program reduction.
table shows that perses and c reduce averagely take .
hours and .
hours in classical program reduction which is shorter than ppr.
this is expected since perses and c reduce only reduce the variant while ppr additionally reduces the seed and the difference in between.
we believe this trade off is worthwhile since the extra minimum sized differencestable the execution time of ppr dd perses and c reduce on benchmark ppr.
time hour bug idppr dd perses c reduce llvm .
.
.75x .
.51x .
.50x llvm .
.
.44x .
.30x .
.78x llvm .
.
.49x .
.15x .
.38x llvm .
.
.01x .
.64x .
.43x llvm .
.
.11x .
.39x .
.68x llvm .
.
.45x .
.24x .
.39x llvm .
.
.00x .
.03x .
.07x llvm .
.
.47x .
.42x .
.07x llvm .
.
.06x .
.18x .
.41x llvm .
.
.36x .
.16x .
.20x llvm .
.
.42x .
.16x .
.17x gcc .
.
.60x .
.61x .
.13x gcc .
.
.04x .
.44x .
.73x gcc .
.
.69x .
.58x .
.49x gcc .
.
.06x .
.37x .
.06x gcc .
.
.08x .
.23x .
.60x gcc .
.
.31x .
.18x .
.84x gcc .
.
.69x .
.95x .
.08x gcc .
.
.12x .
.67x .
.74x gcc .
.
.38x .
.91x .
.33x mean .
.
.68x .
.46x .
.10x provided by ppr can further ease the debugging process.
in fact ppr is even faster than c reduce in out of cases.
rq2 on average ppr takes .
hours in reduction which is acceptable when compared with those traditional program reduction algorithms.ppr pairwise program reduction esec fse december san francisco ca usa .
rq3.
effectiveness of each reducer in ppr to investigate the efficacy of each reducer we conducted an ablation study on ppr.
specifically we created three alternatives of ppr i.e.
pprtd pprld and pprco .
compared to ppr each of them disables one of the reducers in algorithm i.e.
mintdiff td minldiff ld and mincommonality co respectively.
we measured and compared their effectiveness with ppr.
table results when disabling a reducer or changing the order of reducers.
for each scenario we list the average final size and reduction rate.
the cells with indicates the reduction did not finish in 24h.
seed variant difference original .
.
.
ppr .
.
.
.
.
.
pprtd pprld .
.
.
.
.
.
pprco .
.
.
.
.
.
co td ld .
.
.
.
.
.
ld td co table shows the results.
without mintdiff pprtd fails to terminate in a reasonable time.
this is because the difference is large tokens and complex in most of the cases reducing only by ddmin is ineffective and slow.
therefore it is critical to reduce difference with the guidance of syntax in mintdiff .
the size of the reduced difference of pprld is tokens larger than ppr on average which demonstrates the fact that minldiff serves as a complement of mintdiff to further reduce the difference.
without mincommonality the reduction rates of seed and variant drop from .
.
to .
.
respectively.
the explanation to this change is that difference reducers are only responsible for reducing difference only mincommonality is capable of removing unnecessary common code shared by seed and variant.
rq3 all reducers in ppr contribute to effectiveness of ppr especially the mintdiff andmincommonality .
.
rq4.
the impact of the order of reducers to understand how the order of reducers impacts the reduction we experimented with two alternative orders reducing the commonality before reducing the difference i.e.
mincommonality mintdiff minldiff co td ld and swapping the order of tree based and list based difference reducition i.e.
minldiff mintdiff mincommonality ld td co .
ifmincommonality is invoked ahead of all difference reducers the average size of final seed and variant are .
and .
which are .06x and .13x larger than those from the original order shown in table .
the difference size is .
which becomes 16x larger than the original and is almost half of the final seed variant size on average.
further investigation explains such change if the common code snippets instead of the difference are reduced first then the remaining difference will take a larger proportion in the program making tree differencing algorithms harder to match thecommon part.
such impact propagates through iterations and finally produces a pair of diverged program i.e.
seed and variant look very different from each other.
ifminldiff is invoked before mintdiff ppr fails to terminate in reasonable time.
such result is in line with the behavior when mintdiff is disabled and demonstrates the fact that syntax guided reduction is critical in reducing large difference.
rq4 empirically difference should be reduced before reducing the common parts.
as for the order of difference reducers the tree based reducer is more effective and efficient and thus should be given a higher priority.
discussion .
usefulness of ppr in fuzzer design besides providing insights to compiler developers when debugging ppr also offers useful feedback to those who are designing fuzzing techniques.
gcc is the example showcased in the paper of hermes a compiler fuzzing tool for illustrating the effect of their proposed mutations.
the code inserted by hermes is highlighted in blue.
to identify this bug triggering part the authors of hermes reduced the variant with c reduce and then manually searched for patterns from the original mutation set which involves code blocks tokens in total.
our algorithm in contrast automates the procedure finishes it in .
hour and presents the same minimized bug triggering changes shown in figure .
seed.c 2for b b b for d d if f break variant.c for b b b for d d if g for d d if f break if f break figure final result of gcc code snippet .
code highlighted in blue is the final differences from seed to variant.
.
generality on other languages ppr can be parameterized towards any language.
to demonstrate ppr s effectiveness on language other than c we further conducted experiments using two prevalent programming languages rust and javascript.
to build a benchmark suite similar to benchmark ppr we applied random node level deletion insertion and replacement on a pool of seed programs to fuzz rustc .
.
and jerryscript2.
.
separately and collected bug triggering programs and their corresponding seed programs for each language.
then we run ppr and dd on this benchmark suite.
as shown in table ppr effectively reduces the seed and variant programs by more than .
for variants ppr achieves .
and .
reduction rates on rust and javascript respectively higher than .
and .
from dd.
for differences ppr reaches tokens on average on both rust and javascript far lower than 57esec fse december san francisco ca usa mengxiao zhang zhenyang xu yongqiang tian yu jiang and chengnian sun table results of ppr and dd on rust and javascript.
seed size variant size difference size bug idoriginal ppr dd original ppr dd original ppr dd rustc rustc rustc rustc rustc rustc rustc rustc rustc mean mean r .
.
.
.
jerry jerry jerry jerry jerry jerry jerry jerry jerry mean mean r .
.
.
.
and tokens from dd.
moreover for all cases in rust dd fails to find out a program for seed.
our explanation is that rust has a strict syntactical or semantical rule for program so it is not likely to find a valid subset of the variant without the guidance of syntax.
.
threats to validity the threat to internal validity mainly lies in the correctness of the implementation of ppr.
to mitigate this authors have carefully reviewed the implementation and tested it on various test cases.
the generality of our approach and results can be a threat to external validity.
to mitigate this we have evaluated ppr on pairs of c programs which reflect diversity in compilers bug types mutation strategies and mutation degrees.
additionally we evaluated ppr on another two languages.
the results demonstrated the effectiveness and generality of ppr on diverse programs.
related work we discuss three lines of related work.
test input minimization and generalization.
delta debugging is the foundational technique for systematically minimizing bug triggering inputs and changes.
hierarchical delta debugging further refines this approach by applying ddmin iteratively on different levels of a program s parse tree from top to bottom.
perses enhances reduction efficiency by normalizing grammars and using transformed grammars to guide the reduction process resulting in more effective reduction compared to hdd.
vulcan further improves the performance by introducing aggressive program transformations.
specific languages also have tailored reduction tools c reduce designed for c c programs while j reduce focuses on java bytecode .
ddset introduces automated generalization abstracting concrete programs into a mixture of terminal and abstract symbols to capture failureinducing patterns.
smartcheck and extrapolate specialize in generalizing haskell programs.
all the work above mainly focus on reducing or generalizing single failure inducing inputs and can be classified as classical programreduction algorithms.
by contrast pairwise program reduction reduces both failure inducing input and failure inducing changes simultaneously in which way we believe can complement classical program reduction on compiler debugging.
failure inducing change isolation.
delta debugging sparked a range of related researches in the realm of isolating failure inducing changes.
crisp assists java developers in locating such changes by enabling iterative selection application and un of affecting changes to pinpoint failure inducing ones.
autoflow employs static and dynamic analysis for automated isolation of failure inducing changes.
donaldson et al.
introduced spirv fuzz an effective reduction and deduplication approach for compiler testing capable of reducing failure inducing transformation sequences to smaller ones that still trigger failures.
unique in its approach ppr not only isolates failure inducing changes but also minimizes commonalities between two programs.
slicing based fault localization .
technique sharing similarity with ppr is dual slicing a slicing based approach to locate the source of errors in software.
by comparing execution traces of programs of different versions dual slicing techniques can identify the differences and localize the root cause of bugs or regression faults on a program e.g.
wang et al.
studies typical programs such as grep and coreutils.
however ppr differs from program slicing w.r.t.
the study subjects as it focuses on programs as the input of a compiler interpreter instead of programs on their own.
moreover ppr performs both reduction and isolation on a pair of program inputs while dual slicing only isolates the root cause of errors in the program.
unlike dual slicing which requires white box techniques for execution traces program reduction methods like ppr are black box approaches suitable for bugs within the compilers rather than in program inputs.
conclusion in this paper we propose pairwise program reduction ppr a novel perspective to complement classical program reduction techniques.
unlike perses and c reduce ppr takes as input a pair of programs.
it reduces not only the seed and variant programs but also the differences between them.
to evaluate ppr we construct benchmark ppr containing programs that trigger bugs in gcc and llvm.
the experiment conducted with benchmark ppr shows that final programs from ppr are several orders of magnitude smaller than those from dd and even comparable to classical program reduction w.r.t.
size.
ppr provides more insightful difference than dd for both compiler developers and fuzzing designers.
finally evaluation on rust and javascript demonstrates ppr s generality on other languages.