discovering repetitive code changes in python ml systems malinda dilhara malinda.malwala colorado.edu university of colorado boulder usaameya ketkar ketkara uber.com uber technologies inc. usa nikhith sannidhi nikhith.sannidhi colorado.edu university of colorado boulder usadanny dig danny.dig colorado.edu university of colorado boulder usa abstract overtheyears researcherscapitalizedontherepetitivenessofsoftware changes to automate many software evolution tasks.
despite theextraordinary riseinpopularityof python basedmlsystems theydonotbenefitfromtheseadvances.withoutknowingwhat aretherepetitivechangesthatmldevelopersmake researchers tool and library designers miss opportunities for automation and ml developers fail to learn and use best coding practices.
tofilltheknowledgegapandadvancethescienceandtooling in ml software evolution we conducted the first and most finegrained study on code change patterns in a diverse corpus of top rated ml systems comprising million sloc.
to conduct thisstudywereuse adapt andimproveuponthestate of the art repetitivechangeminingtechniques.ournoveltool r cpatminer minesover 4mcommitsand constructs350kfine grainedchange graphsanddetects28kchangepatterns.usingthematicanalysis weidentified22patterngroupsandwereveal4majortrendsofhow ml developers change their code.
we surveyed ml developers to furthershed light onthese patternsand their applications and wereceiveda15 responserate.wepresentactionable empiricallyjustified implications for four audiences i researchers ii tool builders iii mllibraryvendors and iv developersandeducators.
ccs concepts softwareanditsengineering softwaremaintenancetools computing methodologies machine learning.
keywords refactoring repetition code changes machine learning python acm reference format malinda dilhara ameya ketkar nikhith sannidhi and danny dig.
.
discovering repetitive code changes in python ml systems.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
.
ameya ketkar contributed this work as a research assistant at oregon state university.
this work is licensed under a creative commons attribution international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
introduction many software changes are repetitive by nature thus forming change patterns.
like in traditional software systems machinelearning ml developersperformrepetitivecodechanges too.
for example listing shows a common change where ml developers replaced a forloop that sums the list elements with np.sum ahighlyoptimizeddomain specificabstractionprovided bythelibrary numpy .sincethischangeinvolvesprogramming idioms at the sub method level it is fine grained.
if this code change is repeated at multiple locations or in multiple commits it is afine grained code change pattern.
listing commit c8b28432 in github repositoryniftk niftynet replace forloop with numpy sum for elem in elements result elem result np.sum elements overtheyears researchersinthetraditionalsoftwaresystems have provided many applications that rely upon the repetitiveness of changes code completion in the ides automatedprogramrepair apirecommendation type migration librarymigration coderefactoring fine grainedunderstandingofsoftwareevolution .unfortunately thesearemostlyavailableonly for java and do not support python and ml systems.
researchers observed that python dominates the ml ecosystem in both the company driven and the community driven ml software systems yet the tooling is significantly be hind .
in order to advance the science and tooling for ml code development in python we need to understand how developers evolve and maintain ml systems.
previous researchers have focused on high level software evolution tasks like identifying ml bugs updatingmllibraries refactoringandtechnical debt of ml systems managing version control systems for data and testing .
however there is a lack of understandingoftherepetitivefine grainedcodechangepatternsthat ml developers laboriously perform.
what are fine grained changes performedinmlsystems?whichonesareml specific?whatkinds of automation do ml developers need?
withoutanswerstosuchquestions researchersmissopportunities to improve the state of the art in automation for softwareevolution in ml systems tool builders do not invest resources where automation is most needed language and library designers ieee acm 44th international conference on software engineering icse icse may pittsburgh pa usa malinda dilhara ameya ketkar nikhith sannidhi and danny dig cannotmakeinformeddecisionswhenintroducingnewconstructs and ml developers fail to learn and use best practices.
inthispaper weconductthefirstlarge scalestudyanddiscover repetitive change patterns in python based ml systems.
we employ both quantitative miningrepositories and thematic analysis and qualitative methods surveys to answer the research questions.
blending these methods has the advantage of the results beingtriangulated.thequantitativemethodshelpusdiscover what fine grained change patterns ml developers perform.
the qualitativemethodhelpsusanswer whythesechangesareperformed how they are performed and how tool builders can improve ml developer productivity.
for the quantitative analysis we use a large data set of ml projectsfromgithub comprising58millionsourcelinesofcode sloc at the latest revisions .
million mapped code blocks .
million changed files and .
billion changed slocs.
we extracted 308finegrainedcodechangepatternswhere58 ofthemappear in multiple projects.
we applied thematic analysis u p o n 500mostpopularpatternsfromourdataset andcategorizedthem into fine grained change pattern themes that reveal majortrends.
moreover we designed and conducted a survey with mldevelopers inwhichwepresented1 235patternsfortheirfeedback and achieved a response rate.
in the survey of the developersconfirmedtheneedofautomationfor22patterngroups.
among these we discovered four major trends transform to contextmanagers e.g.
disableorenablegradientcalculation swap ml training device convert forloops to domain specific abstraction e.g.
seelisting1 updateapiusage e.g.
migrateto tensorflow.log from log transform matrices and use advanced language features e.g.
transform to listcomprehension .
the mainchallenge inconducting suchlarge scale representative studies is the lack of tools for mining non java repositories.
to overcome this challenge we reuse adapt and extend the vast ecosystemofjavaast levelanalysistools to python.mostofthesetoolsrelyontechniquesthatareconceptually language independent i.e.
they operate on intermediate representation of the code e.g.
ast nodes .
second we observed that of the python ast node kinds identically overlap with those in java e.g.
while statment assignment statement etc.
.moreover another18 ofpythonastnodekindsalsoexistinjavawithsome differences e.g.
python s forloop has multiple loop variables .
only of the python ast node kinds are unique to python e.g.
withstatement generators etc.
.hence oneofourkeyideasis to reuse the java ast level analysis tools to analyse of thepython ast nodes and for the remaining of ast nodes we either modify existing capabilities or add brand new ones.
we first developed a novel technique javafypy to transform pythonasttoaformatthatcanbeprocessedbyjavaast levelmin ingtools.weusedjavafypytoadapttopythonthestate of the art fine grainedchangepatternminingtool cpatminer .cpatminermatcheschangedmethodsandtheirbodystatementsacross the commits and identifies fine grained change patterns.
refactorings such as move rename and extract method re arrange and obfuscatethecodestatements thatarehardtomatchacrosstheedit leading cpatminer to miss multiple occurrences of patterns.
to improvetheaccuracyof cpatminer weintegrateitwiththestateof the art refactoring mining technique refactoringminer that de obfuscates the re arranged code statements.
our novel tool r cpatminer performs refactoring aware fine grained change pattern mining in the commit history of python systems.
our findingsand toolshave actionableimplications for several audiences.
among others they i advance our understanding ofrepetitive changes that the ml developers perform which helps theresearchcommunitytoimprovethescienceandtoolsforml software evolution ii provide a rich infrastructure to automateand significantly extend the scope of existing studies on ml systems iii help tool builders comprehend the ml developers strugglesanddesireforautomation iv providefeedbackto language and api designers when introducing new ml constructs and v assist educators in teaching ml software evolution.
this paper makes the following contributions tothebestofourknowledge weconductedthefirstandthe largeststudyonfine grained28 308codechangepatternsonml systems.
we identified code changes patterns.
we applied thematic analysison most popular patterns and categorized them into fine grained change pattern themes that reveal major trends.
we designed and conducted a surveywith open source ml developers to provide insights about the reasons motivating those changes the current practices of applying those changes and their recommendation for tool builders.
we developed novel tools to collect fine grained change patterns applied in the evolution history of python based ml systems.
we applied these tools on open source projects hosted on github.
we make the collected information and tooling publicly available for reuse so that we enable further research.
we present an empirically justified set ofimplications of our findingsfromtheperspectiveoffouraudiences researchers tool builders language designers and ml developers.
motivating example listing2 specifiesthedevice cpu foroperationsexecutedinthecontextandmovemethod init model toparentclass 1class ferneuralnet def init model self with tf.device cpu b h t q.get shape .as list ... 6class timedelaynn ferneuralnet def init model self b h t q.get shape .as list thecodechangeshowninlisting2specifiesthehardwaredevice using tf.device line for the tensorflow operation in line .tf.device is a context manager from the ml library tensorflow .thisisafine grainedcodechangeandthedeveloperhas interleavedthiswitha pullupmethod refactoringthatpulls init modelfrom timedelaynn into the parent class ferneuralnet .
isspecifyinghardwaredevicefor tensorflow operationsa pattern?howfrequentisthispattern?dodevelopersneedtoolsupport to recommend and automate this code change pattern ?
we consider thisfine grained code change instance a repeated patternif a similar code change was performed in the history of this project or any otherproject.researchershaveproposedadvancedtechniquesto mine such fine grained change patterns from the commit histories .
however these techniques are inapplicable to mine 737discovering repetitive code changes in python ml systems icse may pittsburgh pa usa python codepython parser jython typeaugmenter syntaxtransformer customized eclipsejdt java parserminingalgorithm eclipse jdt java parser design of java ast analysis tools design of javafypyast ast figure1 designofjavafypyandexistingastanalysistools thefine grainedcodechangepatterns showninlisting2because theirtechniquesminecodechangepatternsforjava and they do not account for overlapping refactorings.
researchers have shown that developers often interleave many programming activities such as bug fixes feature additions or other refactoring operations and often these changes overlap as shown in listing .
such overlapping changes and refactorings can easily obfuscate existing fine grained change patternminingtools becausetheydonotaccountforthese changeswhenmatchingcodeacrossthecommit.forexample cpatminer does not match the method body of init model in theclass ferneuralnet lines3 tothebodyof init model intheclass timedelaynn line7 astheyareindifferentlocations anddifferentfiles.thislackof refactoringawareness isaseriouslimitationofexistingpatternminingalgorithmsbecausetheycanmiss severalconcreteinstancesofchangepatternsthatareobfuscated by overlapping refactorings.
re implementing the existing java ast mining tools for python will require a significant amount of development effort.
it is also neither feasible nor sustainable as researchers are continuously implementing new java ast mining tools or improving existing tools.
for this purpose we propose javafypy a technique to adapt existingjavaastminingtoolstopythonthatleveragesthesimilaritybetweenthejavaandpythonabstractsyntaxtrees ast .we use javafypy to adapt the state of the art fine grained change patternminingtool cpatminer topython.tomakecpatminer refactoring aware we adapt the state of the art java refactoring inference tool refactoringminer known as rminer to python and integrate it with cpatminer as r cpatminer.
particularly the code block mapping pairs i.e.
two versions of the same codeblockinamethodbeforeandafterthechange reportedbyrminer are provided as input to cpatminer.
r cpatminer mines change patternsinpythonsoftwaresystemsinarefactoring awaremanner.
technique mostofthecurrentcodechangeminingtools i.e.astminingtools are conceptually language independent because they operate upon theabstractsyntaxtrees ast only.however theirimplementation isboundonlytojava.toovercomethispracticalimplementation limitation we propose a very pragmatic solution javafypy atechnique that transforms the input python program to an astthat can be processed by the mining algorithm of existing java astanalysistools.javafypywillfast trackresearchersandtool buildersbymakingtheast basedminingtoolsimplementedfor javaprogramsapplicableforpythonprograms.thus itwillsave severaldevelopment hours ofworkrequired forre implementing these techniques.
as shown in 1in figure javafypy takes apython code as an input and produces an ast that can be usedin mining algorithms of java ast analysis tools.
to achieve this javafypyfirsttransformsthepythoncodetoastandenrichesthe astbyaugmentingtypeinformation.then the syntaxtransformer mapsthecorrespondingjavaconcretesyntaxtotheastnodes.the javaparser eclipsejdt usesittoproducethefinalast.eclipse jdtisthemostpopularjavaparserusedinastminingresearch tools.therefore weselectedeclipsejdtastheparserthatproducesthefinalast.this enhancedandenriched astcanbeprocessedby theminingalgorithmsofjavaastanalysistools.toolbuildersand researchers can use javafypy and extend their tools for python.
.
python code transformation asshowninfigure2javafypyfirst parsestheinputpythonprogram to an ast.
we define an ast as definition3.
.
ast let t bean ast.t has oneroot.
each node ni thas a parent except the root node .
each node ni t hasasequenceofchildnodes denotedby cni .numberofnodes in the sequence cniis denoted by lengthcni.
each node niis a specific syntax category known as ast node kind kindni assignment statement for statement method invocation ... .
weleveragethesyntacticsimilaritybetweenpythonandjava to adapt the java ast analysis tools to python.
we thoroughly studied the java and python language specifications and mappedthepythonastnodekindstothoseinjavabasedonthe description in the specifications.
definition .
.
mapped ast node let tjbe a java ast and tpbe a python ast.
nj tj np tp.
we state that njandnp are mapped ast node kind if njandnpmaintain a structural similarity.
mapped node of node npis denoted by m np nj.
wefoundthreekindsofmappingsnamely identicalastnode nearly identical ast node andunique ast node .
definition .
.
identical ast node let cnjbe a sequence of childastnodesofaparentjavanode njandcnpbeasequence ofchildastnodes ofapythonnode np.westatethat njandnp are identical ast nodes if i m np isnj and ii ni cnp m np cnj.
identicalastnode definition3.
ofthepython sast node kinds can be identically mapped to a java s ast node.
for example wemappedpython s iftojava sif statement andmapped python s assignto java sassignmentstatement.
definition .
.
nearly identical ast node we state that njand npasnearlyidenticalastnodes if njandnpmeetsconditions i m np isnj and ii ni cnp m ni cnj.
nearly identical ast node definition .
of python s ast node kinds could be partially mapped to those of java.
for instance bothpythonandjavaprovidethe forconstructtoiterate over a collection however unlike java python allows to iterate over multiple variables see the forloop in figure thus ast of python forloop contains additional child ast node kinds.
definition3.
.
uniqueastnode let npbeapythonastnode.
we state that npis unique to python if there is no mapped ast node intj.
i.e.
m np tj .
738icse may pittsburgh pa usa malinda dilhara ameya ketkar nikhith sannidhi and danny dig for x y in iter z x y yield z python astfor statement expression iter blockexpression y expression x assignment statement x x y yield statementvariable declaration int x variable declaration int y for int x int y iter z x y yield z for statement expression iter block assignment statement x x y yield statementcoustomized jdt parser type augmented python ast transformed code figure an example code transformationperformed by javafypy uniqueastnode ofthepythonnodeshadnojavacounterpart.
for instance java does not support listcomprehensions oryieldstatement as shown in figure aswecanobserve javaandpythonsyntaxsignificantlyoverlaps.
asshownin 2infigure1 astminingtoolslikecpatminerand rminerparsetheinputprogramtoeclipsejdtast.toadapttheir tools to python with javafypy tool builders or researchers simply needtomigratetheirjavaparsertoourtechnique javafypy .after that wecansimplyreusetools ast basedminingalgorithmsto analyse72 ofthe identicalastnode kinds andmodifythecurrent implementationtoaccommodatethe18 nearlyidenticalastnode kinds and add brand new capabilities often involving adding new visitors for handling the unique ast node kinds.
after the changes thetoolstakepythoncodeasaninputandinfertheresults thus adapting java ast mining tools to python.
figure shows an example of the code transformation steps shown in figure that javafypy performs automatically.
the python code snippet in figure contains all three ast node kinds identical ast node z x y nearly identical ast node for loop and unique ast node yield z .
thejava parser first constructs the ast of the code snippet then the type augmenter augmentstheastwithtypeinformationbyadding variabledeclaration nodes.
thisstep is importantbecause the java basedast mining tools rely on the syntactic richness that the java language offers.
unlike python java programmers have to explicitly declare the types of variables fields and methods.
to add this syntactic richness to the input program javafypy augments the ast of the input program with type information shown in figure as red nodes .weobtainthetypeinformationfrompytype thestateof the practicetypeinferencetoolforpythondevelopedbygoogle whichiswidelyadoptedbythepythoncommunity.asthelaststep syntax transformer transforms the ast to code and passes it to our customized eclipse jdt parser which we extended to parse nearly identical ast node kinds and unique ast node kinds.
can javafypy effectively transform all identical nearly identical and unique ast node kinds?
we evaluated this empirically with popular python projects including tensorflow pytorch keras nltk scikit learn scipy and numpythat comprise 23k python files and .9m sloc.
we checked whether all ast nodes i.e.
identicalastnodes nearlyidenticalastnodes anduniqueastnodes weresuccessfullymappedandtransformedtotheoutputastof javafypy.
we achieved this by transforming all of the python files intheprojects whichhad12mpythonastnodes.thisconfirms that javafypy can effectively transform any input python program to an eclipse jdt ast format.
.
refactoring aware change pattern mining .
.1adaptingcpatminer .cpatminer isthestate of theart code change pattern mining tool that uses an efficient graphbased representation of code changes to mine previously unknown fine grainedchangesfromgitcommithistory.ititeratesoverchanged methods in each commit and uses eclipse jdt java parser to generate an ast of java source code.
then its mining algorithm builds program dependence graphs for each ast node independentlyandthenmergesthegraphstocreateonebiggraph calledchange graph .
cpatminer builds change graphs for each changed method and it represents the before and after a source code change that can be used to mine code change patterns.
since ofthepythonastnodekindsoverlapidenticallywiththose in java we reused most of the capabilities for building the change graphs.weaddednewcapabilitiesincpatminertocreateprogram dependencegraphsfor uniqueastnodes andmodifiedtheexisting capabilities of nearly identical ast nodes .
overall we extended cpatminerwith2 extracodelinesduetothenewormodified capabilities and reused the rest of the code.
while this ratio might bedifferentwhenadaptingothertools itshowcasesthemeritof javafypy to reuse java ast based mining tools for python.
.
.2introducingrefactoringawareness .asdiscussedinsection cpatminer does not account for the overlapping refactoringsappliedinthecommit.theserefactoringsmovecodeblocks between methods or change the method signature making it hard to match the changed code blocks.
thus missing the opportunities tobuildchangegraphs fortheobfuscatedchanges.toovercomethis we made the cpatminer refactorings aware by integrating it with rminer .
we used javafypy to adapt rminer and use it to detect refactoring kinds that move code blocks.
rminer uses astbasedstatementmatchingalgorithmtomatchclasses methods and statementsinsidemethodbodies thushelpingusmatchmovedcodeblocks.weconsulttheauthorsof rminerandextenditsstatementmatchingalgorithmtoreasonaboutthe uniqueandnearlyidentical astnodekinds.forexample listing3showsavariablerename refactoringinlistcomprehension apython uniqueastnode kind of the project deepmedic detected by python adapted rminer.
listing3 commit8d4be555indeepmedic variablerenameinlistcomprehensiondetectedbypython adaptedrminer indices indices we use python adapted rminer to accurately match the moved codeblocks.weextendedcpatminertobuildchangegraphsfor thecodeblockpairsreportedbyrminer.hence cpatminerno longer misses obfuscated code blocks that contain fine grained changes.wedevelopedthetool r cpatminer toefficientlyand 739discovering repetitive code changes in python ml systems icse may pittsburgh pa usa accurately mines source code change patterns in the version histories of python software systems in a refactoring aware manner.
research methodology weprefixalltheadaptedtoolnameswith pytodisambiguatethe toolnamesfromtheirjavacounterparts.wefirstevaluatetheeffectiveness ofthetools wedeveloped oradapted .
then we useour reliable and validated tools to explore the repetitive code changes appliedinpythonmlsystems.forthispurpose weanswerthree research questions rq1.whatarethefrequentcodechangepatternsinmlcode and whatpatternsneedautomation?
toanswerthisresearchquestion wetriangulatecomplementaryempiricalmethods asshowninfigure .
i we mined repositories using r cpatminer and extracted28 308patterns ii weappliedthematicanalysison2 patterns iii wesenta surveyto650mldeveloperstoseektheir opinion on automating the identified code change patterns.
rq2.howdoestherefactoringawarenessimprovethepatternmining over the baseline cpatminer?
r cpatminer performs refactoring awarechangepatternmining thusimprovingbaselinecpatminer.
compared to cpatminer does r cpatminer extract i more changegraphs?
ii morecodechangepatterns?and iii morecode instances per pattern?
rq3.what is the runtime performance of r cpatminer pycpatminer and pyrminer?
to answer this we compare the execution time of the python adapted tools with their java counterparts.
70lqhu surmhfwvu kdqjh sdwwhuqv xwrpdwlrq vxjjhvwlrqv iru wrro exloghuv 7khpdwlf dqdo vlv kdqjh sdwwhuqv iru wkh vxuyh 2qolqh vxuyh figure3 schematicdiagramoftheresearchmethodologytoanswer rq3 .
subject systems our corpus consists of commits from large mature anddiversemlapplicationsystems comprising58mlinesofsource codeand150kpythonfiles usedbyotherresearchers tounderstandthechallengesofevolvingmlsystems.thiscorpus is showntobeverydiversefromtheperspectiveofpythonfiles loc contributors andcommits.theyvarywidelyintheirdomainand application include a mix of frameworks web utilities databases and robotics software systems that use ml.
further we added lowlevel ml libraries such as scipy spacy and high level ml libraries suchaskeras pytorch caffe nltk andtheanoto our subject systems.
this ensures our dataset is representative and large enough to answer our research questions comprehensively.
.
static analysis of source code history .
.1change pattern identification running r cpatminer on the ml corpus extracted unique code change patterns where58 ofthemhavecodechangeinstancesinmultipleprojects of them have been performed by multiple authors.since the mined patterns are numerous we followed the best practicesfromnegaraetal.
.theyorderedthepatternsalong threedimensions byfrequencyofthepattern f bythesizeofthe pattern s and by f s. since the repetitive changes done by severaldevelopersandprojectsarestable andhaveahigherchance ofbeingautomated wealsoconsideredthenumberofprojectsand authors as extra twodimensions.
then we ordered the mined patterns along all five dimensions.
then two of the authors who have more than three years of professional software development experienceandextensiveexpertiseinsoftwareevolution manually investigated the top patterns for each of the five dimensions and identified meaningful code patterns i.e.
the patterns that can be described as high level program transformations.
twoauthorsofthepapermanuallyanalyzedeachchangepattern to identify the high level programming task performed in thechangepatterns.
followingthebestpracticesguidelinesfrom the literature the authors used negotiated agreement technique toachieveagreement .twoauthorsofthepaperindependentlycodedthechangepatternscarefullyandassignedoneormore descriptivephrases i.e.
codes tothepatterns.bothauthorsconducted the initial meeting after coding around of the data the suggestedminimumsizeis10 .duringthemeeting theauthorscarefullydiscussedthecodingprocessofallthepatterns.also theynegotiatedanydisagreementsbetweentheassignedcodesand the patterns that cannot be described as high level program transformations.
after inter coder agreement was achieved recommendedinter coderagreementlevelrangesfrom70 tomore than in the literature the two authors independently coded the remaining change patterns.
this process identified all thepatternsforwhichthetwoauthorswereabletoagreeuponthe underlyingmeaningofthepattern.afterthecodingfinished the authors held another meeting in order to finalize the codes and extract themes.
themes capture something important about the data inrelationtothemeaningofthepattern.italsorepresentssome levelofpatternedresponseormeaningwithinthedataset .the two authors reviewed the initial themes against the data several timesandrefinedtheirnamesanddefinitionsuntiltheybothagreed that there were no further refinements possible.
we identified four trends themes ofpatternsbasedontheirstructuralsimilarityat the statement and expression level namely i transform to contextmanagers ii convert forloopstodomainspecificabstraction iii update api usage and iv use advanced language features .
.
qualitative study themostreliablewaytounderstandthemotivationsandchallenges associated with repetitive code changes is to ask the developers who performed them.
to achieve this we surveyed developers who performed the identified change patterns.
.
.1contactingthedevelopers wecontactedthedevelopers performingrepetitive codechanges thatwe consideredworthy of furtherinvestigationbysendinganemailtotheaddressesprovidedintheirgithubaccount.thebodyofeachemailmessagewasautomatically generated by the application we developed and included the following information introduction to the research team and the purpose of the study.
a plot of number of repetitive changes done in the project.
740icse may pittsburgh pa usa malinda dilhara ameya ketkar nikhith sannidhi and danny dig alinktothefrequentrepetitivechangesdoneintherespective projectsothatthedevelopercanuseitasaneducationalresource.
the following four questions for the developer q1.whatarethereasonsforperformingthecodechangesabove?
q2.how often do these code changes happen in ml codes?
q3.howoftenhaveyoumanuallyperformedthiskindofchange?
q4.would you like to have this change automated by a tool?
the first question aims at discovering actual motivations behind a code change as expressed by the developers themselves.
the secondquestion focusesonthe frequencyofperforming thecode change on ml codes and it helps to examine the need for mlspecificides tools.the lastthree questionsaim atunderstanding whetherdeveloperstrustandusetoolsupportforperformingthe code changes.
this is important as there is relatively low ide supportforperformingcodechangesinmlcodes .asample email is available on the companion website .
in total we sent emails to developers out of which responded bringingustoa15 responserate.thisissignificantly higherthantheusualresponserateachievedinquestionnaire based software engineering surveys which is around .
results .
repetitive changes in ml systems rq1 .
.
characteristics of patterns mined by r cpatminer.
we executedr cpatmineronourcorpusdescribedinsection4.1containing1.5mchangedsourcecodefiles comprisingofover490m lines of source code.
for these changed files r cpatminer produced349 406changegraphswithatotalof4.7mnodes.thetool extracted unique code change patterns where and ofthemareperformedbymultipleauthorsandinmultipleprojects respectively.figure4showsthe degreeofsharing ofthepatterns amongstdevelopersand projects.weobservedthat ofthedevelopers who performed the code change patterns share of their change patterns with other developers share at least of their patterns with others and share at least of the patterns.moreover oftheprojectsshare100 oftheirpatterns withotherprojects ofthemshareatleast50 oftheirpatterns withothers oftheprojectsshareatleast10 ofthepatterns.
this shows that r cpatminer extracts patterns that are pervasive amongst the developers and projects.
a developers b projects figure degree of sharing of patterns amongst developers and projects .
.
discovering pattern trends.
understanding code change patterns that the ml developers perform is important to advance scienceandtoolinginmlsoftwareevolution.ourthematicanalysis and developer surveys reveal previously unknown repetitive changepatternsgroupswherethedevelopersaskforautomation.amongstthesepatterns weidentifiedfourmajortrendsbasedon their structural similarity i.e.
expression and statement level transform to context managers instances convert forloopstodomainspecificabstraction 239instances update api usage instances use advanced language features instances next wesummarizeandtriangulateresultsobtainedfromsource code mining thematic analysis and developer surveys.
note weusereal worldcodeexamplestodescribefrequentchange patterns.
the examples use identifiers tf np andtorchas aliases of ml libraries tensorflow numpy andpytorch.
due to space limitations we provide few code examples.
our companion website presentsacuratedrepositoryofexemplarsforeachpattern aswell asallthe instances for each pattern.
.
.3trend transform to context managers a python context manager is an abstraction for controlling the life cycle for a code block.
it declares the methods enter initialization and exit finalization which together define the desired runtimeenvironmentfortheexecutionofacodeblock.thecodeblock needstobesurroundedina withstatement thatinvokesthe contextmanager.weobserved1 237changeinstancesbelonging to eight pattern groups p1 p8 in table where developers move code blocks into withstatements and use context managers.
listing commit dfb7520c in pytorch disable gradient input.grad.data.zero with torch.no grad input.grad.zero listing is an example of pattern p2 disable or enable gradient calculation .
the survey respondent s21 said when we do not need gradient computation in a dl network using tensor.backward itisimportanttodisablethegradientcalculationgloballytoreduce memory consumption and increase speed .
the context manager torch.no grad frompytorch createsanexecutionenvironment forthecodeinline3anddisablesthegradientcalculation.likewise thepatterns p2 p8 intable1createnewexecutionenvironments.
listing commit 02ccf29b in tensorflow datasets move context managers that used to read data to withstatement file tf.gfile.gfile label path dataset csv.dictreader file delimiter tie with tf.gfile.gfile label path as file dataset csv.dictreader file delimiter tie we will now explain the most populous pattern group p1 read write traverse data which moves an already existing context managerwithina withstatement seelisting5 .thesurveyrespondent s11 said when we use context managers in withstatement the requiredresourcesareallocatedandreleasedprecisely.
line3inlisting uses the context manager tf.gfile.gfile which handles i o operations.
the developers do not need to handle i o opera tions such as file open initialization and file close finalization when they use the context manager insideawithstatement.
however ifdevelopers use thecontext manager as afunction call see deletedline1in listing5 theyneedtohandlealltheinitialization and finalization logic .
hence if a context manager is used as a functioncall i apimisuses oftenhappen and allocatedresources might not be managed efficiently ii developers need to 741discovering repetitive code changes in python ml systems icse may pittsburgh pa usa table1 triangulatingsourcecodeminingresultswithsurveyresponses 4majortrends thepatterngroupsforeachtrend and whetherthatpatternisspecifictomlcode columnml .columnishowsthenumberofinstancesforeachpattern.columnr shows number of survey respondents.
next columns indicate their responses to survey q2 how often these changes happen inmlcode?
andq3 howoftenhaveyoumanuallyperformedthischange?
withfrequency veryoften vo often o rare r and never n .
q4 would you like to have this change automated by a tool?
response yes no already automated aa .
static analysis survey responses q2 q3 q4 trend ppattern ml1irvoornvoornyesnoaa move to with statement and use contextmanagersp1read write traverse data p2disable or enable gradient calculation check925100 p3swap ml training devices check213100 p4change name and variable scopes in dl networks check106757 p5execute dependencies of a tensorflow graphs check573100 p6temporarily change configurations of libraries p7transform to context managers in pytest p8use context managers to open temporary directories dissolve forloops into domain specific abstractionsp9transform to optimized operations in numpy check17910100 p10transform to operations in listordictionary p11transforming to python built in functions p12transform functions in string p13transform to set operations updateapi usage p14migrating to apis ml libraries check265100 p15transform matrix check82683 p16change data visualization check28250 p17composite ml apis check225100 p18update container p19update type of matrices check164100 use advanced language featuresp20simplify conditional statement p21migrate from dict set list constructors to literals p22transform to python list dict or set comprehension 1ml specific patterns i.e.
patterns related to ml techniques.
more than developers confirmed they happen in ml very often or often update all the initialisation and finalisation code when they update the library versions if the apis have changed .
the respondent s13said ienvisionidesthatautomatemovingcontextmanagers towithstatements.
table tabulates the results for each major trend and pattern group and shows survey responses for each pattern group.
of thesurveyrespondentswhoperformedtrend 1changesconfirmed thattheymoveto withstatementsveryoften vo oroften o .all respondentsperformthecodetransformationmanually and74 of the respondents requested automation in their ides.
.
.4trend convert for loops into domain specific abstraction listing shows one such example where the developer uses np.sumfromnumpy instead of using forloop to compute the sum of elements in a list.
developers often perform this changetoenhancetheperformanceandcodereadability.survey respondents22whoperformedpatternp9said sometimes python forloopisarealperformancekiller.iwantmyidestosuggestthe optimized apis from ml libraries that i can use instead of loops .moreover as alternatives to forloops developers use i list or dictionary operations p10 ii built in python functions p11 iii python string.join p12 and iv set operations union andintersection p13 .pythonisaninterpretedlanguage thus compiler level optimisations do not happen in python.
the respondent s24 said for other programming languages i might expect thecompilertooptimizethistypeofloop soyes iwouldbeinterestedinasuggestionbytheide.
asshownintable1 oftherespondents who performed trend confirmed they do this very often vo or often o in ml code.
all the respondents manually perform the change and of the respondents requested automation support.
.
.5trend update api usage listing shows an example api migration where the developer uses a readily available np.mean instead of computing mean of the list first occ .
survey respondents35said numpyoffersefficientarraysandapisforcomputational operations tools that inspect the code and suggest numpy apis are very much needed.
listing commit 8592777b in inspirehep magpie migrate api to numpy return sum first occ len first occ return np.mean first occ matrix transformations p15 such as transpose broadcast squeeze and unsqueeze are frequent in ml projects.
the respondents31said bugsduetowrongmatrixshapesarehardtodetect andprevalentinmlsystems.iliketohavetoolsthatidentifythese bugsandbroadcastthematricestocorrectshape .
chenetal .
observed developers change the bit size of matrices to get good trade off between training time and accuracy of the predictions.
742icse may pittsburgh pa usa malinda dilhara ameya ketkar nikhith sannidhi and danny dig congruent to this we observed developers update the type of matrices e.g.
migratingtoanint64matrix p19 asshowninlisting7.
listing7 commit8f9cabbfinstellargraph stellargraph update matrix type np.hstack a.row a.col np.hstack a.row a.col .astype np.int64 other patterns include changing data visualization with matplotlib p16 e.g.
betweendrawingalltheplotsinonefigure vsusinganindividualfigureforeachplot.anotherpatternisusingcompositemlapis p17 .developersoftentraversedatasets multiple times which is inefficient .
a more efficient solution is to apply a composite operation.
in listing developers compute dot product on three matrices instead of applying a np.multi dot .
listing8 commit180646fainscikit learn compositeapis denominator np.dot np.dot w.t w h denominator np.linalg.multi dot ml libraries offer several optimized containers e.g.
numpy arrays tensors for data processing.
updating containers e.g.
from python s listtonumpy.array is another frequent change in ml systems p18 .
ketkar et al .
discovered that in java code these typemigrationsaremorecommonthanrenamerefactorings.moreover table shows that of respondents who performed trend performitveryoften vo .alltherespondentsmanuallyperform these changes and of respondents sought automation in ides.
.
.6trend use advanced language features python offers powerful features i functions such as boolandisinstancethat can be used to simplify a conditional statement p20 ii literalssuchas toefficientlycreatecontainersinstead ofusingconstructorssuchas list dict tuple p21 see listing .
iii python comprehension to make code concise and inline forloops p22 .
researchers observed ml code extensively operates on data which results in expressions that are longer and more complex than in traditional systems.
good softwareengineeringprinciples requirethatdeveloperschange the code to make it concise and readable.
however of the surveyrespondentswhoperformedtrend4changesconfirmedthey rarely performthis intheir project and of developerssought automated help.
listing9 commit15d7634dinrasahq rasa usesetliterals instead of set constructor set utils.module path from instance p for p in agent.policy ensemble.policies utils.module path from instance p for p in agent.policy ensemble.policies .
improvements caused by refactoring awareness rq2 .
.
impactofrefactoringawareness.
toanswerthisquestion we executedthepycpatminerandr cpatmineronthestudycorpus andcomparedtheresults.wecompared numberofchangegraphs number of patterns and distribution of code instances per pattern reported by both tools.asshownintable3 r cpatminerprocessed16 morechanged methods .1bmoreastnodesthanpycpatminer.pycpatminer builds one change graph for each mapped code block pair i.e.
beforeandafterthechangedmethodbody .therefore r cpatminer produces morechange graphs thus confirming the valus of de obfuscating change graphs that were previously obfuscated by refactoring.thenther cpatminerminesallthegenerated change graphsand extracts repeated isomorphic sub graphs as patterns.
cpatminer uses minimum frequencies of repeated subgraphs to bethreeadherestotheruleofthree astandardrecurrence measureinpatternanalysis.therefore allthepatternscontainat least three code instances.
we compared the number of patterns generatedbyther cpatminerandpycpatminerandobserved thatr cpatminercaptures morepatternsthanpycpatminer.
we also compared the distributions of the number of code instancesperpatterninbothpycpatminerandr cpatminer.to assessifthereisastatisticallysignificantdifferenceindistributions ofthenumberofcodeinstancesperpatternreportedbypycpatminer and r cpatminer we applied the wilcoxon signed rank test on the paired samples of number of code instances of eachpattern.
the test rejected the null hypothesis that the density of codeinstancesofthepatternproducedbypycpatminerismore thanitisinr cpatmineratthesignificancelevelof5 p value .
.
we used the hodges lehman estimator to quantify the difference between the two distributions as it is appropriate to be used withthe wilcoxon singed rank test.
the valueturned out to be which is equal to the estimated median of the differencebetween the number of code instances per pattern from pycpatminer and r cpatminer.
therefore r cpatminer extracts more code change instances per pattern than the pycpatminer.
.
.
evaluating the precision of pyrminer.
it is important for pyrminer to have a high precision as we use it to first matchtherefactoredcodeblocksthatwethenpasstor cpatminerto buildchangegraphs.wefirstidentified18refactoringkindsthat obfuscate fine grained changes i.e the refactorings that change methodsignaturesorshiftthemethodbodies.first weexecuted the pyrminer on our study corpus and chose a statistically significantrandomsampleofrefactoringinstancesforeachrefactoring kind.hence usingat test weconclude with95 confidencethat the precision of the refactoring detection is only for each refactoring kind as shown in table .
table precision of pyrminer per refactoring kind refactoring kind precision tp refactoring kind precision tp rename method .
moveandrenameclass .
move method .
move class pull up method .
extract class .
push down method .
extract subclass extract superclass .
parameterize variable .
split parameter .
move renamemethod .
rename class .
remove parameter .
reorder parameter .
rename parameter .
add parameter merge parameter .
two of the authors that have more than three years of software developmentexperienceandextensiveexpertiseinsoftwareevolution manually validated the refactorings reported by pyrminer.
743discovering repetitive code changes in python ml systems icse may pittsburgh pa usa most cases were straightforward and thus were validated individually butbothauthorsinspectedsomechallengingcasestoreachan agreement.intotal wevalidated2 062uniquerefactoringinstances outofwhich1 965weretruepositivesand97werefalsepositives.
this achieves an average precision of which is close to the precision of the original java rminer .
.
this also shows theeffectivenessof javafypytoadaptjavaast analysistoolsto python.wereleaseallthevalidatedrefactoringinstancesonour companionwebsite .tothebestofourknowledge thisisthe largest to date python data set of validated refactoring instances.
recallindicatestheproportionofactualrefactoringsidentified bypyrminer.javaresearchersusepreviouslyformedunbiasedora clestocomputerecalloftools .tothebestofourknowledge thereisnosuchunbiasedrefactoringoracleforpython.considering thecomplexityofbuildinganoracleandourmainfocus toretrieve correctcode blockmappingstomakepycpatminerrefactoringaware we leave computing recall as future work.
however we observedr cpatminerdetects16 morechange graphs i.e.
mappedcodeblocks and15 morepatternsthanthepycpatminer which strongly indicates that the pyrminer has a satisfactory recall.
.
runtime performance of r cpatminer pycpatminer and pyrminer rq3 a fast execution time persuades the users that the adapted tools can be run on their systems even on a consumer laptop in anacceptable amount of time.
it will enable the creation of biggerdatasets of repetitive code changes to strengthen the validity of empiricalresearchortrainlearning basedcoderecommendation systems aswellas enable innovativeuses of code changepattern miningatcommittime.therefore weevaluatedtheexecutiontimesoftheadaptedtoolsandcomparedthemwiththejavacounterparts.
table analysed data set and execution time.
java cpatminerpy cpatminerr cpatminer total changed methods 824k 1m .16m total ast nodes of changed methods 92m .5b .6btotal changed graph nodes 8m 4m .7m total patterns 17k 24k 28k execution time 8hours 12hours 19hours 1the data of the java cpatminer is obtained from its original paper to measure the execution time of the tools we executed the pythonadaptedrminer cpatminer andr cpatmineronalarge corpusandcomparedtheexecutiontimewiththejavaversionof thetools.weexecutedeachtoolseparatelyonthesamemachine with the following specifications intel core i9 cpu .90ghz gb ddr4 memory tb ssd macos .
.
and java .
.
.
first werecordtherunningtimeofthe typeinference tool pytype version .
.
.
pytypeis decoupled from javafypy.
therefore wecomputedtheexecutiontimeof pytypeseparately.
pytypetook on mean 360ms and 61ms on median for type inference of all changed files in a commit.
we pushed the inferred type information of all the changed files in all the studied projects commitstoarepository ingithub.similarto typeshed atype repository of python library apis that the library clients use fortypeannotations researcherscanfast tracktheiranalysisbysimply reusing this inferred type information .
to record running time of pyrminer we followed the steps used by tsantalis et al.
for computing the running time of their java rminer.
we recorded the time required for parsing the sourcecodeofthecommit anditsparent andthetimerequired fordetectrefactorings.ouranalysisshowsthatpyrminertakes 55msonmedianand .32ms onmeantoprocessapythoncommit.
tsantalis et al.
found that the java version of rminer takes44mson median and 253mson mean to process one java commit.
therefore pyrminer takes reasonable time overhead for theadditional processing i.e.
ast transformation andwill not impacttheprimarygoalof rminer i.e.
createlargerrefactoring datasets to strengthen the validity of empirical studies or enable novel applications of refactoring mining .
table shows the size of processed data and the execution time ofthetools java cpatminer pycpatminer andr cpatminer.
therunningtimeofthepycpatminerandr cpatminerisless than hours and hours respectively whereas java cpatminer takes less than hours to mine patterns.
however the java and pythoncorpusisdiverse seetable3 .hence itishardtomakea faircomparison.
nguyenetal .
statethattheprimarygoalof thecpatmineristominethecorpusweeklytobuildadatabaseof patterns.webelievethatr cpatminerandpycpatminerhave reasonable execution times for achieving the same goal.
implications wepresentactionable empirically justifiedimplicationsforfour audiences i researchers ii tool builders and ide designers iii ml library vendors and iv developers and educators.
.
researchers r1.
exploitapplicationsofchangerepetitivenessofpythonml software rq1 rq3 .
in the past researchers exploited the repetitiveness of changes in java systems through code comple tion automated program repair api recommendation typemigration librarymigration andautomatedrefactoring .usingourrichand diversedatasetof28kchangepatternsinstancesandourjavafypy researchers can bring the same benefits to python ml systems.r2.
foundationstostudypythonmlsoftwareevolution rq1 rq2 rq3 .
despite the widespread use of python ml systems its evolutionandmaintenancetasksaretheleastautomatedandthe least studied due to the unavailability oftool support to study ml systems .
previously researchers have built infrastructure to studymanyaspectsofsoftwareevolution.forexample rminer andrefdiff mine refactorings typefactminer mines type changes migrationminer andapimigrator mineapimigrations cpatminer andcodingtracker minefine grained repetitive code changes in java.
this rich infrastructure allowsresearchers to study java software systems and there are hun dreds of published papers that are built upon this infrastructure.
unfortunately they miss the whole ecosystem of python ml codebases.researcherscanuseourdataandtoolsettostudywhether previously held beliefs from traditional software are still valid for mlsystemsorwhetherweneedtodesignnewtoolsandworkflows 744icse may pittsburgh pa usa malinda dilhara ameya ketkar nikhith sannidhi and danny dig e.g.
version control systems code smells technical debt etc.
that are specific to ml.
r3.
enhanceexistingresearchandtoolsformlsystems rq1 rq3 our infrastructure can be used to enhance the existing research on ml systems.
for example tang et al .
introduce a taxonomy of refactoring kinds performed in java ml systems humbatova et al .
islam et al .
introduce a taxonomy of bugs in ml systems based on manual analysis of stackoverflow posts.
these studies perform extensive manual analysis to build varioustaxonomiesusingasmallerdatasetofchanges.withour significantlylargerdataset of28kchangepatterns theycansignificantly extend or further validate their taxonomies.
moreover researchers showed the potential of leveraging ml techniques for codecompletion .however theytrainthemlmodelseither on a noisy or small dataset which could reduce the accuracy of the recommendations.researcherscanuseourtools datasettotrain theirmodelsonalarge curateddatasetandimprovetheiraccuracy.
r4.
build novel applications for ml developers rq1 .
researchers can also use our tools dataset to build novel applications.
braiekandkhomh observedmllibrariesarecorecomponents ofmlsystemsandarefrequentlyevolving whichcausesdeveloper frustration .
a tutoring system can suggest to developers whichconstructstouseinordertomodernizetheirmlcode.for example atutoringsystemcouldrecommendchangingthecodeto usemllibraryapisinsteadof forloops orremovingredundant matrixoperations orother changesfromrq1 table1 .moreover a tutor system can recommend novice programmers how to use advanced language features see trend in rq1 table .r5.
revisitexistingstudiesandtoolsformakingthemrefac toring aware rq2 .
thereexistaplethoraofresearchtoolsfor mining software repositories and hundreds of researchers usedthese tools to conduct empirical studies.
given that refactorings obfuscateprogramelementsduringsoftwareevolution weshowed thatmakingastateof thearttoolsuchas cpatminerrefactoring awareincreasesitsoveralleffectivenessbyasmuchas15 .wecall theresearchcommunitytoadaptsimilarmethodsandtorevisitprevious results obtained with tools that were not refactoring aware.
.
tool builders and ide designers t1.
new inspirations for tool development rq1 .
to help tool builders invest resources where automation is most needed in table we present patterns along with the ml developers requestforautomation.movingto withstatementsandusingcontext managersisthemostprevalentchangepatternamongtheanalysed patterns seerq1 p1 p8 .inthesurvey ofrespondentssuggest toolsthatinspectdeeplearningcodebasesandrecommendusing withstatementsto i turnonoroffgradientcalculations p2 ii specify hardware type p3 iii change variable scopes p4 and iv executedependencies p5 .respondentsfurthersuggestedtools to i movecontextmanagerinvocationsto withstatements and ii detect misuses of context managers.
.
ml library vendors l1.
understand ml library usage rq1 .
ml library vendors continuouslyimprovelibrariesandintroducenewmllibrariesat an unprecedented rate .
library developers deprecate apis introducemoreefficientalternativeapis e.g.
table1 p18 and splitmllibraries .ourfindings theaccompanyingdataset and the tools we developed can help ml library vendors to understandwhatapisaremostcommonlyused misused andunderused andhowthedevelopersadapttonewapis.thus theycanmakeinformed empirically justified decision s to improve features .
.
software developers and educators s1.
richeducationalresource rq1 developerslearnandeducatorsteachnewprogrammingconstructsthroughexamples.robillardetal.
studiedthechallengesoflearningapisandconcluded that one of the important factors is the lack of usage examples.
usingourdatasetof28kcodechangepatternsthatweminedinour corpus developersandeducatorscanlearnfromreal worldcode transformations e.g.
transformingto multi dot .weprovide22 empiricallyjustifiedcodechangepatternsthatimprovemlcode frommanyaspects includingspeed codequality andreadability.
mldeveloperscanabsorbthesechangestotheircodeandimprove the code.
we released this through an educational resource .
threats to validity internal validity can we trust the results produced by tools?
the findingsof ourstudydependon theaccuracyofour toolstomine code change patterns in a refactoring aware manner.
we rely on type inference for augmenting the ast with rich type information.
sincetype inference deduces the types of elements by statically analysing the program it may not accurately detect them com pared to the run time .
this can effect the quality of mappings reportedbyr cpatminerandthestatementsmatchedbyrminer.
to mitigate this threat we use pytype a mature tool developed by google.
thousands of projects at google and other places rely upon pytypeto keep their codes well typed .
moreover wevalidatejavafypy seffectivenessattransformingavarietyof syntacticvariationsupon12mastnodesfrom14popularprojects.
our manual validations shows that pyrminer reports refactorings withhighprecision .wealsomanuallyvalidated2 500most popular patterns produced by r cpatminer.
toavoidthe experimentalbias wefollowedthebestpractices for applying thematic analysis by achieving inter coder agreement when labelling the patterns.external validity do our results generalize?
we studied projects from a wide range of application domains making thestudy results generalizable to other open source projects in sim ilar domains.
however a study of proprietary code bases might revealothertrends.nevertheless wemakeourtoolsavailableso thatotherscanusethemtominepatternsinproprietarycodebases.
moreover r cpatminer reports numerous patterns we manually analyzedasubsetofthem acompleteinvestigationisnotpractical.
to mitigate this we ranked the code change patterns in five dimensions and manually validated the top ones.
verifiability can others replicate our results?
to ensure replicability we make the tools and the data publicly available .
related work .
.1studiesonevolutionofmlsoftwaresystems .researchers have studied repetitive tasks of ml systems from many aspects.
745discovering repetitive code changes in python ml systems icse may pittsburgh pa usa humbatovaetal .
andislametal .
introduceataxonomy ofml relatedbugsandbugfixpatterns shenetal .
studybugs in deep learning dl compilers and yanet al .
study numerical bugs in dl systems.
zhang et al .
observe dl program failuresat microsoftand highlighttheneedfor dl specifictools to fixdlbugs.lwakatareetal .
zhangetal .
classifycommon challengesthatmldevelopersfacewhenmaintainingandevolving ml systems.
wan et al .
found anti patterns and misused apis in mllibraries.
nguyen etal .
create adatabase of dlmodels extractedfromgithubtoutilizeasdefaultmodelsandaccelerate automl.amershietal .
performafieldstudyatmicrosoftand proposebest practicestoaddresscommonchallenges thatrepeats amongmlsystems.incontrast ourfocusisonunderstandingfine grainedrepeatedcodechangesthatthemldevelopersperformand their motivations.
theclosestrelatedworkisbytangetal .
.theauthorsstudy gitpatches from26 javaml systems and presenta taxonomy ofrefactoringkindsthatoccurredinmlsystems.incontrast we quantitativelyandqualitativelystudiedfine grainedcodechange patterns in a significantly larger corpus python based ml systems comprising git patches.
our findings include both refactorings e.g.
p1 p9 and other semantics modifying codechanges e.g.
p2 p6 .
moreover we cross validated our findings bysurveying97mldevelopers.wemakeourtoolsavailabletofurther enhance the science and tooling for evolving python ml systems.
.
.2studies on repetitive code changes .researchers have conductedmanystudiesonrepetitivecodechanges.nguyenetal .
use a graph based algorithm to mine fine grained code changesatcommitlevel.theyconductalarge scalestudyonthe repetitivenessofcodechangesinjavasoftwareevolutionandshowthatrepetitivenessiscommoninsmallgranularity numberoflines anditdropsexponentiallyasthegranularityincreases.researchers havealsostudiedrepetitivenessfromthevantagepointofhigherlevel maintenance and evolution tasks i dig and johnson cossette and walker study incompatibilities between api versions ii teyton et al .
mine the library migrations trends and observehowfrequently when andwhytheyareperformed and iii ketkaretal .
conductalarge scalestudyontypechangesin java systems and reveal that type changes are more frequent than renaming all of these studies focus on repetitiveness in traditional systemsanddonotrevealthekindsofrepetitivechangesthedevelopers perform in mlsoftware.
in contrast we study the practices of fine grained code changes in ml systems and found four trends of fine grained changes.
of the sur veyed developers requested automation support for the identified trends in their ides.
previous researchers looked at python idioms and how they wereusedinpythonsystems.
alexandruetal .
presentanonexhaustive list of python idioms gleaned from a developer survey.
sakulniwat et al .
studied the evolution of python withstatementoverthetime.
phan udometal .
usedeveloperforums to builda database ofpython idioms andpropose teddy asystem that recommends idioms to developers.
in comparison we provide r cpatminer which can mine repetitive code changes in python systemsinrefactoringawaremanner.r cpatminercanbeused to increase related work s idiom databases.researchersreimplementedcertain javaastminingtoolsfor pythonfromscratch.pyref isapythonreimplementofjava rminer thatidentifies9kindsofpythonrefactoring.incontrast ourpyrminerdoesnotrequirereimplementingfromscratch and it finds alllegitimate java refactoring in python.
moreover we manually validated kinds of refactoring as shown in table .
golubevetal .
developedpythonchangeminer atoolthat usesfgpdg to mine python repetitive code changes involving function calls.
in contrast we present javafypy a techniqueforadaptingjavaastminingtoolstopythonwithouthavingto rewritethemfromthegroundup.weadaptedcpatminer and rminer topythonusingjavafypy andsubsequentlycreated r cpatminer a refactoring awarecodechange patternminerfor python systems.
researchersproposedseveraltechniquesthatinfer specifickinds ofcodechangepatterns.forexample revisar getafix anddeepdelta inferrepeatedbugfixesandcompilationerrors fromcommithistories.
libsync meditor anda3 infer the adaptations required to perform library migration.
ketkar etal.
developedtcinferatechniquetoaccuratelyinferrewrite rulesfortypechangesfromaproject sversionhistory.theyalso proposed intellitc a configurable ide refactoring plugin thatautomatestheseinferredtypechanges.incontrast wediscover previously unknown patterns in ml systems that involve adapting ml libraries e.g.
p9 forloop tonumpy .
conclusions thispaperpresentsthefirstandthelargeststudyoffine grained code change patterns in python based ml software systems.
to provideuniqueinsights weusecomplementaryempiricalmethods i mining software repositories containing over million loc ii using thematic analysis to identify the groups and trends and iii surveying ml developers.
to conduct this study and advancethescienceandtoolinginpythonmlsoftwareevolution we designed a novel technique javafypy to reuse adapt and improve upon the java state of the art ast mining tools.
we introduce a noveltoolr cpatminerthatperformsrefactoring awarechange patternminingintheversionhistoryofpythonprojects.wepresent code change pattern groups in four trends where of them are specific to ml.
in the developer survey of the respondents requestedthesepatternsautomatedintheirides.theresultsand thetoolspresentedinthisstudyhaveactionableimplicationsfor researchers tool builders library designers ml developers and educators.wehopethatthispaperandourreadilyavailabledataset and tools catalyzes the community to advance the science and tooling for the evolution of python based ml systems.