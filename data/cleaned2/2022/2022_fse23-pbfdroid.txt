property based fuzzing for finding data manipulation errors in android apps jingling sun shanghai key laboratory of trustworthy computing east china normal university china jingling.sun910 gmail.comting su shanghai key laboratory of trustworthy computing east china normal university china tsu sei.ecnu.edu.cnjiayi jiang shanghai key laboratory of trustworthy computing east china normal university china jyjiangsunny gmail.com jue wang state key lab for novel software tech.
and dept.
of computer sci.
and tech.
nanjing university china juewang591 gmail.comgeguang pu shanghai key laboratory of trustworthy computing east china normal university china ggpu sei.ecnu.edu.cnzhendong su department of computer science eth zurich switzerland zhendong.su inf.ethz.ch abstract like many software applications data manipulation functionalities dmfs are prevalent in android apps which perform the common crud operations create read update delete to handle app specific data.
thus ensuring the correctness of these dmfs is fundamentally important for many core app functionalities.
however the bugs related to dmfs named as data manipulation errors dmes especially those non crashing logic ones are prevalent but difficult to find.
to this end inspired by property based testing we introduce a property based fuzzing approach to effectively finding dmes in android apps.
our keyidea is that given some type of app data of interest we randomly interleave its relevant dmfs and other possible events to explore diverse app states for thorough validation.
specifically our approach characterizes dmfs in data model based properties and leverage the consistency between the data model and the ui layouts as the handler to do property checking.
the properties of dmfs are specified by human according to specific app features.
to support the application of our approach we implemented an automated gui testing tool pbfdroid .
we evaluated pbfdroid on20real world android apps and successfully found 30unique and previously unknown bugs in apps.
out of the 30bugs 29of which are dmes 22are non crashing logic bugs and are crash ones .
to date 19have been confirmed and9have already been fixed.
many of these bugs are non trivial and lead to different types of app failures.
our further evaluation confirms that none of the 22non crashing dmes can be found by the state of the art techniques.
in addition a user study shows ting su and geguang pu are the corresponding authors.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
the manual cost of specifying the dmf properties with the assistance of our tool is acceptable.
overall given accurate dmf properties our approach can automatically find dmes without any false positives.
we have made all the artifacts publicly available at .
ccs concepts software and its engineering software testing and debugging.
keywords property based testing model based testing android app testing non crashing functional bugs acm reference format jingling sun ting su jiayi jiang jue wang geguang pu and zhendong su.
.
property based fuzzing for finding data manipulation errors in android apps.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
introduction android apps are ubiquitous and serve many different aspects of our daily life .
specifically like many software applications data manipulation functionalities dmfs for short are prevalent in android apps .
these dmfs perform the common data manipulation operations crud i.e.
create read update delete to handle app specific data e.g.
creating files reading emails deleting posts .
thus ensuring the correctness of these dmfs is important because they serve as the fundamental of many core app functionalities.
however unlike the crash bugs targeted by many existing automated gui testing techniques the non crashing logic bugs related to these dmfs are seldom tackled and may lead to frustrating consequences in real life .
a real example .
in this paper we name the bugs which fail the normal operations of dmfs e.g.
cannot create a file as data manipulation errors dmes for short .
figure shows such a dme .esec fse december san francisco ca usa jingling sun ting su jiayi jiang jue wang geguang pu and zhendong su figure a dme inamaze v3.
.
the top graph gives an overview of this bug.
the small red box on each page denotes a ui event.
amaze a file management app allows users to manipulate files or folders on android devices.
however its dmf rename folder has a serious bug shown in figure .
specifically a user can create a new folder named old name under the directory storage emulated example see figure a d add a file test.txt in this folder old name see figure e h switch to the up level directory storage emulated see figure h j and search the created folder old name under storage emulated see figure j l .
as expected the folder old name can be successfully found see figure l .
however in this case if the user renames the folder old name to new name see figure l o the app fails as the folder name is not correctly updated to new name see figure o .
even worse if the user opens the folder old name the original file test.txt in this folder cannot be found see figure p .
in this example the failure of renaming the folder old name is a dme which involves three dmfs create folder search folder and rename folder .
these dmfs manipulate the app data folder .
note that the three dmfs work fine independently and the steps create folder switch to the root directory search folder and rename folder are the necessary operations to manifest the dme .
prevalence of dmes .
to investigate the prevalence of non crashing dmes the main focus of this paper we studied the 4popular wellmaintained open source android apps with different categories on github i.e.
amaze a file manager 4k stars ankidroid a card learning tool .4k stars k9mail an email client .1k stars and wordpress a personal blogger .7k stars and their 245non crashing bugs which were reported from august to july spanning three years .
by examining the bug reports and reproducing the bugs we find that a large portion of the noncrashing bugs are dmes .
it indicates that dmes are indeed prevalent and effective bug finding techniques are in need.
limitations of existing testing techniques .
modern automated gui testing techniques have been widely used to help find functional bugs in android apps .
however existing techniques have two major limitations in finding dmes .
first the majority ofexisting testing tools are limited to crash bugs due to the lack of strong test oracles .
thus they are difficult to find those dmes which lead to non crashing failures like the bug in figure .
second although some testing tools can find non crashing bugs by generating automated oracles based on heuristics or metamorphic relations .
the oracles are too generic to find dmes which are usually app specific.
our approach and its novelty .
to this end inspired by the classic idea of property based testing pbt we aim to introduce a novel property based fuzzing approach to effectively finding dmes in android apps.
our insight is that given a generic app functionality we can specify its property as pre e post whereedenotes the ui event trace performing the functionality and preandpost denote the pre and post conditions before and after executing e respectively.
for example for the dmf rename folder in figure edenotes the event trace of rename folder i.e.
open the menu of folder old name select rename input new name and click save in figure l o predenotes the precondition i.e.
the menu icon of folder old name on figure l should exist and post denotes the postcondition i.e.
the folder name should be newname on figure o .
in this way we can apply the classic idea of pbt to generate a number of random inputs i.e.
random ui event traces in our context on the app under test to validate the correctness of .
if there exists one random input which leads to an erroneous program state satisfying prebut violating post after executinge a bug is found.
for example the property of the dmf rename folder is falsified by the event trace in figure l o because the folder name is not correctly updated to new name .
however applying the preceding high level idea to fuzz dmfs is not straightforward.
we face two keytechnical challenges how to explore diverse app states to adequately validate the property of admf ?
how to define and check the property of a dmf which involves app data changes?
to address these two challenges we have two keyobservations detailed in section .
exploring the mutual interactions between dmfs w.r.t.
the shared app dataproperty based fuzzing for finding data manipulation errors in android apps esec fse december san francisco ca usa could lead to diverse app states e.g.
in figure the three dmfs create folder search folder and rename folder allmanipulate the shared app data old name and thus manifest the dme and the property of a dmf can be characterized by some data update effect e.g.
for the dmf rename folder the data update effect is changing old name to new name andchecked by the data update effect displayed on the ui pages e.g.
in figure o when folder old name is renamed to new name new name should be displayed on the ui page .
inspired by the preceding two observations given some type of app data of interest our idea is to randomly interleave the relevant dmfs and other possible events to explore diverse app states thus improving the fault detection ability and characterize the property of a dmf by a data model based property pre e r post whererrecords the data update effect of ein the abstract data model thus facilitating property checking.
specifically the data update effect of these dmfs are recorded in the model in parallel when different dmfs are interleaved during fuzzing.
and we leverage the consistency between recorded app data and ui pages as the handler to check the correctness of dmfs .
as a result we can do property testing whenever the execution of a dmf is finished.
in practice we focus on testing the dmfs in terms of five common data manipulation operations1 i.e.
create read update delete andsearch .
the properties of these dmfs i.e.
dmf specifications are provided by human according to app features.
overall the novelty of our technique is combining the idea of property based testingwith model based properties to facilitate validating dmfs in the context of android apps.
evaluation and results .
we implemented a gui testing tool pbfdroid to support the application of our property based fuzzing approach.
we applied pbfdroid to find dmes in20popular android apps 17open source and 3industrial apps and successfully found 30unique and previously unknown bugs in 18apps.
specifically among the 30bugs 29bugs are dmes .
out of the dmes 22are non crashing logic bugs and are crash bugs.
to date dmes have been confirmed and 9have already been fixed by the app vendors.
the remaining bugs are still under active discussions between developers.
our further evaluation confirms that none of the non crashing dmes can be found by the state of the art testing techniques.
moreover we conducted a user study to investigate the feasibility of manually specifying dmf specifications.
it shows that the involved manual cost is reasonable.
on average it only takes minutes to specify one single dmf and minutes for all the dmfs w.r.t.
the app data of interest per app.
overall given accurate dmf specifications our approach can automatically find dmes without false positives.
to sum up this paper has made the following contributions we introduce a property based fuzzing approach to finding dmes especially the non crashing ones.
our approach combines the idea of property based testing with model based properties to achieve effective fuzzing for dmfs.
we propose a novel idea i.e.
randomly interleaving different dmfs and other possible events to generate diverse app states for improving the fuzzing effectiveness.
1in our work we differ read andsearch read denotes viewing existing data entries while search denotes retrieving data entries with some criterion.
we implement a gui testing tool pbfdroid to support the application of our approach.
pbfdroid successfully found 30unique and previously unknown bugs 29of which are dmes 22are non crashing logic bugs .
pbfdroid significantly complements existing gui testing techniques.
approach this section presents our approach a property based fuzzing approach to finding dmes in android apps.
.
high level idea an android app ais a ui based event driven program.
a ui page is represented by a ui layoutl which contains a number of ui views or widgets .
a ui vieww w l has some attributes e.g.
classname i.e.
the view type resourceid i.e.
the view id text i.e.
the view text and etc.
definition .
ui event .
a ui view wcan be executed by a ui evente.
we denoteease t w o wheree.tdenotes the event type e.g.
click edit e.wdenotes the ui view won whicheis executed ande.odenotes the optional data of e e.g.
the text inputted by edit .
examples .
in figure page c corresponds to a ui layout l. on l an edit field view wexists its classname isedittext andtext is old name .
the event eof inputting old name in wcan be represented as e edit w old name .
definition .
test inputs for apps .
an appaaccepts as a test input in the form of a sequence of ui events i.e.
event trace .
an event traceecan be denoted as e whereeiis an event.
wheneis executed on a we can obtain a sequence of the app states s i.e.
s or denoted by s0e1 s1...si 1ei si...sn 1en sn wheresiis the app state due to the execution of ei onsi i n .
we usesn e s0 to denote the effect of executing e on the initial app state s0and reaching the ending state sn.
definition .
app property .
given some app functionality f its app property is distilled from the specification of an app a. specifically is represented in the form of pre and post conditions i.e.
pre e post whereedenotesfin the form of an event trace preis the precondition imposing a necessary condition that must hold before execution of e andpost is the postcondition defining the effect on the app state after executing e. specifically an app property can be interpreted as if s preands e s s post should hold s ands are the states before and after the execution of e respectively .
property based testing .
property based testing pbt validates the correctness of a piece of program under test against some specified properties i.e.
the test oracles .
specifically it generates a large number of test inputs to check whether the properties could be violated.
for example for a function sort which takes as input an array arrand returns the sorted arrwith its elements in the ascending order we can specify one of its property as arr arr where i j n nis the length of arr .
the idea of pbt is to generate a number of arrays with different sizes and elements e.g.
integers to validate whether the property holds.
our high level idea .our high level idea is to leverage the idea of property based testing to validate app properties.
given an app aesec fse december san francisco ca usa jingling sun ting su jiayi jiang jue wang geguang pu and zhendong su table pre and post conditions semantics and data update rule of dmfs in the five common data manipulation operations.
op preopsemantics of eoproppostop create e1.w l0 create a new data object d d d0dn d0 d w.d w w ln read e1.w l0 read the details of any data object d w.d w w ln update e1.w l0 update any data object dtod d d0dn d0 d d w.d w w ln w .d w w ln delete e1.w l0 delete any data object d dn d0 d w.d w w ln searche1.w l0 d0 search any data object d d0 w.d w w ln and one of its app properties pre e post we aim to validate the correctness of .
specifically we aim to generate different app statess s s.t.s pre and check whether s post always holds after the execution of e. here s e s andsdenote the app states ofa.
ifs post does not hold for some s we are guaranteed to find a violation of when is correctly defined .
.
challenges and observations however instantiating the high level idea for validating the properties of dmfs i.e.
the in our setting is non trivial.
we face two technical challenges how to explore diverse app states to adequately validate the property of the dmf ?
and how to define and check the property of the dmf which involves app data changes?
to address these two challenges we define some concepts in this section to illustrate our two key observations.
section .
will present our approach based on the observations.
app data data type and data object .
following the common model view controller mvc architecture pattern an android appaaccepts ui events from users to manipulate app data and visualizes the data on the ui pages.
we observe that an app a may contain different types of app data from the perspective of app functionalities.
each type of app data tis usually associated with some dmfs .
these dmfs manipulate the concrete data objects of tto achieve some functionality.
specifically a data objectd i.e.
an instance oft is usually associated with some ui view won some ui layout lfor visualization.
here we use d wto denote the mapping from a data object dto its corresponding view w. examples .
in figure page d displays the created folder oldname which can be viewed as a data object of data type folder name hereafter we use folder for short .
specifically the data object old name is visualized by a text view w itstext is oldname and resourceid is amaze id firstline on the page d .
this relation can be denoted by old name w. on page d the current app data of type folder can be recorded as old name .
based on the preceding concepts we have two observations.
observation exploring the mutual interactions between dmfs w.r.t.
the shared app data could lead to diverse app states .
we observe that given some type of app data its relevant dmfs can affect each other by manipulating the shared data objects which may lead to different app states.
this observation is similar to the insight of interleaving class method calls on some shared class objects to improve testing object oriented programs .
examples .
inamaze the three dmfs i.e.
create folder search folder and rename folder work fine independently.
however when these three dmfs interact with each other on the shared data object old name see the event trace in figure an erroneous app state is manifested.
observation the property of a dmf can be characterized by some data update effect and checked by the data update effectdisplayed on the ui pages.
we observe that for a functionally correct app its each dmf leads to specific impacts on the app data.
therefore we can record these data update effects to define the properties of these dmfs .
additionally based on the common mvc architecture pattern adopted by android the data update effect will be always displayed on the app s ui pages.
therefore we can check the property of a dmf by checking the consistency between the recorded app data and the data displayed on the ui pages.
example .
in amaze the execution of dmf create folder see figure leads to the addition of a new folder to the app data i.e.
adding a data object old name to the app data of type folder .
therefore the data update effect of executing dmf create folder can be represented as from to old name .
after the execution ofdmf create folder the data object old name is visualized on page d which denotes the dmf create folder achieve its functionality correctly.
.
instantiation of the high level idea inspired by the preceding two observations our instantiated idea is that given one type of app data dof interest we randomly interleave the relevant dmfs with other possible events on the shared data objects to explore diverse app states for thorough validation.
meanwhile we record the data update effect of each dmf when different dmfs are interleaved and leverage the consistency between the app data and ui layouts as the handler to check the correctness of dmfs.
definition .
app state .
an app state is composed of two key components the ui layout lfor front end visualization and the app datadstored in the background e.g.
in files or database .
in this way we can represent an app state as s l d whereland dare the ui layout and the app data at the app state s respectively.
model based properties of dmfs .
we specify the model based property of a dmf as op preop eop rop postop whereop denotes one data manipulation operation i.e.
op create read update delete search .
here eopis the event trace performing the dmf .preopandpostopare the pre and post conditions respectively.
specifically we introduce d an abstract data model to record the app data of type tmanipulated by the dmf .dis updated byrop which runs the semantics of eop.
table gives the model based properties of the five types of dmfs.
how to do property checking on one dmf ?we take create in table as an example to illustrate how to do property checking on one dmf .
let the event trace eopofcreate be e1 ... ei ... en .
wheneopis executed on some app state s0 we can obtain a sequence of app states s s0 l0 d0 ... si li di ... sn ln dn cf.definition and .
note that the precondition preopofcreate e1.w l0 e1is the first event of eop ande1.w ise1 s target ui view decides whether create is executable onproperty based fuzzing for finding data manipulation errors in android apps esec fse december san francisco ca usa figure illustration of our approach on the bug in figure .
states0 recall thats0 l0 d0 .
during the execution of create the abstract data model dis independently updated according to the semantics of eop i.e.
we can obtain a sequence of mirrored app data i.e.
.
when create is successfully executed i.e.
all the events of eopare executed roprecords data update effect by adding dintodn d d0 and the post condition postopchecks the consistency between dnanddnvia the ui layoutln.
specifically postopchecks whether there exists one ui view w wis mapped from the data object d on the ending page ln which displays the data object d. ifwdoes not exist the property is violated and a dme is found.
in this way we can leverage dto record the app data changes and achieve property checking whenever one dmf is executed.
note that for update anddelete in table ifd d d d does not delete any element in d. how to do property checking on multiple dmfs?
we use figure to demonstrate the process of property checking on multiple dmfs using the example depicted in figure .
figure shows that how our approach records the app update effect when interleaving different dmfs and does property checking whenever the execution of a dmf is completed.
starting from the app state sa corresponding to page a in figure the execution of the three dmfs create folder search folder and rename folder updates the app state changes from sa la da tosd ld dd sl ll dl and finallyso lo do where thela ld llandlo correspond to the ui layout of page a d l and o in figure andda dd dlanddorepresent the actual app data respectively.
the abstract data model d is updated from to old name oldname and finally new name according to the executions of these three dmfs .
during this process we can utilize the consistency between the recorded data in dand the ui layouts to perform property checking after each dmf is executed.
in this way we can find that the property of dmf rename folder is violated because a ui view displaying the data object new name does exist on lo.
implementation we implemented an automated gui testing tool pbfdroid to support the application of our property based fuzzing approach.
figure shows pbfdroid s workflow.
pbfdroid takes as input the app under test assists users to conveniently specify the dmfs of interest and outputs any found dmes with bug reproducing tests .
pbfdroid contains four modules dmf instantiator input generator data recorder and property checker .
in the following we first present the main module input generator section .
data recorder section .
and property checker section .
which implement our core approach.
we discuss dmf instantiator section .
at last which is a user interaction module.
.
input generator input generator drives the main testing loop described in algorithm and coordinates with data recorder andproperty checker figure workflow of pbfdroid algorithm property based fuzzing for finding dmes inputs dmflist appa s relevant dmfs w.r.t.
some app data type output dmes the found dmes a list storing the bug reproducing tests 1procedure main while not timeout do 3d eventtrace clearandrestartapp a whileeventtrace.len lmax do l dumpguilayout a candidatedmfs foreachdmf dmflist do ifispreconditionhold dmf l d then candidatedmfs .append dmf ifrand .
candidatedmfs then dmf randomselect candidatedmfs succ events execute a dmf.e eventtrace eventtrace events if succ then continue d updateappdata dmf d l dumpguilayout a if ispostconditionhold dmf l d then dmes.append eventtrace else e randomevent l candidatedmfs succ events execute a ifsucc then eventtrace eventtrace events returndmes during fuzzing.
in detail input generator is responsible for generating and executing random gui tests.
it randomly interleaves the relevant dmfs w.r.t.
some data type and other possible events to explore diverse app states.
note that the input generator is compositional like the data generators in classic property based testing.
because it calls sub generators to generate random string for the text inputs of edit events random types of events e.g.
click or long click and composes a sequence of events i.e.
a gui test .
specifically dis the abstract data model and eventtrace records the executed events during testing.
in the main testing loop lines pbfdroid first initializes dandeventtrace and prepares the app under test by clearing its app data lines and then iteratively generates gui tests to fuzz the app controlled by lmax the maximal length of a gui test .
pbfdroid checks which dmfs stored incandidatedmfs are qualified to be executed lines .
here ispreconditionhold checks whether one dmf s precondition holds according to the current app state.
to randomly interleave the dmfs and other possible events pbfdroid randomly selects one dmf whencandidatedmfs is not empty lines ora random ui event line by coin flipping.
if one dmf is selected all events in the event trace of this dmf dmf.e here will be executed by execute line .
note that execute returns two variables succesec fse december san francisco ca usa jingling sun ting su jiayi jiang jue wang geguang pu and zhendong su figure defining the dmf specification of rename folder with the assistance of pbfdroid a the given user inputs b the automatically generated dmf specification.
which indicates whether the dmf is successfully executed and events which records the successfully executed events.
if the event trace of this dmf is successfully executed the functionupdateappdata updates the abstract data model d line .
then function ispostconditionhold checks whether the dmf s postcondition holds according to the ui layout land the abstract app data model d line .
if the property is violated the event traceeventtrace which records all the executed events will be stored as a bug reproducing test line .
however if the dmf fails to execute lines dwill not be updated and the gui testing will continue until reaching the limit lmax lines .
and if a random event eis selected and successfully executed this event will be recorded in eventtrace lines .
note that function randomevent randomly selects one executable event eon the current layout l andeshould not be the first event of any dmf in candidatedmfs .
in practice pbfdroid usesuiautomator to execute events and obtain ui layouts.
.
data recorder data recorder maintains the abstract data model daccording to the executed dmfs cf.ropin table by updateappdata .
specifically it only updatesdwhen a dmf is successfully executed.
for example only when the dmf rename folder is completely executed the data object old name will be replaced by new name in d.data recorder records the data update effect of each dmf to facilitate property checking whenever a dmf is executed.
.
property checker property checker checks whether the precondition or postcondition of admf is satisfied based on the ui layout and the simulated app data cf.preopandpostopin table by ispreconditionhold and ispostconditionhold .
for example when the dmf rename folder is successfully executed this module will check whether there existsa ui view on the layout displaying the data object new name .
if the ui view does not exist the postcondition is violated.
.
dmf instantiator dmf instantiator assists users to conveniently define dmfs .
figure uses the dmf rename folder to illustrate the basic procedure.
as shown in figure a when a user selects rename folder as the target dmf the user needs to tell pbfdroid about dmf type e.g.
create read update delete search dmf s event trace and the manipulated data objects.
in this case the dmf type of rename folder is update and the event trace of rename folder will be automatically recorded when the user interactively executes the events on the device screens the views of events are annotated in the red boxes on l0 l1 l2 l3 .
the manipulated data objects are specified by the user in text according to the dmf type.
in this case the removed data object is old name on l2 and the added data object is new name on l3 .
based on the preceding user inputs this module automatically generates the dmf specification defined in a json style domain specific language .
figure b shows the generated dmf specification of rename folder .
specifically it contains six main fields eventtrace data datachange views precondition and postcondition .
we explain these fields as follows.
eventtrace .
this field records the event trace of a dmf corresponding to eopin table .
each event has its type target view and optional data.
in this case the event trace of dmf rename folder contains four events e1 e2 e3 e4 .
specifically e3is an edit event its target view is w3 annotated on l2and specified in field views and its data is random which informs input generator to generate a random string with letters numbers or symbols .
when creating a dmf the event trace should ensure that the preand the post condition of the property could be observed on the starting page e.g.
l0 and the ending page e.g.
l4 respectively.property based fuzzing for finding data manipulation errors in android apps esec fse december san francisco ca usa data .
this field defines the manipulated data objects corresponding todandd in table .
in this case the dmf rename folder has one removed and one added data objects which are specified by vieww3 stexts onl2andl3 respectively.
datachange this field defines the data update effect w.r.t.
the dmf type corresponding to ropin table .
in this case of rename folder the data update effect is removing removeddataobjectand adding addeddataobject in the app data d removeddataobject andaddeddataobject are specified in field data .
views .
this field defines the ui views related to the dmf .
each view can be identified by some of its attributes e.g.
classname resourceid text .
these views and their attributes are automatically collected according to the recorded events or user inputs.
precondition andpostcondition .
these two fields define the pre and post conditions of a dmf corresponding to preopand postopin table .
the event trace of dmf can be executed only when the precondition is satisfied while the postcondition checks whether the property of dmf is valid after the event trace of dmf is successfully executed.
note that the mapping from data objects to the relevant views are automatically identified by this module according to the user inputs.
for example when a user specifies new name as the added data object this module will analyze ui layouts l0 l4 to find the relevant views whose text is new name .
the grey dotted boxes and arrows in figure show how this module maps the userspecified text new name to the relevant view w5 and records this view in the dmf specification.
w5is used in the postcondition.
pbfdroid uses weditor to automatically record user events.
discussion .
in practice some dmfs may require additional predicates in its precondition to accurately model their properties.
for example in amaze an app user can create a folder under any directory rooted by storage emulated .
we know that if a user creates a folder under storage emulated a but searches it under storage emulated b the user will not find the folder.
it is the expected app behavior.
thus to accurately define the dmf search folder of amaze we manually added an additional predicate into its precondition i.e.
the search directory should be storage emulated .
in detail we added a new view w0 text storage emulated to fieldviews of the generated dmf specification and added the predicate w0 l0in fieldprecondition .
we observe that among the dmfs used in our experiment in section dmfs .
require adding additional preconditions.
evaluation our evaluation aims to answer these research questions rq1 can pbfdroid find dmes in real world android apps including open source and industrial apps?
rq2 can the state of the art techniques find the dmes uncovered by pbfdroid ?
can pbfdroid complement them?
rq3 how do different testing strategies or configurations affect the bug finding abilities of pbfdroid ?
rq4 how much manual effort is required to define dmfs with the assistance of pbfdroid ?table app subjects evaluated in our study k m b app idapp name version stars installations app featuretarget data dmfs markor .
.
.2k 100k 500k text editor file aard2 .
10k 50k dictionary reader word simpletask .
.
10k 50k task manager task skytube .
.6k 100k 500k video player channel anymemo .
.
100k 500k learning software card amaze .
.
.9k 1m 5m file manager folder ankidroid .
.3k 10m 50m learning software card wikipedia .
.
.7k 50m 100m wikipedia reader favorite tasks .
.2k 100k 500k task manager task radiodroid .
100k 500k radio manager radio activitydiary .
.
1k 5k activity recorder activity myexpenses .
.
1m 5m expense tracker account antennapod .
.
.6k 500k 1m podcast manager podcast materialistic .
.2k 100k 500k news browser story notepad .
.
500k 1m note manager note transistor .
.
10k 50k station browser station omni notes .
.
.5k 100k 500k note manager note tiktok .
.
1b 5b video platform user capcut .
.
100m 500m video editor user feishu .
.
10m 50mcollaboration platformfolder .
evaluation setup app subjects .
to our knowledge genie and odin are the only two work which can automatically find generic non crashing bugs in android apps.
they are close to our work.
thus we selected allthe apps from these two work as our subjects selecting these apps also allows a fair comparison between pbfdroid genie and odin in rq2 .
specifically genie andodin evaluated and apps respectively.
after removing the duplicated apps we obtained apps.
from the apps we excluded apps i.e.
unitconverter and fosdem because their functionalities are too simple to contain any dmf and and bible because it is not usable due to the unavailable web services .
to complement the subjects we additionally selected popular open source apps notepad and omninotes from and 3industrial closed source apps tiktok capcut feishu from bytedance.
thus we have 20apps in total all of which are released on google play .
in table version stars installations and app feature give the latest app versions at the time of our study the numbers of stars on github the installations on google play and the main app feature respectively.
these apps are representative with diverse features and most of them are popular.
note that our approach is not limited to specific app types.
dmf specifications .
according to the app feature we selected one major data type per app and defined the specifications of the relevant dmfs .
specifically we defined the dmfs in terms of create read update delete andsearch .
given the target data type we defined one dmf ofcreate read and search respectively and all the dmfs ofupdate anddelete .
because all the update and delete may affect the app data added by create .
thus some apps e.g.
amaze may have more than five dmfs as they have multiple dmfs forupdate anddelete while others e.g.
aard2 may have fewer than five dmfs as they do not have some types of dmfs .
for example one major data type of the app amaze in figure is folder and we defined its seven relevant dmfs i.e.
create folder view folder rename folder delete folder hide folder unhide folder and search folder .
in table data type dmfs gives the selected data type for which we defined thedmfs and the number of defined dmfs .
note that we selected only one data type because it is already enough to demonstrate the feasibility and effectiveness of our technique see the results ofesec fse december san francisco ca usa jingling sun ting su jiayi jiang jue wang geguang pu and zhendong su rq1 .
it is not a conceptual or technical limitation of our technique.
if we consider more data types and more dmfs we expect to find more dmes .
the numbers of selected data types or dmfs are orthogonal to our approach and do not affect pbfdroid s scalability or effectiveness.
in practice the exact number of dmfs we can test for an app is decided by the relevant app features.
evaluation setup of rq1.
we ran the 17open source apps on android emulators pixel xl android .
deployed on a bit ubuntu .
machine cores amd 2990wx cpu and 64gb ram and the 3industrial apps on one real android device oppo a11s android .
.
we allocated machine hours for extensively testing each app and configured the maximum length of one gui test generated by pbfdroid as events.
for each app we manually inspected all the reported bugs to find the distinct ones which have different bug triggering tests and manifestations.
then we reported each distinct bug to the app vendors.
each bug is provided with a bug reproducing test and video to ease confirmation and diagnosis.
if a bug is not marked as duplicated by the app vendors we regard it as a unique bug.
evaluation setup of rq2 .
two major categories of automated gui testing tools for android exist based on the oracle problem .
one category of tools can automatically find non crashing bugs.
in this category genie and odin are the only two tools which can find generic non crashing bugs which may find dmes .
thus we selected genie andodin for comparison.
we did not select other tools because they target other specific types of non crashing bugs rather than dmes .
we will discuss the differences between these work and ours in section .
the other category of tools e.g.
monkey is limited to crash bugs due to the lack of strong test oracles .
although pbfdroid focuses on finding non crashing bugs we still selected monkey for comparison.
specifically we allocated the same hours for genie odin andmonkey to test each of the 17open source apps in the same experimental environment.
genie andodin were setup with their default settings in their original papers .
we manually inspected all the bugs reported by genie odin andmonkey to see whether they can find the dmes uncovered by pbfdroid .
evaluation setup of rq3 .pbfdroid interleaves different dmfs and other possible events to generate diverse program states.
thus we investigated whether different interleaving strategies could affect the bug finding abilities of pbfdroid .
specifically we setup two baseline strategies for comparison baseline a .
baseline a only tests one single dmf without interleaving with other possible events.
specifically given one dmf we manually identify the shortest event trace from the app starting page to the gui page satisfying the precondition of the dmf e.g.
figure a d is a qualified event trace for the dmf rename folder .
during testing baseline a always follows this event trace to reach this dmf executes the events of the dmf randomly generates necessary text inputs for some events e.g.
edit of the dmf and checks the postcondition.
baseline b .
baseline b interleaves one single dmf with other possible events .
it corresponds to algorithm when the input dmflist only contains one dmf under test.
we allocate the same testing time hours per dmf in each of the 17open source apps and experimental environment forbaseline a and b and compare them with pbfdroid .
baselines a and b will not terminate before reaching the time bound because they are set up for running continuously.
additionally our experiment sets the default maximum length of each gui test lmax see algorithm line as events.
lmax constrains the possible interleavings between dmfs and other possible events and thus may affect the tool s effectiveness.
thus we evaluated the other two configurations of lmax i.e.
and events per test respectively with the same testing time hours per app and experimental environment to test the 17open source apps and compared the numbers of found bugs.
roughly 40k gui events can be generated in the hour testing time for each app.
evaluation setup of rq4 .
we recruited 10graduate students to study the manual cost of defining dmf specifications.
the number of participants in our study is similar to those of prior relevant work which recruited and students respectively .
all these students major in software engineering and have basic knowledge on android and none of them was from the environment ofpbfdroid developers or this paper s authors.
they voluntarily participated in this study and signed the informed consent .
note that it is reported that graduate students can represent professionals e.g.
developers or testers in the software engineering experiments .
in this study we let the participants define the same set of dmfs used in rq1 rq3.
specifically we selected the appmarkor a text editor app from our subjects to record a video tutorial about minutes illustrating how to define dmf specifications.
to avoid biases we excluded markor from the study.
for the remaining open source apps in table we randomly assigned each participant eight apps at the same time we make sure each app is evaluated by five different participants to ensure diversity .
to mimic the realistic testing environment in which app developers or testers are familiar with app functionalities each participant was provided with the necessary information about the dmfs via recorded videos which explain the ui steps of dmfs and their functionalities see the discussion paragraph in section .
.
during the study we recorded the whole process of participants activities on a desktop and counted their time spent on defining each dmf specification including the time of generating dmfs by interacting with dmf instantiator adding additional necessary preconditions to the generated specification and self checking the defined dmfs .
we validated the accuracy of the final dmf specifications.
.
results for rq1 effectiveness of pbfdroid .
table shows the bug finding results.
it gives the app name the bug id the bug state fixed confirmed or pending related dmfs which are necessary for bug manifestation the length of minimal bug reproducing test in the number of ui events consequence and a brief description of the bug.
pbfdroid found 30unique and previously unknown bugs in 18out of the tested apps.
out of these 30bugs 29bugs are dmes of which are non crashing bugs and are crash bugs.
to date 19bugs have been confirmed and 9have already been fixed while the remaining are still pending none of them was rejected .
the remaining bugs are still under active discussions between developers.
specifically dmes require the combination of two or more dmfs for bugproperty based fuzzing for finding data manipulation errors in android apps esec fse december san francisco ca usa table bug finding results of pbfdroid .
app name issue id issue state related dmfs steps consequence description markor fixed create search wrong behavior no files can be searched in the root directory fixed create update wrong behavior renaming will fail if new name contains ?
fixed create update search data loss renaming will overwrite the same case sensitive name files fixed search crash rotating the screen after searching causes a crash fixed create update crash rotating the screen while editing will cause a crash aard2 fixed create search wrong behavior symbols in search text are ignored when searching simpletask confirmed create search wrong behavior searching again after canceling a search will not work skytube pending create delete search wrong behavior the function of clearing the blocked channel list is unstable confirmed create search infinite loading refreshing video list after blocking any channel causes infinite loading anymemo pending create update update delay the card list is not updated in time after editing any card pending create search data loss the reset all preferences option will delete the added card amaze fixed create search infinite loading searching for hidden folders causes crashes or infinite loading confirmed create search update wrong behavior renaming will fail on the search results page confirmed create search wrong behavior search results are not sorted by relevance ankidroid fixed create read wrong behavior cards that use the wrong card template will show up empty confirmed create update read wrong behavior cards cannot be edited when their type is changed to cloze fixed create crash saving an empty video in card causes a crash wikipedia t305555 fixed create update search update delay cannot search the favorites by new name after renaming the favorites tasks confirmed create read wrong behavior tasks can be filtered by other criteria but not by date radiodroid pending crash long pressing the radio information in the history causes a crash activitydiary fixed search crash rotating the screen after entering invalid date in the search bar cause a crash pending create delete crash deleted activity cannot be recovered correctly materialistic pending read crash rotating the screen before selecting zoom in or zoom out causes a crash notepad pending create read wrong behavior the layout is inconsistent using the right to left layout setting transistor pending create crash pressing the keyboard s next key while editing causes a crash omin notes confirmed create delete search wrong behavior deleted items can still be searched tiktok confirmed create read wrong behavior videos of blocked users can still be seen in the recommendation page pending create read update delay the status is not updated in time after unblocking the user capcut confirmed create read wrong behavior videos of blocked users can still be seen in the recommendation page feishu pending create update search update delay cannot search the folder by new name after renaming the folder manifestation.
these results show that pbfdroid is effective.
moreover we received positive feedback from app developers who commented the found bugs are important and non trivial.
for example skytube s developer commented this bug is really important and annoying and ankidroid s developer commented it s a lot more complicated than i thought at first glance .
diversity of bugs found by pbfdroid .pbfdroid found 22noncrashing dmes of different consequences.
we classified them into four types and illustrate some assorted bug samples.
unexpected wrong behaviors 22bugs dmes lead to unexpected wrong app behaviors.
for example simpletask a task management app has a search function.
if a user searches again after canceling a previous search the user will not be able to find any matching results.
delayed data update 22bugs dmes lead to delayed data update.
for example in wikipedia if a user changes the name of the favorite the user will not be able to search the favorites via the new name for a long time.
user data loss 22bugs dmes lead to severe user data loss.
for example anymemo a flashcard learning app has a creation function for users to add their own cards.
however due to an error in this function if a user selects the option reset all preferences in the app setting all the user added cards will be unexpectedly deleted from the database.
infinite loading 22bugs dmes lead to infinite loading.
for example in skytube if a user adds a channel to the blocked list and then refreshes the video list the app will enter into infinite loading and do not respond anymore.
.
results for rq2 we find that genie odin andmonkey missed all the 22noncrashing dmes found by pbfdroid and they only found and out of the crash bugs found by pbfdroid respectively.
we further analyzed the results of genie andodin to understand the reasons why they missed all the non crashing dmes .
we find two major reasons.
first their automated oracles are limited in finding dmes .genie finds non crashing bugs based on the independentview property that is interacting with one gui view should not affect the states of the others and only adds additional gui effects.
however we find many of the dmes are not within the scope of this generic oracle.
for example the amaze s bug in figure cannot be detected by genie as no independent view exists for folder old name .
odin uses a heuristic oracle to find non crashing bugs that is appending the same events to the test inputs terminating at similar gui layouts and clustering the manifested behaviors to identify the minorities as suspicious bugs.
however one abstraction rules used by odin ignores the texts displayed on the gui pages when clustering.
as a result it cannot identify those bugs which lead to incorrect displayed texts.
for example in figure o the folder old name is not correctly renamed which thus cannot be captured by odin .
second their randomly generated tests are of low quality .
many tests generated by genie andodin did not cover meaningful app functions.
as a result it is difficult for them to explore diverse app states to find dmes which may require long and specific event traces see steps in table .
as a side note genie andodin reported many false positives which took us much time for inspection.
these results show that pbfdroid can complement the state of the art techniques in finding dmes.
.
results for rq3 table compares baseline a b and pbfdroid in the numbers of found bugs.
baseline a and b only found and bugs respectively.
moreover allthe bugs found by baseline a and b were found by pbfdroid .
thus pbfdroid is much more effective than baseline a and b. it indicates that interleaving different dmfs and other possible events is crucial for improving the bug finding ability.
baseline b is limited due to two major reasons.
first most of thedmes .
requires combining two or more dmfs for bug manifestation.
when interleaving one single dmf with other possible events baseline b may not be able to cover other dmfs by random exploration.
for example to find the bug of rename folder in figure baseline b has to create a folder old name switchesec fse december san francisco ca usa jingling sun ting su jiayi jiang jue wang geguang pu and zhendong su table comparison between baseline a baseline b and pbfdroid .
c and nc represent crash and non crashing bugs respectively.
tool baseline a baseline b pbfdroid failure type c nc c nc c nc bugs figure number of found unique bugs under different lmax.
to the up level directory and search folder old name via random exploration which is difficult.
in our experiment baseline b only finds bugs which require two dmfs .
second because baseline b only considers one single dmf it cannot simulate the data changes when other dmfs are covered by chance.
for example if baseline b tests a search dmf the data added by create cannot be checked because that data will not be recorded.
baseline a is further limited because most dmfs only fail in some corner cases when running independently.
however baseline a cannot reach such cases due to the lack of some random events.
for example ankidroid s card editing function fails only when the default card type is changed which can only be covered by a random event .
comparison between different lmaxs.
figure compares the tool effectiveness under the configurations of and events per test which are denoted by the black grey and red curves respectively.
the horizontal axis denotes the hour testing time and the vertical axis denotes the number of found unique bugs.
we can see that the three configurations of lmax do not have distinct impacts on tool effectiveness.
whenlmax is set as pbfdroid can find bugs more quickly because it may interleave more dmfs in one gui test but at last the three configurations found the same numbers of unique bugs on the open source apps.
.
results for rq4 figure shows the time cost of defining one single dmf denoted by the white boxes and all the dmfs denoted by the red boxes for each of the open source apps evaluated by five different participants respectively.
the horizontal axis gives the app names and the vertical axis gives the time in minutes.
from figure we find that the time cost of defining one single dmf across all the apps ranges from minutes with an average of minutes and the time cost of defining all the dmfs per app ranges from minutes with an average of minutes.
because some apps e.g.
anymemo have more dmfs than the other apps.
they took more time than the others.
overall the time cost of defining the dmf specifications is reasonable.
allthe participants commented that pbfdroid is convenient to use.
as a side note we find that most of thedmf specifications defined by participants i.e.
out of the .
dmf specifications are accurate.
we analyzed the inaccurate dmfs and found the inaccuracies were caused by some trivial mistakes of participants e.g.
clicking a wrong ui widget when recording a dmf confused with the resourceid anddescription figure time cost of participants in our study spent on defining one single dmf and all the dmfs per app.
fields of a ui widget when adding additional preconditions.
we believe these issues are orthogonal to our technique and can be mitigated by better engineering e.g.
giving warning messages .
discussion this section provides an extended discussion of our work in the following three aspects dmf specifications generability of our approach and threats to validity.
dmf specifications .
in our experiment we carefully inspected the app features when defining dmfs .
thus we did not incur any false positives.
defining dmf specifications requires human participation similar to writing program specification in formal verification but the involved effort is one time.
even if an app upgrades only a slight revision is needed.
moreover our examination on the 30found bugs shows that these bugs are nontrivial and escaped from developer testing for a long time.
on average they had been hidden for months and affected release versions.
thus the benefits outweigh the spent effort.
generability of our approach .
despite our approach focusing on finding dmes .
this property based fuzzing pbf approach has broader applicability.
when the property pre e post is instantiated on other app functionalities pbfdroid can help automatically find the other types of bugs in android apps.
for example if we define the property of some registration functionality in the app our approach can check whether the registration can always succeed.
in the future we will explore how to extend property based testing for more generic app properties .
threats to validity .
the first threat is the representativeness of app subjects.
to this end our study includes different categories of open source and industrial apps many of which are popular on github and google play.
thus they can represent real world apps.
the second threat is the human factors in the user study which may cause inaccuracies or biases.
to this end we instructed the participants by providing informative tutorials and video recorded all the activities of participants during the study to carefully measure the time cost.
moreover each dmf is evaluated by five different participants to mitigate possible biases.
related work finding non crashing bugs for android apps .
most automated gui testing tools use runtime exceptions as the oracle .
therefore they cannot find the noncrashing dmes which our work focuses on.
to tackle the oracle problem three major categories of testing techniques have been proposed.
table compares the representative work in these categories which we explain as follows.
the first category of priorproperty based fuzzing for finding data manipulation errors in android apps esec fse december san francisco ca usa table differences between existing testing tools and ours in finding non crashing bugs of android apps.
tool what to provide before testing?
types of test oracle genie metamorphic relations odin implicit knowledge appflow modular tests pseudo oracles chimpcheck example based tests assertions pbfdroid specification model based specification work adopts metamorphic relations to generate automated oracles.
however most of these work targets specific types of non crashing bugs e.g.
system setting related defects data loss issues .
only genie targets generic non crashing bugs but it missed all the non crashing dmes due to the limitation of its metamorphic relation discussed in section .
.
the second category uses differential analysis or testing .odin finds non crashing bugs by differing the buggy and normal app behaviors based on the heuristic oracle bugs as deviant behaviors .
but it missed all the non crashing dmes due to the limitation of its abstraction rule discussed in section .
.
some work uses differential testing to find non crashing compatibility bugs based on different devices.
they cannot find dmes .
the third category synthesizes the tests for one app manually constructed to test another app with similar features.
appflow synthesizes from the modular abstract tests.
however these work does not target dmes .
the synthesis accuracy is not high which may lead to many false positives .
in contrast pbfdroid can automatically generate gui tests without false positives.
to our knowledge chimpcheck is the only work applying property based testing for android apps.
however chimpcheck andpbfdroid have two key differences.
first chimpcheck s main contribution is its novel ui trace generators which can fuse example based tests with random testing e.g.
monkey to generate test inputs.
it does not focus on finding non crashing bugs including dmes .
second chimpcheck uses the assertions in the user provided example based tests as the oracle.
pbfdroid uses the user specified model based properties as the oracle.
due to the limited expressiveness the assertions are difficult to validate dmfs when different dmfs are interleaved in our setting.
therefore if adapted in our scenario by manually providing example based tests for the dmfs chimpcheck can only reach the ability of baseline b in our evaluation see section .
.
property based testing and model based testing .
propertybased testing pbt was popularized by claessen and hughes .
specifically the two key elements of pbt are the data generators and the property specifications.
in our work the data generator is designed to generate random ui based event traces by interleaving the dmfs and other events and the properties are specified in the model based properties an abstract model capturing data update effect of the dmfs in the apps .
our work is different from the prior pbt work in two aspects.
first the prior work designs the data generators for their own specific domains which cannot be applied for android apps.
second these prior work specifies the properties in theassertions or temporal logic formula which are not suitable or expressive to capture the data updateeffect in our setting.
to our knowledge few work in the literature combines pbt with the model based properties .
on the other hand using an abstract model as the specification is the foundation of model based testing mbt .
a lot of work exists in applying mbt to test android apps.
however the models in these work are the finite state machine based ui models in which each state is an abstract ui layout and each edge is a ui event which are used to guide test generation rather than deriving the oracles.
these models are different from the model in our work.
therefore all of these mbt work cannot find non crashing bugs.
finding the errors related to crud .
our work finds software errors related to the crud operations.
costa et al.
model the find operation i.e.
search in android apps as one ui test pattern to check its correctness.
mariani et al.
specify the crud operations of web apps in alloy specification language and build a tool augusto to generate semantic tests with oracles.
however augusto only tests one crud operation independently and does not consider their combinations.
since a direct comparison is infeasible as augusto targets web apps baseline a in our evaluation see section .
can be viewed as a similar implementation of augusto .
our approach which interleaves different dmfs of crud operations is shown to be much more effective than baseline a. some work uses metamorphic testing to find the crud errors in database management systems.
conclusion we introduce a property based fuzzing approach to effectively findingdmes which combines the idea of property based testing and model based properties.
given some type of app data we interleave different dmfs and other possible events to generate diverse app states for validation.
the realization of our idea pbfdroid has successfully discovered 30previously unknown bugs from 20popular android apps.
among these bugs 22are non crashing dmes which cannot be found by the state of the arts.
so far 19have been confirmed and 9fixed by the developers.
the majority out of cause non crashing failures and are hard to be detected by state of the art automatic testing tools.
data availability we have made all the artifacts including pbfdroid and its source code the defined dmf specifications of all app subjects the data of the user study publicly available at .