solsee a source level symbolic execution engine for solidity shang wei lin shang wei.lin ntu.edu.sg nanyang technological university singaporepalina tolmach palina001 ntu.edu.sg institute of high performance computing a star nanyang technological university singapore ye liu li0003ye ntu.edu.sg nanyang technological university singaporeyi li yi li ntu.edu.sg nanyang technological university singapore abstract most of the existing smart contract symbolic execution tools perform analysis on bytecode which loses high level semantic information presented in source code.
this makes interactive analysis tasks such as visualization and debugging extremely challenging and significantly limits the tool usability.
in this paper we present solsee a source level symbolic execution engine for solidity smart contracts.
we describe the design of solsee highlight its key features and demonstrate its usages through a web based user interface.
solsee demonstrates advantages over other existing source level analysis tools in the advanced solidity language features it supports and analysis flexibility.
a demonstration video is available at ccs concepts software and its engineering development frameworks and environments software verification and validation .
keywords smart contract symbolic execution acm reference format shang wei lin palina tolmach ye liu and yi li.
.
solsee a sourcelevel symbolic execution engine for solidity.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
.
introduction symbolic execution is a program analysis technique which explores multiple execution paths of a program by assigning symbolic instead of concrete values to variables.
for each analyzed execution path a symbolic execution engine maintains a path condition a first order boolean formula that describes the conditions satisfied by the branches taken along that path and a symbolic memory store that maps variables to symbolic expressions or values.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
off the shelf constraint solver is typically used to determine the feasibility of each explored path based on the generated path condition formula .
symbolic execution is commonly used to systematically explore the program space and detect property violations as well as security vulnerabilities.
in recent years symbolic execution has been extensively applied on smart contracts computer programs that run on blockchain and govern billions of dollars which brings paramount importance to the security and correctness of the contract code .
most smart contracts are written in solidity a high level programming language of the ethereum blockchain platform which compiles into evm bytecode for deployment and execution on the blockchain.
listing shows a sample solidity implementation of a token smart contract.
in ethereum users interact with a smart contract by initiating transactions that invoke its functions with public orexternal visibility.
token sdeposit function lines allows the contract to accept eth a native cryptocurrency of ethereum and records the deposited amount msg.value in a balances mapping entry associated with a transaction sender msg.sender .
the recover function lines sends all eth balance of token to its owner the address that performed contract deployment i.e.
creation which involved the execution of a constructor function lines .
access control on recover is implemented using the functionality of the ownable smart contract lines that token inherits from line .
thus the signature of recover line contains an invocation of the onlyowner modifier lines .
the modifier adds additional behavior such as a prerequisite line to a function body which replaces in a modifier code line .
the transfer of eth line is performed via ethereum s built in .call.value function call.
given a smart contract written in solidity solsee symbolically represents the storage memory configuration of the smart contract and executes each statement based on the operational semantics of solidity .
our developed operational semantics for solidity supports many important features including inheritance modifiers eth transfer and others.
during symbolic execution this representation is directly used to determine satisfiability of the generated path constraints using z3 smt solver .
to facilitate efficient exploration of interesting smart contract behaviors in a realistic setting solsee supports user defined harness function that specifies the sequence of function calls to be analyzed symbolically.
the harness definition follows exactly the syntax and semantics of solidity which is intuitive and easy to use for developers.
listing illustrates how to define a harness in solsee .
the main contract serves as the entry point similar to the main 1687esec fse november singapore singapore shang wei lin palina tolmach ye liu and yi li 1contract ownable address internal owner constructor address owner public owner owner modifier onlyowner require owner msg.sender contract token isownable mapping address uint256 public balances string public name constructor string memory tokenname ownable msg.
sender public payable name tokenname deposit function deposit public payable balances msg.value function recover public onlyowner owner .
call .value address this .balance listing source code of the token smart contract function in c and the harness is defined as a constructor of it.
the harness contains the declaration of a symbolic variable which should come with the prefix line and the creation of the token smart contract which involves transferring a symbolic amount of eth to this contract line .
the harness also includes a call to thetoken srecover function which is executed successfully because the call is invoked by the main contract satisfying the onlyowner modifier.
lines show the definition of a fallback function another solidity specific feature supported by solsee .
here the fallback function is invoked when eth is transferred to a smart contract i.e.
upon the execution of the .call.value in listing line .
since the execution of recover succeeds the assertion in listing line should always be satisfied.
the assertion in a harness function can also be used to declare a property which can be constructed using solidity operators and variables available in the main contract.
in addition solsee allows assumptions to be specified in terms of smart contract s variables using the assume statement.
for example line in listing indicates that the analysis will only be concerned with the paths where the eth balance of the main contract is not less than the amount of eth being sent to token upon its creation.
related work.
most of the existing symbolic execution tools for smart contracts operate on bytecode rather than source code level which retains limited semantic information about the smart contract and hence complicates reasoning about high level properties of a smart contract.
most of these tools focus on detecting wellknown vulnerabilities based on a certain pattern appearing in smart contract bytecode e.g.
oyente mythril maian etc.manticore is a bytecode level symbolic execution engine which supports property based symbolic execution and provides users with some control over the state exploration process.
while manticore also offers a gui plugin it visualizes low level bytecode instructions which are difficult for a developer to match1contract main token token bool fallbackexecuted constructor public uint amount assume address this .balance amount token new token .
value amount ot token .
recover assert fallbackexecuted function external payable fallbackexecuted true listing solidity source code of the harness contract with their original solidity source code statements.
meanwhile existing source level tools for solidity smart contracts offer limited support for solidity features and or do not allow customization of the function call sequence and the environment to be analyzed.
for example verismart is a smart contract verifier that is also used in smartest to perform symbolic execution of smart contracts.
these tools do not precisely handle the execution of fallback functions and inter contract function calls which constitute essential functionality of smart contracts.
inter contract function calls are also not analyzed precisely by smtchecker a built in verifier within the solidity compiler.
two other source level tools solc verify and verisol translate solidity code into boogie intermediate language which can introduce discrepancy between the analyzed code translation and original solidity semantics.
in addition they also lack support of certain solidity functionality and do not allow customization of the harness function and analyzed environment which leads to multiple false positives reported by these tools as shown in sect.
.
esbmc solidity translates solidity into an intermediate representation of esbmc which may introduce semantics discrepancy and it does not support certain solidity features such as polymorphism and inheritance.
contribution.
in this demonstration paper we present solsee a user friendly symbolic execution engine for analyzing source code of one or several interacting smart contracts written in solidity.
the key features of solsee can be summarized as follows precise operational semantics.
solsee symbolically represents the configuration of smart contracts and executes each program statement based on the exact operational semantics for solidity version .
.
user defined harness function.
solsee facilitates analysis and debugging of smart contracts by allowing users to define the harness function to control the function call sequence for verification.
solsee detects and reports unsigned integer underand overflow and checks the validity of assertions which can be used to specify custom high level properties of the analyzed smart contracts.
smart contract debugging.
with the symbolic paths generated bysolsee users can debug smart contracts.
users are able to visualize the execution details corresponding to the symbolic paths step by step in a web user interface.
methodology in this section we introduce the design and usage of solsee .
1688solsee a source level symbolic execution engine for solidity esec fse november singapore singapore smart contractharness functionpropertyinputoperational semanticssymbolic path exploration propertycheckingsolseesymbolic execution web uiast generationsolcz3 smt solver analysis resultsolseevisualizersolseebackend figure tool architecture.
.
design solsee was implemented with lines of c code and currently supports smart contracts written in solidity v0.
.
figure demonstrates an overview of the tool architecture.
solsee takes one or more smart contracts and a harness function as input which should be provided using a web ui.
in its backend solsee uses a solidity compiler solc to generate the ast for the given contracts.
then solsee symbolically executes each statement by traversing the ast based on the solidity operational semantics.
the storage memory configuration of the smart contract is encoded symbolically as z3 types .
also the smt solver is used to discharge the feasibility queries of symbolic paths and validity queries of assertions.
the latter helps prove or disprove the user defined properties encoded as assertions in the harness function.
solsee does not bound the loop iterations and may unroll the loops infinitely.
this can be addressed by requesting the user to provide a loop invariant or generating one automatically which is left for future work.
the frontend of solsee is based on the remix ide which is implemented as a reactjs application.
the frontend of solsee communicates with its backend via restful apis.
solsee also provides a debugging capability and helps developers examine the operation of a smart contract by visualizing its symbolic execution in detail.
its usage is presented in sect.
.
.
the symbolic execution module of solsee supports a majority of the solidity language features including the intra and intercontract function calls multiple inheritance library support via the using ... for construct low level function calls such as .call.value with the associated fallback mechanism modifiers and many others.
similarly to the solidity compiler solsee automatically generates getter functions for public smart contract variables of elementary types.
similar to other source level analyzers for smart contracts solsee does not support inline assembly.
solsee also introduces a supplementary assume statement that can be used to specify assumption conditions when verification is performed as shown in listing line .
insolsee require andassert have different semantics although in solidity both functions could lead to a transaction with all its effects on the state being reverted if the required asserted condition is not satisfied.
in solidity require is used to check a condition that is expected to fail occasionally e.g.
a guard condition on function input arguments.
thus should the expression enclosed inrequire evaluate to false solsee rollbacks all effects of the transaction on the smart contract state.
we consider each statementin the harness function as one transaction.
semantics of assert correspond to its purpose in solidity it is used to check conditions that should never evaluate to false.solsee stops execution and reports a violation if the asserted condition is violated.
in addition solsee also reports possible integer under and overflows a common issue in solidity smart contracts which heavily utilize unsigned integers to store important information such as token balances .solsee takes a modular arithmetic approach to handling unsigned integers of various sizes from uint8 touint256 it models them using z3 integers constrained by range assertions to follow the semantics of unsigned integer arithmetic operations in solidity.
although using bitvectors is another popular approach to model unsigned integers it has been shown to have scalability issues.
to model one and multi dimensional arrays and mappings solsee relies on the array theory.
the symbolic execution process of a smart contract is guided by the harness function provided by the user to orchestrate the interactions with the analyzed smart contract s .
during path exploration and assertion property checking solsee relies on z3 an smt solver to resolve constraints.
using a harness function makes symbolic analysis performed by solsee highly configurable which is necessary to effectively and efficiently analyze complex smart contract code in a realistic setting which is demonstrated by our evaluation shown in sect.
.
additionally a harness can also be used to encode properties about the execution trace or smart contract invariants in a form of assertions.
to optimize tool performance smart contract variables in a harness or analyzed smart contracts are assumed to have concrete default values unless they are declared as symbolic.
ethereum balance of a harness main smart contract is assumed to be symbolic too.
.
usage solsee has both a command line interface and a gui.
given a file that contains solidity source code of all smart contracts to be analyzed e.g.
token.sol symbolic execution via solsee can be invoked using the following command .
solsee symexe main .
token.sol figure shows the web gui of solsee .
the ui is built on the remix ide framework and allows users to do the following develop smart contracts in the smart contract panel customize the main contract serving as the harness for analysis and verification in the harness contract panel click on the symbolic execution button to trigger the symbolic execution of solsee to obtain a set of symbolic paths visualize the detail of each symbolic path in the result panel click on the debugging button for further debugging.
the detailed description of each step can be found in the appendix.
insolsee we consider a small step operational semantics.
thus if a statement includes several function calls users need to separate function calls into different statements.
for example the following statement with two function calls a f g can be rewritten into three statements t1 f t2 g a t1 t2 .
while it is not convenient in syntax it forces the developer to explicitly specify the order of function evaluation which is not specified in the official solidity document .
this enforcement eliminates ambiguity for analysis and verification especially when 1689esec fse november singapore singapore shang wei lin palina tolmach ye liu and yi li table evaluation results.
smart contract feature solsee verisol verisol sp solc verify verismart smtchecker token token implementation multiplemodifiers two modifiers applied to one function fallbackfunction fallback function execution getterfunction auto generated getter functions safemathlibrary using library functions on uint multipleinheritance multiple inheritance via c3 linearization structs arithmetic operations on struct newbytesarray newdynamic memory array of bytes32 uintoverflow uint8 overflow detection revert proper handling of revert in a function the code is analyzed correctly only in the absence of external function calls non default modular arithmetic mode must be used figure the web user interface of solsee .
both f andg have side effects on state variables and different execution orders may lead to different results.
evaluation in this section we demonstrate the capabilities of solsee and compare it with other source level tools for solidity smart contracts.
the tools we compare with include solc verify verisol v0.
.
and its modified version used in smartpulse denoted as verisol sp in table verismart and smtchecker included in solc v. .
.
.
all these tools claim that they can identify assertion failures which is the capability we perform the evaluation on.
we could not run exgen due to compilation issues.
esbmc solidity cannot process smart contracts even from its own documentation so we do not compare with it as well.
we evaluated solsee and these tools on our running example listing and a dataset of nine different features present in solidity.
table summarizes how these features are supported by different tools.
each of the nine features has one corresponding smart contract as shown in the first two columns of table .
our results demonstrate that all tools used for comparison lack support of certain solidity features except solsee .
for example verisol does not support modifiers with multiple statements witness multiplemodfiers .verismart cannot handle fallback functions witness fallbackfunction or correctly analyze arithmetic operations on variables of unsigned integer uint types witness uintoverflow .solc verify andverisol follow the semantics of arithmetic operations for uint in solidity only if a non default modular arithmetic mode is enabled.
solc verify fails to process a bytes32 array in newbytesarray while variables of type struct are not supported by smtchecker witness structs .
in addition our results show that the analyzed tools report potential violation of numerous assertions which are in fact false positives e.g.
solc verify supports most solidity features used in experimental smart contracts but in many of them it reports all assertions as potentially failing .
we attribute this fact to the lack of harness function support and missing or incorrect handling of solidity language features and their semantics.
for example none of these tools except solsee andsmartpulse correctly implement c3 linearization that solidity uses to decide the order in which methods are inherited in the presence of multiple inheritance witness multipleinheritance .
besides while verismart and smtchecker process some of our smart contracts correctly they can only do so if all the functionality is stored in a single contract i.e.
no external function calls allowed.
in terms of the speed of analysis our tool is as efficient as other tools used for comparison.
in closing solsee has a unique source level gui that visualizes the symbolic execution process which facilitates debugging.
conclusion this paper presents solsee a user friendly symbolic execution engine for smart contracts written in solidity.
solsee offers a large degree of customization which enables highly effective symbolic analysis of real world smart contracts under realistic settings.
our evaluation shows that solsee is useful in analyzing interacting smart contracts in an efficient manner based on the user defined harness function and assertions.
solsee also facilitates analysis and debugging of solidity smart contracts through a source level visualization of symbolic execution in a gui.
data availability the binary of solsee and experimental smart contract dataset used for the evaluation are available on our website .
the release of solsee source code is pending approval from the funding agency.
1690solsee a source level symbolic execution engine for solidity esec fse november singapore singapore