demystifying the dependency challenge in kernel fuzzingyu haouc riversideriverside usayhao016 ucr.eduhang zhanggeorgia institute of technologyatlanta usahzhan033 ucr.eduguoren liuc riversideriverside usagli076 ucr.eduxingyun duuc riversideriverside usadxing003 ucr.eduzhiyun qianuc riversideriverside usazhiyunq cs.ucr.eduardalan amiri saniuc irvineirvine usaardalan uci.eduabstractfuzz testing operating system kernels remains a daunting task todate.
one known challenge is that much of the kernel code is lockedunder speci f ic kernel states and current kernel fuzzers are not ef fective in exploring such an enormous state space.
we refer to thisproblem as the dependency challenge.
though there are some ef forts trying to address the dependency challenge the prevalenceand categorization of dependencies have never been studied.
mostprior work simply attempted to recover dependencies opportunisti cally whenever they are relatively easy to recognize.
in this paper we undertake a substantial measurement study to systematicallyunderstand the real challenge behind dependencies.
to our surprise we show that even for well fuzzed kernel modules unresolved de pendencies still account for of the uncovered branches.furthermore we show that the dependency challenge is only asymptom rather than the root cause of failing to achieve more cov erage.
by distilling and summarizing our f indings we believe theresearch provides valuable guidance to future research in kernelfuzzing.
finally we propose a number of novel research directionsdirectly based on the insights gained from the measurement study.acm reference format yu hao hang zhang guoren li xingyun du zhiyun qian and ardalanamiri sani.
.
demystifying the dependency challenge in kernel fuzzing.in44th international conference on software engineering icse may21 pittsburgh pa usa.acm new york ny usa pages.
introductionfuzzing has become one of the most popular and essential methodsfor uncovering bugs and vulnerabilities due to its practicability ande ectiveness.
both academia and industry have devoted a largeamount of resources to researching and deploying fuzzing systems.for example google allocated more than servers to deployits clusterfuzz infrastructure and has found tens of thousands ofvulnerabilities so far .this work is licensed under a creative commons attribution international .
license.icse may pittsburgh pa usa copyright held by the owner author s .acm isbn .
despite the continuous research e orts and improve ments on fuzzing techniques fuzzing sophisticated stateful software e.g.
os kernels remains a big challenge.
even with the state of the art kernel fuzzer syzkaller the achievable code coverageof various kernel modules is generally low from our measurements from to after extensive fuzzing sessions.one common belief of the major obstacle is that a large portionof code can only be covered under speci f ic kernel states e.g.
someglobal variables need to be set to speci f ic values .
it is known to bedi cult for a fuzzer to search the enormous state space and enterthe desired ones.
this problem cannot be easily solved by simplyadopting advanced mutation strategies that operate solely on localinputs e.g.
function arguments since many conditions in the codeare controlled by global memory which may need to be set by acompletely di erent function syscall invocation .
in this paper werefer to this challenge as thedependency challengein fuzzing oskernels.in recent years there have been a few related works that madesome progress in tackling this challenge.
moonshine aimsto recognize dependencies from manually curated test cases e.g.
linux testing project and distill them into more concise seedsfor fuzzing.
however its goalis not to discover and analyze newdependencies.
hfl applies static analysis and symbolic execu tion to solve a subset of dependency issues.
although it manages toachieve improvements on code coverage compared to the baseline according to our measurement its result is still far from satisfactory e.g.
only .
of linux kernel code can be covered during a hour fuzzing session .
furthermore it still remains unknown whattypes of dependencies are resolved and how large of a fraction theyrepresent.
in general due to the lack of a deep and quantitativeunderstanding of the dependency challenge we argue that currentresearch has only explored the surface of this challenge.in this paper we take a data driven approach to systematicallyunderstand the dependency challenge in kernel fuzzing with anin depth measurement study on a subset of linux kernel modules.speci f ically we aim to answer the following questions how well does the state of the art fuzzer perform e.g.
re garding code coverage against the complex and stateful kernel?how many uncovered branches are related to dependencies?
wespeci f ically focus on well fuzzed kernel modules as the results willrepresent the di cult cases that are worth solving in the future.
what are the root causes behind unresolved dependenciesand how important are they?
though the community has been ieee acm 44th international conference on software engineering icse icse may pi t tsburgh pa usayu hao hang zhang guoren li xingyun du zhiyun qian and ardalan amiri saniaware of the dependency for years it is still unclear what the rootcauses are for fuzzers failure to resolve the dependency.
what can we do to address unresolved dependencies?
withthe understanding of root causes we hope to shed light on potentialsolutions and draw attention to blind spots in current researchdirections.to answer these questions we develop a pipeline of measurementinfrastructure including a combination of automated components fuzzing and static analysis and meticulous manual investigationswhenever necessary to get to the root causes that are otherwisedi cult to obtain.
through our measurement study we not onlydiscover that the dependency challenge is ubiquitous but also f inda diverse set of root causes which need focused e orts movingforward.
for example as will be discussed in we suggest thatmulti syscall analysis and multi interface fuzzing are two promisingdirections.
furthermore we show that much of the kernel codeis simply impossible to be covered dead code without a properenvironment.
we believe the curated dataset from our study isvaluable in guiding future research in kernel fuzzing.we summarize our main contributions as below to the best of our knowledge we are the f irst to perform an in depth measurement and systematic analysis on the dependencychallenge in kernel fuzzing.
we develop a measurement pipeline including automated com ponents that can quantify the magnitude of the dependencychallenge.
we will open source the measurement pipeline anddata to facilitate future research.
based on our measurement results and deep understanding of thedependency challenge we reveal many unexpected observationsand point to new research directions that will improve kernelfuzzing.
background2.
de f initionthis section gives some de f initions to help explain the challengesof resolving dependencies and the root causes of uncovered code.unresolved condition uc .we de f ine an unresolved conditionto be a condition that has been evaluated during fuzzing but it hasnever been evaluated to the desired value that allows an uncoveredbranch to be taken.global memory.we de f ine global memory to include global vari ables and any heap memory reachable from global variables e.g.
aglobal pointer may point to a heap object .
either way global mem ory persists across system call invocations i.e.
system calls canchange the global memory which becomes observable to another.kernel state.we de f ine the kernel state as all the content in globalmemory.
if a function reads the global memory in a condition thecorresponding kernel state could in f luence which branch is taken.this means that an execution path of a system call depends on notonly arguments but also the kernel state.unresolved dependency ud .we de f ine an unresolved depen dency to be an uc where some global memory is read i.e.
thiscondition can only be satis f ied if the kernel has a desired state.write statement ws .we de f ine a statement as awrite statementas long as it writes to some global memory.1static intcdrom read cdda ... 2if cdi cdda method cdda bpc full nframes uncoveredcode4... 5intregister cdrom ... 6cdi cdda method cdda bpc full figure an example case of unresolved dependencyeffective write statement ews .we de f ine an e ective writestatement to be a ws that has the potential to change the globalmemory to an expected value by an ud.dependency.we de f ine a dependency to be a relationship betweenan ud and its ews.
conceptually it is similar to def use exceptdependency is speci f ic to global memory and the use has to be acondition check.
furthermore we further categorize dependenciesintoexplicit dependenciesandimplicit dependencies.
theformer represents the cases where the value written to the globalmemory e.g.
a f ile descriptor is propagated back to userspace which is then subsequently passed as an argument that is checkedagainst the global memory a read .
as an example when a syscallgenerates a kernel f ile object throughopen it will be stored in aglobal array and its f ile descriptor returned to userspace.
the samedescriptor value will be passed in a subsequent syscall read which causes the stored object in the array to be read.
the latterrepresents the cases where there is no overlap between one syscall soutput and another syscall s input arguments.
the example we willshow next is an implicit dependency.
.
an example casewe use a simple example from thecdromkernel module to illus trate how to f ind the root cause of an ud.
as shown in figure conditioncdi cdda method cdda bpc full line wherecdiis a global structure always evaluates to false when a fuzzingtest case reaches it causing the true branch to be uncovered.a common way to resolve such a condition is to f ind and executeits ews .
in this example line which is reachable throughanother functionregister cdrom is an ews for the ud at line2 since it writes the expected value tocdi cdda method.
the nextstep is to assemble a test case reaching and thus executing theews before the ud.
if the ews is again guarded behind anotherud we need to resolve it at f irst this can be a recursive process.3m o t i v a t i o nlinux kernel fuzzing tackling dependencies.the typical in terface exposed by os kernels is syscalls.
therefore before onecan start fuzzing the kernel it is necessary to generate a test caseconsisting of a sequence of syscalls with corresponding argumentsprepared .
in the case of the state of the art kernel fuzzer syzkaller it requires a description or speci f ication of the syscall interfaces.typically the speci f ications also calledtemplates are manuallycurated which includes the information about the syscalls theirexplicit dependency relationship and the possible range of valuesof syscall arguments.
since manually curating templates for variouskernel modules is not scalable especially a long tail of device drivers there has been some recent work e.g.
difuze and syzgen that aims to automate the generation of syscalltemplates which660demystifying the dependency challenge in kernel fuzzingicse may pi t tsburgh pa usaincludes some limited hardcoded knowledge about explicit depen dencies as well.
another direction considered is to simply takesyscall traces generated by existing applications that exercise aspeci f ic target module and mutate the trace .
this bypasses theneed to generate syscall templates and instead pushes the problemto being able to generate high quality syscall traces.
in practice itoften falls short in coverage because existing applications typicallyexercise only a small portion of the kernel module.furthermore syzkaller templates by design are unable to en code implicit dependencies where no explicit return and argumentrelationship exists e.g.
the example in figure is such a case.
itis possible to analyze existing syscall traces generated by applica tions .
this line of work can capture dependencies bothexplicit and implicit that are naturally exercised by existing appli cations but will not be able to resolve new dependencies.
anotherdirection e.g.
explored by hfl is to conduct more sophisti cated program analyses and look for read write relationships ofthe same global memory.
however it focuses on resolving mostlyexplicit dependencies which are typically encoded in well writtentemplates already i.e.
the templates correctly describe most of thesystem calls and their relationships.
indeed as we f ind out frommeasuring the dependency challenge in popular kernel modules the majority of uds are implicit instead of explicit.motivation.to summarize we believe the state of the art kernelfuzzing research has only explored the surface of the dependencychallenge.in particular we f ind that most of the existing workfocuses on the low hanging fruits of improving fuzzing cov erage against the kernel modules with largely incomplete ormissing syscall templates.for example difuze generatestemplates considering some explicit dependencies for kernel mod ules where no prior templates exist.
hfl focused on discov ering explicit dependencies in less tested modules.however inthis paper we aim to understand what the remaining chal lenges are when syscall templates are already comprehensivewith the obvious dependencies recognized and encoded andwhen fuzzing time is sufficiently long.
in particular we areinterested in whether the dependency challenge is still theprominent hurdle and why?consider the example case in fig ure .
surprisingly even such a seemingly trivial dependency canbe extremely challenging for the state of the art kernel fuzzer toresolve and cannot be solved by prior work because it is an implicitdependency .
interestingly as will be shown in .
it turns outthe root cause is that the ews is inside the initialization functionsof the kernel module and a kernel fuzzer implicitly assumes suchfunctions are out of the fuzzing scope and never considers fuzzingsuch functions.following this direction in this project we select a set of kernelmodules whose templates are well written so that we can observeand analyze their coverage de f iciencies.
from this study the ob vious question we hope to answer is whether dependencies arestill a major hurdle.
if so what future research directions should beconsidered to overcome the challenge?
to achieve this goal we relyon the state of the art kernel fuzzer syzkaller which has provede ective in f inding thousands of kernel bugs and continuouslyimproved.
in particular we allow syzkaller to fuzz speci f ic kernelmodules su ciently long to realize the full potential of the corre sponding templates.
this allows us to have an objective view of theremaining ucs which represent the hard cases we want to furtherinvestigate.
measurement pipelineto conduct a proper analysis of the dependency challenge in kernelfuzzing we build a measurement pipeline that has a combinationof automatic and manual analysis components.
roughly speaking the automatic analysis aims to measure the scale of the dependencyproblem whereas the manual analysis attempts to distill the rootcauses of uds.
the latter is often much more in depth and requiresmore than just mechanical analysis.the high level work f low of the measurement pipeline is shownin figure .
first after long fuzzing sessions of speci f ic kernel mod ules we collect the coverage and test cases from a fuzzer and obtainthe ucs based on the coverage.
then we use static analysis to de termine what ucs are actually uds which can quantify the degreeof the dependency challenge answering the f irst question in .
inaddition we leverage static analysis to recognize the correspond ing wss that can in f luence a condition which is a necessary steptoward analyzing the root causes of uds in part to answer thesecond question in .
from here on we manually inspect each wsof a dependency and f igure out ews.
if so we then investigate thereason syzkaller fails to resolve the dependency.
if none of the wsscan resolve the dependency we will also investigate the underlyingreasons.step collecting coverage.this step is relatively straightfor ward.
in addition to allocating su cient fuzzing time for kernelmodules we log all the test cases and their corresponding coveragesuch that we can later use them for automated and manual analysis.step determining unresolved dependencies.the next stepis to determine what ucs are uds.
this can be achieved through astatic taint analysis where the taint source is any global memory.in addition we also consider local variables whose values are indi rectly decided by global memory as taint sources more detail in .
.
basically whenever any source f lows into any sink the sinkstatement is e ectively an ud.
the result of this step allows us toquantify how often the dependency challenge impedes the fuzzerto make further progress.since accuracy is critical for ensuring that our measurement isnot too far o from the ground truth we have made changes and im provements to a state of the art static analysis engine dr.checker to adapt it to our use case and demonstrate decent accuracy.
in ad dition it is worth noting that the static taint analysis is based onthe toolchain of llvm .
therefore it is necessary to map anuc address to the llvm instruction.
the details of the above aredescribed in .step recognizing write statements of dependencies.givenan ud next step is to identify wss throughout a kernel module1that can in f luence the value of the global memory thereforehaving a chance to resolve the dependency.
in addition we aim topinpoint any ews.
to identify wss we rely on static alias analysisby searching for wss that change the same global variable s asused in an ud.1the ewss are possible outside the kernel module.
due the scalability issue we do notextend the scope of static analysis to the whole kernel but we will manually searchthe whole kernel in later manual analysis.661icse may pi t tsburgh pa usayu hao hang zhang guoren li xingyun du zhiyun qian and ardalan amiri sani figure measurement pipeline including the data collected from dynamic static and manual analysisonce static analysis results provide a set of wss we then man ually inspect each ws and determine which one s are in fact ef fective .
unfortunately this goal is extremely challenging to ful f illautomatically because many wss write values that are dynamicallydetermined and it can be hard to construct a test case to reach suchstatements as well.
in fact according to our analysis the majority ofthe wss are simply never even covered in our long fuzzing sessions.nevertheless when the write values are statically determined i.e.
constants our static analysis can determine their e ectiveness andprune any wss that are obviously not e ective.
for the remainingwss we have to resort to a manual analysis to identify ewss.step distilling root causes.finally to drill down to the rootcause of an ud we need to prove or disprove whether it can beresolved.
speci f ically if we manage to f ind any ews from the pre vious step we will attempt to construct an actual test case that canexercise the ews which will eventually resolve the dependency.we can then analyze why the fuzzer failed to generate such a testcase i.e.
root causes by inspecting its runtime logs recorded pre viously.
however i np r a c t i c e w e f ind it extremely challenging toconstruct such test cases even for experienced researchers.first of all most ewss were never even exercised during thefuzzing session.
it can be challenging to construct a test case thatcan reach the statement.
for example the ews may be guardedagain by some ucs and even uds .
even if we can reach the ews it can often be tricky to precisely control the value which mayin turn depend on global memory .
this can lead to a recursiveanalysis starting all the way from the second step more details in .
.
even though our static analysis can help with this process ofdetermining uds and narrowing down the search space of ewss it is still a substantial undertaking.second it turns out that it is challenging to mechanically followthe procedure of looking for ewss and how to reach them.
forexample there are often complications such as test cases not beingable to reproduce the same consistent behaviors as some kernelstates are modi f ied by the test cases .
therefore in the end weend up f irstly making sense of the overall architecture of eachkernel module i.e.
understanding the semantics of most criticalfunctions and data structures before jumping into the details ofeach dependency.
this includes manual auditing of the source codeas well as dynamic testing e.g.
setting breakpoints and observingbehaviors of certain functions.
as more details will be discussedin .
on average each case takes about .
hour to hours toanalyze.
we believe this is a valuable dataset that will bene f it anyfuture research on kernel fuzzing.
implementationin total there are .9k c .7k go and .5k protobuf linesof code for the whole pipeline including the mapping between bi nary and llvm bitcode .
static taint analysis 4k c lines ofchanges to dr.checker in .
data sharing serialization and dese rialization between all components collecting statistics organizinginformation to support manual analysis and the experimental so lution .
below we describe in more detail about the two maincomponents in the measurement pipeline mapping .
and staticanalysis .
.
we will open source all of the components and datato facilitate the reproduction of results and future research.
.1mapping between binary and llvm bitcodethe coverage information collected during fuzzing is about bi nary instructions speci f ically through the instrumentation pro vided by kcov .
in contrast our static analysis operates on thellvm bitcode.
for example when determining whether an ucis an ud it takes a branch instruction in llvm as input i.e.
brcond true branch false branch.
therefore we need to mapthe binary level coverage back to the llvm bitcode level.
this turnsout to be a non trivial process.
speci f ically by default the linuxkernels are compiled with a high optimization levelo2 this is alsonecessary for an e cient fuzzing process the bitcode f iles gener ated at an early stage unoptimized in the compilation pipelineare very di erent from the kernel binary in terms of the control f lows and boundaries of basic blocks making it challenging to mapbetween them.our solution is to use optimized bitcode f iles produced at a muchlater stagein clang through an undocumented feature whichshare the same control f low graph and basic block structure as thosein binary.
this allows us to obtain an accurate mapping betweenthe binary and ir instructions.
due to the space limit we do notgo into details here.
we will however include the solution in theopen sourced version of our measurement infrastructure whichmay help other projects that need such mappings.
.
static taint analysisour static analysis engine is built on top of the state of the art dr.checker which is designed to be f low context and f ield sensitive to analyze kernel source translated into llvm ir .
how ever since dr. checker s built in alias and taint analyses are notsuitable and precise enough for our purposes we made two cate gories of changes adapting it to work in our use cases and improving its accuracy.
first since the llvm bitcode we analyze is compiled withtheo2optimization level as described above exotic forms of irinstructions will be generated by clang which are not handled662demystifying the dependency challenge in kernel fuzzingicse may pi t tsburgh pa usaby dr. checker as it compiles the kernel usingo0 .
one such in struction is the multi index gep that aggregates multiple layersof pointer o set calculations in a single instruction.
for example getelementptr struct.foo chunky i64 i32 i323 i32 4is equivalent to chunky .f2.f3.f4 the last three in dices represent the f ield indexes .
second instead of treatinguser controlled syscall arguments as taint sources as in the case ofdr.
checker we need to taint any global memory which accordingto its de f inition in .
can be either a explicitly declared globalvariables or b heap memory reachable from global variables.
theformer is straightforward.
the latter can be tricky because some times the reachability relationship is established during some setupor initialization phase which can often be outside of the scope ofa kernel module.
an example is thefileordevicestructure thatfrequently appear as the f irst argument of a driver sioctl han dler.
such structures may belong to heap memory and are reachablefrom some global data structures but such reachability relationshipis set up in the generic kernel as opposed to a speci f ic kernel module.therefore we simply apply domain knowledge to such functionarguments and label them as taint sources accordingly.
one signi f icant improvement we made over dr. checker isthe pointer arithmetic resolution.
partly due to theo2optimizationlevel we f ind many more pointer arithmetic operations such as int char p byte offset which is basically equivalenttop f wherepis originally a pointer to a structure type whichcontains an integer f ieldfat the o setbyte offset.
therefore we analyze the de f inition of structures and map a byte o set to aparticular f ield in the structure.
with this improvement we willnot lose track of such points to relationships.
we also handle thewidespread container of cases in kernel where the pointer toa container structure is obtained by subtracting an o set from apointer to an embedded structure within it.
these cases can causedi culties for a static analysis due to the pointer arithmetic andthe unawareness of the container structure type.
we address thisproblem by inferring the container type from the context of thecontainer of pointer calculation e.g.
the resultingchar pointercan be converted to the actualstruct type by a later cast ir and then creating the correct container object hosting the originalembedded structure.
this way we can precisely maintain the point to records.
evaluationin this section we f irst describe the experiment setup and vali dation of the static analysis results in .
.
we then present themeasurement results about the prevalence of uds and the complex ity involved in analyzing them in .
.
finally we report the resultsof our root cause analysis to .
.
.
experiment setup and validation ofmethodologyfuzzing setup.we pick four linux kernel driver modules fortesting from kernel version .
as listed in table .
they areall available and compiled based on thedefconfig default kernelcon f iguration which represents commonly used drivers.
there arethree reasons we pick them table description and fuzzing time for each modulenamesloc template size lines time hour cdrom .6k 34448snd seq 14k 27848ptmx 39k 32448kvm 60k 806120fgurpvqgbvhtswp nypfigure coverage over timetable categories of unresolved dependencies and samplecases for manual analysis domi uc domi u1d448 u1d436 samplea ud domi u1d448 u1d437 sampler 30sum2977 compared to the core linux kernel driver modules account forthe majority of the kernel code and therefore the attack surfaceas well.
there are about .7m sloc for the whole linux kernelbut .4m sloc .
of them are device drivers.
as mentioned in compared to the less tested and less populardrivers we choose more popular ones that are relatively welltested and have relatively comprehensive syzkallertemplates.
atthe start of our analysis there were only drivers with syzkallertemplates and of which had well written templates whichlimits our choices signi f icantly.
we aim to cover di erent types of linux device drivers onecharacter device driver ptmx one block device driver cdrom andone main sub category of character device driver miscellaneous kvm and one other character device driver that is outside of the drivers folder snd seq.as shown in table we test each module individually foratleast48 hours repeated three times.
the machine we use to conductfuzzing has an intel r xeon r gold cpu and 512gb of ram and runs ubuntu .
lts.
we use cpu cores in di erentvms when fuzzing a module.
we collect the union of coverageachieved in all three fuzzing runs.
the fuzzing time is determinedexperimentally based on how long it took for coverage to converge as will be shown in figure .
for example the coverage ofptmx snd seq andcdromstill improves after hours and we allocate48 hours for them.
on the other hand the coverage ofkvmstillimproves even after the hour mark which prompts us to allocate120 hours for it.
this way we ensure all the remaining ucs at theend of the fuzzing session will likely represent the limitations ofsyzkaller and its templates.663icse may pi t tsburgh pa usayu hao hang zhang guoren li xingyun du zhiyun qian and ardalan amiri sanitable accuracy of static analysisname ucmanual analysisstatic analysis ud ws ews ud fp fn ws fp fncdrom .
.
.
.
.
.
.
snd seq .
.
.
.
.
.
.
ptmx .
.
.
.
.
.
.
kvm .
.
.
.
.
.
.
sum avg .
.
.
.
.
.
.
sampled cases for manual analysis.we sample two datasetsfor manual analysis summarized in table .
the f irst dataset isto validate the accuracy of our static analysis results.
the secondis for the root cause analysis.
for the f irst dataset we start fromucs and manually determine which are in fact uds.
then we alsoconduct an exhaustive manual search for their corresponding wss with the understanding of the semantics of each kernel module asdiscussed in .
such uds and their wss serve as ground truth.to cover a representative set of samples we categorize the ucsby the number of instructions behind them i.e.
the instructions denoted as domi that are dominated by the condition in thesame function and that there are no other ways to reach themwithout satisfying the condition .
a smaller domi indicates thatthe condition is likely related to simple error handling whereas alarger domi is related to the functional part of the kernel module.as shown in table we partition the ucs into four ranges basedon domi from which we then randomly sample samplea ofcases.
note that although the f irst category happens the most uc but the aggregated domi is the lowest whereas the lastcategory has fewer ucs but more aggregated domi.
as a result weslightly favor the last category as they represent more functionalcode and are generally more worthwhile to test.
for the seconddataset we start directly with uds as opposed to ucs so we caninvestigate their root causes.
in total we randomly sampled 115uds over di erent categories as shown under the sampler columnin table favoring the last category even more because resolvingsuch dependencies will unlock more functional code.accuracy validation of static analysis.from the f irst sampleddataset that serves as ground truth we show the static analysisresults in table .
as we can see since we try our best to optimizeour analysis to avoid exaggerating the ud problem in kernel fuzzing the overall accuracy is very good.
there are a .
false positiverate and .
false negative rate with regards to determining ifan uc is an ud.
that means that there is likely an underestimateof the dependency issue by our static analysis as there are morefalse negatives .
there are a .
false positive rate and at leasta .
false negative rate regarding the ws analysis note thatthe false negative rate is a lower bound because we do not claimto have found the complete set of wss manually for each ud.
inother words the ws result overall is also an underestimate.unreachable functions elimination.our initial observation ofthe fuzzing results indicate that most kernel modules have muchmore code than what we can cover with syzkaller because of ob viously unreachable functions.
as a result we prune unreachablefunctions as described later in because otherwise the percentageof code coverage in the end will look unrealistically small whichtable classi f ication of unresolved conditionsname uc ud unknown non ud global controlcdrom 3snd seq 1ptmx 5kvm 9sum135 18table prevalence of unresolved dependenciesname uncoverede e ud uc dome u1d448 u1d437 dome u1d448 u1d436cdrom snd seq ptmx kvm sum may leave us with the wrong impression about the kernel fuzzingperformance.classi f ication of unresolved conditions.we now give an overviewof the ucs from the samplea dataset.
based on our manualcharacterization of these cases as shown in table we can dividethem into uds non uds and unknown cases.
wecan further break down the ud cases into cases where the ud isdirectly a ected by a global memory and cases where the udis indirectly a ected by global memory.
the latter cases representuds where their conditions check the value of a local variablewhose value is indirectly decided by global memory through controldependence as opposed to data dependence .
for example if ud var true if var uncovered code .if var is classi f ied asud because the local variablevaris indirectly a ected byif ud .for the non ud cases they always correspond to conditions whosevalues are in f luenced purely by syscall arguments.
finally for theunknown cases they represent cases that are di cult to analyzebecause they require analysis of either the assembly code or codeexternal to the driver module itself.
we exclude these unknowncases from our subsequent analysis.
overall the ud cases repre sent of the uc cases indicating that the dependencychallenge is indeed a major hurdle for kernel fuzzing.
.
measurement resultsin this section we report static analysis results at scale and quantitative metrics that show the di culty of analyzing theseuds.prevalence of unresolved dependenciesthe results are shownin table .
the number of total edges e represents the total pos sible coverage from one basic block to another for each module.after taking the union of coverage obtained from three fuzzingruns we report the remaining uncovered edges uncoverede .
aswe can see even with all the pruning of unreachable code there arestill many uncovered edges even after hours or hours offuzzing for each module ranging from to percentage wise.out of edges that are never covered we further look at those withcorresponding conditions that are exercised but never evaluatedto the desired value i.e.
either true or false .
these correspond664demystifying the dependency challenge in kernel fuzzingicse may pi t tsburgh pa usatable write statements stats from static analysisname udstatic analysis ws wsc wse wse wscdrom .
.
.
.
snd seq .
.
.
.
ptmx .
.
.
.
kvm .
.
.
.
sum avg .
.
.
.
to ucs uc which are much smaller than the total number ofuncovered edges but each of them acts as a guard that preventsmany more subsequent edges from being covered.
out of theseucs our static analysis reports on average as uds ud .
eventhough dependency is a known problem this prevalence of it isstill surprising keep in mind that the number is likely an underes timate .
according to the breakdown by modules ptmxandkvmhave the higher ud.
this is expected because the more complex amodule is the more global states are likely introduced and hencemore dependencies.
dome u1d448 u1d436describes the sum of the numberof uncovered edges that are intra procedurally dominated by theguard conditions reachable only from the ucs and dome u1d448 u1d437isthe sum over all the uds.
we choose intra procedural dominationbecause we do not want to overestimated it.
it shows that udsroughly lock away three quarters of the code.write statements.from our static analysis results we f ind thatthe average number of wss for each ud is about as shownin the ws column in table .
if we look at the number for eachmodule kvmandptmxexhibit many more wss.
in addition we f ind that sometimes an ud may involve more than one piece ofglobal memory e.g.
in f luenced by multiple global variables andeach of them may have multiple wss.the next step in the measurement pipeline is to determine whichwss are e ective.
as discussed in this step is very challengingeven with manual analysis.
one of the reasons is that these wssare often writing values determined at runtime in the form ofexpressions .
as table shows .
of the written values areexpressions wse instead of constants wsc .
in the end asshown in our later manual analysis results in table we f ind thatthe number of ewss ews is far smaller than ws often only asingle one .the results show that it would be likely an expensive search toexhaustively test every single ws automatically given that we mayneed to determine the possible values that can be written whichcan be challenging by itself .
this problem is exacerbated when weconsider the recursive nature of dependencies as will be shownnext.recursive dependencies.whenever a ws cannot be reached byany of the existing test cases attempted by syzkaller it is likely thatit may be blocked o due to additional uds leading us to recur sively analyze more wss and dependencies.
when this happens the search space can blow up quickly depending on the numberof wss we have to attempt at each depth level which we know is13 on average and the depth of recursion di cult to measure .we measure two approximate metrics to quantify the recursivedependency challenge.
first we f ind that on average .
of wsare uncovered after the fuzzing sessions are done across all fourtable root causes of unresolved dependenciesname ud deadcode environment unobserved template search unknown .
.
.
.
.
.
.
.
.
.5cdrom 0snd seq 0ptmx 5kvm 6sum115 11drivers.
this indicates that it requires work to construct a test casebefore we can even verify whether these wss are feasible.
second when the wss are not covered we f ind surprisingly .
of themare due to recursive dependencies based on our static analysis of thedominating conditions.in other words if a fuzzer has not managedto reach the ewss after a long fuzzing session it is almost alwaysnever due to barely missing the opportunity indicating some morefundamental roadblocks as we will investigate later in .
.non self contained unstable test cases.during the processof our manual investigation of root causes we f ind another commonhurdle.
that is the test cases generated by syzkaller are not self contained.
speci f ically syzkaller or fuzzers based on it generatesa stream of test cases and executes them accumulating signi f icantkernel state changes as it progresses until a reboot occurs .
thismeans that the success of a test case can be dependent on theprevious ones that may have accidentally set up the kernel state e ectively making these test cases non self contained or unstable .this is important for our manual investigation because we rely onthe test cases generated by syzkaller to reproduce the results e.g.
if a test case is reported to reach some ud we will re execute thetest case and hope that it will still be able to otherwise we have toput more e ort in the steps mentioned in .
unfortunately a largefraction of test cases that were previously able to reach uds andwss become unstable when tested later in isolation average and respectively .
this is another reason why manual analysiscan be expensive as we need to reconstruct the state which canhelp us understand the root cause of the unresolved dependency.
.
analysis of root causesoverall it took about person hours with the help of all the re sults produced by automated analysis in the measurement pipeline in order for us to be con f ident about the correctness of our results.even then there are a few cases where we cannot determine theroot causes even after hours of investigation.
this means that wecannot either construct a test case that can resolve the dependencyor prove that it is impossible.
given the level of di culty in con ducting such an analysis we will publicly share the datasets whichwe believe is valuable to researchers who aim to improve kernelfuzzing.overall we distill and summarize the root causes into six cat egories and an unknown category .
the results are presented intable .
we next describe them one by one.
.
.
dead code.the amount of dead code in a large complexpiece of software such as linux is a mystery.
from our results weare surprised to see a substantial portion of the uds turnout to lead to dead code representing almost of uds.
in other665icse may pi t tsburgh pa usayu hao hang zhang guoren li xingyun du zhiyun qian and ardalan amiri sani1static struct snd seq queue queue list 2static intseq free client1 ... 3snd seq queue client leave client number 4snd seq queue client termination client number 6voidsnd seq queue client leave intclient 7for i i sndrv seq max queues i 8if q queue list remove i client !
null 9queue delete q 12voidsnd seq queue client termination intclient 13for i i sndrv seq max queues i 14if q queueptr i null 15continue 16spin lock irqsave q owner lock flags 17if q owner client uncovered branch19q klocked 20spin unlock irqrestore q owner lock flags 21if q owner client uncovered branch23if q timer running 24snd seq timer stop q timer 25snd seq timer reset q timer 27queuefree q figure case of dead codewords it is simply impossible to reach these uncovered branchesbehind uds no matter how hard we try.
the best thing fuzzerscan do it to recognize them and avoid wasting time trying to coverthem.dead code is a well known issue and compilers routinely per form dead code elimination .
we suspect that the reason whycompilers fail to identify them is due to the nature of uds requiringthe analysis of global memory beyond a local context .
for exam ple we f ind a function may double check the existence of certainelements in a global queue right after its caller removes them theexample is available in the uploaded dataset among other exam ples .
to get further con f irmation we reported the case to linuxkernel developers and they have agreed with our assessment andeliminated the dead code subsequently.
even though we have notreported all the cases to linux we exercise the same rigor acrossall the dead code cases.interestingly exceptcdrom all other kernel modules have asubstantial fraction of dead code cases out of their uds.
forsnd seq half of its uds are surprisingly dead code cases out of .
inaddition we are curious to see whether the dead code cases onlyrepresent small pieces of code e.g.
redundant error checks .
ingeneral the data are indeed in line with the hypothesis especiallygiven the way these cases are sampled shown in table .
however there is still a substantial fraction of counterexamples.
followingthe categorization in table we f ind out of the dead codecases have only a small number of dominated instructions in thesame function .
however the remaining cases are spreadout cases with11 100dominated instructions cases with101 190dominated instructions and cases with 190dominatedinstructions.we give a fairly complex dead code example that we manually de termined in figure .
there are two unresolved dependencies line17 with uncovered instructions and line with uncovered1static intcdrom read cdda ... 2if cdi cdda method cdda old uncovered branch4... 5intregister cdrom structcdrom device info cdi 6if cdi disk c d i c d d a m e t h o d c d d a b p c f u l l 7elsecdi cdda method cdda old uncovered branch8... 9static intide cd probe ... 10if drive media !
ide cdrom gotofailed 11devinfo disk info disk 12register cdrom devinfo ... 13static intprobe gdrom ... 14if gdrom execute diagnostic !
return enodev 15register cdrom gd.cd info ... figure case of environment dependencyinstructions .
based on the control f low graph and data f low graph it does not seem like the uncovered branches of line and line22 are dead code.
however if we look at the call graph we can f ind that the only caller of the functionsnd seq queue client termination is the functionseq free client1 that callsthe functionsnd seq queue client leave before the func tionsnd seq queue client termination .
what the functionsnd seq queue client leave does is to remove all the ele ments in global queues if their client ids are equal toclient number see line .
interestingly functionsnd seq queue client termination goes through the same global queues to look forelements that have a speci f ic client id againclient numberasshown in line .
this will obviously lead both conditions at 17and to always evaluating to false.
to get further con f irmation we reported this case to linux kernel developers and they haveagreed with our assessment and eliminated the dead code subse quently.
even though we have not reported all the cases to linux we exercise the same rigor across all the dead code cases.
.
.
environment dependency.we f ind that oftentimes an udmay depend on the con f iguration of and values from the executionenvironment e.g.
hardware .
if the underlying execution environ ment is not the expected type or returns the expected result adependency will not be resolved.
note that we do attempt to prunecode that obvious cannot be reached because of environment de pendency see .
nevertheless our heuristics only focused onfunction pointers which point to di erent targets depending onthe underlying execution environment.
other than those we f indthere are still many other cases most are much smaller that arenot excluded earlier.
an analysis that could automatically recognizethem would be helpful so users of fuzzer can tune the con f iguration.we show an example in figure where the ud iscdi cdda method cdda old line .
we f ind the ewscdi cdda method cdda old line which is not covered because ofyet another udif cdi disk line .
the value ofcdi diskis decided by the caller ofregister cdrom which can be eitheride cd probe line orprobe gdrom line .
these twofunctions check the type of the hardware device and either writestodevinfo disk line or does not.
we omit a few other devicetypes and the exact hardware read functions for brevity.
only if wehave the correct hardware device present in this case a gdrom not cdrom will we reach line and in turn line .666demystifying the dependency challenge in kernel fuzzingicse may pi t tsburgh pa usa1static structsnd seq client clienttab 2static intopen file 3clienttab client 4client type user client 5file private data client 6static longioctl file cmd arg client f i l e p r i v a t e d a t a 8snd seq ioctl create port client ... 9static intsnd seq ioctl create port ... 10if client type kernel client uncovered branch12... 13intsnd seq create kernel client ... 14client type kernel client 15returnclient number 16int initsnd seq system client init 17sysclient s n d s e q c r e a t e k e r n e l c l i e n t n u l l !system!
18snd seq ioctl create port sysclient ... 19module init alsa seq init figure case of unobserved dependency moduleinit in total we identify such cases as shown in table whichrepresent almost a quarter of all uds.
among them we f ind that 18are about reading the hardware type or property nine in moduleinitfunctions and nine in syscalls a special situation here isnested guests inkvm which counts six cases .
six of them attemptto read something that can change at runtime.
the remaining threeare undetermined.
.
.
partially unobserved dependency.this is an interestingcategory although rare in our investigation related to the designof syzkaller where certain functions are simply not in the scope ofthe fuzzer.
for example any code that occurs in the moduleinitorexitfunctions or the bottom half processing are not trackedby syzkaller.
this means that any code that is reachable from eithercategory of functions will never be covered even if they do getexecuted .
this is because such coverage cannot be attributed to aspeci f ic test case.
this leads to a variety of problems.first this can lead to incorrect accounting of uds.
speci f ically some functions can be reachable from both syscall entry points andthe above categories.
we f ind that it is possible that such functionshave uds during syscall fuzzing but in reality the dependency is infact resolved during these other unobserved execution paths frominit exitor bottom half .
for example snd seq create kernel client in figure contains the only ews line for theud line and is only called by themodule initfunction i.e.
init alsa seq initat line .
when the ud is reached fromsyscalls i.e.
ioctl the kernel stateclient typealways takesthe value ofuser client which is set by the ws at line inopen .
obviously this will lead the syzkaller to think that it isunresolved.
there are two cases in total that can be essentiallyconsidered resolved dependencies.second because syzkaller was not aware of functions relatedto theinit exitand bottom half it also does not have the abilityto schedule them during fuzzing.
this leads to ewss that are in voked only sporadically in the case of the bottom half or onlyat the module load time or unload time.
for example the mod ule init may initialize some kernel state to an expected value byan ews .
however syzkaller may f irst schedule test cases thataccidentally overwrite the expected value before the ud is evenseen.
we f ind nine such cases where the only ewss are located in !
!
!
!
!
!
.
!
!
.
?
?
?
a ?
?
?
.
b4628 c .d e d d d d d d d f !
g h!
.
cc c .
dd c e i i figure case of unresolved dependency because of incom plete templatesinit exitfunctions or the bottom half.
there are two cases underthis category where the dependencies are not triggerable.as we can see this is highly dependent on the kernel mod ules.
even though rare overall they do constitute a non negligibleportion of the cases incdrom .
andsnd seq .
.
weanticipate seeing many more cases of bottom half processing inmodules with frequent external interactions e.g.
audio camera and network drivers.
.
.
incomplete templates.the root causes introduced thus farare outside of the control of a fuzzer e.g.
dead code and envi ronment dependencies .
now we move on to the root causes thattechnically fall under the scope of syzkaller.
speci f ically we men tioned that syzkaller relies on templates that encode the knowledgeabout the syscall interface for each kernel module.
the qualityof templates has a direct impact on the fuzzing performance asthe test cases are generated based on the templates.
even thoughthe templates are already comprehensive as suggested by theirsizes shown in table from our analysis we discover a variety ofde f iciencies.
this can include missing knowledge about syscall rela tionships argument types and ranges etc.
which result in failuresto reach otherwise reachable ewss.
basically if an ud can be re solved clearly with an amended template it belongs to this category.overall our manual investigation reports cases under this cate gory template as shown in table .
this represents the largestcategory of root causes that will allow coverage improvement byresolving more dependencies.most cases belong tokvm which is the most complex piece ofkernel module out of the four we analyze.
an example is shown infigure .
the ud is at line and we locate the ewss at line .as we can see the value of thectxt dis determined by anothervariableopcode.flags which is in turn determined by the wsopcode twobyte table at line .
finally we knowthat the data an instruction bu er referenced byuserspace addr which is a pointer f ield in an argument of the syscall at line candecide the value ofctxt b. however the template in syzkallerdoes not correctly describe what the bu er should look like.
inorder to resolve the dependency a test case would need a speci f icsequence of instructions in the bu er as described in lines and .unfortunately syzkaller is simply not aware of the desirable bytesequences.
in total we f ind about cases that are similar to thisexample inkvmmodules.667icse may pi t tsburgh pa usayu hao hang zhang guoren li xingyun du zhiyun qian and ardalan amiri sanithere are also similar but simpler examples where a single ar gument needs to take a magic number much like what commonlyoccurs in userspace programs.
in the kernel modules we analyzed we observe eight such cases.in addition we observe that the templates can also miss explicitdependencies.
across the four drivers though there is only a singlecase we f ind inkvm.
this con f irms our assertion that the templateswritten for these four drivers are already relatively comprehensive.
.
.
specialized search requirement.finally there are a few casesthat need a more specialized search algorithm that is beyond thecapability of a general purpose fuzzer.
our manual analysis f inds 9cases related to the search algorithm search out of in table .
interleaving of multiple threads in order for the ud to readthe expected value sometimes a race condition is required.
inother words a speci f ic thread interleaving has to occur in orderfor the value written by the ews to be exposed.
if the windowof opportunity is small it is highly unlikely that syzkaller willbe able to resolve the dependency.
in total we f ind six cases.
speci f ic sequence of syscalls some ewss need multiple itera tions to successfully change the kernel state to the desired value e.g.
i .
this means that one needs to repeatedly invoke one ormore syscalls that contain the ewss to resolve the dependency.in total we f ind three cases related to the sequence of syscalls.
future research directionsfrom the previous results we have shown that uds are a prominentreason for uncovered code in kernel fuzzing.
we also show theyare challenging to resolve due to a diverse set of root causes.
in thissection based on the insights we gained from our measurement we summarize two main future research directions that have topromise to overcome these challenges.open problem cross syscall input propagation analysis.as reported in .
.
of the uds are actually the result ofimperfect templates missing certain syscall argument knowledge .this means that once the templates are amended the dependenciescan be potentially resolved and we verify that it is indeed the casewith experiments .
in this section we propose a new analysis thattracks the propagation of a syscall input argument across syscallinvocations.we wish to point out this is a unique type of dependency becausethe ws always writes a value speci f ied in a syscall argument.
if weblindly target any dependency without understanding its uniquepattern it is unclear what we should do to resolve them.
for exam ple one can attempt a whitebox approach similar to hfl tolocate the write and read pairs regarding the same global memory.however as we showed in our measurement see .
there aretypically several possible wss and it is unclear which one is theews.
this is likely why hfl has focused on only explicit depen dencies where typically there is only one ws.
to understand howthis general direction will work in practice we actually developeda failed solution prior to having the full insight from our measure ment study that attempts to collect all the write syscalls duringfuzzing and then pair them up with the read syscalls.
the resultsshow that whatever implicit dependencies that we are able to re solve in this solution syzkaller can also resolve them in most caseseven quicker.
this is a good indication that syzkaller is actuallyalready sophisticated enough in terms of its algorithmics.
as long asthe templates have encoded su cient knowledge regarding syscallsand argument types and possible values given su cient fuzzingtime syzkaller will be able to resolve the implicit dependencies thatare covered by the templates.
unfortunately it does not resolvethe hard dependencies such as those that are reported in our re sults.
this is because we simply do not have the knowledge of whatcorrect syscall arguments to supply not given in syscall templates in order for the ws to write the expected value.
thanks to ourmeasurement insight as shown in .
.
we know that cases outof are due to incomplete descriptions of syscall arguments.secondly we observe that more than half of such inputs 11cases are not processed immediately in a single syscall invocation.instead they are stored in some global memory in one syscall andthen used in another syscall invocation.
if we analyze the syscallwhere the use happens oftentimes they look just like a magicnumber check if g array magic num which should betheoretically easy to resolve e.g.
through symbolic execution .
nev ertheless these magic number checks are performed against theglobal memory to make which symbolic directly is meaningless rather than syscall inputs.
those cases would become solvable ifthere is a cross syscall input propagation analysis in the form ofeither static or symbolic which could f ind the related inputs.
wehave leveraged our static taint analysis developed for the measure ment and found that indeed such cross syscall propagations canbe identi f ied.
they have resulted in us identifying four missingdescriptions in the templates two of which have been f ixed in alater version of syzkaller .
therefore we believe a cross syscallinput propagation analysis is an e ective method to resolve suchcomplex dependencies.open problem multi interface fuzzing.as we discussed in .
.
we show that many dependencies can be resolved only whenwe consider the interfaces that are not out of the scope of syzkaller i.e.
unobserved .
we have given two speci f ic categories of inter faces including hardware side input and the moduleinit exitfunctions.
we have mentioned that the latter should be included aspart of the syscall fuzzing interface.
on the other hand hardware side input has been considered in recent works .we wish to point out that this is a very di erent problem from thecurrent hardware side fuzzers such as usbfuzz and franken stein bluetooth fuzzing which focus primarily on the attacksurface from the hardware side only.
this is understandable becausethese drivers do process complex inputs from the hardware in ad dition to those from syscalls .
nevertheless from the insight gainedfrom our measurement we show syscall fuzzing and hardware side fuzzing can be intertwined.
that is in order to make furtherprogress in syscall fuzzing i.e.
covering certain branches we ac tually need proper hardware side input to arrive at the right timeto write to the global memory with the expected value.
to general ize this observation conversely when performing hardware sidefuzzing we might encounter dependencies that can be resolved bysyscall inputs only e.g.
putting the device into certain states bysyscalls .we frame the goal as multi interface fuzzing as it needs to coor dinate the inputs from multiple di erent types of interfaces e.g.
inputs from syscall and hardware side can be interleaved .
we be lieve this is a worthwhile research direction as the bugs that are668demystifying the dependency challenge in kernel fuzzingicse may pi t tsburgh pa usauncovered this way are likely hidden deeply in some di cult to reach driver states.
discussion and limitationlimited data set scale.in this paper we delve into four spe ci f ic linux kernel modules to investigate the dependency challenge.even though we believe they are representative of kernel modulesof varying type and size their functionalities may not be diverseenough to cover other modules such as gpu drivers network mod ules f ile systems etc.. nevertheless based on our observation thedistilled dependency challenges do appear general enough for otherdrivers.
in the future we plan to pick more modules and charac terize their di erences in terms of their respective dependencychallenges.
in addition much of the analysis is conducted manuallywhich is hard to scale.
nevertheless we plan to expand the analysise ort as future work to improve kernel fuzzing.unreachable functions elimination.as we mentioned in .
we prune as much unreachable functions as we can.
speci f ically weprune two types of unreachable functions interrupt handlingrelated functions that can not be reached from userspace and functions that are reachable only when certain hardware environ ment is present.
for the f irst case based on the call graph generatedduring static analysis we prune all the functions that cannot bereached from syscall entry points e.g.
ioctl .
to account forpotential inaccuracies in call graphs due to indirect calls we applya known type based method to conservatively generate callgraphs i.e.
as long as the signature of the function pointer is com patible with that of a target function we will consider it a validtarget.
this method guarantees that all potential targets will bediscovered and no functions will be incorrectly pruned this methodis commonly used to enforce control f low integrity .
the secondcase turns out to be much more challenging as hardware dependentcode can be scattered throughout a module.
as a f irst order approx imation we inspect all function pointers and their potential targetsand look for cases where the target is dependent on the underlyinghardware environment.
a major example is thesvmpart of thekvmmodule which is dedicated to amd cpus containing basicblocks.
in total the two methods can prune about of edgesacross modules on average.accuracy and bene f it of manual analysis.our measurementstudies heavily relied on the manual analysis to identify the rootcauses of dependencies.
this is a non trivial task because everydependency may look di erent and unique in certain aspects.
toensure that we do a good job we not only look at the uds them selves.
instead we read the overall structure of the whole kernelmodule to understand its design in a big picture which allows us tomake an accurate assessment of the root causes.
unfortunately it isvery much di cult to replace our manual analysis with automatedprogram analysis which means fuzzer can not resolve those hardproblems automatically like humans.
however fuzzers have theirown ways that conduct a random search for test cases in a givenscope.
and the root causes from manual analysis can help eitherset up the fuzzing scope or o er better search.generalization to general software fuzzingwe aim not to over claim our f indings beyond kernel fuzzing as the os kernel is animportant class of software that deserves attention by itself.
never theless we believe that fuzzing stateful and multi entry programs especially device drivers will likely encounter similar challenges although the distribution of the root causes might di er.
related worklinux kernel fuzzing.in recent years there is a plethora ofresearch on improving kernel fuzzing with the goal of achievingmore coverage and f inding more bugs.
kafl supports x86based kernels and speeds up fuzzing by hardware assisted feedback.razzer leverages static and dynamic analysis techniques to f ind race bugs through fuzzing.
there are also tools built on fuzzingspeci f ic linux kernel subsystems including f ile systems devicedrivers by mutating hardware inputs and hypervisors .the work deploys fuzzing to the enterprise level linux kernel.nevertheless few address the dependency challenge directly.stateful fuzzers.there are some stateful fuzzers which try toconsider states during fuzzing for user space programs particularlynetwork protocols.
restler uses a lightweight static analysisto explore service states of rest api.
and the work tries toinvestigate how to extend stateful rest api fuzzing e.g.
restler in general.
spfuzz uses the knowledge from the rfc to help thefuzzing.
snooze needs humans to de f ine the states of protocolsto assist fuzzing.
steelix uses program state which includescoverage information and comparison progress information toguide fuzzing.
the work improves fuzzing of tls by analyzingits state machine which again requires signi f icant manual e ort.the work generates test cases for a compiler when there arewell de f ined syntax and non trivial semantics.static taint analysis on linux kernels.there are several statictaint or data f low analysis tools against linux kernel source.
dr.checker ubitect and k miner are based on thellvm framework and are all open source.
packetguardian is another one based on cil .
dr. checker best suits our needand our static analyzer is built on top of it.
conclusionin conclusion we have conducted an in depth investigation ofthe dependency challenge in kernel fuzzing using a combinationof static and manual analysis.
with a comprehensive set of data we demonstrate the challenges when analyzing the unresolveddependencies in linux kernel.
in addition we distill the root causesof unresolved dependencies.
finally we reveal many unexpectedobservations and point to new research directions that will improvekernel fuzzing.acknowledgmentsthis work was supported in part by the us national science foun dation nsf grants cns and cns .data availabilitysource code and datasets related to this article can be found at and may pi t tsburgh pa usayu hao hang zhang guoren li xingyun du zhiyun qian and ardalan amiri sanireferences vaggelis atlidakis patrice godefroid and marina polishchuk.
.
restler stateful rest api fuzzing.
inproceedings of the 41st international conference onsoftware engineering icse montreal qc canada may joanne m.atlee tev f ik bultan and jon whittle eds.
.
ieee acm .
banks marco cova viktoria felmetsger kevin c. almeroth richard a.kemmerer and giovanni vigna.
.
snooze toward a stateful networkprotocol fuzzer.
ininformation security 9th international conference isc samos island greece august september proceedings lecture notes incomputer science vol.
sokratis k. katsikas javier l pez michael backes stefanos gritzalis and bart preneel eds.
.
springer .
alfred chen zhiyun qian yunhan jack jia yuru shao and zhuoqing mor ley mao.
.
static detection of packet injection vulnerabilities a case foridentifying attacker controlled implicit information leaks.
inproceedings of the22nd acm sigsac conference on computer and communications security denver co usa october indrajit ray ninghui li and christopher kruegel eds.
.
acm .
chen yu wang zheng zhang and zhiyun qian.
.
syzgen au tomated generation of syscall speci f ication of closed source macos drivers.inproceedings of acm sigsac conference on computer and communicationssecurity ccs.
yih farn chen emden r. gansner and eleftherios koutso f ios.
.
a c datamodel supporting reachability analysis and dead code detection.
insoftwareengineering esec fse 6th european software engineering conference heldjointly with the 5th acm sigsoft symposium on foundations of software engi neering zurich switzerland september proceedings lecture notes incomputer science vol.
mehdi jazayeri and helmut schauer eds.
.
springer .
.control flow integrity design documentation.
corina aravind machiry christopher salls yan shoshitaishvili shuanghao christopher kruegel and giovanni vigna.
.
difuze interface awarefuzzing for kernel drivers.
inproceedings of the acm sigsac conferenceon computer and communications security ccs dallas tx usa october november bhavani m. thuraisingham david evans tal malkin anddongyan xu eds.
.
acm .
de ruiter and erik poll.
.
protocol state fuzzing of tls implementations.in24th usenix security symposium usenix security washington d.c. usa august jaeyeon jung and thorsten holz eds.
.
usenix associa tion .
k. debray william s. evans robert muth and bjorn de sutter.
.compiler techniques for code compaction.acm trans.
program.
lang.
syst.
.
developers.
.linux testing project.
gens simon schmitt lucas davi and ahmad reza sadeghi.
.
k miner uncovering memory corruption in linux.
in25th annual network anddistributed system security symposium ndss san diego california usa february .
the internet society.
godefroid bo yuan huang and marina polishchuk.
.
intelligent restapi data fuzzing.
inesec fse 28th acm joint european software engineeringconference and symposium on the foundations of software engineering virtualevent usa november prem devanbu myra b. cohen and thomaszimmermann eds.
.
acm .
google.
.clusterfuzz.
google.
.syzbot.
google.
.syzkaller.
han and sang kil cha.
.
imf inferred model based fuzzer.
inproceedings of the acm sigsac conference on computer and communicationssecurity ccs dallas tx usa october november bhavani m.thuraisingham david evans tal malkin and dongyan xu eds.
.
acm .
r. jeong kyungtae kim basavesh shivakumar byoungyoung lee and insikshin.
.
razzer finding kernel race bugs through fuzzing.
in2019 ieeesymposium on security and privacy sp san francisco ca usa may .
ieee .
kernel.
.kcov.
kyungtae kim dae r. jeong chung hwan kim yeongjin jang insik shin andbyoungyoung lee.
.
hfl hybrid fuzzing on the linux kernel.
inproceedings2020 network and distributed system security symposium.
internet society sandiego ca.
kim meng xu sanidhya kashyap jungyeon yoon wen xu and taesookim.
.
finding semantic bugs in f ile systems with an extensible fuzzingframework.
inproceedings of the 27th acm symposium on operating systemsprinciples sosp huntsville on canada october tim brecht andcarey williamson eds.
.
acm .
lattner and vikram s. adve.
.
llvm a compilation framework forlifelong program analysis transformation.
in2nd ieee acm internationalsymposium on code generation and optimization cgo march san jose ca usa.
ieee computer society .
li bihuan chen mahinthan chandramohan shang wei lin yang liu and alwen tiu.
.
steelix program state based binary fuzzing.
inproceedingsof the 11th joint meeting on foundations of software engineering esec fse2017 paderborn germany september eric bodden wilhelm sch fer arie van deursen and andrea zisman eds.
.
acm .
machiry chad spensky jake corina nick stephens christopherkruegel and giovanni vigna.
.
dr. checker a soundy analysis forlinux kernel drivers.
in26th usenix security symposium usenix security vancouver bc canada august engin kirda and thomas ristenpart eds.
.
usenix association .
c. necula scott mcpeak shree prakash rahul and westley weimer.
.cil intermediate language and tools for analysis and transformation of cprograms.
incompiler construction 11th international conference cc heldas part of the joint european conferences on theory and practice of software etaps2002 grenoble france april proceedings lecture notes in computerscience vol.
r. nigel horspool ed.
.
springer .
pailoor andrew aday and suman jana.
.
moonshine opti mizing os fuzzer seed selection with trace distillation.
in27th usenix se curity symposium usenix security baltimore md usa august william enck and adrienne porter felt eds.
.
usenix association .
peng and mathias payer.
.
usbfuzz a framework for fuzzing usb dri vers by device emulation.
in29th usenix security symposium usenix security2020 august srdjan capkun and franziska roesner eds.
.
usenixassociation .
rubini and jonathan corbet.
.linux device drivers.
o reillymedia inc. .
jan ruge jiska classen francesco gringoli and matthias hollick.
.
franken stein advanced wireless fuzzing to exploit new bluetooth escalation tar gets.
in29th usenix security symposium usenix security august srdjan capkun and franziska roesner eds.
.
usenix association .
schumilo cornelius aschermann ali abbasi simon w rner andthorsten holz.
.
hyper cube high dimensional hypervisor fuzzing.in27th annual network and distributed system security symposium ndss2020 san diego california usa february .
the internetsociety.
schumilo cornelius aschermann robert gawlik sebastian schinzel and thorsten holz.
.
kafl hardware assisted feedback fuzzing for oskernels.
in26th usenix security symposium usenix security vancouver bc canada august engin kirda and thomas ristenpart eds.
.
usenixassociation .
shi runzhe wang ying fu mingzhe wang xiaohai shi xun jiao houbing song yu jiang and jiaguang sun.
.
industry practice of coverage guided enterprise linux kernel fuzzing.
inproceedings of the acm joint meetingon european software engineering conference and symposium on the foundationsof software engineering esec sigsoft fse tallinn estonia august marlon dumas dietmar pfahl sven apel and alessandra russo eds.
.acm .
song bo yu xu zhou and qiang yang.
.
spfuzz a hierarchicalscheduling framework for stateful network protocol fuzzing.ieee access7 .
song felicitas hetzelt dipanjan das chad spensky yeoul na stijnvolckaert giovanni vigna christopher kruegel jean pierre seifert and michaelfranz.
.
periscope an e ective probing and fuzzing framework for thehardware os boundary.
in26th annual network and distributed system securitysymposium ndss san diego california usa february .
theinternet society.
vasudev vikram rohan padhye and koushik sen. .
growing a test corpuswith bonsai fuzzing.
in43rd ieee acm international conference on softwareengineering icse madrid spain may .
ieee .
yang je huang and guofei gu.
.
automated generation ofevent oriented exploits in android hybrid apps.
in25th annual network anddistributed system security symposium ndss san diego california usa 670demystifying the dependency challenge in kernel fuzzingicse may pi t tsburgh pa usafebruary .
the internet society.
zhai yu hao hang zhang daimeng wang chengyu song zhiyunqian mohsen lesani srikanth v. krishnamurthy and paul yu.
.
ubitect a precise and scalable method to detect use before initialization bugs in linuxkernel.
inesec fse 28th acm joint european software engineering conferenceand symposium on the foundations of software engineering virtual event usa november prem devanbu myra b. cohen and thomas zimmermann eds.
.
acm .