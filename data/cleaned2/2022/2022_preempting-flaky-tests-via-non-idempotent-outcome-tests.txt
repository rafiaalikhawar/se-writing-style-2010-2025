preempting flaky tests via non idempotent outcome tests anjiang wei stanford university anjiang stanford.edupu yi peking university lukeyi pku.edu.cnzhengxi li university of illinois zli89 illinois.edu tao xie peking university taoxie pku.edu.cndarko marinov university of illinois marinov illinois.eduwing lam george mason university winglam gmu.edu abstract regression testing can greatly help in software development but it can be seriously undermined by flaky tests which can both pass and fail seemingly nondeterministically on the same code commit.
flaky tests are an emerging topic in both research and industry.
priorworkhasidentifiedmultiplecategoriesofflakytests developed techniques for detecting these flaky tests and analyzed some detected flaky tests.
to proactively detect i.e.
preempt flaky tests we propose to detectnon idempotent outcome nio tests anovelcategoryrelated to flaky tests.
in particular we run each test twice in the same test execution environment e.g.
run each java test twice in thesame java virtual machine.
a test is nio if it passes in the first run but fails in the second.
each nio test has side effects and selfpollutes thestatesharedamongtestruns.weperformexperiments on both java and python open source projects detecting nio java tests and nio python tests.
we have inspected all detected tests and opened pull requests that fix tests with already accepted only rejected and the remaining pending.
acm reference format anjiangwei puyi zhengxili taoxie darkomarinov andwinglam.
.
preempting flaky tests via non idempotent outcome tests.
in 44th internationalconferenceonsoftwareengineering icse may21 pittsburgh pa usa.
acm new york ny usa pages.
.
introduction nondeterministic tests that can pass or fail for the same version of thecodeundertestareknownbymultiplenames.practitionersand researchers most often call these tests flaky but also call them flappers unreliable tests brittle assertions nondeterministictests erratictests andmore.inthispaper weusetheterm flakytests.flakytestshave beenreportedasanimportantprobleminacademicresearch e.g.
atleastsevenpapersfrom2021analyze anddetect flaky tests and in both grey literature e.g.
blogs from gradle salesforce and thoughtworks and research permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
facebook google huawei microsoft and mozilla .
one well studied category o f flaky tests are order dependent od tests whose outcome depends on the order in which tests are run od tests occur in twomajorsituations.first testingframeworks suchasjunit do notmandatetheorderinwhichtestsarerun andtestsuitesthat pass in one order can start failing when run in another order.
a notoriousexampleoccurredwhenthejavastandardlibrarychanged from java to java many test suites that used to pass started failing resulting in many publicly reported complaints .
second testscanrunindifferentordersduetotheuseofregression testing techniques such as test prioritization test selection and test parallelization .
the terminology on od tests is somewhat confusing as prior papers usedthesametermwithdifferentmeaningsorintroducednewtermsforsame similarconcepts.
wefollowthemostrecentlyusedterminology .following shietal.
wecallatesta victimforagiventestsuite e.g.
t1in figure1 ifthetest failswhenrun afteranothertest calleda polluter inthesametestsuite e.g.
t2infigure1 but passeswhenrun before that other test.
the victim fails because the tests share some state xin figure and the polluter modifies i.e.
pollutes thesharedstate.huoandclause calledthetestassertionsthat dependonthesharedstate brittleassertions .eachvictimhasat leastonebrittleassertion butnotalltestswithabrittleassertion are victims e.g.
t3in figure has a brittle assertion but no test pollutes z .
we call a test a latent victim if it has a brittle assertion but may or may not be a victim in the current test suite.
note that a polluter is defined with respect to a given test suite where the test suite has a victim.
gyori et al.
used the term polluter torefertoanytestthatchangessomesharedstateevenif ithasnovictiminthecurrenttestsuite e.g.
t4infigure1modifies ybut no test fails because of that .
to avoid confusion we use latent polluter torefertoatestthatmodifiesthesharedstatebut mayormaynothaveavictiminthecurrenttestsuite.following musuvathi et al.
a latent polluter can be also called a nonidempotent statetest becausethetestdefinitelymodifiesthestate butrunningthetesttwicemayormaynothaveadifferentbehavior.
to reduce the risk that flaky tests fail at inopportune times practitioners andresearchers haveadvocated for proactively detecting potential flaky tests i.e.
preempting them from becoming flaky.
for example to preempt od related tests huo and clause proposed using dynamic taint analysis to detect latent victims and gyori et al.
proposed monitoring ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa anjiang wei pu yi zhengxi li tao xie darko marinov and wing lam shared variables x y z w are initialized to 2voidt1 assert x victim 3voidt2 x polluter 4voidt3 assert z latent vi ctim 5voidt4 y latent polluter 6voidt5 assert w w nio figure example test suite containing different kinds of victims and polluters including an nio test.
the shared heap state and file system to detect latent polluters.
however whiledetectinglatent victimsandlatent polluters the keyistobalancedetectingasmanytestsaspossiblewithdetecting tests that are worth fixing.
for example gyori et al.
figure reported many false positives they automatically found latent polluters manually inspected all and filtered out tests that cannot reasonably become polluters e.g.
modify state that cannotbeobservedviaanypublicapibutonlythroughreflection and did not fix any of the remaining tests.
todetectlatent victimsandlatent pollutersthatareworthfixing we propose to focus on non idempotent outcome nio tests which are related to od tests and similar to unrepeatable tests .
a test is an nio test if the test outcome pass or fail changes after repeated test runs due to the changes of the state shared amongruns of the nio test e.g.
t5in figure .
for a test tto be an nio test tmust write and read some shared state win figure .
detecting tcanbehelpfulbecauseanodtestcanemergewhen tis run together with anothertest from the current or future versions of thet s test suite where that other test writes or reads a part of thestatesharedwith t.iftheothertestwritestothesameshared state then tcan become flaky victim if the other test reads the shared state then tcan become a polluter with the other test as flaky victim.
figure shows the relationship of multiple categories of od related tests.
nio tests are important to detect because they may be more worthyfixingthanotherlatent victimsandlatent polluters considering that nio tests are bothlatent victims andlatent polluters at the same time.
in contrast to many false positives that gyori et al.
reported for latent polluters with no pull requests opened we find that developers are receptive to our nio test fixes.
while debugging nio tests in unfamiliar projects can be timeconsuming wehavefixedmanynioteststhatwehavedetected in open source projects.
specifically we have opened pull requests for tests.
developers have accepted fixes for of the tests withonly6rejected andtheremaining70pending.
oneproject is an outlier as we have opened fixes for nio tests and the developers have accepted our fixes for all tests.
to detect nio tests we use a simple idea run each test twice in the same test execution environment to check whether thetest passes in the first run but fails in the second run.
as prior work on flaky tests has been mostly for java and recently for python weperformourevaluationonopen sourcejavaand pythonprojects thegeneralprincipleeasilyextendstootherlanguages.weruneachtesttwiceinthesameexecutionenvironment ajavavirtualmachine jvm orapythoninterpreterforjavaorpython tests respectively.
a test is categorized as nio if the test outcomechanges deterministically from pass to fail .moreformally we require that there existsa test order angbracketleft... t t ... angbracketrightsuch that running the test tresults in the outcomes pass and fail .
figure2 relationshipofpolluters victims latent polluters latent victims and nio tests.
todetectniotestsforjavaprojects weevaluatethreemodes thatruntestsinisolationortogether.onemodererunsonly onetest methodin thesame execution environment anothermode reruns test methods from only one class and the third mode reruns all test methods from the entire test suite.
we modify the idflakies tool to support running the same test twice withoutchanging thetestcode.bydefault junitdoes notrunthesametest method twice.
hence prior tools for flaky tests including dtdetector electrictest idflakies ifixflakies and pradet do not contain this feature.
ourevaluationon127testsuitesfromopen sourcejavaprojects detects nio tests in of the test suites.
the three modesdetect only slightly different tests but rerunning all tests from theentiretestsuiterunsthefastest.weapplythatmodeon1006 python projects and detect nio tests in projects.
of the detectedniotests 42arenotniointhelatestversion i.e.
already fixed or deleted .
we have inspected in detail all remaining testsandopenedpullrequestsfor84 ofthetests.each test requires building the project running the test and debugging thesharedstate usuallyrequiringatleastanhourfrommultiple authors.
section .
discusses our experience of fixing nio tests and section presents multiple real cases of our fixes.
in this paper we make the following main contributions nio tests.
we define nio tests as tests that deterministicallychangeoutcomefrom pass to fail whenruntwice in the same execution environment nio tests are in the intersection of latent polluters and latent victims.
effective detection.
we propose three modes to detect nio tests by repeatedly running tests either in isolation ortogether in the same execution environment.
empirical evaluation.
we evaluate all modes on java test suites and detect nio tests.
we also evaluate themost effective mode on python projects and detect additional nio tests.
real cases.
wepresentmultiplerealcasesofnioteststo illustratethespecificcausesthatmakethemnioanddiscuss our experience in fixing nio tests.
well accepted fixes.
we have opened pull requests that fix tests with of them accepted only rejected and the remaining pending.
our dataset and scripts are publicly available .
background modes and examples niotestsarerelatedtoodtests whichcanpassorfailbasedon the order of the tests in the test suite.
section has introduced the most common kinds of od related tests.
we introduce one less common kind here.
od tests deterministically fail when run in some pre states.
a test that fails for all pre states is a broken not authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
preempting flaky tests via non idempotent outcome tests icse may pittsburgh pa usa flaky test.
beyond victims and polluters defined in section shi et al.
defineda brittleas atest thatfails evenwhen run inthe starting execution environment state i.e.
a brittle bfails in the order angbracketleftb angbracketright and has at least one test sin the test suite such that s sets the state for the brittle to pass i.e.
bpasses in the order angbracketlefts b angbracketright .
in contrast victims pass in the starting state i.e.
a victim vpasses intheorder angbracketleftv angbracketright butfailafterapolluter p i.e.
vfailsintheorder angbracketleftp v angbracketright victims are much more common than brittles.
in all prior work various tests in the same order were all differenttests because each test was always run only once in a test order.
incontrast niotestsstemfromrepeatingthe sametest.inthe simplestcase onlyonetest tisrun twice i.e.
the orderis angbracketleftt t angbracketright.if thefirstrunfails thetestisabrittle.however ifthefirstrunpasses and the second run fails the test is nio.
note that each nio test is by definition botha latent victim and a latent polluter it selfpollutes the state on which it depends.
moreover some nio tests maybevictimsorpollutersintheirtestsuite butourevaluation for java tests shows that most of the nio tests .
are neitherpolluters norvictims in their test suite.
.
three modes for detecting nio tests weevaluatethree modestodetectniotests.eachmoderepeatedly runs just a particular test method from a test class isolatedmethod all the test methods from a test class isolated class or all the test methods from a test suite entire suite .
for example consideratestsuitewithtwotestclasses candd andthreetests1 c.t c.u andd.vwiththeirexplicitlylistedclasses isolated method repeatedly runs each test in its own vm2twice e.g.
angbracketleftc.t c.t angbracketright isolated class runs all tests from each test class in one vm e.g.
angbracketleftc.t c.t c.u c.u angbracketright entire suiterunsalltestsfromthetestsuitein one vm e.g.
angbracketleftc.t c.t c.u c.u d.v d.v angbracketright.
different modes for detecting nio tests could have trade offs in termsoftheteststhattheydetectormiss andhowfasttheyrun.
comparedtoisolated classandentire suite isolated methodwould miss detecting a test tas nio if another test t prime sets pollutes the statesothatrunning angbracketleftt prime t t angbracketrightmakesthesecond tfail whilerunning just angbracketleftt t angbracketrightmakes both runs pass.
in our experiments section we find that isolated method does notmiss detecting any nio testthatisolated classandentire suitedetect.however isolatedmethod needs to create a new vm for every test so this mode can run substantially slower than the other modes.
some prior projects did compare running java tests isolated in jvm vs. alltogetherinonejvm butthoseprojectswere notrepeatingtests trying to detect nio tests.
on the other hand isolated class and entire suite would also miss detecting a test tas nio if some other test t prime prime sets cleans the state so that running angbracketleftt prime prime t t angbracketrightmakes both tpass or both fail while runningjust angbracketleftt t angbracketrightmakesthefirst tpassandthesecond tfail.inour experiments wefindthatentire suitemisses13 of223 niotests detected by isolated method.
of the tests are not detectedbecause they fail in both runs which should prompt developersto inspect them already.
the remaining tests are not detected because they pass in both runs.
section .
presents more details.
1we use the term test to refer to a test method following the junit terminology and how the test code is organized into test classes that contain test methods.
2weusetheterm vm torefertoanexecutionenvironment suchasajavavirtual machine or a python interpreter.1static atomicinteger counter newatomicinteger 2classcommand...exception 3public void execute ... counter.incrementandget throw new activitiexception test 9public void testretryinterceptor ... setup retryinterceptor and processengine 11try processengine.getmanagementservice .
executecommand newcommand...exception assert.fail ... catch activitiexception e ... assert what number of retries failed 17assert.assertequals retryinterceptor.
getnumofretries counter.get after 20public void shutdownprocessengine 21processengine.close counter.set figure our fix for an example nio test detected by allmodes in activiti .
toillustratethedifferencesandsimilarities wenextshowtwoexamplesofrealnioteststhatwedetectinopen sourcejavaprojects atestdetectedbyallthreemodesand atestdetectedbyonly isolated method.
these examples come from popular java projects showing that even mature well tested projects can have nio tests.
section discusses more examples of nio tests.
.
.
nio test detected by all modes.
figure shows an nio test detected by all three modes.
this test is from the project activiti which is a light weight workflow and business process management platform.
thetestretryinterceptor teststartsbysettingupa retryinterceptor which is used to set up a processengine line .
the test thenrunsacommandwiththe processengine line12 beforeassertingthatsomenumberofretriesareperformed lines15and17 .
by default the retryinterceptor is set to retry a command three times if it fails.
specifically the command object used by the test is command...exception which simply increments the sharedcounter before throwing an exception lines .
this test is nio because of the shared countervalue.
the test asserts line that the number of retries recorded by retryinterceptor is the same as the value of the counter.
in the first test run the retryinterceptor ensures that the command line is retriedthreetimes 1forthefirsttry andthetestpassesasthe executemethod line3 willhaverunfourtimes setting counter tofour.however inthesecondtestruninthesamejvm the retryinterceptor is reinitialized and starts with zero retry while the counteris notreinitializedandwillalreadybefourfromthefirst run of this test.
indeed the exception for the test failures in thesecond run is that retryinterceptor.getnumofretries is four whilecounter.get is eight from the two runs of the test.
we prepare a fix by resetting the counterto in the after methodoftheclass line22 .ourpullrequest forthisfixhas been accepted by the developers.
an alternative fix would have authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa anjiang wei pu yi zhengxi li tao xie darko marinov and wing lam test 2public void testsize throws interruptedexception ... create an object i n internalthreadlocal 4assert.asserttrue size method is wrong!
internalthreadlocal.
size ... create an object i n internalthreadlocal 6assert.asserttrue size method is wrong!
internalthreadlocal.
size internalthreadlocal.removeall test 10public void testsetandget ... setup testval and internalthreadlocal ... create an object i n internalthreadlocal 13assert.asserttrue set is not equals get objects.
equals testval internalthreadlocal.get figure4 ourfixforanexampleniotest testsize detected by only the isolated method mode in dubbo .
addedcounter new atomicinteger atthestartofthetest.
the testretryinterceptor test isneithera victim nor a polluter.
.
.
nio test detected by one mode.
figure shows a test detectedasnioinonlytheisolated methodmode.thistestisfrom the project dubbo which is a high performance remote procedure call framework.
thetestsize test checks whether the size method defined ininternalthreadlocal correctly returns the total number of local internalthreadlocal objects bound to the current thread.
the test first creates a thread local object and asserts that size returns line .
the test then creates another thread local object and asserts that size returns line .
thistestfirstpassesandthenfailswhenruntwiceintheisolatedmethod mode because the test does not remove the two created objectsbetweenthetwotestruns.specifically duringthesecond run of this test in the same jvm three objects are bound to the currentthread twoobjectsfromthepreviousrunofthetestand one new object from the current run ofthe test while during the firstrunonlyoneobjectisbound.therefore inthesecondrun the test fails the first assertion line .
incontrast testsize failsin bothrunsof theisolated classand entire suitemodesandis thus notreportedasnio.inthesetwo modes testsize runs after testsetandget line which also createsathreadlocalobject line12 anddoesnotremoveit.essentially testsize is not only nio when run in the isolated method mode but also a victim with testsetandget being the polluter.
although testsize isnotreportedasniointheisolated class and entire suite modes the test does fail in both modes and developerswouldideallyfixallfailingandniotests.section4.2describes aninterestingcasewhereatestpassesinbothisolated classand entire suite modes but is detected as nio in isolated method.
our fix simply adds internalthreadlocal.removeall at the end of the test line .
our pull request for this fix has been accepted by the developers.
research questions and setup to improve the understanding of nio tests we investigate the following research questions rqs rq1 how prevalent are nio tests in projects with flaky tests?
rq2 how do different running modes affect nio test detection?
rq3 how do the runtimes of detection modes differ?
rq4 how do developers respond to proposed fixes for nio tests?
rq5 how do nio tests compare to other od related tests?
weempiricallyaddresstheserqsonjavaandpythonprojects.
we first describe how we select the projects for our evaluation.
we use java projects for all five rqs but python projects for only rq1 andrqs4 .wedonotusepythonprojectsforrqs2 3toreducethe machinecosts ourevaluationonjavaprojectsfindstheentire suitemodetobethebesttrade off.wenextdescribehowweuse modify some testing tools forour evaluation.
we finally describe how we confirm the detected nio tests.
.
projects forjava weusetheprojectsfromourrecentstudies onflaky tests.thestudiesfoundatleastoneflakytestin55open sourcejava projectsobtainedfromgithub.foreachproject weusethesame gitcommitasthestudies.weusethesameprojectsandcommits becausethestudiesdetectedvictimsandpollutersinthespecificproject commits thereby allowing us to compare nio tests that we detect to previously detected tests section .
.
however these projectcommitsaresomewhatolder sosomedetectedniotests may be already fixed or deleted in the latest project version.
allselectedprojectsusethemavenbuildsystem soeach testsuiteinourstudy asinpriorstudies isamavenmodule.
maven basedjavaprojectsareorganizedinasetofmodulesthatcaneachhavetheirowncodeundertestandatestsuite.ourstudyuses of the modules from the recent studies.
we omit modules because we have trouble running their tests.
all projects use junit the most popular testing framework for java.
most maven plugins runthesameoperationoneachmoduleintheproject.surefire isthedefaultmavenpluginforrunningtests executing mvn test at the top level of a maven based project runs surefire for eachmodule in the project.
surefire then finds all test classes in themodule and passes them to junit which for each test class findsall test methods and runs them withoutrepetition.
as described insection3.
weadapttheidflakiestool toenablerunning various modes withtest repetition.
for python we use the dataset from a recent study by gruber et al.
.
the dataset has projects each of which is reported to haveatleastoneflakytest.todetectniotests weruneachproject onthecommitinwhichthedatasetreportsatleastoneflakytest.
buildingpythonprojectscanbedifficultduetodependency related errors .
we use flapy the infrastructure released with the dataset for building the projects and running the tests.
.
tools for detecting nio tests forjava wemodifyaresearchtestingtool i.e.
idflakies to enable repeating tests in one execution without any changes tothe test code.
we choose idflakies because we are familiar withthe tool and it works for the java projects that we select .
our extension is relatively simple as idflakies already treats the inputasa listoftestsandallowsrepetition.however theoutput that idflakies produced for multiple test runs would overwrite the resultsofearlierrunswiththelaterrunsbecausethetestnamewas authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
preempting flaky tests via non idempotent outcome tests icse may pittsburgh pa usa used as a key to the run result.
to support running test s multiple times in one jvm we change how idflakies reports results and have added our change to idflakies.
forpython thedatasetthatweusecomeswithaninfrastructure to run tests using pytest the most popular testing framework in python.
to run each test multiple times in one python interpreter weusea pytestplugincalled pytest repeat .we invokepytest repeat with count withnomodificationstothe test code.
from the output we exclude parameterized unit tests whose name includes a square bracket and unittest style tests whose class extends unittest.testcase because pytest repeat cannotrunthemcorrectly .ifpytest repeat didnothavethese limitations we could have detected even more nio tests in the projects that we evaluate.
to ensure that our experiments finish in areasonableamountoftime weseta10 secondtimeoutforeach test.
only of tests time out.
werunsetupsandteardownsduringniodetectionforbothjava andpython.wedonotcleanthediskstatebetweenrunsbecause the cleaning would be too expensive.
.
confirming detected nio tests runningatesttwiceandobservingthefirstrunpassandthesecond run fail does notguarantee that the test is nio because some tests arenon deterministic i.e.
theycanpassandfailinrepeated runsevenforthesametestorder.moreover consideringthatidflakiesor pytest repeat mayhavebugs wewanttocheckwhether all nio tests detected by these two specialized tools can also be detectedusingthetoolsthatdevelopersmorecommonlyusetorun tests such as surefire and junit for java and pytestfor python.
for both java and python we confirm whether the detected testsareniobyaddingacopyofthetestandrunningtogetherthe originalandthecopy thuseffectivelyrunningthetesttwice.forex ample forajavatest testpublicvoidtestoriginal body wecanadd test public void copy testoriginal .running a test twice by adding a copy is fairly reliable and robust.3using a copy to confirm the detected nio tests we remove the tests that arebrittles ornon deterministic.beyondconfirmingeverytest fromtable2byrunningacopy wemanuallyinspectthecodeto identify the shared state.
our manual inspection and running of theoriginalandcopyoftheniotestsconfirmthat everytestinour evaluation is indeed nio no false positives .
anotherbenefitofaddingatestcopyistoshowthatoneneed notusespecializedtools suchasidflakiesand pytest repeat to detecttheniotests.forjava wealsoconsiderconfirmingtheniotestswiththe ruleand classrule annotationfromjunit.wefind these annotations to be worse than adding a copy because they do not work for some older versions of junit or when the test class uses some specialized test runners.
results .
rq1 prevalence of nio tests forjava wedetectatotalof223niotestsin34modules.weapply ourthreedetectionmodesto127modulesanddetectatleastone 3running a test copy however can mask the confirmation of nio tests when the test name affects thetest behavior e.g.
the test name matchessome external resource in the file system.
we do not observe such a problem in our additions of copy.1public class searchquerytest extends ... override public void setup super.setup createuser bob ... createuser barbara ... createuser anton ... createuser robert ... createuser john ... session session getsession session.flush session.gettransaction .commit session.begintransaction test 15public void no where assertequals query .fetch .
size figure nio test no where i n querydsl .
nio test in of modules.
these modules have a total of tests so nio tests are over .
of all tests in these modules.
modulem20 with122niotests isanoutlier.evenignoringthis module westillfindtheratioofnioteststobenon negligible over .
out of of all tests in the remaining modules.
for python we detect a total of nio tests in projects.
we apply the entire suite mode to projects and detect at least one niotestinabout9 ofprojects.thismoderunsatotalof34 tests in these projects so nio tests are over .
of all tests.
table shows the statistics of the nio tests detected in java modules.duetolimitedspace weomitadetailedbreakdownfor90 pythonprojects.foreachjavamoduleinwhichourexperiments detect at least one nio test we tabulate the github slug username project and module name the number of nio tests that are detected for isolated method im isolated class ic and entiresuite es modes the time to run our experiments for the threedifferent modes and the time ratios.
in section .
we compare nio tests to other kinds of od related tests in these java modules and python projects.
a1 nio tests are currently prevalent enough that every project should run nio detection at least once.
.
rq2 niotestsdetectedindifferentmodes section has introduced our three modes to detect nio tests.
in our experiments the majority of nio tests are detected by allthreemodes.alltestsdetectedbyentire suitearedetectedby isolated class andalltestsdetectedbyisolated classaredetected by isolated method.
in contrast isolated method detects and tests that are not detected by isolated class and entire suite respectively.
our inspection finds that resp.
tests are notdetected by isolated class resp.
entire suite because they havepolluters in the test class resp.
test suite .
these polluters run beforetheniotests makingthemfailtwice intheisolated class orentire suitemode.section2.
.2presentsanexampleofoneofthese tests where a polluter makes the example test fail in both runs of the isolated class and entire suite modes.
the remaining out of tests which pass in the first run and fail in the second run in isolated method interestingly pass in both runs in the isolated class and entire suite modes.
all three tests are from the module m22 querydsl hibernate search and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa anjiang wei pu yi zhengxi li tao xie darko marinov and wing lam table statistics about the nio tests detected and the time taken in various modes im isolated method ic isolated class es entire suite .
overhead shows the ratio of runtime for various modes.
nio tests time to run overhead idproject user name module imicesim icesim icim es m1activiti activiti activiti engine .
.
m2activiti activiti activiti spring boot starter .
.
m3apache hadoop hadoop hdfs httpfs .
.
m4apache hadoop hadoop hdfs nfs .
.
m5apache hadoop hadoop mapreduce client app .
.
m6apache hadoop hadoop mapreduce client core .
.
m7apache hadoop hadoop mapreduce client jobclient .
.
m8apache hbase hbase server .
.
m9apache incubator dubbo4 dubbo cluster .
.
m10apache incubator dubbo dubbo common .
.
m11apache incubator dubbo dubbo config api .
.
m12apache incubator dubbo dubbo monitor default .
.
m13apache incubator dubbo dubbo remoting netty .
.
m14apache incubator dubbo dubbo rpc api .
.
m15apache incubator dubbo dubbo rpc rest .
.
m16eclipse ee4j tyrus non deployable .
.
m17elasticjob elastic job lite elastic job lite core .
.
m18looly hutool hutool core .
.
m19orbit orbit actor tests .
.
m20pholser junit quickcheck core .
.
m21pholser junit quickcheck generators .
.
m22querydsl querydsl querydsl hibernate search .
.
m23spring projects spring boot spring boot .
.
m24spring projects spring boot spring boot actuator .
.
m25spring projects spring boot spring boot actuator autoconfigure .
.
m26spring projects spring boot spring boot test .
.
m27spring projects spring boot spring boot test autoconfigure .
.
m28spring projects spring ws spring ws core .
.
m29undertow io undertow servlet .
.
m30vmware admiral kubernetes .
.
m31vmware admiral common .
.
m32vmware admiral request .
.
m33wildfly wildfly server integration .
.
m34zalando riptide riptide spring boot starter .
.
sum arith.
mean geo.
mean .
.
all three tests have the same root cause.
one of the three tests searchquerytest.no where is shown in figure .
unlikethetwoexamplesdescribedinsection2 thepollutedstate that causes no where to fail is not on the heap but in a database stored in the file system.
specifically the test adds five entries to a databaseandthencheckswhetherthedatabasecontainsfiveentries line .
the entries added to the database are saved to the file systemonlyafterallofthetestsfinishandthejvmexits.therefore in the isolated class and entire suite modes even when this test is runmultipletimes andthe setup methodisrunmultipletimes all of the runs use a new empty database and all of the runs pass.
however we find no where to pass inthe first run and failin the second run in the isolated method mode because we already run twice another test in the searchquerytest class saving the database to the file system before no where runs.
the first run of 4apache incubator dubbo nowredirectsto apache dubbo butwekeeptheoldname to be consistent with prior work.no where in the isolated method mode passes even with a polluted database because the database is loaded asynchronously and if the database is not ready by the first run then it simply uses a new databasefrommemory.ontheotherhand thesecondruntypically usesthepolluteddatabasefromthefilesystemandconsequently fails.
section .
describes more details about this test.
a2 allthreemodesdetectsimilartests butisolated methoddetects slightly more than isolated class which detects slightly more than entire suite.
.
rq3 runtime of different modes section has discussed how the three different modes can vary in the runtime due to the number of jvms that the modes need to run.
in all three modes the total number of test runsis exactly the same but the number of jvm runs differs greatly.
each jvm run hastostartajvmandloadtherequiredclasses takingnontrivial time.thenumberofjvmrunsneededisthesameasthenumber authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
preempting flaky tests via non idempotent outcome tests icse may pittsburgh pa usa of tests the number of test classes and one in the isolated method isolated class and entire suite modes respectively.
table1presentsthetimetorunthethreedetectionmodes.as expected theisolated methodmodeistheslowestamongthethree modes.specifically the geo.mean overheadoftheisolated methodmodeis8.4xand2.5xovertheentire suiteandisolated classmodes respectively.
these numbers confirm that the overhead for each jvm run is nontrivial .
our results also show that the m23 module has a much higher overhead for isolated method entiresuitethanothermodules.wefindthatthehigheroverheadisbecausem23hasthehighestnumberoftests ofallthemodules andconsequently isolated methodruns2 108jvms whileentiresuite runs only jvm.
as the entire suite mode runs substantially fasterthantheothertwomodesandyetmissesdetectingonly5.
of nio tests we recommend that developers regularly run theentire suitemodeandonlyrarelyruntheisolated methodmode to detect nio tests that the entire suite mode may miss.
followingourownrecommendation werunonlytheentire suitemode forpythonprojectsbutconfirmthedetectedpythonniotestsby running each test twice in isolation.
a3 the most cost beneficial mode is entire suite we suggest running entire suite periodically and isolated method for only newlyadded or directly modified tests .
.
rq4 experience with fixing nio tests we fix and open pull requests for nio tests.
of them are accepted only rejected and the remaining pending.
table showsthestatisticsaboutourpullrequests.therows java and python showthesumforalljavamodulesandpythonprojects respectively.toillustratediversity weshowdetailsforeachjava module.
due to space limit we show only the sum for python.
our experiments use an older version of projects to compare withvictimsandpolluters section4.
buttestsareworthfixing only in the latest version.
the table marks as n a tests thatarenotniointhelatestversion i.e.
fixed deleted ignored e.g.
annotated with ignorein java or archived.
we inspect all361 nio test that we detect even n a .
for each nio test we inspect for at least one hour before giving up and proceeding to the next test.
each nio test that we do not fix in our first iteration is reinspected later.
in the end we do not fix tests java and python for three reasons we cannot localize the pollution for java and python tests we localize the pollutionbutitisdifficulttoclean for13javaand13pythontests and wedonotfixteststhatarespecifiedtoruninspecificorders for1javaand5pythontests e.g.
annotatedwith testmethodorder in java because developers are likely already aware of the statepollution thus unlikely to want to clean the state pollution that makesothertestspass inotherwords theniotestsetsstatefor some brittle test .
anexampletestthatwedonotfixbecausewecannotlocalize thestatepollutionis authutilstest.testvalidatesessiondata from m31.thetesttriestocreateanewusereachtime checksseveral functionalities of the session and then clears the session.
in the secondrun thetestfailstheassertion assertequals authctxuser getop.getauthorizationcontext because the call getauthorizationcontext returnsnullinstead of the expected object.
we findtable2 statisticsaboutourpullrequests prs forniotests n a markstestsnotavailableinthelatestprojectversion.
nio tests nio tests in our prs id detected n aopened accepted rejected m1 m2 77n a m3 m4 m5 m6 m7 m8 m9 m10 m11 m12 m13 11n a m14 m15 22n a m16 m17 m18 11n a m19 11n a m20 m21 m22 m23 m24 m25 m26 m27 m28 m29 m30 m31 m32 m33 m34 java python total thatnullisreturnedbecauseattheendofthefirstrun theregularuser logsout via authutils.cleanupsessiondata getop .however aftercarefulinspection wefindthatseeminglyallthevariables involved in the test code are newly initialized and therefore wecannot easily identify the exact global variable that is shared be tween the two runs.
we envision that future research can apply program analysis techniques to help developers localize the shared state for nio tests.
an example test that we do not fix because we cannot clean the pollution is webmvcmetricsfiltertests.regexbasedrequestmapping from m24.
in the second run the test fails the assertion assertthat .timer .count .isequalto 1l because count returns2linstead of the expected 1l.
it is obvious that we need toresetthetimer ortheobjectthatstoresthetimer tocleanthe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa anjiang wei pu yi zhengxi li tao xie darko marinov and wing lam pollution.
however after extensive code search we cannot find a reasonable cleaning method.
moreover the receiver object for timer iscreatedbyaclassimportedfromalibrarydependency preventing us from easily implementing the functionality to reset the timer s state in the module m24 itself.
overall wefix268 oftheavailable319 testsbyrevising adding codetocleanthesharedstateoftheniotests therebymakingthem idempotent.the number ofopenedpullrequests prs is n a if allniotestsdetectedinamodulearenolongerapplicableinthe latest version.
our fixes cover at least one test in out of components java modules and python projects that have at least one nio test remaining in the latest version.
basedontheacceptancerateanddevelopers comments mostof our fixes have been appreciated by developers.
ignoring the outlier m20 ofalltheacceptedtests forjava forpython were acceptedwithoutcomments while60 wereacceptedwith developer compliments e.g.
nice catch thanks lgtm only for java for python tests had some discussions with developers e.g.
asking us to modify before .
out of the fixed tests only6 5forjavaand1forpython hadourprsrejected.forthe rejected tests in m3 and m26 the developers believed that thepolluted state would affect only the test itself and not any othertest and thus claimed that no fixes were needed .
for the three rejected tests in m27 the developers believed that our fix waspotentially masking theproblem .fortherejectedpython test thedeveloperappreciatedourfindingbyconfirmingthatthe niotestis certainlyavalidissue butrejectedourprbecausethe developer wanted to completely refactor the code instead .
themodulem20isabigoutlierwith120tests.wepointoutthat the fixes for these tests do have some diversity e.g.
modifying eightdifferentsetsofdatastructures.moreover eachtestrequiresadifferentlinetobefixed sofixingallthetestsisnotsimplychanging one line that is shared across all the tests.
reflectingonourprsandourlimiteddiscussionswiththedevelopers the lessons learned are that providing steps to reproduce testfailuresand explanationsofwhyfixingnioisbeneficialcan improve the likelihood that prs get accepted.
for example for one pr we had initially reported the failure message from running the test twice without providing or .
the developer commented i mnotsurehowthiswouldsolvethe andi ve never come across it and closed our pr.
after we provided and including cleanstate pollutionso thatsomeother testswon t fail in the future the developer promptly reopened and merged ourpr replying thanksfortheexplanation.theprmakessense .
our recent prs include both and .
a4 developers are generally positive about fixes for nio tests providing reproducing steps and explaining the motivation help.
.
rq5 nio victim polluter comparison every niotest isboth latent victimand latent polluter and some nio tests may be victims or polluters in their test suite.
to un derstand how the nio tests that we detect relate to od relatedtests detected in prior work we intentionally use the same pro jects modules and commits as prior studies for java and python thathavereportedsomevictimsorpolluters.detecting victims is expensive and typically requires running many random figure number of fixed java and python nio tests andtheir overlap with victim and for java only polluter tests.
orders of test suites or sophisticated analyses of test dependencies .detecting all pollutersisevenmoreexpensive asthedetectioncanrequirecheckingalltestpairs .in fact thepythondataset thatweusereportsonlyvictimsbut does not report polluters.
figure top row shows venn diagrams relating the number ofnio victim and forjavaonly pollutertestsinthesedatasets.
of223javaniotests only13arevictimsbutnotpolluters 7are pollutersbutnotvictims and8arebothvictimsandpolluters.of python nio tests only are victims.
we find that a large number of victims and polluters detected in prior work are notnio tests.
on the other hand despite the relation of victims and polluters to nio tests the majority of the nio tests that we detect werenotdetected before.
figure6 bottomrow showsvenndiagramsfocusingonthe268 nioteststhatwefix.of186fixedjavaniotests only12arealso victims 7arealsopolluters and1isbothvictimandpolluter.of fixed python nio tests only are victims.
the venn diagrams show some of the diversity of the nio tests that we fix.
a5 niotestsarerelatedtobutnotsubsumedbyodtests detecting nio tests can be an effective way to preempt od tests.
case studies we next discuss some interesting examples of nio tests that we inspectorfix.whileallniotestspollutesomepartoftheshared state differenttestspollutedifferentparts.theseexamplesillustrate various parts of the shared state that cause nio tests.
.
java database three tests from querydsl section .
are nio because of the statepollutedthroughadatabasestoredonthedisk.specifically the test fails an assertion line in figure with the message expected but was .thetestclass searchquerytest extends abstractquerytest whose before public void setup method insertsfivenewusersintoadatabase line8 .wheneverjunitruns the test class it invokes the setupmethod that inserts five more users into the database.
indeed if we run the test in two jvms the failure in the second jvm is due to every user being added twice.
our inspection reveals that each jvm run adds some files in the directory querydsl hibernate search target lucene indexes com.
querydsl.hibernate.search.user .thesefilesaredatabase related persist across different jvms and make the test nio.
interestingly these files are only persisted afterthe jvm finishes.
therefore authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
preempting flaky tests via non idempotent outcome testsicse may pittsburgh pa usa test 2public void testasync 3rpccontext rpccontext rpccontext.getcontext 4assert.assertfalse rpccontext.isasyncstarted 5rpccontext.setasynccontext newasynccontext ... ... checks no asynccontext has started 7rpccontext.startasync 8assert.asserttrue rpccontext.isasyncstarted 9asynccontext.write newobject ... assert something was done by asy nccontext 11rpccontext.stopasync 12assert.asserttrue rpccontext.isasyncstarted rpccontext.removecontext figure developer fix for nio test in dubbo .
runningthesametesttwiceorevenmoretimesinthesamejvm from a clean disk state does notlead to any test failure.
the fix for these tests is simple just correcting a typo changing fileutils.delete new file target lucene3 tofileutils.delete new file target lucene in the setup method.
this project usestravisciforcontinuousintegration butthisissueis notdetected inci becauseit runs theentire testsuite without repeated tests inonejvmalwaysfromacleandiskstate.incontrast running thetestsuitemultipletimesonthesamemachine e.g.
adeveloper s laptop would have detected the issue.
we opened a pr with our fix and the developers accepted it and replied thanks!
thumbs up alt .
.
java file system the test testviewfswithnfs3.testnfsrenamesinglenn fromhadoop checks whether it can rename a file represented by an hdfsfile object.this testisnio becauseofdiskupdates.
thetestfirst gets thehdfsfile that it tries to rename and checks the status of this hdfsfile.
the test then renames that hdfsfile and checks its status after renaming.
in the second run on the same jvm this testraises a nullpointerexception specifically from invoking statusbeforerename.isdirectory .beforerenaming thetestchecksthat thehdfsfile is not a directory.
the problem is that the test gets thehdfsfilestatus objectfor statusbeforerename basedonthefile name but the name has been changed in the first run so statusbeforerename becomes nulland causesthe exception.our proposed fix renames the hdfsfile again back to its original name at the end of the test and was accepted with merged.
thank you .
in the same project the test testtaskprogressreporter.testbyteswrittenrespectinglimit writes some bytes to the local file system.
it also increments some counters that are written to thefile system.
however after the test finishes the counters are not reset makingoneassertionfailwhenthetestrunsforthesecond time.
our fix invokes filesystem.clearstatistics to reset the counters at the end of the test and was also accepted.
.
java heap reachable from static fields the mostcommoncase fornio testsis heap pollution either the staticfieldsthemselvesortheobjectsreachablefromthestaticfields arepolluted.figure7showsanexampleniotestfrom dubbo .
thetest testasync startsbygettingaremoteprocedurecallcontext line .the testaims tocheckwhether thecontext properly exercisessometaskasynchronously.in 2public void testsigtermedfunctionality throws ... 3appcontext mockcontext mockito.
mock appcontext.
class 4jheventhandlerforsigtermtest jheh newjheventhandlerforsigtermtest mockcontext adds some jobid to the static filemap 7jheh.stop adds some jobid to the static filemap 9jheh.stop assertions at the end of the test a method to execute jheh.stop override 14protected voidservicestop throws exception log the info 16for map.entry jobid metainfo jobit filemap.
entryset jobid toclose jobit.getkey log the info finaljob job context.getjob toclose intsuccessfulmaps job.getcompletedmaps job.getfailedmaps job.getkilledmaps nullpointerexcep tion rai sed in the second run stop the job ... helper class for testsigtermedfunctionality 27classjheventhandlerforsigtermtest extends jobhistoryeventhandler 28public jheventhandlerforsigtermtest appcontext context intstartcount super context st artcount jobhistoryeventhandler.filemap.clear figure our fix for nio test in hadoop .
four times lines and whether the async task in rpccontexthasstarted.thefirsttwochecksbeforethe rpccontext starts the async task line are expected to be false while the later two checks are expected to be true.
the test is nio because the rpccontext fromline3 is sharedinallrunsofthistest.therefore thefirstcheck line4 inthesecondrunfails becausetheasync taskhasalreadystartedduringthefirstrun.notethateventhough line stops the async task the check on line still passes inthe first run while line fails in the second run because rpccontext.isasyncstarted is simply checking whether the async taskhasstartedbefore andnotwhetheritisstillongoing.inthe latestversion thedevelopershavecleanedthestatepollutionbyadding rpccontext.removecontext at the end line so the test is n a in table .
testjobhistoryeventhandler.testsigtermedfunctionality from hadoopisnio.figure8showstherelevantcodesnippet.theroot causeofthefailureisthatthistestaddssomeentriestothestatic fieldjobhistoryeventhandler.filemap whichissharedamongtests and does not remove the entries from the map.
jobhistoryeventhandler.filemap has as keys the ids of the jobs that have been created.
the call jheh.stop line in the test calls another method servicestop line which iterates over the jobhistoryeventhandler.filemap togetthejobids thengetseach jobobject byitsid andfinallystopsit.afterthefirsttestrun thecreated job objects are cleaned but their stale ids remain in jobhistoryeventhandler.filemap .therefore inthesecondrun thetestgets null from these stale ids line and throws nullpointerexception line22 .ourfixistoclear jobhistoryeventhandler.filemap atthe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa anjiang wei pu yi zhengxi li tao xie darko marinov and wing lam 1defcmd mock def cmd mock name str cmd.
overrides yield cmd mock cmd.
overrides cmd.
overrides figure our fix for nio test in benchbuild .
end of the constructor of class jheventhandlerforsigtermtest a helperclassofthistest line30 .infact theconstructorofanother helperclass jhevenhandlerfortest inthesamefileclears jobhistoryeventhandler.filemap sothesamecleanupneedstotakeplace in the constructor of jheventhandlerforsigtermtest .
our pr for this test has been merged by the developers.
metricstest.shouldrecordcircuitbreakers fromriptideis another test that is nio due to the pollution of the shared static field.
this test adds new timersto thesimplemeterregistry but does not clear them.
in the second test run the assertion assertequals timer.count attheendfailsbecausethe timer.count hasbeen incrementedto 8aftertwo runs.interestingly thisstatepollution not only makes the test fail in the second run but also causes an other test shouldrecordrequests in the same test class to fail.
in other words shouldrecordcircuitbreakers is a polluter for the victimshouldrecordrequests .
because this issue affects multiple tests we do not fix just one test body but add to the class a teardown method whichcleans simplemeterregistry aftereachtestrun.our pr forthistestwaspromptlyaccepted within10minutes and the developers gave a thumb up and thanked for our contribution.
.
java system property securityutilstest.testensuretruststoresettings inadmiraltests whetheritcanproperlysetsomesystemproperties.forexample forsecurity properties the test starts by getting the value of the system property with system.getproperty security properties .
thenitchecksthatthispropertyhasnotbeenset bycomparingthe valueto nullandanemptystring.thischeckpassesinthefirsttest run.thetestthenruns system.setproperty security properties ... andassertequals ... tosetanothervaluetothatsystem propertyand toassertthat ithasbeenproperly set.thetest isnio because it does not reset this system property at the end.
in the secondrunofthetestonthesamejvm thefirstassertion checking that this property has not been set fails.
thefixforthistestistocleanthepollutedsystemproperties e.g.
weaddsystem.clearproperty security properties .ourpr was pending review before the project got archived.
.
python buggy cleaning thetest test cli slurm.test slurm command frombenchbuild isnioduetoaninterestingstatepollution developershavecode tocleanthestatebutmistakenlypollutethetypeofavariableso that the test fails on the second run.
this type mistake is more likelytoappearinadynamicallytypedlanguage.figure9shows therelevantcodeandourfix.thetestcallsthefunction cmd mock thatitselfreturnsafunction cmd mock thatcanaddthecorresponding value of the key nameto a dictionary called cmd.
overrides .
notethat cmd.
overrides isaglobalvariablesharedamongtest1defto zero tvd northing easting surface northing surface easting perform somechecking northing surface northing easting surface easting northing northing surface northing easting easting surface easting return tvd northing easting initialization for global variables g1 g2 ... g5 10g1 ... 11deftest zero global variables passed in as arguments v1 v2 v3 to zero g1 g2 g3 g4 g5 np.testing.assert equal ... assertion figure our fix for nio test in wellpathpy .
1deftest celery integration server address server httpserver server address handler perform some assertions server.socket.close figure our fix for nio test in pybrake .
runs.
in the second run the test fails reporting typeerror list indices must be integers or slices not str .
the root cause iscmd.
overrides that sets the global variable to be an emptylist.whiledevelopershadthoughttocleanthestate they mistakenly wrote the wrong cleaning code.
our fix changes the empty list to the empty dictionary.
the developers accepted our pr and said thanks good catch!
.
.
python function side effect thetest test location.test zero fromwellpathpy isniodue to state pollution stemming from the side effects in the function under test.
figure shows the test and the function to zero.
the test calls to zeroby passing global variables of type numpy arrays initialized outside test zero .
the second run of the test fails causing assertionerror when executing line .
the root cause is that to zeromodifies the data in the numpy arrays passed in namely g2andg3 .
within to zero northing andeastingpoint to thesame numpy arraysas g2andg3 respectively.a discussion ofsuchaliasingfornumpyarraysisonstackoverflow .ourfix replacestheoperator thatmodifiesarraydata inplacewithan assignmentthatcreatesnewarraysanddoesnotmodifythearrayspassedin.thedevelopersmergedourpr andcommented this is a good change .
.
python network related the test test celery integration.test celery integration from pybrake isnioduetostatepollutionrelatedtonetwork.figure shows the relevant code and our fix.
the second test run throwsoserror address already in use .thereason is that the test does not release the network resource at the endof the execution and therefore the second run cannot initialize theserver usingthesameaddress.our fixistoclose theserverto make the address reusable after the test execution.
the developers merged our pr .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
preempting flaky tests via non idempotent outcome tests icse may pittsburgh pa usa discussion motivation and cost for rerunning a passing test.
one could question why rerun tests twice when it is not usually done and takes time.
the cost of rerunning tests twice to detect nio tests hasthebenefitto preemptorder dependent od tests aprominent category of flaky tests .
as a cost effective approach to proactively detect od related tests instead of rerunning all tests twice all the time developers could rerun only sometimes all tests periodically e.g.
every weekend or only some tests newly added or recently modified tests for all regression runs.
we previouslyproposedthesetwooptionsforotherflaky test detection approaches but not for rerunning tests twice.evidence of nio tests becoming polluters or victims.
we describethehistoryoftwoexamplesfrom hadoop.anexamplenio testthatbecameapolluteris testjobhistoryeventhandler.testsigtermedfunctionality whichonedeveloperhadadded in 5f52156a and later became a polluter when another developer added in 64e4fb98 three victims ten months later.
for this nio test the developers accepted our fix with compliments.
had the first developerusedourapproachtodetectniotests thetestcouldhavebeenfixedbeforethevictimswereadded.anexampleniotestthat became a victim is testtaskprogressreporter.testtaskprogress whichonedeveloperhadaddedfirst in 7e6f384d andthenbecame a victim when another developer added in cb26cd4b a polluter aboutsevenmonthslater.yetagain usingourapproachcouldhave prevented the later polluter victim pair.
threats to validity somekeythreatstovalidityaretheruntimeratiosandwhethertheteststhatwedetectarereallynioandworthfixing.ourcomparison of the runtime for different modes section .
can be affected by thenoiseinthemeasurementoftime.tomitigatethisthreat we run the experiments on isolated azure machines and claim only a general trend of the overhead of different modes.
as our evaluation for nio tests involves rerunning the tests our results could be affected by flakiness itself.
for example a test mayappearnio firstrunpasses secondrunfails althoughthe test is actually idempotent and happens to exhibit nio like results becauseofsomenondeterminism.tomitigatethisthreat wererun the nio tests with various tools and additionally manually inspect all detected nio tests to obtain higher confidence in the tests that we study.
in fact the projects under evaluation likely have more nio tests that are not detected because of tool limitations e.g.
pytest repeat does not run certain kinds of python tests .
we also use many existing tools and modify some to detect nio tests.inprinciple manyofthesetools suchasmavensurefire junit pytest orpytest repeat couldhavebugsthat impact our results.
we mitigate this threat by choosing some of themostwidelyusedbuildsystemsandtestingframeworks.ourownmodificationstoidflakies aremorelikelytohavebugs.
we mitigate this threat by having multiple authors check idflakies modificationsandmanuallyinspectvariousresults.finally thebest waytoalleviateconcernsaboutusefulnessofniotestsistoprovide fixesthatdeveloperslargelyaccept paraphrasingthesaying the proofisinthepudding wecouldsay theproofisinpring i.e.
opening pull requests that get accepted.
related work arecentsurvey reviewsmanypapersthathavestudiedvarious causes and categories of flaky tests .
these papers focus on tests that can pass or fail when running each test in a test suite only once.
in contrast wearethefirsttoinvestigateniotests whichpassand fail when run twice in the same vm.
tohelpwiththeproblemofflakytests varioustoolshavealso beenproposedtohelpdetectthesetests .most tools require running the tests and observing whether a test can pass in some runs and fail in other runs.
similar to these tools our detectionofniotestsisbasedonwhetheratestcanpassandfailin various runs.
unlike these prior tools we run the tests twice in the same vm.
our findings for nio tests are particularly important to the topic of flaky test detection because nio tests can pollute the state used by other tests andthey can fail themselves depending on the state set by other tests.
much of prior work on flaky test detectionhasbeenonorder dependenttests whichpassorfaildue to the pollution of othertests.
beyond detecting flaky tests related work has also proposed automatically fixing flaky tests tolerating flaky testsbyresettingstate accommodatingtestdependencies generatingorder dependentflakytestsusingmutations and accommodating order dependent tests in regression testing .
the ideas from these projects could help automatically fix or accommodate nio tests in the future.
niotestsarebothlatent victimandlatent pollutertests.oraclepolish andpoldet usesophisticatedtechniquestodetect latent victim and latent polluter tests respectively.
however they report many more tests that developers consider false positives.
morerecently additionaltoolshavebeenproposedtodetectpolluters .wereportthe importantintersection oflatent victim and latent polluter tests.
our approach is simplebut effective at preempting polluters and victims.
our approach is also portable e.g.
we evaluate on both java and python tests.
conclusion this paper has focused on nio tests which pass in the first run but fail in the second run in the same vm.
we have proposed threemodes todetectnio tests thesemodes detect223nio java tests and the most practical mode detects nio python tests.
these nio tests are mostly new and have notbeen detected by prior research on flaky tests.
we have opened pull requests for nio tests and developers have accepted many of them.
we hope that our promising results on nio tests and our publicly availabledataset can spur more research on this topic.