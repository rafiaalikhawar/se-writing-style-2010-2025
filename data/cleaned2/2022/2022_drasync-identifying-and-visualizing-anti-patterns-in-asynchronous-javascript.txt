drasync identifying and visualizing anti patterns in asynchronous javascript alexi turcotte turcotte.al northeastern.edu northeastern university boston ma usamichael d. shah mikeshah northeastern.edu northeastern university boston ma usa mark w. aldrich mark.aldrich tufts.edu tufts university medford ma usafrank tip f.tip northeastern.edu northeastern university boston ma usa abstract promises and async await have become popular mechanisms for implementing asynchronous computations in javascript but despite their popularity programmers have difficulty using them.
this paper identifies 8anti patterns in promise based javascript code that are prevalent across popular javascript repositories.
we present a light weight static analysis for automatically detecting these anti patterns.
this analysis is embedded in an interactive visualization tool that additionally relies on dynamic analysis to visualize promise lifetimes and instances of anti patterns executed at run time.
by enabling the user to navigate between promises in the visualization and the source code fragments that they originate from problems and optimization opportunities can be identified.
we implement this approach in a tool called drasync and found .6k static instances of anti patterns in 20popular javascript repositories.
upon examination of a subset of these we found that the majority of problematic code reported by drasync could be eliminated through refactoring.
further investigation revealed that in a few cases the elimination of anti patterns reduced the time needed to execute the refactored code fragments.
moreover drasync s visualization of promise lifetimes and relationships provides additional insight into the execution behavior of asynchronous programs and helped identify further optimization opportunities.
keywords javascript asynchronous programming program analysis visualization acm reference format alexi turcotte michael d. shah mark w. aldrich and frank tip.
.
drasync identifying and visualizing anti patterns in asynchronous javascript.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for third party components of this work must be honored.
for all other uses contact the owner author s .
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
introduction theasync await feature was added to the javascript programming language in to facilitate asynchronous programming with convenient syntax and error handling.
programmers can designate a function as async to indicate that it performs an asynchronous computation and await expressions may be used in these functions to await the result of other asynchronous computations.
the javascript community has enthusiastically embraced this feature as it is less error prone than event driven programming and syntactically much less cumbersome than the promises feature on which it builds.
however many javascript programmers are still unfamiliar with asynchronous programming and particularly with async await and how it interacts with promises.
as a result they sometimes produce code creating redundant promises or code that performs poorly because the ordering of asynchronous computations is constrained unnecessarily .
we identify 8anti patterns involving the use of promises and async await that commonly occur in javascript programs.
these anti patterns reflect designs that are likely to be suboptimal because they may create promises unnecessarily perform synchronization that is redundant or cause code to become needlessly complicated.
examples of these anti patterns include redundant uses of await the use of await in loops over arrays and explicit creation of new promises where none are needed.
in many cases these anti patterns can be refactored into code that is more concise or more efficient.
we developed a lightweight static analysis to detect these antipatterns directly in source code and implemented this analysis as a set of codeql queries .
furthermore to help programmers understand the run time impact of the anti patterns we developed drasync a profiling tool that visualizes the lifetime of the promises created by an application and that highlights the run time instances of each anti pattern.
this enables programmers to focus their attention on anti patterns in frequently executed code and provides valuable insights into where performance bottlenecks occur.
in an experimental evaluation drasync s static analysis detected .6k instances of anti patterns in 20javascript applications and drasync s dynamic analysis determined that in the aggregate these anti patterns were executed 24ktimes by the application test suites.
to evaluate whether the detected anti patterns represent actionable findings we selected 10instances of each anti pattern randomly and attempted to manually refactor them to eliminate the anti pattern.
we were able to successfully refactor 65of these 80instances and ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa alexi turcotte michael d. shah mark w. aldrich and frank tip determined that in certain cases these refactorings can have measurable impact on the number of promises created by an application or the time needed the execute affected code fragments.
in summary the contributions of this paper are as follows the definition of 8anti patterns that commonly occur in asynchronous javascript code drasync a tool that relies on static and dynamic program analysis to detect anti patterns and visualize promises and occurrences of anti patterns during program execution enabling programmers to quickly identify quality issues and performance bottlenecks an empirical study of 20javascript applications in which drasync is used to identify .6k anti patterns which are executed 24ktimes confirming that they are pervasive and a case study that investigates whether 10randomly chosen instances of each anti pattern can be refactored providing evidence that the majority of anti patterns reported by drasync can be eliminated through refactoring.
further analysis of these results suggests that under certain conditions eliminating anti patterns may improve performance.
promises and async await this section reviews promises and the async await feature features which were added to javascript in recent years to facilitate asynchronous programming.
readers already familiar with these features may skip this section.
apromise is an object that represents the value computed by an asynchronous computation and is in one of three states pending fulfilled or rejected.
upon construction a promise is in the pending state.
if the computation associated with a promise psuccessfully computes a value v then ptransitions to the fulfilled state and we will say that pisfulfilled with value v. if an error eoccurs during the computation associated with a promise p then ptransitions to the rejected state and we will say that pisrejected with value e. the state of a promise can change at most once accordingly we will say that a promise is settled if it is fulfilled orrejected.
creating promises.
promises can be created by invoking the promise constructor passing it an executor function expecting two arguments resolve andreject for fulfilling or rejecting the newly constructed promise respectively.
e.g.
the following code snippet letc ... letp1 newpromise resolve reject if c resolve else reject error!
assigns to p1a new promise that is fulfilled with the value or rejected with the value error!
depending on the value of c. convenience functions promise.resolve andpromise.reject accommodate situations where a promise always needs to be fulfilled or rejected with a specified value respectively.
for example the following code snippet letp2 promise.resolve letp3 promise.reject error!
assigns to p2andp3promises that are fulfilled with the value 4and rejected with the value error!
respectively.reactions.
to specify that a designated function should be executed asynchronously upon the settlement of a promise programmers may register reactions on promises using methods then and catch .
here a reaction is a function that takes one parameter which is bound to the value that the promise was fulfilled or rejected with.
for example the following code snippet p2.then v console.log v v extends the previous example by registering a reaction on the promise referenced by variable p2to print the value .
similarly the following code snippet p3.catch e console.log error e will cause the text error error!
to be printed.
promise chains.
thethen method returns a promise.
if the reaction that is passed to it returns a non promise value v then this promise is fulfilled with v. if the reaction that is passed to it throws an exception e then this promise is rejected with e. furthermore ifthen is used to register a reaction fon a promise p then the rejection of pwith a value ewill cause the rejection of the promise returned by p.then f with the same value e. this enables the construction of chains of promises.
in the following code snippet a promise chain is created starting with variable p1as defined above p1.then v v .then w console.log w .catch err console.log an error occurred.
ifp1was fulfilled with then the reaction v v will be executed asynchronously with vbound to the value 3and return the value4 so the promise created by this call to then is fulfilled with the value 4as well.
since a reaction w console.log w was registered on that promise the value 4will be printed.
if on the other hand p1was rejected with the value error!
the promises created by both calls to then will be rejected as well with the same value causing the reaction on the last line to execute which prints an error occurred.
.
linked promises.
so far we have only considered situations where a function fthat is registered as a reaction on a promise returns a non promise value.
however if freturns a promise p that promise becomes linked with the promise p created by the call to then or catch that was used to register the reaction.
concretely this means that p will be fulfilled with a value vif when pis fulfilled with v andp will be rejected with a value eifpis rejected with e and if p remains pending then so will p .
consider the following example letp4 promise.resolve letp5 newpromise resolve reject settimeout resolve p4.then v p5 .then w console.log w prints after one second here the promise referenced by p4is fulfilled with and the promise referenced by p5is fulfilled with 6after milliseconds have elapsed.
the reaction v p5 that is registered on p4returnsp5 so the promise created by this call to then becomes linked withp5 i.e.
it will be fulfilled with after milliseconds have passed.
the last line registers another reaction on this promise so the value 6is printed after milliseconds.
1thethen method optionally accepts a reject reaction as its second argument.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
drasync identifying and visualizing anti patterns in asynchronous javascript icse may pittsburgh pa usa synchronization.
several functions are provided for synchronization.
the promise.all function takes an array of promises as an argument and returns a promise that is either fulfilled with an array containing the values that these promises are fulfilled with or that is rejected with a value ei if piis the first promise among p1 pnthat is rejected and eiis the value that it is rejected with.
other synchronization functions includepromise.race andpromise.any .
for example2 the following snippet prints array after second letp6 promise.resolve letp7 letp8 newpromise resolve reject settimeout resolve foo promise.all .then vs console.log vs promisification.
promisification is a mechanism for automatically adapting an asynchronous event driven api into a promise based api.
it assumes that methods in an event driven api meet two requirements i the callback function is the last parameter ii upon completion of the asynchronous operation the callback function is invoked with two parameters errandresult where erris a value that indicates whether an error has occurred and result contains the result of the asynchronous computation otherwise.
in such cases an equivalent promise based api can be derived by creating a new promise that invokes the event driven api passing it a callback that rejects the promise with errif an error occurred and fulfills it with result otherwise.
promisifying event driven apis can be done using the built in util.promisify function.
async await .javascript allows a function to be declared as async to indicate that it computes its result asynchronously.
an async function freturns a promise if no exceptions occur during the execution of f this promise is fufilled with the returned value and if an exception eis thrown then the promise is rejected with e. inside the body of async functions await expressions may be used to await the settlement of promises including promises created by calls to other async functions.
concretely when execution encounters an expression await xduring the execution of an async function control returns to the main event loop.
at some later time when the promise that xevaluates to has settled execution resumes.
if that promise was fulfilled with a value v then execution resumes with the entire await expression evaluating to v. if the promise was rejected with a value e then execution resumes with the entire await expression throwing an exception e. theasync await feature has been designed to interoperate with promises as is illustrated by the example below.
import fs from fs async function analyzedir dname letfnames awaitfs.promises.readdir dname letps fnames.map fname fs.promises.stat fname letfstats awaitpromise.all ps letsum fstats.reduce acc v acc v.size console.log sum 2adapted from global objects promise all.the example shows an async function analyzedir that prints the sum of the sizes of the files in the directory identified by its parameter dname .
on line an await expression is used to await the results of the built in readdir operation this operation returns a promise that is eventually fulfilled with an array containing the names of files in the specified directory which is assigned to fnames .
on line the mapoperation on arrays is used to map the builtinfs.stat operation3over this array resulting in an array psof promises that will eventually resolve to objects containing metainformation for each file.
promise.all is used on line to create a promise that is eventually fulfilled with the meta information objects for each of the files and an await expression is used to await this result so that it can be stored in a variable fstats .
on line the reduce operation on arrays is used to compute the sum of the sizes of the files and this sum is printed on line .
javascript s async await feature can be thought of as syntactic sugar for promise based asynchrony.
consider function fetchasynchronously url fetch url .then response response.json .then jsonresponse do something here the function fetchasynchronously takes aurl fetches it converts it to json and then does something with it all using promises.
in this setup the bulk of the function logic would be in the body of the last callback do something .
using async await we can write the function more concisely as async function fetchasynchronously url constresponse awaitfetch url constjsonresponse awaitresponse.json do something motivating examples asynchronous programming is rife with pitfalls.
as a first example consider sap s ui5 builder project which provides modules for building ui5 projects.
ui5 builder s file resourcepool.js contains the following function which drasync flagged as an instance of the promiseresolvethen anti pattern that will be presented in section asyncgetmoduleinfo name letinfo this.
dependencyinfos.get name if info null info promise.resolve .then async constresource await this .findresource name return determinedependencyinfo resource ... this.
dependencyinfos.set name info return info on line promise.resolve is invoked to create a promise that is fulfilled immediately with the value undefined4.
on the same line an async function is registered as a fulfill reaction on this promise so this reaction is asynchronously invoked with undefined as an argument.
this means that promises are created when the 3fs.stat is a library function that returns an object that contains various information about a file including its size see 4since no argument is passed in the call to promise.resolve the value undefined is used by default.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa alexi turcotte michael d. shah mark w. aldrich and frank tip figure an example of the promiseresolvethen anti pattern found in getmoduleinfo .
the user selected one of the promises in a promise chain originating from an empty promise.resolve identified by label a and the reaction s promise is shown with label b and finally the promise belonging to the async function is shown with label c. reaction executes i the promise created by promise.resolve ii the promise created by the invocation of then and iii the promise created by the invocation of the async function.
this is manifested in drasync s visualization as an extremely short lived promise linked two other longer running promises see figure .
in this case the code can be refactored as such asyncgetmoduleinfo name letinfo this.
dependencyinfos.get name if info null info async constresource await this .findresource name return determinedependencyinfo resource ... this.
dependencyinfos.set name info return info now only one promise is created on line by invoking the async function .
this code is executed times in ui5 builder s test suite and fewer promises are executed each time.
besides being more efficient the code is more concise and easier to understand.
as another example consider appcenter cli developed by microsoft which implements the command line interface cli for the visual studio code vscode interactive development environment ide .
function cpdir defined on lines in src util misc promisified fs.ts implements the copying of a directory async function cpdir source target details omitted constfiles awaitreaddir source for leti i files.length i constsourceentry path.join source files consttargetentry path.join target files awaitcp sourceentry targetentry this code reads the source directory source on line and then iterates over the resulting list of file names.
in each iteration of the loop a call to function cpisawait ed which copies a file from sourceentry totargetentry .
here cpreturns a promise that is fulfilled once sourceentry is successfully copied to targetentry or rejected if an error occurs.
it is important to note that this use of await in a loop causes the execution of function cpdir to be paused until the promise returned by cpis fulfilled and execution will pass back to the main event loop at this time so that other event handlers can be executed in the meantime.
this is manifest in drasync s visualization by a staircase pattern of promises that have lifetimes that do not overlap see figure .
figure an example of the loopoverarraywithawait antipattern in the visualization here from a view depicting an overview of all promises.
each loop iteration is clearly separated with no overlapping promises.
in this case the copying of file entries need not be sequential and we can refactor the above code as follows async function cpdir source target details omitted constfiles awaitreaddir source awaitpromise.all files.map file constsourceentry path.join source file consttargetentry path.join target file return cp sourceentry targetentry here we turn the for loop into a map over the files array mapping a function that returns the promise associated with cp.
we thenawait the entire array of promises with promise.all line which will wait for all these promises to resolve.
this refactoring preserves the behavior of appcenter cli s tests and enables additional concurrency because although javascript is single threaded at the language level it relies on i o libraries that can execute concurrently .
we will report in section how the refactoring significantly improves the performance of the loop.
these anti patterns are detected using a simple static analysis.
our drasync tool additionally relies on dynamic analysis to determine how often each instance of an anti pattern is executed and helps programmers prioritize which code should be fixed.
for instance we found many instances of the await in loop pattern inappcenter cli but the highlighted cpdir example was by far the most frequently executed while running the application s tests.
anti patterns this section defines a set of anti patterns that occur frequently in asynchronous javascript applications.
we identified most of these through manually inspecting javascript source code5 and inspecting visual profiles produced by drasync for noteworthy patterns e.g.
repetitive structures or promises that are very short lived .
in addition a search for issues related to promises and async await on the popular stackoverflow forum turned up the explicitpromiseconstructor6andcustompromisification7anti patterns.
it is important to note that an occurrence of one of these antipatterns is not necessarily a reflection that a design is wrong or inefficient but it indicates that it is likely that the code can be improved to make it more efficient by creating fewer promises or enabling additional parallelism or to make it more concise.
section presents a case study that investigates for a representative subset of instances of these anti patterns how often we were able to refactor 5section .
provides further detail on the process for selecting subject applications.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
drasync identifying and visualizing anti patterns in asynchronous javascript icse may pittsburgh pa usa asyncfunctionnoawait f fasync e0 e1 e0 await e1 e0 f asyncfunctionawaitedreturn f fasync e0 e1 e0 return e1 e0 f e2 e1 await e2 loopoverarraywithawait s0 e0 e1 e2 e3 s1 s0 for e0 e1 e2 s1 isarraytest e1 await e3 s1 promiseresolvethen e0 e1 f e0 promise .resolve e1 .then f executoroneargused e0 e0 f v0 v1 new promise f v0 arg f v1 arg f e1 e2 e1 e2 f e1 e2 v v1 e1 e2 reactionreturnspromise e0 e1 e2 f e0 e1.then f return e2 f e2 promise .resolve e2 promise .reject custompromisification e0 f0 f1 f2 s0 s1 v0 v1 e0 new promise f0 f1 ... f f0 if s0 else s1 f2 v0 arg f0 v1 arg f0 v0 s0 v1 s1 v0 s1 v1 s0 explicitpromiseconstructor e0 e1 f0 f1 f2 v0 v1 v2 v3 e0 new promise f0 e1.then f1 .catch f2 f0 v0 arg f0 v1 arg f0 v2 arg f1 v0 v2 f1 v3 arg f2 v1 v3 f2 figure anti patterns that commonly occur in asynchronous javascript code.
them manually.
section presents an empirical evaluation that reports on the prevalence of each of the anti patterns.
figure defines each anti pattern as a set of ast nodes that meet some specified criteria.
in the figure we use fto represent functions including arrow functions and class methods eto represent expressions and sto represent statements.
subscripts are used in cases where a predicate refers to multiple program elements of the same kind.
furthermore fasync denotes that fis anasync function and e f read as fcontains expression e indicates that fis the innermost function declaration or function expression such that esyntactically occurs within the body of function f. asyncfunctionnoawait.
this anti pattern is defined as any function fsuch that i fis anasync function and ii for any expression e0 await e1 e0does not occur in the body of f. in other words the pattern identifies async functions that do not contain any await expressions.
as we will discuss in section such functions can often be refactored into functions that are not async to avoid the creation of a promise each time the function is executed.
note that the scope of this refactoring may expand beyond fitself functions calling fmay no longer need to await the result of the call f. asyncfunctionawaitedreturn.
this anti pattern is defined as any function fsuch that i fis anasync function and ii any returnexpression in fis an await expression.
in such cases the use of await is redundant because the value vthat the await expression evaluates to is immediately used to settle the promise created by theasync function which itself would need to be awaited it is more efficient to return the promise as it will become linked with the promise created by the async function .
loopoverarraywithawait.
this anti pattern covers for loops of the form for e0 e1 e2 s1 where i the condition e1tests that the loop iterates over an array by checking that it refers to the array.prototype.length property using auxiliary function isarraytest and ii the body s1of the loop contains at least one await expression.
this situation is well known in the javascript community as being needlessly inefficient in situations where the iterations of the loop are independent of one another and the eslint checker has a rule for detecting it.
as we will discuss in section in many cases such loops can be refactored to use promise.all and array.prototype.foreach to enable additional parallelism.
promiseresolvethen.
an expression e0 promise .resolve e1 .then f is constructed i.e.
a new promise is constructed on which a fulfill reaction is registered immediately.
note that entire expression e0may form the beginning of a longer chain of promises.
in such cases it is often possible to shorten the length of the promisechain by refactoring e0 e.g.
topromise .resolve f e1 to reduce the number of created promises.
section discussed a slightly more complex instance of this anti pattern.
executoroneargused.
this anti pattern targets expressions of the formnew promise f where a promise is constructed using an executor function fthat has formal parameters v0andv1 usually the parameters of executor functions are called resolve andreject but programmers may choose different names .
furthermore an additional constraint is imposed that if the body of fcontains expressions e1and e2that refer to v0orv1 then they must both refer to the same variable.
in other words the anti pattern targets executor functions that either resolve or reject the promise but not both.
in such cases it may be possible to refactor the code to use promise.resolve orpromise.reject instead.
reactionreturnspromise.
in this scenario a reaction fthat is registered on a promise in an expression of the form e1.then f returns an expression e2that consists of either a call to promise.resolve or a call to promise.reject .
in such cases it is often possible to avoid the explicit construction of a promise because the reaction already creates a promise that is fulfilled or rejected with the reaction s return value.
custompromisification.
this anti pattern aims to detect situations where a programmer has written a custom function for promisifying an event based api call.
it targets expressions of the form new promise f0 where the promise constructor is invoked with an executor function that contains a call f1 ... f that passes a callback function f2to some api function f1.
moreover f2contains a statement if s0 else s1 where either s1calls the function passed as the first parameter to the executor usually called authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa alexi turcotte michael d. shah mark w. aldrich and frank tip resolve and s2calls the function passed as the second parameter to the executor usually called reject or vice versa.
in such cases it is often possible to utilize the util.promisify promisification function instead.
while this does not reduce the number of promises created it avoids the pitfalls of accidentally introducing bugs when re implementing functionality that is available in standard libraries.
explicitpromiseconstructor.
this anti pattern occurs when a new promise is constructed that is fulfilled when some existing promise is fulfilled and that is rejected when that promise is rejected.
concretely we say that an instance of this pattern occurs when the promise constructor is invoked with an executor function f0that has parameters v0andv1.
in addition the body of f0contains an expression e1.then f1 .catch f2 where f1has a parameter v2and f2has a parameter v3.
lastly f1is required to contain a call v0 v2 and f2is required to contain a call v1 v3 .
occurrences of this anti pattern can often be refactored to avoid the creation of a new promise e.g.
by returning the promise e1.
implementation drasync consists of three components i a static analysis for detecting anti patterns ii a dynamic analysis for gathering information about the lifetimes of promises and detecting run time instances of anti patterns and iii an interactive profiling tool that visualizes the lifetimes of promises and instances of anti patterns and that provides additional features for understanding execution behavior.
our code is open source and publicly available8.
.
static analysis the static analysis uses codeql to implement the antipatterns of figure as a set of ql queries.
these queries follow the logic of the definition closely.
for example the query that is used to find the promiseresolvethen anti pattern looks as follows 84predicate promisedotresolvedotthen methodcallexpr c c.getmethodname then and c.getreceiver instanceof methodcallexpr and methodcallexpr c.getreceiver .getmethodname resolve in two cases we extended the queries with special handling of corner cases.
our implementation of executoroneargused was extended to exclude cases where calls to resolve are passed as an argument to settimeout as we found that such occurrences of the anti pattern are generally not amenable to refactoring.
we also extended loopoverarraywithawait to handle for ofandfor in loops.
all ql queries can be found in the supplemental materials.
.
dynamic analysis drasync relies on the node.js async hooks api to instrument source code to log the creation and settlement of promises to record when await expressions are first encountered and when their execution is resumed and to determine run time instances of anti patterns.
the instrumentation distinguishes different run time instances of promises that are created at the same location e.g.
promises created during multiple executions of the same promise constructor or of the same async function enabling us to calculate how often each anti pattern is executed.
8artifact link information is recorded about dependencies between promises the async hooks api provides a unique asyncid for each promise as well as a triggerasyncid which is the asyncid of the promise that triggered it i.e.
the promise that it depends on .
moreover the dynamic analysis determines whether promises are related to i o operations through simple heuristics if a promise originates from a function from a predefined list of i o functions from the util node.js library and whether they originate from user code or from library code.
this information is used in the interactive visualization to enable programmers to filter promises based on their origin and quickly hone in on relevant promises.
the results of the static analysis and a dynamic analysis are aggregated into a single trace file that is used in drasync s interactive visualization component.
.
interactive visualization the visualization helps with exploring the execution behavior of asynchronous javascript code and enables one to identify certain anti patterns visually.
the visualization also shows the number of runtime occurrences for each instance of an anti pattern enabling programmers to prioritize those anti pattern instances that may impact execution behavior the most.
drasync s interactive visualization tool was developed using the p5.js framework .
figure shows a screenshot of a visualization produced by drasync which follows the standard information taxonomy by providing a high level overview filters and details on demand .
we briefly discuss drasync s different views.
promise lifetime view and source code view.
this view labeled a in the figure is organized as a gantt chart .
here the x axis represents time and the y axis shows the created promises as a series of stacked bars so each promise is represented by one line that starts at the time when the promise was created and that ends when it was settled.
users can pan and zoom through the promise lifetime view and hovering on a promise shows a fragment of the source code responsible for creating the promise along with some meta information.
furthermore clicking on one of the promises opens the associated source code in tab b for further inspection.
mini display view.
this view green bars in the view labeled c at the bottom of the figure shows the general shape of the promises created during execution clicking here enables the user to quickly navigate to areas of interest in the promise lifetime view e.g.
staircase patterns corresponding to instances of loopoverarraywithawait that may benefit from refactoring .
metrics view.
this view labeled d summarizes metrics how many promises were created the total elapsed time the average duration of promises and counts for detected anti patterns.
these can be compared before and after refactoring to see if redundant promises have been eliminated or if performance has changed.
summary view and filters.
this view labeled e shows of all promises and anti pattern instances clicking on these will navigate to the associated promise in the promise lifetime view and will display the associated source code.
for realistic applications the number of promises created at run time can quickly become overwhelming so drasync provides various filtering facilities to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
drasync identifying and visualizing anti patterns in asynchronous javascript icse may pittsburgh pa usa figure the interactive visualization displays the run times of each promise as well as visually summarizes the data capture by drasync.
users can filter particular promises and directly investigate the source code for more details on demand.
table summary of case study anti pattern successful unsuccessful asyncfunctionnoawait asyncfunctionawaitedreturn loopoverarraywithawait promiseresolvethen executoroneargused reactionreturnspromise custompromisification explicitpromiseconstructor focus on promises of interest.
in particular users can focus on those promises that are related to file i o or network i o see view labeled f or on promises whose creation site matches a specified text string see view labeled g .
case study to evaluate if the anti patterns reported by drasync represent useful information we randomly selected instances of each antipattern and attempted to refactor them manually.
these instances were chosen from the 20subject applications that we will report further on in section .
to ensure that our findings are not biased towards a particular programming style no more than three instances of each pattern were chosen from a single application and we only selected anti pattern instances that drasync reported as being executed by the application s test suite so that we could check that the refactoring did not cause behavioral changes.
an overview of our findings can be found in table .
below we report on some noteworthy situations that we encountered.
many refactorings were simple and quick though others took more considerable time e.g.
some loop refactorings took minutes in order to understand possible data dependencies .
further details for all cases can be found in the supplemental materials.asyncfunctionawaitedreturn.
as discussed in section this antipattern reflects inefficient code as it involves waiting for a promise to settle with some value v and then creating a new promise that is settled with the same value.
the following function in file src utils readspec.ts inopenapi typescript codegen was flagged bydrasync as an instance of this anti pattern export async function readspec input string promise string if input.startswith https return await readspecfromhttps input if input.startswith http return await readspecfromhttp input not executed return await readspecfromdisk input here await is redundantly used on each of the return paths and drasync informed us that the first and third of these awaitexpressions were executed by the test suite.
we confirmed that the tests still passed after removing the await keywords.
loopoverarraywithawait.
section already discussed an instance of this anti pattern in appcenter cli that we were able to refactor successfully.
however some of the instances reported by drasync could not be refactored such as the the following code snippet on lines in file src templatelayout.js ineleventy for letfnoffns templatecontent awaitfn data data templatelayout .augmentdatawithcontent data templatecontent here each loop iteration awaits the result of the call to fn data and then re assigns data on the next line.
since each loop iteration depends on a value computed in the previous iteration we are unable to parallellize the loop using promise.all.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa alexi turcotte michael d. shah mark w. aldrich and frank tip executoroneargused.
an interesting case of this anti pattern occurs on lines in src streaming utils capabilitiesfilter.js indash.js return new promise resolve constpromises details omitted promise.all promises .then details omitted resolve .catch resolve here a new promise is created that is fulfilled with the value undefined since no argument is passed to resolve in reactions on a promise that is created by a call to promise.all .
the creation of a new promise can be avoided by refactoring the above code to constpromises details omitted return promise.all promises .then details omitted return .catch return after this refactoring it is evident that the resulting code lacks proper error handling given that catch is used to register a no op function to absorb errors that cause the previous reaction in the promise chain to be rejected.
custompromisification.
for this anti pattern we found that we could successfully refactor of instances highlighted by the tool using the util.promisify library function.
the remaining case involved the use of an event handler with complex control flow.
in all but one of the successful cases using promisify and refactoring the inner logic of the callback into a reaction on a call to the promisified function was sufficient.
for a more interesting case consider the following snippet on lines in file src engines nunjucks.js ineleventy return async function data return new promise function resolve reject tmpl.render data function err res if err reject err else resolve res consttmplrenderprom util.promisify tmpl.render return tmplrenderprom.call tmpl data here tmplrenderprom must be invoked with function.prototype.
call to preserve the correct value for this during its execution.
reactionreturnspromise.
for this anti pattern of the cases we examined could be refactored the one unsuccessful case involved a promise reaction with complex event handlers where the returned promise was fulfilled or rejected in response to external events.
for an example of a successful refactoring consider this snippet from netlify cms lines of packages netlify cmscore src backend.ts constpublishedentry await this .implementation .getentry path .then data data .
catch return promise.resolve false return false here .catch and.then return promises anyway so explicitly returning a promise that is immediately fulfilled or rejected is needless.
evaluation this evaluation aims to answer the following research questions rq1 how often do the anti patterns of figure occur in practice?
rq2 how often can anti patterns reported by drasync be eliminated using refactoring?
rq3 can the elimination of anti patterns improve performance?
rq4 what is the performance of drasync?
.
experimental setup to identify a set of candidate projects we first ran a codeql query on a large set of javascript github repositories available to the codeql team to find projects containing promise related features9.
of the 100k projects that this turned up we used the npm filter tool to discard projects that did not have running test suites resulting in projects with at least one running test command.
of those projects we randomly selected 20projects meeting the following criteria the project i was edited in the last year ii had over stars iii contained over instances of promise related features and iv running the application s test suite results in the creation of at least promises.
all experiments were performed on a centos linux .
.
core server with 2x core .35ghz processors and 128gb ram.
.
rq1 how often do anti patterns occur?
after discounting anti patterns occurring in test code compiled typescript and distributions we found .6k anti patterns instances in the projects selected for evaluation.
moreover drasync s dynamic analysis detected that a total of 24kinstances of these anti patterns were executed by the applications test suites.
these results are tabulated in table and provide strong evidence that anti patterns commonly occur.
the first cells of the table read appcenter cli has instances of the asyncfunctionnoawait pattern in its code s instance is executed in the tests e and runtime promises are associated with this anti pattern d .
anti patterns commonly occur in asynchronous javascript code.
we found a total of .6k anti patterns in subject applications.
.
rq2 can detected anti patterns be refactored?
section summarized findings of a case study wherein we tried to refactor 80instances of anti patterns flagged by drasync .
of these 80cases we were able to successfully refactor .
for the 15that we were unable to refactor not all are necessarily false positive because developers with more expert knowledge may have additional insights enabling them to refactor the code.
each of the refactorings is reported on in the supplementary materials.
a case study involving 80anti patterns in real world code suggests that the majority of anti patterns detected by drasync can be eliminated through refactoring.
9this includes