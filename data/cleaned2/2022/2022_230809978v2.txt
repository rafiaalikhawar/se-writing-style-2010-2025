software architecture in practice challenges and opportunities zhiyuan wan zhejiang university hangzhou china wanzhiyuan zju.edu.cnyun zhang hangzhou city university hangzhou china yunzhang hzcu.edu.cnxin xia huawei hangzhou china xin.xia acm.org yi jiang huawei shanghai china jiangyi54 huawei.comdavid lo singapore management university singapore singapore davidlo smu.edu.sg abstract software architecture has been an active research field for nearly four decades in which previous studies make significant progress such as creating methods and techniques and building tools to support software architecture practice.
despite past efforts we have little understanding of how practitioners perform software architecture related activities and what challenges they face.
through interviews with practitioners from organizations across three continents we identified challenges that practitioners face in software architecture practice during software development and maintenance.
we reported on common software architecture activities at software requirements design construction and testing and maintenance stages as well as corresponding challenges.
our study uncovers that most of these challenges center around management documentation tooling and process and collects recommendations to address these challenges.
introduction software architecture refers to a collection of design decisions that affect the structure behavior and overall quality of a software system serving as the foundation for subsequent decisions .
the research field of software architecture has achieved tremendous progress since its inception in the 1980s .
in the 2000s there has been a paradigm shift in understanding the essence of software architecture moving from a purely technical view to a socio technical view.
the early paradigm centered around the tangible outcomes of software architecture practice such as the structure and behavior of software systems their components and connectors and the use of views architecture description languages design methods and patterns .
the subsequent paradigm concerned how stakeholders reach the outcomes through software architecture practice specifically how they reason about their choices and make architectural decisions .
previous studies have put effort into developing methods and tools for architecture representation and documentation analysis and evaluation recovery and optimization as well as knowledge management and decision making to support software architecture practice.
despite these efforts we have little understanding of how practitioners actually perform software architecture practice during the development and maintenance of software systems and what challenges they encounter in practice.
to systematically explore the challenges and point improvement towards better practice we corresponding author.conducted interviews with participants involved in the design implementation and maintenance of software architectures.
our research question is what are the software architecture related activities performed in practice and the corresponding challenges faced by practitioners ?
interview participants come from organizations of varying sizes from small startups to large technology companies.
they have diverse roles in software development and maintenance including architect development testing and project management.
during the interviews we explored various aspects of software architecture practice including the architectural styles applied techniques and processes followed and tools utilized.
we also sought to identify where challenges arise in software architecture practice during software development and maintenance.
we observe that challenges in software architecture practice surface at different stages of software development and maintenance process evolution and changes of software requirements at the requirements stage design documentation requirements decomposition and architecture analysis and evaluation at the design stage architecture conformance checking continuous architecture monitoring and code quality at the construction and testing stage and architecture erosion and refactoring at the maintenance stage.
even though architectural styles and software architecture practice differ substantially across organizations we find common patterns of architectural styles and associated challenges.
overall our observations suggest four themes that would benefit from more attention with respect to management gr documentation tooling cgs and process fostering an organization wide culture of building high quality architecture paying more attention to the up to dateness and traceability of design documentation adopting and developing effective tools to support software architecture practice and improve the reuse of architecture knowledge to facilitate architecture design.
in summary this paper makes the following contributions we identified challenges in software architecture practice during software development and maintenance through interviews with practitioners triangulated with a literature review we provided recommendations for improving software architecture practice and outlined future avenues of research.
the remainder of the paper is structured as follows.
in section we briefly review related work.
in section we describe the methodology of our study in detail.
sections and present the results of our study.
we discuss the implications of our results in section and any threats to the validity of our findings in sectionarxiv .09978v2 aug 2023esec fse november san francisco usa zhiyuan wan yun zhang xin xia yi jiang and david lo .
section draws conclusions and outlines avenues for future work.
related work structural construction of software systems.
software architecture practice embraces the concept of architecture view which represents a partial aspect of the high level structures of a software system .
researchers propose various approaches for documenting the relevant views of software architecture to help practitioners successfully use it maintain it and build a software system from it including unified modeling language architecture description languages e.g.
and domain specific languages e.g.
.
despite the development of formal approaches for specifying software architectures in practice natural language is widely used in documenting software architectures sometimes accompanied by diagrams of informal models .
the benefits of software architecture documentation have been widely investigated in previous studies e.g.
serving as an educational tool to introduce new team members to a software project and reduce entry barriers for new contributors in oss development .in this paper we explore how software practitioners capture and document software architecture.
design decisions.
the early literature has made great efforts to develop approaches and tools for capturing architecture design decisions explicitly including formal models e.g.
and description templates e.g.
.
the formal models and description templates have consensus on capturing rationale constraints and alternatives of architectural design decisions .
recently researchers propose approaches for the automatic extraction of design decisions from different information sources e.g.
e.g.
email archives issue management systems commit messages and stack overflow.
in addition researchers conduct empirical studies to investigate architectural decision making practice including decision making process e.g.
methods e.g.
and tools e.g.
and shift their focus towards addressing the social and psychological aspects of architectural decision making behaviors including naturalistic and rational decision making cognitive biases and group decision making .in this paper we explore how software practitioners make architectural design decisions.
software evolution.
from an evolution perspective architecture analysis and evaluation is a preventive activity to improve qualitative attributes delay architectural decay limit the effect of software aging and identify architectural drift and erosion of software systems .
previous studies propose a wide spectrum of approaches and tools for architecture analysis and evaluation including extracting intuitions and experiences of stakeholders and further using their tacit knowledge e.g.
creating scenario profiles for a concrete description of quality attributes e.g.
architecture conformance and compliance checking e.g.
and using various quality metrics e.g.
mojofm .
architectural changes occur during regular development and maintenance activities which involve a wider spectrum of code components as well as dependencies among them than local code changes .
it is complex for practitioners to comprehend the scopes and impacts of architectural changes .
the complexity elevates the cost and effort of implementing architecturalchanges across the software development lifecycle .in this paper we explore how software practitioners perceive software evolution as well as how they conduct architectural changes and address the evolution problems from the architectural perspective.
architecture knowledge management.
it has been suggested that if it is not written down it does not exist thus to prevent knowledge vaporization and architectural drift a plethora of works on capturing different types of architecture knowledge have emerged for modeling design decisions and rationale.
the uses for architecture knowledge span four broad categories i.e.
sharing compliance discovery and traceability .
a shared understanding of architecture knowledge among stakeholders of software systems alleviates miscommunication and information overload especially for the software systems that are produced by practitioners from different geographic areas .
due to the large number of stakeholders and the dispersion of knowledge it is challenging to effectively share and reuse architecture knowledge .
architecture knowledge enables evaluation and review of architecture compliance e.g.
in terms of requirements missing and conflicting conflicts between requirements and design and violation of design principles.
the discovery of architecture knowledge allows reasoning and uncovering design problems and alternatives .
traceability of architecture knowledge improves understandability of software architectures helps to locate relevant knowledge enables impact analysis of architectural changes and facilitates design review evaluation and assessment .in this paper we explore how software practitioners manage architecture knowledge.
methodology we adopted a qualitative research strategy to explore software architecture practice in software development and maintenance and corresponding challenges with interviews of software practitioners in the industry.
our study consists of four steps we prepared an interview guide informed by an initial literature review we conducted interviews we triangulated results with literature findings and we validated the findings with our interview participants.
we based our research on straussian grounded theory which derives research questions from literature analyzes interviews with open and axial coding and consults literature throughout the process.
specifically we simultaneously conducted interviews and reviewed literature utilizing immediate and continuous data analysis making constant comparisons and refining our codebook and interview guide throughout the study.
step scoping and interview guide.
to scope our research and prepare for the interviews we searched for software architecture practice discussed in the existing literature on software engineering section .
in this phase we selected papers opportunistically through keyword search and our personal knowledge of the field.
we applied standard open coding process to identify sections in the papers that potentially relate to software architecture practice.
although most papers did not directly address challenges in software architecture practice we marked discussions that potentially related to challenges e.g.
inadequate knowledge management for design decisions.
we then analyzed and condensed these codes into the stages of software development and maintenance andsoftware architecture in practice challenges and opportunities esec fse november san francisco usa developed an initial codebook and interview guide provided in supplement a and supplement b .
step interviews.
the first author conducted a series of interviews with software practitioners from organizations1 in person and online interviews.
each interview is to minutes long.
the interviews were semistructured and made use of the interview guide which was sent to the participants before the interviews in line with previous studies .
all the interview participants are involved in industrial software projects.
the demographics of interview participants are summarized in table with details found in supplement c. note that some participants take more than one role in their projects.
participant selection.
we selected participants with the maximum variation sampling method of purposeful sampling to cover participants with different job roles and in various types of organizations.
we adapted our recruitment strategy throughout the study based on our findings in the interviews.
in the later stages of the study we focused on specific roles and organizations to fill gaps in our understanding.
participant selection data collection and data analysis continued until saturation was reached and a rich description of experience had been obtained.
new codes did not appear anymore in data analysis the set of codes was considered stable.
we recruited potential participants with necessary software architecture knowledge through personal networks and recommendations from previous participants.
we separately interviewed multiple participants within the same organization to get different perspectives.
given that some organizations with multiple business units may adopt different software practice we recruited several participants from each business unit for those organizations.
for confidentiality we refer to organizations by number and participants by pi jwhere irefers to the organization number and jdistinguishes participants from the same organization.
data analysis.
all interviews were recorded transcribed and analyzed using constant comparative method.
data collection and data analysis took place simultaneously.
after each interview the first author transcribed the recording of the interview open coded the transcript using nvivo qualitative analysis software .
specifically the first author broke the transcript down line by line into concepts termed meaning units labeled the units with codes and continuously compared similar codes.
to ensure the quality of codes the second author reviewed the initial codes created by the first author and provided suggestions for improvement.
these suggestions were discussed and incorporated into the codes.
after the open coding stage we generated a total of unique codes of software architecture activities and challenges to codes for each interview.
next we conceptualized the resulting codes by specifying the relationship between them and integrating them into categories e.g.
design documentation andarchitecture erosion .
finally we mapped these categories to software development and maintenance phases e.g.
software requirements andsoftware construction and testing .
in addition we created visualizations of architectural styles in each organization provided in supplement d and used these visualizations to explore whether the concepts associated with certain types of architectural styles.
1the interviews were approved by the relevant institutional review board irb participants were instructed that we wanted their opinions privacy and sensitive information would not be intentionally mentioned.table participant and company demographics.
type break down participant role architect development project management testing participant seniority years of experience or more years under years company type big tech non it mid size tech startup company location asia north america europe step triangulation with literature.
triangulation refers to the use of multiple methods or data sources in qualitative research to increase the credibility and validity of research findings which is also used in grounded theory research on software engineering e.g.
.
we used methodological triangulation which involves the use of two methods to gather data i.e.
interviews and literature review.
specifically as we gained insights from interviews we returned to the literature to identify related discussions and potential solutions to triangulate our interview results.
we pursued a best effort approach that relied on keyword search for themes that surfaced in the interviews as well as backward and forward snowballing.
consequently we identified papers as possibly relevant and coded them with the evolving codebook.
the data from the papers were used to confirm and support the findings of the interviews representing triangulation.
the complete list of the papers can be found in supplement e. step validity check with interview participants.
for assessing fit and applicability as defined by strauss and corbin and validating our findings we returned to our participants after creating a full draft of this paper.
we presented the participants with both the full draft and a summary of the challenges and recommendations that emerged during the interviews along with questions that prompted them to look for correctness and areas of agreement or disagreement i.e.
fit and any insights gained from reading experiences of the other companies roles and the overall findings i.e.
applicability .
specifically participants were asked to indicate agreement or disagreement by placing a tick or cross next to each challenge or recommendation based on their realm of experience they were also asked if they had any insights to add.
all participants indicated general agreement and six responded with comments several explicitly reaffirmed some findings.
we incorporated three minor suggested changes to details in the recommendations.
software requirements some software requirements particularly certain non functional ones have a global scope in that their satisfaction cannot be allocated to a discrete component in a software system.
a requirement with a global scope could affect the software architecture and the design of many components.
unpredictable evolution and changes of software requirements complicate architecture design gr .
architects perform architecture design towards a visionary future by foreseeing the potential evolution and changes in software requirements.
practitioners expect software systems to evolve and iterate spontaneously as requirements change over time p1a p2a p3b p3e p4a p4d p6a p7a p10a p12a p13a p14a esec fse november san francisco usa zhiyuan wan yun zhang xin xia yi jiang and david lo p15a p17a p18a .
for example p1a architect shared we had to think about scaling up the capacity handling more users and dealing with increased concurrency in our architecture design ... we were looking ahead maybe in the next to years considering that the business requirements would evolve.
however requirements sometimes tend to change and evolve in an unpredictable way including the increasing variety of users p1a p10a p11a the change in business requirements of the whole industry p4a p11a p14a and the evolution of technology stacks p3e p7a p8a p9a p11a p12a p13a p15a .
the unpredictable evolution and changes of requirements sometimes make it infeasible to deliver new features or meet the quality requirements with current architectures as frequently mentioned in the literature .
in practice even experienced architects cannot design a perfect software architecture that can support evolution and changes of requirements in the long term future especially with modest time and resources p1a p2a p3e p4d p8a p11a p12a p13a p14a p15a .
some participants explained that the challenges arise because requirements violate the original assumptions about the expected quality attributes of the software systems e.g.
capacity number of concurrent users and tps p2a developer .
other participants explained a perfect architecture could cost far more than affordable.
given the development of technology stacks are fast and evitable aggressive adoption of the latest technology increases development cost p6a p11a .
for instance transaction based features can be hardly implemented with a non transaction based architecture of a software system p3e .
recommendations.
it is important for architects to make tradeoffs between multiple factors with awareness of requirements volatility and unpredictability .
it seems beneficial to adopt more formal architecture documentation for capturing the tradeoffs in architecture design and constructing trace links between requirements and design decisions which has been suggested in the literature .
the explicit capturing of tradeoffs and their rationales facilitates the communication of essential design decisions among various stakeholders and the reuse of architecture knowledge.
a practical strategy could be designing a software architecture that can support the evolution and changes in requirements for one to three years in the future p2a .
some participants suggest a reactive strategy to overcome requirements volatility and unpredictability a standard process for adapting refactoring and retiring software architectures p2a p3g .
software design jan bosch emphasized that designing a system can be viewed as a decision process .
practitioners work with various stakeholders to make design decisions with a high level view of both business and technical aspects of software systems.
we observed challenges in design documentation design principle application and design quality analysis and evaluation with respect to software architectures.
.
design documentation design documentation describes information about the design interfaces and functionality of software to support practitioners intheir development and maintenance activities by which the diverse stakeholders communicate with the design team and with each other .
use of models and tools is inadequate to ensure the completeness of architecture documentation cgs .
most organizations provide unified templates for architectural specifications but no adequate support of models and tools to ensure the completeness of architecture documentation.
as reported by participants the common parts of architectural specifications across organizations include views of software architecture interface specifications and rationales behind design decisions.
some large scale organizations allow customization to organizational wide templates for different business units e.g.
p3d architect we ve tweaked the company s templates to better suit our specific business needs.
.
nonetheless no participants reported that they use any formal models or tools to make sure that architecture documentation is complete for communication.
some participants mentioned that sometimes they cannot find the relevant information in architecture documentation p9a p19b .
the incompleteness of design documentation is also discussed in the literature e.g.
.
architecture documentation becomes obsolete as software evolves .
participants reported that design documentation tends to suffer from up to dateness problems.
most participants observe the inconsistency between design documentation and code implementation as software systems evolve e.g.
when integrating new features into the systems and bug fixing p3b p3e g p4c p6a b p7a p8a p9a p10a p11a p12a p14a p18a p19a b p20a p21a .
the documentation code inconsistency would confuse the developers who perform development tasks.
moreover a few participants in agile projects reported that documentation tends to be missing for new features or components due to a fast development pace.
p6a developer explained the traditional modeling method like uml becomes a significant roadblock to fast paced design in agile development .
whereas the literature discussed challenges in providing up to date software documentation e.g.
our interviewees were concerned about the inconsistency between design documentation and code implementation in particular.
inadequate tool support for sharing version control and tracing of scattered design documentation cgs .
design documentation is written and organized with a wide variety of methods across and within organizations as reported by our participants p3b p3e p3g p4a p5a p6a p7a p11a p13a p14a .
we observe that most participants use traditional text processing software to write design documentation and version control systems to keep track of changes in documents.
for example p3g project manager architect described we simply use microsoft office word to capture our design documents .
the ineffective methods for organizing design documentation further impact its usability for readers e.g.
information findability and content searchability as well as its usefulness for practical use in software development and maintenance.
these findings align with literature past observations that design documents are typically written in natural languages with supporting diagrams .
in most organizations practitioners performed detailed design for a module or microservice with the architecture documentation of interface level design as input.
some of the practitioners reported they included detailed design documentation insoftware architecture in practice challenges and opportunities esec fse november san francisco usa code comments p2a p6a but few intentionally build the trace links between architecture and detailed design documentation.
recommendations.
architecture documentation quality is important to understand and evolve software architectures as well as training and education of developers .
participants emphasized the completeness up to dateness usability and usefulness of design documentation in our interviews p2a p3a g p4a p5a p6a p11a p12a p19a .
the importance of high quality documentation is frequently discussed in the literature e.g.
.
as for layered architectures interface specifications provide the standardized mechanism in which subsystems can effectively communicate with each other and enable them to operate as independent modules p3a p3f .
when it comes to microservices architectural style some organizations limit the scope of interface specifications at the microservice level in a software system p4a p5a .
some organizations have a standard process to make design documentation up to date in which developers cannot merge their code unless the corresponding design documentation has been updated and use wikis to host design documentation p4c p19b .
placing documentation in standard locations is an effective practice to help practitioners locate it as suggested in the literature e.g.
.
some organizations adopt collaborative writing tools for the generation and sharing of design documentation p4d p6a b p11a p14a p19a b cgs .
in contrast a few participants suggest applying the code as documentation principle2to avoid extra cost and efforts for writing and maintaining design documentation p4a p5a .
.
design principles practitioners applied a wide range of design principles when designing software architectures including abstraction coupling and cohesion decomposition and modularization encapsulation and information hiding separation of interface and implementation and separation of concerns.
unclear boundaries between architectural elements in software systems gr .
some practitioners observe challenges in understanding underlying businesses when it comes to the decomposition of architectural components p3a p4d p5a p8a p9a p11a p19a p21a .
as p3a architect explained one cannot elegantly decompose a software system by simply collecting and listing a bunch of business scenarios .
the misunderstanding of businesses leads to unclear boundaries between architectural components in a software system and further affects the quality and productivity of the detailed design of the system.
software decomposition has been extensively studied in prior research of software engineering in which software clustering has become an active research area.
software clustering is defined as the process of decomposing large software systems into smaller manageable highly cohesive loosely coupled and feature oriented subsystems .
a recent study presents a systematic literature analysis to structure and categorize the state of the art research evidence of software clustering over the past decade.
as for a microservice architecture it is challenging to decompose a software system into the optimal number of microservices with appropriate levels of granularity p3a p4d p5a p11a .
on one hand the granularity and number of microservices would affect the code quality and cost efforts in subsequent development activities.
p5a architect shared bigger microservices tend to have tedious interfaces while smaller microservices tend to introduce more cost and efforts when testing and addressing issues when integrating microservices .
on the other hand the granularity and number of microservices could make an impact on the satisfaction levels of non functional requirements e.g.
the latency of service invocation.
interdisciplinary knowledge is required to lower coupling and improve cohesion of software gr .
a common theme in the interviews is that it is challenging to design a software system that is loosely coupled and highly cohesive p2a p3a b p3f g p4a b p6a p11a .
as participant p3a architect explained business requirements change over time in different frequencies ... a component tend to be highly coupled with others if it is responsible for both frequently and rarely changed requirements.
a highly coupled and low cohesive software architecture could further lead to difficulty in the planning and management of subsequent software development activities like detailed design and implementation.
identifying the business requirements with potential changes in the future requires interdisciplinary knowledge of both architecture design and businesses for practitioners.
recommendations.
decomposition and modularization are important to architecture design as a principle most frequently mentioned in our interviews .
it is crucial to place different functionalities and responsibilities in different components of software systems p3a d p3f g p4a p5a .
the decomposition of software systems occurs from two perspectives vertically decomposing a software system into layers and horizontally decomposing the system into smaller components.
for software systems with layered architecture styles practitioners usually emphasize vertical decomposition for isolating software from physical hardware changes.
the isolation further makes it easier to move the software components between different hardware solutions for a variety of application domains.
conversely for cloud based and microservice systems practitioners emphasize the horizontal decomposition of systems into microservices and components with a deep understanding of the underlying business requirements of the systems p5a .
practitioners should make tradeoffs of balancing the granularity and number of microservices as well as balancing the non functional requirements for individual microservices and the satisfaction level for the overall system .
to identify and tailor services based on business requirements some organizations use domain driven design ddd as a flexible methodology to create a high level of microservices architecture design with an iterative design and development process p3a p3f p4a p5a .
coupling and cohesion are also frequently discussed as important design principles in our interviews .
for different architecture styles coupling measures interdependence among architectural elements of different levels of granularity e.g.
components modules layers and microservices while cohesion measures the strength of association of architectural elements within a particular scope p2a p3a b p3f g p4a b p6a .
for instance several organizations enforce the coupling and cohesion principle in terms of separate compilation testing release and deployment of modules p3g .
participants applied a variety of strategies to lower coupling and improve theesec fse november san francisco usa zhiyuan wan yun zhang xin xia yi jiang and david lo cohesion of architectural elements.
some participants suggested designing independent architectural elements for change prone businesses when decomposing a software system p3a p3g .
to improve the cohesion of a software system some participants suggested designing a module for common functionalities across businesses which interacts with other modules or microservices p3b p4b p6a .
.
design quality analysis and evaluation practitioners take into account various quality attributes that contribute to the quality of software architecture including quality attributes at runtime and those not discernible at runtime.
to effectively analyze and evaluate the quality of software architectures some organizations adopt automated techniques and tools as well as measures for quantitative estimation.
architecture review requires a standard process active involvement of external experts and tool support gr cgs .
the majority of our participants reported that architects and design teams perform architecture reviews in their projects yet few mentioned the involvement of external consultants in architecture reviews.
architecture review and evaluation intends to uncover risks and issues in software architectures before they cause tremendous costs later in the software engineering life cycle.
large scale organizations tend to conduct formal sessions of architecture review within development teams on a regular basis p3a p4c d p11a p19a but smaller organizations set up informal architecture review irregularly e.g.
once after the completion of architecture documentation and before coding.
for instance p1a architect shared informal architecture reviews would take place once every one to two years during software maintenance planning for the evolution of software architectures.
participants rely heavily on experience in architecture review and evaluation process manually inspecting requirements multiple potential solutions and rationale behind architectural design decisions in architecture documentation p1a p2a p3a p3d p4b p6a p9a p16a .
for example p3d architect stated senior engineers and architects often leverage their expertise to evaluate and critique architectures and ultimately drive architectural design choices ... their experience guides them in assessing and shaping the overall architectural landscape.
the widespread use of experience based reasoning aligns with findings in the literature e.g.
.
lack of effective and apply to all quantitative measures cgs .
literature has proposed various metrics to measure the quality of software architectures including coupling and cohesion .
most participants perceive the importance of measures to effectively quantify various aspects of software architectures but identify two challenges in applying architecture measures in practice p1a p3a p3b p3d g p4a b p11a p14a p19a .
first it is challenging to propose quantitative measures that accurately reflect the in depth problems in software architectures p3a p4a b .
in some organizations the implemented quantitative measures for architecture quality tend to be superficial and lack of theoretical basis.
the challenges come from complexity in the understanding of business logic as well as the architectures of software systems.
second no general criteria exist concerning good quality architectures across softwaresystems making it challenging to enforce organizational wide measures for architecture evaluation p3a p4a b .
organizations do not enforce standard architectural design across business units leading to a variety of architectural styles within organizations.
p3a architect explained the reasonable decomposition of modules is closely dependent on the underlying scenarios ... the reasonable decomposition of microservices is also related to businesses ... no measures apply to all .
in some organizations that enforce organizational wide measures participants would adopt a whitelist approach to exclude special cases whenever the measures do not apply.
recommendations.
practitioners need to consider both runtime and non runtime quality attributes of software systems but with different priorities in architecture review .
performance is the runtime quality attribute most frequently mentioned in the interviews p1a p2a p3a p3d p3g p4a p5a p6a p11a p15a p19b with example terms of latency and transactions per second.
other runtime quality attributes are also discussed e.g.
functionality p3d p3g p4a p4c p5a p11a availability p1a p3a p3d p5a p4c p11a elasticity p5a p11a and security p1a p13a .
meanwhile most participants emphasized the importance of extensibility and maintainability as the non runtime quality attributes of software systems p1a p3a p3d p3f g p4a p6a .
some participants also considered reusability p2a p3f g compatibility p3e and testability p3g .
it is also recommended to involve external experts from other teams to review and evaluate the software architectures and provide prioritized recommendations for architecture improvement gr .
for instance p2a developer suggested that the design teams should collect feedback about api design and encapsulation from the downstream users .
in terms of tool adoption to support architecture review and measurement some participants suggested using simulation and prototyping techniques to evaluate potential solutions to support architecture decisions p3a p4a c p12a .
a few participants suggested using static analysis tools for visualizing architectures p1a and checklists when conducting architecture reviews p5a p13a .
given thresholds for measures of architecture quality may differ across software systems some participants suggest only applying a limited set of measures in automated tools for estimating fundamental architecture quality within organizations yet leave the left as a reference for practitioners to make decisions p3e p3f .
other participants suggest using whitelists to exclude special cases from the automatic measurement of architecture quality p3b .
6software construction and testing the software construction and testing phase relies on the outcomes of the software design process.
we found many challenges during this phase stemming from architecture conformance checking architecture monitoring and construction quality.
.
architecture conformance checking architecture conformance checking aims to ensure the consistency between the implemented architecture of a software system and its intended architecture as the system is implemented.
the diverges of implemented architecture from the corresponding intended architecture could lead to software architecture erosion .software architecture in practice challenges and opportunities esec fse november san francisco usa automated architecture conformance checking is rare cgs .
despite the common awareness of architecture divergence participants rarely rely on automated tools to check architecture conformance in the software construction phase p1a p3b c p3e p3f g p4a c p6b p11a p12a p13a p15a p19b .
instead some organizations rely heavily on periodical manual inspection in line with the observations of previous studies e.g.
.
in the manual inspection for architecture conformance inspectors rely on the detailed description of code changes especially the architectural changes thus the code contributors should provide comprehensive information for their changes.
p4b architect explained the detailed description would save the time of architects to evaluate whether the code changes conform with the intended architecture .
obsolete documentation and lack of traceability hinder automation of architecture conformance checking .
some participants report several potential obstacles that hinder the adoption of automated tools p3b p3g p4a p4c p19a .
first the obstacles come from the up to dateness of architecture documentation and specifications.
p4a project manager architect explained developers tend to forget updating architecture documentation when evolving software architectures because of deadline pressures .
the obsolete architecture documentation and specifications are unreliable for automated architecture conformance checking.
second no traceability links between artifacts exist to support locating the artifacts that contribute to the resulting architectural inconsistency.
for instance p3b architect and p3g project manager architect illustrated no standard process or tool support to build trace links between design decisions and their implementation .
recommendations.
knowledge vaporization could cause inconsistency between the intended architecture and implemented system gr .
some participants attribute knowledge vaporization to high developer turnover in software development projects p3e p4a b p6b p12a p13a p19a .
developer turnover aggravates architecture divergence by losing knowledge about project contexts including system requirements and architectural decisions .
a poor understanding of project contexts also hinders knowledge transfer among team members.
.
continuous architecture monitoring limited tool support to continuously monitor the health status of software architectures cgs .
architecture monitoring aims to quantify the health status of software systems in a continuous way and evaluate whether the symptoms of architecture problems crept into a system .
despite the common awareness of the importance of architecture monitoring among our participants few organizations employ specific automated tools for architecture monitoring in practice.
as mentioned by the participants without continuous architecture monitoring teams would discover architecture problems at the late stages of software life cycle p3a p12a .
when it comes to building software on top of legacy systems it is difficult to make accurate project planning due to long lived architecture problems in the legacy systems as expressed by p3b architect the presence of weird dependencies and calls in the legacy system makes it a headache to build the new system on top of it.
this adds a bunch of risks when trying to make plans.
pinpointing architecture problems requires a system wide perspective .
pinpointing architecture problems with quantitative measures of architecture monitoring is difficult as frequently mentioned in our interviews p2a p3a p4c d p7a p11a p14a p19b .
as p2a developer illustrated the root causes of performance degradation in architecture monitoring could arise from architecture problems code issues or both ... it is difficult to accurately pinpoint architecture problems that cause the performance degradation.
pinpointing the root causes requires an overall perspective of the entire software system yet individual developers tend to focus on the code of modules under development in the phase of software construction thus lacking such perspective p3a .
the literature also discussed that the separation between interface and implementation in componentbased software along with the hiding of the implementation from the component client could introduce problems that are difficult to pinpoint when their effects cross component boundaries .
maintenance of monitoring tools requires ongoing effort gr .
the maintenance of monitoring tools is another common challenge mentioned by participants.
in some organizations automated testing frameworks are deployed to quantitatively monitor the performance of software systems but cannot automatically adapt to the evolution of systems.
the tools require significant effort and cost for their maintenance for expanding the scope of measured quality attributes and evolving thresholds of measurements p3f p4c p5a p12a .
for example p3f developer shared someone griped about the hassle of calibrating the quantitative measures as the system evolves.
recommendations.
our observations suggest that the use of automated testing frameworks appears to be a practical way to continuously monitor architecture quality in terms of system performance .
as our participants reported some organizations use unit testing stress testing and performance testing frameworks to continuously monitor the quality of software systems p2a p3a p3c p3e f p4b d p5a p7a p11a p12a p14a p19b .
the performance metrics generated by automated testing frameworks tend to serve as an indicator of architecture problems e.g.
performance degradation.
participants raised several expectations for building tools to support continuous architecture monitoring cgs integrating a vast variety of metrics for comprehensively evaluating software architectures especially in terms of the quality attributes of software systems p2a p4a deriving the metrics from the software architecture experiences in practice given architecture design is a human and knowledge intensive process p3e f backing up empirically based metrics with theoretical support p1a and visualizing metrics to facilitate diagnose of potential architecture problems p3b .
in addition it seems important to budget for the maintenance of architecture monitoring tools or even a dedicated maintenance team .
involving architects is important when pinpointing architecture problems in continuous architecture monitoring gr .
in the process of architecture monitoring participants suggested involving architects to analyze potential problems indicated by monitoring tools especially the potential problems in the core components of a software system p2a p3a p3e .
conversely developers are suggested to be actively involved p3f by providing explanations oresec fse november san francisco usa zhiyuan wan yun zhang xin xia yi jiang and david lo rationale behind implementation decisions that violate the criteria for metrics as specified in monitoring tools.
.
construction quality technical debts are introduced to software projects gr .
participants regard technical debts as a common cause of architecture erosion.
technical debt is a metaphor reflecting technical compromises that yield short term benefits but hurt the long term success of software systems .
participants reported a variety of technical debts in the course of software construction including workarounds shortcuts and sub optimal operations p2a p3b p3g p4a c p5a p6a b p7a p11a p12a p13a p14a p15a .
the workarounds shortcuts and sub optimal operations tend to change architecturally relevant elements such as classes components and modules introduce undesired dependencies among these elements and further break architectural integrity which is observed in previous work e.g.
.
participants frequently reported that pragmatism prioritization and ignorance may contribute to the introduction of technical debts.
an example of pragmatism creating a minimum viable product in a short amount of time is noted in prior research which is also recounted by some participants p3b p3g p5a p6a .
the implementation of critical functions is generally prioritized above architecture quality due to the fast pace and time pressure in software development p2a p4a b .
ignorance refers to the inability of individual developers to construct highquality software systems due to the lack of adequate knowledge on writing clean code the applied technologies and business domains p3d which is also highlighted in a prior study .
p3d architect illustrated without a deep understanding of a programming language or technology developers tend to misuse the features of the language or technology when performing specific programming tasks ... unintentionally incur technical debt .
a few participants mentioned some examples of technical debts relating to design activities p2a p3b including upfront detailed design of modules with an under focus on quality attributes of software systems such as maintainability and extensibility and sub optimal upfront solutions in software architectures.
lack of tool support for detecting architectural smells cgs .
most participants notice the occurrence of architectural smells in their software systems but lack tool support for detecting architectural smells p2a p3a g p4a d p6a b p11a p12a p13a p15a .
architectural smells indicate the structural problems in the components and their interactions with other components of software systems that are caused by architecture antipatterns misuse or violation of architecture styles and violation of design principles .
dependency related architectural smells are the most frequently mentioned architectural smells in our interviews p3a b p3d p3f g p4a p4c d p11a p19b including cyclic undesired and unstable dependencies .
some participants gave examples of cyclic dependency smells p3b p3d p3f p4b as shared by p3b architect happen when architecture components such as modules or subsystems depend on each other in some way directly or indirectly .
the subsystems and microservices involved in a dependency cycle tend to be impractical or even impossible to separately release deploy and maintain .
the undesired dependency occurs when an architecture component depends on anexcess number of other components p3d or the dependency introduces violations of design principles e.g.
top down dependencies in layered architectures p3g .
in terms of unstable dependency p3g project manager architect mentioned that some modules depends on other modules that are less stable than itself ... because of the dependencies the more stable modules tend to change frequently with the less stable ones .
modularity violation architectural smells are also frequently discussed in our interviews p2a p3a b p3d g p6a p11a p19b .
participants reported that software systems become increasingly complex as the development proceeds with gradually losing cohesion in architectural components thus deteriorating the modularity of the systems.
for example some participants observed god components as an architectural smell p2a p3b p3d f as expressed by p3b architect some components have taken on way too many responsibilities and completely disregarded the principle of separation of concerns .
the presence of modularity related architectural smells may imply the sub optional decisions for decomposition and modularization in the design phase p2a p3a p3d p3f g p6a .
unawareness of correlation between code smells and architecture problems gr .
most organizations use a variety of code analysis tools for code smell detection yet participants do not understand whether relationships exist between code smells and architecture problems.
specifically organizations apply homegrown open source or commercial tools for automated detection of code smells including duplicated code p3c p3f p11a p12a p17a cyclomatic complexity p3b bad naming p2a p3b d p3f p4b and large class p2a p3b p3e f .
for example p3c developer lead testing shared we ve got tools to help us catch duplicate code and other code smells but it s not clear how the results actually help us identify architecture problems .
previous studies indicate that certain patterns of co occurrence of code smells tend to be effective indicators of architectural erosion .
several code smell detection techniques look at the correlation between code smells and architectural smells for locating architecture problems e.g.
.
some code smell detection tools also employ code smell metrics that are relevant to the identification of architectural smells .
recommendations.
investing effort and time in addressing technical debts is important gr .
some participants recommended employing commit level refactoring to gradually reduce technical debts that contribute to architecture problems p4a p5a .
a few participants suggested incremental benefit analysis for code changes relating to technical debts which may encourage developers to prioritize development tasks that address technical debts.
it is important to automate the detection of architectural smells to facilitate the enforcement of architectural constraints in the construction phase cgs .
most participants emphasized that the automated detection of architectural smells as a proactive prevention strategy of architecture erosion can lower the cost of future maintenance for software systems p2a p3a g p4a b p6a .
some participants recommended integrating architectural smell detection into the code review process and involving architects to review code commits that incur architectural smells developers are allowed to explain their code that incurs architectural smells p3b .
to increase the usability of such tools participants recommend highlighting affected code by architectural smells and providing actionable mitigation strategies p3g .software architecture in practice challenges and opportunities esec fse november san francisco usa detecting organizational wide dependency related architectural smells requires the collaboration of multiple project teams gr cgs .
the detection of dependency related architectural smells requires the construction of dependency graphs between architectural components .
in some organizations the architectural components are developed and maintained by multiple project teams as some participants mentioned p3a p4a .
thus it is important to coordinate multiple project teams for the construction of dependency graphs.
software maintenance once a software system is delivered and in operation defects are uncovered operating environments change and new requirements surface as the system evolves.
software maintenance aims to modify the software system and ensure that the system continues to satisfy requirements while preserving its integrity.
.
architecture erosion software architecture may exhibit an eroding tendency when changes are accumulated in a software system.
as the system evolves the accumulation of such problems can cause the implemented architecture to deviate away from the intended architecture.
the phenomenon of divergence between the intended and implemented architectures is regarded as architecture erosion .
lack of tool support to explicitly capture and aggregate symptoms of architecture erosion cgs .
architecture erosion tends to affect the quality and evolution of software systems manifesting various symptoms as mentioned in our interviews and the literature .
nonetheless automated tools are rarely used by practitioners in most organizations to explicitly capture and aggregate architecture erosion symptoms in terms of quality attributes as well as maintenance and evolution activities.
most participants have perceived architecture erosion from the quality perspective including performance degradation frequent system failures and high bug rate.
in contrast a few participants pointed out that software systems with eroded architectures might have a good runtime performance because teams only monitor limited metrics of runtime performance of key business requirements p4a project manager architect .
some participants have perceived architecture erosion from the perspective of maintenance and evolution activities including difficulty in integrating new requirements into software systems and locating and fixing bugs p1a p2a p3a p3b p3f p4a p6a p11a p13a p17a .
the difficulty in such activities manifests itself in a variety of ways e.g.
increased cost complex implementation and highly scattered code changes.
for instance p6a developer illustrated when a system suffers from architecture problems integrating requirements tends to cost more time and effort than expected based on experience .
integrating a new requirement in an eroded architecture tends to be extremely complex even for a simple business requirement p1a p3a b p3f .
p4a project manager architect gave an example of locating bugs in an eroded system with microservices architecture a bug could arise from the code that spans across multiple microservices making it hard to locate .
moreover bug fixing in an eroded architecture tends to involve highly scattered code changes which affects an excessive number of files.
p3f developer identified therisks of highly scattered code changes are prone to bugs and failures in the future .
obsolete documentation and increasing complexity of software systems accelerate architecture erosion gr .
obsolete documentation and increasing complexity of software are expressed as the top reasons that cause architecture erosion in our interviews p1a p3b p3f p4a b which have been also raised in the literature .
sometimes practitioners implemented new requirements without updating the design documentation due to deadline pressure p4b .
participants also attribute architecture erosion to the increasing complexity of architecture as a system evolves.
consequently increasing complexity of software systems tends to reduce the understandability of architectures and further deteriorates the architectures by sub optimal implementations when changes occur making the architecture cumbersome heavy complicated and fragmented p1a p3c p3e .
for instance p3d architect explained it is impossible to integrate new requirements into a software system without degrading the quality of its architecture .
recommendations.
a few participants suggested building a dashboard to visualize architecture erosion symptoms which integrates data from multiple sources e.g.
the number of bugs from issue tracking systems runtime logs from the execution environment and performance metrics from monitoring tools p1a cgs .
.
architecture refactoring architecture refactoring also known as large scale refactoring involves structural and broad changes at an architectural scale to maintain the structural quality of an evolving software system and facilitate its success to facilitate the integration of new features.
no agreement on the value of architecture refactoring gr .
practitioners in organizations cannot reach an agreement on prioritizing architecture refactoring tasks over development tasks for delivering business products p2a p3a p3e f p4a p6a p11a p13a .
despite the benefits of architectural refactoring prior studies also reported that developers perceive the structural changes at architectural scale as costly complicated and risky and failing to implement such changes incurs significant consequences.
the value of continuous maintenance activities relating to software architectures tends to be underestimated because the return on investment is usually unclear p6a .
as p2a developer explained given the potentially high anticipated cost of architecture refactoring the senior management level would like to see clear quantifiable value for the organization .
architecture refactoring is primarily business driven including requirements for significant performance upgradation and delivery of new features that are not supported by existing architecture p1a p2a p3g p4a p5a p6a .
in addition technical reasons for architecture refactoring are also mentioned by some of the participants p1a p4b p5a p6a including migration to new technologies and modernization.
inadequate tool support for impact analysis of architectural changes cgs .
participants perceive impact analysis as a challenging activity when it comes to architecture refactoring.
impact analysis for architecture refactoring requires a conceptual grasp of the overall code structure as well as a deep understanding of design decisions of a software system as discussed in the literatureesec fse november san francisco usa zhiyuan wan yun zhang xin xia yi jiang and david lo e.g.
.
p1a architect emphasized that impact analysis of architecture refactoring becomes even challenging for an aging system due to its increasing complexity and staff turnover because no one in the team could be capable of performing accurate impact analysis .
organizations rarely provide tool support for impact analysis of architecture refactoring due to limited traceability information between architecture design and implementation artifacts.
in addition as a software system evolves over time the traceability information becomes obsolete due to the separate evolution of its architecture and source code p3b p3e g p4a p6a section .
also observed in previous studies e.g.
.
inadequate tool support for module and system level refactoring cgs .
in practice participants reported that their teams perform software refactoring of various granularities at different frequencies local refactoring occasionally p3a p3e f p4a b p5a p6a module level refactoring on a monthly basis p1a p3a p3f p4a p5a and system level on a yearly basis p1a p3e p11a .
most organizations integrate automated tools into their software engineering process to support local refactoring but do not provide tool support for module and system level refactoring.
practitioners tend to manually perform module and system level refactoring with limited support from automated testing frameworks.
p3a compared automated testing frameworks to safety net of a software system which validates various aspects of artifacts under refactoring e.g.
functionality performance and user experience.
prior studies also reported that software architects and developers primarily rely on manual efforts for large scale refactoring activities with minor support from disjoint tools .
recommendations.
it is important to cultivate a software engineering culture in which the whole organization shares a common commitment to high quality software architecture gr .
senior management and practitioners with different roles need to understand the implications of software architecture practice and their stakes in the system p3a p3e f p13a .
despite the importance of impact analysis in architecture refactoring there is little tool support due to limited traceability information cgs .
impact analysis supports the identification of areas affected by possible changes p3a p3e p4a p5a and the estimation of resources needed to accomplish the refactoring p1a .
in practice some organizations encourage practitioners manually build traceability links by including snippets of design documentation or its link in commit description p2a javadoc comments p4b or code review comments p6a .
the strategy enables the capturing of traceability links but requires significant maintenance efforts as architecture and source code evolves.
a few organizations use a devops dashboard to build traceability links between user stories design artifacts and source code.
it seems beneficial to adopt a more formal process for building traceability across design and implementation artifacts .
discussion in the interviews we observed that large scale organizations tend to adopt better software architecture practices as compared to smaller organizations.
while most organizations struggle to establish effective processes and tooling for achieving high quality software architectures smaller organizations struggle more and have limited advice to draw from for improvement.
apart from the size oforganizations our findings indicate that architectural styles have a notable influence on software architecture practices specifically in terms of documentation and the application of design principles.
interface specifications enable communication between subsystems in layered architectures but tend to be limited at the microservice level in microservices architectures section .
.
layered architectures prioritize vertical decomposition for hardware independence whereas microservice architectures emphasize horizontal decomposition based on business requirements section .
.
in addition participants highlighted the challenge of locating bugs in eroded systems with microservices architectures as bugs can arise from code spanning across multiple microservices posing difficulties in identification section .
.
we observed that architects participants raised more challenges compared to non architects participants with a median of vs. challenges.
similarly participants with or more years of experience participants raised more challenges than those with less than years of experience participants with a median of vs. challenges.
regarding the product domains participants from paas participant communications participants and intelligent device participants domains identified the highest number of challenges with median values of and challenges mentioned in the interviews respectively.
supplement f presents a summary of the challenges along with the recommendations identified through our interviews.
most organizations face common challenges in performing software architecture activities in terms of four aspects collaboration and management support gr architecture knowledge management adoption development and maintenance of tools cgs and process for architecture design and evolution .
beyond the specific challenges discussed throughout this paper we observe four broad themes that would benefit from more attention both in practice and future research grmanagement it is important for the strategic management level and practitioners in an organization to share a mindset that high quality software architecture requires a continuous and significant investment of time and resources throughout the software life cycle and benefits all stakeholders in software development and maintenance.
the architects from different projects or business units can work in a cross functional team in which they collaborate in architecture evaluation and review collect feedback from developers across projects to analyze architecture problems e.g.
architecture inconsistency and architectural smells and capture emerging aspects of software architecture as systems evolve.
documentation organizations use a variety of tools to capture and share architecture documentation yet practitioners express the need for better modeling tools versioning mechanisms and lightweight support for traceability in practice section .
.
despite abundant research on architecture knowledge management little is used in practice to ensure the completeness upto dateness and traceability of architecture documentation.
thus future research could put effort into designing a unified engineering tool for architecture knowledge management within an organization with support for sophisticated reasoning as well as evolution and runtime decision making.software architecture in practice challenges and opportunities esec fse november san francisco usa cgstooling practitioners struggled with inadequate use or lack of automation and tool support for architecture conformance checking section .
continuous monitoring section .
architectural smell detection section .
and architecture refactoring section .
.
the development of such tools is a highly sophisticated and time consuming process involving interdisciplinary expertise in both technical and business aspects of software systems.
some participants recommend building a dedicated team for tool development and maintenance to alleviate additional burdens for development teams.
traceability links between various software artifacts play a fundamental role in such tools but require manual maintenance in practice which can be time consuming and error prone.
recent studies on automatic traceability recovery may provide support to the maintenance of traceability links.
future research could investigate the applicability of such traceability recovery techniques in practice.
process in practice architects tend to base the reasoning process of design decisions on their own experiences and expertise.
even though some organizations encourage the practice of including design decisions and rationale in architecture documentation few provide guidance for representing design decisions and rationale to support the consumption of such architecture knowledge.
we have seen a number of meta models that aim at representing design decisions and rationale .
it can be beneficial to integrate the use of meta models in the decision making process for architecture design.
threats to validity our study exhibits typical threats for qualitative research.
generalizations beyond the sampled participant distribution should be made with care.
another threat could be the representativeness of our study demographics for the software industry in general as the participants have been sampled through our personal networks.
in several organizations we only interviewed a single person possibly giving us a one sided perspective.
to mitigate this threat we applied maximum variation sampling method to cover practitioners with varying levels of experience and diverse job roles and from organizations of different sizes product domains and geographical regions.
the purposive sampling and constant comparisons in data analysis lead to data saturation being achieved with a relatively small sample size of interview participants.
the diverse range of organizations and experience of participants presented an opportunity to triangulate the overall dimensions of the broad topic of software architecture in practice.
despite the specialized experience within different organizations among various participants the participants shared significant similarities in the challenges they encounter as evidenced in the follow up validity check.
conclusion and future work this work followed a qualitative research strategy through interviews with participants from organizations to explore how practitioners perform software architecture related activities as well as what challenges they face.
we observed significant variations among organizations in terms of their strategies processes and tools related to software architecture.
yet we identified common challenges in performing software architecture activities in terms of four aspects collaboration and management support architecture knowledge management adoption development and maintenance of tools and process for architecture design and evolution.
future research could put efforts into quantitatively exploring how cultural product and company characteristics influence the software architecture practices and challenges and further designing strategies to attain high quality software architectures throughout software development and maintenance.