speedingup smtsolvingvia compiler optimization benjaminmikek bmikek gatech.edu georgia instituteoftechnology usaqirun zhang qrzhang gatech.edu georgia instituteoftechnology usa abstract smt solvers are fundamental tools for reasoning about constraints in practical problems like symbolic execution and program synthesis.
faster smt solving can improve the performance and precision of those analysis tools.
existing approaches typically speed up smt solving by developing new heuristics inside particular solvers whichrequiresnontrivialengineeringefforts.thispaper presentsanewperspectiveonspeedingupsmtsolving.wepropose smt llvm optimizing translation slot a solver agnostic pre processingapproachthatutilizesexistingcompileroptimizations to simplify smt problem instances.
we implement slot forthe two mostapplication critical smt theories bitvectors and floating point numbers.
our extensive evaluation based on the standard smt lib benchmarksshows that slot cansubstantially increasethenumberofsolvablesmtformulasgivenfixedtimeouts andachieve mean speedups ofnearly for large benchmarks.
ccsconcepts softwareanditsengineering formalsoftwareverification.
keywords smtsolvers simplification compileroptimization acm reference format benjaminmikekandqirunzhang.
.speedingupsmtsolvingviacompileroptimization.
in proceedingsofthe31stacm jointeuropeansoftware engineering conference and symposium on the foundations of software engineering esec fse december3 sanfrancisco ca usa.
acm newyork ny usa 13pages.
introduction satisfiability modulo theories smt constraints are first order logicalformulaswithfunctionsandvariablesfromvarioustheories suchasrealnumbers integers and asrelevanttosoftwareengineering bitvectors andfloating pointnumbers.state of the artsolvers like cvc5 and z3 use a complex mix of heuristics theoryspecific engines and sat solver calls to efficiently reason about smtconstraints.yetmanyconstraintsstilltakeaprohibitivelylong timetosolve.improvingsolverperformancecanimproveresults for real world applications.
for example in symbolic execution lowersolvingtime equates togreatercode coverage .
esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
more powerful solving strategies.
these have sometimes takentheformofnewsolverslikeboolector orofnewalgorithms in existing solvers.
for example berzish et al.
introduce new heuristics for string constraints involving regular expressions while bj rner et al.
improve z3 s performance for custom theories.fastsmt speedsupsolvingbyusingmachinelearningto choose the best solverheuristics.
this paper proposes a new perspective on improving smt solving insteadofdevelopingmoreadvancedsolvingtactics ourkey insightistorepurposeexistingcompileroptimizationtechniques to thesmt problem.in particular we propose a translation based pre processingstep smt llvmoptimizing translation slot whichcandirectlyoptimizeinputsmt libformulas.conceptually ourapproach has three main advantages simplicity end usersofsmtsolverscanbenefitfromcompileroptimizationsasablackbox withoutdetailedknowledge ofsmt specific optimizations.
solver independence becauseitisapre processingstep on smt constraints semantics preserving optimization can be usedin applications that use any solver s .
extensibility new compiler optimizations can be directly applied to further improve smt solving without the need to make complex changes to solvers.
slotbypassestheneedtore implementcompileroptimizations insmtsolversbytranslatingtheconstraints ratherthantheoptimizations.
while not all compiler optimizations are useful for the smt context the combination of semantics preserving optimization with existing solvers creates a sieve some constraints arecaughtquicklybyexistingsolverheuristics whileothersare handledbetterby slot.
we have implemented slotfor the smt theories of bitvectors andfloating pointnumbers.constraintsinthesetheoriesarethe most relevant to software engineering because they model machinearithmetic forexample theyareusedinpracticaltoolsfor symbolicexecution translationvalidation andprogram synthesis .insection weshowthatthesemanticsofthesetwo theories can be exactly represented in llvm ir.
the key challenge forslotisbridgingthesemanticgapbetweensmtconstraintsand llvmirwhichexistsbecausethelanguages onedeclarativeand the other imperative were designed for entirely different purposes.
figure1illustrates the three components of slot.
thefrontend translatessmtconstraintstollvmir.thisstepensuresthatevery smt function is converted to an equivalent sequence of llvm instructions.
optimization uses the llvm optimizer to simplify thetranslatedconstraintalmostforfree.finally slot sbackend translatestheoptimizedllvmirbackintoansmtconstraint.the complex structures created by the optimizer must be translated back withoutsemantic gaps.
thisworkislicensedunderacreativecommonsattribution sharealike4.
internationallicense.
esec fse december3 san francisco ca usa benjamin mikekandqirun zhang smtllvmir llvmir smt frontendllvmopt backend solver solversat sat figure1 overviewof slot stranslationandoptimization process.
the output constraint smt is satisfiable if and onlyif theoriginalconstraint smt issatisfiable.
we have applied slotto the quantifier free benchmarks for bitvectors floating point numbers and their combination included in the smt lib specification .
our extensive evaluation demonstratesthat slotcansubstantiallyspeedupsmtsolving especially forcomplexconstraintswhichwouldotherwisetakealongtimeto solve.ourapproachincreasesthenumberofsolvableconstraints byupto20 forbitvector forfloating point and80 formixed benchmarks.moreover slotismoreeffectivethanexistingsolvers combined it can solve constraints for which all tested solvers time out.
we also observe mean speedups above for bitvector and floating point and as high as for mixed constraints.
by measuring which optimization passes contribute most to the speedup we findthatsimplepeepholeoptimizationsandglobalvaluenumbering are sufficient to improve solver performance.
in summary we make the following primary contributions we present an easy to use solver agnostic framework for speeding up smt solving by translating constraints to a compilerir andback.
we define prove and implement slot and show that it improves the performance of solvers on standard benchmarks.
we measure which llvm optimization passes contribute most to speeding up smt formulas giving users access to well testedsimplificationsandsolverdevelopersinsightinto possible solver improvements.
the rest of the paper is structured as follows.
section 2motivatesslotwith an example smt constraint.
section 3presents backgroundonconstraintsinsmt lib whilesection 4describes slot stranslationandprovesitsfidelity.section 5describesthe evaluation results and section 6puts the results incontext.finally section7surveys relatedwork andsection 8concludes.
motivating example this section presents a concrete example figure to motivate slot.
specifically it takes z3 seconds to solve the original formula figure 2a .afterapplying slot theoptimizedformula figure2d can be solvedalmostinstantly.
inputsmtconstraint.
figure2agivesansmtformulafromthe smt lib qf bvbenchmarkset.1itcheckswhethermultiplication can overflow lines when the inputs u1d44eand u1d44fare subject to a divisionconstraint line .theformulais unsatbecauseanyvalue of u1d44ewhichsatisfiesthe secondassertioncauses the multiplication u1d44e u1d44ftooverflow.eventhoughthisconstraintisconciseandsimple z3takes 390secondsto return the unsatresult.
1qf bv challenge multiplyoverflow.smt21 declare fun a bitvec declare fun b bitvec assert not extract bvmul zero extend a zero extend b x00000000 assert bvuge bvudiv xffffffff a b check sat a original smt lib constraint.
1define i1 smt i32 a i32 b zext i32 b to i64 zext i32 a to i64 mul i64 lshr i64 trunc i64 to i32 icmp eq i32 xor i1 true udiv i32 a icmp eq i32 a select i1 i32 i32 icmp uge i32 b and i1 14ret i1 b resultof slotfrontendtranslation.
1define i1 smt i32 a i32 b 2ret i1 false c resultof slotoptimization.
assert false check sat d finalformulaafter slotbackendtranslation.
figure slottranslation and optimization process.
frontend.
figure2bgivestheresultof slot sfrontend anllvm functionthatissemanticallyequivalenttothesmtconstraintin figure2a.
this function returns true onan input u1d44e u1d44f if and only if u1d44e u1d44f satisfies the originalconstraint.
itsinstructions mirror the function applications in figure 2a.
for example zextis equivalent to the smt zero extend operation and mulisequivalentto bvmul.
optimization.
figure2cgivestheresultofllvmoptimization on the function in figure 2busing all available optimization passes.
in this example only three passes affect the function s instructions instcombine reassociate anddce.
these simplify away all substantive code producing the function that always returns false.
backend.
finally figure 2dshows the result of translating figure2cback to an smt constraint.
since the llvm function always returns false the corresponding smt constraintsimply asserts falsity.z3can nowtrivially produce the unsatresult in0.02seconds.
challenges.
from figure we can see that slotallows an smt solver to leverage the power of existing llvmoptimizations.
the keytechnicalchallengeof slotisbridgingthesemanticgapbetweensmtconstraintsandllvmir i.e.
ensuringtheinputand outputsmtconstraintsareequivalent.whilemultiplicationand bitextensionareequivalentinthetwolanguages smtfunctions cannotalwaysbedirectlymappedtollvmir.forexample line offigure 2baddsachecktoensurethedivisiononline 8offigure 2a does not introduce division by zero because this has undefined behaviorinllvm.
1178speedingupsmtsolvingviacompileroptimization esec fse december3 san francisco ca usa preliminaries this section gives background on the smt problem and describes the bitvector and floating point theories of the smt lib standard .
definition smt formula .
given atheory u1d447with signature and interpretations u1d43c an smt formula u1d719is an expression made up ofsymbols functionapplicationsor variables from .
u1d43cis theset of mapsfromvariablesin tosort appropriatevalues.
u1d719issatisfiableif thereexistsaninterpretationin u1d43cthat satisfies u1d719.
intuitively a theory u1d447provides definitions of sorts i.e.
types andfunctions andansmtformulaisasetofvariablesandaconstraint on those variables using functions from u1d447.
if there exists an assignmentofthevariableswhichfulfillstheconstraint wecallthe formula sat otherwise itis unsat.thesmt libstandarddefines eight theories and from these logics combinationsof functions from one or more theories possibly with extensions.
all logics rely on the coretheory which defines basic boolean operations like logic and logic or and equality.
we restrict our discussion tothecoretheoryandthequantifier freelogicsofbitvectorsand floating pointnumbers.
smt lib has a sort for each width of bitvector bitvec u1d45b severalunaryandbinaryoperationsonbitvectorslike bvnegand bvadd andbitvectorcomparisonslike bvuge.thetheoryoffloatingpointnumbersdefinesthesorts floatingpoint u1d452 u1d460 forintegers u1d452 u1d460 .
operations on floating point values follow standard ieee754semantics thoughthesizesoftheexponentandsignificand are not limited to those defined in ieee .
as with the bitvectorlogic thereare unaryandbinaryoperationson floating point values many of these require the specification of one of the five roundingmodes andcomparisonsthatyieldbooleans.thereare also conversions from floating point to bitvectors from bitvectors tofloating pointvalues andbetweendifferent sizefloating point values.table 1gives afull listof qf bvandqf fpfunctions.
followingtheworkofkroeningandstrichman wesummarizetable 1usingthegrammarshowninfigure .thegrammar consistsofformulas u1d439 bitvectorcomparisons u1d435 floating point comparisons u1d436 bitvectorvalues u1d449 andfloating pointvalues u1d44a .
intuitively formulasareexpressionswithbooleansort bitvector and floating point comparisons are expressions of boolean sort which take bitvector or floating point expressions respectively andvaluesare expressionsofbitvector orfloating pointsort.
slot smt llvm optimizing translation thissectionformalizesthetranslationdescribedinsection 2and presentsproofsofsemanticspreservationforbitvectorsandfloatingpointvalues.
.
overview givenansmtconstraint u1d436 slottranslateseachoperationtoan llvm equivalent creating an llvm function u1d43f.
it then invokes thellvmoptimizer producinganoptimizedfunction u1d43f .finally it translates back into an smt constraint u1d436 .
intuitively equivalence between u1d436and u1d436 meansthattheirsetsofsatisfyingassignments areequal.equivalencebetweenaconstraintandanllvmfunctiontable1 list offunctionsinthe bitvectorand floating point theories by type.
we abbreviate bitvectors bv floating point valuesfp and rounding modes rm.
u1d434represents any type.
indicatesafunction parameterized by integerconstants indicates afunction that changesbitwidths.
function sort qf bvandqf bvfp functions bool bool not bool bool bool and or xor u1d434 u1d434 bool distinct bool u1d434 u1d434 u1d434 ite bv bv bool bvule bvsle bvuge bvsge bvult bvslt bvugt bvsgt bv bv bvnot bvneg extract repeat zero extend sign extend rotate left rotate right bv bv bv concat bvadd bvsub bvmul bvsdiv bvudiv bvsrem bvurem bvsmod bvand bvor bvnot bvxor bvnand bvnor bvxnor bvshl bvlshr bvashr bvcomp fp bool fp.isnan fp.isinfinite fp.iszero fp.isnormal fp.issubnormal fp.isnegative fp.ispositive fp fp bool fp.eq fp.lt fp.gt fp.leq fp.geq fp fp fp.neg fp.abs rm fp fp fp.sqrt to fp fp.roundtointegral fp fp fp fp.rem fp.min fp.max rm fp fp fp fp.add fp.sub fp.mul fp.div rm fp fp fp fp fp.fma bv fp to fp bv bv bv fp fp rm bv fp to fp to fp unsigned rm fp bv fp.to ubv fp.to sbv u1d439 true false u1d436 not u1d439 u1d439 u1d439 and u1d439 u1d439 or u1d439 u1d439 xor u1d439 u1d439 u1d439 u1d439 distinct u1d439 u1d439 ite u1d439 u1d439 u1d439 u1d435 u1d449 u1d449 distinct u1d449 u1d449 bvc u1d449 u1d449 u1d436 u1d44a u1d44a distinct u1d44a u1d44a fpc u1d449 u1d449 fp.isclass u1d44a u1d449 constant symbol ite u1d439 u1d449 u1d449 bvop1 u1d449 bvop2 u1d449 u1d449 fp.to ubv u1d44a fp.to sbv u1d44a u1d44a constant symbol fp.fma u1d44a u1d44a u1d44a fpop1 u1d44a fpop2 u1d44a u1d44a to fp u1d449 to fp unsigned u1d449 fp u1d449 u1d449 u1d449 figure3 thegrammarofconstraintsinthe qf bvandqf bvfp logics.bvcisanyofthebitvectorcomparisonsfromtable .
fpcmeansanyofthefloating pointcomparisons and class meansanyofthefloating pointclassoperations.
bvop1and bvop2meananyoftheunaryandbinarybitvectoroperations respectively andthesamefor fpop1andfpop2.
means that given a variable assignment evaluating the constraint produces the same result as executingthe llvmfunction.
algorithm 1performs the translation from an smt lib constraint u1d436intoanllvmfunction u1d43f.eachfunctionrecursivelybuilds the llvm statements corresponding to an smt expression.
the getllopfunction represents fetching an llvm instruction or instructions which have the same effect as the input smt operation u1d436op.the variables of u1d436are convertedto arguments of u1d43f.
optimization from u1d43fto u1d43f is performed by the llvm optimizer.
forblack boxstyleprocessingofsmtconstraints slotusesall the passes included in llvm s o3optimization level.
however not 1179esec fse december3 san francisco ca usa benjamin mikekandqirun zhang algorithm1 slotfrontendtranslation.
data c aconstraintwithfunction u1d436op children u1d4360 u1d4361 ... result l an llvmfunction function buildllvm c ifcis an fp comparison then returnbuildcomparison fp c else ifcis a bvcomparison then returnbuildcomparison bv c else ifcis a leaf then returncas booleanconstant else return getllop u1d436op buildllvm u1d4360 buildllvm u1d4361 function buildcomparison t c returngetllop u1d436op buildval t u1d4360 buildval t u1d4361 function buildval t c ifcis a leaf then returncas at constant else ifcis an fp conversion then returngetllop u1d436op buildval bv u1d4360 else ifcis a bvconversion then returngetllop u1d436op buildval fp u1d4360 else ifcisitethen returnselect buildval bool u1d4360 buildval t u1d4361 buildval t u1d4362 else return getllop u1d436op buildval t u1d4360 buildval t u1d4361 alloptimizationpassesarerelevantto slot stranslation forinstance slotdoesnotintroduceanymemoryoperations .section discussesindetailwhichllvmpassesaremostimportantfor slot.
finally we translate u1d43f back into an smt constraint u1d436 with algorithm .
this translation is straightforward we proceed along the u1d43f syntax tree and convert each instruction to its equivalent smt lib function as in algorithm .
because frontend translation optimization and backendtranslationallpreservethe semanticsof the constraint we can then use the satisfiability of u1d436 as a proxy for the satisfiability of u1d436 this property is formalized in theorem .
the key challenge of translation is defining getllopwithout introducing undefined behavior.
some functions can be translated one to one butbitvectordivision shifts andfloating pointcomparisons have subtly different semantics in llvm and smt lib.
in addition some smt operations have no direct llvm equivalent and viceversa requiringtheirsemanticstobebuilt fromexisting operations ineachlanguage.
.
frontend translation types.let u1d436beansmtconstraintovervariables u1d4501 u1d4502 ... u1d450 u1d45b.the possiblesortsofavariable u1d450 u1d456areboolean bitvector andfloatingpoint.an smt lib booleanisequivalentto the llvm i1type.an u1d45b widebitvector isequivalenttothellvmtype i u1d45b.thesmt lib floating pointsorts floatingpoint floatingpoint floatingpoint and floatingpoint arerespectivelyequivalentto llvm s half float double andfp128types.
smt lib supports floating point values of arbitrary width and even of arbitrary exponent and significand widths but llvm supportsonlyafewfixedfloating pointwidths.we therefore limitour translationtothestandard16 and128 bitfloating point types withexponentandsignificand sizeslistedabove.algorithm2 slotbackend translation.
data l an llvmfunction result c an smt constraint function buildsmt l u1d449 u1d43f.
u1d44e u1d45f u1d454 u1d462 u1d45a u1d452 u1d45b u1d461 u1d460 returnconvertval v l.return function convertval vars value ifvalueinvars then returngetsmtvar value else ifvalueis a constant then returngetsmtconst value else ifvalueisicmpthen returngetsmtbvcomp convertval vars value.op convertval vars value.op else ifvalueisfcmpthen returngetsmtfloatcomp convertval vars value.op convertval vars value.op else ifvalueis an intrinsiccall then returngetsmtintrinsic convertval vars value.op ... else returngetsmtop convertval vars value.op convertval vars value.op example1.
an smt constraint u1d436withvariables declare fun a bool declare fun b bitvec declare fun c floatingpoint is translated to anllvmfunctionwiththe followingsignature define i1 c i1 a i64 b float c .
variablesandconstants.
duringfrontendtranslation wegive variables the same names in u1d43fas in u1d436.
it is also straightforward to translate boolean and bitvectorconstants which have the same representationinllvmasinsmt lib.thefloating pointvalues andnanaretranslatedtotheirllvmrepresentations all otherfloating pointvaluesare constructedfrom bitvectors.
simpleoperations.
manyoperationshavethesamesemantics inllvmandsmt lib welisttheseherewithoutdetailedproof.
slottranslatestheseoperationsbysimplyapplyingtheequivalent llvmoperation to the same arguments.
thebooleanfunctions and or andxorhavethesamenames andsemanticsinllvmandsmt lib.
u1d44e u1d44f isreduced to or not u1d44e u1d44f .
bitvector and floating point comparisons including for bitvectors and fp.eqfor floating point are equivalent to thellvm icmpandfcmpinstructionswiththeappropriate condition codes orderedfor floating point .
the smt lib function iteisequivalentto llvm select.
zeroextensionandsignextensionareequivalentinsmt lib andllvm.
thebitvectormathoperations bvadd bvsub andbvmuland foatingpointmathoperations fp.neg fp.add fp.sub fp.mul fp.div andfp.remhave the same semantics as the similarly namedllvminstructions.
the smt lib notandbvnotoperations are equivalent to the llvmxorinstruction with the second argument having all bits set i.e.
.
1180speedingupsmtsolvingviacompileroptimization esec fse december3 san francisco ca usa zero icmp eq i u1d45b b div udiv i u1d45b a b out select i1 zero i u1d45b i u1d45b div a llvm equivalentof bvudiv u1d44e u1d44f .
zero icmp eq i u1d45b b neg icmp slt i u1d45b a const select i1 neg i u1d45b1 i u1d45b div sdiv i u1d45b a b out select i1 zero i u1d45b const i u1d45b div b llvm equivalentof bvsdiv u1d44e u1d44f .
zero icmp eq i u1d45b b rem u s rem i u1d45b a b out select i1 zero i u1d45b a i u1d45b rem c llvm equivalentof bv u s rem u1d44e u1d44f .
figure llvm equivalents of smt lib division and remainder.
to fpon a single bitvector argument is equivalent to the llvmbitcastinstruction.
to fpon a floating point argument is equivalent to either fpextorfptrunc depending on the relative widths.
to fpon a rounding mode and a bitvector i.e.
signednumericconversiontofloating point hasthe samesemanticsas sitofpinllvm.similarly to fp unsigned isequivalentto uitofp.
thesmt libconversions fp.to ubv andfp.to sbv areequivlent to the llvm instructions fptouiandfptosi respectively.
in addition to functions with equivalent llvm instructions we express several smt lib functions using llvm intrinsics.
these are commonllvmfunctionsinvokedusing the call intrinsic syntax.
in the context of slot there is no cost to using intrinsics insteadofinstructions aswedonotusethellvmirtogeneratea binary.
smt lib bit rotation is equivalent to llvm s funnel shift intrinsics.forexample rotate left u1d456 u1d44e becomes call i u1d45b llvm.fshl.i u1d45b i u1d45b a i u1d45b a i u1d45b u1d456 .
floating point fusedmultiply add fma squareroot and absolute value have thesamenames andsemantics insmtlibandllvm as intrinsics .
fp.minandfp.maxare equivalent to the llvm.minnum and llvm.maxnum intrinsics respectively.thesematchthesmtlib semantics in that if one argument is nan the other argumentisreturned.
the smt lib floating point class predicates like fp.isnan fp.isinfinite etc.
are equivalent to the llvm.is.fpclass intrinsic.
thisintrinsic takesa bitmaskrepresenting which classestocheckfor eachofthesmt libpredicatescanbe representedwiththe flags.
division and bit shifting.
there are several functions whose smt libandllvmversionsdifferinsubtlewaysbecauseofundefined behavior.
in smt lib bitvector division by 0is defined asafixedvaluedependingonthedividend.inllvm itproduces apoisonvalue whichispropagatedbytheoptimizerthroughall subsequentoperations.tobuildanequivalentseriesofllvminstructions we mustadd acheckfor this case.
wide icmp uge i u1d45b b u1d45b shift shl i u1d45b a b out select i1 wide i u1d45b0 i u1d45b shift a llvm equivalentof bvshl u1d44e u1d44f .
wide icmp uge i u1d45b b u1d45b shift lshr i u1d45b a b out select i1 wide i64 i u1d45b shift b llvm equivalentof bvlshr u1d44e u1d44f .
wide icmp uge i u1d45b b u1d45b neg icmp slt i u1d45b a const select i1 neg i u1d45b i u1d45b0 shift ashr i u1d45b a b out select i1 wide i u1d45b const i u1d45b shift c llvm equivalentof bvashr u1d44e u1d44f .
figure llvm equivalentsofsmt libshift.
bca bitcast float a to i u1d45b bcb bitcast float b to i u1d45b nana call i1 llvm.is.fpclass.f u1d45b fp a i32 nanb call i1 llvm.is.fpclass.f u1d45b fp b i32 both and i1 nana nanb eq icmp eq i u1d45b bca bcb out or i1 both eq figure llvm equivalent of u1d44e u1d44f for floating point values.fpindicates half float double orfp128withwidth u1d45b.the constant i32 3indicates acheckfor nan.
figure4shows the frontend translation of the four smt lib bitvector division and remainder operations.
in each case slot addsacheckcomparingthedivisortozero andthenchooseseither theresultofanllvmmathoperationoraconstantasdefinedin the smt lib standard.
signed division figure 4b may produce either1or 1depending on the signs of the inputs.
the bvsmod operation istranslatedto acomputationinterms of urem.
in addition to different handling of division by llvm and smt lib have different semantics for bitvector shift operations.
in llvm shifts by the bit width or more have undefined behavior.
in smt lib they always result in a bitvector of all 0s or all1s in the case of arithmetic shift right of anegative value .
the translations ofthesethree shift operations are showninfigure .
floating point equality.
llvm floating point math does not haveundefinedbehaviorasintheintegercase butwemusthandle two distinct notions of equality fp.eqand .
the function fp.eq checks for floating point equality in the ieee sense it has the same semantics as llvm s fcmp oeq.
smt lib on the other hand is a core theory operation that checks for the equality of two smtexpressions.unlikeieee everyvaluemustbeuniquely represented in smt lib so there is one nan object which is equal to any other nan.
in all other cases means bitwise equality this translation isshowninfigure .
changing bit widths.
there are three bitvector operations that changethebitwidthsoftheirarguments concatenation combining multiple bitvectors repeat repeating a single bitvector a constant number of times and bit extraction.
each of these operations is translatedtoasequenceofllvminstructionsthatsimulatetheir semantics.
suppose we have a bitvector u1d44eof length u1d45band want 1181esec fse december3 san francisco ca usa benjamin mikekandqirun zhang zsg zext i1 sign to i u1d45b zex zext i u1d452 exp to i u1d45b zsi zext i u1d460 sig to i u1d45b ssg shl i u1d45b zsg u1d45b sex shl i u1d45b zex u1d452 right or i u1d45b sex zsi all or i u1d45b ssg right out bitcast i u1d45b all to fptype figure7 llvmequivalentof fpsignexpsig .
u1d45bisthewidth ofthefloating pointvalues u1d452isthewidthoftheexponent and u1d460is the width of the significand.
fptypemay be any of half float ordouble.
to extract the bits from u1d456down to u1d457 both inclusive in smt lib .
intuitively to extract this portion of u1d44e we move the bits of interest to the right end of the bitvector a shift by u1d457 and then truncate to the appropriate size u1d456 u1d457 .
concatenationinvolvesextendingbothargumentstothenew width shiftingoneintothenewly addedall zerobitsoftheother andthencombiningwithbitwise or.thesmt lib repeat u1d45b a operationistranslatedbychainingmultipleconcatenations.the number of repetitions is a constant parameter and is therefore known statically.
the translations of concatenation and repetition mayaddredundantoverheadforsomeinputs butanysuchoverhead iseliminatedduringthe optimization phase.
floating point construction.
the smt lib floating point constructor fptakes a bitvector each for the sign exponent and significandandreturnsafloating pointvalue.inllvm weneedto concatenate shiftandbitmask thethreepartsandinterpret i.e.
bitcast the result as a floating point value.
this translation is showninfigure .
roundingmodes.
smt libdefinesfiveseparatefloating point roundingmodes roundnearesttiestoeven roundnearesttiestoaway roundtowardpositive roundtowardnegative androundtowardzero .
these modes specify the semantics of floating point operations likeadditionandsubtractionwhenroundingisrequired.bydefault llvm floating point instructions follow round to nearest with ties to even so slottranslates smt function applications with this rounding mode directly to llvm instructions.
for other rounding modes the tool must generate an llvm call to a constrained floating point intrinsic in llvm which in most cases allows the specification ofroundingmode.
example2.
thesmtoperationwith32 bitfloating pointvariables u1d44eand u1d44f fp.add roundtowardpositive a b is translated to thefollowing call float llvm.experimental.constrained.fadd.f32 float a float b metadata !
round.upward metadata !
fpexcept.ignore however constrainedfloating pointintrinsicsdonotexistfor allsmt liboperations inthesecases slotchoosesthecorrectintrinsic based on rounding mode.
for example smt lib conversion from floating point to signed bitvector fp.to sbv becomes one of constrained.roundeven constrained.lround llvm.ceil llvm.floor orfptosi dependingontherounding mode.analogousmeasures are requiredfor fp.to ubv andfp.roundtointegral .
.
backend translation simple operations variables and types.
during backend translation the straightforward operations listed in section .
canbetranslatedjustasduringfrontendtranslation.functionargumentsof u1d43f areconvertedtovariablesin u1d436 withthesamenames and types.
llvm s optimizer may add or remove intermediate ssa variables in u1d43f but only the function arguments are converted to variables in u1d436.
the optimizer may render one of the function arguments dead in this case it is not translated back into a variable.
therefore thesetofvariablesin u1d436 isasubsetofthevariablesin u1d436.bitvectorandfloating pointtypesarealsotranslatedasduring frontendtranslation.however llvmdoesnotdistinguishbetween booleansand1 widebitvectors whilesmt libdoes.inmostcases this distinction is immaterial and we treat i1as a boolean but wheretheoptimizerintroducesbitvectoroperationsonan i1 for instance signextension weconverttheargumenttoabitvector ratherthanaboolean.
undefined behavior.
during frontend translation great care mustbetakennottointroduceundefinedbehaviorinto u1d43f.thisis becausethesmtversionsofoperationsaremorestrictlydefined thanthoseinllvm inotherwords thesmtbitvectordivision for instance matchestheoutputsofllvmdivisiononallinputs but notthereverse.llvmoptimizationdoesnotintroduceanyundefined behavior so during backendtranslation we need not insert anychecksaroundoperationslikedivisionandshifting.thereis one llvm operation that is undefined in smt lib bitcast conversions from floating point values to integers.
slothandles these conversionsbyintroducinganextraintegervariableandconstrainingthe result ofconverting itto afloating point.
bit operation intrinsics frontend translation produces only thoseintrinsicslistedinsection .
.however theoptimizermay introduceotherintrinsicswhichmustbehandledbybackendtranslation.the llvm.bswap intrinsicswapsthe lowestandhighest bytes of its input and is translated to a sequence of extract and concatenate operations representing these semantics.
similarly the llvm.bitreverse intrinsicreversesallofthebits thisisalsoachieved bycomposingextractionandconcatenation.finally the llvm.ctpop intrinsic counts how many bits are set have value in a bitvector this is also achieved through several extractions followed by addition.
math intrinsics.
llvm includes the intrinsics umin umax smin andsmaxto take the signed minimum unsigned maximum signed minimum and signed maximum respectively of two bitvector arguments.
these intrinsics are translated into an smt lib ite operation with the appropriate comparison.
for example a umin call on bitvector arguments u1d44eand u1d44fis translated to the smt lib expression ite bvultab ab .
in addition llvm includes saturated math operations like llvm.usub.sat .
these instructions prevent over and underflow by clampingthereturnvalueto 0ifunderflowwouldhaveoccurred.
liketheminimumandmaximumoperations theseintrinsicsare translated to a iteexpression.
rounding mode intrinsics produced byfrontendtranslationmustalsobeconvertedbacktothecorresponding smt function with the correct rounding mode argument.
1182speedingupsmtsolvingviacompileroptimization esec fse december3 san francisco ca usa .
preservationofsatisfiability we show that for bitvector and floating point constraints the satisfiability of the original smt constraint is preserved through frontend translation lemma optimization and backend translation lemma2 .
property optimizer semantics preservation .
given an inputllvmfunction u1d43fwhichdoesnotcontainanyundefinedbehavior theresultofoptimizing u1d43f callit u1d43f hasthesamesemanticsas u1d43f.that is forall inputs u1d4591 u1d4592 ... u1d459 u1d45b u1d43f u1d4591 u1d4592 ... u1d459 u1d45b u1d43f u1d4591 u1d4592 ... u1d459 u1d45b .
this property of the optimizer may not always hold because the optimizer may contain bugs.
but in our work we take it as ground truth that the input and output of the optimizer are equivalent.
because we focus on relatively simple optimizations e.g.
we do not deal with memory operations compiler bugs changing our results are likely to be rare.
in our testing of more than smtbenchmarks wehaveencounterednocompilerbugs.wenow prove that slotissemantics preserving.
lemma frontend translation .
let u1d436be an smt constraint with variables u1d4501 u1d4502 ... u1d450 u1d45b and u1d43fbe the function produced by the frontend translation of u1d436.
then u1d436is satisfiable if and only if there existsaninputto u1d43fforwhich u1d43freturnstrue.
proof.
assume u1d436is satisfiable.
then there exists an assignment of the variables of u1d436 u1d44b u1d4651 u1d4652 ... u1d465 u1d45b for which u1d436 evaluatestotrue.let u1d43fdenotethellvmfunctionresultingfrom frontend translation.
from section .
at each instruction u1d456in u1d43f thevalueproducedby u1d456isthesameasthevalueproducedbythe corresponding function application in u1d436.
in particular with the assignment u1d44b u1d436 soutermostfunctionapplicationshouldproduce true.this means that the last instructionin u1d43fmustreturn true.
assumethatthereisaninput u1d44b u1d4651 u1d4652 ... u1d465 u1d45b suchthat u1d43f u1d44b istrue and consider whether the assignment of the values u1d44b tothevariablesof u1d436satisfies u1d436.bythetranslationsinsection .
for eachinstruction u1d456 theequivalentfunctionapplicationin u1d436yields thesamevalue.inparticular weassumethatthelastinstructionin u1d43freturnstrue this corresponds to thefinal result ofevaluating u1d436 sothe assignment u1d44bmustsatisfy the constraint u1d436.
lemma2 backendtranslation .
let u1d43fbeanllvmfunction over integer bitvector types with u1d45barguments and let u1d436be the smt constraint resulting from performing backend translation on u1d43f.
then u1d436is satisfiable if and only if there exists a set of inputs u1d4591 u1d4592 ... u1d459 u1d45b suchthat u1d43f u1d4591 u1d4592 ... u1d459 u1d45b returnstrue.
proof.
assume that there exists an input u1d4591 u1d4592 ... u1d459 u1d45bon which u1d43freturns true.
let the set of values of the internal ssa variables of u1d43funder the given input be u1d4631 u1d4632 ... u1d463 u1d459 and call u1d44c u1d4591 u1d4592 ... u1d459 u1d45b u1d4631 u1d4632 ... u1d463 u1d459 the set of all variables from u1d43f.
at each instruction u1d456in u1d43f thecorrespondingfunctionapplicationin u1d436gives thesamevalueas u1d456.inparticular because u1d43freturnstrue thelast instruction and so the result of evaluating u1d436 must be true which means that the assignment u1d44csatisfiesthe constraint u1d436.
assume that u1d436is satisfiable.
this means that there exists a set of variables u1d44c u1d466.alt1 u1d466.alt2 ... u1d466.alt u1d458 for which u1d436produces true.
nowtakethesubsetof u1d44c whichcorrespondstotheinputvariables of u1d43f.ateachinstructionin u1d43f weknowthevaluemustbethesameasthecorrespondingsmtfunctionapplication.inparticular the outermostfunctionof u1d436correspondsto u1d43f sreturninstruction so since the assignment u1d44ccaused u1d436to evaluate to true u1d43fmust also returntrue.
theorem1 preservationofsatisfiability .
givenansmt constraint u1d436on floating points and bitvectors the newconstraint u1d436 produced by slotis satisfiable ifand only if u1d436is satisfiable.
proof.
let u1d43fbe the llvm function produced by frontend translationof u1d436 u1d43f betheresultofoptimizing u1d43f and u1d436 betheresult of conducting abackendtranslationof u1d43f .
assume u1d436is satisfiable.
then by lemma there exists an input onwhich u1d43freturnstrue.
moreover from section .
we know that u1d43fcontains no undefined behavior.therefore byproperty thereisaninputto u1d43f suchthat u1d43f alsoreturns true.butthen bylemma u1d436 issatisfiable.
assumethat u1d436 issatisfiable.thenbylemma thereexists aninputonwhich u1d43f returnstrue.again weknowthat u1d43fhasno undefined behavior by the lemmas in section .
so by property thereisaninputto u1d43fforwhich u1d43freturnstrue.butthen bylemma u1d436issatisfiable.
theorem 1meansthatthesequenceoftranslation optimization and translation described in this section produces a new constraint thathasthesamesatisfiabilityastheoriginal.moreover because of the construction of the translation slotalso preserves models between u1d436and u1d436 .
that is if u1d436is satisfiable an assignment that satisfies u1d436 directlygivesanassignmentthatsatisfiestheoriginal constraint we just ignore the extra variables introduced by the translation and optimization process.
the theoretical guarantee of theorem 1gives us a practical solver agnostic tool for preprocessing andoptimizing smtconstraints.
evaluation we evaluate slotby applying it to the smt lib benchmark suites forthesubjecttheories .wehighlightourmostimportantresults as follows.
slotincreases the number of solvable formulas at specifiedtimeoutsbyupto24 forbitvector onlybenchmarks forfloating point only benchmarks and for mixed benchmarks allowing the solving of all but one qf bvfp benchmarkwithin 600seconds.
on average slotslows down the smallest benchmarks but speedsupthelargestbenchmarks.geometricmeanspeedups are up to .
for bitvector only benchmarks and over for floating pointbenchmarks.
most ofslot s speedup is the result of just a few simple llvmoptimizationpasseslike instcombine .ourapproach shows which optimizations are missing from smt solvers and allows the effort involved in developing these passes to be instantlyavailable inthe smtcontext.
.
experimentalsetup givenasolver abenchmark andatimeout u1d447 wefollowathreestepprocesstotesttheeffectivenessof slot.first wemeasurehow longittakesforthesolvertoconcludeeither satorunsatforthe benchmark call this u1d447pre.
then we apply slotto the benchmark 1183esec fse december3 san francisco ca usa benjamin mikekandqirun zhang table timeoutimprovementresultsproducedby slot.eachcolumndenotesadifferenttimelimit withthetotalnumber oforiginalunknownformulas total thenumberimproved imp.
andthepercentage .the all rowsdenotethe number of formulas for which all solvers timed out but at least one of the solvers produced a solution after slotwas applied.
benchmark solver totalimp.
totalimp.
totalimp.
totalimp.
totalimp.
qf fpz3 .
.
.
.
.
cvc5 .
.
.
.
.
all .
.
.
.
.
qf bvfpz3 .
.
.
.
.
cvc5 .
.
.
.
.
all .
.
.
.
.
qf bvz3 .
.
.
.
.
cvc5 .
.
.
.
.
boolector .
.
.
.
.
all .
.
.
.
.
producing a new smt constraint we call the time it takes to do this u1d447slot.
finally we measure howlong the solvertakesto solve the optimized benchmark u1d447post.
for a fair comparison we must offset the overhead of running slotagainst the speedup achieved.
thus aformulahasbeenimprovedif u1d447slot u1d447post u1d447pre.thisis theslot onlyresult.
in addition we adopt the portfolio methodology byrunning slotoptimizationinparallelwithasolver a user can simply take whichever result is produced first.
when discussing speedups we report this i.e.
min u1d447pre u1d447slot u1d447post astheportfolioresult.we reportall proportionalspeedupsas geometricmeans reducingtheimpactoflargeoutliers.weanswerthe following researchquestions rq1 howmanymoreformulascanbesolved?
given atimelimit howmanyformulasfrombenchmarksetscan slotconvertfrom unknownto either satorunsat?
rq2 howmuchfastercanformulasbesolved?
whatis the proportional speedup produced by slotfor constraints withlowandhigh originalsolving times?
rq3 which llvm optimization passes contribute?
whichoptimizationstrategiesinllvmaremosteffectiveat simplifyingsmtformulasbeyondthecapabilitiesofexisting solvers?
implementation.
we have implemented slotin about linesofc andmadeitpubliclyavailableongithub.2weusez3 s built inparserforthesmt liblanguageandthestandardllvm c api but provide input and output in the standard smt lib formatforusewithsolversotherthanz3.frontendandbackend translation is carried out as described in section .slothas been testedwithllvmversion16.
.
.
benchmarks.
weuseastestcasesthestandardsolverbenchmarks provided by the smt lib developers for floating point numbers qf fp u1d45b bitvectors qf bv u1d45b and mixed floating point and bitvector constraints qf bvfp u1d45b .
as discussed in section we restrict floating point variables to the standard and bit widths and exclude any constraintswhichcontainvariableroundingmodes.theselimitsare .minimal only benchmarks from qf fp all for variable rounding mode and qf bvfpbenchmarks for unsupported widths and for variable rounding modes are excluded amounting to just0.
ofallmixedandfloating pointbenchmarks.
solvers.
we test with the state of the art general smt solvers z3 andcvc5usedinpriorliterature .forthebitvector only benchmarks we alsotest with boolector a solverspecifically optimizedforbitvectors .slothasbeentestedwithz3version .
.
cvc5version1.
.
andboolector version3.
.
.
testingenvironment.
allexperimentsareperformedonaserver withtwoamdepyc7402cpusand512gbram runningubuntu .
.wetestwithtimeoutsbetween30and600seconds inline with those used in applications for translation validation zero to five minutes and symbolic execution between five and solvercallswithinonehour .finally whenmeasuringspeedups we count solver and slottimeoutsas secondcontributions.
.
rq1 howmanymoreformulascan be solved?
table2shows the number of constraints that are changed from unknown to solved by slotfor each of thethree benchmark sets.
the total column denotes the number of unknown benchmarks at eachtimeout andtheimprovedcolumn imp.
givesthenumberof constraints from those which can be solved after slotis applied.
theresultsinclude slot srunningtime i.e.
wereportabenchmark asimprovedonlyif u1d447post u1d447slot u1d447 .sincesolversaretypically run with a fixed timeout e.g.
during symbolic execution the proportionofconstraintsthatmovefromtimeouttosolvedatfixed valuesof u1d447 represents an improvement for users.
slotis most effective at speeding up constraints with a mix of floating pointandbitvectorvariables.itallowsallbutonemixed benchmarktobesolvedwithin600secondsandreducesthenumber ofunsolvableconstraintsbyaboutone thirdatalltimelimits.
slot renders solvable roughly of timeout floating point constraints and of bitvector benchmarks.
the results are comparable for each of the tested solvers showing that slot s speedup is not solver specific.
1184speedingupsmtsolvingviacompileroptimization esec fse december3 san francisco ca usa most importantly slotnot only improves each solver s performancebut alsodoesbetter thanallsolvers combined.the all rowsintable 2showthenumberofbenchmarksforwhichallofthe solvers timed out and the number which became possible to solve withatleastoneofthesolvers.theimprovementsintheserows showthat slotoutperformsevenaportfolioofexistingsolvers decreasing the number of unknown constraints by as much as for small bitvector benchmarks.
.
rq2 howmuch faster can formulasbe solved?
figure8showsthemeanspeedupsobservedforeachbenchmark set.
values below one indicate a slowdown.
for the smallest benchmarks slotslows down solving often substantially.
however whiletheproportionalslowdownislarge theabsoluteslowdownis typicallysmall andoccursbecausetheoverheadoftranslatingoutweighsthecostofsimplysolvingthebenchmark i.e.
u1d447slot u1d447pre .
forexample onebenchmark3withz3isspedupfrom0.06seconds to .
seconds a speedup but slottakes .
seconds to translate and optimize it creating an overall proportional slowdown.
theeffectreversesformorecomplexconstraints forconstraints that takelonger than 300seconds we improve mean solving time bymorethan .
forfloating point about .
formixed andbetween1.
and2 forbitvectorbenchmarks.theportfoliomethodologyyieldsevengreaterrunningtimeimprovements intherange of3 forqf bvfpand2 forqf bv.
even small constraints below seconds of initial running time see appreciable speedups underallsolverswiththeportfoliomethod.thedifferencebetween theslot only and portfolio results exists because the dramatic speedup of some constraints is offset by a slowing down of others.
.
rq3 which llvm optimization passes contribute?
to understand why slotproduces performance improvements weinvestigatewhichllvmpassescontributemosttotheunderlying results.
the structure of smt constraints means that most llvm optimization passes are irrelevant to slot.
translated smt constraintsdifferfrom mostprograms inthat they perform no memory operations smt variables are directlytranslatedintollvmfunction arguments.
theyhaveonlyonefunction thismaintainstheequivalence definitionsdescribedinsection .
the single function has only one basic block i.e.
there is nobranching .thisisaconsequenceofthenatureofsmt constraints theonly branch likeoperationis ite whichis translatedto an llvm selectinstruction.
themajorityofllvm s58optimizationpassesaffectonlymemory operations are interprocedural or optimize branching .
an additional passes do not apply to translated smt constraints foravarietyofotherreasons theyarearchitecture specific they optimize debug information etc.
.
we also exclude bb vectorize becausevectorizationintroducessubstantialtranslationoverhead while providing no benefit in the smt context.
this leaves eight 3qf bv sage2 bench 7588.smt20 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
original solving time s speedupz3z3 ptf.
cvc5cvc5 ptf.
a qf fp .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
original solving time s speedupz3 z3 ptf.
cvc5 cvc5 ptf.
b qf bvfp .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
original solving time s speedupz3z3 ptf.
cvc5cvc5 ptf.
bltr.bltr.
ptf.
c qf bv figure geometric mean speedup from original constraint to optimized constraint produced by slotfor each benchmark set under z3 cvc5 and boolector for qf bv .
constraints are grouped into ranges of original solving time along thex axis.all measurementsinclude u1d447slot.
1185esec fse december3 san francisco ca usa benjamin mikekandqirun zhang table3 percentageofbenchmarksaffectedbyeachoptimization pass.
pass qf fp qf bvfp qf bv instcombine reassociate gvn sccp dce instsimplify aggressive instcombine adce passesthatare relevant to slot instcombine regularandaggressive instsimplify deadcodeelimination regularandaggressive globalvaluenumbering reassociate andsparseconditionalconstantpropagation sccp .
slotrunsthesepassesinthesameorder inwhichthey are performedduringllvm o3optimization.
table3shows how many benchmarks each optimization pass affects a benchmark is counted for a pass if the pass applicationcausedanychangetothellvmirfunction.agressivedead code elimination did not change any constraints and aggressive instcombine only changed a few this may be because for the smt context theirfeaturesareusuallyhandledbythenon aggressive versions.themosteffectivepassesare instcombine whichchanges almost every constraint reassociate and global value numbering forqf bv .
notably many more passes change bitvector benchmarks than floating point this is a combined result of lower structural complexity in the qf fpandqf bvfpbenchmark sets and greater difficultyinoptimizing floating pointoperations.
table4showsthemeanspeedupobservedforbenchmarkswhich wereandwerenotaffectedbyeachoptimizationpassfor qf bvwith initial timeouts above seconds the results for floating point and mixed benchmarks are comparable but have small sample size.
even passes with negative spread like dce are beneficial under portfoliomethodology.theresultsconfirmthat reassociate and instcombine speed up benchmarks the most followed by global valuenumberingand instsimplify .
theinstcombine pass consists mostly of simple peephole optimizations whichshowsthatsolverperformancecouldbenefitfrom simple theory specific reasoning which is already implemented incompilers.globalvaluenumberingandreassociationalsocontributesubstantially whilesomesolverheuristicsalreadyeliminate common subexpressions more advanced implementations of these algorithms in llvm provide further benefits.
our results show that the extensive effort expended to perfect compiler optimizationsindeedprovidesbenefitsbeyondthoseavailableinexisting smt solvers.
using slot solver users can benefit from that effort withoutdeepknowledge ofsolver implementation.
discussion compileroptimizationvs.smtsimplification.
becausethe purpose of compiler optimizations is to reduce the number of processor instructions some operations which are simpler in llvm may not provide any advantage in smt.
for example bitvector multiplication by u1d45bis equivalent to shifting left by u1d45b however table4 meanspeedupsforbenchmarkswhichareandare not affected by each pass from the qf bvbenchmark set with initialsolvingtimeabove30secondsunderz3.thespreadis the difference in mean speedup between benchmarks which are affected by thepassand those which are not.
pass countspeedup withoutspeedup withspread reassociate .
.
.
instcombine .
.
.
gvn .
.
.
instsimplify .
.
.
sccp .
.
.
dce .
.
.
agg instcombine .
.
.
z3 takes much longer to solve constraints involving shifts.
on one benchmark4for example z3 takes less than a second if doubling is expressed as u1d44e u1d44eor2 u1d44e but does not finish within hours if it isexpressedas shift left byone.
in our implementation of slot we provide a flag to force backend translation to generate multiplication rather than shift where possible.
however there may be more complex analogous examples arising from the fundamentally different purpose of llvm.
so whilecompileroptimizationunlockslogicnotpresentinexisting smtsolvers itactsmoreasasievethanasamagicbullet.running slotand a solver as a portfolio allows solver heuristics and slot each to shine where they perform best each well on some benchmarks butslowingdown onothers.
onlythosebenchmarks that neither can handle slip throughthe sieve.
slotoverhead.
the main driver of the proportional slowdown forsmallconstraintsisthecostofrunning slot.incontrasttoa solver whichjust needs to parse the constraint slotmust parse translate optimize translateagain andthenwrite.
slot sruntime isroughlylinearinthesizeoftheastoftheoriginalconstraint whilesmt solvinghasunpredictable possiblyexponential performance.thismeansthattheproportionof u1d447slot u1d447postcontributed byslotgenerally decreases as u1d447preincreases as shown in table .
the moderateincreasefor qf bvbenchmarks above 300seconds isaresultof slottimeouts thesearecountedas100 contribution intable5.frontendtranslationmakesupabout60 oftherunning time ofslotfor bitvectors and about one third for mixed and floating point constraints while optimization contributes between and .
backend translation takes longer for constraints including floating point numbers about because floating point intrinsicsrequireadditionalstepstobetranslatedbacktosmt lib.
other smt theories.
program analysis tools make use of just afewsmttheories bitvectors floating point andmore recently strings .slotimproves the performance of solvers on thetheoriesrelevanttotheseapplications andweleavetofuture worktheextensionof slot sgeneralmethodtoothertheorieslike realnumbersofuseoutsidesoftwareengineering .whilethe optimization process usedin slotmayprovidebenefitsoutside bitvectors and floating point numbers applying translation and 4qf bv bv term small rw noetzli bv term small rw 1244.smt2 1186speedingupsmtsolvingviacompileroptimization esec fse december3 san francisco ca usa table u1d447slot parenleftbig u1d447slot u1d447post parenrightbig as a percentage for bitvector and floating point benchmarks.
time interval u1d447preusing z3 qf fp qf bv qf bv .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
optimization toother theories would require either a newconception of semantics preservation or substantial under approximation since compiler irs are not expressive enough to model unbounded computation.
the limitations imposed by under approximating mayalsonegate any benefitprovidedbycompileroptimizations.
related work smtconstrainttransformation.
existingworkpresentsanumberofstrategiesforsimplifyingsmtconstraints.dillig etal.
introduce a solver internal constraint simplification algorithm that preservessatisfiability.reynolds etal.
introducesimplifying transformationsforunboundedstringconstraints.transformations ofsmtformulasarealsoemployedtotestsolvers.stringfuzz focuses on generating well formed formulas but also provides some transformations on string constraints.
storm transformsbooleanformulastoperformblack boxtesting.bugariu et al.
introduce constant assignment and term synthesis as transformationsforstringconstraints.sparrow andyinyang expand transformations to real numbers and integers.
the transformationsperformedbythesetoolsaredesignedtotestsolvers our approach uses arelatedmethodto speedupsolving instead.
speedingupsmtsolving.
mostworkonimprovingsmtsolver performance focuses on algorithms to be implemented within a solver.inadditiontoz3 cvc5 andboolector suchworkhastaken the form of new solvers like mathsat bitwuzla and yices .
early work on improving solver performance used symmetry to reduce the constraint solving search space .
more recently niemetz et al.introduced syntax guided quantifier instantiation to speed up solving for quantified constraints .
for particulartheories z3str3 speeds upsolving ofstringconstraints andberzish etal.introducenewmethodsforsolvingconstraints involvingregularexpressions .sadhak combinescvc4with fuzzingtechniquesfor uninterpretedfunctionstoimprove performance.fastsmt usesaneuralnetworktofindbetterwaysto combine existing solver heuristics thereby speeding up solving.
mba solver departsfromsolver specificapproachesbypreprocessing bitvector constraints involving alternating bitwise and arithmeticoperations.ourapproachismostsimilartomba solver asslotusespre processing ratherthansolver internal improvements.
however it differs in that we apply the broad range of optimizations performed by llvm including floating point transformations.
we harness an existing source of optimizations as a blackbox ratherthanhand crafting one for the smtproblem.the constraint code nexus.
work on symbolic execution and translationvalidationhasusedsmtconstraintstorepresentthesemanticsofllvmprograms.klee convertsllvmirprograms into smt formulas that encode symbolic execution constraints many symbolic execution tools are built on the llvm smt core providedbyklee .aliveanditsprogeny generatesmt constraintsfromllvminstructionstoverifytheoptimizationsperformed by the llvm optimizer which lee et al.
expands to llvm s memory model.
lifejacket and alive fp use smt formulastoverifyfloating pointcomputation.vera alsotranslates c code to smt constraints for program verification and faces some engineering challenges analogous to slot.
constraints intheformalrefinement basedb methodhavealsobeentranslated tosmt lib .theseapproachesusesmtsolverstoreason about programs and compilers.
slotdoes the opposite using a compilerforreasoningaboutsmtproblemsandexactlypreserving constraintsemantics instead of solving analysisconstraints.
optimizations outside compilers.
donget al.
apply compileroptimizationsdirectlyto programswhichserve as inputsfor klee.
they find that those optimizations can slow down symbolic execution becausethe optimizercomplicates branching structure.
leo attemptstoremedythislimitationbyusingmachinelearningtochoosewhichoptimizationpassestoapply.
slot sresults differbecauseitoperatesat the levelof constraints notprograms.
this allows slotto work incontexts outsidesymbolic execution andalsoto avoid analysis frustratingbranching optimizations.
declarativeandimperativecode.
existingworkhasexplored conversion from declarative to imperative languages to allow platformflexibility orgiveaccesstogreateroptimizationopportunities .
more recently li and slind convert functions in higher order logic to a simplified intermediate representation.
steno translates declarative queries into imperative code to speed up operations over collections.
slot on the other hand goes beyond translation to an imperative language by adding backend translation and achieves a simplification of the declarative constraints ratherthantransforming themintoexecutablecode.
conclusion this paper has presented a general pre processing tool slot which allows solverusers to apply compiler optimizations to smt constraints as a black box.
slotpractically improves solvers performance on standard benchmarks and increases the number of solvable constraints at fixed time limits.
furthermore the speedup isachievedusingonlythesimplestcompileroptimizationpasses giving solver developers insight into possible improvements to solver tactics.