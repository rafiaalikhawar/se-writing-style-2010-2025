116static executes before analysis for event driven programs rekha pai indian institute of science bengaluru karnataka india rekhapai iisc.ac.inabhishek uppar indian institute of science bengaluru karnataka india abhisheku iisc.ac.inakshatha shenoy akshathabshenoy gmail.com tcs research pune india pranshul kushwaha indian institute of science bengaluru india pranshulk iisc.ac.indeepak d souza indian institute of science bengaluru india deepakd iisc.ac.in abstract theexecutes before relation between tasks is fundamental in the analysis of event driven programs with several downstream applications like race detection and identifying redundant synchronizations.
we present a sound efficient and effective static analysis technique to compute executes before pairs of tasks for a general class of event driven programs.
the analysis is based on a small but comprehensive set of rules evaluated on a novel structure called the task post graph of a program.
we show how to use the executes before information to identify disjoint blocks in event driven programs and further use them to improve the precision of data race detection for these programs.
we have implemented our analysis in the flowdroid framework in a tool called andracer and evaluated it on several android apps bringing out the scalability recall and improved precision of the analyses.
ccs concepts software and its engineering automated static analysis .
keywords static analysis executes before event driven programming race detection asynchronous calls android applications.
acm reference format rekha pai abhishek uppar akshatha shenoy pranshul kushwaha and deepak d souza.
.
static executes before analysis for event driven programs.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse .
acm new york ny usa pages.
nnnnnnn.nnnnnnn permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore association for computing machinery.
acm isbn x xxxx xxxx x yy mm.
.
.
.
introduction the event driven programming edp model has become a popular contemporary paradigm widely used in the development of mobile apps distributed systems graphical user interfaces and web applications among others.
these programs are multi threaded in which each thread has associated with it a queue of program units called tasks that are posted to it by other threads and that it executes sequentially in a fifo manner.
the posting of tasks is typically triggered by events like button clicks completion of background tasks etc.
while edp is an efficient paradigm control flow in these programs can be complex and non standard and pose a challenge to the developer to guard against common concurrency issues like data races and atomicity violations.
the non standard concurrency model also makes it challenging to carry out static analysis in a sound precise and efficient manner.
a key notion that has proved useful in analyzing edp programs is the executes before relation on the tasks of a program.
a task aexecutes before another task bin an edp program pif in every execution of p every instance ofacompletes execution before any instance of bbegins its execution.
versions of the executes before relation derived from a static happens before relation on a partial unrolling of the program in have been used to detect eventraces where two conflicting accesses may not be ordered and use after free races.
another use of the executes before relation which we show in this paper is in a disjoint block analysis also known as a not may happen in parallel or not mhp analysis for edp programs.
disjoint blocks are blocks of code in two tasks which are guaranteed never to overlap or happen in parallel in any execution of the program much like blocks of code protected by the same lock.
disjoint block information is fundamental for data race detection high level race detection for atomicity violations and for identifying redundant synchronizations.
a final promising use of the executes before relation is in carrying out efficient data flow analysis for edp programs.
one can imagine using executes before information to construct a combined controlflow graph of the program and analyze it using techniques like .
it is important for any analysis that computes the executesbefore relation to be sound in that it never reports that 174esec fse november singapore r. pai et al.
232taskaexecutes before task bunless aactually does execute before b particularly when one is interested in race detection for safety critical applications or eliminating redundant synchronizations or data flow analysis.
unforunately none of the existing techniques we are aware of are sound.
in particular the works in consider a finite unrolling of the program wherein a task may have multiple copies corresponding to different contexts which task thread they were posted by etc and compute a happens before ordering on the start end invoke nodes in these copies using standard causal rules.
they then derive an executes before relation on tasks by declaring ato execute before bif the end nodes of all copies of ahappen before the start nodes of all copies of b. however as we illustrate later this is easily seen to be unsound for edp programs in general.
in this paper we propose a sound efficient and fairly precise way of identifying executes before pairs in an edp program.
we give a small set of conditions and inference rules that can be statically checked on a structure called a task post graph induced by the program which are sufficient to guarantee that one task executes before another.
we have implemented and evaluated the analysis on several android apps and observed that it has good recall of manually identified executes before pairs in these apps.
in fact we compare favourably with ercatcher one of the state of the art event race detection tools in terms of recall of eb pairs retrieved on their specially created set of microbenchmarks .
in a couple of applications downstream we show how to use the executes before information in addition to lock information to identify pairs of disjoint blocks in edp programs and apply this to statically detect data races and check for redundant synchronizations in android apps.
we show the value of the executes before based disjoint block rules by observing that they are solely responsible for of the conflicting accesses eliminated which techniques like would miss.
overview in this section we illustrate the main ideas of the paper with an example event driven program in the form of an android app adapted from shown in fig.
.
the figure shows an android activity myactivity that has a field pand four tasks or program units oncreate a b and c. when the application begins execution the android runtime creates themain thread with a fifo queue attached to it.
it then posts or enqueues the task oncreate which is an android lifecycle callback to the main thread.
the main thread begins by dequeing the only task in its queue oncreate and executing it.
tasks in an app can post other tasks onto threads using handlers.
the oncreate task creates a handler formain line using which it posts tasks aand b in that order onto the main thread s queue lines .
the main thread upon completion of oncreate proceeds with dequeing and executing task awhich initializes the value of p line .
the main thread then dequeues and executes task b. .
class myactivity extends activity .
long p .
runnable a new runnable .
public void run p 0l .
.
runnable b new runnable .
public void run .
long y p .
handlerthread child new handlerthread .
child .
start .
handler hb new handler child .
getlooper .
hb.
post c .
long z p .
.
.
runnable c new runnable .
public void run p .
.
public void oncreate .
handler handler new handler .
handler .
post a .
handler .
post b .
.
on c1 c2c2 c1c1 ii create createon i a b childmain mainmain ca b cmain childmainmain figure top an example android app i its tpg and ii its tpg with the eb relation superimposed.
this task creates a child thread with a handler lines and posts task cto it line .
the child thread dequeues and executes task c which writes to variable p line .
we say that a task x executes before a task yin an edp program pif whenever we have an execution of pwith instances of tasks xandy every instance of xmust complete before any instance of ybegins execution.
in this sense in the given program we can see that oncreate executes before both aand b. this is because firstly each task has a single instance.
secondly oncreate must execute for aandbto be posted and since they are posted to the same thread main tasks aandbmust wait for oncreate to finish executing.
we further observe that aexecutes before bsince it is posted by oncreate tomain before bis.
finally both oncreate and amust execute before c even though they are posted to different threads since both oncreate and aexecute before bwhich posts c. the five executes before pairs are thus oncreate a oncreate b oncreate c a b and a c .
we now describe how we statically identify such executesbefore pairs.
we propose a small set of conditions c1 c2 290executes before analysis esec fse november singapore 348and c3 described in sec.
each of which allows us to conclude that a task executes before another.
the conditions are phrased on a structure we call a task post graph tpg which has the set of tasks as its nodes and an edge from node xtoylabelled thwhenever task xcontains a post of task yto thread th.
fig.
i shows the tpg corresponding to the example program.
the small arc arrow across the edges corresponding to posts of aand bfrom oncreate indicates that all posts of atake place before those of binoncreate .
the dashed edges in fig.
ii show the executes before pairs inferred using the rules with the labels indicating the rule used.
for example we infer that oncreate executes before c by rule c1 see fig.
c1 b which essentially says that if all paths from the initial task to cpass through oncreate and all these paths have at least one post to the thread to which oncreate is posted then oncreate executes before c. we note that all five executes before pairs mentioned in the previous paragraph are inferable by our rules.
we note that if we had modified the above program with a loop around the post of tasks aandbin lines then the post of ais no longer ordered before the post of b and our rules would only allow us to infer that oncreate executesbefore each of tasks a b and c. however the approach in unsoundly infers that aexecutes before b. one of the uses of the executes before information is in determining in a sufficient way when two blocks of code or two tasks themselves are disjoint in that they can never happen in parallel i.e.
overlap in time during an execution .
we give a couple of such rules in sec.
.
the first of these rules says that if one task executes before another they are disjoint.
this lets us infer that oncreate is disjoint with tasks a b and c and that ais disjoint with both band c. our second rule says that if it is the case that a parent xof task y executes before any other parent of ythen task xis the first to post y and hence the block of statements before the post ofyin task xare disjoint with the whole of y. in the above example this lets us infer that the block of code in task bup to the post of c lines is disjoint from the whole of c. the disjoint block information can be used to detect data races in a sound manner.
to do this we first collect conflicting accesses that may run on different threads.
in the example program these are the pairs of statements and .
whenever a pair of accesses is covered by a pair of disjoint blocks we can eliminate it as non racy since they can never happen in parallel .
the access pair is covered by the pair of disjoint tasks aand c and hence can be eliminated.
similarly the pair of statements is covered by the pair of blocks comprising the first half of b till the post of c and the whole of c and hence can also be eliminated.
we note that the approach in will fail to eliminate the access as non racy.
finally we report as a potential race since we were unable to eliminate it using any of our rules.
we note that this pair of accesses actually constitutes a harmful race.
event driven programs an event driven program is essentially a multi threaded program with dynamically created threads.
it is organized as a set of program units called tasks which access a set table edp program commands cmd v l statement description t create create a new thread and store tid in t. stopth stop executing the current thread.
join t wait till thread tfinishes.
post t a enqueue task aon thread t s queue.
skip do nothing.
x e assign the value of etox.
assume b enabled if bevaluates to true skips.
lock l block till lis available then take it.
unlock l releases lock l. of shared global variables.
initially there is only a main thread which starts off by executing a designated main task.
among other things a task can create new threads and post tasks to other threads.
each thread conceptually maintains a fifo queue of tasks that have been posted to it and repeatedly dequeues and executes the task at the head of its queue.
the table alongside shows the set of commands that an event driven program can use over a set of variables vand locks l. we denote this set of commands by cmd v l. more formally an event driven program pis a tuple v l t where vis a finite set of global variables lis a finite set of locks and tis a finite set of tasks.
every task a tis represented as a control flow graph cfg ga loca enta exta insta where locais the finite set of locations of a enta exta locaare the entry and exit locations of arespectively and insta loca cmd v l locais the set of instructions of a. we use the notation instp s a tinstato denote the set of all instructions in p and task for an instruction ininstato denote the task ain whose cfg it occurs.
we assume a designated main task called mint which begins the program s execution on the main thread.
we also assume anidletask which does no useful work and executes in a thread whenever there are no other tasks to run on it.
we denote the class of event driven programs by edp and refer to such programs as edp programs .
fig.
shows the textual version of an example edp program with tasks m count andprod.
before we define the semantics of an edp program some notation will be useful.
we use zto denote the set of integers.
we denote the set of finite sequences or words over a finite set of symbols sbys and represent the empty sequence by .
for a function f a b a aandb b we usef to denote the function g a bgiven by g x f x for x aandg x botherwise.
if c a we usef cto denote the restriction of fto the domain c. for a logical condition bover a set of variables vwe denote by the set of valuations that satisfy b. for an arithmetic expression eover variables v and a valuation forv we denote by the value obtained by evaluating ein .
406esec fse november singapore r. pai et al.
464some general notions for rooted labelled directed graphs will be useful going forward.
we represent such a graph by a tuple g v r e where vis the set of nodes of the graph r vis a designated root node is the set of edge labels and e v vis the set of labelled directed edges of the graph.
let g v r e be a labelled directed graph.
a path from node utovis a finite possibly empty sequence of connected edges in the graph starting at uand ending at v. the length of a path is the number of edges in the path.
given a label we define the length of a path ingto be the number of labelled edges in .
we say a node mdominates another node ning denoted dom m n if every path from the root node rtonpasses through m. letp v l t be an edp program.
we define the semantics of pas a labelled transition system sp s s0 where sis the set of states s0 sis the initial state and is the transition relation as described below.
a state s sis a tuple t mt mq ml where tis a set of active threads that are created but not terminated mt t t loc associates with each active thread a task and a location in the task representing its current location.
thus if mt th t l then we require that l loct.
mq t t associates with each thread a queue of tasks represented as a sequence of tasks ml l tis a partial map which associates with each lock the thread if any that has acquired the lock and v zis a valuation for variables representing their current value.
the initial state sinis main main7 m entm main7 undef x. .
the transition relation describes the possible transitions between states and captures the semantics of the program.
lets t mt mq ml and s t m t m q m l be two states and l c l be an instruction in a task a with l exta.
then we have s s iff there exists a thread tintsuch that mt t a l and either cis the command skip t t m t mt m q mq m l ml and or cis the command assume b t t m t mt m q mq m l ml and or cis the command x e t t m t mt t7 a l m q mq m l ml and or cis the command stopth t t t m t mt t m q mq t m l ml and or cis the command th create t t tid for some tid t m t mt tid7 idle entidle m q mq tid7 m l ml and or cis the command join th th t t t m t mt m q mq m l ml and ortask m task count task prod .
n .
n n x .
x x .
x .
x .
post child count .
post main count .
child create .
post child prod .
x x .
post main count main count count countcountx x n n x x child countprodprod count x n n x x n n x x x child create post main count x n post child prod post main count post child count m figure example edp program p1and one of its executions cis the command post th b t th mt t t where t idle t t m t mt m q mq m l ml and or cis the command post th b t th mq t mt t idle t t m t mt t7 a l m q mq m l ml and or cis the command lock k ml k is undefined t t m t mt m q mq m l ml and or cis the command unlock k ml k t t t m t mt m q mq m l ml k t and .
for the case when l exta the rules are similar except that the thread tnow switches to b entb when t s queue is non empty and bis the task at the head of t s queue when t s queue is empty twill now point to idle entidle .
anexecution of an event driven program pis a finite sequence of transitions 1 .
.
.
n n ofsp such that there exists a sequence of states s0 .
.
.
s nofsp with each iof the form si i si for some i and s0 sin.
the sequence of instructions executed in is 1 .
.
.
n. 522executes before analysis esec fse november singapore 580it is convenient to visualize an execution of an edp program as a sequence of instructions or statements with time going downwards and a column for each thread as shown in fig.
.
note that there may be multiple instances of a task that execute in the same or different threads in an execution.
in the example execution of fig.
the task count has three instances two in the main thread and one in the child thread.
however each instance except possibly the last one on a thread runs to completion in that once the instance is executing on a thread it is not switched out from the thread until it completes by reaching its exit location.
if we project an execution to a single thread thit will look like a sequence of initial and complete execution paths except possibly for the last one which may only be initial through the cfgs of the different tasks.
we close this section with a notion related to task cfgs.
letp v l t be an edp program and let abe a task int.
let l c l and m c m be instructions in insta.
we say instruction l c l may follow instruction if there is a path from m tolinga.
task post graph in this section we introduce the task post graph tpg structure for an event driven program.
this structure will help us in identifying executes before pairs in an edp program in a structural manner.
the tpg of an edp program pcontains information about task apossibly posting task bto a thread th represented by an edge in the graph from atoblabelled th.
note however that tasks may be posted to concrete threads created dynamically during the execution of p. to use a static label for the post edges we make use of the notion of abstract threads.
we associate all the threads created at a particular create statement in the program with an abstract thread corresponding to that statement.
for convenience we assume that in an edp program a thread variable is assigned at only one statement and we use the thread variable as the name of the abstract thread associated with that create statement.
we note that a create statement in pmay be executed multiple times during an execution of p as it may be in a loop in a task or it may be in a task that is posted multiple times during the execution of p. we say an abstract thread is unique if it corresponds to exactly one concrete thread.
for convenience we call such an abstract thread a unique thread .
to illustrate these notions consider the example program p2of fig.
.
there are four abstract threads child1 child2 child3 and the implicitly created thread main .
the abstract threads main andchild1 are unique.
the abstract threads child2 andchild3 due to lines and respectively are not unique multiple concrete threads corresponding to child2 are created in a loop while child3 is created in a task namely a that is posted multiple times lines and .
letp v l t be an edp program.
the task post graph tpg induced by p denoted tpg p is a labelled directed graph n e where n t s is the set of vertices oftask m .
child1 create .
post child1 a .
post main b .
while .
child2 create task a .
child3 create task b post main a m a bchild main mains main figure illustrating abstract threads prog p2and its tpg the graph corresponding to the tasks of pand a dummy initial vertex s and eis the set of labelled edges of the form a th b such that task acontains a post of task bto the abstract thread thinp.
we also add the edge s main m ineto denote the implicit posting of the main task mto the main thread.
the tpg for the program p2in fig.
is shown to the right in fig.
.
to avoid clutter we henceforth leave out the dummy node sfrom the diagrammatic representation of the tpg.
next we define a few notions related to the task post graph that will be useful in the sequel.
the instance post tree corresponding to an execution of an edp program depicts the different task instances that were created during the execution and the order in which one instance posted other task instances to abstract threads.
more formally letp v l t be an edp program and let be an execution of p. the instance post tree corresponding to denoted ipt is a rooted directed ordered tree with nodes corresponding to task instances in the first instance of mas the root and labelled edges i th j whenever task instance count prodmmain countmain mainchild child countiposts task instance jto the abstract thread th.
moreover for each instance ithe children of iare ordered according to the order in which they were posted in i. the figure alongside shows the instance post tree corresponding to the execution of fig.
with the children of a node being ordered from left to right the blue arc also indicates this .
we note that every path in the instance post tree of an execution ofp is also a path in tpg p essentially the tree ipt embeds homomorphically into tpg p .
we say that an edge from task ato task blabelled thin tpg pis aunique post edge if there is exactly one post th b statement in a and that statement is not in a loop.
it is easy to see that if a th b is a unique post edge then any instance of acan post at most one instance of bto thread th.
we say that a task ainpisunique if every execution of pcontains at most one instance of a. a sufficient condition ontpg pthat ensures that task ais unique is that there should be a unique path from mtoa and all edges along this path should be unique post edges in the sequel we will 638esec fse november singapore r. pai et al.
696refer to this condition as a unique path of unique posts .
to see that the condition is indeed sufficient suppose we had two instances of ain an execution ofp and consider the instance post tree ipt of .
consider the two paths and from mto the two instances of ain this tree and let xbe the lowest common ancestor of the two instances of aalong these paths.
let xbe an instance of task b. let yandy be the two children of xalong the paths and respectively.
ifyandy are instances of different tasks then we do not have a unique path from mtoaintpg p. ifyandy are instances of the same task say c then the b th c edge in tpg pcannot be a unique post edge.
finally let and be two paths in the tpg of a program p. we say isordered before if 1 x th y 2and 1 x th z 2for some paths 1 2 and threads thandth and tasks x yandz such that y z 2and have no node in common and each post of task ydominates all posts of task zin the cfg of task x. executes before letpbe an edp program and let aandcbe tasks in p. we say task aexecutes before taskcinp if in every execution ofp every instance of acompletes execution before any instance of cbegins execution in .
more precisely suppose contains the entry instruction of an instance of cat position jand the entry instruction of an instance of aat position i then i j and there exists a position kwith i k j such that the instance of aexecutes its exit instruction at position k. we describe several sufficient conditions on an edp program and its tpg which will ensure that a task executes before another.
let p v l t be an edp program and aandctwo distinct tasks in t. each condition on tpg p below aims to ensure that aexecutes before c. figs.
and illustrate these conditions.
in the figures an arc arrow across path and indicates that is ordered before .
c1 this condition is illustrated in fig.
c1 a .
there is a task xwhich is posted to a unique thread th and a number d such that there is a unique path of unique posts from mtox all paths from mtoaandmtocpass through x each path from xtoais labelled thand has length at most d and every path from xtochasth length at least d .
fig.
c1 b shows the special case of this condition when d and a x. c2 this condition is illustrated in fig.
c2 .
there is a taskx a unique thread th and a number d such that there is a unique path of unique posts from mtox all paths from mtoaandmtocpass through x there is a unique path of unique posts of length d from xtoa with all edges labelled th and for every path from xtoc is ordered after the path from xtoa and the th length of is at least d. c3 this condition is illustrated in fig.
c3 .
there is a taskxand a unique thread thsuch that there is a unique path of unique posts from mtox xposts task aonto thvia a unique post and is the only task to post a for every child bofxother than a the path from m toashould be ordered before a path from mtob all paths from mtocpass through x and task cis always posted to the thread th.
fig.
shows the tpgs of some edp programs that satisfy the conditions c1 c3 respectively.
the edge label indicates that the thread does not matter.
in each case the taskacan be seen to execute before task c. next we define some ways of inferring executes before pairs from an initial set of such pairs in p. i1 if a task aexecutes before every parent dof a task cin tpg p then amust execute before c. see fig.
i1 .
i2 if tasks aandcare such that there is a unique path of unique posts from mtoaintpg p ais posted to a unique thread th aposts ctoth and aexecutes before every parent of cthat is different from a then amust execute before c. see fig.
i2 .
i3 if tasks a d and care such that aexecutes before d dexecutes before c and ddominates cintpg p then amust execute before c. see fig.
i3 .
we can now give a simple saturation algorithm alg.
to compute a sound set of executes before pairs.
algorithm compute eb pairs data edp program p result setebof executes before pairs eb add pairs a c toebbased on conditions c1 c3 while a new pair a c that can be inferred by rules i1 i3 do eb eb a c end return eb theorem .
.
the set ebreturned by alg.
for an edp program pis sound in that if a c ebthen aexecutes before cinp.
proof.
before we give a detailed proof as an illustration of the argument we argue why amust execute before cin a program pwith a tpg shown in fig.
c1 a .
assuming thatthis a unique thread and mmakes a unique post of xto th the program psatisfies condition c1 .
now consider an execution ofpwhich contains an instance naofaand an instance ncofc.
we will argue that the intance namust finish execution before nccan begin execution.
we note that there must be a unique instance of xin saynx.
now namay have been posted by nxdirectly or by an instance ndof task dthat was posted by nx.
let us consider the more interesting latter case.
the instance ncmust have been posted by an instance 754executes before analysis esec fse november singapore c3 unique posts postsunique unique postsunique posts c1 b c1 a c2 main m a cthx th thb a cth len dlendthxmain m th th len 1main m a cth th len d cathxmain m th len d figure illustrating sufficient conditions c1 c3 on the tpg of a program for ato execute before c. c2 c3 c1 a mmain dth e f ath cth thxth dth ce f gathth th ththmain m mmain ath b c th d figure example tpgs of programs satisfying conditions c1 c3 .
in each case task aexecutes before c. i1 eb eb eb i2 eb eb ebunique path of unique posts eb eb i3 eb a d e c a d e c thm thad c figure illustrating executes before inference rules i1 i2 and i3 .
dark edges are inferred by the rules.ngofg which in turn was posted by an instance nfoff which in turn was posted by an instance neofe.
the basic observation is that nd which is at a th distance of from x must be posted to thbefore ng which is a th distance of from x .
this holds regardless of whether nxposted nd before neor not.
it then follows that nawill be posted to th byndbefore ngexecutes on th and hence namust complete execution before nccan begin execution.
it is sufficient to argue that a the base rules c1 c3 are sound and that b the inference rules i1 i3 are sound as well.
to see the soundness of rule c1 let aandcbe tasks in program psatisfying the conditions of the rule and consider an execution ofpcontaining an instance of aand an instance of c. consider the instance post tree ipt of and let naandncbe the nodes corresponding to the above instances of aandcrespectively.
let and be the two initial paths in the tree to naandncrespectively.
we note that and must correspond to initial paths in tpg p. by the conditions of c1 the two paths in ipt must appear as shown in fig.
7a except possibly for the left to right ordering .
here nxis posted to th nyis the lowest common ancestor of naandncin the tree and all tasks from nxto nyare posted onto th.
let ny n0 n1 .
.
.
n k na k be the task instances in the path from nytona all these task instances being posted to th .
then there must exist a subsequence of task instances m1 .
.
.
m k 1in the path from nytonc excluding ny such that each miis posted to th.
the dashed contours in the figure indicate the same th level from ny ornx .
it is clear that n0 nymust be posted to thbefore m1is.
we can now argue that n1must be posted to thbefore m2is.
either n1is posted to thbefore m1is or m1 is posted before n1is.
in the former case it is clear that n1 would be posted before m2.
in the latter case m1must wait fornyto complete its execution on thbefore it can post m2 by when nywould have posted n1toth.
thus in both cases n1is posted to thbefore m2is.
it now follows that n2must be 870esec fse november singapore r. pai et al.
m nx ny n1 n2m1 m2 mknk nath th th thth th thth ncth mk a inst.
post tree for c1 nx ny n1 n2m1 m2 mknk nath th th thth thm ncth b inst.
post tree for c2 i ii m nx nanxm th nanb ncncth thth c inst.
post tree for c3 figure illustrating the soundness argument for c1 c2 and c3 posted to thbefore m3is and so on till na nkis posted to thbefore mk 1is.
since they are posted to the same unique thread th namust finish execution before mk 1can begin execution.
since nccan be posted only after mk 1begins execution it follows that the instance namust complete its execution before the instance of ncbegins execution.
this proves that amust execute before cinp.
for the soundness of c2 consider tasks aandcsatisfying the conditions of c2 and consider an execution containing an instance of aandc.
once again the instance post tree of must look like the one shown in fig.
7b.
by the ordering condition the post of the task corresponding to n1tothin the instance nyofymust have taken place before the post of the task say z that leads to the post of m1.
thus n1is in the queue of thbefore the instance of zis posted and therefore before m1is eventually posted to th.
continuing this argument we have that nk nais posted to thbefore mkis and hence nacompletes its execution on thbefore mk begins and hence also before ncbegins.
this proves that a executes before c. for the soundness of c3 consider an execution of the program pcontaining instances of aandc.
using the ipt we show every instance of acompletes execution before an instance of ccan even start.
let naandncbe the nodes in the ipt corresponding to the instances of aandcrespectively.
inipt due to constraints and of rule c3 there is exactly one instance of the tasks in the path from mtoaintpg p. thus nais the only instance of task awhile task ccan have multiple instances ncbeing one of them.
further from constraints and in c3 node nccan be i a descendant of nainipt or ii a descendant of nb inipt where bis a sibling of aintpg p as in fig.
7c .
case i it is easy to see that the instance nais posted even before ncis posted.
since they are posted to the same unique thread th due to constraints and of c3 instance nacompletes execution even before nccan start.
case ii instance ncis posted only after nbis posted.
since the path from task mto task ais ordered before any path from mto b due to constraint instance nxposts naeven before it posts nb.
since naandncare posted to the same unique thread th naappears in th s queue even before nc.
thus instance nacompletes execution before nccan even start.
in either case instance naof task acompletes execution before an instance ncof task c. thus aexecutes before c. coming now to the soundness of the inference rules i1 i3 .
consider rule i1 and suppose tasks aandcsatisfy the conditions of the rule in p. consider an execution with an instance of aandc.
now the instance of cmust have been posted by one of the parents dofc.
but aexecutes before d so the instance of amust have completed before the instance ofdbegan and hence before the instance of cbegan.
for the case of i2 suppose tasks aandcsatisfy the conditions of rule i2 and consider an execution with an instance ofnaofaandncofc.
ifncwas posted by a task different 986executes before analysis esec fse november singapore 1044from a then similar to the previous argument nawould execute before nc.
ifncwas posted by an instance of task a then since ahas at most one instance by the conditions of i2 ncmust have been posted by natoth.
since this a unique thread nccan only execute once nahas finished.
this completes the soundness argument for i2 .
the soundness of rule i3 is fairly immediate.
the only thing to note is that the definition of executes before is nottransitive.
in particular if we know aexecutes before danddexecutes before c we cannot conclude that aexecutes before c. this is because we may have an execution with instances of aandc butnoinstance of d. however note that if ddominates cin the tpg of p as the rule requires then we must have an instance of dwhenever we have one of c since an instance of dhas to execute to transitively post an instance of c. the correctness now follows easily.
data races and mhp let us fix an edp program p v l t .
consider two tasks aandbint aandbcould be the same task and two non empty paths and ingaandgbrespectively.
we say and may happen in parallel inpif there is an execution ofp and two instances of aandbin in which the execution follows paths and inaandbrespectively such that the paths and interleave that is either begins after has begun but not yet ended or vice versa .
we now define when two statements s1ands2 corresponding say to instructions 1 l1 c1 l and 2 l2 c2 l in tasks aandbinprespectively may happen in parallel.
consider the program p obtained from pby enclosing the statements s1ands2inskip statements.
more formally we obtain p by replacing the instruction 1by the sequence of instructions l1 skip m1 m1 c1 m and m skip l where m1andm 1are new locations in loca and similarly for 2. let 1be the path l1skip m1c1 m 1skip l 1inga and similarly 2ingb .
we now say s1ands2may happen in parallel inp if the paths 1and 2may happen in parallel in the program p .
in the example program of fig.
statements in lines and may happen in parallel whereas statements in lines and cannot happen in parallel.
two statements are called conflicting accesses if they are read write accesses to the same variable at least one of them is a write and the two statements may run on different threads.
we say two statements s1ands2inpare involved in adata race or are simply racy if they are conflicting accesses that may happen in parallel.
thus the statements and in the example program of fig.
are racy but statements and are not.
similarly statement races with itself while statement does not.
finally we define what it means for a block of code to happen in parallel with another.
a block of code in pis specified by a pair l x where for some task ainp lis a location in locaandx locais a subset of locations reachable from l. an initial path in a block b l x of a taskainp is a non empty path in gathat begins at land stays within the set of locations x except possibly for thelast location in the path.
we say a statement s m c m inpbelongs to block b l x ifmbelongs to the set x. we say two blocks b1andb2ofpmay happen in parallel if there are two initial paths 1inb1and 2inb2 which may happen in parallel with each other.
otherwise we say b1andb2aredisjoint .
in the example program of fig.
b1 and b2 are blocks in tasks mand prod respectively.
the two blocks can be seen to be disjoint.
we observe that if s1ands2are statements in two blocks b1andb2respectively in p and b1andb2are disjoint with each other then it follows that s1ands2cannot happen in parallel.
we now present four rules to identify pairs of disjoint blocks in an edp program.
the first two are based on the executes before order in the program while the last two based on fork join and locks are more standard.
let us fix an edp program p v l t and let aandbbe two tasks in t. the rules below tell us when a or a part of it is disjoint from b. rule first to post if ais a unique task aposts b and aexecutes before every other parent dofb then the blocks enta x and bare disjoint where x loca n loca nmay follow a post of bina .
rule executes before if aexecutes before b then aandbare disjoint.
rule join if ahas a join th statement such that th corresponds to a unique abstract thread and bis posted only to th then the block bcomprising statements dominated by the join statement in a is disjoint with the task b. rule lock if b1andb2are blocks enclosed in lock l unlock l statements for some lock l then b1 andb2are disjoint.
theorem .
.
the rules are sound in that if any edp program psatisfies the premise of one of the rules the identified blocks are indeed disjoint in p. proof.
the soundness of rules and are standard.
to see that rule is sound suppose tasks aandbinpsatisfy the conditions of the rule.
consider an execution ofp in which there is an instance of task aand an instance of task b. now there can only be one instance of ain since ais a unique task.
if the instance of bwas posted by some other parent cofb then since aexecutes before c it must have finished execution before bbegins and hence must be non overlapping with b. on the other hand if the instance ofbwas posted by the unique instance of a then clearly no part of the statements in the block enta x can overlap with statements of b. this completes the soundness of rule .
the soundness of rule executes before is immediate.
alg.
shows our algorithm to detect races in edp programs.
we say that the pair of blocks b b covers a pair of statements s s in a program p if either sbelongs to b ands belongs to b or vice versa.
1102esec fse november singapore r. pai et al.
1160algorithm race detection data edp program p result setprof potential races find the set caof conflicting accesses in p pr ca foreach conflicting access pair s1 s2 in pr do ifthere are disjoint blocks b1andb2which cover s1 s2 then pr pr s1 s2 s1 s2 is non racy end end return pr as another application of our eb based disjoint block rules consider the problem of identifying redundant synchronization blocks in an edp prgram.
we say that a block of code enclosed in lock unlock statements is a redundant synchronization if the block does not contain a statement that may happen in parallel with a conflicting access.
synchronization blocks usually have significant performance overheads and locks that are provably redundant can safely be eliminated from the program.
we can compute a conservative set of redundant synchronizations as follows.
we first find the set of conflicting accesses in the program and eliminate all pairs covered by the disjoint block rules i.e.
all rules except the lock rule .
let the resulting set of conflicting accesses be s. now for each synchronization block bwe check whether bcontains an access that is part of a pair in s if not we saybis redundant.
android apps as edp programs an android application or app is built using one or more of android s four core components activity service content provider and broadcast receiver .
an activity is a component that provides a ui with which users can interact.
an activity undergoes a sequence of state transitions that permits it to interact with the user.
these state transitions are triggered by lifecycle callbacks such as oncreate onstart onresume onpause onstop onrestart andondestroy .
these callbacks run on the main thread.
the activitymanagerservice a part of the android system controls the order in which the activity callbacks are executed.
android also provides ways for executing user events ui tasks and background operations in threads other than the main thread.
in this section we model the activity component of android and the background processing.
modeling an activity.
an android application can be viewed as an event driven program with the activity callbacks running as tasks on the main thread.
the systask running on the system thread models activitymanagerservice and it controls the order of callbacks running on the main thread.
a task in our model corresponds to the callbacks listed above.systask .
post main oncreate .
l1 post main onstart .
l2 post main onresume .
while .
post main onclick .
post main onpause .
if .
goto l2 .
else .
post main onstop .
if .
post main onrestart .
goto l1 .
.
else .
post main ondestroy .
figure systask as an edp task ui tasks like onclick are modeled as edp tasks that execute on the main thread.
these tasks are enabled for execution after the onresume task.
fig.
shows the systask as an edp task that posts the lifecycle tasks and an onclick ui task in the expected order.
android provides the asynctask feature that allows to run instructions in the background and report results from the background thread to the main thread.
we model an asynctask as having three tasks namely onprogressupdate and onpostexecute .
the task which does background processing runs on a new thread while onprogressupdate which passes results of the background processing runs on the main thread andonpostexecute which does clean up operations after the background processing finishes runs on the main thread.
implementation and evaluation in this section we evaluate the recall of eb conditions in sec.
in retrieving executes before pairs.
we also assess the usefulness of these conditions in downstream applications of race detection and redundant synchronization detection.
we present the tool andracer that statically analyzes android apps to compute eb pairs data races and redundant synchronizations.
we first describe the tool implementation followed evaluation on several android apps.
.
tool implementation andracer takes an application package as a .apk file as input and outputs a set of pairs of accesses that may be involved in a data race.
a schematic representation of the tool is shown in fig.
.
the tool has four components tpg builder that constructs the tpg of the input app eb generator that computes pairs of tasks that are executesbefore related ca generator that computes the list of conflicting access pairs and rule checker which applies the disjoint block rules to eliminate non racy conflicting access pairs and to list redundant synchronizations.
tpg builder.
the tpg builder relies on having an entry method for the application.
the tool uses the flowdroid 1218executes before analysis esec fse november singapore ca listeb tpgtpg buildereb generator rule checker ca generatorpot.races syncred.and.
appandracer figure schematic of andracer tool framework to translate an application to one having an entry class dummymain with an entry method dummymain .
the dummymain method posts all the life cycle callbacks of the android components.
we assume a single run time instance for a component.
the tpg builder first finds the nodes in the tpg which essentially are the tasks.
it then collects the callbacks using flowdroid .
the post statement determines an edge in the tpg from the task that has the statement to the task being posted.
the tpg builder recognizes methods like handler.post thread.start timer.schedule and asynctask.execute as post statements.
each edge has attributes like the abstract thread for the post uniqueness of the abstract thread uniqueness of the post and the order of the post.
a post is determined to be non unique if it appears inside a loop or in different locations.
finally the order of posts made by a task is determined by the order it which it appears in the cfg of the task.
eb generator.
this component implements alg.
to soundly compute the executes before relation between all possible callback pairs in a given app.
ca generator.
the ca generator collects the set of accesses to shared variables and marks whether they are read or write.
for each callback pair that may be posted to different threads which is inferred from the labels of incoming edges to the callbacks in the tpg and for each pair of shared accesses in the callback pair the ca generator checks whether the pair of accesses conflict.
if so the access pair is marked as conflicting.
the tool uses the points to analysis computed by the context and flow insensitive spark framework to decide on the access pairs.
rule checker.
given a list of conflicting access pairs in the app and the tpg for the app this component applies the disjoint block rules described in sec.
to eliminate conflicting access pairs that cannot happen in parallel.
this component also applies the procedure described in sec.
to compute redundant synchronization blocks.
.
evaluation benchmarks.
we ran our tool on the latest versions of real world android applications to demonstrate the usefulness of the executes before rules.
the first part of table summarizes the features of the applications which are taken from various domains like finance health security and education.
only applications with multiple threads were selected for the experiments and the column thds shows the number ofthreads in each application and the tasks column gives the number of tasks.
results.
we conducted the experiments on an intel xeon w cpu with 256gb ram running ubuntu .
lts.
the second part of table shows the recall of the executesbefore eb conditions in computing executes before pairs when we ran andracer on the apps.
the ar eb column gives the number of executes before pairs computed by the tool while the man eb column gives the number of executes before pairs found on manual inspection.
the manual inspection was done on a subset of android components mostly activities.
the recall column gives the fraction of the manual pairs identified by the tool manual pairs identified by the tool divided by total manual pairs as a percentage.
the time column gives the time taken in seconds by the tool for the executes before analysis.
our tool performed well with an average recall of demonstrating that our executes before conditions are fairly comprehensive in identifying executes before pairs in practice.
in fact most of the missed eb pairs were either due to the imprecise flow sensitive analysis of spark or callbacks missed byflowdroid rather than the inadequacy of the rules.
table benchmark features and recall features recall app kloc thds tasks ar eb man eb recall time s childmon .
.
.
aard2 .
.
.
dns66 .
.
.
charreco .
.
.
a2dpvol .
.
.
asetu .
.
.
kpdroid .
.
.
openapk .
.
.
deskcon .
.
.
clipstk .
.
.
crescash .
.
.
bitcoinpr .
.
.
osmon .
.
.
anymemo .
.
.
mileage .
.
.
antpod .
.
.
owncloud .
.
.
k9mail .
.
.
.
fbreader .
.
.
table compares the executes before relations detected byandracer and ercatcher on a set of microbenchmarks called benchdroid designed by the authors of ercatcher.
the app groups column lists the applications grouped based on the usage of android constructs.
the number of apps in a group is listed in the apps column.
the man eb column lists the actual executes before pairs in these programs that we found by manual inspection.
the er eb column gives the number of executes before pairs 1334esec fse november singapore r. pai et al.
1392detected by ercatcher we disregard the unsound pairs reported by ercatcher while ar eb gives the number detected by andracer .
our tool has a total recall of .
compared to ercatcher s recall of .
.
table comparison with ercatcher app groups apps man eb er eb ar eb asynctask lifecycle looper executor singleactivity thread timertask table shows the results of our tool for race detection on these apps.
the ca column shows the number of conflicting accesses detected.
the table is further structured to evaluate three main features of the tool the effectiveness of the eb relations in eliminating ca pairs as non racy eb usefulness the precision in detecting actual races race statistics and the usefulness in detecting redundant synchronizations redn.
sync.
.
the syn and eb columns give the number of ca pairs eliminated as non racy due to the use of synchronizations and executes before relation respectively.
note that some pairs can be eliminated by both.
the seb column gives the number of ca pairs eliminated solely due to the executes before relation.
moving on to race statistics the pr column gives the number of ca pairs flagged as potentially racy by the tool and ar is a conservative count of actual races found by manual inspection.
due to the complex control flow we were not able to inspect some of the apps for actual races.
the top section of the table gives ar values for those apps which we could manually analyze.
the time taken to report races in sec is given under the t s column.
finally the rsb column gives the number of redundant synchronizations detected by our tool and the number in parenthesis is the number of synchronizations used in the apps.
the t s column here is the time taken in sec to report the redundant synchronizations.
furthermore among the potential races in the column pr we looked at the applications with the prs on the nonatomic accesses of long double float.
we see that prs on nonatomic accesses of long double and float were found in applications crescash antpod and owncloud .
the accesses of crescash were manually verified and were found to be harmful potential racy pairs hpr .
discussion.
we note that our tool is able to filter out a large part of the conflicting access pairs as non racy on the average of .
of cas are eliminated .
the proposed eb based rules were found to be useful in eliminating ca pairs as on an average of ca pairs eliminated were solely due to the eb rules.
it is worth noting that the eb rules were soley responsible all ca pairs eliminated in the crescash apptable data races reported by andracer eb usefulness race statistics redn.
sync.
app ca syn eb seb pr ar t s rsb t s childmon .
.
aard2 .
.
dns66 .
.
charreco .
.
a2dpvol .
.
asetu .
.
kpdroid .
.
openapk .
.
deskcon .
.
bitcoinpr .
.
anymemo .
.
mileage .
.
owncloud .
.
fbreader .
.
clipstk .
.
crescash .
.
osmon .
.
antpod .
.
k9mail .
.
which had well over cas.
the figures for the charreco app are similarly encouraging.
our tool is fairly precise in that only few of false positives are reported.
one of the reasons for imprecision in race detection is due to the imprecision in spark s points to analysis.
another reason is that the tool considers that multiple instances of a task to be represented by one abstract task.
there are several scenarios in the apps where multiple components post the same task.
since none of the rules apply this leads to some false positives.
despite these the average precision of our tool is around .
the redundant synchronizations analysis detects unnecessary use of synchronization constructs in the applications.
the tool found that some of the apps like aard2 dns66 antpod owncloud and fbreader relied on a lot of synchronizations which were not needed since their shared accesses do not happen in parallel as detected by the eb conditions .
to summarize our tool performed well in detecting data races and redundant synchronizations despite the use of imprecise points to analysis.
the proposed executes before conditions played a significant role in the performance numbers of the tool.
it also performs well over ercatcher in detecting executes before pairs.
related work we group related work according to work on executes before mhp and dynamic and bounded model checking based techniques for edp programs and discuss our work in relation to them.
1450executes before analysis esec fse november singapore 1508executes before analysis.
hu et al.
wu et al.
and salehamadi et al.
consider the problem of statically determining executes before pairs as part of their goal of statically detecting event based races in android apps.
event races are conflicting accesses that are not causally ordered in the application for instance we would like an access to happenafter the initialization and a free to happen after an access .
the basic approach in these works is to construct a finite contextual unfolding of the program and to compute happens before orderings on this unfolding.
they then implicitly infer an executes before ordering on tasks by saying thataexecutes before bif the end node of every contextual instance of ais happens before ordered with the start node of every contextual instance of b. to begin with event races are different from the standard races we target in this paper two accesses that run on the same thread or two accesses that are well synchronized by locks and hence non racy may be event races simply because there is no fixed order between them.
secondly this way of infering executes before pairs is easily seen to be unsound for general edp programs where one has posts in a loop or recursive posts by tasks.
thus the aim in appears to be produce a small set of potential event races with a low false positive rate with no intention of being sound.
in contrast we want our execute before rules to be sound and effective on the general class of edp programs given the downstream applications of mhp analysis sound data race and redundant synchronization detection and data flow analysis.
mhp analysis.
kahlon et al.
give a static analysis to detect races in multi threaded c programs with asynchronous function calls which is similar to edp programs.
their main focus is on a context sensitive points to and must held lockset analysis for c programs in the presence of function pointers.
the mhp rules they give essentially correspond to standard fork join and lock unlock rules.
as demonstrated by our experiments the eb based rules are crucial in obtaining good precision for event driven programs.
the algorithm by computes precise mhp information for fork join asynchronous programs.
this is not very useful in our setting for example in android apps where joins appear to be rarely used.
since android apps are java based one may ask if static race detection techniques for java could be used for android apps.
while many of the techniques for obtaining a precise set of conflicting accesses for example would help here too the mhp analysis would not be sound as they do not consider the task posting feature of edp programs.
moreover these techniques typically drop soundness in favour of precision.
for instance declare statements to be non mhp even if two may held locks may alias.
the nadroid tool of tries to address task posting in android apps by converting them to a standard java program in which each callback is on a different thread and then invoking a java race detector like chord .
however as one would expect this approach leads to a lot of false positives.bounded analysis.
droidracer uses a bounded modelchecking approach to detect a wide range of event based races.
the authors give a formal semantics of event driven systems that considers both thread interleavings and event dispatch.
in another bounded model checking approach implements aphase bounding algorithm to analyze c programs that have an execution model which supports asynchronous programming in a tool called bbs which uses the bounded model checker cbmc.
while such approaches can be expected to be very precise they are not scalable and are inherently unsound.
conclusion in this paper we have given a sound and efficient technique with good recall to statically identify executes before pairs in event driven programs.
the executes before information is shown to be effective in downstream analyses like data race detection and identifying redundant synchronization blocks in android apps.
in future work we would like to explore the use of the executes before information in sound detection of event based races as well as in efficient and precise data flow analysis for event driven programs.