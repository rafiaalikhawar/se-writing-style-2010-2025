fuzzing class specifications facundo molina university of rio cuarto and conicet argentina fmolina dc.exa.unrc.edu.armarcelo d amorim federal university of pernambuco brazil damorim cin.ufpe.brnazareno aguirre university of rio cuarto and conicet argentina naguirre dc.exa.unrc.edu.ar abstract expressing class specifications via executable constraints is important for various software engineering tasks such as test generation bug finding and automated debugging but developers rarely write them.techniquesthatinferspecificationsfromcodeexisttofillthis gap buttheyaredesignedtosupportspecifickindsofassertions andaredifficulttoadapttosupportdifferentassertionlanguages e.g.
to add support for quantification or additional comparison operators such as membership or containment.
to address the above issue we present specfuzzer a novel technique that combines grammar based fuzzing dynamic invariant detection and mutation analysis to automatically produce class specifications.
specfuzzer uses i a fuzzer as a generator of candidate assertions derived from a grammar that is automat ically obtained from the class definition ii a dynamic invariant detector daikon to filter out assertions invalidated by a testsuite and iii a mutation based mechanism to cluster and rank assertions so that similar constraints are grouped and then the stronger prioritized.
grammar based fuzzing enables specfuzzer tobestraightforwardlyadaptedtosupportdifferentspecification languages bymanipulatingthefuzzinggrammar e.g.
toinclude additional operators.
we evaluate our technique on a benchmark of java methodsemployedintheevaluationofthestate of the arttechniques gassertandevospex.ourresultsshowthatspecfuzzercaneasily support a more expressive assertion language over which is moreeffectivethangassertandevospexininferringspecifications according to standard performance metrics.
ccs concepts theory of computation program specifications softwareanditsengineering dynamicanalysis softwaretesting and debugging.
keywords oracle problem specification inference grammar based fuzzing.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
reference format facundo molina marcelo d amorim and nazareno aguirre.
.
fuzzing classspecifications.in 44thinternationalconferenceonsoftwareengineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction softwarespecificationsareabstractdescriptionsofthesoftware s intendedbehavior.theyservetwomainpurposes toexplicitlystate the userneeds and tocheck implementation conformance .
in object oriented oo design where software is organized as a set ofclasses aclassspecificationdescribestheintendedbehaviorof the class methods and the constraints on the state of the class objects.
while the specification of a class is typically described informally throughnaturallanguagedocumentationofitsapi the specification becomes significantly more useful when expressedformally through constraints known as contracts .
contractsenabletechniquesof variouskinds includingtestgeneration automated debugging bug finding and verification .
despite the benefits of formal contracts developers rarely write them.
to aid developers in equipping implementations with contracts techniques for inferring class specifications have been proposed .however thespecificationexpressivenessoftheseapproachesislimited.daikon thebaselinethatothertechniques use supportsarestrictedsetoftemplates fromwhichassertions are generated.
it is then limited to simple assertions e.g.
no direct support for quantification or requires the developer to manually extend the assertion language.
gassert and evospex two recently proposed techniques for contract inference try toaddress this limitation of daikon by supporting more expressive assertion languages but their extensions focus on specific kinds of constraints gassert focuses on logical arithmetic constraints no quantified expressions and evospex focuses on object navigation constraints only very simple logical and arithmetic operators are supported .moreover asbothtechniquesarebasedonevolutionary search they are difficult to extend or adapt to support further expressions as the evolutionary algorithms are targeted for the specific languages supported by the corresponding tools.
to overcome the limitations of existing approaches we propose specfuzzer atechnique for generatinglikely specifications byfuzzingpotential specifications associated with a given class.
specfuzzerusesgrammar basedfuzzingtoautomaticallygenerateconstraintsthatcanbeusedascandidatespecificationsbyan invariant detection tool in our case we use daikon .
fuzzing 1in the context of this paper we will interchangeably use the terms contractandspecification.
a contract is typically composed of different assertions for various program points such as method preconditions and postconditions.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa f. molina m. d amorim and n. aguirre traditionallyusedtoefficientlyproducestructuredrandomdatafor testing has two key advantages in this context it eliminates theneedofdeveloperstomanuallydefinecandidateassertionsand itenablesdeveloperstostraightforwardlyadaptthelanguageof assertions by manipulating the fuzzing grammar.
fuzzing can quickly produce very large sets of assertions to be fed to a dynamic detection tool.
however as the assertions are generated randomly and dynamic invariant detection only filters out assertions that can be invalidated by a given test suite a substantial number of candidate specification expressions may be reported by the dynamic detector when fed with fuzzed assertions.
toaddressthisproblemandbetterassistdevelopersindrivingtheir attention to the likely most relevant specifications specfuzzeruses an assertion reduction mechanism based on clustering and mutationtesting .aftergeneratingthousandsofcandidate specificationswithfuzzing specfuzzerusestheoutputofacustommutationanalysistoclustercandidatespecifications.moreprecisely it partitions the set of specifications according to the mutants they kill and within each partition the assertion that is falsified the most number of times when running the test suite on the mutants is picked as the representative.
notice that even though all the assertionsinthesamepartitionkillthesamemutants somemay be falsified more than others as a same mutant may be killedby multiple tests.
the rationale for the mutation based partitionis that assertions that kill different mutants are non equivalent or alternatively that assertions that kill the same mutants are similar the rationale for ranking assertions according to the number of failures is that assertions that are falsified a greater number of times are stronger .
we compared specfuzzer with gassert and evospex two state of the art techniques in specification inference.
to evaluate specfuzzer we used the same benchmarks from the evaluationofgassertandevospex carefullystudiedthesubjects and manuallyproducedcorresponding groundtruth assertionscapturing the intended behavior of the subjects.
we then used thisground truth to accurately assess precision and recall of spec fuzzer gassert and evospex.
it is worth noting that prior work used indirectmetrics to compute precision andrecall as opposed to the direct usage of ground truth and prior work used subsetsofthesubjectsweconsider ourbenchmarkisthecombination of the gassert and evospex benchmarks .
our results showthat specfuzzer increases the expressiveness over gassert and evospex beingabletoexpress moreassertionsintheground truththanthesetools.specfuzzerwasalsoabletodetect75 of allassertionsinthegroundtruth showingabetteroverallperformancecomparedtoprevioustechniques.theresultsweobtained provide initial yet strong evidence that specfuzzer is effective.
in summary this paper makes the following contributions specfuzzer anoveltechniqueforassertioninferencethat combines grammar based fuzzing and dynamic invariant detection.
an efficient mechanism for grouping similar assertions and for ranking assertions based on their strength.
athoroughevaluationofourtechniqueagainstgassertand evospex in which performance metrics are computed in relation to manually written assertions ground truth .the evaluation artifacts of specfuzzer are publicly available .
background thissectionpresentsbackgroundmaterialthatisimportantforthe rest of the paper.
.
specification inference specification inference is the problem of generating a formal description of the software behavior from existing software artifacts e.g.
documentation source code etc.
specification inference isclosely related to the oracle problem which is the problem of decidingwhetherornotaprogramexecutionisconsistentwiththe desiredbehavioroftheprogram.specificationinferenceprovides a means to create oracles .
for regression testing purposes it sometimessufficestoproducespecificationsofexpectedproperties as assertions for the context of a given test case .
however moregeneralassertionsthatcaptureproperties atgivenlocations withintheprogram notthetest foranyinput haveotherapplications including testing.
this is the problem we study in this paper defined as follows.
definition2.
.
givenatargetprogram p andaprogrampoint of interest inp infer a specification that captures the states at i.e.
for every state sofp holds insif and only if there exists an execution tofpsuch that sis the state of tat program point .
.
grammar based fuzzing fuzzing is a very active topic both in research and practice .
fuzzing is a technique to automatically produce large sets of oftenstructured data fortestingatargetprogram.thegeneration process typically involves randomness and the rationale is thattesting on large sets of quasi valid data can reveal subtle bugs suchaswronglyhandledinputsandcornercases.awell known usecaseoffuzzingisdetectionofsecurityvulnerabilities suchas buffer overflows .
differentfuzzingstrategiesexist .grammar basedfuzzing uses an input grammar to produce syntactically valid inputs by traversingtheproductionrulesofthegrammar.initssimplestform theinputgenerationprocesscanbeimplementedasanincrementalexpansionofastringstartingfromtheinitialgrammarsymbol and replacingnon terminalsymbolsbytheapplicationofarandomlychosen production rule of the correspondingnon terminals until thestringconsistsofterminalsonly aboundonthenumberofnonterminals enables this process to handle recursion which would otherwiseleadtoinfiniteloops.asanexample considerascenario where the program to test takes as input a propositional logic pl formula characterized by the grammar from figure .
to generate testingdata theplgrammarcanbefedtoagrammar basedfuzzer e.g.
grammarinator toefficientlyobtainaverylargesetof well formedtestdata plformulas inthiscase .togenerateinputs thefuzzerexplorespathsinducedbythegrammarproductionrules.
for instance the input neg p and q can be obtained through the following derivation start leadstoformula leadstonegformula leadstoneg formulaandformula leadstoneg p and formula leadstoneg p and q .
it is worth noticing that a great advantage of fuzzing in this case is that the input language can be easily adapted by modifying the grammar.
for instance our fuzzer would be able to generate authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fuzzing class specifications icse may pittsburgh pa usa angbracketleftstart angbracketright angbracketleftformula angbracketright angbracketleftformula angbracketright angbracketleftatomic angbracketright neg angbracketleftformula angbracketright angbracketleftformula angbracketrightand angbracketleftformula angbracketright angbracketleftatomic angbracketright true false p q r .
.
.
figure propositional logic grammar.
formulaswithdisjunctionsifweaddacorrespondingproduction rule to the non terminal formula.
theaboveexampleisrelevantbecausethetechniquewepropose inthispaperusesgrammar basedfuzzingasalightweightapproach to produce assertions such as the pl formulas above as candidate specificationsforprogrampoints.thesimplicitywithwhichthe grammar can be adapted or extended will be one of the advantages of the approach compared with related techniques.
.
assertion language an assertion is a logical expression associated with a program point expressing an expected property at that location.
the use of assertions has wide spread applications in software design software testing and verification .
ourassertionlanguageissimilarinexpressivepowertojml and features first order quantification forall exists arithmetic andlogicaloperators andreachabilityexpressions thereachoperator reach x f1 ... fk denotes the smallest set of objects reachablefrom x throughfields f1 ... fk .additionally postconditionassertionsmightusethe old expr notation torefertothe value of expression exprat the precondition.
for simplicity we drop the backslashes shorten the quantifier names and replace thesemicolonnotationinjmlquantificationbytheimplication in thecase ofuniversal quantification or conjunction inthe caseof existentialquantification .asanexample thefollowingexpression all sortedlist l reach this next .has l l.elem old l.elem states that the integer field elemof the list nodes reachable from this hasisthejmloperatorformembership remainsunchanged.
this expression corresponds to the following jml expression forall sortedlist l reach this next .has l l.elem old l.elem our assertion language is motivated by the expressive power of the languages in related work and in contract languages .
this is a generallanguage that includes the usual relational arithmetic and logical operators but no domain specific functions e.g.
trigonometric functions that would be relevant only for some analysis subjects are not considered .
the assertion languageenablesonetorefertoclass objectfields butnottothe resultsofmethodcalls.thatwouldrequireustodeclaremethodsas pure to use them in assertions which is beyond what our current implementationsupports.
illustrative examples thissectionillustratesspecfuzzerontwosimpleexampleswith the purpose of highlighting limitations of state of the art specification inference techniques and illustrate specfuzzer.
examples.
figure shows min a java method to compute the minimumoftwointegers whereasfigure3shows sortedlist ajava returns the minimum of two integers public static int min int x inty if x y return x else return y figure method to get the minimum of two values.
public class sortedlist private int elem private sortedlist next private static final int sentinel integer.max value constructors public sortedlist this sentinel null private sortedlist int elem sortedlist next this.elem elem this.next next method to insert an element in the list void insert int data if data elem next.insert data else next newsortedlist elem next elem data figure class sortedlist implements an ordered list of integers.
classimplementinganorderedlistofintegers.the minmethodis straightforward.class sortedlist isslightlymoreelaborate.ithas two instance fields elemandnext that represent the value of a linked list node and the reference to the next node respectively.
italsohasaclassfield sentinel thatstoresaspecialvalue the maximum java integer value as a mark for the end of the list.
the sentinel should be placed at the end of the list and should not be repeated.thedefaultconstructorcreatesanodemarkingtheend of the list.
the insertmethod takes the integer dataas parameter and inserts it in its correct sorted position in the linked list.
as it is notpossibleforanyintegervaluetobegreaterthanthesentinel the search is guaranteed to insert the element before the sentinel.
relevant properties.
theintendedbehaviorofmethod ministhat itcomputestheminimumbetween xandy.aspecificationofthe postcondition of minin our assertion language is as follows result x result y result x result y the postcondition of method sortedlist.insert involves variousproperties thelistisacyclicandsortedincreasingly thesentinelisinthelist attheend andthe dataelementisinserted.this postcondition can be specified as follows all sortedlist l reach this next .has l !reach l.next next .has l all sortedlist l reach this next .has l l.elem l.next.elem authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa f. molina m. d amorim and n. aguirre table gassert and evospex on the running examples.
gassert evospex min int x int y postcondition x result y result result y result x result x result y sortedlist.insert intdata postcondition 1elem data elem old elem exists sortedlist l reach this next .has l l.elem data old elem next.elem exists sortedlist l reach this next .has l l.elem sentinel exists sortedlist l reach this next .has l l.elem data we may consider these assertions to be the ground truth postconditionspecificationsofthecorrespondingmethods andwhat we would ideally expect specification inference tools to produce.
.
techniques for specification inference daikon.daikon isdynamictechniquethatinfersspecifications by monitoring test executions.
considering definition .
besides the program p daikon requires a test suite tforpto infer specifications.
daikon uses tto exercise p it monitors program states at various program points of p it considers a set of assertions obtained by instantiating assertion patterns and those that are not invalidated by any test at a given program point are reported to the user as likely invariants at the program point.
gassert and evospex.
gassert andevospex arerecently proposedspecificationinferencetechniques.asdaikon thesetools execute a test suite of the program under analysis and observe executionsto inferspecificationsthatareconsistentwiththeobservations.
while daikon requires the test suite to be provided gassertandevospexusetheirowntestgenerationmechanisms third partytestgenerationtoolsinthecaseofgassert acustom testgenerationapproachinthecaseofevospex .althoughbothtechniques are based on evolutionary search they have key dif ferences.
gassert implements a co evolutionary algorithm thatexplores the space of possible assertions the co evolution deals with false positives and false negatives via two cooperating evolutionary processes and usesthe oasis oracle assessmenttool to iteratively improve the assertions.
evospex implements a classicalgeneticalgorithmtoexplorethesearchspace andusesastate mutationtechniquetogeneratepostconditionstatesinwhichthe assertionsbeingsoughtforshouldfail.gassert sevolutionaryoper ationsfocusonlogicalandarithmeticassertionswhereasevospex s focusesonobjectnavigationalproperties.forthesetools changingtheassertionlanguagesimpliesredefiningthecorresponding evolutionaryoperatorsandotherparametersoftheevolutionary algorithms which is non trivial.
tables1and2showhowdaikon gassert andevospexperform on the examples for brevity we have removed thisfrom nonquantifiedexpressionsinthe insertexample .gassertperforms perfectly on the minexample but poorly on sortedlist it does not capture most of the ground truth evospex infers one complex assertion for sortedlist.insert that the element is inserted and missestheremainingthreeinthecorrespondinggroundtruth it also infers part of the ground truth for min.
daikon infers the sameasevospexinthecaseof min andinthecaseof sortedlist.insert it only infers specific sortedness instances between the first fewelements of the list but it fails to generalize this relationship for the whole structure.
it fully misses the remaining assertions in the ground truth.
.
specfuzzer specfuzzerusesacombinationof staticanalysis grammar based fuzzing and mutationanalysis toinferspecifications.
specfuzzer proceeds as follows.
first it uses a lightweight static analysis to produce agrammar forthe specificationlanguage whichis tuned to the software under analysis.
then it uses a grammar based fuzzertogeneratecandidatespecificationsfromthatgrammar.a dynamic detector then determines which of those specifications are consistent with the behavior exhibited by a provided test suite.
finally specfuzzer eliminates irrelevant and equivalent specificationsusingamechanismbasedonmutationanalysisandclustering.
asalientfeatureof specfuzzeristhatdeveloperscanadjustthe setofspecificationsproducedbytuningthegrammarasopposed to making changes in the tool.
table shows the assertions that specfuzzer infers as postconditions for methods minandsortedlist.insert .
recall that specfuzzer uses fuzzing and reports a higher number of assertionscomparedtotheothertechniques.weconfiguredthefuzzer toproduce2000candidateassertionspersubject andfoundthat out of those generated and were confirmed as likely invariants by the dynamic detector for minandinsert respectively.
the mutation based partition strategy enabled specfuzzer to considerably reduce the reported assertions to and respectively.
in the case of min the inferred assertions are valid and their conjunctionisequivalenttothecorrespondinggroundtruth.for sortedlist.insert thefirst3assertionsalreadycover3outof4 assertions in the ground truth the only missing one is list acyclicity .
the other inferred assertions are either valid but less relevant or invalid .
the invalid ones are specifications that were true in the provided test suite but there exist some unseen scenarios in which they are falsified.
notice that this also affectsthe other techniques even though gassert and evospex includecostly mechanisms to reduce invalid assertions the assertion inferredbygassertfor sortedlist.insert inparticular isaninvalid property .
approach this section presents specfuzzer a technique for specification inferencethatusesacombinationofstaticanalysis grammar based fuzzing and mutation analysis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fuzzing class specifications icse may pittsburgh pa usa table daikon and specfuzzer on the running examples.
daikon specfuzzer min int x int y postcondition 1result x x result 2result y x result result x y y result x y y !
result x y y result x y y result x y y result x y y result x y x result sortedlist.insert intdata postcondition 1elem next.elem exists sortedlist l reach this next .has l l.elem sentinel 2elem next.next.elem all sortedlist l reach this next .has l l.elem l.next.elem 3next.elem next.next.elem exists sortedlist l reach this next .has l l.elem data 4next !
null next !
null 5elem old elem elem !
old elem 6elem old next.elem next.elem old elem 7elem old next.next.elem data next.elem next.elem old elem 8elem data elem data xor data old elem 9next.elem old elem elem data data next.elem 10next.elem old next.elem exists sortedlist l reach this.next next .has l l.elem !
11next.elem old next.next.elem exists sortedlist l reach this next .has l l.elem this.elem 12next.next.elem old elem exists sortedlist l reach this next .has l l.elem l.next.elem 13next.next.elem old next.elem all sortedlist l reach this.next next .has l l.elem this.next.elem 14next.next.elem old next.next.elem elem old elem old elem old next.next.elem elem !
next.next.elem old next.next.elem data next.next.elem next.next.elem old next.elem figure4showstheworkflowofthetechnique.specfuzzertakes asinputajava2classc andproducesassertionsthatseektocharacterize properties of different execution points in c such as method preconditionsandpostconditions.followingthedaikonterminology we will generally refer to assertions that hold on specific program points as invariants.
the technique is organized as a pipeline of five components a tests and mutants generation component that produces tests and mutants for other components of the pipeline a grammar extractor that analyzes cto generate a specification grammar for that class a grammar fuzzer which produces candidate assertions by exploring the production rules fromtheextractedgrammar a dynamicinvariantdetector r esponsible for inferring likely invariants from the fuzzed assertions via observations made with the executions of an input test suite and an invariantselector component whichpartitionsthelikely invariants produced by the previous component to discard useless weak assertions groupstogethersimilarassertions andreports a reduced set of assertions prioritizing the stronger ones.
the following sections discuss these components in greater detail.
.
tests and mutants generation the first step of our process to infer specifications for a class c consistsof i generatingatestsuite texercisingthemethodsof thetargetclass c and ii producingaset m1 ... m nofmutants ofc representingsyntheticfaultsintheclass.asfigure4shows theseartifactsareusedatdifferentstagesofthetechnique.weused 2although our approach is general and language independent some parts of our current prototype such as the grammar extraction and the evaluation of candidate fuzzed specifications arecurrentlyimplementedforjava.supportingotherlanguages that daikon can handle like c would require the implementation of such parts.randoop for test generation and major for mutant generation.althoughweusedthesetoolsinourcurrentimplementation the user may replace them with other tools or even provide her own test suite and mutated versions of the target class c. .
grammar extractor thegrammarextractor takesasinputaclass candcreatesagrammargcexpressingthelanguageofcandidateassertionsfor c.those assertions denote method preconditions postconditions and class invariants.theextractorinstantiatesourbasegrammar referred toasb withinformationthatisspecificto c e.g.
attributetypes legally typed navigational expressions involving the attributes etc.
figure5showsafragmentofthebasegrammar b capturingthe fixedpartsofthespecificationlanguage i.e.
thepartsthatarecommontoanyinputclassofinterest.forthispaper thegrammar bsupports numerical comparisons logical expressions membership expressions and quantified expressions.
numerical comparisons and specfuzzer dynamic invariant detector specs grammarfuzzed specslikely invariantstarget class test suite grammar fuzzer grammar extractor target class mutants invariant collector inferred invariants test generation randoop mutation tool major figure the specfuzzer workflow.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa f. molina m. d amorim and n. aguirre angbracketleftfuzzedspec angbracketright angbracketleftquantifiedexpr angbracketright angbracketleftbooleanexpr angbracketright angbracketleftquantifiedexpr angbracketright angbracketleftquantifier angbracketright angbracketlefttyped var angbracketright angbracketleftbooleanexpr angbracketright angbracketleftquantifier angbracketright all exists angbracketleftbooleanexpr angbracketright angbracketleftnumcmpexpr angbracketright angbracketleftlogiccmpexpr angbracketright angbracketleftmembershipexpr angbracketright !
angbracketleftbooleanexpr angbracketright angbracketleftnumcmpexpr angbracketright angbracketleftnumexpr angbracketright angbracketleftnumcmpop angbracketright angbracketleftnumexpr angbracketright angbracketleftnumexpr angbracketright angbracketleftnumcmpop angbracketright angbracketleftnumexpr angbracketright angbracketleftnumbinop angbracketright angbracketleftnumexpr angbracketright angbracketleftnumexpr angbracketright angbracketleftnumvar angbracketright angbracketleftnumconst angbracketright angbracketleftlogiccmpexpr angbracketright angbracketleftbooleanexpr angbracketright angbracketleftlogicop angbracketright angbracketleftnumcmpexpr angbracketright angbracketleftboolvar angbracketright angbracketleftlogicop angbracketright angbracketleftboolvar angbracketright angbracketleftlogicop angbracketright angbracketleftnumcmpexpr angbracketright angbracketleftnumcmpexpr angbracketright angbracketleftlogicop angbracketright angbracketleftnumcmpexpr angbracketright angbracketleftmembershipexpr angbracketright angbracketlefttype setexpr angbracketright.has angbracketlefttype var angbracketright angbracketleftnumcmpop angbracketright !
angbracketleftnumbinop angbracketright angbracketleftlogicop angbracketright xor figure fragment of the base grammar b. logicalexpressionsarethesimplestconstructsofthelanguage.they relatenumericalexpressionsandbooleanexpressionsbyusingtraditional numerical operators and logical connectives angbracketleftnumcmpop angbracketright and angbracketleftlogicop angbracketright respectively.
membership expressions allow one to expresswhetherornotatypedelementbelongstoaset collection of the corresponding type.
the grammar fragment uses the has notationfromjml andshowsaproductionrulefortypedvariables.
althoughitisnotexplicitlyshowninthegrammarfragment the reachoperator is a way of building a typed set expression.
a concreteexampleof amembershipexpressionfrom aformulashown in section is the following reach this next .has l expressingthatlist lbelongstothesetofobjectsreachablefrom thisbynavigations zeroormore through next.finally thegrammarallowsforexistentialanduniversalquantification.again an example of a quantified expression from section is the following exists sortedlist l reach this next .has l l.elem sentinel whoseintuitivereadingisthatthereexistsalistobjectreachable fromthiswith the field elemholding the sentinel.
toobtainthegrammar gc thegrammarextractortakes band addsordeletessymbolsandproductionrules basedonthestructure ofc.
the process basically depends on c s direct and indirect fields fields declared in citself or in a class reachable from c .
intuitively fromeveryfield navigation aterminalsymbolofthe corresponding type is defined e.g.
this.next will be a terminal of typesortedlist .
set expressions deserve a more detailed description.
firstly if a field fis of a collection type then fwill be a terminal of typed setexpr.
for instance if sortedlist were an implementationof collection then thisandthis.next wouldbeterminals oftype sortedlist setexpr .secondly the reachoperatorisalso involved in building set expressions.
for expression eand recursive field f a field is recursive if it is defined in a class cand has angbracketleftfuzzedspec angbracketright angbracketleftquantifiedexpr angbracketright angbracketleftquantifier angbracketright angbracketlefttyped var angbracketright angbracketleftbooleanexpr angbracketright angbracketleftnumexpr angbracketright sortedlist l exists angbracketleftlogiccmpexpr angbracketright angbracketleftbooleanexpr angbracketright angbracketleftlogicop angbracketright angbracketleftnumcmpexpr angbracketright angbracketleftmembershipexpr angbracketright reach this next .has l angbracketleftnumexpr angbracketright angbracketleftnumcmpop angbracketright l.elem sentinel figure a derivation tree produced by our grammarfuzzer for the expression exists sortedlist l reach this next .has l l.elem sentinel .
typec of class c a production rule allows expression reach e f tohavetype c setexpr .thus expression reach this next has typesortedlist setexpr .
.
grammar fuzzer the goal of the grammar fuzzer component is to produce candidate assertions.
it uses a standard generative grammar based fuzzertoachievethisgoal .thiscomponentproducesderivations ofgc i.e.
strings in l gc to obtain assertions for c.i tbe gins with the start symbol angbracketleftfuzzedspec angbracketrightand keeps expanding nonterminal symbols until no more non terminals are present.
eachnon terminal symbol is expanded based on a non deterministic choiceand toavoidexpansionsleadingtoinfinitederivationpaths alimitof5onthenumberofnon terminalsisdefined.furthermore to avoid getting stuck in a situation where the number of symbols cannotbereducedanyfurther thetotalnumberofexpansionsteps is also limited to .
the rationale for this choice is that complex class assertions can be created by combining small assertions ratherthan longerones.figure 6showsthederivation treeofthe property used in our illustrative example exists sortedlist l reach this next .has l l.elem sentinel .
byusingthisderivationmechanism our grammarfuzzer producescandidatepredicatesveryefficiently.inallofourexperiments we generated up to different candidates every time we executed specfuzzer.
furthermore as the grammar gchas been specifically extracted for a class c all the specifications generated bythefuzzerareguaranteedtoexpresspropertiesover c.weimplementedourfuzzerinjava reproducingageneralgrammar based fuzzer written in python .
.
dynamic invariant detector thegoalofthe dynamicinvariantdetector istoevaluatetheplausibilityofthecandidateassertionsproducedbythefuzzer.asfigure4 shows thedynamicinvariantdetectortakesasinputatestsuite produced by the test generator and a set of assertions produced bythefuzzer.thiscomponentinstrumentstheprogramwiththe assertionsgeneratedbythefuzzerandrunstheteststoverifywhich assertionsholdacrossallexecutions.theresultingassertionsare reported as likely invariants.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fuzzing class specifications icse may pittsburgh pa usa thedynamicinvariantdetectorisbuiltontopofdaikon 3astateof the art toolfor likely invariantdetection .
we useddaikon as follows.
we configured daikon to include the assertions we provided i.e.
theexpressionsproducedbythefuzzer intheinitial pool of candidate assertions it uses.
for that we used a mechanism provided by daikon to incorporate new constraints.4furthermore we included along with the new constraints a component that allows the tool to interpret and evaluate the assertions at run time.
.
invariant selector the goal of the invariant selector is to partition the assertions that were deemed valid by the dynamic invariant detector grouping together similar assertions and taking a single representative from each partition.
at the same time this component discards assertionsthat althoughwereconfirmedbytheinvariantdetector are consideredweakandthuslessrelevant.thiscomponenttakesas inputthesetoflikelyinvariantsobtainedfromthepreviousstep andthesetofmutantsoftheinputclass c obtainedfromamutation tool .
this component reports a subset of the likely assertions it re ceives as input ranking the invariants by the number of failures in corresponding code assertions.
the invariant selector reduces the numberofreportedassertions.tosumup thiscomponentdiscards an assertion because of one of two reasons theassertionisconsidered weak andnottocapturerelevant properties of the target class theassertionis semantically similartoanotherproduced assertion.
inthefollowing wedescribehowweapproximatethedetection of weak and equivalent specifications via mutation analysis.
.
.
detecting weak specifications with mutation analysis.
recall thatthefuzzerreportsthousandsofconstraintsandthedynamic invariant detector in our case daikon can only discard specifications invalidated by the tests.
several constraints can still survive the filtering process described on section .
.
even with bettertest suites some assertions would still survive that process.
forexample a tautology such as x y x y wouldnotbe invalidated by daikon as it is a valid proposition but it is unlikely to be useful.
being syntactically driven the fuzzer can produce valid assertions that do not provide any interesting information.
the assumptionisthatitalsogeneratesinterestingones.specfuzzer usesmutationanalysistodiscarduninterestingassertions.theideais the following if a likely invariant an assertion that is not falsified by the test suite of c cannot be falsified by any mutant of c then itisapropertythatnotonlyholdson c butalsoonallsynthetic buggy versions of c. we will then consider it a weakassertion and discard it as being irrelevant.
this approach of using mutation analysistoinducemoreeffective stronger oracleshasbeenused inpriorwork notablybyfraserandzeller aswellasinrecent work on oracle improvement and specification inference .
.
.
clustering similar specifications with mutation analysis.
it ispossiblethatspecfuzzerproducessyntacticallydifferentassertions that are semantically equivalent or similar with respect to .
irrelevant equivalent reported figure7 breakdownofreasonsfordiscardingspecificationson sortedlist.insert .
only .
of the specifications that survive the invariant detection stage are reported.
a distance metric .
specfuzzer tries to identify and removesuch assertions.asanexample considerthefollowingassertionsthat are produced by specfuzzer on our sortedlist example all sortedlist l reach this next .has l l.elem l.next.elem all sortedlist l !
reach this next .has l l.elem l.next.elem both these assertions express the sortedness property on lists.
the equivalenceoftheseassertionsfollowsfromdemorgan slaws algebraic properties of integers and the equivalence of boolean connectives.toidentifyequivalentassertionsandassertionsthat aresimilarwithrespecttotheirabilitytocapturesyntheticfaults specfuzzeragainusesmutationanalysis.twoassertionswillbe considered similar if they kill the same set of mutants i.e.
if theare falsified on the same set of program faults.
for example the two assertions above kill the same set of mutants together with 74otherassertions.specfuzzerusesthismutation basednotion of assertion equivalence to partition the set of likely assertions accordingtothemutantstheykill.moreover fromeachpartition specfuzzerselectsarepresentativeassertion.todoso itproceeds with the following heuristic the assertions in each partition are ranked by the number of times they fail when running the testsuite on the mutants while they all kill the same mutants someassertions may fail a greater number of times i.e.
for more tests in the test suite .
the rationale is that assertions that fail the most represent stronger properties and thus they may subsume other assertions in the partition.
considering the sortedlist.insert example thismechanismenabledspecfuzzertoreducethenumberofreportedspecificationsfrom437specificationsto16.figure7shows the breakdown of assertions classified as irrelevant section .
.
equivalent section .
.
and reported for the example.
artifact.specfuzzer is publicly available for download .
evaluation to evaluate specfuzzer we performed a series of experiments focused on the following research questions rq1isgrammar basedfuzzingeffectiveatgeneratingrelevantassertions?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa f. molina m. d amorim and n. aguirre rq2isthemutation basedselectorsuccessfulforremovingredundant irrelevant assertions?
rq3how does specfuzzer compare with alternative techniques?
rq1 analyzes the effectiveness of using grammar based fuzzing asatechniquetogeneratecandidateassertions withrespecttoa groundtruth.rq2evaluatesthesuitabilityofthemutation based assertionselectioncomponentof specfuzzer atdiscardingweak assertions andprioritizingthemostrelevant.finally rq3compares theeffectivenessof specfuzzerwiththestate of the arttechniques gassert and evospex .
.
evaluation subjects theperformanceevaluationinpreviousworkusedindirectmetrics to compute precision and recall .
in this paper we compute thesemeasuresdirectly whichrequireshavingagroundtruthfor comparison for each evaluation subject.
we took all the java methodsthatwerepartoftheevaluationofgassert andall23 methodsinthecontractreproducibilityevaluationofevospex obtainingadatasetcomposedof57subjectmethods.westudied eachmethod andmanuallyproducedcorresponding groundtruth assertions capturing the intended behavior of the corresponding method.wemadeourbestefforttobefairintheconstructionof thisgroundtruth bothincapturingasmuchofthegroundtruth as possible and in how the ground truth is modularized as a set of properties eachgroundtruthspecificationisexpressedasaconjunctionofassertions .theywereallcross checkedbyauthors and when possible their validity was verified using smt via microsoft intellitest .
with this process we obtained a total of groundtruthassertions forthe57methods.eachobtainedgroundtruth specificationhasbetween1and3conjuncts.thedetailsaboutthese assertions can be found in our replication package.
notice that since previous work focuses only on inferring postconditions ourevaluationalsofocusesontheseprogrampoints al thoughspecfuzzercaninferassertionsforvariousprogrampoints.
after obtaining the ground truth composed of assertions we carefullyexaminedeachgroundtruthassertion todetermineifit can be expressed in the assertion language of at least one of the evaluatedtools.since15ofthe80assertionswerenotsupportedbyanyofthesetools wediscardedthem .afterthat wealsoremoved methods that ended up without ground truth postconditions.
this results in postcondition assertions for java methods.
each assertion within the in the ground truth could be expressed in the assertion language of at least one tool.
gassert s language can express of the evospex s language can express 29ofthe65 andspecfuzzercanexpress41ofthe65.althoughourgrammarsupportsall65assertions whenimplementingsupportfor the grammar into daikon s assertion template instantiation some expressions are ignored by daikon s infrastructure e.g.
expressions that require instantiating templates with objects of different classes .thereisnofundamentalreasonwhytheseissuescannot be resolved but they demandsubstantial modificationsin daikon.
5discarded assertions include complex trigonometric properties vector cross product constraints assertions involving characters and strings and conversions between characters and hexadecimal encodings.table inferring assertions with grammar based fuzzing.
ground truth reported detected detected .
.
.
experimental setup specfuzzerrequiresatestsuitefortheclassunderanalysis and asetofmutantsforthisclass.thetestsuitewasgeneratedusing randoop and the tool was instructed to generate a maximum of test sequences.
mutants were generated using major with all supported mutation operators enabled.
the fuzzer was run until different candidate assertions were generated syntactic duplicates were removed for each subject class.
regarding gassert and evospex we followed the same methodology described in the corresponding papers using exactly the same configuration parametersfor the evolutionary processes ofeachtechnique.moreover toaccountfortherandomnessofeachapproach for each of the java methods we ran each of the tools toinferpostconditionsatotalof10times.alltheresultsreported in this section correspond to the averages of the executions.
we seta timeout of 90minutes for each executionof each tool.
alltoolswererunonanintelcorei73.2ghz with16gbofram running gnu linux ubuntu .
.
the detailed description of how to reproduce the experiments in this paper is available in the replication package site.
.
effectiveness of grammar based fuzzing the effectiveness of grammar based fuzzing in producing relevant assertions is measuredagainst assertions in theground truth.
the experiment for rq1 consisted in running specfuzzer on each subject and analyzing the percentage of those assertions that the tool wasabletoinfer.recallthattheinvariantselectorusesa mutationbased heuristic to discard assertions.
as such it may wrongly discard relevant assertions.
for that reason to answer rq1 we ran specfuzzer with the invariant selector disabled.
we manually inspected the output of specfuzzer.
more precisely we manually analyzed the assertions that specfuzzer reportsto verifyif theywere presentin theground truth and ifthe groundtruthassertionswerepresentintheoutputaswell .insome cases it was difficult to determine if a given assertion was equivalent to a certain assertion in the ground truth.
when the obtained expressions allowed for it we used an smt solver via microsoft intellitesttocheckexpressionequivalence.moreprecisely weproduced c programs whose branch conditions captured implication andequivalencebetweenoutputcandidateassertionsandground truth assertions and used the dynamic symbolic execution tool intellitest to check whether such expressions could be falsified.
table3summarizesthe resultsof theexperimentsforrq1 with respecttotheoverallgroundtruth 65assertions andthesubset ofthegroundtruththatisactuallysupportedbyspecfuzzer as we explained before out of the are currently supported by our implementation .
we report the number of reported assertions the number of ground truth assertions detected by the tool and the percentage of ground truth assertions that were detected.
if we consider thelanguage supported byour implementation ourtool authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fuzzing class specifications icse may pittsburgh pa usa table performance of the invariant selector reducing assertions.
subject g reported detected red.
before after before after oasis.simplemethods daikon.stackar .
.
.6daikon.queuear .7math.arithmeticutils 50math.fastmath .3math.mathutils .9lang.booleanutils .5guava.intmath .3tsuite.angle tsuite.mathutil .
.
.9tsuite.envelope .
eiffel.composite .5eiffel.dlln .
eiffel.map .
.
.
eiffel.ringbuffer .1cozy.polyupdate .
.
.8cozy.structure .2cozy.listcomp02 .9cozy.minfinder .2cozy.maxbag .
total .
.
.
.
.
correctly detects .
of the assertions in the ground truth if we considerthelanguagesupportedbyatleastoneofthespecification inference tools specfuzzer correctly detects .
of the ground truthassertions.theseresultsconfirmthatgrammar basedfuzzing is effective in generating relevant assertions as shown later on evenwhenconsideringthe65assertionsinthegroundtruth the performance of fuzzing is comparable with state of the art tools .
.
performance of invariant selection the invariant selector component of specfuzzer implements a mutation based heuristics to reduce the number of reported assertions discarding weak assertions assertionsthatsurviveall mutants and selecting representatives among similar assertions assertionsthatkillthesamemutants .rq2evaluatestheperformance of this stage.
the experiment in this case compares the assertions obtained after invariant detection with the assertions that are preserved after running the invariant selection.
the comparison measures assertion reduction and the percentage of the ground truth that is covered prior and after assertion selection.
table shows these results for all subjects grouped by class name.
in each case we report assertions in the ground truth reported assertions before and after invariant selection and percentage of the ground truth that is covered again before and after invariant selection.
finally we indicate the reduction rate obtained byinvariantselection numberofassertionsafterselection with respect to the number of assertions before selection .
the invariant selection results show that the mutation based heuristicsinspecfuzzereffectivelyreducesthenumberofreported assertions with a relatively small loss in property detection with respecttothegroundtruth .moreprecisely thereportedassertionsarereducedby and6outofthe40correctlyfuzzedassertions arediscarded covering of thegroundtruth of65 assertions of the ground truth assertions that the tool supports .table5 validassertionsdiscardedbytheinvariantselector.
subject assertion stackar.pop thearray null stackar.topandpop thearray null angle.getturn abs res composite.addchild c.value old c.value children old children ancestors old ancestors tounderstandthereasonswhywemiss6groundtruthassertions duringinvariantselection weanalyzedhowtheseassertionsare classified by the detector.
in all cases the assertions are deemed as irrelevant i.e.
theyarenotkilledbyanymutant.whiletheproblem may be a weak test suite it becomes clear when observing the assertions that there is no mutation operator able to kill theseassertions the assertions are shown in table .
the problem is not specificto major themutation tool that weused other tools such as pit do not have mutants able to kill these assertions either.
letus providetwo concreteexamples.
assertion abs res for angle.getturn correspondstoamethodwhose resultiseither0 1or1 nomutantmakesthismethodreturnavalueotherthanthese.
in the composite.addchild subject assertion c.value old c.value wouldbeviolatedifamutantchangedthevalueof c aparameterof the method a mutation operator achieving this effect would have to add a new sentence.
theseobservationssuggestthatwemayimprovetheeffectiveness of our heuristics by extending major with support for additional mutation operators specific to our purposes.
.
comparison of gassert evospex and specfuzzer rq3 compares specfuzzer with the state of the art tools gassert andevospex.thecomparisonisbasedonstandardperformance metrics precision recall and f1 score.
these metrics are computed withrespecttothegroundtruththatweproducedfortheevaluation subjects as follows.
given a set gof ground truth formulas the precisionofaset aofassertionsproducedbyatooliscomputed by determining the number of assertions in athat are implied byg.
many assertions were trivially incorrect not implied by the groundtruth andweremanuallyidentified.inmorecomplexcases in correctness was determined using intellitest.
once the set iof incorrect assertions in awas determined precision is computed with the formula a i a. to compute recall we check the number of formulas in gthat are implied by a i .
again while some cases were trivial to check manually for instance when a ground truth formula was directly present in a i more complex ones were confirmed using intellitest.
recall is then computed by the formula n g wherenis the set of ground truth properties implied by a i. toolswereruntoinferassertionsasdescribedearlierinthissection and the results are shown in table grouped by subject class.columns mand gshowthenumberofmethodsinthesubjectandthenumberofassertionsinthegroundtruth respectively.foreachtechniqueweshowthenumberofinferredassertions theprecision and recall with respect to the ground truth and the f1 score.
we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa f. molina m. d amorim and n. aguirre table precision recall and f1 score of gassert evospex and specfuzzer on the data set.
subject m g inferred precision recall f1 score gassert evospex specfuzzer gassert evospex specfuzzer gassert evospex specfuzzer gassert evospex specfuzzer oasis.simplemethods .
.
.
daikon.stackar .
.
.
.
.
.
.
.72daikon.queuear .
.
.
.
.
.54math.arithmeticutils .66math.fastmath .
.75math.mathutils 0lang.booleanutils .
.9guava.intmath .
.
0tsuite.angle tsuite.mathutil .
.
.
.
.47tsuite.envelope .
eiffel.composite .
0eiffel.dlln .
.
.
.
eiffel.map .
.
.
.
.
.
.
eiffel.ringbuffer .
.
.
.
.3cozy.polyupdate .
.
.
.
.
.
.
.03cozy.structure .
.97cozy.listcomp02 .
0cozy.minfinder 1cozy.maxbag .
.
.
.
.
total .
.
.
.
.
.
.
.
.
total specfuzzer .
.
.
.
.
.
.
.71total gassert .
.
.
.
.
.
.
.
.67total evospex .
.
.
.
.
.
.
.
.
summarizetheperformancemetricsfortheoverallgroundtruth of assertions as well as in the context of assertions that are supportedbyeachparticulartool recallthatgassertsupportsin its language of the evospex of the and specfuzzer of the .
that is rows total specfuzzer total gassert and totalevospexshowtheperformanceofthetechniquesontheportionof thegroundtruththat specfuzzer gassertandevospex support respectively.
inferred assertions.
ifwefocusonthenumberofinferredassertions gassert and evospex report fewer assertions than specfuzzer.
thisisanadvantageoftheprevioustechniques sincetheproduced output is easier to interpret.
the main reason here is that both techniques feature evolutionary processes that aim at minimizing the size of the assertions this is an objective of both evolution processes .
specfuzzer is in this respect a simpler technique.
still the invariant selector component allows our tool to report a rea sonable number of assertions per method on average .
thisnumber is still large and calls for future work to further reduce thenumberofassertionsthatspecfuzzerreports.apossibleapproachistoexploitthemutationkillinginformationtoidentifysubsumption implicationrelationsacrossassertions sothatonlythe stronger assertions are reported.
more precisely a mutation based notionofimplication wouldconsiderthatan assertion 1implies another 2ifthesetofmutantskilledby 1includesthosekilled by 2. it is important to notice that as our assertion equivalence definition and mutation based identification of weak assertions areapproximate soourcurrentassertionreductionmechanismalreadyaffectsrecall table4showssomeconcreteexamples .moreaggressivereductionmechanisms suchastheabovedescribedbasedon subsumption implication may affect recalleven further.
a way of reducingreportedassertionswithoutcompromisingrecallwould require precise equivalence implication checking across assertions e.g.
using sat or smt .
although this is a viable option it may considerably affect both efficiency and scalability and thus the generality of the technique.
precision.
precision is the aspect in which gassert and evospex outperformspecfuzzer.again thishastodowiththefactthatboth gassertandevospexincorporatemechanismstoactivelyreduce the number of false positives understood as invalid properties .in particular gassert iteratively improves assertions using oasis launching evosuite instances to search and detect defects in the candidate assertions.
evospex uses a bounded exhaustive testgenerationtechniquewiththeaimofbuildingamorethorough test suite able to discard more false positives.
both techniques have disadvantagesassociated with theseprocesses.
gassert pays apriceinefficiency itisthemostcostlyofthethree evospex s boundedexhaustivetestgenerationhasscalabilityissues dueto its bounded exhaustive test generation it has difficulties scaling to larger subjects .
specfuzzerborrowsfromdaikonthemechanismtodealwith precision.
this issue can be dealt with by improving test suite quality.
we used randoop in our experiments which may be complemented by additional automated test generation techniques.
recall.recallistheaspectwherespecfuzzeroutperformsgassert and evospex.
this is the case for the overall ground truth and for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fuzzing class specifications icse may pittsburgh pa usa mosttool specificgroundtruthsubsets.evospexhasbetterrecall thanspecfuzzerforitsspecificlanguage itinfers5assertionsthat specfuzzercannot.outofthese5 2assertionsarediscardedbytheinvariant selector we described the reasons above .
the remainingthreearesupportedbythegrammar butdaikoniscurrentlyunable toinstantiatetheseassertions wealsodescribedthisissueearlier inthepaper thatis thesethreeassertionsarenotpartofthe41 that our prototype currently supports.
therecallimprovementof specfuzzerovertheothertechniques makes our tool more effective overall as summarized by the f1scores.noticethatspecfuzzerhasabetterf1 scorecomparedwith previous techniques for the overall ground truth i.e.
even taking intoaccountitsprecisionlimitations andthecurrentissueswith support for assertions.
.
threats to validity ourexperimentalevaluationwasperformedonadatasetbuiltwith subjects from previous works.
we needed to manually study these subjects in order to define the ground truth assertions.
to mitigate the risk of errors we checked these assertions using microsoft intellitest previously named pex .
threatstointernalvaliditymayarisefromtherandomnessofthe eachtechnique.toaccountforthisissue weevaluatedspecfuzzer gassertandevospexover multiple runsoneachsubjectmethod and reported the averages.
as further work we plan to extend the experimental evaluation to larger scale java projects which will likelyimplyabandoningthecomputationofperformancemetrics overgroundtruths duetotheeffortthatwouldinvolvestudying larger projects and manually writing correct assertions.
related work theuseofassertionsinprogramshasalongtradition.originally assertionswereusedaspartofapproachesforsoftwareverification and soon were incorporated into programming languages for run time checking .
assertions are currently used for multiple softwaredevelopmentactivities programverification softwaredesign bugfinding program comprehensionandmaintenance programrepair among others.
specification inference is an active area of research.
besides the techniques that infer contract assertions with which we have com paredourtechniqueinthispaper otherrelatedapproaches exist inparticularforinferringtestoracles thatis assertionsthatarevalidonlyforspecificunittests andotherkindsof specifications suchasbehavioraldescriptions .these techniques seek related but different objectives and thus can complement each other.
in relation to test assertion inference tools andtechniques forinferring testassertionsproduce specificationsthat are difficultto generalize as contracts contract specifications ontheotherhand canbeinstantiatedastestassertions butmay captureweakerproperties comparedtotheirtestassertioncounterparts.
other related techniques attempt to produce assertions fromothersources suchascomments orweakerformsofspecifications notably metamorphic relations .
other related forms of specification inference focus on different properties e.g.
behavioral properties in linear time temporal logic or propertiesthatdescribethetemporalrelationshipsbetweendifferentmethods in an api .
as described in these techniques that infer behavioral properties can be complemented by daikon the dynamic invariant detection technique that our work is based on and therefore they can also profit from more expressive assertions.
previous approaches have worked on improving daikon s effectiveness.
in particular the work reported in combines daikon withstaticverification inawaythatcanbeunderstoodasanimprovementtoprecision staticverificationisemployedtoconfirm assertion validity .
our approach on the other hand is largely motivatedbyautomaticallyequippingdaikonwithmoreexpressive assertions an issuenot tackled in .
we are not awareof other approaches that automatically address the expressiveness limitationsofdaikon.fuzzing isalsoaveryactivetopic withknown applications in security vulnerability discovery and bug finding in general.tothebestofourknowledge ourapproachisthefirstto employ fuzzing to produce candidate formal specifications.
conclusion and future work formal class specifications have applications in various areas of software development including software design bug finding and programcomprehension.techniquestoautomaticallyinferclass specificationshavebeenproposed butarelimited e.g.
theysupport a limited number of assertion types and are inflexible to change.
to fill this gap we presented specfuzzer a technique to infer likelyclassspecificationsthatcombinesstaticanalysis grammarbasedfuzzing andmutationanalysis.ourevaluationshowsthat specfuzzerhassuperiorperformanceincomparisonwiththestateof the art tools gassert and evospex especially considering recall.
furthermore theuseofgrammar basedfuzzingenablesspecfuzzer to be easily adapted to different assertion languages.
thispaperalsoopensvariouslinesforimprovement aswehave identifiedsomeconcretelimitationsofourapproach.themutation basedmechanismstoclusterequivalentassertionsanddiscardweak assertionsareaffectedbytheabsenceofmutationoperators that would allow our tool to detect some specific constraints.
other moresophisticatedmechanismstodealwithassertionsnotkilled by any mutant may also be incorporated e.g.
constraint basedtechniques .
in general the modular structure of our techniqueenables us to improve specific components e.g.
test generation to improve precision fuzzing to consider more effective efficient fuzzing techniques etc.
finally implementation limitations in the dynamic detection phase constitute a bottleneck for specfuzzer s assertioninferencecapabilities thatweplantoaddressinfuture extensions of our tool.