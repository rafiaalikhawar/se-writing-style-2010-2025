linear time temporal logic guided greybox fuzzing ruijie meng national university of singapore singapore ruijie comp.nus.edu.sgzhen dong fudan university china zhendong fudan.edu.cnjialin li national university of singapore singapore lijl comp.nus.edu.sg ivan beschastnikh university of british columbia canada bestchai cs.ubc.caabhik roychoudhury national university of singapore singapore abhik comp.nus.edu.sg abstract software model checking as well as runtime veri cation are verication techniques which are widely used for checking temporal properties of software systems.
even though they are property veri cation techniques their common usage in practice is in bug nding that is nding violations of temporal properties.
motivated by this observation and leveraging the recent progress in fuzzing we build a greybox fuzzing framework to nd violations of linear time temporal logic ltl properties.
our framework takes as input a sequential program written in c c and an ltl property.
it nds violations or counterexample traces of the ltl property in stateful software systems however it does not achieve veri cation.
our work substantially extends directed greybox fuzzing to witness arbitrarily complex event orderings.
we note that existing directed greybox fuzzing approaches are limited to witnessing reaching a location or witnessing simple event orderings like use after free.
at the same time compared to model checkers our approach nds the counterexamples faster thereby nding more counterexamples within a given time budget.
our ltl fuzzer tool built on top of the afl fuzzer is shown to be effective in detecting bugs in well known protocol implementations such as openssl and telnet.
we use ltl fuzzer to reproduce known vulnerabilities cves to nd zero day bugs by checking properties extracted from rfcs for which cves have been assigned and to nd violations of both safety as well as liveness properties in real world protocol implementations.
our work represents a practical advance over software model checkers while simultaneously representing a conceptual advance over existing greybox fuzzers.
our work thus provides a starting point for understanding the unexplored synergies among software model checking runtime veri cation and greybox fuzzing.
joint rst authors corresponding author zhen dong and ivan beschastnikh participated in the work while being at the national university of singapore as post doc and visiting associate professor respectively.
.
this work is licensed under a creative commons attribution noderivs international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
reference format ruijie meng zhen dong jialin li ivan beschastnikh and abhik roychoudhury.
.
linear time temporal logic guided greybox fuzzing.in44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction softwaremodelcheckingisapopularvalidationandverification methodforreactivestatefulsoftwaresystems.itisanautomated techniquetochecktemporallogicproperties constrainingevent orderingsinprogramexecution againstafinitestatetransitionsystem.
model checking usually suffers from the state space explosion problem thisisexacerbatedinsoftwaresystemswhicharenaturallyinfinite state.tocopewithinfinitelymanystates theresearch communityhaslookedintoautomaticallyderivingahierarchyof finitestateabstractionsviapredicateabstractionsandabstraction refinementoftheprogram sdatamemory e.g.see .whenever a counterexample trace is found in such model checking runs the trace can be analyzed to find a whether it is a spurious counterexampleintroduceddue toabstractions or b theroot cause bug causing the counterexample.
this has rendered model checking to be a useful automated bug finding method for software systems.
runtimeverificationisalightweightandyetrigorousverificationmethod whichcomplementsmodelchecking .in runtime verification a single execution of a system is dynamically checkedagainstformallyspecifiedproperties e.g temporallogic properties .specifically formal propertiesspecifythecorrect behaviours ofa system.then thesystem isinstrumented tocapture events that are related to the properties being checked.
during runtime a monitor collects the events to generate execution traces and checks whether the traces conform to the specified properties.
when the properties are violated it reports violations.
runtime verificationaimstoachievealightweightbutnotfull fledgedverification method.
it verifies software systems at runtime without the needofconstructingmodelsaboutsoftwaresystemsandexecutionenvironments.however togenerateeffectiveexecutiontraces software systems are required to be fed many inputs.
these inputs are usually obtained manually or via random generation therefore runtimeverificationmaytakemuchmanualeffortandexplore many useless inputs in the process of exposing property violations.
paralleltotheworksinsoftwaremodelcheckingandruntime verification greybox fuzzing methods have seen substantial ieee acm 44th international conference on software engineering icse icse may pittsburgh pa usa ruijie meng zhen dong jialin li ivan beschastnikh and abhik roychoudhury recentadvances.thesemethodsconductabiasedrandomsearch over the domain of program inputs to find bugs or vulnerabilities.
themainadvantageofgreyboxfuzzingliesinitsscalabilitytolarge software systems.
however greybox fuzzing is only a testing not verification methodanditismostlyusefulforfindingwitnessesto simple oracles such as crashes or overflows.
recently there have beensomeextensionofgreyboxfuzzingmethodstowardsgeneratingwitnessesofmorecomplexoracles suchastestsreachinga location .however generatinginputsandtracessatisfyinga complextemporalpropertyremainsbeyondthereachofcurrent greyboxfuzzingtools.thus today sgreyboxfuzzingtechnology cannotreplacethebug findingabilitiesofsoftwaremodelchecking and runtime verification.
inthis paper wetake astep forwardinunderstanding thesynergiesamongsoftwaremodelchecking runtimeverificationand greybox fuzzing.
given a sequential program and a linear time temporallogic ltl property weconstructtheb chiautomata a accepting and use this automata to guide the fuzz campaign.
thus given a random input exercising an execution trace wecancheckthe progress of inreachingtheacceptingstates ofa and derive from a the events that are needed to make furtherprogressintheautomata.furthermore ingeneral tracesacceptedby a areinfiniteinlengthandvisitanacceptingstateinfinitely often.
to accomplish the generation of such infinite length traces in the course of a fuzz campaign we can take application state snapshots at selected program locations and detect whether an accepting state of a is being visited with the same program state.
the application state snapshot can also involve a state abstraction if needed in which case the counterexample trace can be subsequently validated via concrete execution.
wepresentafuzzing basedtechniquethatdirectsfuzzingtofind violationsof arbitraryltlproperties .tothebestofourknowledge no existing fuzzing technique is capable of finding violations of complex constraints on event orderings such as ltl properties.
existing works on greybox fuzzing are limited to finding witnesses of simpleproperties such ascrashes or use after free.this is the main contribution of our work algorithms and an implementation of our ideas in a tool that is able to validate any ltl property thereby covering a much more expressive class of properties than crashesoruse after free.ourworkadaptsdirectedgreyboxfuzzing which directs the search towards specific program locations to findviolationsoftemporallogicformulae.werealizeourapproach for detecting violations of ltl properties in a new greybox fuzzer tool called ltl fuzzer.
ltl fuzzer is built on top of the afl fuzzer andinvolvesadditionalprograminstrumentationtocheck if a particular execution trace is accepted by the b chi automaton representing the negation of the given ltl property.
weevaluatedltl fuzzeronwell knownandlarge scaleprotocol implementations such as openssl openssh and telnet.
we show that it efficiently finds bugs that are violations of both safety and liveness properties.
we use ltl fuzzer to reproduce known bugs violations in the protocol implementations.
more importantly for50ltlpropertiesthatwemanuallyextractedfrom request for comments rfcs ltl fuzzer found new bugs representing the violation of these properties out of which cves have been assigned.
these are zero day bugs which have previously not been found.
we make the data set of properties andthe bugs found available with this paper.
we expect that in future otherresearcherswilltakeforwardthedirectioninthispaperto detect temporal property violations via greybox fuzzing.
the datasetofbugsfoundbyltl fuzzercanthusformabaselinestandard for future research efforts.
the dataset and tool are available at approach overview atahighlevel ourapproachtakesasequentialprogram panda linear timetemporallogic ltl property asinputs.theatomic propositionsin refertopredicatesovertheprogramvariablesthat canbeevaluatedtotrueorfalse.anexampleisapredicate x y in which xandyare program variables.
our approach identifies program locations at which the atomic propositions in the ltl property may be affected.
for this we find program locations at whichthevaluesofvariablesintheatomicpropositionandtheir aliasesmaychange.1ourtechniqueoutputsa counterexample i.e.
a concreteprograminputthatleadstoaviolationofthespecification.
counterexample generation proceeds in two phases.
in the first phase the program pis transformed into p prime.
for this we use code instrumentationtomonitorprogrambehaviorsandstatetransitions during program execution.
we check these against the provided ltl property.
in the second phase a fuzz campaign is launched for the program p primeto find a counterexample through directed fuzzing.
we illustrate our technique with an ftp implementation called pure ftpd2.
pure ftpd is a widely used open source ftp server whichcomplieswiththeftprfc3.hereisapropertydescribedin the rfcthat anftp implementationmust satisfy.the ftpserver muststopreceivingdatafromaclientandreplywithcode552when user quota is exceeded while receiving data.
code indicates theallocatedstorageisexceeded.throughoutthispaper wewill use this ftp property as represented by to illustrate how our technique finds property violations in pure ftpd.
.
ltl property construction we start by manually translating the informal property in the rfc into a ltl property .
for this we search the pure ftpd source code using keywords appeand552.
source code analysis reveals that pure ftpd implements a quota based mechanism to manage user storage space and it works only when activated and the command appeis handled by the function dostor in which user quota size is checked when receiving data.
when the quota is exceeded the server replies with code msg quota exceeded viathefunction addreply .wetherefore construct the property as f a f o g n the negation of is thus f a f o g n where definition of atomic propositions a o nappear in table .
next we identify program locations where the values of variables in atomic propositions in may change at runtime.
a simple 1in general our approach requires an alias analysis to map the atomic propositions to program locations.
1344linear time temporal logic guided greybox fuzzing icse may pittsburgh pa usa table mapping between atomic propositions and program locations ... indicates omitted loop entries .
predicate atomic prop.
locations quota activated true a angbracketleftftpd.c angbracketright user dir size user quota o angbracketleftsafe rw.c angbracketright angbracketleftsafe rw.c angbracketright msg quota exceeded true n angbracketleftftpd.c angbracketright angbracketleftftpd.c angbracketright loop entry true l angbracketleftftpd.c angbracketright... example is the proposition quota activated true which correspondstotheprogramlocationwherequotacheckingisenabledin pure ftpd.
at another statement user dir size user quota w e consider the first statement of functions that are used to store data in user directories.
as a result whenever data is written to user directories those functions will be invoked and this proposition will beevaluated i.e.
allcaseswhereuserquotaisexceededwillbecapturedinanexecution.for msg quota exceeded true weidentify functioninvocationsof addreply msg quota exceeded... which are a reply to clients when the quota is exceeded.
specific program locations for each atomic proposition are listed in table .
their corresponding code snippets are shown in listings and .
here we show one code snippet per atomic proposition.
for convenience we use a tuple angbracketleftl p cp angbracketrightin which ldenotes a program location pis an atomic proposition and cprepresents the predicate for the atomic proposition p. at the end of our manual ltl property generation process we output a list lcomprising such tuples.
for the example property the manual process of writing down the predicates and the accompanying tuples was completed by one of the authors in minutes.
listing enabling the user quota option ftpd.c .
ifdef quotas 6064case n ... us er quota size 1024ull 1024ull if generate event a if liveness record state listing writing to user directories safe rw.c .
safe write const int fd const void constbuf size t count const int timeout if user dir size user quota generate event o if liveness record state listing replying msg quota exceeded ftpd.c .
4442afterquota if overflow addre ply msg quota exceeded name if generate event n if liveness record state listing entry of a loop statement ftpd.c.
.
4066for 1a!o 2o!n figure b chi automata accepting traces satisfying .
if generate event l if liveness record state .
program transformation after deriving the property and the list of tuples l we transform program pintop prime which can report a failure at runtime whenever isviolated.weperformthisprogramtransformationusingtwo instrumentation modules event generator which generates an eventwhenapropositionin isevaluatedtotrueatruntime monitor which collects the generated events into an execution trace and evaluates if the trace violates .
if a violation is found the monitor reports a failure.
event generator.
to detect changes in s proposition values duringprogramexecution theeventgeneratorinjectseventgeneration statements at specific program locations.
to do so the generator takes the list lproduced in the previous step as input.
for each tuple angbracketleftl p cp angbracketright l the generator injects a statement if cp generate event p at the program location l such thataneventassociatedwith pcanbegeneratedwhencondition cpis satisfied.
for instance the program location angbracketleftftpd.c angbracketright correspondsto thepropositionvariable a quota activated true and the enabling condition is true.
the generator then inserts a statement if generate event a at line in ftpd.c seelisting1 .consequently whenever angbracketleftftpd.c angbracketrightisreached an event associated with ais generated and recorded at runtime.
instrumentation for the other tuples appear in listings and .
monitor.the monitor module inserts a monitorinto program p toverifyiftheprogrambehaviorconformstoproperty atruntime.
specifically the monitor produces a trace by collecting events that are generated during execution by the instrumented code .
itthenconvertsthenegationof toab chiautomata a and checkswhether a accepts .ifthetraceisaccepted themonitor reportsafailure i.e.
doesnotholdin p.inourpure ftpdexample the negation of isf a f o g n and the converted b chi automata a is illustrated in figure .
checkingsafetyproperties.
ab chiautomataacceptsatrace if and only if visits an accepting state of the automata infinitely often e.g.
state2infigure1 .forthenegationofa safetyproperty the b chi automata a accepts all traces which reach an accepting state since all traces reaching an accepting state will loop thereinfinitely often.
since onlya finite prefixof the trace is relevantforobtainingthecounter exampleofasafetyproperty the monitor thus outputs a counterexample if it witnesses a trace that leads to an accepting state in the b chi automata a .
1345icse may pittsburgh pa usa ruijie meng zhen dong jialin li ivan beschastnikh and abhik roychoudhury checkinglivenessproperties.
theb chiautomataofthenegation of accepts a trace if and only if visits an accepting state of a infinitely often e.g.
state in figure .
for instance an infinite trace a o v in which v nwill be accepted by a .
formally suchatracehastheform 1 2 2 where 1 starts in an initial state of the b chi automata a and runs until anacceptingstate sofa and 2runsfromtheacceptingstate sbacktoitself.witnessingatrace 1 2 inwhich 2occurs infinitelymanytimes isdifficultinpractice sinceafuzzcampaign visits program executions which are necessarily of finite length.
a straightforward approach to tackle this difficulty is to detect a loopinthetraceandterminateexecutionwhenwitnessingtheloop occursmtimes e.g.
1 m bracehtipdownleft bracehext bracehext bracehtipupright bracehtipupleft bracehext bracehext bracehtipdownright 2 2 .
this approach is insufficient because witnessing 2formtimes does not guarantee 2occurs infinitelyoften forinstance for i i m i ... 2... may generate 2formtimes but stops generating 2afteri m .
in this paper we record program states when events associated with atomic propositions occur in the execution and detect a state loopinthewitnessedtrace.iftheexecutionofthestateloopproduces 2 that means trace 2can be generated infinitely many timesbyrepeatedlygoingthroughthestateloop.asaresult we assume that the witnessed trace can be extended to an infinite 1 2 shapedtrace.considerfollowingtwosequenceswitnessed in the execution e e0e1 eiei ei hei ei h s s0s1 loopbody bracehtipdownleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipupright bracehtipupleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipdownright sisi si hsi h si 2h where eisasequenceofeventsassociatedwithatomicpropositions thatoccurintheexecutionand sisasequenceofprogramstates thatarerecordedwheneventsoccur forinstance siindicatesthe programstatethat isrecordedwhentheevent eioccurs.suppose siis identical to si h thensi si h 1is a state loop and its loop bodyissi si h.whenever sitakesinput isi si h 1thatleadsto sifromsi h siwill transition to siitself.
we assume that the systemundertest isareactivesystemtakinga sequenceofinputs anditisdeterministic thatis thesameinputalwaysleadstothe sameprogrambehaviorintheexecution.thus eiei ei hcan begenerated infinitelymany timesby repeatedlyexecutinginput isi si h 1on state si.
trace e e0 ei ei ei h can be generated by running input is0 si isi si h whereis0 siis an input that leads to state sifroms0andisi si h 1is an input that leads tosifromsi h .
as explained occurrence of astate loop in the execution is evidencethatthewitnessedtracecanbeextendedtoaninfinite 1 2 shaped trace.
we leverage this idea to find a violation of a liveness property.
when witnessing a trace in the execution that can be extended to a 1 2 shaped trace that is accepted by b chi automataa weconsideraviolationofthelivenesspropertyhas beenfound.hence forlivenesspropertyguidedfuzzing weenrich theprogramtransformationof ptop primeasfollows instrumenting a function call that records the current program state when an eventappearinginatranstionlabelof a occursintheexecution showninlisting1 specifically functioncall record state takes the current program state and generates a hash code forthe state at runtime instrumenting event generating and staterecording statements at the entries of forandwhileloop statementsintheprogramtoobservepossibleloopsinfuzzing.listing4 showstheinstrumentationofa forloopstatementinpure ftpd.
more detailed and specific optimizations about state saving for checking liveness properties appear in section .
.
witnessing event sequences since program p prime generated in the previous step reports a failure when is violated we can find a counterexample for by fuzzing p prime.
an input that leads to such a failure is a counterexample.
however findinganinputofthiskindischallengingbecauseithasto generateanexecutioninwhichcertaineventsoccurinaspecific order.
in our running example of pure ftpd the quota mechanism mustbeactivatedfirstintheexecution then user quotamustbe exceeded and finally the execution must enter a loop in which no msg quota exceeded is sent back to the client.
existing directed fuzzing approaches like aflgo aim to direct fuzzing towards a particular program location and cannot drive execution through multiple program locations in a specific order.
we now discuss our b chi automata guided fuzzing in the next section.
b chi automata guided fuzzing given an ltl property to be checked automata theoretic model checkingofltlproperties constructstheb chiautomata a acceptingalltracessatisfying .inthissectionwewilldiscusshow a can be used to guide fuzzing.
first we design a mechanism to generate an input whose execution passes through multiple program locationsin a specificorder.we designthis mechanism by augmenting a greybox fuzzer in two ways.
power scheduling.
during fuzzing the power scheduling componenttendstoselectseeds closertothetargetonthe pre built inter procedural control flow graph.
thus the target can be reached efficiently.
to achieve this we use the fuzzing algorithm of aflgo .
inputprefixsaving.thiscomponentobservesexecutionand recordsinputelementsthathavebeenconsumedwhenreaching a target.
as mentioned we focus on fuzzing reactive systems that take a sequenceofinputs.themechanismwefollowinvolvesdirecting fuzzing towards multiple program locations in a specific order.
considerasequenceofprogramlocations l1 l2 lm.ourapproach works as follows first it takes l1as the first target and focuses on generating an input that leads to l1.
meanwhile it observes execution and records the prefix i1that leads to l1.
next it takes l2 as the target and focuses on exploring the space of inputs starting with prefix i1 i.e.
keeping generating inputs starting with i1.a sa result an input that reaches l2vial1can be generated.
basedontheabovemechanismofvisitingasequenceofprogram locations wedevelopanautomata guidedfuzzingapproach.the approachusestheb chiautomata a instrumentedinprogram p primeand observes the progress that each trace makes on a at runtime e.g.
how many state transitions are made towards the accepting state.
to guide fuzzing the approach saves the progress each input achieves on a and uses it to generate inputs that makefurtherprogress.specifically itsavestheprogressforeach 1346linear time temporal logic guided greybox fuzzing icse may pittsburgh pa usa input by recording state transitions that are executed on a and theinputprefixthatleadstothosetransitions.considerinput i0and itstrace 0goesfrominitialstate s0tostatesmonautomata a .
theachievedprogressisrepresentedasatuple angbracketleftxi xs angbracketright wherexi is the shortest prefix of i0whose execution trace goes from s0to smandxs 0is the state transition sequence s0 smvisited.
such progresstuplesarestoredintoaset xandareusedtoguidefuzzing.
for input generation the approach takes a tuple from xand usesittogenerateinputsthatmakesfurtherprogress.considera tuple angbracketleftxi xs angbracketright xsrecords state transitions on automata a which input prefix xihas led to.
thus we can query a withxsto find a transition that makes further progress i.e.
a state transition that gets closer to an accepting state of a .
in the example assuming xsisstate0infigure1 thenthetransitionfromstate0tostate1will beidentifiedsincestate1isclosertotheacceptingstate2.suppose tis the next progressive state transition of xs then we can further querya to obtain atomic propositions that trigger transition t. then by querying the map between atomic propositions and program locations we can identify program locations for those atomic propositions.
in the example atomic proposition atriggers transition from state to state and its corresponding program location is angbracketleftftpd.c angbracketright as shown in table .
from the above we can define criteria for an input to make further progress its execution has to follow the path that an input prefix xihas gone through such that the generated trace can gothroughstatetransitions xs and subsequentlytheexecution reachesoneofprogramlocationsthatareidentifiedabovetoensure the generated trace takes a step further in a .
togenerateinputsofthiskind ourmechanismforgenerating inputsthattraverseasequenceofprogramlocationsinaspecific ordercomesintoplay.assume liisoneofprogramlocationsidentified above for making further progress in a .
the mechanism takeslias the target and keeps generating inputs that start with prefixxiuntil generating an input that starts with prefix xiand subsequentlyvisitslocation li.thisishowourapproachusestuples inxto generate inputs that make further progress towards an acceptingstateintheb chiautomata a .thedetailedfuzzing algorithm is now presented.
fuzzing algorithm algorithm shows the workflow of our counterexample guided fuzzing.
to find a counterexample the algorithm guides fuzzing in twodimensions.first itprioritizestheexplorationofinputswhose executiontracesaremorelikelytobeacceptedby a .specifically if the trace of the prefix of an input reaches a state that is closer to an accepting state on a then its trace is more likely to be accepted.thealgorithmselectsinputprefixeswhosetraceshavebeen witnessedtogetclosetoanacceptingstateandkeepsgenerating inputsstartingwiththem showninline5andline10 .secondly thealgorithmfocusesongeneratinginputswhoseexecutionmakes furtherprogresson a .givenaninputprefix thealgorithmfinds a state transition tthat helps us get closer to an accepting state ina and finds the atomic propositions which enable tto be taken line .
for the atomic propositions enabling transition t we identify the corresponding program locations line .
then weattempttogenerateinputsthatreachtheprogramlocationinalgorithm counterexample guided fuzzing input p prime the transformation of program under test input a automata of negation of property under test input map map between propositions and program locations input flag true for liveness properties input total time time budget for fuzzing input target time time budgetfor reaching a program location 1procedure fuzz p prime a map flag total time target time 2s0 getinitstate a 3x angbracketleft s0 angbracketright starting with init state of a 4fortime total timedo angbracketleftxi t xs t angbracketright selectprefix x p selecttargetatomicproposition a xs t l selectprogramlocationtarget map p fortime prime target timedo d feedback of cfg distance spower power schedule algorithm i generateinput d spower i prime replaceprefix i xi t d angbracketleftxi xs angbracketright evaluate p prime i prime flag d d d x x angbracketleft xi xs angbracketright end 15end the execution and trigger the program behavior associated with theatomicproposition.asaresult thegeneratedtracecanmake further progress in a .
to generate inputs that reach a particular programlocation weleveragethealgorithmproposedinaflgo line8 .
itsidea isto assignmore powerto seedsthat are closer to the target on a pre built control flow graph such that the generated inputs are more likely to reach the target.
the time budget for reaching a target is configurable via parameter target time.
for prefix selection line the algorithm defines a fitness function to compute a fitness value for each prefix tuple.
given a tuple angbracketleftxi t xs t angbracketright its fitness value is ft ls ls la li wherelsis the length of xs tandlais the length of the shortest pathfromthelaststateof xs ttoanacceptingstateon a andli isthelengthofinputprefix xi t.asshownintheformula aprefix tuple has a higher fitness value if the last state of xs tis closer to an acceptingstateon a andtheinputprefixisshorter.heuristically by extending such a prefix our fuzzing algorithm is more likely to generateaninputwhoseexecutiontraceisacceptedby a .prefix tuples with higher fitness values are prioritized for selection.
for atomic proposition selection line we adopt a random selectionstrategy.considertuple angbracketleftxi t xs t angbracketrightandthelaststateof xs tisst thealgorithmidentifiesatomicpropositionsthatmakeaprogressive transition from stona as follows if state stis not an accepting stateofa anyatomicpropositionthattriggersatransitionfrom sttowards an accepting state is selected.
if state stis an accepting state anyatomicpropositionthattriggersatransitionfrom stback to itselfis selected.
forsimplicity the algorithmrandomly selects one from the identified atomic propositions.
when the selected 1347icse may pittsburgh pa usa ruijie meng zhen dong jialin li ivan beschastnikh and abhik roychoudhury proposition phasmultipleassociatedprogramlocations werandomlyselectoneofthemasatarget.themainconsiderationfor adoptingarandomstrategyistokeepourtechniqueassimpleas possible.
moreover these strategies can be configured in our tool.
state saving inlivenesspropertyverification ltl fuzzerdetectsastateloopin thewitnessedtrace.ifastateloopisdetected ltl fuzzerassumes thecurrenttracecanbeextendedtoalasso shapedtrace 1 2 .
this works witha concreterepresentation of programstates howeverinrealitystaterepresentationofsoftwareimplementationsare always abstracted.
state representations that are too abstract may misscapturingvariablestatesthatarerelevanttotheloop which leads to false positives.
state representations that are too concrete may containvariable states that areirrelevant to theloop such as avariableforsystem clock whichleadstofalsenegatives.tobe practical ltl fuzzer takes a snapshot of application s registers andaddressable memory and hashes it into a bit integer which is recorded as a state.
addressable memory indicates two kinds of objects globalvariables objectsthatareexplicitlyallocated with functions malloc andalloca .
such a convention was also adopted in previous works on infinite loop detection .
furthermore ltl fuzzeronlyrecordsaprogramstateforselectedprogramlocations notforallprogramlocations.specifically weonlysavestatesfortheprogramlocationsassociatedwiththe transitionlabelsoftheautomata a where isthelivenessproperty being checked.
note that a transition label in a is a subset of atomic propositions .
the full set of atomic propositions isconstructedbytakingtheatomicpropositionsappearingin and embellishingthissetwithatomicpropositionsthatweintroduce foroccurrenceofeachprogramloopheader suchas lintable1 .if thetransitionlabelinvolvesaset lofatomicpropositions wetrack states for only those atomic propositions in lwhich correspond toloopheaderoccurrences.thegoalhereistoquicklyfindpossible infinite loops by looking for a loop header being visited with the same program state.
hence for the transition label !
nin our running example we only store states for the program locations corresponding atomic proposition lin table .
listing quota checking ftpd.c.
.
4315if ... max filesize off t max filesize user quota size quota.
size off t ... gotoafterquota intheexampleshowninsection2 ltl fuzzerwitnessesastate generatedatprogramlocation angbracketleftftpd.c angbracketright showninlisting4 thathasbeenobservedbefore andatthesametimethewitnessed trace is accepted by a .
in this case ltl fuzzer reports a violation of the ltl property shown in page .
to validate if the violation is spurious we check if the observed state loop can be repeated in the execution.
our analysis shows a chunk of data was readduringtheexecutionofthestateloopandthechunkofdata was from a file uploaded by the client.
we duplicated the chunk of data in the uploaded file and reran the experiment and found the state loop was repeated.
that means the witnessed trace canbeextendedtoa 1 2 shapedtrace whichvisitstheaccepting stateoftheautomataaccepting showninfigure1 infinitely many times.
thus the reported violation is not spurious.
we further analyzed the root cause of the violation.
it shows there was a logical bug in the quota checking module.
as shown in listing the assignment of max filesize occurs in a conditional statementandisneverexecutedduetothat max filesize sinitial value is .
to fix the bug we created a patch and submitted a pull requestonthegithubrepoofpure ftpd whichhasbeenconfirmed and verified.
ltl fuzzer implementation weimplementltl fuzzerasanopensourcetoolbuiltontopof afl which comprises two main components instrumentor and fuzzer.
in the following we explain these components.
.
instrumentation module aflcomeswithaspecialcompilerpassfor clangthatinstruments everybranchinstructiontoenablecoveragefeedback.byextending thiscompiler weinstrumentaprogramundertestatthreelevels specific locations basic blocks and the application.
specific locations.
ltl fuzzer takes a list of program locationsatwhichprogrambehaviorsassociatedwithapropertyunder test might occur.
at each of the given program locations the instrumentationmoduleinjectstwocomponents eventgenerator and state recorder .
event generator is a piece of code that generates an eventwhentheprovidedconditionissatisfiedatrun time.thestate recorder is a component that takes a snapshot of program states and generates a hash code for the state when the given program location is reached in the execution.
basic blocks.
ltl fuzzer guides fuzzing to a target using the feedback on how close to the target an input is as explained in section .
at runtime ltl fuzzer requires the distance from each basic block to the target on the cfg control flow graph .
the instrumentor instruments a function call in each basic block at runtime.thefunctioncallwillqueryatablethatstoresdistances from each block to program locations associated with the given property i.e.
targets .
the distance from a basic block to each programlocationiscomputedofflinewiththedistancecalculator component that is borrowed from aflgo .
applications.
foraprogramundertest theinstrumentationmoduleinjectsa monitorintotheprogram.duringfuzzing themonitor collects events generated by instrumented event generators and produces execution traces.
for property checking the monitor leverages spot libraries to generate a b chi automata from the negation of an ltl property and validates these traces.
the instrumentation module also instruments an observerin the program that monitors execution of inputs it maps a given suitable execution trace prefix to the input event sequence producing it so thattheoccurrenceoftheprefixcanbedetectedbytheobserver duringfuzzing.thefuzzingprocessthenseekstofurtherextend this prefix with suitable events as described in the following.
1348linear time temporal logic guided greybox fuzzing icse may pittsburgh pa usa power scheduleprefix replacingprefix pool instrumented program automatatarget prefixes coverage datainputs prefixesprefix controller fuzz engine afl figure the architecture of ltl fuzzer.
.
fuzzer figure2showsthefuzzercomponent sarchitecture.itmainlycomprisestwomodules prefixcontroller andfuzzengine .ltl fuzzer saves input prefixes whose execution traces make transitions on theautomataandreusesthemforfurtherexploration section3 .
atruntime theprefixcontrollerconductsthreetasks collecting prefixes reported by the monitor instrumented in the programundertestandstoringthemintoapool selectingaprefixfromthe pool for further exploration according to algorithm identifyingthetargetprogramlocationbasedontheselectedprefix.the fuzzengineisobtainedbymodifyingafl .itgeneratesinputs starting with a given input prefix.
to reach a target our fuzzer integratesthe powerscheduling componentdeveloped inaflgo to direct fuzzing.
in ltl fuzzer we direct execution to reach atargetaftertheexecutionofaninputprefix.thus thefuzzengine collectsno feedback such ascoveragedataduringexecution ofthe input prefix and only collects feedback data after the execution of the input prefix is completed.
evaluation in our experiments we seek to answer the following questions rq1 effectiveness how effective is ltl fuzzer at finding ltl property violations?
rq2 comparison how does ltl fuzzer compare to the stateof the artvalidationtoolsintermsoffindingltlproperty violations?
rq3 usefulness how useful is ltl fuzzer in revealing ltl property violations in real world systems?
.
subject programs table lists the subject programs used in our evaluation.
this includes open source software projects that implement widelyusednetworkprotocols.weselectedtheseprojectsbecausethey arereactivesoftwaresystemsthatltl fuzzerisdesignedfor include appropriate specification documents from which ltl propertiescanbegenerated and arewidely usedandhavebeen studied.
finding bugs in such real world systems is thus valuable.
.
experiment setup to answer the research questions we conducted three empirical studies on the subject programs.
.
.
effectiveness of ltl fuzzer .we evaluate ltl fuzzer s effectiveness by running it on a set of ltl properties in subject programs where violations are already known we check the number of ltl properties for which ltl fuzzer can find violations.table detailed information about our subject programs.
project protocol sloc inpreviouswork githubstars proftpd ftp .8k pure ftpd ftp .9k live555 rtsp .5k openssl tls .7k .3k openssh ssh .3k .5k tinydtls dtls .2k contiki telnet telnet .4k .4k to create such a dataset we collect event ordering related cves sothattheycanbecapturedasatemporalproperty thataredisclosed in subject programs e.g.
an ftp client copies files from the server without logging in successfully.
specifically for each subject we select such cves with criteria reported recently during2010 includeinstructionstoreproducethebug relevant to event orderings.
then we manually reproduce them withthecorrespondingversionofcode.ifacveisreproducible then we write the property in ltl and put it in our dataset of ltl properties.basedontheaforementionedcriteria wecollected14 cvesin7subjectsasshownintable3 theseltlpropertiescanbe foundinourdataset4andtheappendixofourarxivpaper5.our goalistocheckexperimentallyifltl fuzzercanfindviolations of these ltl properties.
.
.
comparisonwithothertools.
weevaluateltl fuzzerand state of the art techniques on the ltl property dataset above and compare them in terms of the number of ltl properties for which eachtechniquefindstheviolationsandthetimethatisusedtofind aviolation.forstate of the arttechniques wereviewedrecentand well known techniques in model checking runtime verification anddirectedfuzzingdomains.wechosethefollowingtechniques for comparison with ltl fuzzer.
aflgo .
it is a well known directed greybox fuzzer which drives execution to a target with a simulated annealing based power schedule that assigns more energy to inputs that hold the trace closer to the target.
we take it as a baseline tool.
aflltl.
it is an implementation which enables aflgo to detect anltlpropertyviolation.specifically afl ltlpowersaflgo withonlytheltltestoraclesuchthatitcanreportanerrorwhen thegivenltlpropertyisviolatedintheexecution.bycomparing with afl ltl we evaluate how effective is our automata guided fuzzing strategy in finding ltl property violations.
note that aflltlisalsoatoolbuiltbyus butitlackstheautomataguided fuzzing of ltl fuzzer.
l nusmv.itcombinesmodellearningandmodelcheckingto verifypropertiesinasoftwaresystem.specifically itleverages a learning library called learnlib to build a model for the softwaresystemandthenverifiesgivenpropertiesonthelearned modelwiththewell knownmodelcheckernusmv .inthe paper we indicate it with l nusmv.
this technique was publishedat cav andhas beensubsequently adoptedin recent works such as and .
1349icse may pittsburgh pa usa ruijie meng zhen dong jialin li ivan beschastnikh and abhik roychoudhury table statistics of found violations and the performance of four tools in finding the violations.
propcve id type of vulnerability program versionltl fuzzer aflltl aflgo l nusmv time h time h a12time h a12time h a12 prf1cve infinite loop proftpd .
.
.
t o1.
t o1.
t o1.
prf2cve illegal file copy proftpd .
.
.
.
.
t o1.
t o1.
prf3cve improper access control proftpd .
.
.
.
.
t o1.
t o1.
prf4cve illegal path traversal proftpd .
.
.
.
.
t o1.
t o1.
lv1cve improper condition handle live555 .
.
.
.
.
.
.
t o1.
lv2cve use after free live555 .
.
.
.
.
.
.
t o1.
lv3cve use after free live555 .
.
.
.
.
t o1.
t o1.
lv4cve numeric errors live555 .
.
.
.
.
.
.
t o1.
lv5cve improper operation limit live555 .
.
.
.
.
.
.
t o1.
sh1cve user enumeration openssh .7p1 .
.
.
t o1.
.
.
sh2cve user information exposure openssh .2p2 .
.
.
t o1.
.
.
sl1cve use after free openssl .
.0a .
.
.
.
.
t o1.
sl2cve infinite loop openssl .
.
.
t o1.
t o1.
t o1.
sl3cve illegal memory access openssl .
.1f .
.
.
t o1.
t o1.
found violations in total average time usage hours .
.
.
.
comparison with ltl fuzzer on time usage .44x .93x .55x 1t o represents tools cannot expose vulnerabilities within hours for experimental runs.
we replace t o with hours when calculating average usage time.
2statistically significant values of a12are shown in bold.
we briefly summarize why we did not include certain other modelcheckers and fuzzers and all runtime verification tools for comparison.
model checking tools cbmc cpachecker seahorn smack uautomizer divine cannot support ltl property verification.
schemmel s work published at cav2018partiallysupportsltlpropertyverification.spin supportsltlpropertyverificationbutonlyworkswithamodeling language promela and the tool provided in spin for extracting modelsfromcprogramsfailedtoworkonoursubjectprograms.
somemodelcheckingtools anddirectedfuzzingtools like uafl hawkeye and tofu we reviewed are not publicly available.
finally all of available runtime verification tools like javamop marq andmufin cannotcheckltlproperties in c c software systems.
furthermore our method is conceptuallydifferentandcomplementarytoruntimeverification our methodgeneratestestexecutions whileruntimeverificationchecks atestexecution.whilethecombinationofourmethodwithruntime verification is possible a comparison is less meaningful.
.
.
real worldutilty.
inthisstudy wereadrfcspecifications thatthesesubjectprogramsfollowtoextracttemporalproperties and describe them in ltl.
then we use ltl fuzzer to check these properties on the subject programs.
configuration parameters.
following fuzzing evaluation suggestionsfromthecommunity weruneachtechniquefor24hours and repeat each experiment times to achieve statistically significant results.
for the initial seeds we use seed inputs provided in profuzzbench for allsubjects.profuzzbenchis abenchmark 6for some tools the ltl checker module is not available for usage experimentation as our email enquiry with cpachecker team revealed.for stateful fuzzing of network protocols which contains a suite of representativeopen sourcenetworkprotocolimplementations.for contiki telnet whichisnotcontainedinprofuzzbench wegeneraterandominputsasitsinitialseeds.forltl fuzzer weneed tospecifythetimebudgetforreachingasingleprogramlocation and we configure it with minutes for each target.
for aflgo andafl ltl weneedtoprovideatargetforanltlpropertybeing checked.wespecifythetargetbyrandomlyselectingfromprogram locations that are associated with atomic propositions that trigger thetransitiontoanacceptingstateontheautomataofthenegation oftheproperty.intheexampleinsection2 wechoseoneofloop entriesasthetargetsinceproposition otriggersthetransitionto the accepting state shown in figure and it corresponds with loop entries.
for execution environments we conducted experiments on a physical machine with gb ram and a cores intel r xeon r e5 v4 cpu running a bit ubuntu tls .
as the operating system.
.
experimental results .
.
effectiveness.
table3showspropertyviolationsfound byltl fuzzerforthe14ltlpropertiesderivedfromknowncves.
the first column shows identifiers of the properties being checked.
the corresponding ltl properties and their descriptions can be found in our dataset.
columns represent cve ids types of vulnerabilities that cves represent subject names and subject versions respectively.
column ltl fuzzer shows the time that is used to find a violation by ltl fuzzer.
as shown in table ltl fuzzercaneffectivelydetectviolationsofltlpropertiesin thesubjects.itsuccessfullydetectedtheviolationforallthe14ltl propertiesinthedataset.onaverage ittookltl fuzzer1.91hours to find a violation.
1350linear time temporal logic guided greybox fuzzing icse may pittsburgh pa usa table zero day bugs found by ltl fuzzer for several of them cves have been assigned but cve ids are not shown.
propproject description of violated properties bug status td1tinydtls .
rc1 iftheserverisinthe wait clienthello stateandreceivesa clienthello requestwithvalidcookie and the epoch value must finally give serverhello responses.cve fixed td2tinydtls .
rc1 if the server is in wait clienthello state and receives a clienthello request with valid cookie but not epoch value must not give serverhello responses before receiving clienthello with epoch value.cve fixed td3tinydtls .
rc1 if the server is in the wait clienthello state and receives a clienthello request with an invalid cookie must reply helloverifyrequest .cve fixed td5tinydtls .
rc1 iftheserverisinthe dtls ht certificate request stateandreceivesa certificate request must giveadtls alert handshake failure ordtls alert decode error response orset client auth to be verified.cve fixed td11tinydtls .
rc1 after the server receives a clienthello request without renegotiation extension and gives a serverhello response then receives a clienthello again must refuse the renegotiation with an alert.confirmed td12tinydtls .
rc1 aftertheserverreceivesa clienthello requestandgivesa serverhello response thenreceivesa clientkeyexchange request with a different epoch value than that of clienthello server must not givechangecipherspec responses.cve fixed td13tinydtls .
rc1 after the server receives a clienthello request and gives a serverhello response then receives aclienthello request with the same epoch value as that of the first one server must not give serverhello .cve td14tinydtls .
rc1 if the server receives a clienthello request and gives a helloverifyrequest response and then receives a over large packet even with valid cookies the server must refuse it with an alert.cve fixed ct1contiki telnet .
afterwillrequestisreceivedandthecorrespondingoptionisdisabled mustsend doordontresponses.
cve ct2contiki telnet .
afterdorequestisreceivedandthecorrespondingoptionisdisabled mustsend willorwontresponses.
confirmed ct7contiki telnet .
afterwontrequest is received and the corresponding option is disabled must not give responses.
cve ct8contiki telnet .
afterdontrequest is received and the corresponding option is disabled must not give responses.
confirmed ct10contiki telnet .
beforedisconnection must send an alert to disconnect with clients.
cve ct11contiki telnet .
if conducting command withoutabortoutput the response must be same as the real execution results.
cve puf5pure ftpd .
.
when quota mechanism is activated and user quota is exceeded must finally reply a quota exceed message.cve fixed ltl fuzzer is found to be effective in finding ltl property violations detectingviolationsforall14propertiesderivedfrom known cves.
.
.
comparison.
asshownintable3 thelastthreemain columnsshowthetimethatisusedforcomparisontechniquesto findaviolationonthe14ltlpropertiesintheexperiment.note that t o indicates atechnique failedto findthe violationfor an ltlproperty inthe giventimebudget i.e.
24hours .
tomitigate randomness in fuzzing we adopted the vargha delaney statistic a12 to evaluate whether one tool significantly outperforms another in terms of the time that is used to find a violation.
the a12is a non parametric measure of effect size and gives the probability that a randomly chosen value from data group is higher or lower than one from data group .
it is commonly used to evaluate whetherthedifferencebetweentwogroupsofdataissignificant.
moreover wealsousemann whitneyutesttomeasurethestatistical significance of performance gain.
when it is significant taking .
as a significance level we mark the a12values in bold.
ltl fuzzer found violations of all of the ltl properties followed by afl ltl aflgo and l nusmv .
we note that aflltlis also a tool built by us it partially embodies the ideas in ltl fuzzer and is meant to help us understand the benefits of automata guided fuzzing.
in terms of the time that is used tofind a violation ltl fuzzer is the fastest .
hours followed by aflltl .
hours aflgo .
hours and l nusmv .
hours .
in other words ltl fuzzer is .44x .93x .55x faster than afl ltl aflgo and l nusmv respectively.
for cve and cve aflgo performed slightly better than othertechniques whileafl ltlexhibitedthesameperformanceas ltl fuzzerforcve 15473andcve .weinvestigated these cves and found that triggering those vulnerabilities isrelativelystraightforward.theycan betriggeredwithoutsophisticated directing strategies.
as a result other techniques achieve a slightlybetterperformancethanltl fuzzerforthesefourcves.
in terms of the a12statistic ltl fuzzer performs significantly better than other techniques in most cases.
ltl fuzzer found violations of all the ltl properties in theexperiment.afl ltl aflgoandl nusmvfound12 property violations respectively.
ltl fuzzer is .44x .93x .55x faster than afl ltl aflgo and l nusmv.
.
.
real world utility.
in this study we evaluate utility of ltl fuzzer by checking whether it can find zero day bugs in real worldprotocolimplementations.weextract50propertiesfrom rfcs that our subject programs follow aided by comments in the 1351icse may pittsburgh pa usa ruijie meng zhen dong jialin li ivan beschastnikh and abhik roychoudhury source code of the programs and write them in linear time temporal logic.
the details of the ltl properties can be found in ourdataset.intheexperiment ltl fuzzerachievedapromising result.
out of these ltl properties ltl fuzzer discovered new violations for properties which are shown in table .
we reported these zero day bugs to developers and all of them got confirmedbydevelopers.wereportedthemonthecommonvulnerabilitiesandexposures cve system see and of them were assigned cve ids.
out of reported violations have been fixed at the time of the submission of our paper.
notably ltl fuzzer shows effectiveness in finding violations for liveness properties.
in the experiment ltl fuzzer successfully foundviolationsfor4livenesspropertieswhichare prf1 sl2 td1 andpuf5.
all the violations were confirmed by developers i.e.
theyarenotspuriousresults.moreover todiscoverviolationsfor these4livenessproperties ltl fuzzeronlyrecorded6 4and9 states respectively.
since every state is recorded as a bit integer thememoryconsumptionforrecordingstatesisthusfoundtobe negligible in our experiments.
among50ltlpropertiesextractedfromprotocolrfcs ltlfuzzer found previously unknown violations in protocol implementations and of these have been assigned cves.
.
threats to validity therearepotentialthreatstovalidityofourexperimentalresults.
oneconcernis externalvalidity i.e.
thedegreetowhichourresults can be generalized to and across other subjects.
to mitigate this concern weselectedprotocolimplementationsthatarewidelyused andhavebeenfrequentlyevaluatedinpreviousresearch asshown in table .
we may have made mistakes in converting informal requirementsintoltlproperties.toreducethiskindofbias we lettwoauthorscheckgeneratedpropertiesandremovethoseon which they do not agree or do not think are important properties.
in principle ltl fuzzer can report false positives due to incorrectinstrumentation e.g.
ifwefailtoinstrumentsometarget locationsforanatomicproposition.wemitigatetheriskoffalse positives by checking the reported counterexamples and validating thattheyaretrueviolationsofthetemporalpropertybeingchecked.
weaddherethatwedidnotencountersuchfalsepositivesinany of our experiments.
anotherconcernis internalvalidity i.e.
thedegreetowhichour results minimize systematic error.
first to mitigate spurious observations due to the randomness in the fuzzers and to gain statistical significance werepeatedeachexperiment10timesandreported the vargha delaney statistic a12.
secondly our ltl fuzzer implementationmaycontainerrors.tofacilitatescrutiny wemake ltl fuzzer code available.
related work model checkers.
model checking is a well known property verification technique dating back to 1980s it is used to prove a temporal property in a finite state system or to find property violation bugs.
the early works check a temporal logic property against a finite state transition system.
there exist well known model checkers such as which can be used to checktemporal properties on a constructed model via state space exploration .toconstructmodels onemethodismanualconstruction viaamodelinglanguage.thisrequiressubstantialeffortandcan beerror prone .ltl fuzzerdirectlycheckssoftwareimplementations it does not separately extract models from software.
early works on model checking have been extended to automatically find bugs in software systems which are typically infinitestatesystems.modelcheckingofsoftwaresystemsusuallyinvolves either someextraction of finitestate models or directly analyzing theinfinite statesoftware systemvia techniquessuchas symbolic analysis.automaticmodelextractionapproaches includetheworksonpredicateabstractionandabstractionrefinement whichbuildupahierarchyoffinite stateabstractmodels for a software system for proving a property.
these approaches extractmodelswhichareconservativeapproximationsandcapture a superset of the program behavior.
there are a number of stateful softwaremodelcheckers suchascmc javapathfinder macemc cbmc cpachecker which find assertion violations in software implementations.
many of these checkers do not check arbitrary ltl properties for software implementations.thesemodelcheckerseithersufferfromstatespaceexplosion or suffer from other kinds of explosion such as the explosion in the size solving time for the logical formula in bounded model checking.
in contrast ltl fuzzer does not save any states for safety property checking and saves only certain property relevant program states in liveness property checking.
at the same time ltl fuzzer does not give verification guarantees and does not perform completeexploration of thestate space.
we nowproceed to discuss incomplete validation approaches.
incomplete checkers.
instead of exploring the complete set of behaviors orasuper setofbehaviors onecanalsoexploreasubset of behaviors.
incomplete model learning approaches can be mentioned in this regard.
the active model learning technique such as learnlib is widely used to learn models of real world protocolimplementations .itdoesnotneeduserinvolvement.
but it is time consuming and hard to determine whether the learned model represents the complete behavior of the software system .
compared with the active learning ltl fuzzer canmorerapidlycheckproperties asshowninourexperimental comparisonwithlearnlib nusmv.toalleviatethestate explosion problem stateless checkers such as verisoft and chess have been proposed these checkers do not store program states.
these works typically involve specific search strategies to check specificclassesofpropertiessuchasdeadlocks assertionsandso on.
incontrast ltl fuzzer representsa generalapproach tofind violations of anyltl property.
runtimeverification.
runtimeverificationisalightweightand yet rigorous verification technique .
it analyzes a single execution trace of a system against formally specified properties e.g.
ltlproperties .itoriginsfrommodelcheckingandapplies model checking directly to the real implementations.
model checkingchecksamodelofatargetsystemtoverifycorrectnessofthe system whileruntimeverificationdirectlycheckstheimplementation which could avoid different behaviours between models and implementations.
ltl fuzzer shares the same benefit as runtime verification.
besides runtime verification deals with finite 1352linear time temporal logic guided greybox fuzzing icse may pittsburgh pa usa executions asonesingleexecutionhasnecessarilytobefinite.this avoids the state explosion problem that model checking suffers from.meanwhile itleadstothatruntimeverificationapproaches oftenonlychecksafetyproperties.ltl fuzzer however is able to check liveness properties by leveraging the strategy of saving program states.
conceptually our method is very different from runtime verification.runtimeverificationfocusesonthechecking atemporal logic property on a single execution.
our method is focused on usingtemporallogicpropertytoguidetheconstructionofanexecution which violates the property.
thus our work is more of a testgenerationmethod.sinceruntimeverificationmethodsneed tests whose execution will be checked our method can be complementarytoruntimeverification.inotherwords ourmethodcan generatetestslikelytoviolateagiventemporalproperty andthese tests can further validated by run time verification.
greyboxfuzzing.
therearethreebroadvariantsoffuzzing blackboxfuzzing whiteboxfuzzingorsymbolicexecution and greybox fuzzing .
we first discuss greybox fuzzing since they are the most widely used in industry today.incontrasttosoftwaremodelchecking blackbox greybox fuzzing techniques represent a random biased random search over the domain of inputs for finding bugs or vulnerabilities in programs.mostgreyboxfuzzingtechniquesareusedtodetectmemory issues e.g.
buffer overflow and use after free that can produce observable behaviors e.g.
crashes .
however ltl fuzzer can not only witness simple properties like memory corruption but also detectltlpropertyviolations for anygivenltlproperty howevercomplex.recentadvancesingreyboxfuzzinguseinnovative objective functions for achieving different goals such as directsthesearchtospecificprogramlocations.thecapabilitiesof ltl fuzzer go beyond visiting specific locations and ltl fuzzer is used to witness specific event ordering constraints embodied by the negation of an arbitrary ltl property.
pgfuzz i sa greybox fuzzing framework to find safety violations for robotic vehicles but it is customized to be used on implementations of roboticvehicles.ltl fuzzercanbeusedtofindviolationof any ltl property for software from any application domain.
symbolicexecutionbasedvalidation.
symbolicexecutionorwhitebox fuzzing approaches are typically used to find violations of simple properties such as assertions .
recent whitebox fuzzing techniquesdofindviolationsofcertainclassesofproperties.schemmel s work checks liveness properties while chiron checkssafetyproperties.
proposedregular propertyguided dynamicsymbolicexecutiontofindtheprogrampathssatisfying a property.
however all of these approaches require a long time budgetforheavy weightprogramanalysisandback endconstraint solving.
as a result these techniques face challenges in scalability.
incontrast ltl fuzzerisbuiltontopofgreyboxfuzzing itcan validate arbitrarily large and complex software implementations.
perspective we present ltl fuzzer a linear time temporal logic guided greybox fuzzing technique which takes linear time temporal logic ltl propertiesextractedfrominformalrequirementssuchasrfcsandfindsviolationsofthesepropertiesinc c softwareimplementations.ourevaluationshowsthat ltl fuzzeriseffectivein finding property violations.
it detected ltl property violations in real world protocol implementations that were previously unknown of these zero day bugs have been assigned cves.
we make the data set of ltl properties and our tool available for scrutiny.
our work shows the promise of synergising concepts from temporalpropertycheckingwithrecentadvancesingreyboxfuzzing theseadvanceshavemadegreyboxfuzzingmoresystematicand effective .specifically inthispaperwehavetakenconceptsfrom automata theoreticmodelcheckingofltlproperties while atthesametimeadapting augmentingdirectedgreyboxfuzzing .
the main advancement of greybox fuzzing in our work is the ability to find violations of arbitrary ltl properties which is achieved by borrowing the b chi automata construction from .
we note that the real life practical value addition of software modelcheckingisoftenfromautomatedbug findinginsoftware implementations rather than from formal verification.
runtime verificationcomplementssoftwaremodelcheckingbyanalyzing a single execution trace of software implementations.
our work essentially shows thepromiseof enjoying the main practicalbenefits of software model checking more efficiently and effectively via augmentation of directed greybox fuzzing.
this is partially shown by the experiments in this paper where we have compared our work with both model checkers and fuzzers.
our work is also complementary to runtime verification since we generate test executionsguidedbyaltlproperty whileruntimeverificationwould check a ltl property against a single test execution.
arguablywecouldcompareltl fuzzerwithmoremodelcheckersandfuzzers experimentally.atthesametime wehavenoted that many model checkers were found to be not applicable for checking arbitrary ltl properties of arbitrary c c software implementations.moreover theproblemaddressedbyltl fuzzer is certainly beyond the reach of fuzzers since fuzzers cannot detect temporal property violations.
overall we believe our work represents a practical advance over model checkers and runtime verification and a conceptual advance over greybox fuzzers.
we expectthattheresearchcommunitywilltaketheworkinourpaperforward tofurtherunderstandthesynergiesamongsoftware model checking runtime verification and greybox fuzzing.