towards boosting patch execution on the flysamuel bentonuniversity of texas at dallassamuel.benton1 utdallas.eduyuntong xie!tsinghua universityxieyt18 mails.tsinghua.edu.cnlan lu!southern university of science andtechnology11810935 mail.sustech.edu.cnmengshi zhang meta platforms inc.mengshizhang fb.comxia likennesaw state universityxli37 kennesaw.edulingming zhang university of illinois aturbana champaignlingming illinois.eduabstractprogram repair is an integral part of every software system s life cycle but can be extremely challenging.
to date various automatedprogram repair apr techniques have been proposed to reducemanual debugging efforts.
however given a real world buggy pro gram a typical apr technique can generate a large number ofpatches each of which needs to be validated against the originaltest suite incurring extremely high computation costs.
although ex isting apr techniques have already leveraged various static and ordynamic information to f ind the desired patches faster they arestill rather costly.
in this work we propose seapr self boostedautomatedprogramrepair the f irst general purpose techniqueto leverage the earlier patch execution information during apr todirectly boost existing apr techniques themselves on the y. ourbasic intuition is that patches similar to earlier high quality low quality patches should be promoted degraded to speed up the de tection of the desired patches.
the experimental study on state of the art apr tools demonstrates that overall seapr can sub stantially reduce the number of patch executions with negligibleoverhead.
our study also investigates the impact of various con f igurations on seapr.
lastly our study demonstrates that seaprcan even leverage the historical patch execution information fromother apr tools for the same buggy program to further boost thecurrent apr tool.acm reference format samuel benton yuntong xie lan lu mengshi zhang xia li and ling ming zhang.
.
towards boosting patch execution on the fly.
in44thinternational conference on software engineering icse may pittsburgh pa usa.acm new york ny usa pages.
work was done during a remote summer internship at university of illinois.
corresponding authors.permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor pro f it or commercial advantage and that copies bear this notice and the full citationon the f irst page.
copyrights for components of this work owned by others than acmmust be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci f ic permission and or afee.
request permissions from permissions acm.org.icse may pittsburgh pa usa association for computing machinery.acm isbn .
.
.
.
introductionsoftware systems persist everywhere in all facets of today s so ciety they drive f inancial institutions facilitate communicationworldwide oversee critical systems and so forth.
software systems however arefrequently distributedwith numerous bugs that willeventually lead to severe disasters.
for example the 5th editionoftricentis.com s annual report shows that software failuresimpact half of the world s population .
billion users and .7trillion in assets it also mentions that there can be far more bugsin the wild than we will likely ever know about .
therefore itis imperative for developers to f ix these bugs as early as possiblewith minimal resource consumption.
however manual bug f ixingcan be extremely tedious challenging and time consuming sincemodern software systems can be extremely complicated .fortunately in lieu of manual bug f ixing researchers have alsoextensively studied automated program repair apr whichaims to automatically f ix software bugs to reduce manual debug ging efforts.
typical apr techniques leverage off the shelf faultlocalization techniques such as ochiai and tarantula to identify potential buggy locations.
then they leverage varioustechniques to generate potential software patches for the potentialbuggy locations.
lastly each generated patch will need to be ex ecuted against the original test suite to f ind theplausiblepatches i.e.
the patches that can pass all the original tests .
note that notall the plausible patches are the ones that developers want thus developers need to further inspect the produced plausible patchesto derive the f inalcorrectones.
to date various apr techniqueshave been proposed including techniques based on prede f ined templates heuristics and constraint solv ing .
furthermore apr techniques have also drawn wideattention from industry e.g.
facebook fujitsu and al ibaba .compared with manual bug f ixing apr can automatically f ixanumber of real world bugs with minimal human intervention andcan be easily integrated with the natural work ow of continuousintegration lifecycle e.g.
facebook s in house tool sapfix hasbeen integrated into its work ow .
despite the promising futureof apr it is not perfect yet and numerous issues still plague thearea.
among the most paramount of these issues are still the timecosts associated with numerous patches for large scale real worldsystems.
existing studies have demonstrated that patch validationdominates the costs of apr since each patch needs to beexecuted against the original test suite.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usasamuel benton yuntong xie lan lu mengshi zhang xia li and lingming zhangto reduce the apr costs researchers have proposed various tech niques to reduce the number of patches generated e.g.
based onmachine learning code mining and constraint solving .however prior work has demonstrated that such techniques canincur the dataset over f itting issue i.e.
the correct patches maybe skipped for many other unstudied cases .
furthermore re searchers have also proposed to prioritize all the generated patchesto f ind the plausible patches earlier.
such existing techniques pri marily utilize static or dynamic information tostaticallyprioritizepatches before the patch validation e.g.
almost all aprtechniques use the suspiciousness values computed by off the shelffault localization techniques to prioritize the patches no furtherreprioritization is employed during the patch validation process ofthese tools leading to limited improvement.in this work we propose seapr self boostedautomatedprogramrepair the f irst general purpose technique to leverage the patch execution information during apr to directly boost existing aprtechniques themselves on the y. our basic intuition is that earlierpatch execution results can help better prioritize later patch exe cutions on the y to speed up the detection of the desired patches e.g.
plausible correct patches .
in this way we promote the rank ing of the patches similar to the executed high quality patches while degrading the ranking of the patches similar to the executedlow quality patches.
more speci f ically we analyze the modi f ied ele ments to compute patch similarities as patches modifying similarprogram elements can exhibit close program behaviors.
we haveevaluated seapr on state of the art apr systems.
our study alsoinvestigates the impact of various con f igurations on seapr e.g.
theformula for patch prioritization the type of patch validation ma trices full or partial the number of code elements considered forseapr and the additional patch pattern information for computingpatch similarity.
lastly our study further evaluates the performanceof seapr with historical patch execution information from otherapr tools on the same buggy program.to summarize this paper makes the following contributions direction.this paper opens a new dimension to leveragepatch execution information to boost existing apr tech niques on the y and can inspire more future work in thisnew direction.
design.we design the f irst technique seapr in this newdirection to update each patch s priority score based on itssimilarity with the executed patches and the quality of theexecuted patches.
extensive study.we have performed an extensive study ofthe proposed technique on state of the art apr systemsfor jvm based languages using the widely studied real worldbugs from defects4j.
practical guidelines.the study reveals various practicalguidelines including the default seapr can substantiallyspeed up thestudied apr techniques by up to withnegligible overhead regardless of various initial patch prior itization strategies used by the studied apr techniques seapr has stable performance when using different formulaefor computing patch priority and different types of patch execution matrices additional patch pattern informationfor patch similarity computation can further substantiallyimprove seapr and seapr can even effectively utilizehistorical patch execution information from other apr toolsto boost current apr tools.
related work2.
automated program repairautomated program repair apr techniques aim to au tomatically f ix software bugs to substantially reduce manual de bugging efforts and have been extensively studied during the lastdecade.
typical apr techniques usually modify program code rep resentations based on various patch generation techniques andthen validate each generated patch e.g.
via testing formalspeci f ication checking and static analysis to f ind the f inal desired patches.
in recent years apr techniques leveragingtesting for patch validation have gained popularity as testing isthe dominant methodology for detecting software bugs in practice.such apr techniques usually include the following phases.
faultlocalization apr techniques f irst leverage off the shelf fault local ization techniques to localize the potential buggylocations.
patch generation apr techniques will leverage variousstrategies to generate potential patches for the identi f ied potentialbuggy locations.
patch validation all the generated patches willbe executed against the original test suite to detect the patches thatpass all the original tests i.e.
plausible patches.
of course sincenot all plausible patches are desirable patch correctness checking often done via manual inspection in practice is further involvedto f ind the f inalcorrect patches which are equivalent to developerpatches.according to a recent study most state of the art apr tech niques can be divided into the following categories.
heuristic based techniquesleverage various heuristics to iteratively explorethe search space of all possible program edits.
for example theseminal genprog technique leverages genetic programmingto synthesize donor code for high quality patch generation whilethe recent simfix technique employs advanced code search toobtain donor code for patch generation.
template based tech niquesleverage prede f ined f ixing templates e.g.
changing to to perform patch generation.
such prede f ined f ixing templatescan be either manually summarized e.g.
kpar or automat ically inferred e.g.
hdrepair from historical bug f ixes.
constraint based techniquestransform the program repair prob lem into a constraint solving problem and leverage state of the art constraint solvers e.g.
smt for patch generation suchas nopol .
more recently researchers have also looked intolearning based techniques to directly generate patches vialearning from historical f ixes.since it is extremely challenging for apr techniques to f ix allpossible bugs researchers have also recently proposed theuni f ieddebuggingwork to extend the application scope of aprto the bugs that cannot be automatically f ixed.
its basic intuition isthat the massive patch execution information during apr can actu ally substantially boost fault localization.
for example if a patchpasses all the tests it means the patch is likely to mute the impactsof the bug even though this patch may not be correct it can thenbe inferred that the patched location is highly related to the actualbuggy location since otherwise the bug effect would not be muted.2166authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards boosting patch execution on the flyicse may pi t tsburgh pa usawith uni f ied debugging even when apr techniques cannot f ixabug uni f ied debugging still can analyze the patch execution infor mation to provide useful hints about potential buggy locations tohelp withmanual repair.
in this way uni f ied debugging extendsthe application scope of apr to all possible bugs not only bugsautomatically f ixable.
inspired by uni f ied debugging we also aimto leverage the wealth of patch execution information generatedduring apr.
meanwhile there are the following major differences.first while uni f ied debugging aims to leverage patch executioninformation formanualprogram repair our seapr leverages suchinformation to directly boostautomatedprogram repair i.e.
weaim to boost existing apr tools by prioritizing the desired plausi ble correct patches earlier in the validation process.
second theirtechnical principles are substantially different.
uni f ied debugginganalyzesthe correlation between patch locations and test outcomesto infer potentially buggy locations while our work analyzesthecorrelation among executed and remaining patchesvia estimatingtheir behavioral similarities to speed up the detection of desiredpatches.
in fact our work is inspired by prior work on mutationtesting which leverages the similarities of modi f ied elementsfor different mutants to perform test prioritization reduction foreach mutant to speed upmutation testing.
.
cost reduction for aprdespite the promising future of apr it can be extremely time con suming due to the generation and validation of a large numberof possible patches.
actually the patch validation cost has beenshown to dominate the overall apr cost .
therefore re searchers have also lookedinto various techniquesto further speedup apr.
to reducethe validation time spent on each patch ghanbariet al.
and chen et al.
proposed to share the same jvmsession across multiple patch executions in this way the patchloading and execution time can be substantially accelerated forboth source code and bytecode level apr techniques.
in addition researchers have also proposed to prioritize and reduce the test exe cutions for each patch to reduce the validation time for each patch.for example qi et al.
proposed trpautorepair to prioritize testexecutions for each patch based on historical information to falsifyimplausible patches faster mehne et al.
f u r t h e rp r o p o s e dt oreduce the number of test executions for each patch since testsnot covering the patched location s cannot help validate the patch.our seapr technique is orthogonal to such existing techniquessince they aim to reduce the execution cost for each patch whileseapr aims to reduce the number of patch executions.to reducethe number of validated patches almost all existingapr techniques leverage fault localization and various other strate gies to reduce the possible patch executions.
furthermore manyexisting apr techniques also leverage other available dynamic orstatic information to prioritize patch executions to f ind the desiredpatches faster e.g.
based on various fault localization informa tion .
despite various cost reduction techniques have beenproposed apr techniques are still rather time consuming for real world programs .
in this paper we propose the f irst techniqueto leverage on the y patch execution information to help betterprioritize patch executions.
note that our technique is orthogonalto all existing patch prioritization techniques and our experimen tal results demonstrate that ourtechnique cansubstantially speedup state of the art apr techniques with various original patchprioritization strategies.
studied approachin this section we f irst present the necessary preliminaries sec tion .
.
then we introduce the detailed seapr approach sec tion .
.
we will also discuss different seapr variants section .
.lastly we will introduce a further extension of seapr to leveragethe patch execution information from other apr tools for evenfaster apr section .
.
.
preliminariesd e.sc f.sc n.sc t.sc o.sc n.sc3.
.patch validation matrix matrixmvde f inesthe validation results of all tests against all patch candidates.
in thematrix each cell describes the validation result of testt tagainstpatchp p. possible values for each cell are as follows iftremains unvalidated iftfails onpand checkiftpasses onp.patch idt1t2t3pb buggy ver.
check p1 p2 check checkp3 p4 check check checkpatch idt1t2t3pb buggy ver.
check p1 p2 check p3 p4 check check checktable example of full partial patch validation matrixideally the patch validation matrix should befull i.e.
every cellshould be checkor .
in practice during the apr process however mostmodern apr tools terminate the test execution for one patch im mediately after observing any failing test on that particular patch since the primary goal is to f ind correct patches and patches whichfail any test cannot even be plausible.
in this way the apr pro cess can be largely sped up without sacri f icing repair effectiveness.not all apr tools employ this strategy so we study both typesof matrices where some tests remain unexecuted partial matri ces versus where all tests always execute full matrices .
table 1presents the example full partial matrices for example patches i.e.
p1 p2 p3 andp4 o n3e x a m p l et e s t s i .
e .
u1d4611 u1d4612 and u1d4613 .
notethat the f irst row for the patch validation matrix is always the testexecution results of the original buggy program i.e.
pb .d e.sc f.sc n.sc t.sc o.sc n.sc3.
.patch modi f ication matrix matrixmmpresentsall program elements modi f ied within each patch.
each cell describesif patchp pmodi f ies elemente e i.e.
all possible program el ements .
acceptable values for each cell are as follows checkifpmodi f ies elementeand ifpdoes not modify elemente.patch id u1d4521 u1d4522 u1d4523 u1d4524modi f ied element s p1 check check check u1d4521 u1d4522 u1d4523 p2 check check check check u1d4521 u1d4522 u1d4523 u1d4524 p3 check check u1d4522 u1d4523 p4 check u1d4521 table example of patch modi f ication matrixtable presents an example patch modi f ication matrix for theabove four example patches on four program elements.
in this2167authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usasamuel benton yuntong xie lan lu mengshi zhang xia li and lingming zhangway sincep1patches program elements u1d4521 u1d4522 u1d4523 the f irst threecolumns are checkforp1.
note that the patch modi f ication matrix canbe de f ined at different levels e.g.
at the package class method andstatement granularities depending on the granularity of consideredprogram elements.
in this paper we mainly consider the methodgranularity e.g.
the columns will be the methods modi f ied by eachprogram patch.
compared with the patch validation matrix thepatch modi f ication matrix can be computed much faster in factwith negligible overhead and thus can beleveraged to speed upthe patch validation process.
.
basic seaprgiven the above introduced patch validation matrix and patch modi f ication matrix which are readily available for almost all aprtools for the already executed validated patches our seapr per forms on the y patch prioritization to speed up apr.our basicintuition is that patches similar to executed high quality patchesare likely to also be high quality and should therefore be prioritizedearlier likewise patches rather similar to executed low qualitypatches should be deprioritized.
in this section we f irst introduceour de f initions for patch quality section .
.
then we introducethe detailed strategy to compute patch similarity with high or low quality patches section .
.
next we introduce our f inal priorityscore computation for all unexecuted patches section .
.
lastly we present our overall algorithm section .
.
with correspondingexamples section .
.
.
.
.
patch q uality.when processing patches that have been exe cuted validated we need to estimate the patch s quality by analyz ing the patch validation matrix.
intuitively the ultimate goal of apris to produce plausible correct patches that can pass all the originaltests.
therefore in this study a patch is classi f ied as high quality patches we wish to prioritize if it can makeany originally failingtest pass likewise a patch is classi f ied as low quality patches wewish to deprioritize if it cannot make any originally failing testpass.
formally the set of high quality and low quality patches canbe de f ined as equations and respectively.ph p t mv check mv pl p t mv mv uni2260 check note that we can also easily compute the detailed number of origi nally failing tests that now pass on apatch however prior work hasdemonstrated that the detailed test number can be misleading .of course this is just the f irst work in this new direction and wehighly encourage other researchers to investigate other better waysto estimate patch quality.
.
.
patch similarity.after calculating patch quality for executedpatches we iterate through all remaining patches withinptocompute their similarity information with the executed high low quality patches.
for each patchpthat has not been validated yet we compare its patch modi f ication matrix information against thatof each of the validated patches.
during the comparison we com pute the number of elementsmatchinganddifferingamong thetwo compared patches i.e.
two rows in the patch modi f icationmatrix .
we calculate the number of matching elements by perform ing theset intersectionon the two patch modi f ication matrix rowsrepresenting the two patches.
likewise we calculate the number ofdiffering elements by performing asymmetric set difference i.e.
a b a b b a on the two patch modi f ication matrix rowsrepresenting the two patches.based on the similarity dissimilarity with high low quality patches we can compute the following tuple for each unvalidated patchpfor prioritization s uni210e d uni210e s u1d459 d u1d459 .
our basic idea is thats uni210eshouldget increased whenpshares elements with high quality patches s u1d459should get increased whenpshares elements with low qualitypatches d uni210eshould get increased whenphas set difference withhigh quality patches andd u1d459should get increased whenphas setdifference with low quality patches.
since the detailed number ofthe matching different modi f ied elements between two patches cantell the detailed similarity dissimilarity information the incrementshould also consider such detailed information.
in this way theformulae for computing the tuple for each unvalidated patchpare s uni210e summationtext.1p prime e e mm mm p ph s u1d459 summationtext.1p prime e e mm mm p pl d uni210e summationtext.1p prime e e mm mm p ph d u1d459 summationtext.1p prime e e mm mm p pl note thatmm denotes the set of program elements modi f iedby patchp.
for example if a validated patchp is high quality andshares elements with the currentp thes uni210eofpis then increased for mm mm .
all the other tuple elements can be de f ined ina similar way.
.
.
patch prioritization.based on the similarity tuple we com puted from the previous step we can compute the priority score foreach unvalidated patch based on the following intuition a patchmore similar dissimilar with high quality patches should be promot ed degraded a patch similar dissimilar with low quality patchesshould be degraded promoted.
actually such intuition is quite sim ilar to traditional spectrum based fault localization sbfl where the intuition is a program element executed unexecutedby more failed tests should be more less suspicious a programelement executed unexecuted by more passed tests should be less more suspicious.
in this way all the traditional fault localizationformulae can be directly leveraged here to compute the patch pri ority.
we use the ochiai formula shown in equation as ourdefault formula as it is often the default formula for sbfl .in this way patches will be promoted demoted if they are simi lar dissimilar with other high quality patches consistent with ourintuition.ochiai s uni210e radicalbig s uni210e d uni210e s uni210e s u1d459 .
.
overall algorithm.given the above de f initions we can nowpresent the overall seapr algorithm.
shown in algorithm seapr f irst initializes the similarity tuples of all patches considered forseapr as 1s1 line .
then seapr iterates through all such patchesand validates them in order lines .
during each iteration seapr f irst gets the patchpwith the highest priority and pops thatfrom the patch listp.
note that for the patches with tied seaprpriority scores e.g.
all patches are tied before the f irst patch execu tion seapr prioritizes them with their original ordering from the1note that they are initialized as 1s not 0s for numerical stability.2168authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards boosting patch execution on the flyicse may pi t tsburgh pa usaalgorithm seapr algorithminput the original buggy programpb test suitet the list of candidate patchespconsidered for seapr the similarity tuples s uni210e s u1d459 d uni210e d u1d459 output plausible patches p check1begin2initialize s uni210e s u1d459 d uni210e d u1d459 for all patches3whilepis not emptydo4p pop p pop the remaining patch with the highest priority5mv execute p t validatep6ifpisplausiblethen7p check p putpinto the resulting set for manualinspection8r computepatchquality p pb mv incrementally update the similarity tuples for the remainingpatches9forp pdo10ifr high qualitythen11s uni210e mm mm 12d uni210e mm mm 13ifr low qualitythen14s u1d459 mm mm 15d u1d459 mm mm 16p computepriorityscore p s uni210e d uni210e s u1d459 d u1d459 corresponding apr tools.
then seapr executes the patch againstthe original test suite and stores the patch execution results intothe patch validation matrixmv line .
ifpis a plausible patch itwill be stored in the resulting setp checkfor manual inspection lines6 .
to help with on the y patch prioritization seapr computesthe patch quality information for the current patch following sec tion .
.
line .
next seapr goes through all the remainingpatches to update their similarity tuples following section .
.
lines .
note that all remaining patches will be compared withthe newly executed patch to incrementally update their correspond ing similarity tuples.
lastly the priority scores for all remainingpatches will be updated based on the updated similarity tuplesfollowing section .
.
line .
in this way the algorithm willproceed until all patches have been validated or the developers f indthe desired patch.note that the time complexity of the seapr algorithm is u1d442 u1d45b2 at f irst glance u1d45bdenotes the number of patches considered for seapr since all the remaining patches need to be updated after each patchexecution.
meanwhile during our implementation we realize thatthe similarity scores do not need to be updated for each remainingpatch instead we can cluster all remaining patches based on the setof program elements they modify since all patches with the sameset of modi f ied elements will have the same priority.
in this way the time complexity can be reduced to u1d442 u1d45b u1d45a where u1d45adenotesthe number of patch clusters with the same modi f ied element sets.given u1d45a u1d45bin practice our actual seapr implementation incursnegligible overhead.
.
.
example.let us now use the partial patch validation matrix2 shown in table and its corresponding patch modi f ication matrix shown in table as the example to illustrate our seapr technique.for this example if we follow the original patch execution ordering top down we need to execute four patches before f inding the f inalplausible patch.
now we discuss how our seapr canhelp speed upthis process.2note that we use partial since most apr tools will collect partial matrices but ouridea generalizes to full matrices as studied in section .
.shown in tables and column quality describes the patches actual quality available after the corresponding patch validation column match describes the set of matching elements against thelast executed patch for each patch column differ describes theset of differing elements against the last executed patch for eachpatch columns s uni210e d uni210e s u1d459 and d u1d459 represent theaccumulatedsimilarity tuples per patch initialized as 1s lastly column score represents the ochiai priority score as de f ined in equation .in the f irst iteration shown in table seapr will computethe quality of the executed patch p1 marked with gray .
we canimmediately determine that the patch is low quality simply becauseit cannot make any originally failing tests pass.
note that we alsoshow the quality for all other unexecuted patches to illustrate thequality computation.
then givenp1has been executed we canupdate the similarity tuple for each remaining patch.
for example forp2 the set intersection and symmetrical set difference withp1is u1d4521 u1d4522 u1d4523 u1d4521 u1d4522 u1d4523 u1d4524 u1d4521 u1d4522 u1d4523 and u1d4521 u1d4522 u1d4523 u1d4521 u1d4522 u1d4523 u1d4524 u1d4524 respectively.
therefore sincep1is a low quality patch s u1d459increments by andd u1d459increments by forp2 resulting in thetuple s uni210e d uni210e s u1d459 d u1d459 .
similarly we can computethe similarity tuples for all the other remaining patches.
then viaapplying the default ochiai formula on the computed tuples wecan compute the priority scores for all the three remaining patchesas shown in column score in table .
in this way the patch withthe highest priority p4 is selected for the next patch execution.in the second iteration p4gets executed marked in gray asshown in table .
note thatp4is a plausible patch that can passall tests.
therefore the developers can immediately start manualinspection to check ifp4is the correct patch.
of course the patchexecution can still continue ifp4is not the correct patch.
continuingthe algorithm the remaining patches will be further compared withthe newly executedp4to update their similarity tuples.
for example forp2 the set intersection and symmetrical set difference withp4is u1d4521 u1d4522 u1d4523 u1d4524 u1d4521 u1d4521 and u1d4521 u1d4522 u1d4523 u1d4524 u1d4521 u1d4522 u1d4523 u1d4524 respectively.
sincep4is a high quality patch p2 s tuple is updatedby incrementings uni210eby andd uni210eby resulting in the tuple s uni210e d uni210e s u1d459 d u1d459 .
in this way we can compute the scoresfor all remaining patches.idqualitymatchdiffers uni210ed uni210es u1d459d u1d459scorep1low p2high u1d4521 u1d4522 u1d4523 u1d4524 .32p3low u1d4522 u1d4523 u1d4521 .35p4plausible u1d4521 u1d4522 u1d4523 .41table seapr step by step when processingp1idqualitymatchdiffers uni210ed uni210es u1d459d u1d459scorep1low p4plausible p2high u1d4521 u1d4522 u1d4523 u1d4524 .33p3low u1d4521 u1d4522 u1d4523 .22table seapr step by step when processingp4for this example we observe that the original patch executionordering requires patch executions to f ind the f irst plausible patch while our seapr reduces the number of required patch executionsto only i.e.
patch reduction.
in this way the devel opers can start manual patch inspection as soon as after patchexecutions.2169authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usasamuel benton yuntong xie lan lu mengshi zhang xia li and lingming zhang3.
seapr variants3.
.
patch prioritization formulae.besides ochiai other sbflformulae can also be applied here.
in particular we study all sbflformulae from prior work in section .
.
.
.
validation matrix types.besides the partial patch validationmatrices widely used in practice we also consider the impact offull validation matrices on seapr in section .
.
.
.
additional patch pa t tern information.by default seapr onlyuses the set of modi f ied program elements to calculate patch similar ity for prioritizing patches on the y. another seapr extension isto compute the similarity score with additional information.
there fore in section .
we further study another seapr variant whichadditionally considers that patches sharing the same f ixing pat terns may also share similar program behaviors.
in this way wecan promote patches applying the same f ixing patterns as knownhigh quality patches to further boost seapr.d e.sc f.sc n.sc t.sc o.sc n.sc3.
.patch repair pa t tern matrix matrixmppresents the applied repair patterns applied to each patch.
each celldescribes if patchp papplies repair patternr r i.e.
all prede f inedrepair patterns .
acceptable values for each cell are as follows checkifpapplies patternrand otherwise.seapr featurespatch id u1d45f1 u1d45f2 u1d45f3modi f ied element s pattern s p1 check u1d4521 u1d4522 u1d4523 u1d45f1 p2 check u1d4521 u1d4522 u1d4523 u1d4524 u1d45f2 p3 check u1d4522 u1d4523 u1d45f3 p4 check u1d4521 u1d45f2 table example of patch repair pattern matrixthis variant only slightly differs from the default seapr whencomputing patch similarity e.g.
this variant considers both theset of modi f ied elements and the applied repair patterns.
basedon the above patch pattern matrix de f inition we can recomputethe similarity tuples for further improving seapr e.g.
s uni210e inequation becomes s uni210e summationdisplay.1p prime e e mm mm p ph summationdisplay.1p prime r r mp mp p ph .
further leveraging apr results fromother toolsin practice one repair tool is often insu cient to successfully f inda correct patch.
thus developers often need to run multiple repairtools to automatically f ix a bug.
currently different repair toolsare run in isolation.
our basic idea is thatthe execution results ofother repair tools on the same programcan be used to furtherboost the current repair tool under seapr.in particular we use therepair information fromall but onerepair tools to initialize thepriority score of all patches.
for example when applying seaprto tbar on chart all patch executions results of other tools onchart will be treated as the already executed patches to initializethe priority scores of all tbar patches on chart .
with the priorityscores initialized seapr starts with the most prioritized patch andfollows the algorithm outlined in algorithm updating the alreadyinitialized priority scores of each patch.
in this way seapr can geta jumpstart for faster validation.
experimental design4.
research questionsin this paper we study the following research questions rq1 how does the default seapr perform on state of the art apr systems?
rq2 how do different prioritization formulae impact seapr?
rq3 how do full patch validation matrices impact seapr?
rq4 how does seapr perform when leveraging additionalpatch pattern information?
rq5 how does seapr perform when further leveraginghistorical repair information from other apr systems?note that we f irst study our default seapr con f iguration withthe ochiai formula partial patch validation matrices similaritycomputation based on modi f ied elements in rq1.
then in rq2 andrq3 we investigate the impact of different formulae and types ofpatch validation matrices to study the robustness of seapr.
in rq4 we leverage the additional patch pattern information available forstate of the art template based apr techniques to furtherboost the effectiveness of seapr.
lastly in rq5 we investigatewhether historical patch validation information from other aprtools can help achieve even more effective seapr for the currentapr tool.
.
evaluation datasetwe choose to evaluate seapr against defects4j v1.
.
the mostwidely used apr dataset to date which will allow seapr to beeasily compared with and replicated in the future.
the details forthe dataset are shown in table .
column bugs presents thenumber of buggy versions studied for each subject.
columns tests and loc present the number of junit tests and lines of codeavailable within the head i.e.
most recent version of each subject respectively.
for each studied buggy version the average numberof failing tests is .
ranging from to .
please also note thatph the set of high quality patches which is closely related to seapreffectiveness is not necessarily related to the number of failed testssincephpatches can pass the failed test s but fail on the otheroriginally passing tests i.e.
equation does not check whetherthe originally passing tests still pass .
for example for the recentprapr tool there are high quality patches for each bug versionon average.subjectname bugs testslocchartjfreechart262 20596klangapache lang652 24522kmathapache math1063 60285ktimejoda time274 13028kmockitomockito framework381 36623kclosuregoogle closure compiler1337 92790ktotal39521 475344ktable studied bugs from defects4j v1.
.02170authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards boosting patch execution on the flyicse may pi t tsburgh pa usa4.
studied apr toolsfollowing prior work we consider program repair toolspublicly available and applicable to defects4j in this study showin table .
of these tool candidates we exclude acs dynamoth and nopol due to low numbers of patches generated i.e.
500total patches across all studied defects4j projects .
evaluating ourtechnique on such tools with small numbers of patches will inducenoise into our results also in practice it is not necessary to performon the y patch prioritization on such tools with a small numberof patches.
we further exclude sim f ix since the tool stops execu tion after f inding the f irst plausible patch.
the validation resultsof such tools cannot be degraded since the last patch is alwaysthe desired plausible patch results from such tools can only beimproved biasing our f indings.
in total we studied repair toolsin this paper.
note that arja genprog a and jgenprog generatenew patches based on patch executions from earlier iterations dueto their evolutionary design.
therefore we should also have ex cluded these tools however we decided to include these toolssimply to demonstrate the potential bene f its of seapr excludingthem also does not affect our f indings as their results are consistentwith other tools .
note that among all the three categories of aprtools the template based tools have been widely recognized as thestate of the art and can generate a large number of patches.therefore the template based apr tools are the main focus of ourtechnique and study.tool categorytool s constraint basedacs cardumen dynamoth nopol heuristic basedarja genprog a jgenprog jkali jmutre pair kali a rsrepair a sim f ix template basedavatar fixminer kpar prapr tbar table repair tools under consideration4.
evaluation metricswe have adopted the following two evaluation metrics the reduc tion on the number of patch executions before f inding the f irstplausiblepatch and the f irstcorrectpatch.
we study sincein practice developers will begin manual inspection after the f irstplausible patch is found in this way faster plausible patch detec tion can enable developers to start manual inspection earlier andpotentially speed up the apr process .
similarly we study sincedevelopers will stop the patch validation process once the correctpatch is found in this way faster correct patch detection can saveoverall apr time.
also note that we mainly leverage the reduc tion on the number of patch executions as recommended by priorwork since time costs are dependent on many factors e.g.
spe ci f ic implementations and test execution engines unrelated to aprapproaches and are often unstable.
furthermore we also discussthe results of time costs in section .
.to this end our primary evaluation metric patch reduction can be computed as u1d443 u1d44f u1d44e u1d460 u1d452 u1d459 u1d456 u1d45b u1d452 u1d443 u1d45b u1d452 u1d464 u1d443 u1d44f u1d44e u1d460 u1d452 u1d459 u1d456 u1d45b u1d452.p u1d44f u1d44e u1d460 u1d452 u1d459 u1d456 u1d45b u1d452represents the positionof the f irst desired i.e.
plausible correct patch pre prioritization.p u1d45b u1d452 u1d464represents the position of the f irst desired plausible correctpatch post prioritization.
note that when multiple desired patchesare produced the initial desired patch and the f inal desired patchare not necessarily the same patch.
.
experimental procedurefor each studied apr tool we evaluate the effectiveness of seapron all patches that can be generated and validated by the tool withinits original time limit used in its original paper .
we f irst analyzethe original execution of each tool on a subject by subject basisto obtain the original patch execution ordering per repair tooland the position of the earliest plausible correct patch.
afterinformation collection we then repeat the patch validation processfor each tool again with our seapr on the y patch prioritization.for each given subject seapr initially executes the f irstpatchproduced by the tool.
after the f irst patch execution seapr iteratesthrough all patches not yet validated following algorithm torecord the new position for the f irst plausible correct patch.
notethat when computing patch similarity based on patch modi f icationinformation seapr will only be applied to the patches belongingto the top methods since most apr tools only patch such topmethods the impact of applying seapr to different numbers of topmethods is also studied in section .
.
the remaining patches aresimply executed with their original ranking.all our experiments were conducted within the following en vironment .0ghz intel xeon platinum processors 60gb ofmemory and ubuntu .
.
lts operating system.
result analysis5.
rq1 overall seapr e ectiveness5.
.
q uantitative analysis.in this section we f irst investigatethe overall effectiveness of our default seapr on all studiedrepair tools against defects4j.
table shows the patch reductionin terms of the f irstplausible patches.
in this table column 1presents the apr systems studied in this work columns and 3present the average rank of the f irst plausible patches before andafter applying seapr to each studied apr system while columns4 and present the absolute improvement and the reduction ratioachieved by seapr.
note that not all the studied apr tools cangenerate plausible patches for all the studied bugs.
therefore inthis table for each apr tool we only present the results for thebuggy versions on which it can produce plausible patches.
fromthis table we have the following observations.
first seapr im proves the overall effectiveness of patch validations for almost allrepair tools.
for example seapr reduces patch validation by .
on genprog a and .
on avatar.
meanwhile seapr slightlydegrades the performance of cardumen.
one reason is that cardu men only generates a small number of patches for the few buggyversions with plausible patches leaving limited room for furtherimprovement.
second the seapr reduction rates tend to be higherfor apr systems with more patch executions i.e.
the apr systemsthat tend to be more expensive and need more optimizations .
forexample the reduction rate is above for all apr systems withover patch executions before the f irst plausible patch beforeapplying seapr and is above for all apr systems with over 200patch executions before the f irst plausible patch before applyingseapr.
this further demonstrates the effectiveness of seapr inboosting potentially expensive apr systems.similarly table further shows the patch reduction ratios for f inding the f irstcorrect patches.
in this table for each apr tool we only present the results for the buggy versions on which it can2171authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usasamuel benton yuntong xie lan lu mengshi zhang xia li and lingming zhangproduce correct patches.
note that there exists no precise infor mation on the number of correct patches reported in the originalor subsequent papers for genprog a rsrepair a and kali a as well as prapr due to the large number of plausible patchesgenerated at the bytecode level .
for jkali and jgenprog wecannot generate any correct patches as reported by the tool s origi nal paper likely due to the tools nondeterminism and differentexecution environments.
therefore we exclude these six repairtools from table .
we can f ind that seapr can achieve even higherpatch reduction rates in terms of the f irst correct patch comparedwith reductions for the f irst plausible patches .
for example seaprimproves the overall performance of arja avatar jmutrepair kpar and tbar by .
.
.
.
and .
respectively.another interesting f inding is that seapr does not degrade the per formance of any of the studied tools although some tools remainunimproved.
note that the patch reductions for correct patches donot apply to all studied repair tools.
also the results are mainlyconsistent with and even better than that for plausible patches since seapr aims to improve the ranking of plausible patches whilewhether a plausible patch is correct is orthogonal to our technique.therefore we use patch reductions for plausible patches for allfollowing rqs due to the space limit.apr systemsorig.
rankseapr rankdiff.reductionarja203.
.
.
.
avatar57.
.
.
.
cardumen10.
.
.
.
fixminer85.
.
.
.
genprog a226.
.
.
.
jgenprog10.
.
.
.
jkali6.
.
.
.
jmutrepair25.
.
.
.
kali a25.
.
.
.
kpar76.
.
.
.
rsrepair a105.
.
.
.
tbar55.
.
.
.
prapr2052.
.
.
.
table default seapr results for plausible patchesapr systemsorig.
rankseapr rankdiff.reductionarja355.
.
.
.
avatar44.
.
.
.
cardumen17.
.
.
.
fixminer3.
.
.
.
jmutrepair28.
.
.
.
kpar58.
.
.
.
tbar33.
.
.
.
table default seapr results for correct patches5.
.
q ualitative analysis.next we present detailed examples toinvestigate the performance of seapr.
we f irst look into caseswhere seapr can help boost apr example figure 1a shows one of the low quality patches pro duced by arja on chart while figure 1b shows one of severalgenerated plausible patches.
note that these two patches modifydifferent f iles.
in this example we observe how low quality patchesmay help prioritize plausible patches.
according to our technique other patchessharing similar modi f ied elementswith these low quality patches aredeprioritized.
thus as any low quality patch ...public voidsetrangeaxis intindex valueaxisaxis s e t r a n g e a x i s i n d e x a x i s true a low quality patch protected intindexof object object ... return if object null throw newillegalargumentexception !null quotesingle.varobject quotesingle.var argument.!
return b plausible patchfigure arja chart patches nodemismatch checktreeequalsimpl node node2 ...res n.checktreeequalsimpl n2 if res !
null returnres return null ... a high quality patch nodemismatch checktreeequalsimpl node node2 ...node n n2 for n first n2 node2.first res null n !
null n n .
n e x t n n .
n e x t n n n n .
n e x t if node2 null throw newillegalstateexception ... b plausible patchfigure prapr closure patchesmodifying one particular set of methods is validated all other sim ilar patches are deprioritized.
this essentially results in theclustering of patches based on the set of modi f ied methods and prioritizing deprioritizing these clusters.
upon validation ofconsecutive low quality patches this phenomenon culminates to abreadth f irst exploration of the patch clusters mitigating the riskof some high quality patches getting starved.
this process repeatsuntil arja f inds plausible patch from figure 1b.
with seapr weobserve arja validates the plausible patch 33rd instead of 626th apatch reduction of .
.example since prapr tends to generate substantially morepatches than other apr tools we further present how seapr canhelp prioritize the plausible patches for prapr.
thenon plausiblehigh quality patchgenerated by prapr as shown in figure 2a modi f ies methodnodemismatch.checktreeequalsimpl node node2 and is able to pass some originally failed tests since the method isquite in uential for the failed tests.
in this way it can help substan tially improve the ranking of a plausible patch modifying the samemethod as shown in figure 2b .
after applying seapr the f irstplausible patch can be ranked at 46th now at 3165th originally apatch reduction of .
.since seapr is a heuristic based technique it does not work forall cases.
therefore we also look into the negative cases 2172authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards boosting patch execution on the flyicse may pi t tsburgh pa usa public classstrbuilderimplementscloneable publicstrbuilder string str ...buffer new char else buffer new char append str ... a non matching high quality patch public classstrbuilderimplementscloneable private voiddeleteimpl intstartindex intendindex intlen s y s t e m .
a r r a y c o p y buffer endindex buffer startindex size endindex s y s t e m .
a r r a y c o p y buffer endindex buffer startindex capacity endindex size len ... b plausible patchfigure prapr lang patches public final classmathutils public static booleanequals double x double y ...for inti i x .
l e n g t h i if !equals x y if !equals x y x.length !
y.length return false ... a low quality patch public final classmathutils public static booleanequals double x double y ...for inti i x .
l e n g t h i if !equals x y if !equals x y i return false ... b plausible patchfigure tbar math patchesexample figure 3b presents the only plausible patch producedby prapr on lang which modi f ies methoddeleteimpl int int int .
however variousnon plausible high quality patchesgenerated by prapr modify a number of other methods such as thepatch shown in figure 3a modifyingstrbuiler string .
afterdetecting such high quality patches other patches sharing the samemodi f ied elements are prioritized causing some patches originallyranked below the plausible patch to be executed earlier.
as a result the rank of the plausible patch is degraded from 182nd to 347th.example the only plausible patch which is also the only high quality patch generated by tbar for math is shown in figure 4b.however as depicted in figure 4a there are many other patcheswhich modify the same method as the plausible patch but cannotmake any original failing tests pass.
many of such low qualitypatches are originally ranked above the only plausible patch.
as aresult validation of these patches will degrade the execution of theplausible patch.
eventually the plausible patch initially ranked at28th is then degraded to 55th.finding seapr can substantially reduce patch executionsbefore f inding the f irst plausible correct patches for almost allstudied repair tools with a maximum improvement of .
plausible .
correct .
figure impact of di erent formulae on patch reduction5.
rq2 impact of di erent formulaein rq1 we studied seapr with the ochiai formula.
in fact seapris a general approach and can leverage any other existing sbflformula.
therefore in this rq we further investigate the impactof different sbfl formulae on the effectiveness of seapr.
figure 5shows the experimental results of widely studied sbfl formu lae on the repair tools in terms of patch reduction.
fromthe results we observe that seapr reduces the patch validationsof studied sbfl formulae across almost all repair tools by up to78.
genprog a with kulczynski and jaccard .
furthermore fordifferent sbfl formulae the overall patch reduction on all the stud ied tools is rather stable.
for example the formula with the bestoverall improvement is sbi .
and the formula with the worstperformance is op2 .
i.e.
the difference of all studied for mulae is only .
percentage points pp .
op2 performs worse thanthe other formulae because it mainly considers thes uni210einformationwhile largely ignoring other valuable information from the simi larity tuples demonstrating the importance of all the informationtraced by seapr.finding all studied formulae achieve stable performance speeding up the overall validation by at least .
demon strating the effectiveness of our design.
.
rq3 impact of full validation matrixwe now have studied seapr with the default partial patch validationmatrices.
in this section we further investigate the performance ofseapr with full patch validation matrices.
figure presents thepatch reductions achieved by seapr with the partial and full patch validation matrices.
from this f igure we see that seapr can achievesigni f icant reductions on both full and partial patch validation ma trices indicating the general applicability of seapr.
for example the overall reduction by seapr with the partial full matrices is28.
.
on all studied tools.
interestingly despite the over all positive reductions seapr degrades the performance of somerepair tools when using full matrices e.g.
the patch reduction onarja changes from .
with partial matrices into .
withfull matrices .
one possible reason for why seapr performs a bitworse with full matrices is that a signi f icant portion of low quality2173authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usasamuel benton yuntong xie lan lu mengshi zhang xia li and lingming zhang arjaavatarcardumenfixminergenprog ajgenprogjkalijmutrepairkali akparpraprrsrepair atbarpatch reductionvalidationmatrixfull matrixpartial matrixfigure impact of validation matrices on seaprspatches with partial matrices are considered high quality patcheswith full matrices since full matrices execute all tests against eachpatch and can potentially make more failing tests pass.finding seapr substantially reduces patch executions onboth partial and full patch validation matrices and tends toperform slightly better with partial matrices.
.
rq4 impact of additional patch patterninformationin this rq we examine the impact of utilizing additional informa tion for computing patch similarity.
we execute the default con f igu ration of seapr and compute patch similarity using both the setof modi f ied elements and the applied patch patterns.
we achievethis by looking speci f ically only at tools which apply prede f inedrepair patterns i.e.
those tools categorized astemplate based.
notethat we collect the applied f ix patterns as directly implemented byeach tool.
the studied template based tools are tbar kpar avatar and prapr with and repair patterns respectively.3table shows the result of this con f iguration evaluated againstour default seapr setting.
in this table column presents the aprsystems studied in this rq column presents the reduction resultswhen using the method location information to compute patchsimilarity i.e.
the default seapr column presents the reductionresults when using only the new patch pattern information tocompute patch similarity f inally column presents the reductionresults when combining both method and patch pattern informationfor computing patch similarity.
from the table we distinctly observethat seapr with only method location information or patch patterninformation can both achieve nontrivial reductions.
for example the reduction rates range from .
tbar to .
prapr when only using method location information while ranging from31.
kpar to .
avatar when only using patch patterninformation.
furthermore the seapr with both method locationand patch pattern information can achieve even high reductions.for example the reduction rates now range from .
to .
for all the four studied apr systems.finding patch pattern information further improves seapr sperformance on all studied repair tools by up to .
pp.
fur thermore seapr with only patch pattern information canalso achieve competitive patch reduction.3please note we excluded fixminer as we failed to dump its f ixing pattern information.methodpatternmethod patternavatar54.
.
.
kpar17.
.
.
tbar10.
.
.
prapr62.
.
.
table seapr with patch pattern information arjaavatarcardumenfixminergenprog ajgenprogjkalijmutrepairkali akparpraprrsrepair atbarpatch reductiontechseaprseapr historyfigure seapr with historical apr results from other tools figure impact of top method number on patch reduction5.
rq5 boosting seapr via other apr toolsfigure shows the impact of historical information for our defaultcon f iguration following section .
.
note we f ilter out all knowncorrect patches from the historical information from other aprtools since developers will stop the repair process after f indingany correct patch with other tools thus alleviating the need forseapr.
compared to table we observe improvements acrossmost repair tools up to .
pp kali a .
most notably the onlytool with originally negative performance cardumen now has34.
reduction i.e.
over pp improvement.
on the other hand the only instances of degradation come from genprog a avatar tbar and prapr.
the maximum degradation is only .
pp i.e.
tbar degrades from .
to .
while the degradation is lessthan pp and the reductions are still positive for all other instances.overall such historical information can further boost seapr by18.
pp on average for all the studied apr tools.finding supplementing seapr with patch execution in formation from other repair tools can further boost seapr.this extra historical information compared with seapr sdefault con f iguration can further boost seapr by .
ppon average and up to .
pp.
2174authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards boosting patch execution on the flyicse may pi t tsburgh pa usa5.
discussion5.
.
impact of top methods considered.as shown in section .
to avoid degrading high quality or plausible patches to the veryend of all patches for different modi f ied locations we by defaultapply seapr to the top methods for the programs under test.in this section we further investigate the effectiveness of seaprwhen applied to different numbers of top methods.
figure showsthe experimental results for applying seapr to top to top 100methods with the interval of .
in this f igure the x axis showsthe number of top methods considered for seapr while the y axispresents the corresponding reduction achieved by different aprsystems denoted by colored lines .
according to the f igure wehave the following observations.
first the reduction rates increasedramatically for almost all apr systems when increasing the num ber of top methods from to .
the reason is that seapr willhave the chance to improve more patches when more top methodsare considered for seapr.
second the reduction rates for most aprsystems will become stable when seapr is applied to beyond top20 methods.
one reason is that for all other apr systems exceptprapr they rarely patch more than methods in a program undertest making the seapr results largely unchanged when consideringmore than top methods.
meanwhile we can observe that evenfor prapr the purple line which can patch far more methods thanother apr systems the reduction rate is still all positive indicatingthe scalability and wide applicability of seapr.
.
.
seapr overhead.the seapr algorithm is only related to thepatch validation phase which is a pretty standard thing across aprtools.
therefore the changes are minimal for applying seapr overexisting apr tools.
it is also important to analyze the overheadof seapr since it does not pay offif seapr itself is extremelycostly.
interestingly we found that although seapr s overheadoften increases when considering more top methods the averageoverhead for running seapr on each buggy version never exceeds2s for any of the apr tools studied even when considering topmethods .
the reason is that our implementation has been highlyoptimized as shown in section .
.
.
such overhead is negligiblefor apr tools which typically take hours to f ix a bug.
.
.
nondeterminism in apr tools.we currently report the re sults for one run since our goal is to speed upstate of the artapr techniques while the recent state of the art apr techniquesare mostly deterministic e.g.
all the studied apr tools that cancorrectly f ix over bugs for defects4j including prapr tbar fixminer avatar are deterministic.
meanwhile to investigate theimpact of apr non determinism on seapr effectiveness we fur ther rerun the experiments for the non deterministic rsrepair aand kali a tools for times.
the experimental results demonstratethat seapr can achieve an average reduction of .
.
forrsrepair a kali a which is similar to the results shown in table .
.
.
metrics.as shown by recent work using time costs forevaluating apr e ciency often depends on many random factors such as the execution environments test execution engines andspeci f ic implementation choices and can be quite unstable.
fur thermore for the same apr tool the reduction in patch executionsis largely proportional to the reduction in time cost since seapr isoblivious to the patch execution time distribution.
therefore wefollowed the recommendation of the prior work and have usedthe number of patch executions as our main metric.
meanwhile it is also important to check if the reduction in terms of patchexecutions aligns well with the reduction in terms of time costs.therefore we further trace the detailed time cost reduction on anexample tool i.e.
state of the art prapr.
the experimental resultshows that the reduction is .
and .
including seaproverhead in terms of patch executions and time cost respectively.this further demonstrates the validity of our used metric.
.
threats to validity5.
.
internal validity.all of our results are dependent on thecorrectness of the implementation of all the studied techniques.we mitigate this threat by obtaining the source code of apr toolsfrom their websites authors.
also three authors implemented threeseparate versions of seapr variants to perform differential testingto ensure the result correctness.
following prior apr work three authors have participated in patch correctness checking toensure the inspection correctness.
still there may be human errorsin the manual inspection process that may affect our f indings.
.
.
external validity.while our approach is generalizable to anytype of patch and validate system we only evaluate java basedapr tools which may skew results.
to mitigate this threat we1 studied a wide variety of apr tools and consider tools ac tively used in recent and related work.
we also actively evaluateour technique on the most widely studied defects4j dataset withhundreds of real world bugs.
adding more benchmark suites cande f initely further reduce this threat.
however some of the studiedapr tools cannot be easily applied to other benchmarks due toimplementation design limitations of the original apr tools .
.
.
construct validity.a major threat to validity lies in our eval uation metrics.
to mitigate this we compute the number of patchexecutions recommended by recent work .
meanwhile we fur ther discuss the reduction results in terms of time cost.
conclusionwe have proposed the f irst self boosted apr technique seapr which leverages the execution information of validated patchesduring apr to prioritize the remaining patches on the y for fasterapr.
our study on state of the art apr systems and the widelyused defects4j benchmark demonstrates that the default seaprcan substantially speed up thestudied apr techniques by up to79 with negligible overhead seapr has stable performancewhen using different formulae for computing patch priority anddifferent types of patch execution matrices additional patch pat tern information for patch similarity computation can further boostseapr and seapr can even utilize historical patch executioninformation from other apr tools to boost current apr tools.acknowledgmentswe appreciate the insightful comments from all the anonymousreviewers.
this work was partially supported by national sciencefoundation under grant nos.
ccf and ccf aswell as ant group.2175authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usasamuel benton yuntong xie lan lu mengshi zhang xia li and lingming zhangreferences tricentis reports .
.
available boulder university of cambridge study accessed jan. .
s. wang m. wen b. lin x. mao h. wu d. zou h. jin and y. qin automatedpatch correctness assessment how far are we?
inproceedings of the 35thieee acm international conference on automated software engineering pp.
.
k. liu a. koyuncu d. kim and t. f. bissyand tbar revisiting template basedautomated program repair inproceedings of the 28th acm sigsoft internationalsymposium on software testing and analysis .
k. liu a. koyuncu d. kim and t. f. bissyande avatar fixing semantic bugswith fix patterns of static analysis violations inproceedings of the ieee26th international conference on software analysis evolution and reengineering .
t. durieux and m. monperrus dynamoth dynamic code synthesis for automaticprogram repair inproceedings 11th international workshop on automation ofsoftware test ast .
m. martinez and m. monperrus ultra large repair search space with automati cally mined templates the cardumen mode of astor inlecture notes in computerscience .
j. jiang y. xiong h. zhang q. gao and x. chen shaping program repair spacewith existing patches and similar code inproceedings of the 27th acm sigsoftinternational symposium on software testing and analysis .
m. martinez and m. monperrus astor a program repair library for java demo inproceedings of the 25th international symposium on software testingand analysis .
y. yuan and w. banzhaf arja automated repair of java programs via multi objective genetic programming ieee transactions on software engineering .
y. lou j. chen l. zhang d. hao and l. zhang history driven build failure f ixing how far are we?
inproceedings of the 28th acm sigsoft internationalsymposium on software testing and analysis .
m. wu l. zhang c. liu s. h. tan and y. zhang automating cuda synchro nization via program transformation inieee acm international conference onautomated software engineering ase .
j. jiang l. ren y. xiong and l. zhang inferring program transformationsfrom singular examples via big code inieee acm international conference onautomated software engineering ase .
f. long and m. rinard automatic patch generation by learning correct code inproceedings of the 43rd annual acm sigplan sigact symposium on principlesof programming languages pp.
.
z. qi f. long s. achour and m. rinard an analysis of patch plausibility andcorrectness for generate and validate patch generation systems internationalsymposium on software testing and analysis pp.
.
f. long and m. rinard staged program repair with condition synthesis inproceedings of the 10th joint meeting on foundations of software engineering pp.
.
f. long p. amidon and m. rinard automatic inference of code transforms forpatch generation inproceedings of the 11th joint meeting on foundations ofsoftware engineering pp.
.
f. long and m. rinard an analysis of the search spaces for generate and vali date patch generation systems inproceedings of the international conference onsoftware engineering .
w. e. wong r. gao y. li r. abreu and f. wotawa a survey on software faultlocalization ieee transactions on software engineering vol.
no.
pp.
.
r. abreu p. zoeteweij and a. j. van gemund on the accuracy of spectrum basedfault localization inproceedings testing academic and industrial conferencepractice and research techniques taic part mutation .
j. a. jones and m. j. harrold empirical evaluation of the tarantula automaticfault localization technique in20th ieee acm international conference on auto mated software engineering ase .
a. ghanbari s. benton and l. zhang practical program repair via bytecodemutation inissta proceedings of the 28th acm sigsoft internationalsymposium on software testing and analysis .
m. wen j. chen r. wu d. hao and s. c. cheung context aware patch genera tion for better automated program repair inproceedings international conferenceon software engineering vol.
january .
c. le goues m. dewey vogt s. forrest and w. weimer a systematic study ofautomated program repair fixing out of bugs for each proceedings ofinternational conference on software engineering pp.
.
j. xuan m. martinez f. demarco m. clement s. l. marcote t. durieux d. le berre and m. monperrus nopol automatic repair of conditional state ment bugs in java programs ieee transactions on software engineering vol.
no.
.
y. xiong j. wang r. yan j. zhang s. han g. huang and l. zhang precise con dition synthesis for program repair inieee acm 39th international conferenceon software engineering pp.
.
a. marginean j. bader s. chandra m. harman y. jia k. mao a. mols anda.
scott sap f ix automated end to end repair at scale inieee acm 41st in ternational conference on software engineering software engineering in practice icse seip pp.
.
r. k. saha y. lyu h. yoshida and m. r. prasad elixir effective object orientedprogram repair inieee acm international conference on automated softwareengineering pp.
.
y. lou a. ghanbari x. li l. zhang h. zhang d. hao and l. zhang canautomated program repair re f ine fault localization?
a uni f ied debugging approach inproceedings of the 29th acm sigsoft international symposium on softwaretesting and analysis .
l. chen y. ouyang and l. zhang fast and precise on the y patch validationfor all in2021 ieee acm 43rd international conference on software engineering icse pp.
.
c. le goues s. forrest and w. weimer current challenges in automatic softwarerepair software quality journal vol.
no.
pp.
.
w. weimer z. p. fry and s. forrest leveraging program equivalence for adaptiveprogram repair models and f irst results inieee acm international conferenceon automated software engineering pp.
.
b. mehne h. yoshida m. r. prasad k. sen d. gopinath and s. khurshid ac celerating search based program repair ininternational conference on softwaretesting veri f ication and validation pp.
.
y. pei c. a. furia m. nordio y. wei b. meyer and a. zeller automated f ixingof programs with contracts ieee transactions on software engineering vol.
no.
.
r. van tonder and c. l. goues static automated program repair for heap prop erties inproceedings of the 40th international conference on software engineering .
a. koyuncu k. liu t. bissyand d. kim j. klein m. monperrus and y. letraon fixminer mining relevant f ix patterns for automated program repair empiricalsoftware engineering .
k. liu a. koyuncu t. bissyande d. kim j. klein and y. letraon you cannot f ix what you cannot f ind!
an investigation of fault localization bias in benchmark ing automated program repair systems proceedings of 12th ieee internationalconference on software testing veri f ication and validation .
k. liu s. wang a. koyuncu k. kim t. f. bissyande d. kim p. wu j. klein x. mao and y. l. traon on the e ciency of test suite based program repaira systematic assessment of automated repair systems for java programs inproceedings of international conference on software engineering .
d. kim j. nam j. song and s. kim automatic patch generation learned fromhuman written patches inproceedings of international conference on softwareengineering .
x. b. d. le d. lo and c. le goues history driven program repair inieeeinternational conference on software analysis evolution and reengineering vol.
pp.
.
l. de moura and n. bj rner z3 an e cient smt solver inlecture notes incomputer science including subseries lecture notes in arti f icial intelligence andlecture notes in bioinformatics vol.
lncs .
t. lutellier h. v. pham l. pang y. li m. wei and l. tan coconut combiningcontext aware neural translation models using ensemble for program repair proceedings of the 29th acm sigsoft international symposium on software testingand analysis pp.
.
y. ding b. ray and v. j. hellendoorn patching as translation the data andthe metaphor inproceedings of the 35th ieee acm international conference onautomated software engineering pp.
.
s. benton x. li y. lou and l. zhang on the effectiveness of uni f ied debugging an extensive study on program repair systems inproceedings of the 35thieee acm international conference on automated software engineering .
evaluating and improving uni f ied debugging ieee transactions on softwareengineering .
l. zhang d. marinov and s. khurshid faster mutation testing inspired by testprioritization and reduction ininternational symposium on software testing andanalysis .
y. qi x. mao and y. lei e cient automated program repair through fault recorded testing prioritization inieee international conference on softwaremaintenance icsm .
j. a. jones m. j. harrold and j. stasko visualization of test information toassist fault localization inproceedings of international conference on softwareengineering .
m. zhang x. li l. zhang and s. khurshid boosting spectrum based faultlocalization using pagerank inproceedings of the 26th acm sigsoft internationalsymposium on software testing and analysis pp.
.
l. gazzola d. micucci and l. mariani automatic software repair a survey ieee transactions on software engineering vol.
no.
.2176authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.