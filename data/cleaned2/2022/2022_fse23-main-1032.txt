heterogeneous testing for coverage profilers empowered with debugging support yibiao yang state key laboratory for novel software technology nanjing university nanjing china yangyibiao nju.edu.cnmaolin sun state key laboratory for novel software technology nanjing university nanjing china merlin smail.nju.edu.cnyang wang state key laboratory for novel software technology nanjing university nanjing china njuwy smail.nju.edu.cn qingyang li state key laboratory for novel software technology nanjing university nanjing china liqingyang smail.nju.edu.cnming wen school of cyber science and engineering huazhong university of science and technology wuhan china mwenaa hust.edu.cnyuming zhou state key laboratory for novel software technology nanjing university nanjing china zhouyuming nju.edu.cn abstract ensuring the correctness of code coverage profilers is crucial given the widespread adoption of code coverage for various software engineering tasks.
existing validation techniques such as differential testing and metamorphic testing have shown effectiveness in uncovering bugs in coverage profilers.
however these techniques have limitations as they primarily rely on homogeneous sources i.e.
different coverage profilers or the profilers themselves for validation.
in this paper we propose decov a novel heterogeneous testing technique to validate coverage profilers using the information provided by debuggers as a heterogeneous source .
coverage profilers record execution counts for each source line in the program while debuggers monitor hit counts for each source line when running the program in debug mode.
our key insight is that the execution counts obtained from coverage profilers should align with the hit counts monitored by debuggers without conflicts.
decov constructs multiple heterogeneous relations and utilizes them to uncover bugs in coverage profilers.
through experiments on gcov and llvm cov two widely used code coverage profilers we discovered new bug reports with of them directly confirmed by developers.
notably developers have resolved bugs in the latest trunk version.
decov serves as a simple yet effective coverage profiler validator and offers a complementary approach to existing techniques.
ccs concepts software and its engineering functionality compilers .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
code coverage coverage profiler bug detection debugging support heterogeneous testing acm reference format yibiao yang maolin sun yang wang qingyang li ming wen and yuming zhou.
.
heterogeneous testing for coverage profilers empowered with debugging support.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
introduction code coverage refers to the execution frequency of code lines in a program under specific inputs.
as a fundamental measure to approximate dynamic program behavior code coverage plays a crucial role in various software engineering practices including software fuzzing test case prioritization fault localization and repair specification mining fault detection and program understanding .
for example in fault localization code coverage of a target program obtained from passing and failing tests is integrated into a spectrum and then suspicious values are computed for each statement based on this spectrum .
however incorrect code coverage information can significantly mislead developers .
therefore ensuring the correctness of code coverage profilers is of utmost importance.
nevertheless code coverage profilers are susceptible to bugs similar to other software systems.
a recent study named c2vhas identified over bugs in two popular coverage profilers by employing a simple randomized differential testing technique .
the effectiveness of c2v s approach can be ascribed to two fundamental factors elucidated in existing literature first the validation of coverage profilers has not received sufficient attention from both developers and academic researchers.
second the absence of effective test oracles makes automatic testing of coverage profilers challenging.
in the context of coverage profiler testing the test oracle refers to the expected execution frequency of each statementesec fse december san francisco ca usa yibiao yang maolin sun yang wang qingyang li ming wen and yuming zhou under a given test input.
unlike conventional oracles used to validate program functionalities obtaining a complete coverage oracle for a target program especially with respect to specific test inputs is extremely challenging.
even if programming experts can specify such precise test oracles for a given program it is impractical due to the significant amount of human intervention required.
to date two approaches have been proposed to validate coverage profilers.
first c2vemploys differential testing to expose bugs by comparing the coverage statistics provided by different coverage profilers .
the fundamental assumption of c2vis that distinct coverage profilers should generate identical coverage for the same program with the same inputs.
however different profilers are typically implemented independently and may define inconsistent coverage semantics.
for example figure a and figure c depict the code coverage reports for the same program obtained by llvm cov and gcov two popular c coverage profilers.
llvm cov reports that line is not executed as shown in figure a while gcov does not provide coverage information for line denoted as in figure c .
however line was indeed executed and c2v missed this bug.
second codproposes the application of metamorphic testing to uncover bugs in coverage profilers by comparing the coverage statistics for path equivalent programs .coddetects bugs by identifying inconsistencies in the coverage statistics generated for the original program and its equivalent mutated variants by a single coverage profiler.
the key insight of codis that when pruning the unexecuted code of a given program with respect to a particular input the coverage statistics of the remaining code should remain unchanged.
codhas been reported to be effective in identifying deep bugs in coverage profilers .
however cod has several limitations such as false negatives.
using the program in figure as an example codprunes line to generate the expected equivalent mutated program as illustrated in figure b .
regrettably even after the pruning of line the coverage statistics for the remaining code remain unchanged leading to a missed bug bycod.
the limitations of both c2vandcodstem from the homogeneous nature of the relations they define.
specifically c2vleverages another coverage profiler while coduses the profilers themselves for validation.
in essence they check whether the homogeneous relations defined against other profilers or themselves are violated.
approach.
to address the limitations of existing approaches we propose decov aheterogeneous testing technique to further testing coverage profilers.
specifically we define heterogeneous relations with the support of the information provided by a heterogeneous source namely debuggers to validate code coverage profilers.
the key insight of decov is that the execution count of a statement obtained from a coverage profiler should not conflict with the hit count obtained by debuggers.
here the hit count represents the number of times a statement has been executed in a debugger.
to discover bugs in profilers assuming the correctness of the compiler and the debugger1 and given a deterministic program pwith a fixed input decov first compilespwith the coverage profiling option e.g.
the coverage option in gcc and then runs the compiled program to obtain its coverage statistics using the coverage profiler.
subsequently decov compilespwith the debugging 1we assume this because with optimization disabled mis compilations and misdebugging are rare.option e.g.
the g option in gcc and feeds the compiled program to a debugger.
using the debugger decov debugspto obtain the hit count for each statement in p.decov employs two distinct debugging strategies to determine the hit count using the debugger.
the first strategy is the break continue approach which sets breakpoints for each statement and then executes the program using the continue command within the debugger to obtain the hit count.
the continue resumes program execution at the address where the program last stopped bypassing any breakpoints set at that address.
the second strategy is the stepping approach where the program is stepped line by line in the debugger to obtain the hit count for each statement.
decov combines these two strategies to obtain the hit count for each statement since relying solely on either strategy cannot accurately represent the actual execution frequencies for each statement see section .
.
for detailed insights .
finally decov compares the coverage statistics obtained by the coverage profiler and the fused hit count for each statement obtained by the debugger to identify potential bugs in coverage profilers.
in other words if the coverage statistic of a statement conflicts with the fused hit count derived from both the break continue strategy and the stepping strategy in the debugger a potential bug is reported.
by leveraging the power of debuggers decov captures more comprehensive execution frequencies of code lines thereby facilitating the detection of deep seated bugs in coverage profilers.
results.
we implemented decov as a tool and investigated its effectiveness on two widely used coverage profilers gcov and llvm cov which are integrated with the compiler of gcc and llvm respectively.
a total of bugs have been reported and of them are confirmed by the associated developers.
in summary we make the following main contributions concept we introduce the novel concept of heterogeneous testing for software validation.
this concept provides a fresh and innovative perspective offering a broad range of potential applications and opening up new avenues for software validation.
originality we leverage the power of heterogeneous testing to validate code coverage profilers by utilizing information obtained from debuggers.
to the best of our knowledge we are the pioneers in harnessing this information source specifically for the purpose of validating coverage profilers.
implementation we have implemented our proposed concept in the form of a prototype called decov .decov serves as a straightforward yet effective coverage profiler validator with integrated debugging support.
it presents an additional and complementary solution for exposing bugs in coverage profilers particularly for newly designed programming languages.
evaluation we conducted an evaluation of decov by applying it to two widely adopted c code coverage profilers.
the evaluation results demonstrate the effectiveness of decov as it successfully uncovered confirmed bugs.
furthermore decov exhibits the capability to detect most of the bugs reported in prior studies thereby providing additional affirmation of its efficacy.
outline.
section briefly describes the background and motivates our study.
section elaborates on our approach in detail.
section presents the experiment setup and section presents the evaluation todecov .
we discuss decov in section and the related works in section .
section concludes our paper.heterogeneous testing for coverage profilers empowered with debugging support esec fse december san francisco ca usa include setjmp.h struct t const int x g typedef struct t s jmp buf b void f longjmp b int main if setjmp b return s const s g g while f a cp llvm cov include setjmp.h struct t const int x g typedef struct t s jmp buf b void f longjmp b int main if setjmp b return s const s g g while f b cp s13 llvm cov include setjmp.h struct t const int x g typedef struct t s jmp buf b void foo longjmp b int main if setjmp b return s const s g g while foo c cp gcov clang g a.c lldb a.out lldb b a.c breakpoint a.out at a.c lldb run s const s g g lldb continue process exited d op lldb figure llvm bug .
llvm cov incorrectly reported that line is not executed as shown in a .
when setting breakpoint at line line is hit by lldb in d .
this bug cannot be detected by codas removing line does not affect the coverage statistics of the remaining code as shown in b .
besides this bug is also missed by c2vas gcov does not provide coverage information for line as shown in c .
denotes that the line is not instrumented and then no coverage information is provided.
a check or cross mark followed by a number ndenotes the execution count of that line.
background and motivation in this section we introduce the background for coverage profilers and debuggers.
then we describe existing coverage validation techniques and discuss their limitations.
.
coverage profilers code coverage refers to the execution frequency of code lines with respect to a program s execution under particular test cases.
the source level coverage information is widely adopted to support many software engineering tasks.
as the most widely used criterion in measuring the testing adequacy of test cases it is deeply used for automated software testing.
for instance in the context of regression testing we often generate test cases covering changed source code to augment a test suite .
to collect code coverage information a compiler needs to emit additional code along with the executable.
along with a program s execution the required information will be generated and later used by coverage profilers.
with the generated runtime information a coverage profiler produces for each code line s p an execution count cp s n. due to the default optimizations within the compiler it is rather common that some source code lines are not instrumented and thus the coverage profiler cannot provide coverage information for those lines.
in this paper we use n 1to denote unknown coverage information.
.
debuggers debuggers are used to locate and fix programming errors in a target program.
it allows developers to see what is going on inside the target program at runtime or what is the target program at the moment it crashes.
in practice popular debuggers such as gdb and lldb support a rich set of debugging actions including setting breakpoints on different program locations stepping program line by line and inspecting program state at runtime such as the stack frame and the values of variables.
with the provided debugging actions developers can start a program make a program stop on specified breakpoints and examine what has happened when the program stops.
this helps developers observe the behavior of thetarget program at runtime.
to aid debugging activities compilers generate debug information together with the machine executable code .
for instance in the case of c compilers users can enable debug information by specifying the g flag.
the debug information contains