vialin path aware dynamic taint analysis for android khaled ahmed yingying wang mieszko lis julia rubin the university of british columbia canada khaledea wyingying mieszko mjulia ece .ubc.ca abstract dynamic taint analysis a program analysis technique that checks whether information flows between particular source and sink locations in the program has numerous applications in security program comprehension and software testing.
specifically in mobile software taint analysis is often used to determine whether mobile apps contain stealthy behaviors that leak user sensitive information to unauthorized third party servers.
while a number of dynamic taint analysis techniques for android software have been recently proposed none of them are able to report the complete information propagation path only reporting flow endpoints i.e.
sources and sinks of the detected information flows.
this design optimizes for runtime performance and allows the techniques to run efficiently on a mobile device.
yet it impedes the applicability and usefulness of the techniques an analyst using the tool would need to manually identify information propagation paths e.g.
to determine whether information was properly handled before being released which is a challenging task in large real world applications.
in this paper we address this problem by proposing a dynamic taint analysis technique that reports accurate taint propagation paths.
we implement it in a tool vialin and evaluate it on a set of existing benchmark applications and on large android applications from the google play store.
our evaluation shows thatvialin accurately detects taint flow paths while running on a mobile device with a reasonable time and memory overhead.
ccs concepts software and its engineering theory of computation program analysis keywords dynamic taint analysis path tracking android acm reference format khaled ahmed yingying wang mieszko lis julia rubin.
.
vialin path aware dynamic taint analysis for android.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
https .
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
.org .
.
introduction taint analysis is a type of information flow analysis technique that reasons about the propagation of sensitive data through the program execution.
taint analysis has many applications in security e.g.
for identifying information leakages injection flaws and cross site scripting vulnerabilities .
it is also applied in program understanding software testing and debugging activities .
due to the increased popularity of mobile software numerous static and dynamic taint analysis techniques for mobile applications or apps for short were recently proposed.
these techniques are used to facilitate different types of application analysis including identification of injection vulnerabilities and information leakages .
static taint analysis techniques consider all possible paths that data can flow through without running the apps.
yet recent studies show that existing static taint analysis tools do not scale to applications of realistic size and complexity.
they also have difficulties analyzing several generic and android specific language constructs such as reflection dynamic code loading and android callbacks and framework methods.
dynamic taint analysis techniques have access to such runtime information and thus became a practical alternative to static analysis despite their own disadvantages such as the inability to reason about behaviors that were not triggered at runtime and the need to keep a low runtime overhead android simply kills slow apps .
taintdroid is probably the first dynamic taint analysis technique implemented for android it modified the dalvik virtual machine to accurately track information flows while keeping a low execution overhead.
subsequent work such as taint art further improves the efficiency of the analysis while also re implementing it for the new art runtime.
to keep the runtime overhead low dynamic taint analysis techniques typically assume a one bit taint mark for each tracked information source such as device id location and sensitive input data.
they propagate the marks through the execution of the program raising an alert when marked data reaches a sensitive sink such as an api that sends data out from the device.
marks are typically held in a bit vector tag i.e.
one integer attached to each program variable.
such design ensures that taint marks do not occupy too many processor registers which would slow the execution down.
one limitation of this design is that it allows at most different taint marks with a non linear performance degradation when increasing the number of tracked taints.
an even more important limitation is that this design only allows the techniques to report flow endpoints i.e.
the sources and sinks involved in a flow.
the techniques do not capture and cannot report the taint path i.e.
how the information propagates from sources to sinks.
finding such paths manually is a challenging yet necessary task e.g.
to check whether the information was properly handled before it was released.
our experiments show that taint paths extracted from realesec fse december san francisco ca usa khaled ahmed yingying wang mieszko lis julia rubin class appactivity string info string getuserinfo string input1 getuserinput source1 string input2 getuserinput source2 location loc getlocation source3 string size input1.getlength string lang loc.getlanguage string data size lang setinfo data sendinfo log.d input2 void setinfo string str this.info str string getinfo string val this.info return val void sendinfo string data getinfo sendtointernet data sink24 void start appactivity a new appactivity a.getuserinfo a. more code... figure an example application.
android applications contain more than code level statements on average and span more than methods on average.
consider for example the simplified pseudo code snippet in figure .
the method getuserinfo lines is triggered when the app execution starts lines to collect information about the user and store it in a field called info line .
specifically the method reads two input values provided by the user lines e.g.
the username and password specified in different textual input boxes and the user location line .
however instead of storing these values directly it only extracts the size for the first input line and the language spoken at the current user location line .
it concatenates and stores these values in the info field lines and sends the value of this field out to the internet lines .
furthermore the method writes the value of the second user input input2 into a log file stored on the device line .
while existing dynamic taint analysis techniques will correctly report that there is a flow of sensitive information from the user and location data into the sink in line they do not report the exact flow path making it difficult for an analyst to inspect how the information flows between sources and sinks e.g.
to understand that only the size of the user input and the language spoken in a particular location were released and decide whether that constitutes a violation of user privacy.
moreover to keep the size of the taint tag small the techniques only track the type of information being released and do not distinguish between code statements in which the information is obtained.
for example they cannot determine which of the user provided information is leaked username or password making it even harder to analyze the identified flows and or build other types of analysis on top of these tools.
other variations of dynamic information flow analysis e.g.
approaches based on dynamic forward slicing could in principle report path level information.
yet these existing techniques suffer from low efficiency when applied to large software cannot effectively separate paths when simultaneously tracking information from multiple different sources and are not designed to consider specifics of the android platform see section for more details .to fill this gap we propose the first dynamic taint analysis approach for android that accurately tracks and reports detailed statement level taint path information without inducing a substantial application slowdown.
we refer to our approach as vialin for routing and linking source to sink information .
instead of attaching a taint mark to each information source and propagating these marks through data flows as done by the classical taint analysis approaches vialin keeps a lightweight data structure up to five integer variables in most cases that points to elements that hold information about previous propagation steps.
that is vialin treats taint propagation as a sequence of elements representing taint propagation steps.
at a sink it traverses this sequence to report both the propagation path and the source s involved in the paths.
this design leads to a more efficient management of memory allowing the operating system to garbage collect taint marks that can no longer lead to any sink.
it also allows vialin to track any number of taint sources without any implementation changes.
section further illustrates of how vialin operates and how it compares with existing dynamic information flow analysis approaches.
we implemented vialin by extending the android runtime and evaluated it on a set of benchmarks and on large android applications from the google play app store.
we compare the paths extracted by vialin to those extracted statically by flowdroid for the benchmark apps and those extracted by a human expert for the google play apps.
to evaluate the overhead of the path collection functionality introduced by vialin we compare it to our own re implementation of the classical dynamic taint analysis approach that allocates a one bit mark for each tracked taint source as was done in taintdroid.
we had to re implement taintdroid on top of our taint analysis infrastructure as the original taintdroid implementation does not support the current android architecture.
we refer to our re implementation as td .
our evaluation of vialin shows that it can accurately identify taint flows and their corresponding paths with only a few false positive and false negative results.
as with other taint analysis approaches the false positives are due to array file and parcel over tainting while false negatives are due to the lack of support for native code and implicit flows.
yet our evaluation shows that paths reported by vialin can help reveal security vulnerabilities and malicious handling of user sensitive information in large android apps.
the runtime and memory overhead induced by the tool in a typical use is .
and .
respectively which we believe is acceptable given the extra functionality that it provides.
contributions.
this paper makes the following contributions .
it proposes a novel context field flow and path sensitive dynamic taint analysis approach that captures the entire taint propagation path not only its endpoints.
.
it implements the approach in a tool named vialin and empirically evaluates its accuracy and overhead on a set of benchmarks and on large android applications from the google play store.
.
it shows the practical usefulness of vialin in identifying security vulnerabilities and malicious behaviors in large android apps.
.
it makes our implementation of vialin the classical dynamic taint analysis approach td implemented on top of the same infrastructure and all our experimental data publicly available to support future work in this area .vialin path aware dynamic taint analysis for android esec fse december san francisco ca usa string getuserinfo string input1 getuserinput 4t int input1t 0b0001 string input2 getuserinput 5t int input2t 0b0001 location loc getlocation 6t int loct 0b0010 string size input1.getlength 7t int sizet input1t string lang loc.getlanguage 8t int langt loct string data size lang 9t int datat sizet langt ... void sendinfo string data getinfo 22t int datat valt 23t if datat !
report data datat sendtointernet data sink24 string getuserinfo string input1 getuserinput 4t taint input1t injectt null null string input2 getuserinput 5t taint input2t injectt null null 6t location loc getlocation 6t taint loct injectt null null string size input1.getlength 7t taint sizet propagatet input1t null string lang loc.getlanguage 8t taint langt propagatet loct null string data size lang 9t taint datat propagatet sizet langt ... void sendinfo string data getinfo 22t int datat valt 23t checkt datat sendtointernet data sink24 a taintdroid string getuserinfo 4string input1 getuserinput 4tint input1t 0b0001 5string input2 getuserinput 5tint input2t 0b0001 6location loc getlocation 6tint loct 0b0010 7string size input1.getlength 7tint sizet input1t string lang loc.getlanguage 8tint langt loct 9string data size lang 9tint datat sizet langt ... void sendinfo string data getinfo 22tint datat valt 23tif datat !
report data datat sendtointernet data sink string getuserinfo string input1 getuserinput 4t taint input1t injectt null null string input2 getuserinput 5t taint input2t injectt null null location loc getlocation 6t taint loct injectt null null string size input1.getlength 7t taint sizet propagatet input1t null string lang loc.getlanguage 8t taint langt propagatet loct null string data size lang 9t taint datat propagatet sizet langt ... void sendinfo string data getinfo 22t int datat valt 23t checkt datat sendtointernet data sink b vialin 5input2t p1 p2 4input1t p1 p2 7sizet p1 p2 6loct p1 p2 8langt p1 p2 9datat p1 p2 15this.infot p1 p2 18valt p1 p2 10datat p1 p2 22datat p1 p2 c taint structure generated by vialin .
figure taint tracking for the example in figure .
2vialin by example in this section we use the example in figure to illustrate how vialin operates and how it compares with existing classical dynamic analysis approaches.
we leave a detailed discussion about the design choices made our memory management optimization and our handling of android specific constructs to later sections.
figure 2a shows the implementation of the getuserinfo and sendinfo methods augmented with the sketch of the code that tracks taint tags in the classic way as implemented by taintdroid.
there are two types of taint sources in this example which are tracked by taintdroid using two taint marks 0b0001 for the information coming from the user input and 0b0010 for the location data.
to ease presentation we show the marks in a bit rather than bit taint tag vector.
the taint tracking code is injected between the original code lines i.e.
line it in grey for each original line i. for example in line 4t a new taint tag input1tis created to track the taints of the variable input1 .
the tag is associated with its corresponding variable by name it is initialized with the taint mark for the accessed information source 0b0001 in this case.
for each code instruction taint marks are propagated from the used to the defined variables.
for example in line 9t the taint tag datattracking the taints of the variable data is assigned all taints of the variables size andlang by unifying their corresponding taint tags.
at the sink the taint tag of the released variables is checked and if not empty the tool raises an alert reporting the taint marks that reached the sink as done in line 23t.
in this case the tool just reports two taint sources user input and location data.
figure 2b shows the alternative instrumentation performed by vialin .
instead of tracking taint tags as bit vectors it uses an object taint which contains three fields an id of the code instruction that defines the tracked variable and two pointers p1andp2 which point to the taint objects tracking taints of variables used in the instruction.
figure 2c shows a schematic representation of the created graph structure which allows vialin to report both the sources of the taint and the propagation path.
two pointers are sufficient in most cases as java bytecode uses three address instruction commands exceptions to this format are discussed later in the paper.
more specifically our instrumentation uses three operations injectt propogatet and checkt .
the injectt operation createsa new taint object each time a taint source is accessed and associates it with the corresponding defined variable see lines 4t 5t 6t .
the propogatet operation creates a new taint object for the defined variable and propagates the taint from the used variables by setting the pointers p1andp2accordingly.
for the example in line 9t a new taint object datatis created and the pointers p1 andp2are set to point to sizetandlangt which track the taints ofsize andlang .
at a sink the checkt operation traverses the data structure starting from the released variables to identify and report the sources involved in the information release if any and the propagation path see line 23t .
the graph structure in figure 2c illustrates this process it shows that the taint for the data variable accessed in line arrives from both the user input input1 in line via the path and the location source in line via the path .
the graph also shows that input2 in line does not flow to any sink.
in the remainder of the paper we give the necessary background information and describe our implementation of vialin .
we then discuss our experimental setup and evaluation results.
background the android system.
the android operating system is a software stack architecture built on top of the linux kernel.
android apps execute in the topmost architecture layer.
they call apis from the java framework layer which provides an abstraction for interfacing with the device hardware and sensors.
the android runtime art layer compiles apps and the java framework code into native code using the dex2oat compiler the native code is then executed by the art.
apps and the java framework code can also call native code directly through the java native interface jni .
each app is run in its isolated sandbox.
apps interact with one another through parcels a message passing construct that is serialized by the system and transported between apps.
in app communication between different app processes can also rely on parcels.
apps may also store files on the persistent storage of the system.
android memory management.
any memory an app modifies e.g.
by allocating new objects is managed by the art in ram.
an app can release memory by releasing object