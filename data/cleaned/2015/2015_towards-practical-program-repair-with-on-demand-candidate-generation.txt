towards practical program repair with on demand candidate generation jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid the university of texas at austin usa lisahua mengshi.zhang kaiyuanw khurshid utexas.edu abstract effectiveprogramrepairtechniques whichmodifyfaultyprograms tofixthemwithrespecttogiventestsuites cansubstantiallyreduce the cost of manual debugging.
a common repair approach is to iterativelyfirstgeneratecandidateprogramswithpossiblebugfixes andthenvalidatethemagainstthegiventestsuntilacandidatethat passes all the tests is found.
while this approach is conceptually simple due to the potentially high number of candidates that need to first be generated and then be compiled and tested existingrepairtechniquesthatembodythisapproachhaverelativelylow effectiveness especially for faults at a fine granularity.
to tackle this limitation we introduce a novel repair technique sketchfix whichgeneratescandidatefixes ondemand asneeded duringthetestexecution.insteadofiterativelyre compilingand re executing each actual candidate program sketchfix translates faulty programs to sketches i.e.
partial programs with holes and compiles each sketch once which may represent thousands of concrete candidates.
with the insight that the space of candidates can be reduced substantially by utilizing the runtime behaviors of the tests sketchfix lazily initializes the candidates of the sketches whilevalidating them against the test execution.
weexperimentallyevaluatesketchfixonthedefects4jbenchmark and the experimental results show that sketchfix works particularlywellinrepairingbugswithexpressionmanipulation attheastnode levelgranularitycomparedtootherprogramrepairtechniques.
specifically sketchfixcorrectlyfixes19outof 357defectsin23minutesonaverageusingthedefaultsetting.inad dition sketchfixfindsthefirstrepairwith1.
ofre compilations compiledsketches candidates and3.
ofre executionsout of all repair candidates.
acm reference format jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid.
.
towards practical program repair with on demand candidate generation.
inicse icse 40th internationalconference onsoftware engineering may june gothenburg sweden.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
introduction manually debugging faulty code is often tedious and costly and itselferror prone.thelastdecadehasseenmuchprogressinthe area of program repair which has shown much promise for automating debugging to reduce its cost and increase its effectiveness .
a common approach for automatedprogramrepairis generate and validate where several candidate programs that represent potential bug fixesareiterativelygeneratedusingrepairtemplates andvalidated against the given tests until a candidate that passes all tests is found.whiletechniquesthatembodythisapproachhaveshown theireffectivenessonrepairinganumberof defectsusingvarious search algorithms a limiting characteristic of these techniques especiallyforrepairingfaultsatafinegranularity is that they require potentially many candidates to first be generated and then be compiled and tested.
the costs of compilation and test execution are non trivial especially for open source projectsliketheclosurecompiler whichtakesaround1minute forthecompilationandthetestexecution.givenatypicalsearch spaceofrepaircandidates around5k thetotalre compilationand re execution time can be as long as days.
to allow the exploration of large numbers of candidates researchershavedevelopedvarioustechniquesinpreviouswork.for example sometechniques inferconstraintsand synthesizerepairsbytranslatingtheconstraintstopropositional satisfiability sat formulas.
such translation based synthesis may involveincompletetranslationsorcreateimpracticalproblemsthat require creating complex models for all involved libraries.
more over they generally exclusively reason about booleanorinteger type and can hardly handle manipulation of non primitivetype expressions in presence of libraries or complex constructs like ast node level type casting.
some techniques mine historical data or analyze documents to rank the repair candidates.
these techniques have shown their effectiveness on someclassesofdefectslikeexceptionhandling yettheymaynot be effective at repairs that require fine grained expression manipulations at the ast node level.
we present sketchfix which is a novel technique for more effective generate and validate program repair using a perspective differentfrompreviouswork.ourkeyinsightisthatthespaceof candidateprogramscanbeprunedsubstantiallybyutilizingruntime information and by generating candidates on demand during testvalidation.toillustrate considertryingtofixafaultycondition inawhile loopaswellasthebodyoftheloop ifatestexecution raisesanexceptionuponevaluatingaspecificcandidatewhile loop condition allcandidatesofthewhile loopbodyareprunedfrom search for that choice of the candidate condition expression.
in fact our approach for lazy candidate generation will not create any acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid candidates for the while loop body which may contain thousands of patches if the while loop body is not executed.
when a test fails due to either a runtime exception or a test assertion failure thepartsof the candidate program that were directly executed determinethegenerationofthefuturecandidates.insteadofthe traditionalapproachofiterativelygeneratingandvalidatingeach repaircandidate wetightlyintegratethegenerationandvalidation ofcandidates byeffectivelyutilizing runtimebehaviorsof thetest executionstoprunealargepartofthesearchspace whichmustbe explored otherwise.
at the ast node level sketchfix performs a systematic reduction of programrepair to programsynthesis by translatingafaultyjavaprogramtosketches whichwillbe completedbyasynthesizer withrespecttothegiventestsuite.
givenafaultyjavaprogramandatestsuiteasinput sketchfix introducesholestosuspiciousstatementsbasedontheastnodelevel transformation schemas.
to fill in these holes sketchfixemploys a practical sketch engine called edsketch to synthesizesketcheswithbacktrackingsearch.wheneveredsketch encounters runtime exceptions or test failures it backtracks immediatelyandfetchesforthenextchoiceuntilthespaceofcandidates is exhausted or a complete program that satisfies all tests is found.
thiscompleteprogramisregardedasarepairfortheoriginalfaulty program.
sketchfix defines transformation schemas at a fine granularity and prioritizes first the schemas that introduce smaller perturbationstotheoriginalprogram.recenttechniquespresenttheinsight thatpatchesthataresemanticallyclosertotheoriginalprograms aremorelikelytobecorrectfromtheperspectiveofthedevelopers .ourrankingstrategyisinlinewiththisinsightandaims to mitigate the overfitting issue in automated program repair.
we evaluate sketchfix using defects4j a dataset that hasbeen widelyusedtoevaluate automatedprogramrepair techniques.
with default setting sketchfix correctly fixes out of357 bugs in minutes on average.
it additionally fixes faults with alternative settings such as applying more transformation schemas etc.furthermore wecomparesketchfixwithotherrepair techniques and illustrate favored defect classes for different automated program repair approaches.
with on demand candidate generation sketchfixrequiresonly1.
ofre compilations com piledsketches candidates and3 ofre executionsoutofallrepair candidates when it finds the first repair.
lastly we demonstrate that our find grained transformation schemas are able to generate high quality patches by introducing ast node level edits to the original programs.
in summary we make the following contributions on demandcandidategenerationforprogramrepair.
utilizing runtime behaviors we lazily generate on demand candidatesduringthetestexecutionformorepracticalprogramrepair.
this integration of the generation and the validation phases substantially prunes the search space of the repair candidates.
astnode levelprogramrepair wedesignasetofastnodelevel transformation schemas to repair faulty programs at a fine granularity.
this strategy is effective for generating high quality patches that are semantically closer to the original programs.
practicalreductionofprogramrepairtosynthesis.
withoutinferringconstraintsorcreationofconstraintsolvingproblemsforsat smtsolvers wetransformthefaultysubjectstosketchesandsynthesizecodetocompletethesketchesusinga backtracking search based sketch system.
our evaluation shows that this reduction from program repair to program synthesis helps build effective and well founded repair techniques.
motivating example a part of the human written patch to fix the chart14 defect .public class categoryplot extends plot... ... .
public boolean removedomainmarker ... boolean notify .
arraylist markers .
if ... ... else .
if markers null .
return false .
... b a sketch generated by sketchfix and synthesized solutions .public class categoryplot extends plot... ... .
public boolean removedomainmarker ... boolean notify .
arraylist markers .
if ... ... else .
if sketchfix.cond arraylist.class new object markers .. .
return boolean sketchfix.exp boolean.class new object markers .. .
... synthesized solution sketchfix.cond markers null ... sketchfix.exp false ... figure1 anillustrativeexampleforafaultandtherepair generated by sketchfix to illustrate the large search space of repair candidates we present a part of a defect derived from the jfreechart project .
figure a presents a human written patch to fix this part of the bug that omits the null pointer checking for an arraylist object markers .
the class categoryplot contains fields and local variables candidates in total .
given a suspicious location if an automatedrepairtool wantstoinsertan if conditionandareturn statement to fix the bug without considering field dereferences derived from the variables and visible fields inherited from parent classes the space of candidates for the if condition alone can be more than5k.
we defineconditions as leftand righthand side expressions combined with a relational operator either or !
for non primitive types thus the space is .
the returnexpressionhasanother15candidateswiththe booleantypeincluding the default boolean values trueandfalse .
given an average compilationandtest executiontimeof15secondsforthejfreechart project it takes more than days to validate all 87k candidates.
toeffectivelyexplorethislargesearchspaceofrepaircandidates sketchfixtranslatesthefaultyprogramtosketcheswithholesand synthesizes sketches with on demand candidate generation.
given authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards practical program repair with on demand candidate generation icse may june gothenburg sweden asuspiciouslocation sketchfixappliesastnode leveltransformation schemas to generate a set of sketches and each sketch can represent thousands of concrete repair candidates.
figure b illustratesasketchgeneratedbysketchfix.togeneratethis sketch sketchfix applies two schemas at the suspicious location one schema introduces an if condition if condition schema and anotherintroducesareturnstatement return statementschema .
to represent an unknown condition hole i.e if ?
?
sketchfix definesanapi sketchfix.cond ... injavasyntax whichreturnsa non deterministic boolean value either trueorfalse during the test execution.
this api takes two parameters the hole s target type i.e arraylist and an array of visible variables as candidates tofillinthehole.thehole stargettypeisdefinedasthetypeofthe variablesusedtofillinthehole.sketchfixenumeratesalltypes derived from visible variables and generates one sketch for each target type.
at line the return statement schema inserts a return statementwithanon deterministicexpression sketchfix.exp ... i.e return ?
?
whose target type is the return type of the method.
thesketchshowninfigure1 b willbecompiledonlyonce yet itrepresents87kcandidatepatches.sketchfixdirectlyexecutes the given test suite after the compilation.
when the test execution firstreachesthehole sketchfix.cond ... insteadofconsidering thousands of concrete candidates like markers!
null sketchfix only considers two booleanvalues and non deterministically selectseither trueorfalsetofillintheconditionhole.if sketchfix selects falsefor the ifcondition it will not initialize any candidates for the returnexpression because the test execution does not reachthehole sketchfix.exp ... insidethe ifblock.inthisexample choosingthevalue falseforthe ifconditionleadstoatestfailureat runtime.sketchfixbacktracksimmediatelyandselectsthenext choice which is the value truefor the if condition.
sketchfix generates candidates for the expression sketchfix.exp ... when the testexecutionreachestheholeatthefirsttime.given15candidates oftheexpressionhole sketchfixselectsonecandidateatatime during the test execution until a candidate that satisfies all tests isfound.inthisexample sketchfixfindsthefirstsolutionin40 seconds after compiling the sketch once and executing the tests twice.
approach in this section we describe how we translate faulty programs to sketchesusingastnode leveltransformationschemas section3.
.
thesesketchesarefurthersynthesizedbyapracticalsketchengine with on demand candidate generation section .
.
.
ast node level transformation we perform a systematic reduction of program repair to program synthesis by translating faulty programs to sketches at a fine granularity.syntax of partial expressions holes .
figure denotes the syntax of holes.
we define two basic types of non deterministic holesforsketches expressionholesandoperatorholes.theatomicexpressionholes sketchfix.exp representvisiblevariables constant values and field dereferences.
as to the operator holes wedefine arithmetic operators sketchfix.aop relationaloperators !
lessorequalslant greaterorequalslant sketch fix.rop andlogicalatomic expr e var const var.f constant const null true false k arithmetic op aop relational op rop !
lessorequalslant greaterorequalslant logical op lop composite expr e e1op e2orarray figure syntax of partial expressions mexp p turnstileleftet et mapsto t mop p turnstileleftop op mapsto mpar p turnstileleftf par f par turnstileleftf prime par et f par mapsto f prime par t mcon p turnstileleftif c c mapsto clop trop prime t mif p lscript turnstileleft v t p lscript mapsto if trop prime t p lscript mrtn p lscript turnstileleft v t p lscript mapsto return tp lscript figure program transformation schemas operators sketchfix.bop that combine multiple clauses.
sketchfixgeneratescompositeexpressionsby combining expressionholeswithoperatorholesorcombiningarrayvariableswiththe index ofarray elements.
compositeholes can furthercombine together.forinstance wedefineaholeforconditions sketchfix.cond as two expression holes at left and right hand side combined with a relational operator.
both sides of expression holes in the condition canbe replacedby infix expressions e.g.
a b witharithmeticoperators andtheconditionholes canfurtherbecombined togetherwithlogicaloperatorstosupportmultipleclauses.tospecify these holes in java syntax sketchfix provides a list of method invocations and these invocations take two parameters the target type of the hole and a list of objects.
base on the syntax of the holes we define six ast node level transformation schemas figure that take a faulty program pas the input and produce sketches with holes.expressiontransformation m exp givenasuspiciousstatement lscriptin the faulty program p if it contains any variables constant values or field dereferences with the type t mexptransforms this expressionettoapartialexpression tthatrepresentsanyexpression candidateswiththesametype t.thatis theoriginalexpressionwill bereplacedbyahole sketchfix.exp t new object v1 v2 ... whiletheobjectlistcontainsallvisiblevariables parametersand fields.operator transformation m op given a suspicious statement if itcontainsanyarithmetic relationalorlogicaloperatorsdefined in the syntax of holes figure moptransforms the operator to anoperatorhole thatdenotesanyoperatorsofthesameoperatortype.forinstance givenaclause a binthefaultyprogram mopwill replace this clause with a partial expression a?
?bwhere authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid algorithm static transformation for sketch generation input faulty program p fault locations l schemas m output list of sketches q 1function transformsketch p l m is 2q 3foreach lscript ldo apply one schema foreach mdo q q p lscript apply two schemas i whilei m.sizedo m p lscript j i whilej m.sizedo q q m lscript j i the operator hole ?
?can be any of !
lessorequalslant greaterorequalslant .
the correspondinggeneratedsketchis sketchfix.rop integer.class new object a b ifaandbare ofintegertype.
overloading transformation mpar given a suspicious statement ifitcontainsamethodinvocation fthathasaoverloading methodf prime sketchfixtriestomapparametertypesfor fandf prime using an approach similar to the edit distance .
sketchfix only considers overloading methods f primewhose edit distances in terms of theparametertypesarenomorethantwo.sketchfixgenerates holes tforf primeto represent parameters in different types.
condition transformation mcon given a suspicious condition expression c mconintroduces a new clause for the condition.
the newclauseisrepresentedas trop prime twhere tand prime trepresent any expression candidates with the type t. the hole roprepresents relationaloperators.if tisanon primitivetype sketchfixapplies relationaloperators and !
toconstructtheclause whereas for primitive types it applies all relational operators.
the new clauseisappendedtotheexistingbooleanexpression cwithlogical operators and .
if condition transformation mif given a suspicious location lscript sketchfixintroducesanif conditionbefore lscriptwithacondition hole .
if sketchfix selects the target type t the schema will insert an if condition as if sketchfix.cond t new object v1 v2 ... wherethetarget type tisderived fromvisible variables vat the location lscript.
return statementtransformation mrtn given a suspicious location lscript sketchfixinsertsa returnstatementbefore lscript.ifthereturn type of the current method is void sketchfix simply inserts an emptyreturnstatement otherwise sketchfix inserts a hole t basedonthemethod sreturntype i.e.
return t sketchfix.exp t new object v1 v2 ... .
tohandledefectsthatrequiremultipleholestofix suchasthe omissionofnull pointer checkinginfigure1 weapplytransformation schemas incrementally at the suspicious statements.
algorithm shows the static transformation approach that appliesno more than two schemas on the faulty program p. the loop at line4applieseachapplicableschemaonthesuspiciouslocation lscriptto createsketches.thenestedloopstartingfromline7enumeratesallcombinationsoftwoschemasandappliesthesetwoschemasatthe samelocation lscript.given thelargesearch spaceof repaircandidates inopensourceprojects bydefaultsketchfixappliesnomorethan two transformation schemas at the same location.
we leave the discussion of applying more schemas in section .
.
.
intuitively thesynthesiscostincreaseswithmoreholesinthe sketch.wedefinethecostoftransformationschemasasthenumber ofatomicholes expressionholesandoperatorholes introduced by the schemas.
we prioritize the schemas with lower synthesis cost.
for instance we favor expression mexpr andoperator mop manipulation over the condition transformation schema mcon be causethe mconinsertsarelationaloperatorholeandtwoexpression holesattheleftandrighthandsideoftheoperator.thisstrategyis inlinewithexistingliteratures basedontheheuristicthat repair candidates semantically closer to the original programs are relatively easier to comprehend and are more likely to be accepted by the developers.
existing automated repair techniques have utilized various supportiveresourcestoimprovetherepairefficacy suchashistorical data documents anti patterns and test generation .yetwepreservesketchfix spracticalityandleavethe improvement of fix patterns as future work.
.
practical sketch synthesis aftertransformingtheoriginalfaultyprogramtosketchesbased ontheschemas sketchfixexecutestestcasestosynthesizesketches withon demandcandidategeneration.sketchfixwillnotgenerate concrete candidates for a hole until the test execution reaches the hole.
the candidates are created based on the runtime information.
forinstance wewillnotgeneratefielddereferencesfor nullvariables refer to .
algorithm describes the procedure of lazy candidate generation and the sketching using backtracking search.
on demand candidate generation.
when the test execution first reaches a hole line sketchfix initializes the hole s expression candidates based on the given visible variable list.
for theexpression hole sketchfix.exp ... the method candidategen atline3collectsvisiblevariables constantvaluesandfielddereferences refer to edsketch and returns a candidate vector hole.candidates .
each candidate is assigned a unique identifier whichisitsindexinthevector.eachhole scandidateidentifieris initializedas indicatingthatsketchfixhasnotselectedacandidate for this hole algorithm line .
during the test execution the sketchengine non deterministicallyselects anidentifier using choose operator line5 andthecandidatewiththecorresponding identifier is used to fill in the hole.
the execution continues with this selection until it encounters a runtime exception or a test failure leading to a backtrack to the next choice of candidates i.e.
incrementing the candidate identifier and selecting the next candidate at runtime.synthesis with backtracking search.
algorithm illustrates the idea of synthesizing sketches with backtracking search which isembodiedinthesketchengineedsketch .insteadofinferringconstraintsandtranslatingthemtosatfortherepairsynthesis edsketch starts sketching by directly executing the given tests.
wheneveraruntimeexceptionoratestfailureoccurs edsketch backtracks bythrowing a backtrackexception whichwill enforce authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards practical program repair with on demand candidate generation icse may june gothenburg sweden algorithm on demand candidate generation based on edsketch input sketches p test suite t output complete program p primethat pass all test cases 1function synthesizehole hole is 2ifhole.candidates null then first access hole.candidates candidategen hole 4ifhole.id then first access hole.id choose hole.candidates.size 6returnhole.candidates 7function sketch is 8do try explorecurrentchoice catchbacktrackexception createnextchoice 13whileincrementcounter 14function explorecurrentchoice is 15try foreachtest tdo test.run 18catchtestfailureexception throwbacktrackexception 20printsolution 21searchexit if only needs the first solution theprogramtore executefromthebeginning line19 .foreach re execution the sketch engine increments the counter for the non deterministic choose operatorandselectsthenextcandidate line to fill the hole.
the synthesizing process terminates when the space of candidate programs is exhausted or a complete program that satisfies all tests is found.
edsketch embeds a range of pruning strategies to effectively explore the space of candidates.
forinstance basedontheprogramsymmetry theconditionclause a bis equivalent to b a thus only one clause is considered.
ranking candidates based on the locality.
with the notion that variables declared closer to the hole are more likely to beused we rank variables based on their proximity to the hole location i.e.
thenumber of statementsbetween thehole and the variable declaration.
we rank the target types of the hole with a similar heuristic based on the number of statements between the holeandvariabledeclarationsofthistypeinascendingorder.for instance in our motivating example figure b the condition holeatline5favorsthetype arraylist becausetheclosestvariable is with this type.
in summary we discuss how we systematically reduce the problem of program repair to program synthesis at the fine granularity.
weutilizetheruntimebehaviorsofteststoprunealargeamount of search space with on demand candidate generation.
evaluation we evaluate sketchfix on the defects4j benchmark which consistsof357realdefectsfrom5opensourcejavaapplications.de fects4jcontainsvarioustypesofdefectsfromopensourceprojectstable overview of the evaluation dataset and the repair results of sketchfix project loctests bug fixflsketch repair time m time s time m chart 96k2.2k .
.
.
closure 90k7.8k1333 .
.
.
lang 22k2.2k .
.
.
math 85k3.6k1067 .
.
.
time 28k4.1k .
.
.
total fixshowsthenumberofcorrectfixesandplausiblefixes repairsthatpass tests but fail in manual inspection .
to eliminate the bias of the dataset in terms of the defects types and the abundance of these defect classes .
in section4.
wecomparesketchfix srepairefficacyandfavoreddefect typeswithotherautomatedrepairtechniques.insection4.
we investigateiftheon demandcandidategenerationcouldeffectivelyreducethesearchspaceofrepaircandidates.wefinallydiscusshow our ast node level transformation influences the patch quality in section .
.
we address the following research questions in this section what s the repair efficacy of sketchfix compared to other repair techniques?
doestheon demandcandidategenerationtechniquereduce the search space of repair candidates?
how does our fine grained transformation affect the quality of the generated repairs?
.
experiment setting defects4jisacollectionofreproduciblebugswithtriggeringtests verified.
sketchfix regards the test suite of each subject as the correctnesspropertyandtriestosynthesizeanewprogramsuch that all tests could pass.
toidentifysuspiciousstatementsforthedefects weusetheasm bytecodeanalysisframework togetherwith javaagent to capture the test coverage of both failing and passing test executions.sketchfixusesanexistingspectrum basedfaultlocalization technique called ochiai to rank potential faulty statements based on their suspiciousness.
existing empirical studies illustrate that ochiai is more effective on localizing the faults in object orientedprogramsthanothertechniques.ochiaihasbeen applied to numerous repair techniques including all four repair techniques we use in the comparison.
we rank the suspicious statements based on the ochiai suspiciousness value for each statement covered by failing exe cutions and select the top suspicious statements by default.
if multiplestatements havethe samesuspiciousnessscore weorder themrandomly.weleavethediscussionforthenumberofselected statements in section .
.
.
table presents the basic information of the subjects used in the evaluation including the lines of code loc the number of test cases test the number of defects collected in the benchmark authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid 6nhwfk l 1rsro vwru 6nhwfk l 5hsdlu hdrepair assumes that the faulty methods are known in advance.
sketchfix fixes more defects with this assumption of them are also fixed by hdrepair.
we report two results without and with the assumption.
figure comparison of correct patches generated by sketchfix and other repair techniques bug andtheaverageperformancetimetoidentifyfaultystatements fl time .totranslatefaultyprogramstosketches weimplement transformation schemas using javaparser a tool that parses and transforms java programs.
the column sketch time denotes the average performance time to generate program sketches.
sketchfix explores the search space of repair candidates for each program sketch until the space of candidates is exhausted or we findapre definednumberofrepairsthatpassalltests.currently we terminate after finding the first repair yet we set the number of output repairs as configurable.
we report the average performance time sketchfix takes to find the first repair column repair time following the spirit of existing literatures .
we execute only the tests that reach the holes following the spirit of recent workon test pruning .
we manually check all synthesized repairs againsthuman writtenpatchesfromtheversionhistory andreport the number of correct repairs and plausible ones that pass all tests but fail in manual inspection in column fix.
all performance experiments are conducted on a platform with core intel core i7 cpu .
ghz and gigabyte ram on ubuntu linux .
.
.
repair efficacy in this section we answer the first research question by comparingsketchfix srepairefficacywith otherrepair techniques astor nopol acs and hdrepair .
we select these four publicly available repair techniques that have been evaluatedagainstthedefects4jbenchmarkandignoreotherswhich either focus on another language or are not publicly available .
all four techniques use ochiai to identify the suspiciousstatements.notethathdrepairassumesthatthefaultymethodsareknowninadvanceandperformsochiaitoidentifythe faultystatementsinthegivenmethods.wethusaddthisassumption when conducting the comparison with hdrepair.
due to the difference in experiment platforms we can hardly reproduce all experiments for these four techniques we thus mainly refer to the generated repairs provided by the authors and refer to their results of the manual inspection.table2 manualassessmentresultofpatchesgeneratedby sketchfix and other repair approaches no.sfanchno.sfanch ch1 check?
checkm5 check check check check ch3 ?
?
m8 ?
ch5 ?
m22 check ch7 ?
m25 check ch8 check checkm28 ?
ch9 check m32 ?
?
ch11 check m33 check ?
ch13 ?
??
m34 check ch14 check m35 check ch15 ?
check m40 ?
?
ch19 m42 ?
ch20 check m49 ?
?
ch21 ?
m50 check check check check ch24 check m53 check check ch25 ?
?
m57 ?
ch26?
?
?
m58 ?
c1 m59 check c10 checkm61 check c11 m69 ?
c14 check checkm70 check check check c51 checkm71 ?
?
c62 check checkm73 ?
check?
c70?
checkm78 ?
?
c73?
checkm80 ?
?
c126 check checkm81 ?
?
l6 check checkm82 check??
check check l7 ?
check m84 l10 checkm85 check??
check l24 check m87 ?
l35 check m88 ?
l39 m89 check l43 checkm90 check l44 check m93 check l46 ?
m95 ?
l51?
?
checkm97 ?
l53 ?
m99 check l55 check?
check m104 ?
l57 checkm105 ?
l58 check t4 ?
?
l59 check checkt11 ?
?
m2 ?
t15 check m3 check t19 check m4 check sfrepresentssketchfix arepresentsastor nrepresentsnopol c represents acs and h represents hdrepair .
checkrepresents correct fix ?
represents plausible fix and represents not generating fix.
we use the to mark the new generated fixes by providing the faulty methods when comparing with hdrepair.
we highlight the correct repairs generated by sketchfix.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards practical program repair with on demand candidate generation icse may june gothenburg sweden a a bug fix for chart24 generated by sketchfix human written patch for the defect private int upperbound lowerbound public paint getpaint double value double v math.max value this.lowerbound int g int value this.lowerbound ... int g int v this.lowerbound ... ... a sketch generated by sketchfix and the synthesis result public paint getpaint double value double v math.max value this.lowerbound int g int integer sketchfix.exp int.class new object v value ... this.lowerbound ... synthesized solution sketchfix.exp v b a bug fix for math73 generated by astor human written patch for the defect math73 if yinitial ymax return solve f initial yinitial ... if ymin ymax throw new llegalargumentexception ... return solve f min ymin ... bug fix generated by astor with api replacement if yinitial ymax return solve f initial yinitial ... return solve f min ymin max ... return solve f min max c a bug fix for lang58 generated by nopol human written patch for the defect omit complex clauses for simplicity if dec null exp null a b c .. if dec null exp null b a d .. bug fix generated by nopol that is regarded as correct if dec null exp null a b c .. if dec null exp null .. d a bug fix for time15 generated by acs human written patch for the defect and acs s result is semantically identical to this.
if val1 long.min value throw new arithmeticexception ... e a bug fix for math34 generated by hdrepair human written patch for the defect and hdrepair s result is identical to this.
public iterator chromosome iterator return chromosomes.iterator return getchromosomes .iterator figure5 comparisonoffavoreddefectclassesforsketchfix and other repair techniques figure denotes venn diagrams for the defects that can be correctly repaired by sketchfix and other techniques.
given that sketchfix astorandnopoldonot requiresupportive informationsuchasdocuments acs orhistoricaldata hdrepair we separate the comparison into two venn diagrams.
table presents the repair result through manual inspection.
.
.
defect classes favored by the repair techniques .
different repair techniques focus on different types of bugs e.g.
nopol onlydealswithconditionfaults .wearenotintendedtoperformanapple to applecomparisonwiththeserepairtechniques instead we highlightfavoreddefectclassesof sketchfixandothertechniques with examples.
sketchfix.
figure a presents a defect that can be fixed by sketchfix.inthisexample sketchfixappliesthe mexpschema to a type casting expression at the ast node level.
it synthesizes a variable vfor the expression hole to replace the original variable value.notethattheconstraint solving basedrepairtechniques in general only modify expressions in conditions or the right sideofassignmentswith booleanorintegertypes othertechniquesthatleveragestatement levelmutation orsupportive information can hardly repair the defect because this ast node level replacement has a rare chance to be duplicated in existing program context history or documents .
table reports the schema types that finally generate repairs for each defect.sketchfixcorrectlygeneratesrepairsfor19subjectsand around half of them subjects yield expression manipulation.
themanipulationofoperatorsandvariabletypes parametersfor overloadingmethods correctlyfixesanother6defects andtherest schemas or their combinations fix another subjects.
for the defectsthatcanonlybefixedbysketchfixwithrespecttoother four repair techniques of them yield expression manipulation oneofthemisvariabletypemanipulationinoverloading methods and the last one applies an insertion of the if condition.
astor.
astor is a program repair library that contains three repair modes based on the genetic algorithm statement condition removal andoperatormutation.figure5 b showsadefectthatcan befixed byastor.it replacesthe returnexpressionwith another method invocation.
the new return statement exists in the current program context and the astor correctly generates this repair basedonthestatement levelsearch.sketchfixgeneratesthesame repairbytransformingtheoriginalinvocationtoanoverloading method with holes at the ast node level.nopol.
nopol is a repair technique that focuses on the condition faults by modifying existing if conditions or adding pre conditions.
figure c shows a defect and a bug fix generated by nopol.
thegeneratedpatchremovesmultipleclausesandisreportedas correctintheliterature .sketchfixfailstorepairthisintricate condition defect that requires changes on multiple clauses.
acs.acs leverages document analysis to rank patches and it advancesothertechniquesonfixingtheomissionerroroftheexception handling if throw .
figure d presents an example of the repair generated by acs which is semantically equivalent to the human written patch.
sketchfix is not designed to handle exception omission and we leave this as future work.
hdrepair.
hdrepair prioritizes patches based on the mined repairmodelsfromhistoricaldata.itpreferstherepairsthatrequire the method invocation replacement.
figure e shows a repair generated by hdrepairthat replacesan expressionwith a method invocation.sketchfixcanbeextendedtosupportapisynthesis with a similar idea of the on demand candidate generation .
our experiment indicates that sketchfix performs particularly well in the defect classes that require manipulations of expressions andvariabletypes.recentempiricalstudiesonrepairmodels authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid table sketchfix repair result for each subject fix type sk.
sp.
csk.
exe cor t m 1ch1cmrop1.7k .2k .8k .9k .
2ch8cmexp607 .7k .
3ch9cmcon744 .9k .
4ch11 cmexp249 .4k .
5ch13 pmpar813 .8k 6ch20 cmexp137 .9k .
7ch24 cmexp17 .
8ch26 pmif .6k mrtn 9c14cmexp2.6k .1k .
10c62cmrop490 .9k .
11c70pmpar1.2k .9k 12c73pmrop476 .2k 13c126 cmcon462 .6k .
14l6cmexp255 .0k .
15l51pmif .4k mrtn 16l55cmcon108 .6k .
17l59cmexp188 .8k .
18m5cmexp .
19m33cmpar1.1k .8k .
20m50cmcon655 .0k .
21m59cmexp259 .0k .
22m70cmpar139 .8k .
23m73pmif .2k mrtn 24m82cmrop500 .0k .
25m85cmrop407 .2k .
26t4pmpar555 .4k fixrepresents whether it is a correct fix c or a plausible fix p .type denotes the schema types that yield the repair.
sk.shows the number of generated sketches.
sp.presents the total search space of candidates.
csk.
is the number of compiled sketches when sketchfix generates first repair.
exerepresents the number of candidates sketchfix explores when it generates the first repair passing all tests.
cor represents that number when sketchfix generates the first correct repair based on the manual inspection.
t m reports the performance time to synthesize a correct fix.
showtheabundanceofsuchdefects.yetsketchfixisnot designedtohandlestatement levelmutationorexceptionhandling.
.
.
search space extension.
in this section we extend the searchspaceofrepaircandidatestoconsidermoresuspiciousstatements and transformation schemas.
suspicious locations.
by default we consider top suspicious statementsas wenotice thatsketchfixcannotfix manydefects with anincrease of boundwhereas thecost of theprogram repair increases significantly.
if we increase bound to sketchfix correctly fixes more defects chart26 and lang10.
hdrepair fixesdefectswithgivenfaultymethods.withthesamecondition sketchfixcorrectlyfixes 6moredefects closure1 closure11 closure70 closure73 lang51 and time19.
this result also indicates thatconcise faultlocalization techniquescan greatlyimprove the efficacy of program repair techniques.multipletransformationschemas.
asatrade offbetweenthe costofexperimentsandtherepairefficacy sketchfixappliesno more than two transformation schemas at a suspicious location.
thenumberofgeneratedsketchesandcorrespondingcandidates growquicklywithmoretransformationschemas.sketchfixfixes4 more bugs with schemas at a given location closure130 lang58 math53 and time4 .repair at multiple locations.
we introduce an incremental approachtofixdefectsatmultiplelocationsbasedonthereduction of the failing test cases .
if there exists multiple failing test cases we localize the defect with one failing test case and all passing test cases let sketchfix generate sketches and evaluate ifany synthesized solution can eliminate one or more failing testcases.
if a synthesized version reduces the number of the failing test cases sketchfix applies this repair and keeps on considering other failing test cases.
this incremental repair technique is based on the assumption that at least one failing test case can be fixedby synthesizing a sketch and failing test cases are independent with each other such that the fix of one test case will not affect others.
although the validity of this assumption remains unsettled sketchfixcorrectlyfixesanother3defects chart14 math4 and math22 based on this assumption.
.
.
threats to validity.
although defects4j contains hundreds of defects from multiple open source projects this defect benchmarkmayunavoidablyyieldthebiasoftheevaluationdatasets withrespecttothedefecttypesandtheabundanceofthedefectclasses .wecompareourresultwithotherfourrepair techniques that have been evaluated with the same benchmarkand explain the favored defect classes for each technique.
based on the human written patches from the version history we assess the correctness of the generated repairs.
however this assessment may still be biased.
.
search space reduction in this section we answer the second research question on the efficacy of our on demand candidate generation.
sketchfix is able to generate repairs for the subjects shown in table .
with the default setting these repairs include correctfixesthatpassthemanualinspectionandtheplausibleonesthatpass all tests but are regarded as semantically different from thedeveloper written patches.
the column fixdenotes whether the repairiscorrect c orplausible p .thecolumn typerepresentsthe transformation schema types that are used to fix the bugs.
if more thanone schemacombinationcan generaterepairsthat satisfyall testassertions wereportthefirstschemacombination.thecolumn sk.
shows the total number of sketches generated by sketchfix considering all selected locations and the column sp.
lists the total search space of the candidates that the sketches represent.
for instance if sketchfixintroducesanon deterministiccondition clause for a primitive type assume that there are expressioncandidates at both left and right hand side the search space ofcandidates for this sketch is as two expressions are combined with a relative operator which has options !
lessorequalslant greaterorequalslant .
the column csk.presents the number of compiled sketcheswhensketchfixgeneratesthefirstrepairsthatpassall tests.
the column exe.shows the number ofcandidates that have authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards practical program repair with on demand candidate generation icse may june gothenburg sweden beenexecutedagainstthetestsuitewhensketchfixgeneratesthe first repairs satisfying all tests.
and the column cor.represents the number when sketchfix finds the first correct repairs.
the columnt m illustratesthetotalperformancetimeinminuteswhen sketchfix finds the first correct fix including the time for the compilation and the test execution.
with the on demand candidate generation every sketch will be compiledoncewhichmayrepresentthousandsofcandidates.upto the time that sketchfix finds the first repair it compiles .
avg.
compiled sketches space .
if sketchfix wants to exhaustively searchtheentirespaceofrepaircandidates itonlycompiles7 avg.
sketches space of all candidates.
sketchfix utilizes runtime information to further prune the candidates that actually needtobeverifiedbythetestexecution.forexample sketchfixwill notgeneratecandidatesfortheconditionbodyiftheconditionis evaluated to be false.
the experiment shows that sketchfix only executes3 ofcandidates avg.
gen space whenitfindsthefirst repairs that pass all tests.
onaverage sketchfixspends9minutesgeneratingsketches withfaultlocalizationand23minutesgeneratingthefirstrepairs thatsatisfyalltestassertions.tocompareourperformancewith other repair techniques we refer to the performance time reported in the literatures as we are not able to reproduce all experiments of other techniques due to the various experiment platforms.astorandnopolspend30 40minutesonaveragefor eachrepaironapowerfulmachine.hdrepairspendsanaverage of minutes generating patches with given methods.
without reportingtheperformancetimefordocumentanalysis acs spatch generationtime max.28minutes median .5minutes isnotfairly comparable with our repair technique.
without pre processing historical data or document analysis our practical repair techniquecompareswellwithotherrepairtechniquesonperformance.we omit the comparison on the number of executed candidates across different repair techniques because different techniques use different templates and the choice of templates determines the search space of the candidates.
.
the quality of generated repairs weanswerthelastresearchquestioninthissectionbyinvestigating if our ast node level transformation helps generate high quality patches.
shown as figure we illustrate the quality of the repairs generated by sketchfix using an example.
basedontheastnode leveltransformationschema sketchfix transformsamethodinvocationtoitsoverloadingmethod andcor rectlyrepairsthedefectbyreplacingthevariable maxulps integer toepsilon double .thisfine grainedtransformationisinlinewith the notion that the repairs which introduce smaller perturbations to the original programs are more likely to be correct from the perspectiveofthedevelopers.withthesamenotion sketchfixfavors expression manipulations for the overloading method mpar ratherthantheif conditioninsertion mif astheinsertionofanew if condition will introduce more atomic holes than the expression manipulation.
sketchfix generates sketches shown as figure b and synthesizes this sketch as expected.
the repair techniques astor acs and hdrepair fail to generate repairs for this bug.
nopol fixes this defect by adding a new if block.althoughbothsolutionsmightbesemanticallyequivalent a a human written patch for the defect math33 public class precision public static int compareto double x double y double eps .. public static int compareto double x double y int maxulps .. simplextableau.java private final int maxulps private final double epsilon protected void dropphase1objective if precision.compareto entry 0d maxulps ... if precision.compareto entry 0d epsilon ... b a sketch generated by sketchfix and a synthesized solution simplextableau.java as sketch protected void dropphase1objective if precision.compareto entry 0d double sketchfix.exp double.class new object .. epsilon maxulps .. .. synthesized solution sketchfix.exp epsilon c a plausible repair generated by nopol protected void dropphase1objective if precision.compareto entry 0d maxulps if numslackvariables constraints.size ... figure patches generated by sketchfix and nopol for the defect math33 we believe that the repair generated from the fine grained transformationintroducesasmallerperturbationtotheoriginalfaulty program and is conceptually easier to comprehend.
apart from the fine grained transformation our candidate rankingstrategybasedonthelocalityalsohelpsgeneratinghigh quality patches.
figure a shows an expression manipulation that replacesthevariable valuewithv whichisthemaximumvalueofthe variable valueand the field lowerbound .
bothvandlowerbound satisfyalltestassertions yetsketchfixfavorsthevariable vbecauseit isdefinedatthepreviousstatementoftheholewhereas lowerbound is a field in the class.
with the insight that the variables defined closertotheholesaremorelikelytobeused ourpracticalcandidate ranking strategy is in line with other repair techniques that aimtoimprovepatchquality suchasanti patterns program distance and syntactic similarity .
related work thissectioncomparessketchfixwithotherapproachesonprogram repair and program synthesis.generate and validate repair.
generate and validate repair techniques apply a setof transformations to generate a setof candidates and validate each candidate against the given test suite.
to efficientlyexploretheimmensesearchspaceofrepaircandidates inlarge scaleapplications theseautomatedprogramrepairtools leverage genetic algorithms random search semantic authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden jinru hua mengshi zhang kaiyuan wang and sarfraz khurshid search and adaptive search to find a repair that let all test cases pass.
kali applies code removal and debroy et al.
employasetofmutationoperators e.g.
arithmeticoperators and tofixfaults.astor isaprogramrepairlibrarythat includes the re implementations for genprog kali and mutation based repair to fix java code.
to prioritizerepairs par manuallylearns repair patternsfrom the human written patches .
other g v techniques automatically mine repair models from historical data .
codephage eliminates defects by transferring correct code across applications.genesis alsoautomaticallyinfersrepairmodelsbased onthehuman writtenpatches.somerecentworksleveragedocument analysis anti patterns test generation and location selection with test pruning to enhance repair.
sketchfix differs from these g v approaches in that it tightly integrates the generation and validation phase of the repair candidatesandonlygenerateson demandonesduringthetestexecution.
thisintegrationsubstantiallyreducesthesearchspaceoftherepair candidatesandeffectivelypruneslargeamountofre compilation and re execution of the potential repairs.
moreover a number of approaches that aim to imp rove thepatch quality are complementary to ours.
in particular we can use mined repair models and document analysis to prioritize candidates and support more transformation schemas at a fine granularity.
constraint solving repair.
programrepairtechniquessuchas nopol andangelix dynamicallycollectpathconditions andinferconstraintsbasedonthepassingandfailingtestexecutions .theseconstraintsarefurthertranslatedtosatfor sat smt solvers to synthesize a repair that satisfies all inferred specifications.spr infersatargetvalueforthefaultycondition basedonthetestsuite.minthintusesthesymbolicexecutionandstatisticalcorrelationanalysisforthepatchranking.s3 extends thesemantics basedfamilylikesemfix andangelix to incorporate a set of ranking criteria such as the variation of the execution traces similar to qlose .
by inferring constraints based on the execution and translating these constraints to sat these repair techniques may yield incomplete translation or impractical problem of creating modelsforallrelevantlibraries .ingeneral theyexclusively reason about booleanorintegertypes in conditions or the right side of assignment.
they may suffer from the limitations of thesymbolic execution engines to extract constraints.
e.g.
angelix cannotexecutelibrariessuchas python lighttpd andfbcduetothe limitation of klee.
sketchfix is substantially different from these translation based techniques as its sketch backend explores the actual program behaviors in presence of libraries and does not translate to sat smt.
sketchfix thus works well in manipulat ing expressions and handles a whole range of variable types and transformation locations e.g.
sketchfix fixes a bug by replacing avariableinacastexpressionattheastnode level.inaddition sketchfixisnotconfinedtothestructureofthesubjectsaslong as the subjects can be executed.
therefore it can be applied to the projectslike closure compiler whosetestcasesareorganizedusing scriptsratherthanstandardjunittestcases.thisnon conventional structure has obstructed some repair techniques like astor.
automated program repair based on the formal specifications hashadnumeroussuccess.autofix e isabletorepaircomplexdata structure for eiffel program but it relies on human written contractstogeneratefixes.gopinathetal.
usepre andpostconditionswritteninalloyspecificationlanguagetoidentifydefectsandrepairtheprogram andwerethefirsttoconjecturethe reduction of program repair to program sketching f r o mt h e bestofourknowledge.singhetal.
usespecificationtogenerate feedback for students faulty python program.
kneuss et al.
generate test inputs automatically from the specifications to fix faulty scala programs using deductive program synthesis.
yet formal specificationsare usually notavailable forprojects written in imperative languages.domain specific repair.
clearview eliminates security vulnerabilitywithinferredinvariants.demskyetal.
usedaikon to infer invariants for data structure repair.
vejovis infers possible string replacement for dom related faults in javascript codethroughstringconstraintsolver.similartovejovis phprepair usesstringconstraint solvingtofixphpprogramsthat generatehtml.theseapproachessharesimilarspiritwithconstraintsolving repair and thus may encounter similar limitations.program synthesis.
program synthesis has shown its promise on synthesizing code in small well defined domains such as bitvectorlogic anddatastructures .inparticular sketch based synthesis asks programmers to write a program skeleton containingholes andusescounter example guidedinductivesynthesis to complete the holes.
however these approaches require to transformconstraintstosatformulas whichmightbeimpracticalin large scaleprojectswithexternallibraries.edsketch isapractical execution driven sketching engine thatsynthesizes sketches with backtracking search yet it requires users to provide partial programsastheinputs.recentwork enhancededsketchto supportmethodsequencegenerationforapicompletion.differentfromedsketchandotherprogramsynthesistechniques we translate existing faulty programs to sketches with the purpose of repairing the original faulty programs.
conclusion this paper introduced an on demand repair technique sketchfix which tightly integrates the traditionally separate phases of generationandvalidationofcandidateprogramsthatrepresentpotential fixes to consider for the given faulty program.
utilizing runtime information thisintegrationeffectivelyprunesalargeportionof thesearchspaceforthecandidatefixes.thetechniquereducesprogram repair to program synthesis by transforming faulty programs to sketches at the ast node level granularity.
sketchfix employs an execution driven sketching engine to complete the sketches using a backtracking search.
the experimental results show that sketchfixworkswellinmanipulatingexpressions andthefinegrained transformation schemas it employs allow it to generate high quality patches.