responsive designs in a snap nishant sinha ibm research india nishant.sinha in.ibm.comrezwana karim rutgers university usa rkarim cs.rutgers.edu abstract with the massive adoption of mobile devices with different formfactors ui designers face the challenge of designing responsive uis which are visually appealing across a wide range of devices.
designing responsive uis requires a deep knowledge of html css as well as responsive patterns juggling through various design configurations and re designing for multiple devices is laborious and time consuming.
we present decor a recommendation tool for creating multi device responsive uis.
given an initial ui design user specified design constraints and a list of devices decor provides ranked device specific recommendations to the designer for approval.
design space exploration involves a combinatorial explosion we formulate it as a design repair problem and devise several design space pruning techniques to enable efficient repair.
an evaluation over real life designs shows that decoris able to compute the desired recommendations involving a variety of responsive design patterns in less than a minute.
categories and subject descriptors d. .
user interfaces case general terms algorithms design keywords responsive layout inference constraint based design html css .
introduction the massive growth of mobile and tablet devices has compelled both enterprises and individual developers to create uis viewable on multiple devices.
the solution is to create responsive designs which adapt to device environments e.g.
different form factors.
they provide optimal viewing experience across devices by allowing users to read and navigate a page easily and minimizing the effort spent on window resizing panning and scrolling.
indeed was named the year of responsive design1 .
1the term responsive may have multiple informal meanings here permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c circlecopyrt2015 acm.
isbn .
and css are the de facto web design languages offthe shelf browsers can render such designs for mobile platforms.
html css designing requires deep expertise both for i encoding layouts in css and ii various layout transformation patterns that lead to responsive designs.
non experts instead may prefer either programming by demonstration constraint based design or a combination of these approaches.
a design demonstration consists of a set of ui elements or widgets laid out on a canvas e.g.
of a wysiwyg editor nested layouts are specified using container boxes .
design synthesis engines are used to create renderable html css files from the specification.
alternatively the designer may specify a partial ui layout on a canvas and then add constraints on the alignment positioning and relative sizes of ui elements e.g.
min width of a text box max margin between two adjacent elements.
constraint based ui design has a rich history by enabling the designer to focus on the desired design properties instead of how to encode them constraints reduce the layout specification burden.
these constraints are finally used by a layout engine to render a device specific design.
desktop uis have a dedicated layout engine which solves the constraints and renders design on the fly.
in contrast for web uis a browser s layout engine understands only html css natively hence the page synthesis engine should transform the design constraints into css rules.
creating responsive layouts which adapt smoothly to different devices is non trivial.
a naive approach to adapt ui designs to devices is by creating so called fluid designs where ui elements shrink or expand in a fixed ratio to their parent.
however such re sizing leads to cluttered appearance and overlapping elements as devices become smaller.
instead responsive layouts employ multiple transformations on ui elements rearrange resize replace change visibility move elements across pages etc.
further to enable efficient encoding in html css the layouts cannot be rearranged arbitrarily horizontal vertical alignment of elements may change freely e.g.
rows transformed to columns but the parentchild relationships are generally preserved across layouts.
visual tools like adobe reflow assist users in adapting a particular design to different form factors using direct manipulation.
however the designer must juggle through a large number of possible designs manually fixing designs through a laborious trial and error process.
further the tool does not provide any layout recommendations.
grid based css libraries e.g.
bootstrap allow designers to annotate ui elements with css classes having pre defined responsive behaviors e.g.
a 2x2 grid will transform to 4x1 grid at the mobile form factor.
manual annotation is laborious and error prone it is easy to specify wrong annotations which are hard to debug without a deep knowledge of the library and css we refer to designs whose layouts adapt to different form factors.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
544figure top real world example of a responsive site.
below decor a responsive design recommendation tool.
layouts.
constraint based design holds the promise of reducing the manual design effort.
however existing constraint based approaches are ineffective for responsive design because they search over a restricted design space.
for example most techniques try to preserve the ui element alignments from the original design during adaptation and do not explore designs having grid based rearrangments during solution discovery.
consider the original design layout in fig.
top which is adapted to the small tablet stp form factor in fig.
bottom left .
current approaches can shrink the original layout to the one shown in the stp left area but cannot produce the desired layout stp right which requires changing the alignment of multiple elements from horizontal to vertical.
because of their reduced search space these techniques are forced to declare the constraint set inconsistent or drop inconsistent constraints arbitrarily to keep the layout aesthetic.
we present a constraint based design recommender tool decor to assist the designer in creating multi device responsive uis fig.
b .
given an initial ui design user specified constraints on elements e.g.
width or margin and a list of device form factors decor provides ranked device specific recommendations to the designer for approval.
intuitively decoris to responsive design as contentassist tools are to programming the latter improve developer productivity by providing features like auto completion and ranked suggestions while decorprovides design recommendations to enable rapid multi device design.
the designer may specify constraints for each form factor and let the tool provide suggestions for each form factor.
if the designer does not approve of any suggestion she may refine the constraints and query the tool again.
to our knowledge decoris the first tool to provide multiple responsive design recommendations.
the design of decorrelies on two main observations.
first we observe that ui designs are essentially labeled trees and responsive designs may be obtained by one or more tree transformations .
consider a designdwith the design tree t containing an ui element nodenwith children c1andc2laid out horizontally on being rendered nis ahbox .
supposec1andc2appear too narrow on the tablet device.
we can fix dby transforming the orientation of nto vbox wherec1andc2align vertically and hence appear sufficientlywide.
we formalize responsive design as a design repair problem given a ui design and a set of design constraintsc compute the set offixes so that the fixed design satisfies cfor each desired device.
the notion of a fixis at the core of our approach a fix effectively characterizes the designer s actions as she goes about adapting the design for different devices.
our second observation is that although the total number of potential tree transformations space of designs is huge only a few transformation patterns are used in practice.
however trying out all permutations of even this smaller set of transformations on real ui design trees leads to a combinatorial explosion.
to build a practical tool we devise several pruning heuristics which exploit the independence of fixes similar to partial order reduction methods and bias the search towards more general and ordered fix sequences to prune the search space cf.
sec.
.
we evaluate decorover a representative set of synthetic and real life ui designs.
our results show that decoris able to compute several design recommendations involving a variety of responsive design patterns in less than a minute.
the recommendations obtained are realistic i.e.
they precisely mimic the responsive behaviors created manually by experienced designers of real life responsive sites.
in some cases decoris also able to suggest alternative design repairs which require fewer fixes as compared to the original responsive site.
the paper makes the following contributions.
we formalize the responsive design problem as a constraintbased repair problem over labeled design trees.
we present a new specification language to specify constraints over ui elements for multi device designs.
we model the space of design transformations using a design tree graph dtg whose nodes are design trees and transitions are repairs.
an algorithm is presented to search over a dtg systematically to find designs satisfying constraints.
we present efficient pruning heuristics to avoid combinatorial explosion during dtg exploration by avoiding redundant fixes exploiting mutual independence of fixes and enforcing a tree based ordering on fix sequences.
we describe an implementation and an evaluation of decor a tool for creating multi device responsive designs.
we demonstrate that decoris able to provide realistic recommendations for real life designs within a minute.
we conduct a study to compare the user experience with decoragainst a commercial responsive design tool.
.
overview of the approach consider the ui design dshown in fig.
top left based on a real life responsive website .
suppose designer uses a wysiwyg design tool or a mockup builder to create this design for the desktop form factor width 1200px .
now she wishes to adaptdto be visually appealing for the following devices form factors i tablet landscape width 1024px ii small tablet portrait width 600px and iii mobile portrait width 320px .
instead of manually tweaking dfor each form factor the designer uses decorto obtain desired designs.
first she provides a set of design constraints on attributes of ui elements e.g.
minwidth min margin font size or their combinations cf.
sec.
.
.
decorthen generates ranked design recommendations for each desired form factor that satisfy the above constraints.
now the designer picks one of the designs if she approves of it otherwise she adds more constraints and asks decorto come up with better recommendations.
once the designer approves all the designs 545figure an illustrative responsive design example for tablet small tablet portrait stp and mobile portrait mop form factors.
dotted borders mark visually unappealing ui elements solid borders show the fixed versions.
decorgenerates faithful html css files encoding the designs which may be viewed in any off the shelf mobile desktop browser and responds to form factor changes.
to adapt the original design d the tool first extracts a hierarchical annotated design tree dt tfromd cf.
sec.
for details shown in fig.
top right and then repairstto satisfy all constraints for each form factor ff f. repairingtfor eachfinvolves computing one or more sequence of fixes called fix chains .
each fix chain transformstto a visually appealing tree t primeforf.
these fix chains are then ranked and the designs encoding the repaired trees are shown as recommendations.
we describe how decorworks for the tablet landscape tl ff.
decorstarts with most obvious repair it shrinks the original design preserving relative sizes of elements to the width of tlff.
this design is not visually pleasant e.g.
the following elements appear too narrow email input and subscribe button under the newsbar the navbar sidebar and the four ip i i elements fig.
tablet .
to eliminate these issues the designer specifies constraints a min width navbar 200px which applies tonavbar 1in all ffs.
further she determines that the sidebar should now be invisible and specifies constraint b hidden sidebar for all ffs less than tl.
similarly c min width constraints for input button andipielements are specified.
now decoruses these constraints to fix the design it applies fixes from its fix library cf.
sec.
.
to repair the design.
here the computed fix chain has fixes.
first the fix hide element is applied on the sidebar.
then the fix reduce column red col is applied on the body element body has two columns div1anddiv2 boxes in the original design this fix converts body into a single column i.e.
it stacksdiv1overdiv2.
the resulting design is shown in fig.
tablet middle elements fs image andnavbar 1appear too wide again making the design unpleasant.
the designer specifies amax width fornavbar the tool then applies the fix red row to obtain the desired design fig.
tablet right .
note how the minwidth constraints for input andbutton elements inside newsbar are satisfied without applying fix directly on them fixing the higher closer to root tree nodes often obviates the need for fixing specific lower nodes and leads to short fixes.
546for small tablet portrait stp ff decoragain shrinks the previous design to stp s width fig.
stp .
now the unpleasant elements are navbar email subscribe and ip i. suppose the designer decides to hide navbar 2for stp and adds constraints for above elements.
now decortries to satisfy all given constraints for stp it applies red col on newsbar move input and button to a new row and red col on content i.e.
convert from column row box to column row box to obtain the desired design for stp stp right .
on shrinking this design to mobile portrait mop ff fig.
mop navbar 1and ip iappear squished.
decorapplies red col on both topbar navbar 1gets a new row and content switch to column rows to repair this design.
discussion.
note that a designer may not conceive of all constraints upfront she may need to add constraints interactively and re run the tool multiple times.
constraints and fixes are notrelated one to one a single constraint may determine fixes for multiple ffs which saves the designer from re applying the multiple fixes manually.
to fix designs manually without constraints the designer must be able to visualize the design hierarchy and various fix interactions mentally and adapt the design by trial and error which becomes unduly hard with complex designs and longer fix chains.
.
preliminaries designing uis.
static ui design involves defining the ui elements thelayout e.g.
left to right alignment of elements and the styling e.g.
color font size of elements.
either direct manipulation tools e.g.
adobe photoshop or ui programming frameworks or a combination of them may be used.
for creating web uis html and css are the de facto languages javascript is used for the dynamic behavior .
web ui programming involves a significant learning curve most direct manipulation tools do not generate good quality code and end users or unskilled designers struggle to encode their designs in html css .
devices and form factors.
recently a variety of mobile devices have become available.
these devices are distinguished by their display form factors i.e.
width height ratio in pixels denoted aswidth xheight devices may be categorized into following major categories desktop tablet phone having widths 1200px or more 500px 800px and 320px 480px respectively.
further phones and tablets typically support both portrait andlandscape modes.
breakpoints viewports.
abreakpoint is intuitively a transition point for the design and is specified by its width e.g.
700px transition points affect noticeable discrete visual changes in the design cf.
fig.
a .
a designer picks breakpoints in order to ensure visual appeal on a small subset of devices each breakpoint bpcorresponds to one or more devices having width close to bp.
in this paper we use the term device orform factor to specify device properties viewport to denote the design container or renderer e.g.
the browser andbreakpoint to specify the viewport width at which the design changes.
viewport may correspond either to the entire device screen or the reduced width of a resized browser.
responsive designs.
a declarative specification in html css may be rendered on different devices or viewports in completely different ways.
although the underlying structure html remains same the layout positioning styling and visibility of elements may be changed via css3 rules specific to devices or viewports.
these rules can be specified using media query directives based on a combination of device and viewport properties different css rules may be triggered.
for the example in fig.
we write media min width 1200px sidebar display block media min width 1024px and max width 1200px sidebar display none to make sidebar element visible for viewports of width px and hide it for lower width viewports.
media queries can be complex boolean combinations of various device properties and allow designs to adapt to devices in non trivial ways.
ui designs formally.
a designdconsists of a collection of ui elementsb basic widgets containers represented as rectangular objects also called boxes .
non rectangular ui objects e.g.
images are represented by their bounding boxes.
design tree dt .
we represent a design formally using a design treet n ch orn which consists of a set of nodes n and mapsch ornand .
we useroot t andleaves t to represent the root node and the set of leaves of t respectively.
given a node n n ch n denotes the ordered list of children of nint.
the leaves oftcorrespond to basic ui widgets e.g.
button selection image section and intermediate nodes are containers.
functions orn and capture the design features of t orn n denotes the layout of children of nand n denotes the styling positioning and other attributes of n as explained below.
styling.
each noden nis labeled with a set of attributes which determine the size position and visual appearance of non being rendered.
given a set of attributes adrawing values from set va the attribute map n a va which maps a node n and an attribute a a to a valuev va. attribute values may be specified either using absolute measures e.g.
in pixels px or relative to parent of n using percentages.
percentage values allow the design to be fluid.
for example suppose a child node nhas width of its parent the root element r. now if we reduce the rendered width of r n s width will also shrink in the same ratio.
although responsive designs are fluid in general fluidity is not enough elements typically are rearranged to adapt to devices.
hierarchical layouts grids hvboxes.
a dt is rendered as a nested collection of boxes different layouts are obtained by aligning children boxes vertically orhorizontally inside the parent container box.
we specify the orientation of each non leaf node pusing a generic grid box primitive orn p k l means that the children ofpare aligned into a grid with krows andlcolumns and pis said to be a k l box.
when k l we say that pis a hbox vbox i.e.
contains a single row column of elements.
as we will see later the grid box notation allows us to capture layout transformations conveniently.
rendering design trees.
a dttmay be visualized using a suitable renderer e.g.
an off the shelf browser.
the renderer interprets tand projects it on to a d plane as a flatdesignd b r wherebis a set of visible ui boxes corresponding to nodes in tand the attribute map ris defined for each b b. for a boxbn b corresponding to n n r bn n and r bn p is defined in absolute pixel values for all position and size attributes p e.g.
left top height width.
given a device of form factor f wxh we say that a tree tfitsthe device if the rendered box brootforroot t is narrower than w i.e.
r broot width w .
.
constraint based design repair given an initial dt tdrawn for a breakpoint bp e.g.
1200x768 we want to transform tinto a new tree t primewhich is visually appealing for a lower width breakpoint e.g.
800x600.
once t primeis obtained we can encode tandt primetogether into html css automatically using media queries and rules presented in .
we can obtaint primebyshrinking the width of all elements by a fixed ratio however this may lead to visually unpleasant designs e.g.
text may be unreadable page elements may overlap or appear cluttered.
to create a repair strategy we first must define what a goodlooking design is.
while it is hard if not impossible to quantify visual appeal precisely we can often characterize design deficiencies 547constants k n true false strings numbers .. tree nodes n node attributes a a width height margin min width font size .. operators .. breakpoints bp b 1024x768 320x480 tab stp mop all ... constraintsc bpl bp bp l n l cx k cx n.a summationtext k cx k n n hidden n halign n1 n2 valign n1 n2 table constraint language for multi device designs.
l linear predicate cx constraint expression.
expressions should be type correct.
bp alldenotes the set of all breakpoints.
in terms of constraints on size spacing and other attributes e.g.
a design is not looking good because an image is too wide or a paragraph text is too narrow.
therefore we ask the designer to supply a set of design constraints on ui elements a design satisfying these constraints is assumed to be visually appealing.
given a set of constraints c we can repair tin large number of ways to satisfyc e.g.
we may fix the size attributes of nodes or change their orientation or move around subtrees in t. our key observation is that designers rely only on a small subset about of these fixes for creating responsive designs e.g.
converting rows to columns or vice versa changing margin sizes fonts and hiding optional controls.
these patterns are applied carefully only to a selected set of tree nodes and are in many cases independent of each other.
these observations allow to devise a systematic approach to search over the set of possible fixes efficiently.
our constraint based repair framework is extensible both constraints and fixes can be added enabled and removed on demand.
.
design constraints formally design constraints are logical predicates on properties of tree nodes e.g.
attributes width margin orientation and the parent child relationships e.g.
for a paragraph ui element p p.width 600pxis an instance of a max width constraint.
constraints may refer to multiple elements simultaneously e.g.
n1.width n2.width 200px for nodesn1andn2.
table shows our constraint language formally.
the language is inspired by and generalizes the constrained css language which allows specifying linear constraint rules in addition to css rules.
to design for multiple devices each constraint may be specified for one or more breakpoints bpl.
for example n1.width 300px constrains the min width of n1to be 300px for all breakpoints.
named predicates n allow specifying additional constraints hidden n constraintsnto be invisible halign n1 n2 valign constrains sibling nodes n1andn2to be horizontally vertically aligned.
trees satisfying constraints.
a dttis said to satisfy a constraint denotedt iff evaluates totrue given the node attribute values int.
given constraints c we say that tsatisfiescfor a breakpointbp t bpc ifft for each constraint of form c. our goal is to find alltreest bpcfor each breakpointbpand allow the designer to select the desired one.
.
design fixes afixis the basic unit of design tree transformation.
given a dt t n ch orn a fix may modify either i the set of nodes n insert or delete nodes or ii the ordering of children ch or iii the orientation orn or iv one or more attributes height width fix name description fix description red margin reduce margin res child modify children width ratio red row reduce rows red col reduce columns reorder child reorder children nav to select replace list byselect add del node delete add node mod line change line height mod img change image size mod txt change text properties table list of common fixes.
margin font size ... of a node n n. multiple fixes may be required to repair a t i.e.
satisfy constraints c. table shows common fixes used in responsive designs .
for example applying red row fix at noden orn n 2x2 grid box cf.
sec.
?
?
reduces the number of rows of n e.g.
orn prime n 1x4 grid box whereas red col reduces the columns increases rows of ne.g.
orn prime n 4x1 grid box .
each fix targets one or more types of constraint violation distinctly e.g.
red margin reduce margin values targets the constraints over min width or max margin of elements.
dt nodes are not explicitly added removed their visible attribute is toggled.
decortakes a fix libraryfas input and uses fixes from fto repairt.
acombination of these fixes gives rise to popular responsive patterns .
for example the columnflip andmondrian patterns can be captured by red col andred row fixes.
similarly basic gallery column drop orcolumn flip patterns are different instances of the red col fix depending on the number of elements in the grid.
formally a fix is a rewrite rule at a node noft n ch orn n ch prime orn prime prime where are the child nodes of nintand functions ch ornand ch prime orn prime prime denote the children orientation and attributes resp.
for tbefore after transformation.
we describe the fixes red margin andred col informally here.
detailed rules for fixes in table are omitted to the full version of the paper .
recall that nis rendered into nested boxes margin border and content boxes.
the red margin fix onnincreasesn s content box width and decreases left right margins of n without changing the margin box width of n. it first computes the margin value that can be deducted from n s current margin value without violating the min margin constraints on ninc if they exist .
both left and right margins are then reduced by in turn the width of content box of nis increased by the total reduced margins.
this expands the contents of n and its children which now may satisfy a min width constraint.
note how a single fix may satisfy falsify multiple constraints min margin min width .
thered col fix applies to most designs.
suppose nis a k l box withmchildrenc1 ... c m red col reduces the number of columns lofn increasesk in turn .
fig.
shows two red col fixes applied in sequence k l on a design extracted from fig.
.
the fix transforms ninto a k prime l prime box where the columnsl primeis the largest factor ofmless thanl.
the new width and margin values for children ciare as follows margins the top bottom margin for each ciis set to the maximum of a predefined global min margin value and their left right margin values in previous k l box.
for the new rows added to box of n we compute an average horizontal left right margin value from the previous left and right margin values of each child.
in case the new margin value is lower than min margin constraint iforcithen we set it to i. widths for updating width of each ci red col uses a simple heuristic the margin box width for each ciis obtained by dividing the width of namong each child ciin a row of k prime l prime using their relative width ratio.
this relative width ratio is computed fromci s width in k l .
finally the width of content box ofciis obtained by deducting already computed left right margin values for 548img img img img p1 p2 p3 p4v1 v2 v3 v4h1 img img p1 p2v1 v2h1 img img p3 p4v3 v4img p1v1h1 img p2v2figure illustration of the responsive pattern.
eachcifrom corresponding margin box width.
other heuristics for margin and width computation are also possible after fix is applied the designer can further fine tune these values.
we have designed most fixes to be local i.e.
a fix on nkeeps its margin box fixed and hence does not affect its non subtree nodes in the tree.
in general fixes and constraints interact in complex ways applying a fix may lead to satisfaction of some constraints and violation of others.
in other words fixes may enable ordisable other fixes.
therefore different permutations of fixes may lead to different designs.
to ensure we obtain multiple satisfying dts we need to explore several permutations of multiple fixes.
because the number of such fix sequences is huge we introduce design tree graphs to explore representative fix sequences systematically.
.
design tree graphs adesign tree graph dtg g q r t over a fix libraryfand constraintsc consists of a set of states q set of initial states a set of transition labels transition relation r q qand a mapping function t wheret q is the dttcorresponding to state q. the set qconsists of good statesqwith satisfying trees i.e.
t q c. each transition labelg is a pairg n f wherenis a node in a dt and f f. given a state q dtt t q and labelg n f where n t q andf f transition q g q prime riff applying fto nodenintresults int primeandt q prime t prime.
the outgoing edges of a stateqingrepresent the set of valid fixes described below which may be applied tot q .
we construct a dtg separately for each breakpoint each initial state corresponds to a tto be repaired.
finding responsive designs boils down to exploring paths of g to find a good state.
alg.
shows the algorithm for constructing a dtg and finding all good fix chains which lead to good states.
for a breakpoint bp the algorithm starts with a satisfying tree t0from the previous breakpoint shrunk tobp s width.
getvalid fixes computes the set of valid node fix pairs prime at a stateqover libraryf cf.
sec.
.
each node fix pair in primeis applied iteratively using procedure apply fix to obtain new tree t primeand stateq prime.
a dtggmay contain cycles the algorithm uses a state matching criterion to detect cycles and avoid loopy fix chains.
example.
recall the designdfor the pattern shown in fig.
.
we now describe how explore dtg algorithm constructs the dtg fordforstpbreakpoint shown in fig.
.
the algorithm starts with the initial state containing the dt t0ford h1is a box .
suppose after shrinking to stp the width of imgiint0violatesc.
fixingimgidirectly may not be useful instead we may need to fix one of its ancestors.
let us define the bad nodes in a dt to be all nodes whose some descendant violates c. here bad nodes in t0are imgi vi h1 .input breakpointbp initial design tree t0 constraintsc fix libraryf output set of satisfying fix chains t q0 t0 r q q0 g q q r t explore dtg q0 epsilon1 explore dtg q is current fix chain t t q ift bpc then q return prime g etvalid fixes t f primeis an ordered list of pairs n f if primeis empty then return backtrack foreachg primedo t prime a pply fix g t create freshq primewheret q prime t prime prime g q q prime r q g q prime explore dtg q prime prime algorithm computing all satisfying fix chains.
h1 red margin v1 red margin v1 red row red col v1 v2 red row red col v2 h1 red col h1 red col v2 red margin q1 q2 q3q4 q5q6 q7 q prime figure a snippet of the dtg for fixing the original design columns for pattern shown in fig.
.
suppose explore dtg picks a bad node v1to fix and applies red margin tov1 stateq4 stillimgiis too narrow.
the algorithm continues to apply fixes red row which makes v1single row and shrinksimgifurther followed by red col tov1.
at this point it detects a cycle and backtracks without success.
suppose after trying to fixv2 v3andv4similarly the algorithm backtracks to q1 without success.
now explore dtg picks nodeh1and applies fixred margin toh1to reach another bad state q2.
the red col fix is applied to h1 converting it to a box at state q prime treet prime .
because the image widths now satisfy c we obtain a good fix chain h1 red margin h1 red col for stp.
the algorithm will also find a shorter chain h1 red col for stpleading to tree t3atq3.
after finishing with stp explore dtg computes fix chains for the next breakpoint mop starting from either t3ort prime .
a satisfying dt for mop breakpoint is obtained by applying red col toh1again resulting in all vi s being aligned vertically.
explore dtg is inefficient in multiple ways.
the algorithm tries to fixvi s unnecessarily.
although we cannot rule out fixing vi s statically red margin may be a valid fix we can avoid red row forvibecause applying red row will not satisfy the min width constraint.
similarly we can avoid the large number of fix permutations onvi s because they are tree siblings and can be fixed independent of each other.
the algorithm may try to both fix vifollowed by h1and vice versa.
in most cases fixing nodes in the tree order h1 followed byvi is sufficient.
we now present a set of optimizations to explore dtgs more efficiently.
.
efficient exploration of dtgs given a tree twithnnodes and fix library f the number of fix chains in the corresponding dtg is o n!
pn wherep f .
we present path pruning heuristics to explore a small 549input design treet fix library f constraintsc output fix list prime getvalid fixes t f b nodes from tviolatingc g sortbin decreasing tree height order foreachn bdo f prime g etvalid nodefixes n f prime prime return primefix node properties red col vbox red row hbox or root red margin no min.
margin nav to select non navbar red font no descendant with text a b figure a the algorithm getvalid fixes b a list of invalid fixes and their target node properties.
q1 q2q3b1 b2 b3 b1 b2 b3b1 b2 b3fixf1 fixf2 fixf2 red margin red col fixf1 figure a dts fragment illustrating dependent fixes.
representative set of fix chains in dtg based on i pruning the fixes applied to each node and ii selecting the order of nodes to fix.
the latter may omit some satisfying dts from exploration however in our evaluation no desired dts were eliminated.
valid and enabled fixes.
given a dtg state qwith treet the set ofvalid fixes atqconsists of fixes which may be applied to some node intbecause their pre condition is satisfied.
in general many fixes are invalid e.g.
we cannot apply red col on a vbox element orred margin on a node with no margin or reduce font on non text nodes.
for each node n the procedure getvalid nodefixes computes only the valid fixes tab.
and prunes away the rest e.g.
red row in fig.
.
the procedure getvalid fixes combines these fixes for the bad nodes in tand ranks them to obtain enabled fixes primeforq.
redundant fix pruning.
we can prune the valid fix set further by removing fixes which may not help satisfy any violated constraint inc. we detect them by relating the constraints violated and the bad nodes inn s subtree as follows.
ifnis a bad node but none of descendants are bad then fixes red col andred row are redundant.
this is because both these fixes modify only n s descendants not n e.g.
in fig.
suppose the min width for vis is violated but its children imgiandpiare not.
applying vi red col does not change vi s width only its children s width.
applying red col red row onnis redundant if none of its descendants is violating min width max width constraints.
applying red margin if i max width is violated for n i.e.
width n max width n red margin increases the width of n or ii nviolates its min width constraint and maximum margin reduction is not enough i.e.
width n max marginreduction n min width n .
cf.
red margin fix .
the second optimization tries to detect equivalent fix chains in a dtg which correspond to re orderings of independent fixes.
independent fixes.
two fixesf1andf2on nodesn1andn2 respectively are said to be independent if i applying one fix does not disable the other and ii the t primeobtained after applying both f1 andf2does not depend on the order in which the fixes are applied i.e.
the fixes commute .
the notion of independence allows us to explore only the representative fix chains of enabled fixes.
most fixes in table commute with each other leading to the same dt irrespective of the application order.
however depending on the given constraints fixes may disable each other.
fig.
illustrates a portion of the dts for a design with three boxes b1 b2andb3.
in the initial state q1 the min width criteria for both b2andb3 is violated i.e.
bad nodes are b1 b2 b3 .
there are two ways to fix it by applying fix f1 red col on b1or by applying fix f2 red margin on b2andb3.
the two fixes are dependent on each other applying f1leads toq2 with no bad nodes and hence f2is disabled.
similarly applying f2atq1disablesf1inq3.
fixes which only affect the subtree of the target node cannot disable each other because they apply to non overlapping subtrees e.g.
in fig.
fixes red margin red row andred col can be applied to each of the nodes v1 v2 v3andv4and are independent of each other.
for example the fix pair v2 red margin enabled at state q1 remains enabled at q4andq5 after applying fixes to v1.
efficient exploration of graphs with dependent transitions is a hard problem several generic partial order reduction methods for program state space exploration have been developed.
we extend these methods to our problem by exploiting the fact that states in a dtg correspond to trees.
pre order fix chains.
a pre order linearization pre t of a dt tis a node sequence obtained by traversing tin pre order.
because dts are ordered a unique linearization hatwidestpre t exists for each dt t. given a fix chain s n1 f1 nk fk we define the node projection ofs s as the sequence n prime n prime n prime lsuch that i n1 n prime 1andnk n prime l ii s preserves the node order of sand does not stutter i.e.
for all i k n prime i negationslash n prime i .
a fix chain s overtis said to be pre order iffs is a sub sequence of hatwidestpre t .
for example in fig.
the fix chains and are pre order but is not.
we observed that fixes on higher tree nodes affect a large number of nodes and few such fixes in contrast to lower node fixes are sufficient to yield most desired dtgs.
pre order fix chains are biased towards such fixes fixes are applied on the parent node first followed by children.
also pre order fix chains process siblings in a fixed order allowing us to avoid permutations of independent fixes and narrow the search space.
we therefore constrain explore dtg to search only for pre order fixes by checking on the fly if the current fix chain is a sub sequence of the dt linearization.
given a tree t withnbad nodes number of sub sequences of pre t iso n p!
wherep f .
although still large this bound is significantly lower than the earlier bound o n!
pn .
ranking fix sequences.
decorranks the obtained fix chains alg.
as follows.
shorter fix chains are ranked higher than longer ones.
for fix chain sands primeof equal length sis ranked higher if between nodes niandn prime iatithindex resp.
nihas a higher tree height thann prime i. we can also shorten fix chains to remove irrelevant fixes before ranking them cf.
sec.
.
.
implementation and ev aluation we implemented decoras a plugin to maqetta an opensource wysiwyg editor which allows creating designs by dragdrop and then specifying css properties.
the plugin extracts the design as a json file and sends it to a backend server node.js application which provides responsive design suggestions.
the backend takes in user specified constraints and breakpoints also in json format.
we run a simple checker to identify any inconsistency in the input constraints before running decor e.g.
min width is higher than the max width constraint for an element.
decorcan operate in two modes default andinteractive .
in 550thedefault mode decoris fully automated it finds all possible fix chains for each breakpoint ranks them applies the highest ranked fix chain to get the repaired design for that breakpoint and proceeds to the next smaller breakpoint.
in the interactive mode user shrinks the design up to a certain breakpoint identifies constraint violations adds new constraints and invokes decorto get recommendations.
she can add remove update constraints and run decoragain to get a different set of recommendations.
finally the set of obtained design trees one for each breakpoint are encoded into a pair of html and css files using the technique in each tree is encoded into css rules separately and then combined using mediaqueries .
if multiple recommendations exist each of them gets its own css file.
decoris 15k lines of javascript code around 6k lines for repair computation .
we evaluate decorfrom two different perspectives.
q1 what are the characteristics of recommended fix chains and how effective are the pruning strategies cf.
sec.
?
q2 to test the overall usability of the tool understand the benefits and drawbacks of the proposed approach.
for the first part we ran decorin default mode and thoroughly study the recommended fix chains and computation times.
for the second part of evaluation we conduct a preliminary user study of the tool in the interactive mode.
benchmarks.
no standardized set of benchmarks for responsive designs exist.
however several online resources point to the popular responsive patterns and web sites implementing them e.g.
neil s slides and the marcotte s book provide a comprehensive overview of responsive design patterns.
from these