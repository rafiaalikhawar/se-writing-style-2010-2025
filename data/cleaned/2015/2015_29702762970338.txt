continuous detection of design flaws in evolving object oriented programs using incremental multi pattern matching sven peldszus institute for software technology university of koblenz landau germany speldszus uni koblenz.deg za kulcs r malte lochau real time systems lab tu darmstadt germany geza.kulcsar malte.lochau es.tu darmstadt.desandro schulze institute of software technology systems tu hamburg harburg germany sandro.schulze tuhh.de abstract design aws in object oriented programs may seriously corrupt code quality thus increasing the risk for introducing subtle errors during software maintenance and evolution.
most recent approaches identify design aws in an ad hoc manner either focusing on software metrics locally restricted code smells or on coarse grained architectural antipatterns.
in this paper we utilize an abstract program model capturing high level object oriented code entities further augmented with qualitative and quantitative designrelated information such as coupling cohesion.
based on this model we propose a comprehensive methodology for specifying object oriented design aws by means of compound rules integrating code metrics code smells and antipatterns in a modular way.
this approach allows for efcient automated designaw detection through incremental multi pattern matching by facilitating systematic information reuse among multiple detection rules as well as between subsequent detection runs on continuously evolving programs.
our tool implementation comprises well known anti patterns for java programs.
the results of our experimental evaluation show high detection precision scalability to real size programs as well as a remarkable gain in e ciency due to information reuse.
ccs concepts software and its engineering !maintaining software object oriented development software evolution keywords designaw detection continuous software evolution objectoriented software architecture1.
introduction object oriented programming o ers software developers rich concepts for structuring initial program designs in order to cope with the inherent complexity of nowadays large scale software systems.
in this regard design patterns serve as default architectural templates for solving reoccurring programming tasks in compliance with object oriented design principles like separation of concerns .
as nowadays software systems tend to become more and more long living their initial code bases have to be continuously maintained improved and extended over a long period of time.
in practice corresponding evolution steps are frequently conducted in an ad hoc and often even undocumented manner e.g.
in terms of ne grained manual program edits .
as a result the initial program design may be prone to continuous erosion eventually leading to structural decay whose negative side e ects are usually summarized under the notion of software aging .
in particular design aws potentially infecting object oriented programs may seriously corrupt code quality thus increasing the risk for introducing subtle errors during software maintenance and evolution .
object oriented refactorings have been proposed as effective counter measure against design aws by means of behavior preserving program transformations to be repeatedly interleaved with object oriented development work ows .
in fact a manual identi cation of problematic code structures to be removed by applying appropriate refactorings is tedious error prone or even impossible for largerscale software projects.
various approaches have been recently proposed to assist and or automate the identi cation of design aws in object oriented programs.
the di erent attempts may be roughly categorized into three kinds of symptoms potentially indicating object oriented design aws .
software metrics assess quality problems in program designs by means of quanti ed measures on structural code entities e.g.
high coupling and or low cohesion of classes .
code smells qualify problematic locally restricted code structures and anomalies in the small i.e.
at class method eld level e.g.
relatively large classes .
anti patterns qualify architectural decay in the large involving several classes spread over the entire program e.g.
god classes .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
ase september singapore singapore acm.
... .
based on this taxonomy a precise and reliable identi cation of actual occurrences of design aws in real world programs requires arbitrary combinations of software metrics with adjustable thresholds as well as code smells and anti patterns into compound detection rules .
however most existing approaches lack a comprehensive formal foundation and uniform yet modular representation of such designaw detection rules.
instead speci cally tailored detection routines are applied for every design aw individually and being re evaluated from scratch for every program version anew during software evolution .
in this paper we present a comprehensive methodology for specifying and automatically detecting design aws in object oriented programs.
the approach utilizes a uni ed abstract program model comprising those high level objectoriented code entities being relevant for a concise speci cation of well known design aws .
based on this model compound designaw detection rules integrate software metrics code smells and anti patterns and allow for arbitrary combinations thereof.
the modular nature of the rule language allows for sharing similar symptoms among multiple designaw rule speci cations.
the corresponding pattern matching routines derived from those rules incrementally augment the underlying abstract program model with qualitative and quantitative design related information.
this technique builds the basis for e cient designaw detection by systematically facilitating reuse of information among multiple detection rules as well as between subsequent detection runs on continuously evolving programs.
to sum up we make the following contributions.
a comprehensive rule based methodology for objectoriented designaw speci cation based on a uni ed program model integrating the entire spectrum of possible symptoms.
an e cient technique for concurrently detecting multiple design aws on continuously evolving programs based on incremental multi pattern matching.
a tool implementation automating the detection of well known object oriented code smells and anti patterns in java programs.
evaluation results gained from experimental applications of our tool to real world java programs.
the results demonstrate high detection precision and scalability to real size programs as well as a remarkable gain in e ciency due to information reuse.
please note that our tool implementation as well as all experimental data sets are available on our github site1.
.
background consider the sample java program in figure serving as our running example in the remainder of this paper.
the example comprises an extract from the source code of a simplied object oriented catalog software of a video rental shop.
the program design is further illustrated by the class diagram in figure .
originally the rental shop only possessed early horror classics like the blob from .
later on they decided to reward customers for frequent rentals by providing free bonus movies like the refactored remake of the blob from .
therefore a software developer extended the existing shop system by adding the source code parts highlighted in gray in figure .
his design decision was class shop private string shopname demoshop private list customer new arraylist private list movies new arraylist public void addcustomer string name ... public void addmovie string title int year ... public void rentmovie customer cu movie mo ... public void addcustomer string name int bonus customer movie new customer movie .
setname name movie .
setbonus bonus this .
customer .add customer public void addbonusmovie string title int year int level .. public void rentbonusmovie customer customer bonusmovie movie ... public void updatebonus customer customer movie movie ... public int calculatebonuspoints bonusmovie movie int bonus ... 20public class customer private string name protected list rents new arraylist private int bonus public void setbonus int bonus this .
bonus bonus public string getbonus return bonus public void setname string name ... public string getname ... 33public class movie ... 35public class bonusmovie ... figure source code of the video rental system to add a new sub class bonusmovie line to represent free bonus movies.
to store the achieved bonus points of each customer he added a eld bonus as well as a corresponding getter and a setter method for this eld lines to to the class customer .
in lines to the creation and calculation of new bonus movies and the required bonus points are implemented by four additional methods in the class shop.
during a subsequent maintenance phase a senior developer reviewed the evolved software system by re investigating the class diagram in figure again highlighted in gray to get an overview of the edits performed.
during code review the senior developer relies on quantitative software metrics e.g.
number of class members as well as qualitative characteristics of single classes methods and elds.
the recognition of such local symptoms of particular object oriented entities i.e.
so called code smells therefore relies on manual judgments based on the available metric values.
in this particular case the senior developer considered the shop class to be signi cantly larger than the other classes.
in addition the methods of class shop intensively call getters and setters of other classes that in turn do not implement actual functionality but rather only hold program data.
moreover di erent methods in shop do not call each other as they have di erent concerns but mainly call methods in other classes resulting in low cohesion of class shop cf.
the review notes in figure bottom left but high couplings of that class with other classes.
the presence of a predominant class like shop obliged with too much responsibility and degrading other classes to the mere task of storing data constitutes a misuse of 579figure class diagram of the running example object oriented encapsulation concepts.
this speci c combination of symptoms therefore indicates a well known objectoriented design aw usually referred to as the blob antipattern .
as a consequence software maintenance in subsequent evolution steps may be seriously obstructed and error prone.
for instance suppose that the video shop later plans to o er on line streaming which is however excluded from the bonus system.
this new functionality shall be naturally implemented in a new sub class of the central shop class.
but concerning the current implementation in figure this would mean that methods for handling the bonus system are also included in this new class thus leading to erroneous behavior.
as illustrated by this example manually performing comprehensive and precise designaw detection is tedious errorprone and becomes infeasible in a real world software development scenario comprising hundreds of thousands of lines of source code and multiple developers involved.
in this regard designaw identi cation needs to be assisted and at least up to some extent automated.
in particular a comprehensive designaw speci cation and detection framework has to integrate the following techniques corresponding to the aforementioned di erent kinds of symptoms.
selection and computation of quanti able software metrics with adjustable thresholds identi cation of code smells by means of ne grained properties of object oriented entities including software metrics and locally restricted structural patterns occurring in particular classes methods or elds and detection of architectural anti patterns composed of various code smells and coarse grained global program structures as well as static semantic code patterns.
revisiting our running example the identi cation of the design aw the blob in the evolved program involves various code smells.
first the central class constitutes a so called controller class i.e.
a class with a predominant amount of outgoing method calls to members of other classes clearly exceeding the amount of incoming calls.
moreover the central class constitutes a large class with low cohesion i.e.
having a high amount of outgoing method calls compared to those targeting the same class.
the other classes centered around this central class serve as data classes as their methods are mostly getters setters providing accesses to elds storing program data.
in this regard the central class further takes the role of a data class user by making intensive use of data classes.
each of these code smells may be characterized by utilizing di erent kinds of established software metrics amongst others figure modular description of the blob antipattern ii oi number of incoming outgoing method invocations of a class lcom5 a popular variant of the lack of cohesionof methods metric f m number of elds methods in a class and sm gm number of setters getters in a class.
based on these metrics the aforementioned code smells may be described as follows.
data class.
adata class has a high ratio between the number of its getter setter methods and all of its methods denoted as sm gm m compared to all other classes in the program.
large class.
alarge class has a signi cantly higher number of members elds and methods denoted as f m compared to the average of all classes in the program.
low cohesion.
a class with low cohesion has a signi cantly higher lcom5 value compared to the average of all classes in the program.
controller class.
acontroller class has a signi cantly smaller ratio between the number of incoming and outgoing method invocations denoted as oi ii compared to the average of all classes in the program.
data class user.
adata class user has signi cantly more accesses to data classes compared to the average of all classes in the program.
finally specifying fullyedged architectural anti patterns requires arbitrary combinations of code smells with global program structures and static semantic information.
for instance concerning the the blob anti pattern of our running example we observe that the description and therefore the detection of some code smells being part of a the blob anti pattern implicitly depend on each other e.g.
in terms of consists of relationships thus inducing a partial de composition hierarchy among the di erent symptoms constituting a designaw speci cation.
figure visualizes such a modularized description of the the blob antipattern making explicit the dependency hierarchy among the respective software metrics and code smells as initially proposed in .
in practice not only one but multiple di erent design aws have to be taken into account during software main580figure modular description of the swiss army knife anti pattern tenance.
although di ering in subtle details the variety of design aws documented in the literature usually share up to a certain level of detail similar symptoms.
to this end descriptions of anti patterns may also include