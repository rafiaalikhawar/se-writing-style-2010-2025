detreduce minimizing android gui test suites for regression testing wontae choi university of california berkeley wtchoi cs.berkeley.edukoushik sen university of california berkeley ksen cs.berkeley.edu george necula university of california berkeley necula cs.berkeley.eduwenyu wang university of illinois urbana champaign wenyu2 illinois.edu abstract in recent years several automated gui testing techniques for android apps have been proposed.
these tools have been shown to be effective in achieving good test coverage and in finding bugs withouthumanintervention.beingautomated thesetoolstypically runforalongtime say forseveralhours eitheruntiltheysaturate test coverage or until a testing time budget expires.
thus these automated tools are not good at generating concise regression test suites that could be used for testing in incremental development of the apps and in regression testing.
weproposeaheuristictechniquethathelpscreateasmallregression test suite for an android app from a large test suite generatedby an automated android gui testing tool.
the key insight behind our technique is that if we can identify and remove some common forms of redundancies introduced by existing automated gui testing tools then we can drastically lower the time required to minimize a gui test suite.
we have implemented our algorithm in a prototype tool called detreduce.
we applied detreduce to several android apps and found that detreduce reduces a test suite by an average factor of .
in size and .
in running time.
we also found that for a test suite generated by running swifthand and a randomized test generation algorithm for hours detreduce minimizes the test suite in an average of .
hours.
ccs concepts software and its engineering software testing and debugging keywords android gui test minimization currently at google inc. this work has been done while the author was a visiting student at university of california berkeley permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
reference format wontae choi koushik sen george necula and wenyu wang.
.
detreduce minimizing android gui test suites for regression testing.
in proceedingsoficse 40thinternationalconferenceonsoftwareengineering gothenburg sweden may june icse pages.
introduction in recent years there has been a significant surge in the usage and developmentofappsforsmartphonesandtablets.developersare writingmoreappsformobileplatformsthanfordesktops.thecomplexityofmobileappsoftenliesintheirgraphicaluserinterfaces guis .testingeffortsofsuchappsmostlyfocusonthebehavior of graphical user interfaces.
several automated gui testing techniques have recently been proposed.
the techniques include learning based testing model based testing genetic programming fuzztesting andstatic analysisbasedapproaches .thegoalofthemajorityofthesetechniquesistoachieve good code and screen coverage i.e.
covering all distinct screens of anapp andtofindcommonbugssuchascrashesandunresponsiveness.
most of these techniques work by injecting sequences of automaticallygenerateduserinputsoractionstoanappforseveral tens of hours.
we consider each sequence of actions injected by these techniques to be a test case and the set of all sequences of actions to be a test suite.
although automated gui testing techniques could find bugs they tend to generate large test suites containing thousands oftest cases.
each test case can contain tens to thousands of useractions.
such a large test suite can take several hours to execute becausetherunningtimeofatestsuiteislinearinthesizeofthe test suite.1however regression tests should be fast so that they canbeusedfrequentlyduringdevelopment.therefore suchtest suites are difficult to use in regression testing.
in this paper we address the problem of generating a small regressionguitestsuiteforanandroidapp.weassumethatwe are given a large test suite generated by an existing automatedgui testing tool.
we also assume that the test suite is replayablein the sense that if we rerun the test suite multiple times we get thesamecoverageandobservethesamesequenceofappscreens.
theevaluationsectionhasdetailsonhowtoobtainareplayable 1for agui app it isrecommended to restrict theamount of computation performed by each event handler to improve responsiveness.
therefore the running time of a gui test case tends to be linear in the length of the test case.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden wontae choi koushik sen george necula and wenyu wang test suite from an automated gui testing tool.
we assume that thetest suitetakes severalhours torunon theapp.
ourgoalis to spendareasonableamountoftime sayaday togenerateasmall regression test suite for the app that runs for less than an hour and that achieves similar code and screen coverage as the original test suite provided as input.
a couple of techniques have been proposed to minimize test suitesforguis.forexample clappetal .
andhammoudietal .
proposeddelta debugging basedalgorithms.thesetechniquesworkwellifthesizeoftheinputtestsuiteissmall containing less than one thousand user inputs.
however they fail to scale for large test suites because they depend heavily on the rapid generation and feasibility checking of new test cases.
unfortunately for most real world gui apps it takes few minutes to check the feasibility of a new input sequence.
therefore for large test suites containing tens of thousands of user actions a delta debugging basedapproachcouldtakemorethanamonthtoeffectivelyminimizeatestsuite.mcmasterandmemon proposedaguitest suite reduction techniquefor reducing the numberof test cases in a test suite.
however this technique does not make any effort to reducethesizeofeachtestcase.inourexperimentalevaluation weobservedthattestcasesgeneratedbyanautomatedtoolcancontain subsequences of redundant user actions which can be removed to obtain smaller test suites.
we propose an android gui test suite reduction algorithm that can scalably and effectively minimize large test suites.
the key insight behind our technique is that if we can identify and remove some common forms of redundancies introduced by existing automatedguitestingtools thenwecandrasticallylowerthetime required to minimize a test suite.
we manually analyzed test suites generatedbyexistingautomatedguitestingtools andfoundthere are three kinds of redundancies that are common in these testsuites some test cases can be safely removed from a test suite without impacting code and screen coverage within a test case certainloopscanbeeliminatedwithoutdecreasingcoverage and manytestcasessharecommonsubsequencesofactionswhose repeatedexecutioncanbeavoidedbycombiningfragmentsfrom different action sequences.
based on these observations we developed an algorithm that removes these redundancies one by one whilepreservingtheoverallcodeandscreencoverageofthetest suite.
in orderto identifyredundant loopsand commonfragments of test cases we define a notion of state abstraction which enables us to approximately determine if we are visiting the same abstract stateatleasttwicewhileexecutingatestcase.ifanabstractstate is visited twice during the execution we have identified a loop which can potentially be removed.
similarly if the executions of two test cases visit an identical subsequence of abstract states we knowthatfragmentsfromthetwotestcasescanbecombinedto obtain a longer test case which avoids re executing the commonfragment.
whenever we get a new test case by removing a loopor by combining two fragments the resulting test case may nottraverse the same abstract states as expected.
in our algorithm wecheckthefeasibilityofanewlycreatedtestcasebyexecuting it a few times and by checking if the execution visits the samesequence of abstract states every time we call this replayability.
wenoticedthatifourstateabstractionistoocoarse grainedourfeasibility checks often fail leading to longer running time.
on the otherhand ifweuseatoofine grainedstateabstraction wefailto identifymanyredundancies.onecontributionofthispaperisto design a good enough abstraction that works well in practice.
oneadvantage ofour algorithmoverdelta debugging orother black boxalgorithmsisthatwedonotblindlygenerateallpossible newtestcasesthatcanbeconstructedbydroppingsomeactions.
rather we use a suitable state abstraction to only drop potentially redundantloops.anotheradvantageisthatwecreatenewtestcases bycombiningfragmentsfrominputtestcases.thisenablesusto come up with new longer test cases which cannot be generatedusing delta debugging or other test suite reduction techniques.
longertestcasesareusuallybetterthanmultipleshortertestcasesbecausewedonothavetoperformacleanrestartofanapp.aclean restart of an app requires us to kill the app erase app data anderase sd card contents which is very time consuming.
a longer testcaseinplaceofseveralshortertestcasesavoidsseveralsuch expensive restarts.
we have implemented our algorithm in a prototype tool called detreduce forandroidapps.thetoolispubliclyavailableathttps github.com wtchoi swifthand2.weapplieddetreducetoseveral appsandfoundthatdetreducecouldreduceatest suitebyafactorof16 .
insizeandafactorof14 .
inrunningtimeonaverage.we alsofoundthatforatestsuitegeneratedbyrunningswifthand and a random testing algorithm for hours detreduce can reduce the test suite in an average of .
hours.
we are not aware of any existing technique that could get such huge reduction inthe size of a large gui test suite in such a reasonable amount of time.notethatdetreduceoftenrunslongerthangeneratingall testcases however runningdetreduceisaone timecost.oncea regression suite has been generated it will be run many times and each run will take a fraction of the time required to generate all test cases.
overview automatedguitestingtools suchasmonkey a3e dynodroid mobiguitar andorbit exploretheguiofan appautomaticallywithoutanypriorknowledgeaboutthebehavior of the app.
these automated tools are however not good at generatingconciseregressiontestsuitesthatcouldbe usedfortestingin incremental development of the apps and in regression testing.
we proposeaheuristictechniquethathelpstocreateasmallregression test suite for a gui app given a large test suite generated by an automatedguitestingtool.wenextgiveabriefoverviewofour technique using formal notation and a series of examples.
.
definitions and problem statement trace.theexecutionofanapponasequenceofuserinputscanbe denotedbya traceoftheform s0a1 c1 s1a2 c2 ...an cn sn.eachsi isanabstractstateoftheprogram usuallycomputedbyabstracting the screen of the app.
each si 1ai ci siis atransition denoting thattheapptransitionedfromstate si 1tostatesionuserinput or action aiand covered the set of branches ciduring the transition.
severaleventhandlerscouldbetriggeredduringatransition the branches covered during the transition are the branches of the triggered event handlers and the methods transitively called from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
detreduce minimizing android gui test suites for regression testing icse may june gothenburg sweden theseeventhandlers thatareexecutedduringthistransition.here we focus on branch coverage but one could use other kinds of coverage for ci.
coverage.
ifsi 1ai ci siis a transition then ci si is thecoverage of the transition.
in the coverage we include both the set of branches and the abstract states visited by the transition.
we can similarly define the coverage of a trace s0a1 c1 s1a2 c2 ...an cn snas the union of the coverage of all the transitions in the trace i.e.
c i ci si .
replayable traces.
inourtechnique weareonlyinterestedin replayable traces.
a trace s0a1 c1 s1a2 c2 ...an cn snof an appisreplayable ifeverytimetheappisgiventhesequenceofuser actionsa1 a2 ... anin a state s0 the initial state of the app it generates the exact trace .
test suite a set of replayable traces.
we assume that an automated testing tool for gui generates a settsof replayable traces thatcanbetreatedasaregressiontestsuite.the coverageofaset oftracest denotedby c t isdefinedastheunionofthecoverage of the traces contained in the set.
the cost of a set of traces tis the pair summationtext.
t t .
the first component of the pair gives the numberoftransitionspresentinthetracesin t.thisnumberroughly estimates the amount of time necessary to replay the traces in t. between the replay of two traces one needs to perform a cleanrestart of the app by erasing the app data and sd card contents which has high cost.
in order to take that cost into account we have a second component in the pair corresponding to the number of clean restarts necessary to replay all the traces in t. problem statement.
givenasetofreplayabletraces ts thegoal is to find a minimal set of traces t0such that t0is replayable t0 consists of transitions from the traces in ts c ts c t0 and the cost of t0is minimal.
unfortunately finding a minimal t0is intractableforthefollowingreasons.first withoutthereplayabilityrequirement theproblemcanbereducedtoaninstanceoftheprizecollectingtravelingsalesman problem pctsp awell knownnphard problem .
with the replayability requirement a solution foundbysolvingthecorrespondingpctspproblemmayinclude non replayable traces.
therefore we need to solve multiple pctsp problems until finding a replayable solution.
instead of solving the problemoffindingtheglobalminimum wedevelopedatwo phaseheuristicalgorithm whichwefoundtoworkeffectivelyinpractice.
.
limitations of existing approaches in any test case reduction technique we need to construct new traces.althoughthecreationofatracetakeslittletime wehavetoensurethatthetracecanbereplayed.itisimpossibletopreciselyde termineifatraceisreplayable.inourtechnique wecheckifatrace isreplayablebyexecutingitfewtimes.wefoundexperimentally thatifatraceisnon replayable itwillfailtoreplaywithineight executions withvery high probability.
faithfully executinga single transition ina tracecould take afew secondsbecause after injectinganinputoraction weneedtowaituntilthescreenstabilizes.
therefore executing a trace composed of several transitions could takeseveralminutes.moreover afterexecutingeachtraceweneed to perform a clean restart which takes several seconds.
therefore itisgenerallytimeconsumingtocheckifatraceisreplayable.this is the key bottleneck faced by a gui test suite reduction technique.
!
!
!
figure a partial model of a file browser app.
existing test minimization techniques such as deltadebugging and genetic algorithms will create and checkthereplayabilityof manytraces.therefore thesetechniques cannotscalewhen theinitialsetof tracesislarge.but allexisting automatedtechniquesforguitestgenerationcreatelargenumbers of traces.
according to clapp et al .
s experimental results their variantofdelta debuggingcantakeafewhourstoseveraltensof hours to handle traces composed of only transitions.
in our experiments we had to handle test cases having transitions.
if we linearly extrapolate the timings reported by clapp et al.
to transitions delta debugging could potentially take a month.
we seek a technique that can minimize a test suite in a day or less.
.
our observations we observed that the set of traces generated by an automated testing tool has many redundancies.
our technique for gui test suitereductiontriestoremovetheseredundancies.wenextdescribe these redundancies using a series of examples.
.
.
redundant traces.
among the traces in a test suite the coverage provided by some traces is a subset of coverage provided by the remaining traces.
such traces can be removed from the test suitewithoutdecreasingthecumulativecoverage.ourtechnique finds such redundant traces and removes them from the test suite.
.
.
redundant loops.
wealsoobservedthattherecouldbe redundancies within a trace for example if the trace contains aredundant loop.
a loop in a trace is a sub trace of the trace thatbegins and ends in the same abstract state.
traces generated by automatedtestingtoolstendtocontainmanyloops andsomesuchloopsdonotprovideadditionalcoverageoverthecoveragethatcanbeachievedbythetracewithouttheloopandtheremainingtraces.
such loops are redundant and can be removed from the trace if the resulting trace can be replayed.we next illustrate such redundant loops using a couple of examples.
allexamplesutilizethefilebrowserappshowninfigure1.when the app starts it shows the root directory abstract state screen s0 .
in this initial state screen a user can invoke a pop up menu s1 b y touchingthemenubuttononthescreen thebuttonatthetop rightcornerwiththreedotcharacters .oncethemenuisvisible theuser can close the menu by touching the same button.
selecting an item on the menu results in a completely different abstract state screen of the app.
pressing the option button leads the app to the option screen s2 .
the app also allows the user to navigate the file system abstract state screen s0ands3 .
note we intentionally made the directories fooand foo foo to have the same look in order to keep the example simple.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden wontae choi koushik sen george necula and wenyu wang example2.
.
aredundant loop assumethat theusertouches the menu button three times.
this input sequence will open the pop upmenu closeit andthenopenitagain.theuserthenselects the first item i.e.
the option button of the menu.
this action will lead the app to the configuration screen.
assume there are no event handlers associated with the menu open and close events.
the execution of the above action sequence will then generate the followingtrace s0menu s1menu s0menu s1option co s2 where istheemptysetand codenotesthetestcoveragegenerated whenthe appmoves totheconfiguration screen.inthis trace the sub trace s0menu s1menu s0forms a loop since it begins and endswiththesameabstractstate.thecoverageofthislooponly containsthestates s1ands0.thecoverageoftheloopisasubset of the coverage of the rest of the trace co s0 s1 s2 .
thus the loopdoesnotaddanyextracoveragethanwhatisalreadyachieved by the rest of the trace.
this makes sense because the loop merely opensand closesthe pop upmenu.after removingthe loopfrom the trace if the modified trace is replayable we can replace the original trace with the modified trace.
removing the loop gives us the following shorter replayable trace s0menu s1option co s2.
example .
.
a non redundant loop a loop is non redundant when the loop provides coverage that cannot be achieved by the rest of the trace s .
let us assume that the app nowhas event handlers attached to the menu open and closeevents.
re executing the same sequence of actions from ex ample .
will generate the following slightly different trace s0menu cp s1menu cc s0menu cp s1option co s2 wherecpand ccdenote the coverage generated by executing the menu open andcloseeventhandlers respectively.inthismodifiedtrace the loop contributes the test coverage ccwhich cannot be achieved by any other transition in the trace.
therefore the loop should not be removed from the trace.
example .
.
another non redundant loop a loop can be nonredundantiftheremovaloftheloopmakesthetracenon replayable evenifitdoesnotachieveanynewcoverage.notethatifweuse theconcretestateoftheappinsteadofascreenabstraction atrace willbereplayableifweremovealoop.however duetoabstraction thestartandendstates ofaloopmaynotcorrespondtothesame concrete state.
therefore the trace may not be replayable after theremoval of a loop.
let us illustrate this with an example.
this time wearegoingtonavigatethefilesystemtoreachthefoldercontainingpictures i.e.
state s3 .thistaskcanbedonebysimplytouching thefoofolderthreetimes.theexecutionofthesequenceofactions willgeneratethefollowingtrace s0foo cf1 s0foo cf1 s0foo cf2 s3 wherecf1denotes the test coverage generated when opening a folderonlycontainingsubfolders and cf2denotesthetestcoverage generated when opening a folder only containing files.
the tracehasthreeloops thefirsttransition thesecondtransition and thesub tracecontainingthefirsttwotransitions .thethirdloopcannotberemovedbecauseremovingitwillreducethecoverage of the trace.
the first and seconds loops however look identical and one may think that one of the two loops can be removed from the trace.
however removing one of these two loops will make the tracenon replayablebecausetouchingthe foofoldertwiceleads theapptothescreenshowingthecontentsof foo foo folderand we will miss cf2.
the trace obtained after removing one of theloopsisnon replayablebecauseourcoarse grainedstateabstraction maps three distinct app states to s0.
however if we do not use theabstraction wewillhaveunboundednumberofstates which will make both automated test generation and test minimization fail.thisexampleshowsthataloopisnon redundantifitsremoval makes the trace non replayable.
note that determining whether removing a loop will have an impact on the rest of a trace can only be determined by trying to replay the modified trace.
.
.
redundant trace fragments.
while analyzing traces in automatically generated test suites of several apps we observedthat many traces share common sub traces.
if we execute these traces thecommonsub tracesgetexecutedmultipletimes once for each trace but new coverage is only achieved when a common sub trace is executed for the first time.
we can avoid redundant executionofthesecommonsub tracesifwecancombinefragmentsoftracesinamannerthatavoidsrepetitionsofcommonsub traces.combiningfragmentsoftraceswillalsoresultinlongertraces.such longertraceswillreducethenumberofrestarts whicharemore expensiveoperationsthantriggeringanaction.thenextexample describes how common sub traces contribute to redundancy.
example2.
.
splicingthreetraces considerthefollowingthree artificially crafted traces s0a c1 s1b c2 s2c c3 s3d c4 s4 s0a c1 s1d c4 s4e c5 s2c c3 s3d c4 s4 s0a c1 s1b c2 s2c c3 s3f c6 s5 note the first and second traces have two common sub traces s0a c1 s1ands2c c3 s3d c4 s4.
similarly the first and third traces have the common prefix s0a c1 s1b c2 s2c c3 s3.
by combining fragments of the traces we can create the followingtrace s0a c1 s1b c2 s2c c3 s3d c4 s4e c5 s2c c3 s3f c6 s5.
the spliced trace is constructed by appending sub trace s4e c5 s2c c3 s3tothe firsttrace and thenbyappending thesubtraces3f c6 s5to the resulting trace.
the new trace gets rid of six actions and two restart operations from the original traces.
notethat the spliced trace still contains two copies of the sub trace s2c c3 s3 whichwecouldnotgetridof.ifthesplicedtraceisreplayable it can replace the original traces in the test suite.
the running time of the spliced trace will be approximately half of the originaltraces whileprovidingthesamecoverage.thisexample showsthatwecanaggressivelycombinefragmentsfrommultiple traceswhilegettingridofredundantfragments includingredundantprefixes .however inpractice wefoundthattracescomposed of a large number of fragments from different traces tend to be non replayable.therefore inourtechniquewelimitthenumber of different trace fragments that we can combine to a small bound which is three in our implementation.
.
our approach state abstraction.
inourdiscussionsofar weassumedwehave asuitablestateabstractionthatenablesustoclustersimilar looking screens.
the performance of our technique for test reduction de pends heavily on our choice of state abstraction.
if we choose a fine grainedabstraction thenourtechniquerunsfaster butmay miss many opportunities for reduction.
on the other hand if we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
detreduce minimizing android gui test suites for regression testing icse may june gothenburg sweden pick a coarse grained abstraction many of the traces that our technique constructs become non replayable.
therefore our technique spendsmoretimeincheckingreplayabilityofvarioustraces butwe get a bigger reduction.
we observed that a human tester can easily identify screens that are similar by analyzing what is visible on the screen.ideallyweneeded anabstractionthatjudgesthattwoapp screenstobethesameifandonlyifahumantesterfindsthetwo screens visuallyidentical.
afteranalyzing several apps we picked a state abstraction based on information from the gui component tree.
the details of the abstraction are described in section .
removing redundancies.
weproposeatwo phasealgorithm toremoveredundanciesfromaguitestsuite.thefirstphaseremoves redundant traces and redundant loops greedily.
it first removes redundant traces by greedily selecting traces such that each selectedtracecontributesnewcoveragetothecoverageofthesetofalreadyselectedtraces.thenon selectedtracesarethenredundant and are removed from the test suite.
it then removes redundantloops from each remaining trace.
in order to remove redundant loops in a trace the algorithm creates the set of all traces obtained from the trace by removing zero or more loops.
it then selectsa trace from the set that does not decrease cumulative coverage lowerscostofthetracemaximally andisreplayable.suchatrace replaces the original trace in the test suite.
the second phase removes redundant trace fragments as much as possible.
for that it constructs a new set of traces by combining fragmentsofthetracesinthesetcomputedbythefirstphase.when splicing trace fragments we found it useful to limit the number of fragments in spliced trace to a small number three in our case because a trace composed of many fragments tends to be nonreplayableinpractice.thus thesecondphaseofthealgorithmfirst creates the set of candidate traces composed of a bounded number oftracefragments.itthenconstructsanewtestsuitebygreedily selecting traces from the set of candidate traces.
inbothphases wheneverouralgorithmgeneratesanewtrace it checks whether the trace is replayable or not by executing it a few times.thispreventsthealgorithmfromaddinganon replayable trace to the resulting regression test suite.
if the algorithm findsa trace to be non replayable it identifies and saves the shortestnon replayable prefix of the trace.
in the future if the algorithm finds that a new trace starts with one of these saved prefixes then it can safely infer that the trace is non replayable and discard it.
this optimization helps the algorithm aggressively discard some non replayabletraceswithoutexecutingthemmultipletimes.we describe the reduction algorithm formally in the next section.
algorithm .
redundant loop and trace elimination in order to construct a minimal set of traces we only retain the traces from tswhose cumulative coverage is same as the coverage ofts.
then we remove as many loops from the remaining traces aspossiblewhilemaintainingthesamecumulativecoverageand the replayability of the traces.
this results in a set of traces tr whose cost is much lower than the cost of ts.
during the removal of loops our algorithm discovers that certain trace prefixes are not replayable.
we speedup the loop elimination phase by pruning outthetraceswhoseprefixmatchesthenon replayableprefixes.we next describe this algorithm formally.
given a trace we say that a sub trace of is aloopif it begins and ends in the same state.
for example if in the trace s0a1 c1 s1a2 c2 ...an cn snthere exists two states siandsjsuch thati nequaljandsi sj thenthesub trace lscript siai ci ...aj cj sj is a loop.
if we remove the loop from we get a shorter trace lscript s0a1 c1 ...ai ci siaj cj ...an cn sn.atraceobtainedafter eliminating one or more loops from may no longer be replayable.thus anytimeouralgorithmremovesaloopfromatrace weneedtocheckiftheresultingtraceisstillreplayable.let l be thesetofalltracesobtainedbyremovingdifferentcombinationsof zero or more loops from .
note that l contains .
the pseudocode of thealgorithm is shown in algorithm .
the algorithm uses a function replaywhich takes a trace and returns if the trace is replayable otherwise the function returns the shortest prefix of that is not replayable.
therefore the check replay telluswhether isreplayableornot.inthefirstpart ofthealgorithm weremoveallredundanttraces.todosowecreate anemptyset ttostorethenon redundanttraces.thealgorithm goesovereach trace ints.ifc hassomecoverage thatisnot already present in c t then is not redundant and we add to t.aftergoingoveralltracesin ts twillcontainnon redundant traces oftssuch that c t c ts .
in the second part the algorithm performs redundant loop elimination.
it maintains a set of reduced traces trwhich is initialized to the empty set.
the algorithm goes over each trace int.i t thengoesovereachtrace primeinl thesetofalltracesobtained from by removing zero or more loops in the increasing order of cost.
if c prime c tr c c tr and primeis replayable i.e.
if prime replay prime thealgorithmadds primetotrandstopsprocessing elementsof l .thisindicatesthatthealgorithmhascomputed a trace possibly shorter than .
on the other hand if primeis not replayable then any trace in l havingreplay prime as a prefix is removed from the set l because all such traces will also be non replayable.thisreducesthenumberthetracesthatwehave to process from the set l and thus reduces the running time ofthealgorithm.notethatduringtheprocessingofthetracesin l we will end up adding totrif none of the loops in can be eliminated without reducing coverage or without making the resultant trace non replayable.
practicalconcerns.
thealgorithmreliesonarobustimplementation ofreplay .
however in practice it is not easy to have a preciseimplementationof replay thatwillguaranteethat replay returns if and only if is replayable.
such an implementation wouldrequireustotracktheentirestateoftheappincludingthe state of any internet server it might be interacting with.
moreover ifwemaketheimplementationof replay tooprecise inmany acceptablecasesitwillreportthat isnotreplayable.inourtool we make a practical trade off where we re execute the trace a few times which is ten in our experiments and report the shortest prefixof thatisnon replayableoveralltenre executions.ifinall the ten executions we find that is replayable replay returns .
thealgorithmalsoneedstocompute l i.e.thesetoftraces obtainedfrom byremoving0ormoreloops.ourimplementation doesnotcomputetheset l aheadoftime.ratheritperformsa authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden wontae choi koushik sen george necula and wenyu wang algorithm eliminate redundant traces and loops procedure eliminateredundanttracesandloops ts t part eliminate redundant traces.
for tsdo loop over the input trace set.
ifc notsubseteqlc t then t t tr part eliminate redundant loops.
for tdo loop over the filtered trace set t. tl l whiletl nequal do prime argmin tl tl tl prime ifc prime c tr c c tr then if prime replay prime then tr tr prime breakthe inner loop else tl tl replay prime is not a prefix of returntr depth firsttraversalofthetrace toenumeratethetracesin l one by one from the shortest to the longest one.
finally the result of the first phase of the algorithm will change depending on the order of picking elements from ts line and t line .
our implementation uses queues to store test cases which guarantees that test cases are always handled in first come firstserveorder.
wetriedvariousotherorderings butweobservedthat the results did not vary significantly.
.
trace splicing while analyzing traces in the set tr i.e.
the traces generated by loop and trace elimination we noticed traces often share common sub traces.therefore ifwecancombinetracesinordertoavoid common sub traces as much as possible we generate longer traces.
this isgood since longer tracesavoid expensive restarts and avoid execution of redundant sub traces.
however we also found that the more traces we combine the more likely we are to get non replayable traces.
we found experimentally that if we combine threeorfewertracefragments wecouldstillreaptherewardsof longer traces avoiding restarts and redundant execution while creatingreplayabletraces.basedontheseobservations wedevised the second part of our minimization algorithm where we combine fragments from different traces to create longer replayable traces.
atrace fragment is a contiguous portion of a trace obtained by removing a prefix and a suffix of the trace.
for example if s0a1 c1 s1a2 c2 ...an cn snis a trace then for any i j wherei j siai ci ...aj cj sjis afragment of the trace .a setoftracefragments 1 2 ... mcanbecombinedtoformthe trace 1 2... mif 1beginswith thestate s0andfor all i the end state of i 1is the same as the first state in i. given a set of tracestr lettkbe the set of all traces obtained by combining at mostktrace fragments from the traces in tr.
the pseudocode of thealgorithm is shown in algorithm .
the algorithm first constructs the set tkfrom the set tr.
the algorithm initializesthefinalsetofminimizedtraces tmtotheemptyset.the algorithm then does the following in a loop it finds a trace intk such that results in the maximal increase in coverage over the coverage of tm i.e.
maximizes c c tm .
if no such trace is foundintk thealgorithmreturns tm.otherwise if isreplayable it removes fromtkand adds it to tm.i f is not replayable thenalgorithm bounded splicing procedure boundedsplicing tr k tk is a trace composed of at most kfragments of traces in tr tm while tk.c c tm nequal do argmax tk c c tm tk tk if replay then tm else tk tk replay is not a prefix of returntm alltracesin tkhavingreplay asaprefixareremovedfrom tk.
this step speeds up the search for optimal in future iterations.
the loop is then repeated.
theabovealgorithmterminatesandcomputesa tmsuchthat c tm c tr .thealgorithmterminatesbecauseineachiteration we increase the coverage of tm and the coverage of tmcannot be increasedbeyondthecoverageof tr whichissameasthecoverage oftk .
the algorithm also ensures that c tm c tr because for any finite k tkcontains the traces in tr.
therefore in the worstcaseifnoneofthetracesobtainedbycombiningtwoormore tracefragmentsfromdifferenttracesarereplayable wewillendup adding all the traces in trtotm.
this ensures that c tm c tr .
computing tk.algorithm uses a declarative specification to describethetraceset tk.wenextdescribeanalgorithmtocompute the set efficiently.
for any set of traces we can construct a labeled transitionsystemcomposedofthetransitionsofthetracesinthe set.formally if trisasetoftraces weconstructalabeledtransition systemqtr s s0 l a c where sis the set of all states in tr l n n is a set of labels s0is the initial state of the app ais the set of all actions in tr cis the set of coverage sets in tr and is a set of labeled transitions of the form si 1ai ci lsi where si 1ai ci j i si j trs.t.si 1ai ci siis theithtransition in j .
informally an element of is a transition from a trace in tr augmentedwithapairofindicesdenotingthetracetowhichthe transition belongs and the position of the transition in the trace.
notethatforanytracein tr thereisapathinthelabeledtransition systemqtr.moreover anypathin qtrrepresentsatracethatcould beobtainedbycombiningtracefragmentsfrom tr.wecancheckif apathfrom qtrbelongsto tkbyanalyzingthelabelsofthepathas follows.
two consecutive transitions with labels j1 i1 and j2 i2 inapathconstitutea switchifeitherj1 nequalj2ori1 nequali2.apath inqtrbelongsto tkifthenumberofswitchesinthepathisless thank.
the algorithm to construct tkenumerates the paths in qtr using depth first search and discards a path as soon as the number of switches along the path reaches k. the algorithm terminates sincekis finite and the number of trace fragments is bounded.
implementation weimplementedourtestreductionalgorithminaprototypetool called detreduce.
detreduce works for android apps but could beimplementedforotherplatformssupportinggraphicaluserinterfaces.thetoolispubliclyavailableat swifthand2.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
detreduce minimizing android gui test suites for regression testing icse may june gothenburg sweden screen abstraction.
detreduce uses a suitable screen abstractiontoclusterappstates.wefoundthattheabstractionmechanism usedinswifthand isappropriatetogroupscreensthatuser might find to be similar.
we next briefly explain the screen abstraction mechanism.
a screen abstraction is computed from a raw gui component tree collected from an app via uiautomator.
a gui component tree contains detailed information about a screen.
we observed that the following information are useful and often sufficient to characterize a screen which gui components are actionable?
for example checkbox and textbutton components are actionable in android while textbox and decorationbar components are not.
which attribute values of actionable gui components are visible on the screen?
for example for a screen with a checkbox one could observe if the checkbox is checked or not.
weextractthisinformationfromarawguicomponenttree.the abstractioniscomputedbyfirstcollectingasetofactionablegui components i.e.
the components with event handlers from a gui component tree.
each collected component is augmented with the accesspathtothecomponentfromtherootintheguitree.unnecessary attributes are then removed from each component.
evaluation we aim to answer the following research questions.
rq1 how effective is detreduce in reducing test suites?
rq2 does detreduce run in a reasonable amount of time?
rq3 does detreduce preserve test coverage?
rq4 does detreduce preserve fault detection capability?
rq5 how many re executions are required to demonstrate the replayability of a trace?
rq6 what will happen to the splicing algorithm if the number of fragments in traces is increased beyond three?
to answer rq1torq5 we generated test suites using two test generation algorithms swifthand andrandom on eighteen benchmark apps and applied detreduce to reduce them.
to answerrq6 we analyzed the relationship between the likelihood of finding a replayable trace and the bound on the number of fragments in traces using four relatively complicated apps.
we used five smartphones motorola xt1565 to run benchmark apps.
.
experimental setup .
.
benchmark apps.
weapplieddetreducetoeighteenfree appsdownloadedfromthegoogleplaystore andf droid .
table lists these apps along with their package name the type of app andthenumberof branchesintheapp whichoffersarough estimateofthesizeoftheapp.
sincetheappsweredownloadeddirectly from app stores we have access to only their bytecode.
thirteenappswereusedforexperimentalevaluationinpreviousresearchprojects otherapps whichwemarkwithasterisks arenewlyselected.weexcludedappsforwhichswifthandand random saturate the test coverage in less than an hour.
note thataddingsuch appswouldonly improveexperimentresults because most of traces in test suites for such apps are redundant.
.
.
generating a replayable test suite to be used for minimization.togeneratetestsuitestobeusedasinputstodetreduce wetable benchmark apps app package name type br acar com.zonewalker.acar car manager amemo liberty.android.fantastischmemo flashcard amoney com.kpmoney.android finance astrid org.tasks task manager cnote dictapps.notepad.color.note note dmoney com.bottleworks.dailymoney finance emobile org.epstudios.epmobile fitness tracker explore com.speedsoftware.explorer filesystem 54302mileage com.evancharlton.mileage car manager 7728mnote jp.gr.java conf.hatalab.mnv text editor monefy com.monefy.app.lite finance sanity cri.sanity device manager tippy net.mandaria.tippytipper tip calculator todo com.splendapps.splendo task manager 11858ttable com.gabrielittner.timetable scheduler 11858vlc org.videolan.vlc media player whohas de.freewarepoint.whohasmystuff inventory 369xmp org.helllabs.android.xmp media player firstcollectedexecutiontracesbyrunninganimplementationofthe swifthand andrandom algorithms.weraneachforeight hours thencheckedwhetherthegeneratedtracesarereplayablebyre executingeachtracetentimes.foreachnon replayabletrace we identifiedanon emptyreplayableprefixofthetraceandretained the prefix rather than throwing the entire trace away.
an app can generate a non replayable trace for several reasons a the app has external dependency e.g.
it receives messages from theoutsideworld dependsonatimer orreadsandwritestothe filesystem orb theapphasinherentnon determinismduetotheuseofarandomnumbergeneratorormulti threading.weremoved dependencyontheoutsideworldbyresettingthecontentsofthesdcardandtheappdataeverytimewerestart.nonetheless itis impossible to eliminate all sources of non determinism.
therefore we replayed each trace generated by the swifthand and random algorithmstentimestoremovethenon replayablesuffixesoftraces.
wedeterminedexperimentallythateightre executionsissufficient to detect most of non replayable traces for the benchmark apps.
.
.
why we did not use monkey to generate initial test suite?
monkey is a fuzz testing tool for android apps.
monkey is widely used to automatically find bugs in real world android apps.
weinitiallyattemptedtousemonkeytogenerateinputsfordetreduce however wefoundthatmonkeyisnotcapableofgenerating replayable traces.
we now describe our experience with monkey.
monkeyisasimpleblackboxtoolthatreportsonlythesequence of actions it used to drive a testing session.
to get a trace would re quirenon trivialmodificationstomonkey.beforejumpingintothis effort we performed an experiment to determine whether monkey is even capable of generating replayable traces if monkey cannot generate replayable traces there is no point in the modification.
in this experiment we used a script to generate traces with partialinformationfrommonkeyandcheckedifthosetracescould be replayed.
the script injects user actions at the rate of mactions persecond collectingbranchcoverageandscreenabstractionafter injecting every nactions.
the script picks the value of mfrom the set and value of nfrom .
for each pair of values for mandn the script runs monkey until it injects2000actions.bycombiningthesequenceofactionsreported by monkey with the collected coverage information the scriptcan generate traces that have coverage and screen information authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden wontae choi koushik sen george necula and wenyu wang after every nactions instead of having the information after every event.
we call such traces partial traces.
usingthisscript wecollectedthreepartialtracesforeachpossiblevalueof mandnusingthesamerandomseedandcompared thepartialtraces.ifthepartialtracesdonotmatch thisindicates thatmonkeycannotgenerateareplayabletrace.weperformedthe experiment using ten apps with three different random seeds.
theresultsofthisexperimentshowedthatmonkeypassesthe test for four apps when n andm .
for the other six apps monkeyfailsthetestevenwheninjectingoneactionpersecond.at thisspeedmonkeybecomesuselessinpracticebecauseitspower comesprimarilyfromitsabilitytoinjectmanyactionsquickly.it will take too long to generate a sufficiently good test suite using monkey at this speed .
therefore we have concluded that using monkey is not viable for generating initial replayable test suite.
why is monkey testing highly non deterministic?
we found that monkey injects actions asynchronously that is monkey injects an action without checking whether the previously injected action has been fully handled.
this allows monkey to inject an order ofmagnitudemoreactionsthantestingtoolsthatsynchronously injectactions butthisalsomakesmonkeyhighlynon deterministic.
forexample wenoticedthatifactionsareinjectedwhiletheapp isunresponsive thoseactionsaredropped.becausetheperiodof unresponsiveness variesfrom execution to execution the number of dropped actions varies across executions.
.
evaluation of detreduce table2andtable3showtheresultsofapplyingdetreducetothe testsuitesgeneratedbytheswifthandandrandomalgorithms respectively.
each table has four parts.
the first part shows the following information aboutthe test suites to be minimized total branch coverage br.
total screen coverage s. total number of transitions act.
andtotalnumberoftraces tr.
ofeachinitial testsuite.thesecondandthirdpartsofthetableshowinformation aboutthetestsuitesgeneratedafterrunningthefirstandsecond phases respectively of detreduce.
the fourth part shows important statistics summarizing the experiment results the running timeofeachphaseofthealgorithm t p1andtp2 theexecutiontime tr oftheresultingreducedregressiontestsuite andtheratioof theexecutiontimeoftheresultingregressionsuitetotheexecution time of the original test suite in percentage t r t .
we make the following observations from the data shown in the tables.
rq1 the execution time of the reduced test suites tr i ss e v eral orders of magnitude shorter than that of the original test suites hours .
this shows that detreduce is highly effective in minimizing the test suites for the benchmark apps.
regarding the sizes of test suites phase of detreduce removes .
oftransitions median and90.
ofrestarts median .phase2 of detreduce further removes .
of transitions and .
of restarts from the test suites obtained after phase .
these two phasesof detreducecumulativelyremove93.
oftransitions and93.
ofrestarts.wealsofoundthattherateofreduction is higher for test suites generated from random.
this is because thesetestsuiteshavelowertestcoverageandmoreredundancies.
rq2 the running time of the algorithm is within a factor of of the execution time of the original test suites generated by thetestgenerationalgorithms.morethanhalfoftherunningtime wasspentindetectingandeliminatingloopsinphase1 notethat detreduce spends no time removing redundant traces because such traces do not require any execution .
the time spent in phase1isreasonablebecausethephasesearchesforaminimized test suite while eliminating redundant loops from each trace.
note that these experiments employed a conservative parameter ten forthenumberofre executionstoperformtochecktrace replayability and the running cost of detreduce can be further reduced by setting this parameter to eight.
rq3 despite using an approximate method for checking if a traceisreplayable theminimizedtestsuitesnonethelesscover themostoftheoriginalbranchandscreencoverage.detreduce failstoprovide100 coveragefor amoney explorer ttable and vlc.wemanuallyanalyzedthereasonsforthemissingbranches andscreens anddeterminedthatnon replayabletraceswerenot fully removed while generating the original test suites before phase of detreduce.
rq4 in order to check how detreduce affects the faultdetection capability of test suites we collected exceptions raised while executing each test suite.
we identified seven distinct exceptions based on their stacktrace.
all survived after applying detreduce.
note that detreduce does not consider exceptions to be part of the test coverage it tries to preserve.
rq5 we measured how many re executions were required to identify each non replayable trace created during our experiments.
the following table summarizes the results.
t n n n n n n n n n n the first column t shows the total number of traces created during the experiments and the remaining columns show the numberofnon replayabletracesthatrequired nre executions for detection.
the results show that all non replayable traces were detected within the first eight iterations.
the results also showthat37 .
oftracesattemptedduringtheexperimentswere replayabletraces suggestingthatdetreduceisgoodatselecting candidate traces in our benchmarks.
.
splicing and the number of fragments in traces rq6 to understand the effect of bounding the number of trace fragmentsinphase2ofouralgorithm wemeasuredtherelationship between the bound and the likelihood of finding a replayable trace and the average number of trace fragments in a trace generated by splicing.
for these measurements we used four relatively complex benchmark apps.
.
.
bounding the number of fragments and the replayability of traces.
we measured the correlation between the bound on the number of fragments and the possibility of finding a replayabletrace using ten different bounds on k k .
for each k we constructed random traces by combining ktrace fragments fromthetestsuiteafterphase1.furthermore werestrictedeach tracetocontainonly20transitions.inordertoconstructthetraces wefirstcollectedatmost20 000tracessatisfyingtherequirement usingbreadth firstsearchofthetransitionsystem qtr describedin section3.
.notethatthepathsof qtrconsistoftracesthatcanbe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
detreduce minimizing android gui test suites for regression testing icse may june gothenburg sweden table test suite reduction result using detreduce on swifthand traces appinitial test suites phase phase running time in hours br sc act tr br sc act tr br sc act tr t p1tp2trtr t acar .
.
.
.
amemo .
.
.
amoney .
.
.
.
astrid .
.
.
.
cnote .
.
.
.
dmoney .
.
.
.
emobile .
.
.
.
explore .
.
.
.
mileage .
.
.
.
mnote .
.
.
.
monefy .
.
.
.
sanity .
.
.
.
tippy .
.
.
.
todo .
.
.
.
ttable .
.
.
.
vlc .
.
.
.
whohas .
.
.
.
xmp .
.
.
.
median .
.
.
.
.
.
.
.
.
table3 testreductionresultusingdetreduceonrandom traces.
coverage results for detreduce are omitted since detreduceonlymissed0.
ofbranchesand4screensfor amoney.
appinitial test suites phase phase running time in hours br sc act tr act tr act tr t p1tp2trtr t acar .
.
.
.
amemo .
.
.
.
amoney .
.
.
.
astrid .
.
.
.
cnote .
.
.
.
dmoney .
.
.
.
emobile .
.
.
.
explore .
.
.
.
mileage .
.
.
.
mnote .
.
.
.
monefy .
.
.
.
sanity .
.
.
.
tippy .
.
.
.
todo .
.
.
.
ttable .
.
.
.
vlc .
.
.
.
whohas .
.
.
.
xmp .
.
.
median .
.
.
.
table the frequency of replayable traces.
app replayable traces out of samples per app and k k k k k k k k k k k acar astrid 14cnote 11emobile constructedviasplicing.wethensampled200tracesfromthesetof traces.
finally we checked how many of the sampled traces are replayable by executing each trace ten times.
table shows the results.
the first column shows the name of the app and the rest of the columns show the number of replayable traces for each k. our hypothesis was that increasing the number of fragments would decrease the possibility of finding replayable traces and the results confirm this hypothesis for the four apps.
.
.
number of fragments in traces generated by splicing.
even if traces containing many trace fragments tend to be nonreplayable we would not need to bound the number of fragments during phase of detreduce if most of the traces that can betable the frequency of traces composed of kfragments.
app traces composed of kfragments out of samples per app k k k k k k k k k k acar astrid 783cnote 927emobile constructed from qtrcontain a small number of fragments.
our hypothesis was that without a proper bound a significant numberoftracesgeneratedfrom qtrwouldcontainmanytracefragments makingthemnon replayablewithhighprobability.therefore phase of detreduce would spend considerable amount of timecheckingthe replayabilityofnon replayabletraces.
inorder tovalidatethishypothesis weconstructed1000tracescomposed of at most transitions by sampling random paths from qtr and checked the number of trace fragments in each sampled trace.
table5showstheresults.thefirstcolumnshowsthenameof theappandtherestofthecolumnsshowsthenumberoftracescomposed ofkfragments for each kbetween to .
the results show that there are many more traces composed of a large number of fragmentsthantracescomposedoffewerfragments.consequently if we perform splicing without bounding the number of fragments we are more likely to get traces composed of a large number of fragments.
theresults ofthe previous experiment section .
.
suggestthatsuchtracesarelikelytobenon replayable.thisvalidatesourhypothesisthat phase2of detreducewillnotscaleif the number of trace fragments is unbounded.
.
threats to validity weusedalimitednumberofbenchmarkappstoevaluatedetreduce so it is possible that our results to not generalize.
to address thisissue wecarefullyselectedthebenchmarkapps andthedetails of the selection process are explained in section .
.
.
the selectionof thetest generationalgorithms could potentially biastheevaluationresults.specifically theresultsobtainedfrom a single algorithm cannot determine whether the results can be generalized to the other test generation algorithms.
to address this issue we used both swifthand and random algorithm.
we could not use monkey because it cannot generate replayable traces as explainedinsection5.
.
.theresultsobtainedusingrandomshow authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden wontae choi koushik sen george necula and wenyu wang thatdetreduceisnotanartifactthatonlyworkswithswifthand.
however the results arestill not strong enoughto decisively conclude that detreduce can effectively reduce test suites generated from an arbitrary test generation tool.
finally in the evaluation we checked whether the exceptions raised by the original test suites are also raised by the test suites reduced by detreduce.
however this is a limited evaluation.
a morerobustevaluationwouldinvolveinjectingartificialfaultsinto thebenchmark appsandmeasuringthe numberofinjectedfaults detected before and after thetest suite reduction.
we did not take thisapproachbecauseofthedifficultyofinjectingfaultsintothe binary of an android app.
related work gui test minimization.
nd3min isthemostcloselyrelated worktoourresearch.itisaguitestminimizationalgorithmforandroidapps basedondelta debugging .wecomparend3min and detreduce in three aspects a they have different goals nd3minaimstominimizeeachtestcaseinisolationwhilekeeping the final activity.
detreduce tries to minimize a whole testsuite while keeping the branch and screen coverage of the test suite.b handlingnon determinism nd3minaimstotoleratenondeterministic behaviors occurringduring theexecution of anapp.
onthecontrary detreduceisdesignedtoactivelydetectandavoid non deterministic behaviors during the process of minimization.
c runningtime nd3minisavariationofdelta debugging whose worstcasetimecomplexityiso n2 wherenisthesizeofinputtest case .
this could make the algorithm fail to scale since the cost ofperformingeachtestrunisexpensiveinguitesting.nd3min usesupto50hourstominimizeatestcasecomposedof500actions.
detreduceiscapableofhandlingatestsuitecomposedofmore than10 000transitionsinlessthan30hours.wecouldnotperform an empirical comparison because the implementation of nd3min was not available to us.
hammoudietal .
alsoproposedadelta debuggingbasedtest minimization algorithm.
unlike nd3min and detreduce their work aims to minimize manually written test cases for web applications.
their results showed that the execution time of theminimized test cases are on average shorter than that of the original test cases.
this shows that there is room to minimize even manually written test cases.
since they used relatively small testcases composed of less than actions it is hard to say if their delta debugging approach would scale on a large gui test case.
testminimizationingeneral.
testsuitereductiontechniques automatically reduce the size of a testsuite withoutlosing thecoverage ofthe testsuite.
unlikeour work these techniques assume that test suites consist of already compactedtestcases thesetechniquesdonotfocusonreducingthesizeofeachtestcase.theyonlyfocusonselectingasmallsetoftestcasesfromatestsuite.thefirstpartofthefirstphaseof detreduce where we remove redundant traces can be seen as a test suite reductiontechnique.inthecontextofguitesting mcmasterand memon proposed call stack history as a metric for reducing gui test suites.
we might be able to reduce more redundant traces byadoptingthistechnique.however itispossiblethatremovingtoo many traces at the first phase of detreduce might negatively affect the capability of the second phase of detreduce.
delta debugging isprobablythemostwidely knowntest minimizationtechnique.wefounditdifficulttousedelta debugging to minimize a large gui test suite because of the cost of running thetestsuite.itisoftenpossibletoacceleratedelta debuggingby exploiting domain specific knowledge.
for example hierarchicaldelta debugging hdd works on structured texts such as xml by first performing delta debugging on top level structures then gradually moving into substructures.
this allows hdd tosignificantly reduce the time required to reduce structured texts compared to the original delta debugging.
a similar idea has been usedindemi tominimizetestcasesforadistributedsystem.
however we have yet to find a way to make delta debugging scale better on gui test suites.
prior to our work groce et al .
proposed cause reduction a test reduction technique combining delta debugging and greedy test caseselection.therearetwonotabledifferencesbetweencausereduction and detreduce.
first cause reduction is comparable to phase of detreduce and it does not have a component correspondingtophase2.second cause reductionusesdelta debugging as a component.
on the contrary detreduce uses highly domainspecific components such as loop elimination and splicing.
automatedandroidguitestingtechniques.
inthispaperweused swifthand togeneratetestsuites.onecanuseanyautomated gui testing technique such as a3e dynodroid appsplayground or mobiguitar to generate initial test suites.
onemayarguethattestminimizationmightnotbenecessaryin the future if automated testing techniques continue to improve.
automatedguitestingtechniquesareindeedbecomingbetterin maximizingtestcoverageandfindingbugsinalimitedperiodof time .
however recent studies suggest that even test cases and test suites created by human experts need to be compacted.
therefore we predict that gui test suite minimization techniques will remain useful even though automated gui testing techniques continue to improve.
arecentsurvey comparestheperformanceofseveralautomated testing tools for android apps.
their results suggest thatmonkey outperforms other more sophisticated tools in terms of maximizing coverage in a limited period of time.
however we observed that it is difficult to replay test cases generated by monkey.
evenifmonkeyfindsabug itmightbedifficulttoreproducethebug or minimize the sequence of actions obtained from monkey .
gui test scripts and record and replay tools aremeanstogeneratereusabletestcasesreflecting humanknowledge.thesetoolscomplementourapproach.onecanusethesetoolseithertogenerateasetoftestcasestobeminimized or to add more test cases to already minimized test suites.