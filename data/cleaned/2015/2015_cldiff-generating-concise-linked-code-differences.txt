cldiff generating concise linked code differences kaifeng huang fudan university chinabihuan chen fudan university chinaxin peng fudan university china daihong zhou fudan university chinaying wang fudan university chinayang liu nanyang technological university singapore wenyun zhao fudan university china abstract analyzingandunderstandingsourcecodechangesisimportantina varietyofsoftwaremaintenancetasks.tothisend many codedifferencingandcodechangesummarization methodshavebeenproposed.
forsometasks e.g.codereviewandsoftwaremerging however those differencing methods generate too fine grained a representationofcodechanges andthosesummarizationmethodsgenerate toocoarse grainedarepresentationofcodechanges.moreover they donotconsidertherelationshipsamongcodechanges.therefore thegenerateddifferencesorsummariesmakeitnoteasytoanalyze and understand code changes in some software maintenance tasks.
inthispaper weproposeacodedifferencingapproach named cldiff togenerateconciselinkedcodedifferenceswhosegranularity is in between the existing code differencing and code change summarizationmethods.thegoalof cldiffistogeneratemoreeasily understandable code differences.
cldiff takes source code files beforeandafterchangesasinputs andconsistsofthreesteps.first itpre processesthesourcecodefilesbypruningunchangeddeclarationsfromtheparsedabstractsyntaxtrees.second itgeneratesconcisecodedifferencesbygroupingfine grainedcodedifferencesatorabovethestatementlevelanddescribinghigh levelchangesineachgroup.third itlinkstherelatedconcisecodedifferencesaccording to five pre defined links.
experiments with java projects commits andahumanstudywith10participantshaveindicatedthe accuracy conciseness performance and usefulness of cldiff.
ccs concepts softwareanditsengineering softwaremaintenancetools k.huang b.chen x.peng d.zhou y.wangandw.zhaoarewiththeschoolof computerscienceandshanghaikeylaboratoryofdatascience fudanuniversity china and the shanghai institute of intelligent electronics systems china.
b. chen is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
code differencing program comprehension ast acm reference format kaifenghuang bihuanchen xinpeng daihongzhou yingwang yang liu and wenyun zhao.
.
cldiff generating concise linked code differences.
in proceedings of the 33rd acm ieee international conferenceonautomatedsoftwareengineering ase september3 montpellier france.
acm new york ny usa 12pages.
.
introduction analyzingandunderstandingsourcecodechangesisimportantina varietyofsoftwaremaintenancetasks.forexample toimprovesoftwarequality developersoftenspendasignificantamountoftimeto comprehendcodechangesduringcodereview toresolvemergingconflicts codechangeknowledgeisrequiredduringsoftware merging andtoefficientlyfindregressionbugs codechangeinformationisusefulforselectingthetestcasesthatneedtobererun duringregressiontesting .therefore anumberof codedifferencingandcodechangesummarization methodshavebeenproposed to represent code changes at different granularity.
in particular for code differencing text based methods areunawareofthesyntacticstructureofsourcecodeand computetextualdifferencesthatarenoteasyforfurtheranalysis and understanding.
instead tree based methods directly work at the abstract syntax tree ast granularity for generating fine grained syntactic code differences.
the differences betweentwoastsareintheformofaneditscript asequenceof edit actionstotransformtheastbeforechangestotheastafterchanges.
sucheditscriptscanbetoofine grained tooscattered andtoolongto understandcodechangesinsomeapplications e.g.codereviewandsoftwaremerging especiallyforlargecodechanges .moreover therelationshipsamongcodechanges e.g.achangetothesignature of a method can result in changes to all the invocations of the method are missing which arein factimportant forcode change analysisandunderstanding e.g.therelatedcodechangesneedto be considered together during code review or software merging .
ontheotherhand codechangesummarizationmethods generatenaturallanguagesummariestodescribecode changes e.g.
the motivation behind code changes the commit message for code changes in a commit and the release authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. huang b. chen x. peng d. zhou y. wang y. liu and w. zhao public abstract class executorconfigurationsupport ... ... public void shutdown ... this.executor.shutdownnow for runnable remainingtask this.executor.shutdownnow cancelremainingtask remainingtask ... protected void cancelremainingtask runnable task ... org.springframework.scheduling.concurrent.executorconfigurationsupport.java org.springframework.scheduling.concurrent.threadpooltaskexecutor.java org.springframework.scheduling.concurrent.threadpooltaskscheduler.java public class threadpooltaskexecutor extends executorconfigurationsupport ... ... private final map runnable object decoratedtaskmap ... ...protected executorservice initializeexecutor threadfactory threadfactory rejectedexecutionhandler rejectedexecutionhandler ... super.execute taskdecorator.decorate command runnable decorated taskdecorator.decorate command if decorated !
command decoratedtaskmap.put decorated command super.execute decorated ... ... override protected void cancelremainingtask runnable task ... public class threadpooltaskscheduler extends executorconfigurationsupport ... ... private final map object listenablefuture ?
listenablefuturemap ... ... public listenablefuture ?
submitlistenable runnable task executorservice executor getscheduledexecutor try listenablefuturetask object future new listenablefuturetask task null executor.execute errorhandlingtask future false return future listenablefuturetask object listenablefuture new listenablefuturetask task null executeandtrack executor listenablefuture return listenablefuture catch rejectedexecutionexception ex ... public t listenablefuture t submitlistenable callable t task executorservice executor getscheduledexecutor try listenablefuturetask t future new listenablefuturetask task executor.execute errorhandlingtask future false return future listenablefuturetask t listenablefuture new listenablefuturetask task executeandtrack executor listenablefuture return listenablefuture catch rejectedexecutionexception ex ... private void executeandtrack executorservice executor listenablefuturetask ?
listenablefuture ... override protected void cancelremainingtask runnable task ... ... figure an example of code changes from commit 3c1adf7 in spring framework note forcode changesin arelease .
thesemethods aremostly developedfortheeaseofdocumentationofcodechanges.thus the generatedsummariesareusuallytoocoarse grainedtobeuseful for in depth analysis and understanding of code changes e.g.
code review and software merging .
toaddresstheproblemswithexistingmethodsandtoprovide more easily understandable code differencing information required fortaskssuchascodereviewandsoftwaremerging weproposeandimplementanovelcodedifferencingapproach namedcldiff.itis designedtogenerateaconcise linkedrepresentationofcodedifferences whosegranularityisinbetweentheexistingcodedifferencingandcodechangesummarizationmethods.inotherwords cldiff not only generates short and informative codedifferences but also establishes their relationships.
technically cldiff takes as inputs source code files before and afterchanges e.g.inapatch commitorrelease andworksinthree steps.
first cldiff pre processes the source code files by pruning unchanged declarations from parsed asts.
the purpose is to avoid unnecessary differencinganalysis on unchanged astelements in thesecondstep.second cldiffgeneratesconcisecodedifferences via grouping the fine grained code differences generated by gumtree atorabovethestatementlevelanddescribinghigh level changesineachgroup.theunderlyingideaistoputtogetherthe fine grainedcodedifferencesthatarescatteredbutrelatedtoahigh levelastelement.third cldifflinkstherelatedconcisecodedifferencesaccordingtofivepre definedlinks.themotivationisto consider such related code changes as a whole in some tasks.
we have implemented cldiff for java and conducted experiments with open source java projects i.e.
commits in total to evaluate the accuracy conciseness and performance of cldiffaswellasahumanstudywith10participantstoevaluatetheuse fulnessof cldiff.theresultshavedemonstratedthatcldiffgen eratedconcisecodedifferencesandestablishedtheirlinkswithanac curacyof99 and98 respectively andcomparedtogumtree cld iffgeneratedmorethan80 shortereditscriptfor48 commitswith shorter time and was more useful in change understanding.
in summary this work makes the following contributions.
weproposedacodedifferencingapproachnamedcldifftogenerate concise linked code differences.
we implemented cldiff for java and provided visualization for the generated concise linked code differences.
we conducted experiments with open source java projects as well as a human study with participants to demonstrate cldiff s accuracy conciseness performance and usefulness.
preliminaries ast.a source code file can be parsed into an abstract syntax tree ast whichisarooted labeled orderedtree.eachnodehasa label to indicateits typerepresentinga structuralelement e.g.
declaration ofthesourcecode.somenodeshaveastring valuetoindicate the actual token e.g.
variable name in code.
example2.
.
fig.
a and2 b givethetwoastsbeforeandafter the code changes at line in fig.
.
we only show partial asts forclarity.theastinfig.
a containseightnodes.specifically noden5hasthreechildnodes n6 n7andn8 anditslabelis methodinvocation.thelabelof n6 n7andn8issimplename.
n6 n7andn8respectivelydenotethereceiver nameandargumentofthemethodinvocation and their value is taskdecorator decorate andcommand.
astnodetypehierarchy.
thetypeoftherootnodeofanast iscompilationunit whosechildnodescanbeofthetype bodydeclaration.thecommonsubtypesof bodydeclaration aretypedeclaration class or interface declaration methoddeclaration method orconstructordeclaration initializer staticorinstanceinitializing block fielddeclaration fielddeclaration and enumdeclaration enumeration declaration .
declarations can contain a list of statementswhichhave22differentstatementtypes e.g.
ifstatement and variabledeclarationstatement .
statements can contain a list of expressions e.g.
methodinvocation .
therefore declaration statement and expression have a decreasing granularity.
however they can be nested with each other.
astdifferencing.
giventwoastsbeforeandaftercodechanges i.e.ast bandast a ast differencing tools can generate an edit script i.e.
a sequence of edit actions .
by sequentially applying the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
cldiff generating concise linked code differences ase september montpellier france block n1 expressionstatement n2 supermethodinvocation n3 simplename execute n4 methodinvocation n5 simplename taskdecorator n6 simplename decorate n7 simplename command n8 block n9 variabledeclarationstatement n10 simpletype runnable n11 simplename runnable n12 variabledeclarationfragment n13 simplename decorated n14 methodinvocation n15 simplename taskdecorator n16 simplename decorate n17 simplename command n18 ifstatement n19 infixexpression !
n20 simplename decorated n21 simplename command n22 block n23 expressionstatement n24 methodinvocation n25 simplename decoratedtaskmap n26 simplename put n27 simplename decorated n28 simplename command n29 expressionstatement n30 supermethodinvocation n31 simplename execute n32 simplename decorated n33 addvariabledeclarationstatementp n10 n1 addifstatement n19 n1 updateexpressionstatement n2 by addsimplename n33 n3 movemethodinvocation n5 n13 add n10 n1 add n19 n1 add n11 n10 add n13 n10 add n20 n19 add n23 n19 add n12 n11 add n14 n13 move n5 n13 add n21 n20 add n22 n20 add n24 n23 add n33 n3 add n25 n24 add n26 n25 add n27 n25 add n28 n25 add n29 n25 n1 n9 n2 n30 n3 n31 n4 n32 n5 n15 n6 n16 n7 n17 n8 n18 a partial ast before changes b partial ast after changes c mapping by g umtree d edit script by g umtree e edit script by c ldiff figure an example of differencing on line in fig.
editactions wecanconvert ast btoast a.hereweapplythestateof the art tool gumtree to generate fine grained code differences.gumtreeworksintwosteps.first itusesheuristicstoderive amapping between nodes in two asts.
the mapping is a set of pairs angbracketleftnb na angbracketright wherenode nbinast bismappedtonode nainast a. then basedonthemapping itgeneratestheeditscriptthatcontains four kinds of edit actions i.e.
update add deleteandmove.
update n v replaces the value of node nwith a value v. add n p i adds a new node nas thei th child node of node pif pisnotnull.otherwise nbecomesthenewrootnodeandhas the previous root node as its only child node.
delete n removes a leaf node n. move n p i moves node nto be the i th child node of node p. all descendant nodes of nare moved together with n. example .
.
fig.
c give the mapping generated by gumtree between the nodes in the two asts in fig.
a and2 b .
here all the eight nodes in fig.
a are mapped.
based on this mapping gumtreegeneratesaneditscriptcontaining18editactions aslisted infig.
d .specifically oneoftheeditactionsis move n5 n13 which moves the method invocation rooted at n5to be the second child node of a variable declaration fragment rooted at n13.
motivation and overview inthissection wemotivatetheproposedapproachwithanexample before introducing our approach overview.
.
motivation example fig.1lists three source code files changed in a commit taken from spring framework.inclass x aforstructure line2 isadded whereanewly declaredmethod line5 isinvoked.thisnewmethod isthenoverriddeninbothclass y line13 andclass z line because yandzinherit x. in class y a field is declared line6 avariableisextracted line7 andbothofthemareused inanewly added ifstructure line9 .inclass z afiledisdeclared line and then used in a newly declared method line28 .
this new method is then invoked in two similar code changes line16 21and22 .thisexampleisusedthroughoutthepaper.
giventhecodechangesatline7 12inclass yinfig.
wepresent thetwopartialastsbeforeandafterthechangesinfig.
a and b .theaddednodesarehighlightedingreenandthemovednodes arehighlightedinyellow.herenodeletionorupdateisinvolved.forthesechanges gumtreegeneratestheeditscriptshowninfig.
d which means that new nodes are added and one node is moved.
however someeditactions e.g.thoseunderlinedonesinfig.
d arerelatedtoahigh levelastelement e.g.variabledeclarationstate ment butarescatteredacrosstheeditscript.suchrelatedbutscatterededitactions althoughbeingexhibitedtogetherinvisualization makethefollow upanalysisandunderstandingofcodechangesdifficult.forexample incodereview developerswillrecognizethe insertionofavariabledeclarationstatementintuitivelyratherthan thinking of the fine grained tree operations.
similarly in software merging anewly addedvariabledeclarationstatementwillbeconsideredasawholetoresolveaconflict.therefore togeneratemore easily understandable code differences for both developers and automatic analysis tools we try to obtain high level concise code differences at or above the statement level.
fig.
e shows the edit scriptgeneratedbyourapproach.ithasfourhigh leveleditactions i.e.addingavariabledeclarationstatement addingan ifstatement updatinganexpressionstatementbyaddingasimplename andmovingamethodinvocationtobeapartofthenewly addedvariable declaration statement see approach details in section .
.
on the other hand the relationships among code changes are not considered in gumtree but are actually helpful in the analysis and understanding of code changes.
as an example for the newlydeclaredmethodatline5infig.
itisinvokedatline3andoverriddenatline13 14and29 .asanotherexample thecodechangesatline16 21arealmostthesametothecodechangesatline22 .suchrelationshipscapturethecausalityofcodechanges whichcan speeduptheprocess ofcodereviewandimprovetheaccuracyof merging conflict resolution.
therefore we attempt to establish the linksamonggeneratedhigh levelcodedifferences seeapproach details in section .
.
.
approach overview fig.3presentsanoverviewof cldiff.theinputsof cldiffareaset of pairs of source code files before and after changes e.g.
in a commit patch or release .
the outputs can be visualized by our webbasedtool.cldiffworksinthreesteps pre processing section .
generating concise code differences section .
and linking code differences section .
togenerateconciselinkedcodedifferences.
first sincecodechangesoftenaffectasmallpartofasourcecode fileandalargeamountofcoderemainsunchanged wepre process thepairsofsourcecodefilestoremovesomeunchangedcodeinordertoavoidunnecessarydifferencinganalysis.tothisend cldifffirstparseseverypairofsourcecodefilesintoanastpair andthen prunes unchanged declaration level elements from the ast pairbased on a hashing technique.
here we select declaration as the pruning unit to strike a balance between feasibility and scalability.
second asfine grainedcodedifferences intheformofeditactions areoftenrelatedtohigh levelastelementsbutscatteredacrosstheeditscript wegeneratehigh levelconcisecodedifferencesator authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. huang b. chen x. peng d. zhou y. wang y. liu and w. zhao figure an overview of cldiff abovethestatementlevel.specifically cldifffirstusesgumtree toobtainthemappingandeditactionsforeachprunedastpair.
then it traverses the edit actions and the pruned ast pair to iterativelygroupeditactionsthatarerelatedtoanastelementator abovethestatementlevel.finally itgeneratesaconcisecodedifferenceforeachgrouptocaptureitshigh levelchanges.herewechoose statementasthesuitablegranularityofcodedifferencestobetter reflect developers intuition about code changes.
third sincecodechangesareoftencausallyrelatedwitheach other weestablishlinksamongthegeneratedconcisecodedifferences.specifically basedontheconcisecodedifferencesforeach pairofsourcecodefiles cldiffcheckswhetherthereexistsacodechangelinkbetweentwoconcisecodedifferencesaccordingtofive pre defined links e.g.
def uselink .
methodology inthissection weelaborateeachstepof cldiff indetail.
ourapproachisgeneral althoughweexplainourapproachforjava.
.
pre processing inthefirststep wepre processthesourcecodefilestoprunesome unchanged declarations from parsed asts.
giveneachpairofsourcecodefiles angbracketleftfb fa angbracketright weparseitintoanast pair angbracketleftast b ast a angbracketright whereast bistheastofthefile fbbeforecode changesand ast aistheastofthefile faaftercodechanges.then wetraverse ast btocomputetwohashvaluesforthenodewhoselabel is a field enumeration method inner class or initializor declaration andstoretheastnodetoamapwhosekeyisthetwohash values.onehashvalueiscalculatedoverthecanonicalnameofthe residingclassandisusedtodistinguishthesamedeclarationinbothouterandinnerclasses.anotherhashvalueiscalculatedoverthecor respondingdeclarationcode i.e.thesubtreerootedatthenode .fi nally wetraverse ast atocomputethetwohashvaluesforeachdeclarationnode andprunethenode includingallitsdescendantnodes fromboth ast bandast aifthetwohashvaluesfindamatchinthe map.theoutputisaprunedastpair angbracketleftast prime b ast primea angbracketright.noticethatas comments and javadocs are not treated as code they are removed from asts beforehand.
.
generating concise code differences in the second step we generate concise code differences from finegrainedcodedifferences.ourunderlyingideaistoputfine grained code differences within a statement or declaration ast element to a group and describe high level changes in the group.
specifically givenaprunedastpair angbracketleftast prime b ast primea angbracketright weusegumtree togeneratethemapping mandtheeditscript abetween thetwoasts.recallthat mmaintainsthemappedastnodepairs andastorestheeditactions section .then wetraversetheeditactions in three phases to group edit actions and generate concise code differences.
phase1.
different from update addanddeleteactions that only affect one atomic node but not its descendant nodes moveactions movethewholesubtreerootedatonenode.therefore a moveactioncanalreadyreflecthigh levelconcisecodechanges.inthatsense foreachmove n p i a wegenerateaconcisecodedifference movex n p i wherexisthelabelofnode nandexplicitlyreflects the syntactic information and remove move n p i froma.
example4.
.
theeditscriptinfig.
d containsone moveaction move n5 n13 thatmovesawholemethodinvocation.thus cldiff generates movemethodinvocation n5 n13 .
phase2.
somestatementsordeclarationshavesimplestructures while others contain complex ones with statements or declarations nested as composing elements.
in that sense an addor adeleteactiononastatementordeclarationastnodeismostlyaccompaniedbysimultaneous addordeleteactionsonitscomposingelements i.e.
awholeorapartofastatementordeclarationisaddedordeletedto gether.hence wegroupeditactionswithrespecttothecomposing elements ofa statementor declaration and distinguishwhether a wholeorapartofacomposingelementisaddedordeletedtogether.
beforeintroducinghowtogroupeditactions wefirstcategorize allstatementsanddeclarationsintotwocategoriesanddefinetheir baseandcomposing elements.
c1.this category includes statements and declarations whose childnodes ncancontainstatementsordeclarations e.g.
ifstatement trystatement methoddeclaration andtypedeclaration.
wedefineeachnode n nthatisanon blockstatementoradeclaration as a composing element each child node of the node n nwhichisablockstatementasacomposingelement and all the other nodes in nand their parent node as a base element.
c2.this category contains statements and declarations whose childnodesdonotcontainstatementsordeclarations e.g.
expressionstatement variabledeclarationstatement returnstatement andfielddeclaration.
they are defined as a base element and do not have composing elements.
example4.
.
infig.
n10isavariabledeclarationstatementthat belongsto c2 andthus n10andallitsdescendantnodesareconsideredasthebaseelementof n10.n19isanifstatementwhichbelongs toc1 andhence n19 n20 n21 n22andn23areconsideredasthebase element of n19 representing the wrapper of the ifstatement intuitively while n24and all its descendant nodes are considered as a composing element of n19 indicating the statement in the ifstatement body .
similarly the base element of a method declaration denotes the method with an empty body whileits composing elements represent the statements in the method body.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
cldiff generating concise linked code differences ase september montpellier france then we introduce how to group edit actions.
specifically for eachadd n p i awherenis a statement or declaration we put thisactionto bwhichmaintainsthe addactionsonthebaseelement locate nonast a because addactions are applied on ast a andtraverse n sdescendantnodesinadepth firstwaywhiledistinguishingbaseandcomposingelements.forthebaseelement for each traversed node m i fmis newly added by an addactiona w e groupatoband continue the traversal on m s child nodes otherwise misnotnewly added i.e.thereexistsamatchin mform we markbas apartial addition stop our traversal on m s child nodes butcontinuethetraversalonothernodesinthebaseelement.after completing the traversal if bis marked as a partial addition we generate a concise code difference addxp n p i wherexis the label ofn pdenotes partial addition and nis the subtree resultingfromtheactionsin b andremove bfroma otherwise the whole base element is newly added we traverse the composing elements to determine whether they are allnewly added.
if yes we store all these addactions to c generate a concise code differenceaddx n p i wherexis the label of nandnis the subtree resultingfromtheactionsin bandc andremove bandcfrom a.ifnot wegenerate addxp n p i andremove bfroma.intuitively if one whole statement or declaration is added we generate one code difference otherwise we generate code differences on its base and composing elements separately.
ontheotherhand foreach delete n awherenisastatement or declaration we traverse nonast b asdeleteactions are applied onast b inthesamewayasfor addactions andgenerateeither deletexp n ordeletex n .
example4.
.
whentraversingtheeditscriptinfig.
d wefirst analyzeadd n10 n1 whichaddsavariabledeclarationstatement thatbelongsto c2.wegroupitwith add n11 n10 add n13 n10 add n12 n11 andadd n14 n13 inb.a sbismarkedasapartialaddition wegeneratethefirstcodedifferenceinfig.
e .then we analyze add n19 n1 which adds an ifstatement of c1.w e groupitwith add n20 n19 add n21 n20 add n22 n20 and add n23 n19 inb.asbisnotmarked wefurthergroup add n24 n23 withadd n25 n24 add n26 n25 add n27 n25 add n28 n25 andadd n29 n25 inc andthengeneratethesecondcode difference in fig.
e that adds a complete ifstatement.
example .
.
fig.4shows another case of generating concise codedifferences.whentraversingtheeditscriptinfig.
e wefirst encounter add n15 n1 which adds an ifstatement that belongs toc1.wegroupitwithalltheother addactionsinfig.
e inb.as bis not marked we further analyze its composing elements.
however the composing element is not newly added but moved.
thus wegeneratethefirstcodedifferenceinfig.
f whichactuallyadds a wrapper of an ifstatement.
phase3.
afterphase1andphase2 theremainingactionsin a are onlyadd deleteandupdateactions on non statement and nondeclaration ast nodes.
given that some actions are applied within the same statement or declaration we group such actions together with respect to their common ancestor statement or declaration.
in particular for each traversed add n p i a we locate n s closest ancestor node mthat is a statement or declaration in ast a r e placemwithitsmapping m primeinast busingmifm primeexists andput add n p i toalistqmthatmaintainsalltheactionsappliedwithinpublic abstract class patternsrequestcondition... ... public list string getmatchingpatterns string lookuppath ... matches.sort this.pathmatcher.getpatterncomparator lookuppath if matches.size matches.sort this.pathmatcher.getpatterncomparator lookuppath return matches org.springframework.web.servlet.mvc.condition.patternsrequestcondition.java block n1 ... expressionstatement n2 methodinvocation n3 simplename matches n4 simplename sort n5 methodinvocation n6 fieldaccess n7 thisexpression n8 simplename pathmatcher n9 simplename getpatterncomparator n10 simplename lookuppath n11 returnstatement n12 simplename matches n13 block n14 ... ifstatement n infixexpression n16 methodinvocation n17 simplename matches n18 simplename size n19 numberliteral n20 block n21 expressionstatement n22 methodinvocation n23 simplename matches n24 simplename sort n25 methodinvocation n26 fieldaccess n27 thisexpression n28 simplename pathmatcher n29 simplename getpatterncomparator n30 simplename lookuppath n31 returnstatement n32 simplename matches n33 addifstatementp n15 n1 moveexpressionstatement n2 n21 add n15 n1 add n16 n15 add n21 n15 add n17 n16 add n20 n16 move n2 n21 add n18 n17 add n19 n17 n1 n14 n2 n22 n3 n23 n4 n24 n5 n25 n6 n26 n7 n27 n8 n28 n9 n29 n10 n30 n11 n31 n12 n32 n13 n33 b partial ast before changes c partial ast after changes d mapping by g umtree e edit script by g umtree f edit script by c ldiff a an example of code changes from commit b104897 in spring framework figure an example of concise code differences m. similarly foreach traversed delete n orupdate n v ina w e findn sclosestancestornode mthatisastatementordeclarationin ast b andstore delete n orupdate n v toqm.afterthetraversal foreachqm wegenerateaconcisecodedifference updatex m byy wherexis the label of mandyrepresents the actions in qmwith the syntactic information highlighted in their action names.
in this way alloriginally scatterededitactionsononestatementordeclaration are grouped together for the ease of analysis and understanding.
unlike our addanddeleteactions mis not a subtree but an atomic node to inform that the actions in qmare applied on scattered descendant nodes of m. example4.
.
followingexample .1and4.
thereisonlyoneremainingeditaction add n33 n3 intheeditscriptinfig.
d after phase1andphase2.
n33 sclosestancestornodethatisastatement ordeclarationinfig.
b isn30 mappedto n2infig.
a .hence updateexpressionstatement n2 by addsimplename n33 n3 is generated as shown by the last code difference in fig.
e .
.
linking code differences in the third step we establish code change links among the generatedconcisecodedifferencesaccordingtofivepre definedlinks.such links reflect the causality of code changes.
wefirstdefinethefivekindsofcodechangelinks whicharenot meant to be exhaustive but to demonstrate that a small set of links arealreadyusefulinchangeunderstanding.theycanbeextendedto incorporate new kinds of links.
def uselink.
ifthedeclarationofavariable fieldormethodis changed i.e.added deleted updatedormoved bycodedifference authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. huang b. chen x. peng d. zhou y. wang y. liu and w. zhao figure a snapshot of our visualization tool d1 theusageofthevariable fieldormethodcanbechangedby d2.
wedefinethelinkbetween d1andd2asadef uselinkd1du d2.
abstract method link.
if the declaration of an abstract method in a class is changed by d1 the implementation of the abstract method in eachsub class must be changed by d2.
we definethe link between d1andd2as anabstract method linkd1am d2.
override method link.
if the declaration of a method in a class is changed by d1 the implementation of the method might be changed through override in each sub class by d2.
we define the link between d1andd2as anoverride method linkd1om d2.
implement methodlink.
ifthe declaration ofamethodin aninterfaceischangedby d1 theimplementationofthemethodmust bechangedineachclassthatimplementstheinterfaceby d2.w e definethelinkbetween d1andd2asanimplement method link d1im d2.
systematic changelink.
iftwocodedifferences d1andd2aresimilar theymightbecausedbysystematicchanges e.g.refactoring andrecurringbugfixes .wedefinethelinkbetween d1andd2as asystematic change linkd1sc d2.
then weintroducehowtoestablishtheselinksbasedonconcise codedifferences diforeachprunedastpair.assumingthatthere aretotally kastpairs i.e.
i k.specifically toestablish defuselinks wefirstfindeach d d ithatisappliedonavariabledeclaration statement a field declaration or a method declaration and extractthenameofthevariable fieldormethod.then welocate everye d ithatiswithinthesamescope i.e.foravariabledeclarationstatement thescopeisitsenclosingmethoddeclaration and forafieldormethoddeclaration thescopeisitsenclosingclassdeclaration and involves a variable field access or method invocation with the same name and establish the link ddu e. here we only consider the def uselinks within a limited scope e.g.
we do not consider that a method declaration might be used in another class.
tobuildabstract method override method orimplement method links wefirstfindeach d d ithatisappliedonanabstractmethod declaration amethoddeclarationoraninterfacemethoddeclaration andextractthemethodsignatureandthenameoftheenclosing abstract class class or interface.
then we find every e d j j nequali thatisappliedonsuchamethoddeclarationthatithasthesame methodsignatureanditsenclosingclassextendsaclassorimplements an interface with the same name and construct the link dam e dom eordim e.toconstruct systematic change links foreach delete addormove actiond d ithatisappliedonnode nd wefirstgeteach delete addormoveactione d j e nequald thatisappliedon newhoselabel is the same to nd.
then we check whether the size of the grouped editactions seesection .
forndandneisthesame.ifyes we compute the bi gram similarity between the code snippets corresponding tothe subtreesrooted at ndandne.
ifthe similarityis largethanorequalto0.
webuildthelink dsc e.foreach update action the overall procedure is similar but the similarity computation is different.
since our updateactions often group a set of finegrained edit actions that are scattered ndandneare atomic nodes.
hence we get the subtrees rooted at ndandnefrom the pruned astpair i.e.eitherfromboth ast bandast aoronlyfrom ast bdependingonwhether ndandnecanberespectivelymappedintheir m and compute the bi gram similarity.
intuitively this checks whether the changed code before and after changes is similar.
itisworthmentioningthatourstrategyofestablishinglinksis designedtobeheuristicandlightweightanddirectlyworkatthe sourcecodelevel butnotrelyonheavyweightprogramanalysis techniques.
our assumption is that code changes are often focused andsuchasimplestrategyisoftensufficienttoachieveabalance between accuracy and scalability.
we leave it as our future work toinvestigatethecost benefitofusingheavyweightprogramanalysis techniques to establish links.
example4.
.
forthecodechangesinfig.
cldiffcorrectlyestablishesallthelinkswithoutanyfalsepositiveorfalsenegative.
for example it constructs a override method links between the addmethoddeclaration for line and the addmethoddeclaration for line .
it establishes a def uselink between the addvariabledeclarationstatementp forline8andthe addifstatement forline9 .it buildsasystematic change linkbetweenthe updatevariabledeclarationforline16 19andthe updatevariabledeclaration forline22 .
implementation and evaluation we have implemented cldiff for java with 30k lines of java code anddevelopedaweb basedtooltovisualizeourconciselinkedcodedifferenceswith4.6klinesofjavascriptcode.fig.
5givesasnapshot of our visualization tool.
a concise code difference is visualized viahighlightingthecodeandpromptingtheactionname.aclickononeofthehighlightedcodesnippetswillpopawindowtoshowthelinks thatarerelatedtothiscodedifference whileaclickononeofthe links will navigate to the corresponding code difference.
cldiff is open sourced and is available at .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
cldiff generating concise linked code differences ase september montpellier france table projects used in our experiments projects creation date loc stars commits rxjava .0k .6k elasticsearch .2k .5k okhttp .0k .3k retrofit .4k .5k spring framework .5k .7k zxing .0k .3k netty .6k .7k fastjson .0k .3k guava .0k .7k glide .6k .4k mybatis .0k .4k mpandroidchart .7k .8k .
evaluation setup toevaluatetheeffectivenessof cldiff weconductedexperiments using12highly staredopen sourcejavaprojectsfromgithubbycomparingcldiffwithoneofthestate of the artastdifferencingtools gumtree .
table1reports the statistics about projects includingprojectname creationdate linesofcode thenumberofstars andthenumberofcommits.thenumberofcommitsiscomputedbyremovingthecommitsthatarenotrelatedtocodechanges e.g.changes to configuration files or only related to testing code changes.
in total 387commitsareused.wecanseethattheseprojectsareall large scale and popular and have a long evolution history.
this en suresthattheseprojectscontainrichanddiversecodechanges.gumtree was configured with the same setting as the one used in .
ontheotherhand toevaluatetheusefulnessof cldiff weconductedahumanstudywith10participantstounderstandthechanges in commits.
in particular from our school we hired graduate students who had at least years experience in java programming.
oneofthemhad6 yearsexperience andtheaverageexperience was4years.alltheparticipantsarenottheauthorsofthispaper.
besides we randomlyselected commits fromthose projects with the criterion that at most java source files were involved in a commit.
this is to control the complexity of understanding code changes and thus keep the concentration of participants.
usingtheprevioussetup weconductedtheexperimentsandthe human study to answer the following research questions.
rq1 howistheaccuracyofthegeneratedconcisecodedifferences and the established links by cldiff?
section .
rq2 howisthesizeofthegeneratedconcisecodedifferences of cldiff compared to gumtree?
section .
rq3 how is the performance overhead of cldiff compared to gumtree?
section .
rq4 how is the usefulness of cldiff in understanding code changes compared to gumtree?
section .
.
accuracy evaluation rq1 toevaluatetheaccuracyof cldiff sgeneratedconcisecodedifferencesandestablishedlinks werandomlychose10commitsfrom eachproject andmanuallyanalyzedtheresultsof cldiffonthem.
table2showstheaccuracyresults wherewealsoreportedthetotal numberofgeneratedcodedifferencesforthe10commitsandthe total number of established links under column size.
in total we analyzed code differences and achieved an accuracy of and we analyzed links and achieved an accuracy of .table accuracy of cldiff projectconcise code differences links size accuracy size accuracy rxjava .
.
elasticsearch .
.
okhttp .
.
retrofit .
.
spring framework .
.
zxing .
.
netty .
.
fastjson .
.
guava .
.
glide .
.
mybatis .
.
mpandroidchart .
.
forallthe12inaccuratecodedifferences wefoundthatallofthem werecausedbytheinaccuratemappingingumtree becausecldiffusesthemappingthatisheuristicallygeneratedbygumtree .in detail 10ofthemwerecausedbymissedmappings i.e.twoastnodes thatshouldhavebeenmappedareactuallynotmapped.asaresult gumtreegeneratesa deleteandanaddactioninsteadofa moveaction making cldiff fail to generate a moveaction as well.
in addition twoofthemwerecausedbywrongmappings i.e.twoastnodesthatshouldnothavebeenmappedareactuallymapped.thus both gumtree and cldiff generate a code difference that does not reflect the real code change confusing the change understanding.
amongthe512links ourfivepre definedlinksalloccurredexceptforimplement method links andaround91 ofthemwere defuselinks.
we found totally inaccurate links and all of them were def uselinks.theywerecausedbyourheuristicnatureofestablishinglinks e.g.whenalocalvariablesharesthesamenameasafieldinitsenclosingclass ourapproachmightconstructwronglinks.thishigh accuracy is surprising but still reasonable as code changes areoftenfocusedandour simplestrategy onlyanalyzesthose changed code that contain small sources of inaccuracy.
summary.
basedontheresultsintable wecanpositivelyanswerrq1that cldiff had a high accuracy of and for the generated concise code differences and established links.
.
conciseness evaluation rq2 toanalyzewhethercldiffgeneratesconcise orshort codedifferencescomparedtogumtree wemeasuredthelengthoftheedit script i.e.thenumberofactionsinthescript foreachcommit.sincetheupdateactionsincldiffsimplyputasetoffine grainedactions togetherbutnotrepresentacompleteactionlikeour addanddelete actionsdo weusedthenumberofthosefine grainedactionsforthe counting for our updateactions to have a fair comparison.
overall for90 commits cldiffgeneratedshorter editscripts thangumtree.fortheremaining10 commits cldiffhadthesamelength as gumtree meaning that the fine grained edit actions cannot be grouped at or above the statement level.
table3presentsthemaximumandmedianlengthforeachproject theminimumlengthsareomittedastheyareallone whichshows that cldiff significantly shortened the edit script.
fig.
6further shows the lengthratio of cldiff to gumtree with respect to each commitineachproject.foralltheprojects themedianratiowasaround0.
.numerically for48 commits cldiffshortenededit scriptsbymorethan80 .thisowestoourhigh level addanddelete actions describingagroupoffine grained addanddeleteactions.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. huang b. chen x. peng d. zhou y. wang y. liu and w. zhao table length of generated code differences projectmaximum median gumtree cldiff gumtree cldiff rxjava .
elasticsearch okhttp retrofit spring framework zxing netty fastjson guava glide mybatis mpandroidchart average figure length ratio of cldiff to gumtree table4lists the maximum and median group size for our addand deleteactions.
these maximum cases often correspond to the additionordeletionofanentiremethoddeclaration.themediansize was respectively and for our addanddeleteactions.
summary.
basedontheresultsintable 3and4andfig.
wecan positivelyanswer rq2thatcldiffgeneratedmorethan80 shorter edit scripts for commits than gumtree.
.
performance evaluation rq3 table5comparestheaverageperformanceoverhead inmilliseconds of cldiffandgumtreeingeneratingcodedifferencesforthe setofchangedsourcecodefilesineachcommit.italsoreportstheper formanceoverheadofeachstepincldiff.wecanseethatcldifftook72 shortertimethangumtree.thereasonisthat incldiff we prune unchanged declarations in the ast pairs before applying gumtreetogeneratefine grainedcodedifferences whilegumtree directly works on raw asts.
besides the second step of cldiff is themostexpensivestep spending92 ofthetime.thethirdstepis the cheapest step only taking .
milliseconds for a commit.
this actually owes to ourheuristic based strategy to build links which alsoachieveshighaccuracyasdiscussedinsection .
.onaverage cldiff spent .
milliseconds for a commit.
summary.
basedontheresultsintable wecanpositivelyanswerrq3that cldiff spent shorter time than gumtree.
.
usefulness evaluation rq4 toevaluatetheusefulnessof cldiff weconductedahumanstudy with10participantstounderstandthechangesin10commits i.e.to finish10tasks withthehelpof cldiffandgumtree.thisstudywastable group size of our addand deleteactions projectmaximum median add delete add delete rxjava elasticsearch okhttp retrofit spring framework zxing netty fastjson guava glide mybatis mpandroidchart average table performance overhead of gumtree and cldiff project gumtree ms cldiff ms step step step total rxjava elasticsearch okhttp retrofit spring framework zxing netty fastjson guava glide mybatis mpandroidchart average .
.
.
.
.
conductedblindly i.e.participantsdidnotknowwhichtoolwasdeveloped by us.
we divided the participants into two groups equally.
thefirstgroupusedcldifftounderstandthechangesforthefirst five tasks and used gumtree for the remaining five tasks.
the secondgroupusedcldiffandgumtreeinanoppositeway.everypar ticipantwasaskedtoanswerseveralquestionsaboutthechangesineachtask writedownasummaryofhis herunderstandingaboutthe changesineachtask andrecordthetimerequiredtofinisheach task.
details of the tasks are available at .
after they finished all the tasks we further asked the participants to finish a questionnaire which contained four questions with provided options.
q1 does cldiff do a good job?
a yes b neutral c no q2 does gumtree do a good job?
a yes b neutral c no q3 is cldiff or gumtree more helpful?
a cldiff b gumtree c no difference q4 are cldiff s code differences and links helpful?
a both b code differences c links d neither basedonthishumanstudy weusedthreeindicatorstocompare cldiffwithgumtree.thefirstindicatorisascoretoassessthedegreeofunderstandingthechangesineachtask.twooftheauthorsmanuallyassignedascorebetween0and2toboththetask specific questionsandthesummaryofeachtaskforeachparticipant.thusa fullscoreis4.astask specificquestionshaddeterministicanswers .
was deducted for one wrong answer.
the summary was scored basedonwhethercodechangeswereunderstood.duetothesubjec tive nature the two authors finalized the summary s score through discussion.
the second indicator is the time required to finish each task.
the third is the qualitative results about the questionnaire.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
cldiff generating concise linked code differences ase september montpellier france a score of understanding the changes in tasks b time of understanding the changes in tasks figure comparison results of the score and time of understanding the changes in tasks table answers to the questionnaire questionanswers a b c d q1 q2 q3 q4 fig.7showstheresultsofthetwoindicatorsscoreandtime.the x axisinfig.
7denoteseachtask the y axisinfig.
7aand7brespectivelydenotetheaveragescoreofunderstandingthechangesineach taskandtheaveragetimetofinisheachtask.overall theaverageto talscoreof cldiffandgumtreefor10taskswasrespectively34.
and .
and there was a significant difference in score between cldiffandgumtreeaccordingtothewilcoxonsigned ranktest.
theaveragetotaltimeof cldiffandgumtreefor10taskswas respectively and seconds.
however there was no signif icantdifferenceintimebetweencldiffandgumtree.specifically in four tasks cldiff took more time but had higher score in two tasks cldiff took less time but had lower score and in four tasks cldiff took less time and had higher score.
table6reports the results of the four questions in the questionnaire.thefirstcolumnliststhequestion andtheotherfourcolumns report the number of participants choosing the corresponding options.generally alltheparticipantfeltthatcldiffwashelpful q1 andwasmorehelpfulthangumtree q3 whilesomeparticipants felt that gumtree was not very helpful q2 .
besides seven participants thought that our concise code differences were helpful and eight participants thought that our links were helpful q4 .
summary.
based on the results in fig.
7and table w ec a n positivelyanswer rq4thatcldiffwasmoreusefulthangumtree inunderstandingcodechangesforallparticipants andourconcise code differences and their links were helpful for most participants.
.
discussion threats.theprimarythreatstothevalidityofourexperimentsand humanstudyaretwofold.first weanalyzedtheaccuracyof cldiffusingatotalnumberof120commits whichwasnotverylarge scale.
this is because such a manual analysis is very time consuming involvingtheunderstandingofmapping editscript astpairsandreal codechanges.hence wefollowedthesimilarworkintheliterature touse120commits.however thesecommitsweretakenfrom12 differentprojects andthuscanbeconsideredasrepresentativecodechanges.second wehired10graduatestudentstoparticipatethe humanstudyratherthandevelopersworkingintheindustry.therefore weonlyrecruitedthestudentsthathadatleast3 yearsprogramming experience.
a further human study is required to evaluate the usefulness of cldiff in the industry.
limitations.
onemainlimitationof cldiffistheheuristicnatureofestablishinglinks especiallyfor def uselinks asindicatedin our accuracy evaluation section .
.
we plan to investigate the cost and benefit of using data flow analysis to further improve the linkaccuracy.ontheotherhand weonlysupportfivekindsoflinks.
we plan to further analyze the usefulness of each kind of links extendthecapabilityofcurrentlinksandsupportmorelinkssuchthat we can have a compact but really useful set of links.
applications.
we believe that cldiff can be useful in various applications.
for example by applying cldiff to the evolution historyofaprojectandchainingthesecodedifferencestogether we candetectlogicalcoupling atafinergranularity.usingstatistics about the different kinds of code differences in each commit as features wecan classify commits into bugfixing refactoringor upgradingbasedonmachinelearningtechniques.byfurtherattaching a semantic understanding of our generated code differences wecancharacterizeorevenquantifysemanticchangesforsecurity patchorcompatibilityanalysis .bycombiningcldiffwith performance analysis techniques we can analyze performance regressions and potentially locate their root causes.
related work we focus our discussion on the most relevant work in four aspects i.e.
code differencing code change summarization code change decomposition and systematic code changes.
.
code differencing text basedapproaches arefirstproposedtocomputedifferences intheformofinserted removedorchangedlinesofcode betweentwoversionsofasourcefile followedbyseveraladvances thatfurtheridentifymovedlinesofcode.theseapproaches areoftenfastandlanguage independent however theyfailtocomputesyntacticcodechanges hinderingcodereview automatic analysis and tool development based on their code differences.
tree basedapproaches arethenproposedtogenerate syntactic code changes.
changedistiller uses a general tree authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france k. huang b. chen x. peng d. zhou y. wang y. liu and w. zhao differencingalgorithm togenerateaneditscriptfromtwocoarsegrainedastswheretheleafnodesarecodestatements e.g.
method invocationsorcontrolstatements ratherthanrawasts.although being sufficient to meet its purpose of classifying certain change types changedistiller is not able to distinguish updates on statements.thisalsoexplainswhyweusedandcomparedgumtree but not changedistiller.
diff ts can work on raw asts.
it extendsatreedifferencingalgorithm togenerateafine grained editscript.amorerecentapproachisgumtree whichalso worksonrawasts.thegoalistofindaneditscriptthatwellreflects the developer intent based on several heuristics.
higo et al.
e x tendgumtreebyintroducingcopy and pasteasanewkindofeditactionstomakeeditscriptsshorterandmoreeasilyunderstandable.dotzler and philippsen propose some general optimizations to improve the accuracy of the previous tree based approaches in detecting moved code.
most of these tree based approaches generate low levelfine grainedrepresentationsofcodechanges whereasour approach first computes high level abstracted code changes and then establishes potential links among code changes.
besides graph baseddifferencingapproaches areproposed to deal with graph representations of source code e.g.
extendedcontrolflowgraph andabstractsyntaxtree with programsemantics andclassmodel withumlsemantics.with thesemanticinformation theycancapturecertainsemanticcode changes.further someadvances havebeenmadetoachieve semantic differencing based on input output behaviors.
these approachesprovideuswithagoodinsightonextendingourapproach to understand the semantics behind our syntactic code changes.
.
code change summarization to generate natural language descriptions of code changes a numberofadvances havebeenmadetosummarizecodechanges.deltadoc capturesthebehavioralchangesfor everymethodandtheconditionsunderwhichtheyoccur.change scribe generatesacommitmessagebyprovidingageneral description of a commitand detailed descriptions of code changes inthecommitbasedonpredefinedrules.jiangetal.
andloyola et al.
adapt a neural encoder decoder architecture to automaticallygeneratecommitmessagesfromcodedifferences.assoftwaredocumentsareoftenrelated rastkarandmurphy proposeamachinelearning basedtechniquetoextractdescriptionsfromasetof relevant documents e.g.
commit messages or bug reports .
inte grating the ideas of and arena summarizes code changes at the system level and links to issues to generate release notes.thesechangesummarizationtechniquesaremostlydesigned for the ease of documentation of code changes while cldiff generates more fine grained code changes at the syntactic level.
.
code change decomposition developersusuallycommitunrelatedorlooselyrelatedcodechanges in a single commit resulting in tangled changes which make code reviewdifficultandcommit orientedanalysisbiased.tothisend kawrykow and robillard detect non essential changes e.g.
local variableextractions ina commitbased onfine grained code change analysis.
herzig and zeller report the first empirical study on the frequency and impact of tangled changes.
they use amultilevel graph partition algorithm to decompose tangled changesbasedonasetoffeatures.diasetal.
improvefeatures in bynotrelyingonstaticanalysisbutconsideringfine grained code change informationgathered during development.
based on improvedfeatures theyleveragemachinelearningandclustering todecompose tangledchanges.
barnettet al.
usedef useinformationfromaddedorchangedcodetodecomposetangledchanges.
tao and kim develop three heuristics to decompose tangled changesintochangesforformatting changeswithstaticdependencies andchangeswithsimilarpatterns.guoandsong apply programslicingandastsearchingtointeractivelydecomposetan gledcodechangesforcodereviewandregressiontesting.theseap proachesinspireustoexplicitlyestablishlinksamongcodechanges.
.
systematic code changes systematic code changes i.e.
similar related code changes can be caused by crosscutting concerns api evolution recurring bug fixes orrefactoring .
kim etal.
firstidentify such systematic code changes at the method signature level and representthemaslogicrules.then kimetal.
extend to describechangeswithinamethodbodyandatafieldlevel.recently zhang et al.
propose an interactive approach to allow developerstocustomizeageneratedchangetemplateandtomatchthetemplate to summarize systematic changes and locate potential inconsistent or missing changes.
given a systematic code change mcintyre and walker discover locations where this change should be applied if anyexist andmeng etal.
furtherautomaticallyapplythischangetothediscoveredlocationswithdifferent contexts.differentfromtheseapproachesthatfocusonaspecific kind of code changes i.e.
systematic code changes our approach focusesonabroaderrangeofcodechanges.further weplantouse them to improve the construction of systematic change links.
conclusions in this paper we have proposed and implemented a code differencingapproach namedcldiff togenerateconciselinkedcodediffer ences.cldiff sgoalistogeneratemoreeasilyunderstandablecode differences.takingasinputsasetofsourcecodefilesbeforeand afterchanges cldiffworksinthreesteps.first itpre processes source code files to prune unchanged declarations from parsed abstractsyntaxtrees.second itgroupsfine grainedcodedifferencesat orabovethestatementlevelandgeneratesaconcisecodedifference tocapturehigh levelchangesineachgroup.third itlinkstherelated concise code differences based on five pre defined links.
our experiments with open source java projects and a human study with participants have demonstrated the accuracy conciseness performance and usefulness of cldiff.