accurate string constraints solution counting with weighted automata elena sherman computer science department boise state university boise id usa elenasherman boisestate.eduandrew harris computer science department boise state university boise id usa drewharris665 u.boisestate.edu abstract as an important extension of symbolic execution se probabilistic symbolic execution pse computes execution probabilities of program paths.
using this information pse can prioritize path exploration strategies.
to calculate the probability of a path pse relies on solution counting approaches for the path constraint.
the correctness of a solution counting approach depends on the methodology used to count solutions and whether a path constraint maintains a one to one relation with program input values.
this work focuses on the latter aspect of the solution counting correctness for string constraints.
in general maintaining a one to one relation is not always possible especially in the presence of non linear constraints.
to deal with this issue researchers that work on pse for numerical domains either analyze programs with linear constraints or develop novel techniques to handle solution counting of nonlinear constraints.
for the string domain however previous work on pse mainly focuses on efficient and accurate solution counting for automata based string models and has not investigated whether a one to one relationship between the strings encoded by automata and input string values is preserved.
in this work we demonstrate that traditional automata based string models fail to maintain one to one relations and propose to use the weighted automata model which preserves the one toone relation between the path constraint it encodes and the input string values.
we use this model to implement a string constraint solver and show its correctness on a set of non trivial synthetic benchmarks.
we also present an empirical evaluation of traditional and proposed automata solvers on real world string constraints.
the evaluations show that while being less efficient than traditional automata models the weighted automata model maintains correct solution counts.
index t erms probabilistic symbolic execution string constraints quantitative program analysis i. i ntroduction symbolic execution se is a path sensitive program analysis technique that assists with finding program defects generating test cases and detecting vulnerabilities .
se traverses each execution path of a program with symbolic input values that represent all concrete inputs of that program.
during analysis se expresses program variables as functions over symbolic values and at each branching point se creates a predicate over those symbolic values and adds it to the path constraint.
hence a path constraint represents the restricted set of concrete input values that can follow that branch.
to test the feasibility of a branch outcome se passes the path constraint to a satisfiability solverto determine whether the newly added predicate is consistent with the old predicates in the path constraint.
one of the valuable extensions of se is probabilistic symbolic execution pse which is a quantitative analysis.
pse computes the probability with which a concrete program execution could follow a given program path.
using these probability values pse establishes a complete order on execution paths which helps with sidestepping the path explosion problem of se.
for example researchers leveraged path priorities to a analyze first less probable paths since testing is more likely to miss them b thoroughly examine most commonly executed code for defects and c establish the reliability of software by comparing the probabilities of successful and failed paths .
similarly to se pse explores program paths but at a branching point pse computes the sizes of the solution sets for the path constraints before the branching point and after it i.e.
after the addition of a new predicate.
the ratio between the latter and the former defines the probability for that branch outcome on that program path.
the fundamental premise of the correctness for such probability calculation is that the solution set of path constraints must maintain a one to one relation with the set of concrete inputs to a program.
when this relation is broken one cannot be certain that pse computes accurate probabilities.
consequently pse might provide false reliability reports or miss critical program defects.
for example for path constraints over numerical domains this one to one relation breaks in the presence of non linear operations since it introduces nonlinear predicates in path constraints.
while for the integer domain this problem has yet to be addressed researchers investigated approaches to compute the size of a solution set for an arbitrary function over real numbers .
thus researchers working on advancing pse for numerical domains acknowledge this problem by either limiting the applicability of their tools to linear constraints or developing new methodologies for solution counting1in the presence of non linear constraints.
besides numerical programs researchers use se to detect security vulnerabilities in string manipulating programs 1we use this phrase instead of model counting since we reserve the term model to discuss symbolic string modeling.
34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symb state x x x x x x x x x x 0inputs solution set void m int x f t x x if x a symb state x x x x y y x y y y 0inputs solution set void m int x f t x x if x b symb state x x x x x x x x x eveninputs solution set void m int x f t x x if x c fig.
.
examples of exact counting a under counting b and over counting c for the integer domain.
such as password verification input sanitization and database queries generation .
in this case se s path constraints consist of expressions and predicates over symbolic strings.
in order to support such analysis several string constraint solvers have emerged.
they use different representations to model symbolic strings for example jsa stranger use automata based representation z3 str s3 s3p use a set of axioms and uninterpreted functions some solvers model them as bitvectors .
with the increased interest in quantitive analysis of string manipulating programs researchers extended string constraint solvers to support solution counting.
for example stranger is extended to a solution counting solver abc and s3p to s3 .
pse for strings uses the solution count of a string path constraint to determine the probability with which concrete executions realize this path.
in this paper we focus on automata based string constraint solvers since previous work on empirical evaluation of java string constraint solvers for se identified that an automata based solver such as stranger or jsa is a better suited for symbolically executing string manipulating java programs.
previous work on automata based solution counting focuses on developing efficient approaches to accurately count the solution set for a symbolic string constraint for a given boundk.
that is counting the number of strings up to length kin the language of a finite automaton.
to do so researchers utilize either generating functions or caching which in addition to pse can be used in different contexts such as quantitative information flow .
the most recent work introduces a multi track automata symbolic string model mt abc that extends the abc solver to enable efficient solution counting for mixed integer and numerical constraints.
to the best of our knowledge pse for strings lacks research on identifying conditions under which the one to one relation between the input string values and the solution set of an automaton is preserved and under what conditions it breaks.
our work aims to fill this gap by stating the problem examining the solution counting accuracy of traditional automata based symbolic string models and proposing the improvement in accuracy with weighted automata models .to do so we extend jsa i.e.
automata based string constraint solver to produce solution counts and compare it to our implementation of weighted automata.
in this work we demonstrate that traditional automata models inherently cannot maintain a one to one relation between the input string values and string constraint solution counts.
this relation either becomes non injective leading to over counting or becomes non surjective leading to undercounting .
our work contributes to the state of the art of solution counting for symbolic string constraints as follows it brings attention to under counting and over counting problems for automata based string models.
it improves solution counting accuracy by employing the weighted automata model to represent symbolic strings.
it verifies the correctness of weighted automata results by comparing the answers with the actual solution counts.
it evaluates accuracy and performance of traditional automata and weighted automata models on real world benchmark.
ii.
o verview to explain under counting and over counting in pse we first demonstrate them on pse over integer variables.
note that under counting and over counting problems differ from under approximating and over approximating solution counts of constraints.
in the former the model used to express path constraints has either a non surjective or a non injective relation with the input values which causes under counting or over counting respectively of the correct solution count.
in the latter the model for expressing paths constraints maintains a one to one relation with the input values but the method used to count the solutions in the model is approximate.
in other words the former is due to poor quality of models used to represent constraints while the latter is due to inaccurate counting techniques.
a. the integer domain consider figure a that shows a diagram of pse s analysis for a simple code snippet.
on the left is the pse s execution tree and on the right shaded in gray are symbolic states for the input variable x. a symbolic state which describes an authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symb state a b 1a a b 2a a a b 4inputs solution set void n string s string s1 f t a a s s.concat a s1 s1.concat a a a aa s s.concat s1 a a aa aaa aaaa if s.equals aaa aa a aaaa a a aaa a symb.
state b b 1b a b 2b ab a b 4inputs solution set void n string s string s1 f t b b s s.concat a s1 s1.concat a b a ba s s.concat s1 b b a ba abba bbaa if s.contains bb b b aa baa aba baba abba bbaa b fig.
.
examples of a under counting and b over counting of the bounded model incoming state into a program statement consists of a symbolic value of xand a path constraint over symbolic variables.
for example before statement x x the variable xhas symbolic value xwith the constraint x .
the inner nodes of the execution tree have bottom and top text lines.
the bottom line is a program statement e.g.
x x .
the text on the top line shown in a bold font is the list of concrete input values reaching that statement and the text in a regular font is the solution set encoded in the corresponding path constraint.
for example the second node with the statement x x has concrete input values and the solution set of the incoming symbolic state is .
the top line of leaf nodes has the same meaning while the bottom one describes the actual in a bold font and computed by pse in a regular font probabilities.
after examining this execution tree we can see that the input values and the solution set match exactly for every node.
upon taking a true branch of the conditional statement pse updates the model for xand computes the probability as 5for the true branch and similarly for the false branch.
in each case the concrete input values and the solution set a one to one relation between them.
now consider the second example in figure b where the second node has a division operation.
to handle a non linear constraint pse introduces a new symbolic variable yand precisely estimate its bounds y .
while such approach works well for satisfiability check it introduces inaccuracy in pse s solution counting since it breaks the one to one relation between the input values and the solution set.
on the entrance to the branching node the input values set has five elements while the solution count of the symbolic constraint y is one.
the relation between those two sets became nonsurjective.
thus the solution set incoming into the conditional statement if x node differs from the input values which causes pse to predict a wrong branch as more likely to be executed.
we call cases when pse has a decreased solution count because two or more elements of the concrete input set map to a single element of the solution set as under counting .
figure c demonstrates another case when pse is unable to handle modulo operation but can over approximate it witheven set.
in this case a solution count of the true branch outcome contains an extra element while the false branch outcome contains all odd values and some even values.
this example demonstrates a case of solution over counting since the solution sets of both branches have more elements than the corresponding sets of the concrete values.
b. the string domain a symbolic string variable can be represented by a finite automaton where the language of the automaton is the solution set of the symbolic variable.
for pse a string symbolic variable is bounded by k which is the bound on the length of strings in its solution set.
therefore if k 2then all strings with length two or less accepted by an automaton comprise the solution set of that symbolic variable.
we call this modeling of symbolic strings i.e.
a possible cyclic finite automaton and a boundk a s bounded .
as pse interprets program statements it not only updates the automaton but also the bound k.f o r example in the case of a concatenation of two strings k increases for character removal in a string kdecreases.
the bounded automata model given alphabet and a input string length bound k we define the bounded b model its initial values and the model s solution count scas definition the bounded model is composed of a bound b nand an automaton a q e q f whereqis a set of states a set of transitions e p x q p q q x q0 qis the start state and f qis a set of final states.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a new symbolic value has ainitwith language l ainit andb k. the solution count is sc b x x l a x b to primarily focus on the ability of an automata model to produce accurate solution counts we consider the most precise solution counting and automata manipulations algorithms.
figure a illustrates how pse computes probabilities with the bounded model.
the diagram has the same layout as the previous examples for the integer domain.
to save some space and omit duplicating information we only depict the symbolic state for svariable since s1has an identical symbolic state for the first two statements.
in this example the initial bound isk and a .
thus s s initial symbolic value is an automaton with only one state which is the start and final state and has a self loop on a i.e.
its language is .
therefore the input variables can hold either string or a .
after the concatenation operation with the string ain the second tree node pse produces a new automaton and increments the bound to .
even though after this operation the input set a does not match the solution set a aa of the automaton the one to one relation is preserved.
after the second concatenation with s1in the third node the set of input values is described as the cross product of the input values for sands1with size four.
however the resulting solution set of the automaton with b 4produces only three strings.
when we apply s.equals aaa predicate pse evaluates the probability of the true branch to while the correct value is .
this is because bounded lost an extra count of the string aaa due to its inability to distinguish between two aaa strings produced by the input tuples a and a .
this type of behavior of the bounded model results in under counting of the solution set.
when we extend the alphabet to a b and assume that input strings can only contain symbol b then the bounded model can also over count the solution set as we demonstrate in figure b .
after the last concatenation operation in addition to the expected a ba 2set of strings the model also introduces two more spurious strings which affect the probability value of the outcome instead of actual probability of for the true path pse computes about .
hence the above examples demonstrate that even though the bounded model for encoding symbolic strings is suitable for se it might cause pse to compute incorrect probabilities.
acyclic automata model we first focus on improving the bounded model to eliminate over counting as shown in figure b .
the reason for over counting is the presence of cycles in the automaton for the bounded model.
after the concatenation operation with another symbolic string value it is impossible to determine whether a given prefix and the suffix of a string is accepted by the concatenated automata individually.
in the case of the spurious string abba the bounded model has no means to enforce that abandba should be accepted by the concatenated automata.
to avoid over counting we can create an automaton that implicitly encodes all strings up to the bound k. we callvoid m string s string s1 1b s s.concat a ba a s s.concat s1 3ba aa ba a void m string s 1a b s s.concat a a ba a s s.delete 2a b if s.contains a f t b b a a b fig.
.
examples of the acyclic model a solving over approximation and b failing on deletion.
this the acyclic model since such automaton has no cycles.
figure a shows the execution tree and symbolic states for sinput variable using the acyclic model for k and a b to encode symbolic strings.
to save space instead of the entire pse tree we depict sequentially its nodes and the symbolic state they produce.
after the method header statement there is the initial acyclic automata for k .
as the diagram demonstrates after two concatenations the resulting automaton encodes exactly four strings which matches the list of concrete inputs.
we define acyclic a model for a given alphabet and an initial bound kas well as its initial values and its solution count sc as follows definition the acyclic model is an automaton a q q f with the same elements as in bounded.
a new symbolic value is ainit with the language l ainit k. the solution count is defined as sc a l a compared to the bounded model acyclic requires more space for its encoding.
for example for the initial symbolic value bounded has only one state for any value of k while acyclic requires k states.
since the automaton of the acyclic model is more likely to have more states than bounded then applying the string operations on the acyclic model would require more time to complete.
that is the pse with the acyclic model would require more space and time to analyze than the pse with the bounded model.
however acyclic uses the same algorithms for method operations and predicates as for the bounded model.
while eliminating the over counting issue of the bounded model the acyclic model suffers with under counting in the presence of string modifying operations similar to delete int s int e as illustrated in figure b .
in our example the delete operation adheres to its java s authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
stringbuffer api if the second argument is greater than the length of the string then the second argument is set to that length and if the first and the second arguments are the same then the string is not modified.
therefore delete operation with s ande on the automaton does not change the string a but changes two other strings.
this action corresponds to the removal of the transition a from the automaton.
after this operation the state is marked as final.
after determinizing the automaton it has two states with the transitions aandbbetween them.
this modification causes two input values andato be represented with one solution a. such scenario leads to under counting in solution counts which results in incorrect computations of the probabilities in the leaf nodes.
thus we need a better automata model that is able to eliminate under counting.
iii.
w eighted automata model modern programming languages provide string apis with non trivial string altering operations such as deletion of substrings.
many of those methods are not injective that is when applied to two distinct strings those methods produce the same output strings which traditional automata cannot distinguish.
to address this deficiency we need to find an automata model able to encode a multiset of strings that is a model that remembers the count of identical strings.
through literature search we found that researchers working in natural language processing image processing and machine learning also require automata that tracks multiplicity values of each string and to do so they use the weighted automata model .
researchers have extensively studied the theory of weighted automata developed essential optimization algorithms such as determinizaiton and efficient data structured for their implementations .
the novelty of our work is in the application of weighted automata to pse for strings.
the main difference between the traditional automata and the weighted automata models is in the labeling of transitions and the final states.
a transition of a weighted automaton is described by a tuple x w where the first element represents the symbol to transition on and the second element is the weight of such transition.
for example a transition with label a indicates that the weight of such transition is two i.e.
there are two transitions between the same states on the same symbola.
each final state of a weighted automaton has a weightwvalue assigned to it.
it indicates that all strings ending on this state appears wtimes in the language s multiset.
the weight of a string defines the multiplicity value of the string and is calculated as a product of the transition weights and the weight of the final state on the string s accepting path.
in the case of a non deterministic weighted automaton the weight of the string is the sum of the weights of all string s accepting paths.
figure depicts two weighted automata with the same multiset language.
for illustration purposes we use superscripts to indicate weights.
in this example the start state 02is also a final state and has the weight value of .
it means that in this automaton s language the empty string appears twice.
to0221 3b2 a2b10222 3b1 a1b1 fig.
.
two weighted automata with the same multiset language b b ab ab compute the weight of string bwe need to add the weights of all its accepting paths in the weighted automata.
in our example each of the weighted automata has only one path from the state 02to the state 21with the transition weight of for the first one and from the state 02to the sate 22with the transition weight of for the second one.
this results in and1 weights respectively.
the weight of stringab is computed as 1for the first automaton and as1 2for the second one.
formally a weighted automaton is defined over a semiring s s 0 1 where the set srepresents the weight values are the addition and multiplication operations respectively defined on s and 0 1are the identity elements for those operations.
a semiring enforces distributivity of multiplication over addition but has no additive inverses.
now we present a formal definition of a weighted automaton.
definition a weighted automaton aover a semiring s i s an tuple a q e q f whereqis a set of states q0 qis the start state f qis a set of final states eis a set of weighted transitions p x w q p q q x w s and f sis a final states weight function.
for a given string x x0x1...xnaccepted by athrough a pathp q0 q1 ... q n such that qn f the weight of xis calculated as follows wt p qn circlemultiplydisplay i nwi qi xi wi qi e the behavior of a weighted automaton for a given string wis defined as following a x circleplusdisplay pforxwt p depending on a choice of the semiring a weighted automaton can calculate different quantitative properties.
thus in the case of traditional automata the choice of semiring is the ringb b true false that only allows deciding the acceptance of x but ensures useful properties of traditional automata.
for some optimization algorithms such as determinization a semiring must be a weakly divisible semiring where all non 0elements have inverses.
since applying optimization algorithms are essential for weighted automata applicability in our implementation we use the positive rational numbers q ass which makes q q a weakly divisible semiring.
a. properties and operations for weighted automata before we describe how we apply the weighted automata for pse we briefly discuss weighted automata unique properties for general semirings and for our choice q. first authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
as demonstrated in not all non deterministic weighted automata have a deterministic equivalent.
however for qa non deterministic automaton has its deterministic equivalent.
second as illustrated in figure there is no unique minimal deterministic automaton for a given string multiset.
however if a weighted automaton is defined over a weakly divisible semiring such as q then this uniqueness property is preserved through a weight pushing algorithm .
weighted automata are also closed under traditional operations such as union concatenation kleene closure and intersection operations.
however the complement operation deserves a special discussion as it is not defined for an arbitrary weighted automaton since unlike rings semirings do not have additive inverse i.e.
circleminus.
for traditional automata that are defined over the ring ba complement operation is defined.
but for our application of weighted automata over q w e cannot define a positive additive inverse in q .
for example consider a value n nthat describes the multiplicity number of a string x then it is unclear what would be the meaning of complementing number of n. fortunately a string solver does not require the explicit definition of the complement operation.
solvers with traditional automata use the complement operation to compute the difference of two automata which in its turn used to implement complex string methods such as the negation of contains string s .
as shown in a difference operation a1 a 2can be defined for a weighted automaton a1 and a traditional automaton a2.
thus before applying the difference operation on two weighted automata we must change a2to a traditional automaton by setting all its weights to one which is an inexpensive operation o f e .
however the implication of this simplification is potential undercounting of solutions if a2encoded strings with multiplicity of greater than one.
b. the weighted automata model a pse string solver consists of two parts an underlying model for representing a symbolic string and a collection of algorithms for symbolic string manipulations.
since the presence of cycles results in spurious strings as show in figure b we only consider the acyclic weighted automata model w and define it as follows definition the acyclic weighted model is defined as a weighted automaton a q e q f overqwith elements described in definition and an initial bound k. a new symbolic value is ainit with the language l ainit kwith the string multiplicity set to one to define a uniform distribution of input values.
the solution count is sc w circleplusdisplay x l a a x in order to use the weighted model in a string constraint solver we need to define a set of transfer functions that imitate the effects of java string apis on weighted automata.
commonly such transfer functions are defined using classicalalgorithm an transition between states pandqina function efreetransition p q a if p prime x w p ethen for all p prime x w p edo w prime w ifp fthen w prime w prime p end if e e p prime x w prime q end for else for all q x w q prime edo w prime w ifq fthen w prime w prime q end if e e unionmulti p x w prime q prime end for ifq fthen ifp fthen p p q else f f p p q end if end if end if end function automata operations such as union intersection negation and concatenation.
previous research on weighted automata defines these classical operations except negation on weighted automata .
one commonly used operation in modeling transfer functions is adding an transition between two states.
those transitions are later removed by transition removal algorithms.
similar to previous approaches we create an algorithm that models an transition between two states without introducing transitions hence eliminating a need for removal algorithm.
algorithm shows the pseudocode of our implementation.
basically it considers two main cases when the from state phas incoming transitions and when it does not.
in the first case the incoming transitions to the statepare copied to the incoming transitions of qand their weights are adjusted depending on whether pis a final state or not.
in the second case the outgoing transitions of qare copied to the outgoing transitions of pand their weights are adjusted depending on whether qis a final state.
also pis set as final state and its weight is recalculated.
the operation unionmulti is defined as follows e1 unionmultie2 p x w q p x w q e1 p x w prime q e2 or p x w q e2 p x w prime q e1 p x w q p x w q e1 p x w q e2 w w1 w2 in addition our transfer functions also use the operation that converts a weighted automaton ato a regular automaton a by setting weights in edges and in accepting states to one.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
that is a q e q0 f where s f s e p x q p w q e .
below we detail definitions of transfer functions that model java string apis.
our implementation of the weighted solver uses algorithm and the intersection algorithm of for weighted automata and the negation algorithm for traditional automata.
for an unary automata operation we assume it is applied to a1 q1 e1 q01 f1 1 .
binary automata operations also uses a second automaton a2 q2 e2 q02 f2 2 .
the result of an operation is a new automaton ar.
replace char a char b ar q1 er q01 f1 1 where er e p a w q e unionmulti p b w q p a w q e tolowercase lety be a set of upper case symbols and x be a set of lower case symbols and l y x. then ar q1 er q01 f1 1 where er e p y w q e y y unionmulti p l y w q p y w q e concatenate ar qr er q01 fr r is defined in two steps qr q1 q2 er e1 e2 fr f1 f2 p f1 p prime x w p e1orq02 f2 r s braceleftbigg 1 s ifs q1 2 s ifs q2 p f1apply efreetransition p q02 qr alg.
fordelete andsubstring operations please refer to our implementation2.
in order to model java string api complex semantics for those methods the transfer function algorithms are somewhat intricate.
in general they require first to inflate an automaton by requiring that for paths up to certain length all incoming transition to a state should be from the same state.
the algorithms traverse those paths delete some transitions and add transitions.
predicate methods modify a1differently depending whether they are evaluated to true of false.
therefore we define the resulting automata for each of those cases at cfor true andaf cfor false.
isempty leta be an automaton with l a 1 then at c a1 a af c q1 e1 q01 ff c 1 where ff c f1 q01 .
equals at r a1 a2andaf r a1 a2 .
eliminating denominators in weights.
function normalize a q reversebsfordering q whileq negationslash do p head q deqeueu q d for all p x w p prime edo d d denominator w end for ifp fthen d d denominator p end if w prime leastcommonmultiple d ifp fthen p p w prime end if for all p x w p prime edo w w w prime end for for all p prime x w p edo w w w prime end for end while end function contains let the length of longest string accepted by a1iskand defineakto be an automaton with l ak k then at r a1 aka2akandat r a1 aka2 ak to improve the efficiency of weighted automata previous work provides optimization algorithms such as removal determinization and minimization algorithms.
the first two algorithms are more complex than for traditional automata since the weight of the transitions and the final states should be accounted for.
the weighted minimization algorithm is similar to the traditional one because it interprets each pair of a symbol and a weight x w as a single label.
we use determinization minimization as in and our weight normalization algorithm see algorithm to improve the performance of the weighted solver.
this algorithm differs from the weight pushing algorithm presented in which moves the weights of each path as much as possible toward the initial state.
the objective of the normalization algorithm is to eliminate denominators.
the basic idea is to propagate backwards from the final states to the start the denominators of rational weights while updating weights of unexplored transitions.
iv .
e v aluation each automata model we introduce in this paper has its advantages and disadvantages.
bounded represents a set of strings more efficiently but produces less accurate solution counts.
compared to bounded acyclic requires additional states to encode a set of strings but it can handle concatenations with better accuracy than bounded.
yet for other operations acyclic and bounded tend to under count.
we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
expect weighted to be the most precise but at the same time less efficient as algorithms for implementing string operations and automata optimization have to reason about weights of transitions and final states.
the goal of our evaluation is to compare these three automata models by answering the following questions how do the execution times of the models compare to each other?
how accurate is solution counting for these models?
how do inaccurate solution counting of these models influence the correctness path probabilities calculations?
how well the models scale to real string benchmarks?
in order to answer our research questions we conduct two kinds of evaluations one on a set of synthetic benchmarks and another on a set of real string constraint benchmarks.
while in both experiments we evaluate performance and precision we use the former to mainly test the correctness of the weighted automata model implementation and the latter to obtain scalability data.
below we briefly described our implementation of automata models and then we present the evaluation data and discuss the results.
a. automata models implementation we implemented bounded and acyclic models by extending java string analyzer jsa version .
.
which is implemented in java.
we modeled each java string operation with the most precise algorithms available for this classic automaton as described in .
jsa has a highly optimized representation of automata and efficient implementations of the core automata algorithms such as determinization and minimization.
since weighted automata cannot be simply extended from jsa we implemented in java the weighted model and its solver from scratch.
our implementation also includes essential performance optimization algorithms such as determinization minimization and weight normalization as described in the previous section.
from java string api we implemented the following string predicates isempty contains andequals and the following string operations concatenate delete int start int end substring int start int end replace char oldchar char newchar tolowercase all of which occur in the real string constraint benchmarks we used in our evaluation.
since our work primarily investigates the accuracy of the models in the context of pse we implemented a bruteforce algorithm to compute solution counts.
comparing to the advanced work on efficient solution counting algorithms this implementation is straight forward and computes accurate solution counts.
for bounded it traverses automata paths up to depth k and for acyclic and weighted it traverses the entire automaton and computes their solution counts as we presented in their definitions.
even with our brute force implementation the time spent counting solutions is negligible comparing to the time spent analyzing string constraints.in addition to the three automata models we also implemented a concrete solver that produces accurate solution counts of string constraints.
we require the correct solution counts to test our implementation of the weighted solver.
the concrete solver explicitly tracks the set of input strings and invokes java s string apis for operations or predicates that appear in the string constraint.
for example to represent a symbolic string with k and a b the concrete solver creates a map and populates its keys with strings a b aa ba abandbb and values with the frequency with which each string occurs that is it models a multisite of strings.
we compute the solution count as the sum of all map s values.
b. synthetic benchmark for correctness evaluation since the concrete solver explicitly tracks the set of string we must limit the alphabet size the bound kand the complexity of strings constraints for that solver.
in particular a string constraint benchmark should have a small alphabet size and a small initial bound.
moreover a string constraint should have no more than two concatenation operations of symbolic strings since the concatenation operation of two symbolic strings dramatically increases the number of string the concrete solver has to track.
thus processing symbolic inputs with similar characteristic as in the rockyou1k data set k 16and i.e.
all ascii characters would be impossible for the concrete solver.
a realistic benchmark with the aforementioned parameters is not available.
for this reason we systematically generated synthetic benchmarks which have been proven to be effective in testing compiler correctness and finding defects in symbolic execution engines .
we generated benchmarks with the total of non trivial string constraints.
each benchmark contains sequences of string operations and appends each of them with one of the three predicates.
the bound kvaries between two and three and the alphabet size is three except for the benchmarks containing tolowercase operation which is set to six in order to include the upper and the lower cases of the original three alphabet symbols.
we also ensure that no more than three concatenation operations of symbolic strings occur in a constraint otherwise the concrete solver times out.
parameters for operations and predicates are randomly chosen from their valid values.
first we present the execution time experiments as the ratio of the solver s execution time to the concrete solver execution time.
table i captures the count of ratio in five intervals.
the first interval contains the number of constraints for which an automata solver performs faster than the concrete solver i.e.
the ratio values are less than one.
the second interval has counts for ratios between and that is an automata model s execution time is comparable to the execution time of the concrete solver.
the next three columns represent counts for moderate significant and large slowdowns comparing the concrete solver.
as we expected bounded has an overall better performance it executes faster on the largest number of string constraints and has executions with large performance slowdowns.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i time performance for correctness experiment time ratio bounded acyclic weighted bounded acyclic weighted0.
.
.
.
.
automata modelssolution count ratio fig.
.
solution accuracy ration for each automata model next we present data to demonstrate the solution counting accuracies of each model comparing to the concrete one.
we focus on the solution count for a string constraint incoming into a predicate that is the solution count before a branch since this number reflects the effect of string operations on an automata model.
we compute the ratio between value computed by automata solvers and the values produced by the concrete solver i.e.
the correct values.
figure iv b depicts the results as box plots.
we see that our implementation the weighted solver is correct since all ratio values are exactly one.
as we expected bounded both over approximated and under approximate depending on operations present in a string constraint.
also as we anticipated acyclic always under approximates and never exceeds the ratio value above .
overall on the set of synthetic benchmarks both bounded and acyclic models tends to undercount that value by about1 .
the last set of experiments investigate what effects those inaccurate counts have on the computations of local and global probabilities since both kinds of probabilities are used to prioritize path explorations.
the local probability is computed by dividing the solution count of the path constraint after a branch by the solution count of the path constraint before the branch.
to compute the global probability of a path pse divides the same number by the total number input strings to a program which is the same value for all path constraints.
table ii presents that data for accurate branch predication that we separated in five different groups.
the first group miss tells whether an automata solver predicted a different branch branch is more likely to be executed than what the concretetable ii accuracy ev aluation for correctness experiment .
prob.
miss exact local probability bounded acyclic weighted global probability bounded acyclic weighted solver predicted.
that it the automata solver missed the correct branch prediction.
the second group exact contains the number of instances when an automaton solver calculates correct probabilities.
the next three groups show ranges of absolute differences between the probabilities of an automata solver and the concrete solver.
as data in table ii demonstrates the weighted solver always computes the exact probabilities.
bounded mispredicts four branches locally while for the rest predicting correct outcomes with exact slightly deviating and moderately deviating for the actual probability values.
for global probabilities the number of mispredicted branches increases and for correctly predicted branches the numbers probabilities with moderate and highly deviated from the actual values increase.
the acyclic model follows a similar trend with nosignificant differences.
the data show that branch misprediction does occur in the traditional automata models and has a stronger presence in global probabilities.
moreover for the global probabilities the magnitude of the absolute difference between their computed and correct value can affect the order in which program paths are explored by pbs.
overall the study on synthetic benchmarks gives us confidence that the weighted solver implemented correctly and hence we can use its solution counting as the correct value in our larger study on real benchmarks.
moreover this evaluation shows that the traditional automata models commonly compute incorrect solution count and it can lead to incorrect branch predictions.
next we perform similar experiments but on a real program benchmarks on three automata based solvers.
c. real benchmarks for performance and scalability evaluations we use real benchmarks from previous work where the authors used dynamic symbolic execution to collect string constraints from eight real java programs that extensively use string apis.
each dynamic execution run results in a benchmark containing several string constraints.
next we filter constraints in benchmarks by the method implemented in the weighted solver and remove a sequence of operations that do not end in a predicate.
these steps produced bea hcl jhp jxm mqg and ncl benchmarks with the total of constraints.
for each benchmark we set a realistic alphabet that contains both upper and lower case symbols from the english alphabet authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
bounded acyclic0.
.
.
.
.
.
automata modelssolution count ratio fig.
.
solution count accuracy ratio.
and augmented it with special characters if the benchmark uses them.
hence the majority of benchmarks have the alphabet size between and .
with such large alphabet and our observations from the synthetic benchmark evaluations we limited values for the initial symbolic string bound kto .
with the timeout threshold set to one hour to processing a single benchmark both bounded and acyclic were able to compute constraints for each of the bound values.
however the weighted solver was able to compute and constraints for kvalues and respectively.
since this is our initial implementation of the weighted solver it definitely has many opportunities for optimizations of its algorithms or one can use more mature implementations such as vcsn which is written in c and uses efficient data structures and algorithms proposed in .
we use the similar metrics to evaluate performances and accuracies of three automata solvers for each bound k. only for the performance ratio calculation we use the execution time of the bounded solver and for the accuracy we use the solution counts and probabilities of the weighted solver in place of the concrete solver.
even though bounded and acyclic are able to compute all constraints for each bound value we present data only for the constraints that weighted was able to process.
we report in table iv the execution time ratios of acyclic and weighted solver to the bounded model separated into the same intervals as the data for the synthetic benchmarks.
we can see that with the increase of kacyclic s execution time does not scale as well as bounded.
the time ratio values for weighted demonstrate how dramatically its execution time increases as kgrowths.
the accuracy of solution counting is shown in figure .
note that box plots for both bounded and acyclic are the same since real benchmarks do not have concatenation of two or more symbolic string values both solvers compute the same solution counts before predicates.
once again the data demonstrates that traditional automata models are unable to preserve accurate string counts.the data for the last experiment is presented in table iv.
again the bounded solver misses more branches than the acyclic solvers.
one might find it surprising since as demonstrated in figure both solvers produce the same solution count.
the reason is that the bounded solver tends to perform inaccurate predicate operations that allow the same strings to be propagated to both branch outcomes .
we can also observe that with the growth of kthe number of mispredicted branches decreases.
this is because predicates in benchmark constraints use a concrete string in their arguments for example s.equals p .
as the number of strings increases withk the proportion for strings that equal to p decreases thus the correct probabilities computed by weighted and two other models approach .
however the number of exactly calculated probabilities decreases with ksince the larger its value the larger is the difference in solution counts.
as before inaccurate computations are more prevalent in global probabilities.
using the presented data we now can answer our research questions.
first depending on the type of constraints and k value some solvers might run faster than another.
however overall we found that the bounded solver outperforms other solvers due to its smaller encoding size with the acyclic solver being quite close to it.
as expected the weighted solver has the worst execution time but the current implementation has room for improvement.
moreover both the bounded and the acyclic models scale well with the increased symbolic string length while the scalability of the weighted model deteriorate as kincreases still it has a much better scalability than the concrete solver.
for solution counting accuracy the bounded solver can both over approximate and under approximate the accurate solution counts the acyclic solver under approximates the correct values and the weighted model always computes the exact counts.
however in a presence of constraints that use concrete string values both bounded and acyclic able to compute correct counts.
for our benchmarks the affects that solvers and their incorrect solution counting have on probability calculations is rather small but still present for certain type of constraints.
for local probability calculations the most important aspect is an incorrect identification of more likely branch to be taken.
usually such error is small about .
for bounded and even less than .
for acyclic.
however such effect is stronger when calculating global probabilities because for bounded up to of calculated probabilities have incorrect values which is important since global probabilities are used to create a total order on program paths.
we expect that on benchmarks that use concatenations of several symbolic strings or use symbolic values in predicates those errors would be more significant.
v. r elated work our work relates to several bodies of work.
first of all similar to work presented in our research investigates solution counting in an automaton.
while the previous efforts focus on efficient and accurate solution authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii time performance for real string constraints .
time ratio kbound acyclic weighted table iv accuracy ev aluation for real string constraints .
prob.
missed exact kbound local probability bounded acyclic global probability bounded acyclic count for a given automaton and a bound k or handling mixed string numerical constraints our work investigates how well automata based models can preserve the relation between the input variables and the solution count of an automaton which is an essential property of pse s path constraints.
similar to kausler et al.
where the authors measured accuracy of string constraint solver in the context of se our work evaluates accuracy for an automata based string constraint solver in the context of pse.
since the authors empirically demonstrated that a string constraint solver can misidentify an unsatisfiable branch outcome as satisfiable in se it was not surprising for us to find that automata based models miscalculate branch probabilities in pse.
our work addresses a problem similar to the one discussed by borges et al.
in for the domain of real numbers.
instead of approximating non linear functions that appear in pse s path conditions the authors employ numerical analysis techniques to compute their volumes.
by so the authors enforce a one to one relation between the input values and the solution set of a path constraint for real numbers.
unlike borges et al.
we focus on enforcing a one to one relation for symbolic strings.
we also connect our evaluation approach with recent on work on testing symbolic execution engines by kapus et al.
.
in their work researchers compare the results of concretely executed paths with data computed by se for the same paths.
this approach reveals many defects in implementation of symbolic engines.
similar to their work we compare the probability values computed by pse with the probability values produces from the actual concrete runs.
instead of finding implementation defects in pse we detected the limitations of commonly used automata based string models to maintain a one to one relation between the input values and the solution set of an automaton.
vi.
c onclusion and future work we showed that traditional automata models are unable to preserve one to one relation with the inputs strings.
the bounded automata solver can both over and under approximatethe count while the acyclic solver under approximates and the weighted solver permits accurate solutions counting.
while our implementation of the weighted automata scales much better than the explicit string counting it is still slow to handle larger sizes of symbolic strings.
depending on the type of constraint bounded and acyclic solvers can compute incorrect probabilities which are more prevalent in global probabilities calculations for which global probabilities is also more sensitive to.
while we showed that using regular automata based models can lead to incorrect orderings in paths exploration in local and even more significant in global orderings the question remains open whether those incorrect ordering have an impact on pse applications.
thus in the future we plan to evaluate whether improvements in accuracy enable pse based verification tools to detect defects in string manipulating programs more efficiently.
in addition we plan to compare the accuracy of our implementation to the state of the art string string solution counting solvers abc and s3 .
to do so we first would like to improve the efficiency our weighted solver and explore avenues of reducing the alphabet size either from program requirements or and from a light weight program analysis.
since our experiments show a trade off between accuracy and efficiency of automata models for the future work we also plan to include the classification of potential string constraint into categories.
for example for some type of string constraint the bounded model would be more efficient yet produce accurate results.
however if there are possibilities that a constraint contains concatenations of two symbolic string values then using acyclic perhaps would be a better idea.
for more complex constraints especially when arguments of string method contain another symbolic values using either of traditional models would lead to incorrect probabilities calculations.
vii.
a cknowledgments this work supported by the us national science foundation under award ccf .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.