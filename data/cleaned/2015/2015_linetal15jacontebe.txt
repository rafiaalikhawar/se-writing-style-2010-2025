jacontebe a benchmark suite of real world java concurrency bugs ziyi lin darko marinovy hao zhongz yuting chenz and jianjun zhaoz school of software shanghai jiao tong university china ydepartment of computer science university of illinois at urbana champaign usa zdepartment of computer science and engineering shanghai jiao tong university china flinziyi zhonghao chenyt zhao jj g sjtu.edu.cn marinov illinois.edu abstract researchers have proposed various approaches to detect concurrency bugs and improve multi threaded programs but performing evaluations of these approaches still remains a substantial challenge.
we survey the existing evaluations and find out that they often use code or bugs not representative of real world.
to improve representativeness we have prepared jacontebe a benchmark suite of confirmed concurrency bugs from popular open source projects supplemented with test cases for reproducing buggy behaviors.
running three approaches on jacontebe shows that our benchmark suite confirms some limitations of the three approaches.
we submitted jacontebe to the sir repository a software artifact repository for rigorous controlled experiments and it was included as a part of sir.
keywords java concurrency bugs evaluations benchmark suite sir jacontebe i. i ntroduction concurrent code is gaining much attention with the growth of multi core computing.
however developing concurrent code remains challenging and error prone because threads are nondeterministically scheduled and can inappropriately interact.
concurrency bugs are prevalent e.g.
as reported by lu et al.
.
because concurrency bugs decrease the quality of software researchers have proposed various approaches to detect such bugs.
section vi presents an overview of these approaches.
although these approaches can successfully detect some concurrency bugs their effectiveness in practice is largely unknown.
in typical evaluations done by the researchers proposing an approach the code or bugs used may be selected with a bias and not representative of the real world code or bugs.
in addition it is difficult to compare these approaches because their effectiveness may highly depend on the selection of concurrency bugs.
to address the evaluation problem researchers have used various benchmark suites.
section ii surveys four suites in detail.
typically a benchmark suite consists of concurrency bugs and corresponding test cases.
researchers can run different approaches on the benchmarks to evaluate the effectiveness.
while several benchmarks have been used a key concern is whether these benchmarks fully reflect the characteristics of concurrency bugs in the real world.
following sim et al.
luet al.
proposed five guidelines for preparing benchmark suites representative diverse portable accessible and fair.
in particular representative means both code and bugs should be real ones.
the existing benchmark suites do not fully satisfy these guidelines especially the representative guideline as discussed in section iv c. trying to directly use real softwaresystems with no extra artifacts to evaluate the effectiveness is hard.
one main reason is that the complexity of real world software systems makes it difficult to establish whether the reported issues are true positives especially for concurrency bugs much extra effort is required to tell true bugs from various false positives.
in this paper we first survey the existing benchmark suites for java concurrency bugs and then introduce a new benchmark suite called jacontebe from java concurrency testing benchmark .
jacontebe currently contains java concurrency bugs taken from real world code.
jacontebe can help evaluate approaches for detecting concurrency bugs.
first jacontebe allows to evaluate whether an approach is capable of finding the bugs researchers can run novel approaches on jacontebe to evaluate their effectiveness.
second it allows to evaluate whether an approach is practical for real bugs although an approach may work well on seeded bugs it may be insufficient to deal with real bugs because real bugs may have different characteristics.
third it allows to compare the strengths and weaknesses among similar approaches it is important to properly compare and evaluate different tools on real software bugs.
the paper makes the following contributions we present a survey of the existing java concurrency benchmark suites and investigate the evaluations of approaches for detecting java concurrency bugs.
we have observed that the existing benchmark suites do not contain many real world bugs although researchers have the desire to evaluate their work with real bugs.
the gap between real bugs and evaluations is not fulfilled yet.
we build up jacontebe a new benchmark suite for java concurrency bugs.
the initial version of jacontebe contains confirmed real world concurrency bugs from open source projects.
we submitted jacontebe to the sir repository of software artifacts for rigorous controlled experiments and it was included at .
we view jacontebe as ongoing work and plan to collect more bugs in the future.
these bugs can be classified into three types and in particular the subtype of java communication deadlock is less studied in the literature.
for each bug we provide detailed documentation that describes the root cause and buggy interleaving of the bug and we also implement a test case and a testscript so that other researchers can easily reproduce the buggy behavior.
we run jacontebe test cases on three approaches for detecting java concurrency bugs the java pathfinder jpf research tool the rv predict commercial tool and our implementation of the checkmate approach .
the results show that jacontebe can uncover the capability of the existing approaches and can help confirm some of their known limitations in tackling real applications.
the rest of this paper is organized as follows.
section ii surveys the existing benchmark suites and evaluations of approaches to detecting java concurrency bugs.
section iii presents our new jacontebe benchmark suite.
section iv evaluates jacontebe.
section v discusses some results and potential future work.
section vi describes related work and section vii concludes.
ii.
s urvey of benchmark usage in this section we survey first the existing java concurrency benchmark suites and then how these suites and other programs are used in papers on detecting java concurrency bugs.
our survey identifies some limitations in the existing evaluations and lists the characteristics of a desirable benchmark suite.
a. existing benchmarks many evaluations use some of the programs from the following four java concurrency benchmark suites.
java parallel grande jpg is the parallel version of the java grande benchmark suite designed for evaluating parallel java applications for high performance computing.
jpg contains applications.
although not initially designed for bug detection it became popular and many approaches for detecting concurrency bugs used some applications from jpg.
dacapo is a benchmark suite of real world java applications that require non trivial memory loads.
there are two releases of the benchmark suite version with applications and version with applications.
as for jpg dacapo was not originally designed for bug detection and does not explicitly list any concurrency bugs.
the ibm benchmark suite contains buggy java concurrent programs and covers types of concurrency bug patterns .
however of the buggy programs in the ibm benchmark suite are from undergraduate students assignments and rather small .
are open source but only of them are real applications and the others are small programs simulating concurrency behaviors.
program is a commercial product joscar from aol messenger.
the software artifact infrastructure repository sir is a repository of software related artifacts that supports rigorous controlled experimentation with program analysis and software testing techniques.
before we contributed jacontebe to sir sir contained java concurrency bugs collected from different sources including from the ibm benchmark suite and bugs from real applications.
2014fig.
.
surveyed papers distributed by publication year.
table i. r esearch topics of the surveyed papers .
research topic description papers atomicity detect atomicity violations atomic set serializabilitydetect atomicity violations and races3 concurrency debugging debug concurrency bugs concurrency testingtechniques and frameworks for testing concurrency bugs8 deadlock detect deadlock bugs nullpointer dereferencedetect nullpointer bugs in concurrent code1 race detect data races after we investigated the existing benchmarks we came to the following observation observation the existing benchmarks typically contain only several real world concurrency bugs.
b. programs used in evaluations we perform a survey to find out what programs are used in empirical evaluations of published papers.
we focus on five most relevant conferences ase fse icse issta and pldi.
we search dblp1with the query deadlock race datarace concurren atom multithreaded thread preemption parallel venue to find all candidate papers published in each conference between and .
we start from because the oldest well known benchmark suite jpg was published in .
we get candidate papers in total.
after filtering out papers that are not related to java or concurrency bug detection we are left with papers.
to reduce our effort for inspecting these papers we randomly sample only papers published before but we select all papers published since .
we inspect in detail papers from ase from fse from icse from issta and from pldi .
fig.
shows the distribution of the papers by publication year.
these papers are divided into seven different research topics related to concurrency bug detection as shown in table i. we investigate what programs are used in evaluations in these papers.
to simplify the analysis we ignore different count by paper usage count by research topic102 fig.
.
usage of programs in surveyed papers.
the x axis represents the number of papers in which a program was used blue bars and the number of topics that the papers belong to yellow bars .
the y axis represents the number of programs.
jpg dacapo ibm sir count by paper usage count by research topic fig.
.
usage of benchmark suites in surveyed papers.
versions and bugs from the same program project2in the survey and count only the number of different programs projects used in each paper.
for example if a paper uses some code from apache pool .x for one bug and some code from apache pool .x for another bug we count that as one apache pool project if another paper also uses some code from apache pool .x for two different bugs we count that as two papers using apache pool once each.
these papers altogether use programs in their evaluations.
fig.
shows that about two thirds out of of the programs are used in only one paper and on one research topic out of meaning most programs are not shared among evaluations done by different researchers.
jdk and raytracer are shared the most by respectively and papers that cover all seven research topics.
observation researchers often follow an ad hoc process to choose programs for evaluation.
many programs used in the evaluations belong to some of the four benchmark suites jpg dacapo ibm benchmark and sir benchmark.
as fig.
shows jpg is the most widely used and its programs appear in out of .
papers that cover all seven research topics.
note that a paper may use programs from multiple benchmark suites.
of the programs used are from jpg are from dacapo both versions and are from the ibm suite and are from sir several of these programs are in multiple suites programs are in both jpg and ibm while programs are in both ibm and sir.
the other programs do not belong to any well known benchmark suite.
2we use the terms program and project interchangeably but intuitively one should distinguish small programs from real projects.observation jpg has been the most popular benchmark suite although it was not designed for concurrency bug detection and is rather outdated.
we have found out that out of benchmark programs are from real world projects.
object relation mapping tools and web server containers are most represented.
this fact suggests that researchers have the desire to use realworld programs in their evaluations.
however many of the real world programs are not shared among evaluations and researchers only programs appear in two or more papers and in two or more research topics.
one main reason is that when evaluating an approach proposed to find only some bugs researchers prefer to select the benchmark programs that are related to their target bugs.
when the target bugs differ researchers tend to select quite different programs in their evaluations.
although this allows researchers to focus on their target bugs the results can become narrowly applicable and hard to compare.
to fully evaluate the effectiveness there is a strong need for a more comprehensive benchmark suite.
observation real world programs are preferably used by researchers but are often selected with bias.
iii.
t hejacontebebenchmark suite in this section we present jacontebe a benchmark suite we collected to allow more comprehensive evaluations of approaches for detecting concurrency bugs.
the buggy programs in jacontebe are from popular open source systems and confirmed by developers.
a. overview we prepare jacontebe following lu et al.
s five guidelines .
in particular for representativeness and accessibility we collect reported and confirmed bugs from real opensource projects for diversity we collect bugs that cover various bug types and different importance for fairness we choose bugs from projects that are shared among different papers and research topics so they are more general and for portability we choose bugs that are portable to different platforms except two bugs triggered only on windows.
we use the following process to collect concurrency bugs.
first we select from the open source projects that have been used in prior evaluations as described in section iii b. then for each project we search its online bug database for bug reports related to concurrency bugs as described in section iii c. finally for each non duplicate bug report that we can reproduce we create a test case that allows triggering buggy behavior usually deterministically on every run as described in section iii d. in total the initial version of jacontebe contains concurrency bugs from open source projects.
it covers three types of concurrency bugs races e.g.
low level data races and high level atomicity violations deadlocks e.g.
resource deadlocks caused by cyclic locks and communication deadlocks caused by missed synchronization signals and java memorymodel related bugs caused by inappropriate assumptions e.g.
bug 1test case test script bug descriptionlibraries ...derby pooltesting framework dbcp bug bug n...fig.
.
overview of the jacontebe benchmark suite.
about synchronization activities and reordering of statement executions among threads .
fig.
shows the organization of jacontebe.
it contains one common directory with a testing framework and jar libraries shared across the entire benchmark suite and one directory for each project with concurrency bugs currently such directories .
each project directory has several jar libraries shared by its bugs and a subdirectory for each bug.
each subdirectory contains the following a java test case to reproduce the buggy behavior a shell script to set test parameters and run the test a description of the bug and its root cause b. selecting projects it is challenging to sample representative open source projects from their large population.
for example github3 hosts more than 100k java projects and apache4hosts over java projects.
furthermore many projects are added each year with the rapid growth of open source communities.
however as we have observed from our survey some projects5have been used more often for evaluations.
we simply select from those projects that have been already used instead of creating new rules to find out new projects.
we use two requirements for selecting candidate projects a candidate must have been used in evaluations on two or more research topics.
this filters rarely used projects and reduces the bias towards certain approaches on specific research topics.
of programs from our survey this requirement filters out about two thirds leaving .
a candidate must be an open source well maintained project with real bugs.
this ensures that the selected projects have real bugs instead of injected or artificial ones and equally importantly it allows us to access the bug database to retrieve sufficient information to document and reproduce the concurrency bug.
this requirement filters out raytracer one of the programs most widely used in evaluations but which is an artificial program written by researchers for benchmarking and not actual code written by developers and cache4j the popular real world benchmark that has stopped updating since and has no bug database.
this requirement further filters out about three quarters of candidates leaving .
5while we also called them programs before as some are rather small we will call them projects in the remainder as we select larger real projects.table ii.
p rojects in jacontebe.
project papers topics in survey bugs in jacontebedescription apache dbcp database connection pool apache derby relational database apache groovy 6dynamic language for jvm openjdk java development kit apache log4j logging library apache lucene search library apache pool object pooling api we select out of apache dbcp apache derby apache groovy openjdk apache log4j apache lucene and apache pool for the initial version of jacontebe.
as mentioned previously we omit version differences of the same project but in jacontebe we keep openjdk6 and openjdk7 separated because their bugs can be reproduced only with different versions of the java environment.
table ii shows some details of these projects with openjdk6 and openjdk7 merged together in this table because some papers do not clearly mention which version of openjdk is used in the evaluation.
for each project we tabulate the number of papers that used the project in evaluation and the number of research topics that those papers cover the number of bugs prepared in jacontebe note that this is completely independent of the number of papers and topics but by chance the numbers end up similar and a brief description.
openjdk is the most widely used real world project in our survey and is also the biggest contributor of bugs .
out of for jacontebe.
c. searching for concurrency bugs while we selected all the projects for jacontebe from the surveyed papers we could not identify all the bugs because the papers often did not give the bug ids or urls.
therefore we decided to search for concurrency bugs in the bug databases of all the projects.
more specifically we search each bug database with the keywords concurren atom deadlock thread race and synch .
this simple search returns many false positives e.g.
thread also matches threaded or threading two words that are often used in the discussions of bug reports even when not for concurrency bugs.
of issues returned by our queries we manually confirm as related to concurrency bugs.
we select bugs for jacontebe using these requirements the bug should not be a duplicate.
we ignore bug reports which are marked duplicate or clone of in the bug database.
the bug should be reproducible i.e.
the bug report provides sufficient information to reproduce the bug e.g.
stacktraces and thread dumps when the program crashes or even better a test case for triggering the buggy behavior the necessary resources to reproduce the bug are available e.g.
groovy is a deadlock bug from version .1beta but neither source code nor binary release of that version is available for download any more therefore it is not easily reproducible.
the bug should be relevant.
every real bug represents some problem triggered under certain conditions but some bugs have little impact on the system or are only triggered under very specific conditions that are not common and may not be worth fixing.
to identify these bugs that may not be representative we check for the report labeled won t fix or having a similar description in the discussion and or the priority being marked as the lowest level.
finally we collect bugs for our benchmark suite.
these bugs were reported between and .
most .
out of are important marked as blocker critical major or some equivalent priority value in the bug report and the others out of are less important marked as minor or some equivalent value in the bug report .
bugs major and minor have not been fixed until now.
the average fix time for all fixed bugs is .
months and the average fix time for all fixed important bugs is .
months.
these long times indicate that these bugs can be highly non trivial.
as table iii shows we classify the bugs into three types races deadlocks and memory model related bugs.
we then analyze the root causes of communication deadlock a subtype less studied in the literature.
races and atomicity violations jacontebe contains data races and atomicity violations which are two well studied types of concurrency bugs .
both represent the cases of concurrently modifying shared variables such that the output can depend on the execution sequence so in jacontebe we group races and atomicity violations together.
for example fig.
shows a bug in openjdk6.
thread checks two conditions at line while thread can assign a null pointer to filter at line .
if the assignment happens between the checks of condition and condition the checking of condition is invalid.
deadlocks jacontebe contains deadlocks of which are resource deadlocks and are communication deadlocks.
a resource deadlock occurs when a thread holds resources and prevents the other threads to proceed .
a communication deadlock occurs when synchronization signals i.e.
wait notify and notifyall in java among threads are improperly used.
it was pointed out even in that researchers focus on races and atomicity violations more than on deadlocks years later although more researchers have focused on resource deadlocks communication deadlocks are still less studied.
table iv provides some more details for the communication deadlocks in jacontebe.
they have three symptoms.
the bug pool corresponds to a symptom called notify before wait where notify is executed before wait and thus waiting threads will not be notified.
the bug lucene corresponds to a symptom called alwayswait where the condition for a waiting loop always holds blocking the program.
the others correspond to notify notexecuted where a waiting thread cannot get notified because the corresponding notify does not get executed.
a previous study reported similar concurrency bug patterns losing a notify bug pattern and a blocking critical section bug pattern but these patterns are too general and the study didtable iii.
c oncurrency bugs in benchmark programs .
bug types bug description races and atomicity violations 19low level data races and high level atomicity violations deadlockresource deadlock16threads compete for the critical resources locks and each thread holds a resource lock required by others communication deadlock9the wait notify communication between threads is broken memorymodel related issueinconsistent synchronization2the accesses to the shared variable among threads are not properly synchronized so a change from one thread is not visible to other threads sc violation 1the statement execution order among different threads is reordered by jmm making sc violation not show corresponding real bugs.
we thus further investigate the communication deadlocks in jacontebe and summarize their root causes as follows redundant locks this is a mixed use of holding extra locks while invoking wait ornotify methods.
in java when wait is called on an object the lock on the object is released.
however if the waiting thread holds an extra lock and the notify thread waits for it to wake up the waiting thread the program blocks.
misuse of notify andnotifyall ifnotify is incorrectly used at the place where notifyall should be used then the jvm picks only one of the waiting threads seemingly at random while all the remaining threads keep waiting.
scheduling problem the threads may not be appropriately orchestrated making a notify in one thread execute before the intended wait in another thread.
the scheduling problem can also lead to the notify condition being unsatisfied e.g.
inpool the interference among thread executions can change one notify condition to an unexpected state.
unhandled exceptions the waiting threads cannot get notified when an exception is not caught or handled appropriately.
due to exceptions a working thread may not invoke notify ornotifyall or it fails to set the conditions to notify.
logical incorrectness logical incorrectness is related to the thread scheduling problems e.g.
jdk is caused by a conflict of waiting and notify conditions and once a thread waits it is infeasible to notify the thread due to logical problems.
inappropriate usage of data structures and algorithms when data structures and algorithms that do not support concurrency accesses are used in a concurrent setting deadlocks can happen e.g.
pool .
memory model related bugs jacontebe contains three bugs related to the java memory model jmm i.e.
two inconsistent synchronization bugs and a sequentialconsistency sc violation bug .
an inconsistent synchronization is similar to a race condition both occur when two or more accesses to a shared variable are not synchronized properly and at least one access is a write.
however an inconsistent synchronization bug is usually caused by an invisible change which means a shared variable is modified in one thread but the modification is nottable iv .
r oot cause for communication deadlocks in jacontebe.
bug symptom root cause bug description pool notify before wait schedule issuea notify statement may be executed ahead of the corresponding wait statement.
see org jira browse pool .
pool notify not executedinappropriate usage of data structures and algorithmspool uses a linkedlist object.
one thread a attempts to get the first element from the list and if the first element is not retrievable waits.
another thread b retrieves other elements in the list and then notifies thread a to continue.
however b can be blocked and a then cannot be waken up because a list must be accessed from its head.
see pool unhandled exceptionan exception makes a borrowed object to not be returned while other threads wait for that object.
see log4j unhandled exceptionan exception is thrown in a notify thread while other threads waits to be notified.
see apache.org bugzilla show bug.cgi?id .
log4j 38137misuse of notify and notifyallthe program has one dispatcher and two appenders.
after one element is removed from the buffer the dispatcher notifies only one appender making the other appender wait.
see bugzilla show bug.cgi?id .
jdk redundant lockssome redundant synchronization is enforced on threads causing a deadlock of the waiting and the notify threads.
see lucene redundant locks the bug is the same as jdk .
see jdk logical issuethere are conditions for both wait andnotify but they are contradictory.
when the waiting condition is satisfied it is infeasible to reach the notify statement.
see browse jdk .
lucene always wait logical issuethe condition in a wait thread ...while condition fwait timeout g... is always true.
see propagated to another thread.
for example pool is an inconsistent synchronization bug in jacontebe one thread is synchronized to reset a loop flag a shared variable but another thread is not synchronized to read the flag resulting in an infinite loop.
the inconsistent synchronization can be fixed either by marking accesses from all threads to one shared variable as synchronized or declaring the shared variable as volatile .
a sc violation bug happens when the execution sequence of two or more statements in one thread is reordered.
it can be introduced at different optimization phases e.g.
compiling optimizations runtime optimizations or instruction execution optimizations .
although reordering is allowed by the java memory model when it does not perturb the singlethread execution it may break data or control dependencies among threads.
section iv b shows the sc violation bug from the groovy project.
d. implementing test cases it is non trivial to supplement a concurrency bug with a test case that triggers the buggy behavior either deterministically on every run or almost deterministically such that one needs a small number of runs to trigger the buggy behavior.
for jacontebe we leverage the bug reports to create a test case for each bug.
if a bug report has an attached test case we modify it to deterministically trigger the bug.
otherwise we design a new test case according to the description and discussion in the bug report e.g.
stacktraces buggy interleaving or bug symptoms expecting to reproduce the reported bug.
to reproduce a concurrency bug almost deterministically a test case needs to specify appropriate thread interleaving that schedules the execution to the buggy location by following a mostly deterministic interleaving and inputs that lead the execution through the branches to reach the buggy location by following a mostly deterministic execution path.
when necessary to achieve this goal we use instrumentation and mocking to design the test cases.
we can usually enforce the interleaving by adding statements in the test case e.g.
to control that one thread starts1 t h r e a d 2p u b l i c void l o g logrecord r e c o r d f .
.
.
i f filter !
null1 !filter isloggable record 5f return 7g .
.
.
9g t h r e a d p u b l i c void s e t f i l t e r f i l t e r n e w f i l t e r .
.
.
f .
.
.
f i l t e r n e w f i l t e r 15g fig.
.
an instrumentation example in openjdk6.
this bug happens when filter is assigned to null at line in one thread just between the two condition checks at line in another thread.
1i f p h y s i c a l c o n n e c t i o n .
i s c l o s e d 2f .
.
.
4ge l s ef .
.
.
i f !
p h y s i c a l c o n n e c t i o n .
i s g l o b a l p e n d i n g f p o o l e d c o n n e c t i o n .
r e c y c l e c o n n e c t i o n 8g 9g fig.
.
a mock example in derby .
the bug is in the method call at line and requires the checks at lines and to be false and true respectively.
before another but when more elaborated controls are required during the thread execution we use instrumentation to ensure the threads follow the expected interleaving to trigger the bug.
for example fig.
shows the code snippet for a bug that is very unlikely to be triggered when the test is repeated without instrumentation because the time for preemption between the two condition checks at line is very short.
however the bug can be triggered easily if we add some instrumentation either a pause e.g.
sleep for a few milliseconds between condition and so that the bug triggers much more frequently or some control statements to enforce the statement at line to execute just between the conditions and at line so that the bug can be deterministically reproduced.
we use asm a java bytecode manipulation and analysis framework to instrument the java binary code.
in this example as we modify the jdk code itself we need to start the test with the xbootclasspath p option totable v .
r esults for three approaches .
detection succeed fail crash approach jac sir jac sir jac sir jpf rv predict checkmate preload the instrumented code instead of the original code from jdk.
we also use mocking to ensure that the concurrent code strictly follows a given program trace to reach a buggy program location.
for example fig.
shows the code snippet for bug derby that is triggered in the method call at line .
the execution reaches line only when the checks at lines and are false and true respectively.
the real process of setting up and maintaining a physicalconnection object is rather complex so mocking its behavior makes it easier to get the required values.
we use mockito a popular java mocking framework to mock the method call at line to return false directly without calling the real method.
the method call at line always return false so we need no mocking for it.
strictly speaking neither instrumentation nor mocking can guarantee deterministic triggering of a bug on every run.
but in practice using one of them is often effective to help reproduce bugs deterministically.
there is only one bug that we could not reproduce very deterministically.
that is the sc violation bug where we cannot easily enforce the execution sequence of statements in one thread at runtime.
in addition any insertion or deletion of statements may affect the behavior of the java memory model making the reproduced bug to not be the original one.
in this case we can only execute the test case for a large number of times to reproduce the bug.
in particular using the test case from jacontebe the sc violation bug groovy can be reproduced within seconds on a typical jvm.
in summary each bug in jacontebe is accompanied by a test case and a description of the bug.
most test cases out of can reproduce the bug deterministically on every run.
to achieve that test cases use mocking and test cases use instrumentation no test case uses both mocking and instrumentation.
the other test cases need several runs to trigger the bug and one of those test cases uses mocking these test cases could have used more mocking or instrumentation to reproduce the bug faster but it takes only a few seconds for multiple runs to trigger the bug so it was not worthwhile to make them more deterministic.
only one test case for the buggroovy requires many more runs as described in more detail in section iv b. in addition we design a framework for the jacontebe benchmark suite to provide the common utilities for running the buggy programs and the capability of executing the bugs in their expected scenarios such as controlling the threads terminating deadlocks and enforcing thread interleavings.
iv.
e valuation to evaluate jacontebe we perform small experiments with three approaches for detecting java concurrency bugs the java pathfinder jpf research tool6 the rv predict vi.
d etailed results for check mate on jacontebe.
buggy programjacontebe resultdeadlock typeproject versionresult in pool succeedcommunication deadlock pool .
pool succeedcommunication deadlock pool failcommunication deadlock log4j succeedcommunication deadlocklog4j .
.
log4j failresource deadlock dbcp failresource deadlock dbcp .
dbcp succeedresource deadlock commercial tool7 and our implementation of the checkmate approach .
both rv predict and checkmate were proposed in the papers we have surveyed in section ii.
we also run these three implementations on sir old conc which is how we call the old concurrency bugs in sir8 now that jacontebe is also a part of sir.
bugs overlap in jacontebe and sir old conc belonging to the apache log4j and apache pool projects.
we run jpf on all concurrency bugs in jacontebe bugs and sir old conc bugs .
we run jpf v7 and jdk .
whenever possible but jacontebe has jdk6 bugs and jpf v7 is incompatible with lower jdk versions so we also run jpf v6 and jdk .
.
on these jdk6 bugs.
we run rv predict .
on the buggy programs known to contain data races bugs from jacontebe excluding openjdk6 and openjdk7 bugs because they are incompatible with rvpredict s requirement of jre and bugs from sir oldconc excluding atomicity violations that rv predict does not detect .
we run checkmate on all deadlock bugs in jacontebe bugs and sir old conc bugs .
programs in sir oldconc contain both non deadlock and deadlock bugs that can be triggered by the same test case via different schedules so we put these programs into non deadlocks and run on rv predict because detecting a deadlock that actually happened is rather obvious when a program hangs .
we run both jpf and rv predict out of the box only with their default configurations except that for jpf we change the option search.multiple errors from default false to true which instructs jpf to search for multiple bugs in one run.
our checkmate implementation has no configuration options.
the results could differ for different configurations of these tools or for different tools.
a. overall results table v summarizes the results.
for each approach we tabulate the numbers of bugs it successfully detects it fails to detect and where it crashes.
jac is short for jacontebe sir is short for sir old conc and jac sir has the first value for jacontebe and the second for sir old conc.
jpf detects all bugs in sir old conc but does not detect most bugs in jacontebe.
for bugs jpf terminates exploration but fails to detect the bug i.e.
either reports other bugs not the expected one although we set the option search.multiple errors or does not report any bug.
for bugs jpf conceptually crashes i.e.
does not terminate exploration mainly due to unsupported native methods.
jpf is a java virtual machine implemented in java itself and requires special implementation for native methods.
while jpf implements many native methods it does not implement all the native methods required by the jvm specification .
when the code invokes an unimplemented native method jpf terminates execution and reports an error message such as cannot find native method name .
some seeming implementations of jdk methods in jpf are also incomplete e.g.
jpf implements java.lang.class.getprotectiondomain by throwingunsupportedoperationexception whenever invoked.
as the test cases in jacontebe run unmodified realworld projects some of them invoke native and jdk methods unimplemented in jpf making jpf crash.
these results confirm a known limitation of jpf with native methods and show that handling unmodified real code in jacontebe is different from handling carefully prepared simplified examples in sir old conc .
rv predict is a commercial tool that evolved from a long line of research with the most recent result by huang et al.
.
rv predict is designed to detect data races for complex applications.
it succeeds to detect bugs in jacontebe and in sir old conc.
the two missed bugs from jacontebe are in the java.
packages that rv predict by default does not check.
checkmate is chosen among various deadlock detection approaches because it is designed to detect both communication deadlocks and resource deadlocks unlike many other approaches focusing on resource deadlocks only .
we implement checkmate following the original description and run it against all deadlock bugs in jacontebe and sir oldconc.
while checkmate finds almost all deadlocks in sirold conc and the missed bugs are real world bugs it fails to find over two thirds of deadlock bugs in jacontebe.
table vi compares the results of running checkmate on the projects that overlap in jacontebe and the original evaluation of checkmate .
for each bug we tabulate the result of checkmate on the test case from jacontebe the bug s deadlock type and the corresponding project version.
the last column shows the number of deadlocks detected in the corresponding project in the original evaluation that does not report all bug ids but only reports how many deadlocks are found in which version of which project.
the evaluation does mention two bug ids log4j andgroovy we have log4j in table vi and section iii c describes why groovy is not selected.
the results indicate that jacontebe finds more limitations in checkmate than sir old conc finds.
b. most challenging bugs in jacontebe during the evaluation we found two particularly challenging bugs native deadlock and sc violation.
native deadlock.
most resource and communication deadlocks in java code are caused by the synchronization at the pure java level.
we find a special subtype of resourcedeadlocks caused by the native locks acquired in the native methods.
we refer to this type of deadlock as native deadlock it often mixes execution from two different levels the java level and the native c c level.
as any ordinary resource deadlock a native deadlock is caused by cyclic locking.
however unlike an ordinary resource deadlock a native deadlock has some native c c lock s acquired by native methods and potentially some java lock s acquired by java methods.
for example a native deadlock occurs when a thread holds a native lock and acquires a java lock while another thread holds the java lock and waits for the native lock.
we find only one native deadlock in the projects currently in jacontebe but there are likely more such deadlocks in other projects and they are still harmful and can hang the program.
moreover they are difficult for developers to even comprehend e.g.
consider a stackoverflow question9about a deadlock caused by a native method.
jvm does not provide information about acquisition of native locks in the stacktraces.
the bug groovy in jacontebe is a native deadlock bug from groovy .
.
.
fig.
shows its simplified stacktrace.
the thread dump of compiling and instantiation shows literately no lock acquisition but the deadlock information shows the thread compiling and instantiation waiting for a lock held by thread compiling and instantiation .
in fact the native lock is held in the native method forname0 by the thread compiling and instantiation and attempted to be acquired in the native method getdeclaredfields0 by the other thread.
therefore the deadlock is formed by a native lock and a java lock.
such native deadlocks are difficult to detect and reproduce and both jpf and checkmate fail to detect the deadlock ingroovy .
static analysis usually considers native methods as black box and has a limited support for them .
dynamic deadlock prediction e.g.
analyzes the execution trace to find potential deadlocks but the acquisition of locks in native methods is not visible in the program execution trace at the java level.
similarly reproduction techniques e.g.
need to know where the lock has been acquired and released.
the bug groovy could motivate a bigger study of native deadlocks in java.
sc violation.
jmm allows statement reordering that can be surprising to the developer and lead to bugs.
fig.
shows the example bug groovy where two threads execute the same method.
if thread executes line after line then thread passes the condition checks at line and returns the value at line without problems.
however jmm allows thread to execute line before line and if thread executes in between those lines it completes the check at line and can return an unintended null value at line .
different from order violation bugs caused by a nondeterministic execution order of statements in two threads sc violation is caused by the relaxed memory consistency model.
c. comparison with other benchmark suites compared with the currently used benchmark suites for evaluating bug detection for java jpg dacapo ibm and compiling and i n s t a n t i a t i o n w a i t i n g t o l o c k m o n i t o r x000000000cc5b3a8 o b j e c t x00000007d6ce9040 a groovy .
l a n g .
g r o o v y c l a s s l o a d e r i n n e r l o a d e r which i s h e l d by compiling and i n s t a n t i a t i o n compiling and i n s t a n t i a t i o n w a i t i n g t o l o c k m o n i t o r x000000000cc5bc98 o b j e c t x00000007d7da8070 a j a v a .
u t i l .
hashmap which i s h e l d by compiling and i n s t a n t i a t i o n j av a s t a c k i n f o r m a t i o n f o r t h e t h r e a d s l i s t e d above compiling and i n s t a n t i a t i o n a t j a v a .
l a n g .
c l a s s .
g e t d e c l a r e d f i e l d s n a t i v e method .
.
.
a t groovy .
l a n g .
groovyclassloader .
r e c o m p i l e groovyclassloader .
j a v a l o c k e d 0x00000007d7da8070 a j a v a .
u t i l .
hashmap .
.
.
a t groovy4736 .
run groovy4736 .
j a v a compiling and i n s t a n t i a t i o n a t groovy .
l a n g .
groovyclassloader .
r e c o m p i l e groovyclassloader .
j a v a w a i t i n g t o l o c k 0x00000007d7da8070 a j a v a .
u t i l .
hashmap a t groovy .
l a n g .
groovyclassloader .
l o a d c l a s s groovyclassloader .
j a v a a t groovy .
l a n g .
g r o o v y c l a s s l o a d e r i n n e r l o a d e r .
l o a d c l a s s groovyclassloader .
j a v a a t groovy .
l a n g .
groovyclassloader .
l o a d c l a s s groovyclassloader .
j a v a a t j a v a .
l a n g .
c l a s s l o a d e r .
l o a d c l a s s c l a s s l o a d e r .
j a v a a t j a v a .
l a n g .
c l a s s .
forname0 n a t i v e method a t j a v a .
l a n g .
c l a s s .
forname c l a s s .
j a v a a t t e s t .
d1 .
c l a s s t e s t .
d1 a t t e s t .
d1 .
g e t c l a s s t e s t e t e s t .
d1 a t t e s t .
d1.
i n i t t e s t .
d1 a t sun .
r e f l e c t .
n a t i v e c o n s t r u c t o r a c c e s s o r i m p l .
n e w i n s t a n c e n a t i v e method a t sun .
r e f l e c t .
n a t i v e c o n s t r u c t o r a c c e s s o r i m p l .
n e w i n s t a n c e n a t i v e c o n s t r u c t o r a c c e s s o r i m p l .
j a v a a t sun .
r e f l e c t .
d e l e g a t i n g c o n s t r u c t o r a c c e s s o r i m p l .
n e w i n s t a n c e d e l e g a t i n g c o n s t r u c t o r a c c e s s o r i m p l .
j a v a a t j a v a .
l a n g .
r e f l e c t .
c o n s t r u c t o r .
n e w i n s t a n c e c o n s t r u c t o r .
j a v a a t groovy4736 .
run groovy4736 .
j a v a fig.
.
stacktrace of the native deadlock bug groovy .
1p u b l i c metamethod r e t r i e v e s t a t i c m e t h o d s t r i n g methodname o b j e c t arguments f .
.
.
c a c h e e n t r y e .
c a c h e d s t a t i c m e t h o d i f c a c h e e n t r y !
n u l l m e t a c l a s s h e l p e r .
s a m e c l a s s e s c a c h e e n t r y .
params arguments e .
s t a t i c m e t h o d s i n s t a n c e o f metamethod 5f return c a c h e e n t r y .
method 7g .
.
.
c a c h e e n t r y .
params c l a s s e s c a c h e e n t r y .
method p i c k s t a t i c m e t h o d methodname c l a s s e s e .
c a c h e d s t a t i c m e t h o d c a c h e e n t r y return c a c h e e n t r y .
method 13g fig.
.
a sc violation example groovy .
jmm allows the sequence t1.l11!t2.l4!t2.l6!t1.l10 that can return unexpected null .
sir jacontebe provides more bugs from real open source projects with test cases for reproduction and with detailed documentation of root causes and buggy interleavings.
although jpg and dacapo are frequently used in evaluations they were not initially designed for the purpose of concurrency bug detection.
both consist of a set of multi table vii.
c omposition of sir old conc benchmarks .
source programsaverage size loc ibm benchmark suite .
newly designed .
used by research papers .
real world applications .
threaded applications whose concurrency bugs were unknown.
as a result the effectiveness of evaluated techniques may not be precisely calculated when these benchmarks are used.
in contrast jacontebe is built up from real world buggy projects where the symptom type and root cause of each bug have been clearly stated and a test case is provided.
researchers can use jacontebe to evaluate the effectiveness of their approaches in handling real software systems.
unlike jpg and dacapo ibm and sir benchmark suites provide documented buggy programs and tests to reproduce them.
however out of programs in ibm are written by undergraduate students is from a real world application and the others are open source programs.
the buggy programs in sir are from sources bugs from ibm benchmarks bugs designed based on several bug patterns bugs used by other studies and real world bugs as shown in table vii.
these buggy programs cover traditional pedagogical concurrency programs e.g.
dining philosophers and sleeping barbers and typical concurrency bug idioms e.g.
two stage locking .
although both ibm and sir cover various types of concurrency bugs with good diversity the small code size is insufficient to show the limitations of some approaches e.g.
how model checking can encounter the state space explosion problem with larger scale.
jacontebe complements sir in that it provides more real world bugs and jacontebe has been accepted as a part of sir.
v. d iscussion and future work enriching jacontebe with more concurrency bugs.
while we have inspected hundreds of bug reports potentially related to concurrency in the bug databases of projects our inspection is still incomplete.
for example a bug report may not mention any keywords that we queried even if it is about a concurrency bug.
specifically dbcp has been confirmed as a concurrency bug but it does not mention our keywords.
therefore we need to improve our searching method trying to include more true positive matches without substantially enlarging false positives.
additionally we inspected only of the projects from the surveyed papers section iii b so we plan to inspect the other apache xalan apache tomcat apache ftp server eclipse hsqldb and pmd for the future jacontebe versions.
moreover we also plan to analyze more concurrency bugs from other projects to further enrich jacontebe.
evaluating the effectiveness of jacontebe.
we have compared the results of running three approaches against jacontebe and sir old conc to determine if jacontebe can confirm some known limitations of these approaches.
we did not use the ibm benchmark suite for comparison because it is no longer available on its web site and its current maintainer us a distribution that contains only some of the programs from the benchmark suite.
we plan to evaluate more detection approaches and tools in the future.
the effectiveness of real bugs in benchmarks.
whether or when artificial faults can replace real bugs in software testing research is an open question.
recent research finds that the elaborately designed mutants can be used as a substitute for real faults when comparing generated test suites i.e.
the substitution equivalence is conditional on having appropriate mutants.
somewhat older research finds that for typical mutation operators operator based mutant selection may not be better than random mutant selection in several cases increasing the importance of selecting proper mutants that can represent real bugs.
the importance of practical testing scenarios.
jacontebe follows the methodology established by prior benchmark suites to provide test cases that focus on the bugs and can almost deterministically reproduce them with relatively short executions.
however in an actual practical usage of a tool for detection of concurrency bugs the developers would not have such test cases.
in fact they may even have no test cases with both program inputs and expected outputs but only have some program inputs and or they may have much longer executions not focused on the bug.
in the future it would be important to study not only what bugs can be found by various approaches with focused test cases but also how developers actually use the approaches tools e.g.
following the work of parnin and orso on analyzing automated debugging .
vi.
r elated work as a benchmark suite of real world java concurrency bugs jacontebe is related to several lines of research.
benchmark guidelines.
as pointed out by bird et al.
the quality of a benchmark can substantially impact the results of evaluating an approach.
to prepare successful benchmarks sim et al.
proposed seven guidelines and lu et al.
further distilled them into five guidelines.
section ii a presents a survey of four existing benchmark suites of concurrency bugs comparing to these benchmark suites our jacontebe benchmark suite has the following benefits it has clearly documented root causes for bugs all bugs are from realworld open source applications many of our bugs are difficult to detect and it includes tests and scripts to reproduce the concurrency bugs deterministically and easily.
bradbury et al.
propose a methodology for creating a benchmark suite based on a combinatorial test design technique.
specifically they design a matrix that covers combinations of benchmark metrics and suggest to fill the matrix with programs from three sources existing benchmarks such as programs from the ibm benchmark suite bugs from open source repositories and artificial mutants.
they do not provide a benchmark suite covering the full matrix.
bug detection approaches.
luet al.
classify concurrency bugs into deadlock bugs and non deadlock bugs and further classify the latter into atomicity violations order violations and other bugs.
numerous approaches have been proposed for detecting such bugs.
for deadlocks static approaches e.g.
typically analyze code for cyclic use and dynamicapproaches e.g.
analyze execution traces to locate potential deadlocks.
as some reports can be false alarms cai et al.
propose an approach that validates detected deadlocks dynamically.
for non deadlock concurrency bugs such as atomicity violations and races static approaches e.g.
analyze code and dynamic approaches e.g.
falcon analyze runtime behavior to check whether threads can access the same memory locations.
most approaches have to predefine the nature of target bugs.
for example findbugs defines multi threaded bug patterns and farchi et al.
summarized patterns from java concurrency bugs with regard to how bugs are manifested.
all these studies reveal some aspects of concurrency bugs and help us to prepare our benchmark suite.
moreover while collecting the bugs for jacontebe we also find some less studied concurrency bugs complementing the above studies.
concurrency bug reproduction.
huang et al.
proposes leap that monitors and records shared memory dependencies at runtime and replays concurrency bugs deterministically.
typically record and replay suffers from side effects because instrumented code may change the behavior of the original code.
to address the problem researchers e.g.
explore offline approaches that reproduce the concurrency bugs based on execution traces and bug reports.
furthermore hybrid approaches e.g.
clap record little information at runtime and search for executions that reproduce buggy behaviors.
tools such as calfuzzer concurrit and imunit allow programmers to manipulate thread interleavings to reproduce buggy behaviors.
we manually prepare a test case for each bug in jacontebe but the mentioned approaches could reduce the effort for preparing such test cases when we enlarge jacontebe in the future.
vii.
c onclusion we have conducted a survey of the existing benchmarks used for evaluating concurrency bug detection approaches in java and we have prepared jacontebe a new benchmark suite of java concurrency bugs.
jacontebe currently contains real world bugs from practical software projects.
we believe that jacontebe can help researchers to evaluate the effectiveness of their bug detection approaches.
the experiment results and survey datasets are available at sjtu.edu.cn index.php?title jacontebe.