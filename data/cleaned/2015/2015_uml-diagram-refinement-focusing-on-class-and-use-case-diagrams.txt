uml diagram refinement focusing on class and use case diagrams david faitelson software engineering department afeka tel aviv academic college of engineering israel email davidf afeka.ac.ilshmuel tyszberowicz school of computer science academic college of tel aviv yaffo israel email tyshbe mta.ac.il abstract large and complicated uml models are not useful because they are difficult to understand.
this problem can be solved by using several diagrams of the same system at different levels of abstraction.
unfortunately uml does not define an explicit set of rules for ensuring that diagrams at different levels of abstraction are consistent.
we define such a set of rules that we call diagram refinement .
diagram refinement is intuitive and applicable to several kinds of uml diagrams mostly to structural diagrams but also to use case diagrams yet it rests on a solid mathematical basis the theory of graph homomorphisms.
we illustrate its usefulness with a series of examples.
keywords refinement uml class diagram use case diagram graph homomorphism design patterns i. i ntroduction large and complicated uml models are not useful because they are very difficult to understand.
unfortunately models of complex systems are often complex as well .
the traditional advice for dealing with this problem is to group related entities into packages .
but because packages are only organizational units that do not represent any entity in the domain diagrams that consist only of packages convey very little information about the domain we are trying to model.
for example suppose that we partition a large class diagram into several packages but there are important associations between classes in different packages.
we cannot understand the structure of the system just by looking at the relationships between the packages.
we must open the packages to look at the classes inside.
but then it is not clear what we have gained by the packages.
we believe that what is missing here is explicit support for relating diagrams that model the same system at different levels of abstraction.
the uml offers a relationship for asserting that one model is more abstract or refined than another model .
but it does not offer any set of rules for determining if such an assertion is indeed correct.
unfortunately without such rules it is very difficult to place our confidence in the relationship.
for example it is difficult to discuss an abstract diagram with the customer if we are not certain that it is consistent with the more refined version that the developers use.
there have been earlier attempts to add a theory of refinement to uml models e.g.
.
however to the best of our knowledge all this previous work demands that the engineers will use a formal framework asin a methods like z b or object z and reason about their models in terms of a mathematical theory e.g.
the theory of data refinement description logic or category theory .
unfortunately the level of mathematical sophistication required in order to use these approaches is well beyond what most engineers are willing to accept.
our contribution is a simple set of rules that we call diagram refinement for checking if a concrete diagram is consistent with that is refines a more abstract diagram.
our rules have a sound mathematical basis yet they do not require knowledge of this basis in order to be applied.
in fact we believe that diagram refinement has a simple intuitive meaning that can be easily understood by any engineer who is familiar with uml models.
in addition our rules are based on a simple relational semantics.
as a result we can apply the rules to any kind of diagram for which we can define such semantics.
in this paper we describe a relational semantics for two popular uml diagrams class diagrams and use case diagrams.
diagram refinement can be used in a top down fashion to develop new software by gradually enriching abstract models with more details while ensuring that the detailed description preserves the original abstraction.
this is important if we are to use the abstract models to explain and document the system.
alternatively diagram refinement can be used in a bottom up fashion to reverse engineer existing systems in order to discover the abstractions encoded in the concrete models.
certainly having a precise notion of refinement is essential for tool builders.
for example it may be used to ensure that when we move from an analysis viewpoint to a design viewpoint the more detailed design diagram is consistent with the analysis diagram.
but even practitioners that use diagrams only as sketches may find the theory useful.
if you know the theory you can make informed deviations which you understand and are under your control.
in this case your abstractions will still be useful.
however without a theory there is no way to know what is the connection between the abstract and concrete models.
in this case you better throw away the abstraction as using it would lead your readers astray and probably do more harm than good.
in the next section we explain the rules of class diagram refinement.
we then extend the rules to deal with association 1according to class diagrams are the most widely used uml diagrams.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
multiplicities and demonstrate in sect.
iii their usefulness by an analysis of a large and complicated class diagram taken from a real world project.
in sect.
iv we provide a mathematical foundation for the rules where we show that diagrams induce particular kinds of graphs and that the rules of valid refinement are equivalent to graph homomorphisms.
next in sect.
v we show that diagram refinement can be used to formally capture the use of design patterns and to clarify use case diagrams.
we describe the relational semantics that underlies diagram refinement in sect.
vi.
related work is presented in sect.
vii and we conclude in sect.
viii.
ii.
c lass diagram refinement lack of abstraction is a problem of large diagrams but it also exists in small diagrams and they are better tools for illustrating our ideas.
consider the simple diagram in the left corner of fig.
.
we have a class person with an association that represents the relationship between a person s parents and children.2suppose we want to assert that a person is either a male or a female the male is the father and the female is the mother.
how can we represent this information in the model?
a naive approach will add this information to the original diagram.
unfortunately the result is inconsistent with the situation we are trying to model.
it now appears that each person has two parents and in addition has a male father and a female mother.
a better approach is to declare that parents is a derived association of mother and father .
but this only adds another level of complexity to the diagram.
when the diagram is large and complicated declaring that some associations are derived from others only makes it more difficult to understand.
the key to solving this problem is to observe that we are describing the same structure at two different levels of abstraction.
at a high level we are not interested in the gender of the parents so we are happy to model the situation as a single association between persons.
at the more detailed level we refine our model to distinguish the gender of the parents and as a result create a more elaborate model.
by separating the different levels of abstraction into separate diagrams we facilitate modular development.
we can reason about key properties at the abstract level and later focus on the details without hiding the abstraction.
of course we must ensure that the added details are consistent with the abstraction see fig.
note that when the multiplicity is we omit it .
but simply stating that one diagram refines another is not sufficient because we run the risk of creating concrete models that are not consistent with their abstract versions.
therefore in the following sections we define an explicit set of rules for determining when one diagram refines another.
a. v alid diagram refinement a diagram refinement is a mapping from an abstract diagram to a concrete diagram.
to avoid cluttering refinements 2we are aware that it is common to separately name each end of the association but using a single name for the association simplifies the presentation.
we later describe how to apply the ideas to associations with separate names.
g48 g68 g79 g72 g80 g82 g87 g75 g72 g85 g13 g80 g82 g87 g75 g72 g85 g13 g73 g68 g87 g75 g72 g85 g13 g83 g68 g85 g72 g81 g87 g86 g21 g13 g17317 g51 g72 g85 g86 g82 g81 g51 g72 g85 g86 g82 g81 g41 g72 g80 g68 g79 g72 fig.
.
an abstract diagram on the left and its refinement right .
the class person in the concrete diagram represents the class person in the abstract diagram.
the father and mother associations represent the parents association.
with trivial information we adopt the convention that if an entity in the abstract diagram does not appear in the mapping then it is mapped to the entity with the same name in the concrete diagram of course we have to check that such an entity exists .
for example the mapping father parents mother parents determines the refinement between the diagrams in fig.
.
the mapping states that person in the concrete diagram represents person in the abstract diagram and that the associations father and mother correspond to parents .
we did not map male and female toperson as these classes are new additions that do not represent any class in the abstract diagram.
diagram refinement is a relation between two diagrams not between individual entities.
for a diagram refinement to be valid these rules must hold every class in the abstract diagram must map to exactly one class in the concrete diagram.
every association in the abstract diagram must map to at least one association in the concrete diagram.
if association cin the concrete diagram maps to association ain the abstract diagram c s classifiers must map toa s classifiers or to subtypes of these classifiers.
if class xis a subtype of class yin the abstract diagram then the class that is mapped to xin the concrete diagram must be a subtype of the class that maps to y. if class xis a subtype of class yin the concrete diagram and they are mapped to classes aand correspondingly b in the abstract diagram then amust be a subtype of b. rules and ensure that the concrete diagram represents at least all the information in the abstract diagram whereas rules ensure that the structure of the concrete diagram is consistent with the structure of the abstract diagram.
rule ensures that every association between two concepts at the abstract level remains between the same two concepts at the concrete level.
rule ensures that refinement maps subtypes to subtypes.
rule ensures that any subtype relationship that appears in the concrete diagram and can be represented in the abstract diagram will appear in the abstract diagram.
by using these rules we can catch invalid refinement attempts.
for example the diagram in fig.
is not a valid refinement of the abstract diagram in fig.
as we cannot map the associations father and mother toparents without authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g51 g72 g85 g86 g82 g81 g41 g72 g80 g68 g79 g72 g48 g68 g79 g72 g80 g82 g87 g75 g72 g85 g13 g51 g73 g68 g87 g75 g72 g85 g13 fig.
.
an invalid refinement of the abstract person diagram violating rule .
violating rule .
it also violates rule because every class is a subtype of itself.
to fix this refinement we must make male and female subtypes of person .
then the source and target of father and mother are both subtypes of person and we can map them to parents without violating any of the rules.
an important property that these rules ensure is that any composition of abstract associations is mapped to some composition of concrete associations.
therefore a concrete diagram can simulate in greater details any path of association traversals.
for example in the abstract diagram in fig.
it is possible to traverse the parents association as many times as we like producing ever distant ancestors.
similarly in the refined diagram it is possible to follow the same path using father and mother thus not only identifying the ancestors but also their gender.
b. refinement with multiplicity constraints so far we have ignored the multiplicity constraints on the associations treating each association as an unrestricted relation.
in this section we model the meaning of the multiplicity constraints in terms of constraints on relations.3this makes it possible to capture refinement relationships between diagrams that contain associations of different multiplicities.
we will write x y to denote an association with multiplicity constraints xand y where xand ycan be either a single symbol ?
we use ?to denote the optional association .. or a range of the form m..n where m nare natural numbers.
for example represents a many to many association.
when we do not care about the cardinality of one end we replace it with a variable.
for instance x ?
means either ?
or i..j ?
.
the meaning of an association with multiplicity constraints follows from the implications of the constraints to the relation that we identify with the association unconstrained associations of the form correspond to unconstrained relations associations where one end is constrained to be either mandatory or optional correspond to functions total or partial .
in the general case an association xbetween classes aand bwith multiplicity constraints i..j m..n corresponds to the constraints a a m a.x n b b i b. x j where sis the cardinality of the set s and xis the association xseen from b s side which corresponds to the inverse relation of xunder a relational interpretation of associations .
3we rely on a relational semantics of class diagrams explained in sect.
vi.
g88 g17 g17 g89 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g91 g17 g17 g92 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g13 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g91 g17 g17 g92 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g88 g17 g17 g89 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g13 g3 g3 g3 g3 g13 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g13 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g13 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g70 g17 g17 g71 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g68 g17 g17 g69 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g13 g3 g3 g3 g3 g68 g148 g88 g15 g3 g89 g148 g69 g70 g148 g91 g15 g3 g92 g148 g71 g76 g17 g17 g77 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g78 g17 g17 g79 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g91 g148 g78 g15 g3 g79 g148 g92 g88 g148 g76 g15 g3 g77 g148 g89 fig.
.
a lattice of multiplicity constraints.
the lattice supports all possible multiplicities by plugging the appropriate values.
for example a multiplicity of corresponds to .. an optional multiplicity to .. etc.
the edges that are annotated with an inequality exist only when the inequalities hold.
g36 g37 g68 g69 g20 g13 fig.
.
an abstract association.
using this interpretation we build a lattice of association types that defines a partial order on the different association multiplicities4 see fig.
.
the lattice defines the subset relations between the different kinds of associations.
if c appears in the lattice as a child of p then every association of type cis a subset of p. for instance if an association is a surjective injection ?
then it is also an injection ?
?
.
in a valid refinement the associations of the concrete diagram must be either equal to or less than the associations of the abstract relation where less than is defined by the lattice.
in addition to take care of the subtype relations between the classes we add the following constraints functionality when several associations refine a functional x ?
or x association their union must be functional as well.
onto when several associations refine an x association the union of their sources must be equal to the source of the abstract association that they refine.
for example fig.
shows an abstract model with a single oneto many association.
figure shows two valid refinements of the abstract model and fig.
shows three invalid refinements.
c. refinement with other constraints we now explain how we can extend our notion of diagram refinement to additional uml class diagram constructs.
aggregation and composition aggregation and particularly composition constrain the model in terms of how a particular object is shared between other objects.
this type of constraint is mostly independent from multiplicity constraints.
therefore we consider the different aggregation kinds separately from the multiplicity of the association.
any association end in the abstract diagram may be mapped to 4to simplify the lattice s diagram we use the fact that the general notation i..j m..n can describe the optional and mandatory multiplicities a mandatory end corresponds to n..n and an optional end corresponds to .. .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g68 g21 g69 g20 g36 g37 g13 g20 g36 g20 g36 g21 g37 g20 g37 g21 g37 g21 g13 g36 g21 g20 g68 g21 g69 g21 g68 g21 g69 g21 g36 g37 g13 g20 g68 g69 g68 g21 g69 g20 g314 g68 g69 g68 g21 g69 g21 g314 g68 g69 fig.
.
two valid refinements of fig .
note that in the lower diagram we satisfy the onto constraint because the union of the right hand side of a2b1 s and a2b2 s source b1 b2 is equal to b. g36 g37 g68 g69 g34 g13 g68 g69 g36 g37 g13 g20 g36 g20 g36 g21 g37 g20 g37 g21 g68 g21 g69 g36 g13 g20 g36 g20 g36 g21 g37 g37 g13 g36 g20 g68 g21 g69 g13 g13 g20 g20 g68 g20 g69 g68 g20 g69 g68 g21 g69 g314 g68 g69 g68 g20 g69 g314 g68 g69 fig.
.
invalid refinements of the abstract diagram in fig.
.
from top to bottom the first is invalid as it violates the order determined by the lattice the second is invalid as it violates the onto constraint only b2s are mapped toas which fails to ensure that every bhas an a the third is invalid because it violates the functionality constraint the same bis mapped to different as .
either a shared aggregation or a composite composition aggregation in the concrete diagram.
a shared kind in the abstract diagram may be mapped to a composite kind in the concrete diagram.
this reflects the fact that the constraints introduced by aggregation are weaker than those of composition.
every configuration of objects that satisfies the constraints of composition also satisfies the constraints of aggregation.
thus replacing aggregation with composition results in a more specific but still consistent and therefore refined model.
qualified associations qualifying an association reduces the multiplicity of the original unqualified association.
therefore it is valid to map an association ain the abstract diagram to a qualified association cin the concrete diagram provided that c a as given by the lattice .
this is possible even when ais already qualified.
see fig.
for an example.
ocl constraints ocl is used to specify constraints that are difficult or impossible to express with diagrammatic notation alone.
if we think of a class diagram as a notation for specifying the structural relationships between objects then adding ocl constraints further reduces the set of valid object structures rejecting all the structures that fail to satisfy the constraints.
for example we may constrain the diagram in fig.
by insisting that a person is never its own parent we use ocl packages to separate the different diagrams package abstract g38 g82 g80 g83 g68 g81 g92 g51 g72 g85 g86 g82 g81 g13 g72 g80 g83 g79 g82 g92 g80 g72 g81 g87 g38 g82 g80 g83 g68 g81 g92 g51 g72 g85 g86 g82 g81 g13 g72 g80 g83 g79 g82 g92 g80 g72 g81 g87 g86 g88 g85 g81 g68 g80 g72 g38 g82 g80 g83 g68 g81 g92 g51 g72 g85 g86 g82 g81 g20 g72 g80 g83 g79 g82 g92 g80 g72 g81 g87 g86 g88 g85 g81 g68 g80 g72 g81 g68 g80 g72 g17317 g17317 fig.
.
a simple model with two levels of refinement.
in the first refinement we qualify the employment relation on the surname attribute of person but there could still be people with the same surname in the company.
in the second refinement we qualify the qualified association.
context person inv self .
parents forall p p self endpackage we may also constraint the concrete diagram in the same spirit package concrete context person inv self .
mother forall m m self and self .
father forall f f self endpackage for a concrete diagram to refine be consistent with an abstract diagram with ocl constraints we must require that all the constraints in the abstract diagram be implied by the constraints of the concrete diagram with perhaps additional constraints added to the concrete diagram.
however a concrete diagram often encodes the associations in the abstract diagram using different more concrete associations.
therefore we must use the refinement mapping to translate the meaning of the constraints in the abstract diagram to the structure of the concrete diagram.
in our example to keep the refinement in fig.
valid we must ensure that no person is a parent of itself.
however the concrete diagram does not have a parents association instead it represents this abstract association using mother and father .
taking a page from the theory of data refinement we may represent the refinement mapping as a predicate retrieve that explicitly describes how the concrete model encodes the information in the abstract model.
unfortunately it appears that it is impossible to write ocl expressions that link together different diagrams.
it appears that ocl expressions are intended to accompany an individual uml model.
as far as we could see there is no way to say e.g.
that a class person in one diagram is the same represents the same set of objects as a class person in a different diagram.
nevertheless we think it is worthwhile to illustrate how we can describe diagram refinement in ocl under the assumption that it is possible to relate entities in different diagrams.
specifically we assume that it is possible to assert that two class names in different diagrams represent the same class.
figure shows the retrieve predicate for our example.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
context person def retrieve boolean self .
parents .
forall p self .
mother .
includes p or self .
father .
includes p self .
mother .
forall p self .
parents .
includes p self .
father .
forall p self .
parents .
includes p fig.
.
an ocl expression that describes how the concrete diagram encodes the structure of the abstract diagram.
we assume that person represents the same set of objects in both diagrams and check that the parents association in the abstract diagram is the union of the mother and father associations in the concrete diagram.
we now specify when diagram refinement is valid.
assume abstract inv is an ocl boolean expression that represents the constraints in the abstract diagram concrete inv represents the constraints in the concrete diagram and rrepresents the retrieve relation.
then the refinement is valid precisely when ris a valid diagram refinement and the following ocl expression is true concrete inv and r implies abstract inv iii.
a nextended example to illustrate the utility of diagram refinement we have applied it to a diagram that models the conceptual entities of astrogrid a virtual astronomical observatory see http wiki.astrogrid.org .
it provides a registry for locating astronomical data observation platforms and computational services to access and analyze the data in a uniform way.
the astrogrid diagram consists of classes and relationships counting associations and subtypes relations together .
unfortunately it is too big to fit in a single page and still be readable.
to get a feeling for its complexity we have replaced each class in the diagram with a point and each association with an edge see fig.
.
we kept intact only the note that accompanied the original diagram.
the complete diagram is available with the permission of its author online .
we believe that this diagram captures the dilemma that faces the modeler of a complex domain.
on the one hand it is too big to be useful and indeed it was abandoned for this fact yet on the other hand it is still missing many important problem domain entities.
clearly it is impossible to satisfy in a single diagram both the demand for faithful and detailed representation of the conceptual domain and the demand for simplicity and clarity that makes such diagrams useful.
in the following paragraphs we describe our experience of using diagram refinement to better structure the large astrogrid uml class diagram.
as we were not involved in the design of this system we did not have a perfect understanding of all its details.
therefore as we made progress in tryingnote tha t many entities are hidden for the sake of clarity in the diagram fig.
.
an abstraction of the entire astrogrid uml class diagram.
each point is a class and each edge is a relationship association or subtype between the classes.
the note appeared in the original diagram.
g51 g79 g68 g87 g73 g82 g85 g80 g86 g48 g72 g87 g68 g71 g68 g87 g68 g39 g68 g87 g68 g3 g3 g50 g69 g77 g72 g70 g87 g39 g68 g87 g68 g55 g82 g83 g38 g82 g89 g72 g85 g68 g74 g72 g36 g70 g70 g72 g86 g86 g3 g70 g82 g81 g87 g85 g82 g79 g53 g72 g86 g82 g88 g85 g70 g72 g86 g38 g82 g80 g83 g88 g87 g76 g81 g74 fig.
.
the refinement tree showing all the refinements we have performed on the various areas of the atrogrid model.
the names on the nodes are the names of the diagrams that focus on that particular subject.
the top most diagram is the most abstract view of the system.
if we combine all the leaves into a single diagram we get the original astrogrid diagram.
the shaded diagrams appear in the paper the rest are available at to abstract the original diagram we made mistakes which diagram refinement helped us to find and correct.
we know from experience that developing a system model is a similar process.
we make mistakes correct the model and repeat until we do not find any more mistakes.
any method that can help us catch mistakes is thus useful.
the following report illustrates how diagram refinement may be useful in the context of the development process.
after several sessions of studying the original diagram and any astrogrid design documents we could find online we felt that we had understood it well enough to be able to create an abstraction refinement tree of diagrams that describes the essential concepts of the problem domain at various levels of abstraction the result is shown in fig.
.
figure shows the diagram top which is the most abstract view of the system.
the first refinement that we have explored is to elaborate the relationships between the astronomical data and the observing platforms that produce this data.
we can see this refinement in fig.
.
observation platforms hold instruments that perform observations and produce data objects.
each observing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g53 g72 g86 g82 g88 g85 g70 g72 g3 g53 g72 g74 g76 g86 g87 g85 g92 g54 g72 g85 g89 g76 g70 g72 g48 g72 g87 g68 g71 g68 g87 g68 g50 g69 g86 g72 g85 g89 g76 g81 g74 g3 g51 g79 g68 g87 g73 g82 g85 g80 g13 g53 g72 g74 g76 g86 g87 g85 g74 g13 g50 g69 g86 g72 g85 g89 g76 g13 g39 g68 g87 g68 g3 g50 g69 g77 g72 g70 g87 fig.
.
the diagram top representing the most abstract view of the astrogrid system.
we can see that the system has a registry through which we can locate services metadata that holds the storage location of data objects and information about observing platforms.
g70 g82 g79 g79 g72 g70 g87 g76 g82 g81 g13 g79 g82 g70 g68 g87 g76 g82 g81 g76 g81 g86 g87 g85 g88 g80 g72 g81 g87 g86 g39 g68 g87 g68 g3 g50 g69 g77 g72 g70 g87 g47 g82 g70 g68 g87 g76 g82 g81 g50 g69 g86 g72 g85 g89 g76 g81 g74 g3 g51 g79 g68 g87 g73 g82 g85 g80 g44 g81 g86 g87 g85 g88 g80 g72 g81 g87 g82 g69 g86 g72 g85 g89 g68 g87 g76 g82 g81 g86 g76 g20 g17 g17 g13 g77 g72 g70 g87 g20 g17 g17 g13 g19 g17 g17 g20 fig.
.
the diagram data revealing one level of details of the structure of the astronomical data and the entities that collect this data.
data is created by instruments that are located on observing platforms.
platform has a physical location.
in addition the system keeps track of the location in which the observations are stored.
our next refinement was to reveal the hierarchical structure of the data collected by the system.
in the refined model the data object entity becomes a super type of three different kinds of entities physical constants observations and data sets.
only data sets may hold collections of data objects see fig.
.
we have then turned our attention to the structure of the observation platforms.
we have learned from the original diagram that an observing platform can be either a stationary observatory or a spacecraft.
spacecrafts have an orbit that we believed represents their location we show this refinement in fig.
.
but it turned out that we had a mistake.
the problem is with the multiplicities of the two associations.
the location is an to association and so by the onto constraint sect.
ii b the source of orbit must be equal to observingplatform .
however the source of orbit isspacecraft which leaves g20 g17 g17 g13 g79 g82 g70 g68 g87 g76 g82 g81 g20 g17 g17 g13 g39 g68 g87 g68 g3 g54 g72 g87 g47 g82 g70 g68 g87 g76 g82 g81 g50 g69 g86 g72 g85 g89 g76 g81 g74 g3 g51 g79 g68 g87 g73 g82 g85 g80 g44 g81 g86 g87 g85 g88 g80 g72 g81 g87 g82 g69 g86 g72 g85 g89 g68 g87 g76 g82 g81 g86 g70 g82 g79 g79 g72 g70 g87 g76 g82 g81 g13 g76 g81 g86 g87 g85 g88 g80 g72 g81 g87 g86 g39 g68 g87 g68 g3 g50 g69 g77 g72 g70 g87 g50 g69 g86 g72 g85 g89 g68 g87 g76 g82 g81 g51 g75 g92 g86 g76 g70 g68 g79 g3 g38 g82 g81 g86 g87 g68 g81 g87 g13 fig.
.
the diagram data object elaborating the hierarchical structure of data objects.
note that one end of observations is now mandatory whereas in the abstract diagram it was optional.
g39 g68 g87 g68 g3 g50 g69 g77 g72 g70 g87 g47 g82 g70 g68 g87 g76 g82 g81 g50 g69 g86 g72 g85 g89 g76 g81 g74 g3 g51 g79 g68 g87 g73 g82 g85 g80 g44 g81 g86 g87 g85 g88 g80 g72 g81 g87 g82 g69 g86 g72 g85 g89 g68 g87 g76 g82 g81 g86 g20 g17 g17 g13 g20 g17 g17 g13 g76 g81 g86 g87 g85 g88 g80 g72 g81 g87 g86 g54 g83 g68 g70 g72 g70 g85 g68 g73 g87 g50 g69 g86 g72 g85 g89 g68 g87 g82 g85 g92 g50 g85 g69 g76 g87 g82 g85 g69 g76 g87 g82 g85 g69 g76 g87 g314 g79 g82 g70 g68 g87 g76 g82 g81 fig.
.
the diagram platforms a different refinement of the diagram data in fig.
revealing the structure of the observing platforms.
the refinement is wrong as it maps orbit tolocation leaving observatory without a location.
g39 g68 g87 g68 g3 g50 g69 g77 g72 g70 g87 g3 g48 g72 g87 g68 g71 g68 g87 g68 g39 g68 g87 g68 g3 g54 g72 g87 g39 g68 g87 g68 g3 g50 g69 g77 g72 g70 g87 g51 g75 g92 g86 g76 g70 g68 g79 g3 g38 g82 g81 g86 g87 g68 g81 g87 g13 g50 g69 g86 g72 g85 g89 g68 g87 g76 g82 g81 g48 g72 g87 g68 g71 g68 g87 g68 g39 g68 g87 g68 g3 g54 g72 g87 g3 g48 g72 g87 g68 g71 g68 g87 g68 g54 g72 g87 g87 g68 g70 g82 g79 g79 g72 g70 g87 g76 g82 g81 fig.
.
the diagram metadata elaborating the relationships between the structure of data objects and their meta data objects.
observatory without a location.
this analysis has led us to the conclusion that orbit is not a concrete representation of location but rather an additional kind of location that is unique tospacecraft entities.
the correct refinement appears online.
another interesting refinement concerns the relationship between the data objects and their meta data.
in astrogrid the meta data objects record where the data objects observation measurements are being stored.
at the abstract level we simply associate each data object with its meta data object.
however as we can see in the original diagram meta data for data sets is different from meta data for data objects.
we present this state of affairs in fig.
.
interestingly even though this is a valid refinement it appears there is a mistake in the original diagram.
because data sets are also data objects they now have two meta data objects one that they get by inheriting from data object and one that they get directly.
for lack of space we do not describe all the refinements in the refinement tree and we show only the interesting parts of the diagrams.
the full diagrams are available on the website.
if we combine the diagrams in the leaves into a single diagram we get back the original diagram.
nevertheless it is much more convenient to first select a particular topic from the tree and then look at the relevant diagram that has about classes rather than struggling to locate the relevant information in a diagram that consists of about classes.
to conclude if we had just tried to abstract the model without the assistance of diagram refinement we would have probably not detected the mistake that we have just described authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
it is subtle and requires careful attention and among all the details in the model there was nothing a priori that could have directed us to suspect these particular abstractions.
iv .
a m a thema tical founda tion in this section we show that class diagrams naturally translate into graphs and that a valid refinement translates into a graph homomorphism.
as a result we can be certain that our definition of refinement is internally consistent.5but first some preparatory definitions.
a class diagram dis a tuple d d0 d1 where d0is the set of classes in the diagram d1is the set of associations in the diagram and is the transitive closure of the subtype relation between the classes in the diagram we demand that is a partial order .
we will write a x yto assert that the association ais an association between the class xand the class y. in that case we may also write source a xand target a y.6finally we will assume that every class diagram has an implicit class latticetopthat is the supertype of all the classes in the diagram.
this can always be achieved in our mathematical framework and it will simplify the mathematics.
diagram refinement rbetween a concrete diagram cand an abstract diagram a is a pair of functions r0 r1 where r0 c0 a0maps classes in the concrete diagram c0 t o classes in the abstract diagram a0 and r1 c1 a1maps associations in the concrete diagram c1 to associations in the abstract diagram a1 .
the refinement is valid exactly when b1.
r0is a partial bijection injective and surjective b2.
r1is surjective b3.
c c1 a a1 r1 c a r0 source c r0 source a r0 target c r0 target a b4.
a1 a2 a1 a1 a2 r a1 r a2 .
these rules are a formal translation of the informal rules that we have given in sect.
ii a except that the two implications in the final equivalence represent rules and together.
from conditions b1 and b4 above we see that in a valid refinement r0is injective and monotonic with respect to the subtype relation.
unfortunately r0is not total and this may complicate the mathematics that will follow.
it will therefore be useful to define a total function that will complete whatever is missing in r0.
let us call this function .
we define as c r0 min c prime d o m r0 c c prime where by min s we mean the class in sthat is a subtype of all other classes in s or the special class latticetopif no such class exists.
we assume that r0maps latticetopto latticetop.
intuitively traverses a path from cupwards through the subtype hierarchy looking for the first supertype of cthat r0maps to a class in the abstract diagram and maps cto that class see fig.
.
a useful property of is that when ris valid then for any concrete association that r1maps r1 x y x y .
5we plan to consider multiplicity constraints in future work.
6this notation facilitates referencing the ends of associations.
it does not define a direction.
g68 g69 g53 g20 g11 g88 g89 g12 g36 g37 g56 g21 g57 g20 g56 g22 g57 g81 g56 g80 g57 g20 g53 g19 g11 g56 g21 g12 g53 g53 g19 g11 g57 g20 g12 g56 g20 g3896 g11 g56 g20 g12 g3896 g11 g56 g21 g17 g17 g80 g12 g3896 g11 g57 g20 g17 g17 g81 g12 g88 g89 fig.
.
the structure of a valid refinement.
rmaps the association uv toab even though umand vnare not mapped.
but as v1is the least supertype of vnthat is mapped by r and similarly for um we have r1 uv source uv target uv .
g51 g72 g85 g86 g82 g81 g51 g51 g72 g85 g86 g82 g51 g83 g68 g85 g72 g81 g87 g86 g17337 g76 g51 g76 g76 g17337 g17337 g51 g72 g85 g86 g82 g76 g51 g17337 g51 g72 g85 g86 g82 g81 g80 g82 g87 g75 g72 g85 g41 g72 g80 g68 g79 g72 g48 g68 g79 g72 g76 g41 g51 g76 g48 g51 g68 g79 g72 g80 g82 g87 g75 g72 g85 g76 g76 g41 g51 g48 g68 g79 g76 g48 g51 g76 g48 g51 g73 g68 g87 g75 g72 g85 g76 g76 g17337 g17337 g17337 g17337 g76 g51 g80 g76 g51 g17337 g76 g48 g48 g17337 g76 g41 g76 g41 g41 g17337 g17337 fig.
.
the graphs that correspond to the class diagrams in fig.
.
to avoid cluttering the graphs we did not draw the future edges there is a future edge between any two vertices in each graph and the inverse association edges.
diagrams are graphs given a class diagram d w e construct a graph g d whose vertices are d s classes and whose edges correspond to associations between the classes ofd.
for each association abetween aand bwe define two edges a a band a b a. this way we capture the fact that in uml an association has two ends.7in addition whenever class bis an immediate subtype of class a w e add to the graph an inclusion edge iba b a. the edge ibarepresents a total injection from the instances of bto the instances of a making the subtype relation between the two classes explicit.
next for each pair of vertices xand yin the graph we add an edge future xy x y. this edge represents any associations between xand ythat future refinements may create.
finally we add to the graph the vertex latticetop and add an edge ix latticetop x latticetop for every vertex xin the graph.
the vertex latticetoprepresents the supertype of all the classes in the diagram much like the class object is the base class of all the classes in java .
the reason for this particular construction will become apparent in the next section.
for example the two diagrams we used in fig.
correspond to the two graphs shown in fig.
.
7if our diagram has associations with different names for each role we give each edge in the pair the name of the corresponding role.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
v alid refinement homomorphism a graph homomorphism hfrom graph gto graph g primeis a pair of functions h h0 h1 where the first h0 takes the vertices of g to those of g prime and the second h1 takes the edges of g to the edges of g prime.
in addition this pair of functions must satisfy the property that if u m nis an edge in g then h1 u h0 m h0 n is an edge in g prime.
given a refinement r r0 r1 we define a function pair h r h0 h1 according to the following construction c1.
h0 c2.
if r1 a a primethen h1 a a primeand h1 a a prime c3.
if a x y dom r1then h1 a future h0 x h0 y and h1 a future h0 y h0 x c4.
h1 ixy ih0 x h0 y c5.
h1 future xy future h0 x h0 y .
we now prove the following theorem theorem r is a valid diagram refinement from diagram cto diagram aiffh r is a graph homomorphism that maps all vertices associations edges and inclusion edges of g a .
proof assume that ris a valid diagram refinement.
let a x ybe an edge in g c .
it is either an inclusion edge or a future edge or an association edge.
in the first case we know that the inclusion edge ih0 x h0 y exists in g a a s valid refinement maps subtypes to subtypes by rule b4 .
in the second case we know that future h0 x h0 y exists in g a since by construction there is a future edge between any two vertices ing a .
in the last case if rdoes not map a then h1maps a tofuture h0 x h0 y by rule c5.
finally if rdoes map a then by rule b2 and eq.
we have h1 a r1 a x y and from rule b1 we get that h1 a h0 x h0 y .
therefore if ris a valid diagram refinement then h r is a graph homomorphism.
now assume that ris not valid.
if rviolates rules b1 or b2 or b3 then h r will not map all the vertices or all the association edges or all the subtype edges of g a .i fi t violates rule b4 then h r will not be a homomorphism.
v. a dditional applica tions we now show additional applications of diagram refinement.
first we show that it is possible to use diagram refinement to formally capture design patterns in a class diagram and then we show that it is possible to use diagram refinement to improve the structure of use case diagrams ucds .
documenting design patterns refinement of class diagrams can explicitly capture design patterns in a concrete design.
for example fig.
top is a class diagram of a simple file system.
this is a clear example of the composite design pattern yet it has no formal relationship to thispattern diagram.
this is not a problem when the diagram is simple but when the class diagram consists of many nodes and associations it becomes difficult to identify the patterns especially as in many cases the same classes participate in several patterns.
for example a folder may also act as a subject in the observer pattern notifying interested observers about changes to the g13 g49 g82 g71 g72 g41 g76 g79 g72 g41 g82 g79 g71 g72 g85 g81 g82 g71 g72 g86 g13 g55 g85 g68 g70 g78 g72 g85 g41 g86 g82 g88 g85 g70 g72 g81 g82 g71 g72 g86 g88 g85 g70 g72 g86 g82 g88 refinement of composite node component file leaf f older composite nodes childrenrefinement of observer f older subject tracker observer source subject fig.
.
a class diagram that refines two patterns.
we show two refinement mappings to the composite and to observer design patterns.
we did not include the diagrams of these two well known design patterns to save space.
g58 g76 g87 g75 g71 g85 g68 g90 g3 g36 g88 g87 g75 g72 g81 g87 g76 g70 g68 g87 g72 g37 g68 g81 g78 g71 g85 g68 g90 g169 g76 g81 g70 g79 g88 g71 g72 g86 g170 g38 g88 g86 g87 g82 g80 g72 g85 fig.
.
a simple ucd of a customer withdrawing cash from an a tm.
here it is not clear that the bank is not involved in the card authentication step.
files that it contains.
by using class diagram refinement we can explicitly capture the relationship between design patterns and their manifestation in our particular design fig.
bottom .
refinement of use case diagrams ucds depict two separate concepts i the relationships between actors and the use cases in which they participate and ii the structure of the use cases.
this can often cause problems.
consider e.g.
the use case diagram in fig.
.
when a customer withdraws cash she first has to authenticate her card but this does not involve the bank.
the bank is only used later to authorize the cash withdrawal transaction and deduct the money.
how can we express this in the diagram?
currently the diagram simply depicts the customer and the bank as participating in the use case.
should we remove the link between the customer and withdraw and instead link it to authenticate ?
but this misses the fact that the customer participates in the entire use case.
should we just add a new link from customer toauthenticate ?
this is acceptable perhaps when the diagram does not contain a lot of include relationships otherwise it could quickly become flooded with arrows hindering our ability to understand it.
as before this is a case of looking at the same situation from different abstraction levels.
at the abstract level we are not interested in the internal composition of the use case thus we would draw it as in the upper part of fig.
.
at the more concrete level we describe the internal structure of the use case and then show which parts are relevant to which actors as in the lower part of the figure.
we translate a use case diagram into a graph in a similar way to how we translate a class diagram into a graph except that instead of the subtype relation we have include and extend relations.
as in the case of class diagram refinement the rules of use case diagram refinement are that whenever an edge ein the concrete diagram corresponds to an edge e primein the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g36 g88 g87 g75 g72 g81 g87 g76 g70 g68 g87 g72 g3 g56 g83 g71 g68 g87 g72 g3 g68 g70 g70 g82 g88 g81 g87 g3 g38 g88 g86 g87 g82 g80 g72 g85 g58 g76 g87 g75 g71 g85 g68 g90 g3 g37 g68 g81 g78 g38 g88 g86 g87 g82 g80 g72 g85 g17317 g37 g68 g81 g78 g58 g76 g87 g75 g71 g85 g68 g90 g3 g4534 g76 g81 g70 g79 g88 g71 g72 g4535 g4534 g76 g81 g70 g79 g88 g71 g72 g4535 fig.
.
an abstract use case and its refinement.
at an abstract level the withdraw use case has no structure.
at the concrete level we see its structure and can refine the arrows to indicate which parts are used by which actor.
abstract diagram the source and target of emust correspond to the source and target of e prime.
for example the edge adjacent tocustomer in the concrete use case corresponds to the edge between customer and withdraw in the abstract use case since authenticate is included by withdraw which corresponds to withdraw in the abstract diagram.
vi.
s emantics the semantics that underlies diagram refinement is best understood in terms of a simple relational model that consists of a finite collection of sets the sets may be infinite and relations between these sets.
when we refine an abstract collection of sets and relations the result is a new concrete collection of sets and relations from which we can assemble the original abstract collection.
to be more precise if a set a appears in the abstract collection then it should also appear in the concrete collection.
if a relation r a a primeappears in the abstract collection then it must appear in the concrete collection but it may be represented in the concrete collection by a set of relations xi ai a prime i provided that aiis a subtype ofaand that a prime iis a subtype of a prime.
this ensures that when we move from the abstract to the concrete representation we do not change the meaning of the relations.
we have defined our refinement rules precisely to ensure that this notion of consistency between the abstract and concrete diagrams is preserved.
given any kind of diagram if we can provide it with such a relational semantics we may use our refinement rules to support an incremental and consistent development of these diagrams.
we now demonstrate such a relational semantics for two uml diagrams.
these examples may also serve as models for the development of semantics for additional kinds of diagrams.
class diagram semantics we use a simple relational semantics for class diagrams.
we consider each class to represent the set of all its instances and interpret the subtype relationship as a subset relation.8in addition we interpret binary associations as binary relations.
as a result we can use relational composition to model navigation.
for example when we navigate from parent to itself twice we get the 8unless otherwise stated we interpret subtype as disjoint and complete.person male female male female father person male mother person femaleauthenticate withdraw update account withdraw customer authenticate bank update account fig.
.
on the left the semantics of the class diagram in fig.
.
on the right the semantics of the use case diagram in fig.
.
grandparent this corresponds to the relational composition parent parent .
finally we interpret attributes as functional relations.
an attribute aof class awhose type is tis a function afrom atot.
this way we do not have to make a special case for the semantics of attributes.
figure shows on the left the relational semantics of the class diagram in fig.
.
use case diagram semantics we consider each use case in the diagram to represent the set of all actors that participate in the use case.
when actor ais associated to use case uit means that ais a member of u. we consider the include and extend relationships as subset relations.
when use case aincludes use case b it means that bis a subset of a when aextends b it means that bis a subset of a.w e illustrate these ideas in fig.
where we show on the right the semantics of the use case diagram in fig.
.
vii.
r ela ted work hnatkowska et al.
define abstract laws for refinement of uml models.
they represent uml models as sets of terms and rules and establish laws for determining when a transformation of terms and rules is a valid refinement.
the discussion is very abstract and cannot be used as a tool by engineers.
in addition they insist that an abstract term must be refined by exactly one concrete term but we believe this is too strong.
for example it would rule out using mother and father to represent parent .
evans uses a formal semantics for class diagrams to define transformation rules for deducing an abstract class diagram from a more concrete one.
we have found that all the valid deductions in are also valid diagram refinements and all the invalid deductions are invalid diagram refinements.
bergner et al.
discuss the importance of refinement for the development of class diagrams.
this work however defines refinement to mean any kind of transformation between development levels.
it focuses on documenting the transformations but offers no way to check consistency.
ammar et al.
investigate refinement of models specified in uml ocl.
the paper describes the development of an access control system in a series of steps each step is a more detailed refined model of the previous step.
the development is similar to how one would develop a system in b or in event b but in contrast to these systems the paper does not offer a concrete set of rules for checking that the refinement is valid.
more recently they suggest to verify refinement by translating the uml class diagrams and ocl constraints into a b model.
ducournau et al.
describe the refinement of individual classes but not of associations in contrast to our approach authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
which is refinement of entire models.
its definition of refinement is informal.
shen et al.
describe a uml metamodel for checking refinement between class diagrams.
refinement is defined between individual classes and associations.
associations can only be refined to concrete chains.
they focus on a metamodel framework for enforcing refinement rules.
defining the rules is left to the developers.
later work discusses a technique for checking that a more concrete class diagram is consistent with an abstract one.
they compute an abstraction of the concrete diagram and compare it with the abstract diagram.
if the relationships in the two models differ the models are deemed inconsistent.
to generate the abstraction they compute the transitive closure of the relationships in the concrete diagram and keep only the relationships between classes that appear in the abstract diagram.
there are several important differences between this work and ours.
first our notion of refinement allows the concrete model to restrict the abstract model whereas demands exact equivalence.
second we support more ways in which concrete entities may represent an abstract entity.
in particular in diagram refinement several associations in a concrete diagram may represent the same abstract association.
the concrete model of our first example that has mother and father associations would not be considered consistent with its abstract version according to .
third diagram refinement extends to other kinds of uml diagrams whereas applies only to class diagrams.
finally because we use an explicit mapping between the concrete and the abstract models diagram refinement is much easier to check.
indeed it is feasible to check diagram refinement manually whereas the rules defined in must be checked by a machine for all but the smallest models.
pons et al.
discuss the refinement of classes and associations including the case where several concrete associations refine one abstract association heterogeneous refinement .
the paper illustrates refinement of individual constructs classes associations but has no rules for determining valid refinement in the general case.
in addition it ignores multiplicities.
cruz et al.
discuss refinement of use cases and use case diagrams.
like our work they argue that the use cases of a large system should be described by separate diagrams at different levels of abstractions with a refinement relation that links the concrete models to the abstract models.
however they do not consider include and extend relationships between use cases and their discussion is informal.
model subtyping facilitates the reuse of model transformations.
given a model transformation of a model a w em a y safely apply the transformation to any model that is a subtype ofa.
both diagram refinement and model subtyping are partial orders between models but they are different because they have different goals.
for example the concrete diagram in fig.
is not a subtype of the abstract diagram because any model transformation that expects to access the abstract parents relation will break on the concrete diagram which does not contain this association.model slicing is an abstraction technique that facilitates the verification of model properties by extracting from a model only those parts that are relevant to the property being checked.
model slicing is substantially different from diagram refinement first because it is applied to behavioral models and second because it requires a specific goal e.g.
a particular transition in a state diagram and throws away anything that is not relevant to that goal.
in contrast diagram refinement is a relationship between a detailed model and its summary.
nothing disappears but some things will appear in less details.
viii.
d iscussion we have described a set of rules for relating concrete diagrams to abstract diagrams.
the rules can be understood solely in terms of their informal meaning which makes them suitable for developers that are not proficient with formal mathematical foundations.
the mathematics that underlies the rules is used to ensure that they are consistent simple and sound.
we insist e.g.
that every class in the abstract diagram is mapped to exactly one class in the concrete diagram rule .
one may ask why not relax the rule and allow many concrete classes to be mapped to the same abstract class?
we have started our investigation with exactly this idea but the mathematical analysis has revealed many difficulties and complications with this direction.
upon further reflection we have noticed that whenever several concrete concepts c1 ... cnrepresent the same abstract concept a we can always add ato the concrete class diagram and have each ciinherit from a. therefore we do not lose anything by insisting on the uniqueness rule and in return greatly simplify our framework.
the mathematical framework that we have developed has two parts.
the first part is a generic notion of refinement defined in terms of graph homomorphisms mathematical transformations between graphs that preserve their structure.
this notion of refinement ensures that whenever a graph represents a relational model any valid refinement of the graph yields a more detailed relational model that is consistent with the original model.
the second part which is unique to every diagram type is the relational semantics that we define for each diagram type.
by separating the mathematical framework into two parts we make it possible to support additional diagram types with a single formal notion of refinement.
as long as we can develop a relational semantics that represents the relationships in the diagram we can use diagram refinement to help us develop such diagrams incrementally and consistently.
in the future we plan to implement a prototype tool to automatically check for diagram refinement and to support additional diagram types.
in addition we plan to extend the theory to deal with maintaining consistency between several concrete diagrams that refine the same abstract diagram.
acknowledgment we would like to thank mr. tony linde for letting us use his astrogrid conceptual domain diagram in this paper.
this work has been partially supported by gif grant no.
.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.