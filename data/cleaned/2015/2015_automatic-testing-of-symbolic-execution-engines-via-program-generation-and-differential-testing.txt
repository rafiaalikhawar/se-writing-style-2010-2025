automatic testing of symbolic execution engines via program generation and differential testing timotej kapus cristian cadar imperial college london united kingdom ft.kapus c.cadarg imperial.ac.uk abstract symbolic execution has attracted significant attention in recent years with applications in software testing security networking and more.
symbolic execution tools like crest klee fuzzball and symbolic pathfinder have enabled researchers and practitioners to experiment with new ideas scale the technique to larger applications and apply it to new application domains.
therefore the correctness of these tools is of critical importance.
in this paper we present our experience extending compiler testing techniques to find errors in both the concrete and symbolic execution components of symbolic execution engines.
the approach used relies on a novel way to create program versions in three different testing modes concrete single path and multi path each exercising different features of symbolic execution engines.
when combined with existing program generation techniques and appropriate oracles this approach enables differential testing within a single symbolic execution engine.
we have applied our approach to the klee crest and fuzzball symbolic execution engines where it has discovered different bugs exposing a variety of important errors having to do with the handling of structures division modulo casting vector instructions and more as well as issues related to constraint solving compiler optimisations and test input replay.
i. i ntroduction symbolic execution has established itself as an effective testing method with many research groups working on improving various aspects of it.
the technique has also started to be used in the industry with several companies reporting successful adoption .
key to this progress has been the availability of symbolic execution tools which allows industrial users to apply and extend the technique and researchers to experiment with new ideas.
notable examples include opensource tools crest klee fuzzball and symbolic pathfinder and closed source tools pex and sage .
therefore the quality of these symbolic execution tools is essential for continuous progress in this area.
in this paper we present our experience adapting techniques from the compiler testing area which has seen tremendous success in revealing important bugs in popular compilers for testing symbolic execution engines.
more precisely our techniques are based on program generation and differential testing adapted to exercise several key inter related aspects of symbolic execution tools execution fidelity accuracy of constraint solving correct forking and faithful replay that is whether the symbolic execution tool correctly follows the paths it intends to follow gathering precise constraints in theprocess and whether the generated inputs execute the same paths as the ones followed during symbolic execution.
our method is effective for both symbolic execution tools which keep multiple path prefixes in memory as in exe klee mayhem symbolic pathfinder and s2e as well as for those which implement the concolic variant of symbolic execution in which paths are explored one at a time as in dart crest and cute .
one of the key ingredients of modern symbolic execution techniques is mixed concrete symbolic execution .
a reliable tool has to correctly implement both execution types.
on the concrete side symbolic execution engines either embed an interpreter for the language they analyse java bytecode in the case of symbolic pathfinder llvm ir in the case of klee and x86 code in the case of sage or modify and instrument the code statically e.g.
both crest and exe first transform the program using cil and instrument it at that level.
as we show in this paper the execution fidelity of the interpretation or instrumentation can be effectively tested by adapting program generation and differential testing techniques employed in compiler testing .
on the symbolic side the accuracy of the constraints gathered on each explored path is of critical importance if symbolic execution tools are to avoid exploring infeasible paths and report spurious errors and generate inputs that when run natively follow the same path as during symbolic execution.
our approach tests the symbolic execution component in two ways.
first by constraining the initial inputs to follow a single path.
the key idea is simple but effective starting from an automatically generated or real program we create program versions which produce output for one path only say when the integer input x has value and then we check whether the symbolic execution correctly follows that path and outputs the expected results.
second by running small programs symbolically and verifying that the generated inputs are consistent with the paths followed.
in both the concrete and symbolic cases our approach is based on differential testing in which symbolic execution runs are crosschecked against native runs.
an effective crosschecking needs to employ effective and inexpensive oracles that is oracles that find important bugs and do not add a significant runtime cost.
we use four different oracles crashes of the symbolic execution tool and whether the two executions produce identical outputs generate the same sequence .
c ieeease urbana champaign il usa technical research experience report590 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
the main stages of our testing approach.
of function calls and achieve the same coverage.
in both the concrete and symbolic cases our approach also takes advantage of advances in automatic program generation which allows us to quickly create small deterministic programs without undefined and unspecified behaviour and therefore conduct a large number of experiments.
finally whenever a generated program finds a bug in the symbolic execution tool we use existing program reduction techniques which are combined with our oracles in order to obtain a small program with fewer than lines of code in our experiments that forms an easy to understand reproducible bug report.
we applied our approach to the klee crest and fuzzball symbolic execution engines where it has found several serious functionality bugs most of which have already been fixed or confirmed by the developers.
in summary the main contributions of our paper are our experience adapting compiler testing techniques to the novel problem of finding errors in both the concrete and symbolic execution components of symbolic execution engines a novel way to create program versions in three different testing modes which combined with existing program generation techniques and appropriate oracles enables differential testing within a single symbolic execution engine a toolkit implementing our approach together with comprehensive case studies on three symbolic execution engines klee crest and fuzzball implementing different styles of symbolic execution e.g.
concolic vs. keeping all paths in memory interpretation vs. instrumentation and operating at different levels source llvm bitcode and binary .
our approach found important bugs in these engines.
the rest of the paper is structured as follows.
ii gives an overview of our technique showing how we generate randomprograms ii a and create versions of these programs ii b to be crosschecked using four different oracles ii c and reduced to produce small bug reports ii d .
iii presents our case studies on the klee crest and fuzzball systems reporting the effectiveness and performance of our technique.
the lessons learned from the case studies are then presented in iv.
finally v discusses related work and vi concludes.
ii.
t esting approach the main stages of our testing approach are shown in figure .
the inputs are a symbolic execution engine to be tested and a configuration file specifying the parameters of the testing process such as symbolic executor flags and timeouts.
in the first stage generate programs in the figure we generate random deterministic programs with the csmith tool and instrument them to support our oracles.
in the second stage create run versions we create several different versions of a given generated program a native version designed to execute natively single path versions designed to run a single path when executed symbolically and multi path versions designed to run multiple paths when executed symbolically.
these different versions are run and crosschecked using our four oracle types crash detection and output function calls and coverage comparison employ oracles .
any programs exposing mismatches as flagged by our oracles between the native and symbolic execution runs gather mismatches are then reduced using the c reduce tool reduce programs and reported to developers.
while our testing approach is general our infrastructure is targeted toward symbolic execution of c code.
a. generating random programs the first step of our approach is to generate small programs using the csmith tool used in compiler testing.
csmith is a tool that can generate non trivial c programs that leverage authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
many features of the c language and which has been used successfully to find many bugs in mature compilers .
csmith generates programs in a top down fashion.
it starts by creating a single function which is called from main.
csmith then randomly picks a structure from its grammar and checks if it is appropriate for the current context e.g.
continue can only appear in loops .
should the check fail it makes a different choice until it succeeds.
if the chosen structure needs a target e.g.
a variable to read or a function to call it randomly chooses between using an existing construct and generating a new one.
care is taken not to generate constructs with undefined or unspecified behaviour e.g.
by guarding every division operation to ensure the divisor is not zero.
if the selected structure is a non terminal the process repeats.
finally csmith performs several safety checks to ensure there cannot be any undefined or unspecified behaviour.
if that fails the changes are rolled back and the process starts from the most recent successful stage.
the generated programs take no input perform some deterministic computation and output the checksum of all global variables which gives an indication of the state of the program upon termination.
the length and complexity of the generated code is highly configurable.
with the options we used the generated programs are on average lines long containing about functions and global variables.
the global variables can have a wide range of types signed and unsigned integers of standard widths arrays randomly generated structs and unions pointers and nested pointers.
the functions take varying number of arguments of different types and return a randomly chosen type.
function bodies declare several local variables and include ifand forstatements which in turn contain assignments to both local and global variables.
the expressions assigned are deep and nested reading from and writing to multiple global and local variables performing pointer and arithmetic operations and calling other functions.
there are several reasons for using csmith generated programs as opposed to using real software csmith programs are valid c programs without undefined or unspecified behaviour.
this is important because the compiler used to generate the native version of the program and the engine used to symbolically execute the program might take advantage of undefined or unspecified behaviour in different ways which might lead to spurious differences.
csmith programs by design have a good coverage of c language features which a limited collection of real programs might miss.
most of the language features being used in csmith programs can be enabled or disabled via command line arguments.
this is important because once the symbolic execution tool is found to mishandle a certain feature we want to be able to continue testing without repeatedly hitting that same bug.
csmith programs are deterministic and the input and output are easily identifiable the input is represented by the set of global variables in the program and the output consistsof a checksum of the global variables which is printed at the end of the execution.
unlike real programs csmith programs are relatively small or more exactly csmith can be configured to generate small programs which allows us to perform a large number of runs.
disadvantages of csmith programs and automatically generated programs more generally are that they are artificial hard to read by humans and not guaranteed to terminate.
we address the readability issue by automatically reducing the size of the program ii d and the non termination issue by using timeouts as recommended by the csmith authors iii a2 .
b. creating and running versions for each generated program we first create and run an unmodified native binary version of the program.
then for each of our three testing modes we create a modified version of the program to be run by the symbolic execution engine under test.
c mode concrete mode this mode is designed to test the concrete execution of the symbolic execution engine.
for this mode we run the program with the symbolic execution engine without marking any variable as symbolic.
for example we would compile the code to llvm bitcode and then run it with klee directly without any symbolic input.
the symbolic execution run is then validated against the native one using our oracles ii c .
for example the function call chain oracle would check that the native and symbolic runs generate the same sequence of function calls.
sp mode single path mode the aim of this mode is to test the accuracy of the constraints gathered by symbolic execution and its ability to correctly solve them.
essentially this mode is checking the symbolic execution of individual paths in the program.
for this mode we modify the code to mark all the integer global variables of the generated program as symbolic and constraining them to have the unique value assigned to them in the original program.
this essentially forces the symbolic execution engine to follow the same execution path as in the native version but also collect and solve constraints on the way.
constraining a variable to have a unique value needs to be done in such a way that the symbolic execution engine does not infer it has a unique value and reverts to concrete execution for that variable .
in particular assigning a symbolic variable to have a constant value e.g.
x or comparing it with a constant e.g.
if x would typically make the engine treat that variable as concrete on that path.
we used four different ways of constraining a symbolic variable xto a given value v which are listed in table i. for example the second method adds the constraint that x is less than or equal to vand greater than or equal to v while the fourth method adds the constraint that xis divisible by all the prime divisors of v is greater than 1and less than or equal to v. at the implementation level for each integer global variable initialization such as intx we add the following authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i four ways of constraining a variable xto a constant value v. diis a prime divisor of v. constrainer type constraint x v x v x v x v range x v x v x v x v x v divisors i x moddi6 x x v code at the start of main should we for example follow the first constraining method make symbolic x i f x s i l e n t e x i t i f x s i l e n t e x i t in this code the make symbolic function is used to mark the given variable as symbolic while the silent exit function terminates execution without generating a test input on that path.
therefore after executing the code fragment above the symbolic execution engine will continue along a single path with the path condition x x which effectively constrains xto value .
once such a version of the program is constructed its execution can be validated using our oracles as for the previous c mode.
note that one oracle that is effective here as we show in the evaluation is to check that the symbolic execution engine executes a single path.
however we didn t add an explicit oracle for this as other oracles such as the function call oracle would almost always catch such a bug.
mp mode multi path mode while the prior mode tested that the engine correctly performs symbolic execution of a given path this final mode checks that symbolic execution explores multiple paths and generates inputs that exercise exactly those paths.
for this mode we simply mark all integer global variables as symbolic without constraining them to any value and let the symbolic execution engine explore multiple execution paths.
as a result not all oracles are applicable to this mode.
in particular we could not use the output oracle for non concolic execution engines as the output could now be a function of some symbolic variables.
besides the crash oracle we decided to solely use the function call chain oracle which was the easiest to adapt for this scenario.
our approach was to record the sequence of function calls on each path explored during symbolic execution and then for each path to run natively the generated test input and check whether it generates the same function call sequence.
c. oracles we next discuss in detail the four oracles that we used in our approach.
executor crash oracle the first basic oracle consists in detecting generic errors during symbolic execution runs such as segmentation faults assert violations and other abnormal terminations.
output oracle as discussed in ii a csmith programs are designed to have no undefined or unspecified behaviour and produce deterministic output.
more exactly the programs print at the end a single value the checksum of all global variables.
for c mode we simply compare the checksums printed out by the native and symbolic execution runs.
for sp mode we found that computing checksums for symbolic variables is very expensive resulting in many timeconsuming solver queries.
our solution was to exclude the symbolic variables from the checksum computation and instead simply print out their individual values.
for non concolic engines we first ask the constraint solver for a solution which in this case is unique before printing out the symbolic value.
function call chain oracle the function call chain oracle compares the sequence of function calls executed by the native and symbolic execution versions.
this oracle provides the ability to catch some bugs where symbolic execution follows the incorrect path but without having any influence on the output.
for c mode and sp mode this oracle checks that the unique path followed by the symbolic execution engine produces the same sequence of function calls as the native execution.
for mp mode this oracle checks that when natively replaying a generated input the same function call sequence is produced as in the corresponding path explored during symbolic execution.
because some execution paths may not be fully explored by non concolic tools in mp mode due to timeouts we actually check that the function call chain generated during symbolic execution is a prefix of the corresponding native function call chain.
coverage oracle the coverage oracle was used in a similar way as the function call chain oracle to ensure that the native and symbolic execution runs execute the same lines of code the same number of times.
while we could have used this oracle in mp mode as well to check whether the natively replayed execution covers the same lines of code as during the corresponding path explored during symbolic execution we found this more difficult to implement efficiently.
one interesting challenge we faced while implementing this oracle is that even when gathering coverage information on a single execution path the performance overhead was extremely high.
the problem was that the instrumentation would generate select instructions to index into an internal buffer used to track coverage which would make that buffer symbolic leading in turn to expensive constraint solving queries.
once we diagnosed the issue the solution was simple we modified the gcov instrumentation to generate explicit branches instead of select instructions.
this made a huge impact on performance making this oracle usable.
more generally this is an issue that one has to be aware of during symbolic execution when instrumenting programs with coverage information.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
d. reducing bug inducing programs as indicated before our csmith programs are on average lines long and hard to read by human developers.
the code consists of huge nested expressions without any highlevel meaning referring to mechanically named variables.
debugging such programs would be highly difficult.
therefore for each generated program that exposes a bug we used the c reduce tool to reduce it to a manageable size.
at a high level c reduce tries various source level transformations to reduce a c program e.g.
deleting a line and then uses an oracle in the form of a shell script to decide if the transformation was successful.
if so c reduce keeps the reduced program and attempts to reduce it further otherwise it rolls back the change and tries other transformations.
integrating c reduce in our bug finding process was easy as we were able to reuse the same oracle as the one used to find the bug in the first place.
some manual effort was necessary but it was modest overall as we discuss in iv.
one challenge is that unlike csmith c reduce can introduce undefined behaviour.
luckily compilers report most of those undefined behaviours as warnings.
we integrated these warnings into our oracles making them reject reduced programs that trigger these specific warnings.
iii.
c ase studies this section presents our experience applying our testing approach to find bugs in the klee crest and fuzzball symbolic execution engines.
we provide an artifact with additional details about our case studies at ac.uk projects symex tester .
a. klee our main case study uses klee a popular symbolic execution engine for c code that operates at the level of llvm bitcode.
we chose klee for our main case study because we are familiar with it it is actively maintained highly configurable and documented.
as we discuss later this is important in order to be able to iteratively find new bugs.
we start by describing our experimental setup iii a1 and methodology iii a2 and give an overview of our experimental runs iii a3 .
we then present a summary of the bugs found and discuss a few representative bugs iii a4 .
we finally discuss our experience applying our approach to a real application iii a5 .
experimental setup we used the klee commit 637e884bb for all our experiments.
klee was built using llvm .
.
and stp commit a74241d5.
initially we used version .
of stp in a small number of our experiments.
we used csmith .
.
c reduce commit 49782e718 and clang .
.
the experiments were run in parallel on an core .5ghz intel xeon e3 machine with 16gb of ram.
to automate the experiments we have built a toolset consisting of a library and several scripts.
it contains the 1we haven t treated all warnings as errors as csmith programs already generate some warnings during compilation.implementation of the oracles including the functions used to constrain symbolic variables to a single value see table i and the necessary tools to deploy our technique including generating compiling running and reducing csmith programs.
methodology we conducted our experiments in batches with essentially one batch for each bug found.
in each batch we performed the following steps configure the experiment what kind of programs to generate mode to use options to pass to klee .
we started with the default configuration of csmith and klee.
run the experiment typically overnight .
reduce the first program exposing a bug and sometimes further manually simplify it slightly to make it more readable.
report the bug attaching the reduced program.
find a way to avoid the bug and reconfigure the experiment accordingly.
the reason for the last step is that we observed that certain bugs would reappear over and over again making it difficult to identify new bugs.
therefore we adopted an iterative approach in which once we identified a bug we worked on either fixing it or incorporating the developers fix if available in a timely manner or more often reconfiguring our experiment to avoid it.
in the latter case we either disabled some c features in csmith so that the bug would not be triggered for example once a bug involving incorrect passing of structures by value was found we disabled passing structures as arguments or changed the klee options so that the affected code would not run for example by disabling the counterexample cache which was involved in one of the bugs .
at the end of our experiments we were using the options no arg structs no return structs no arg unions no divs and no const in csmith and check overshift false and use cexcache false in klee.
in mp mode we also used the nochecksum option in csmith to disable the expensive checksum computation since the output oracle was not used.
we used either the o0 or o1 optimisation levels to compile the generated programs each with equal probability.
we also attempted to use higher optimisation levels however every csmith generated program compiled with optimisation level o2 or higher exposes the vector instruction unhandled bug in klee iii a4 and therefore we only used these higher optimisation levels for a small number of runs.
we used a 1s timeout for the native execution of csmith programs as a longer runtime is a strong indication of nontermination.
we did not use a timeout in c mode for klee as we knew from the native run that the program should terminate.
the timeouts for klee in sp mode and mp mode were set to 100s as we accounted for constraint solving.
in mp mode we also set the maximum number of forks i.e.
paths to be explored to .
summary of runs in total we have generated and tested almost programs.
a summary of all the runs can be found in table ii.
they are divided by the different modes they used.
we performed most runs around in c mode authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii summary of runs in different modes .
mode runsavg input size loc avg time per run s native klee c .
.
sp .
.
sp .
.
sp range .
.
sp divisors .
.
sp coverage1 .
.
mp .
.
1combined runtime of all replayed test cases.
which as expected have the shortest average running time.
we conducted around runs in sp mode which on average took twice as long as those in c mode.
finally we performed runs in mp mode which were around times more expensive than those in c mode.
note that the average runtime for native runs in mp mode includes replaying all generated test cases.
overall we spent around around hours in cmode around hours in sp mode and around hours in mp mode.
the technique found the bugs within the first runs of each batch.
this means that we could have configured the batches to run for only .5h but we found it convenient to do longer overnight runs.
for sp mode table ii also shows the number of runs performed with each way of constraining inputs to a single value.
the runs involving inequalities and ranges took a similar amount of time while those involving divisors took longer as they involved more difficult constraints.
we excluded the expensive coverage oracle in all runs except sp mode runs with constraints which took around seconds per run on average.
we observed that using the coverage oracle involves about ten times more instructions as the instrumentation also uses code from libc and a significant number of extra i o operations all of which contribute to the significantly higher cost per run.
finally note that individual runs in sp mode and mpmode varied considerably depending on the constraint solving queries generated in each run.
for instance sp mode runs ranged between .01s to .6s remember our sp mode timeout was 100s .
the reason some runs were very quick was that only a small part of the code was executed at runtime.
bugs found table iii summarises the bugs we have found using our approach.
we reported all bugs to the developers except one which had already been reported and another three which had already been fixed before we managed to report them.
we also reported a bug which we later discovered to have been reported before.
at the time of writing the bugs in bold had already been fixed.
as can be seen from table iii we have found a variety of bugs involving the handling of structures division modulo 1union u0f signed f3 3g 5s t a t i c union u0 g f0ulg 7i n t main i n t argc char argv f g988 .
f3 p r i n t f f3 dnn g .
f3 return 11g listing .
reduced program exposing a bug where union fields are not updated correctly.
the native run correctly prints f3 while the klee run prints f3 .
include s t d i n t .
h 2s t a t i c i n t t g 3i n t t func f p r i n t f f u n c t i o n c a l lnn return 6g 8void main f klee make symbolic g sizeof g976 i n t t l1985 g 11lbl2550 func l1985 i f l1985 goto lbl2550 16g listing .
program exposing division by bug in klee.
casting vector instructions and more as well as issues having to do with constraint solving compiler optimisations and test input replay.
these bugs were revealed by different modes and oracles.
we found bugs in c mode bugs in sp mode and bugs in mp mode with bugs found in both sp mode and mp mode.
in terms of oracles the crash oracle found bugs the output oracle and the function call chain oracle with bug found by both the output and the function call chain oracles.
as mentioned before the size of the csmith programs we generated is on average lines of code.
the last column of table iii shows the size of the reduced programs.
in all cases c reduce managed to reduce the programs substantially to fewer than lines of code with most at under lines.
below we give some examples of the bugs found by our approach including the reduced programs that were reported to developers.
some unions not retaining values.
listing shows an example of a bug found in c mode.
the program initialises a union containing a signed field of non standard length and then writes to that field and prints it.
running the program natively correctly prints out while running it with klee prints out which represents the lower bits of .
the root cause of this bug is an optimisation in klee which uses faster functions for memory writes of sizes and bits.
the code contained a check which enabled the optimisation only if the write in question was less than or equal to bits.
if this was not the case the slower general approach was used.
this incomplete check caused the program authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii summary of bugs found in klee including the mode used the oracle s that detected them and the size of the reduced program used in the bug report .
issues in bold have been fixed .
more details on these bugs can be found at h t t p s g i t h u b .c o m k l e e k l e e i s s u e s i s s u e .
issue bug description mode oraclereduced size loc some unions not retaining values c output incorrect by value structure passing c output invalid overshift error triggered by optimisation bug in llvm c output vector instructions unhandled caused by o2 optimisations c output floating point exception c crash incorrect handling of division by spfunction calls output17 execution forks unexpectedly sp function calls segmentation fault due to operator sp crash n a2incorrect casting from signed to unsigned short sp output abnormal termination in stp solver sp mp crash n a1assertion failure in stp solver .
sp mp crash replaying read only variables not handled mp crash file system model and replay library interplay mp function calls n a2divergence b w test generating path and test replay path mp function calls 1not explored further as the bug seems to have been fixed in the newest release of stp.
2fixed prior to reporting as the side effect of what looks to be an unrelated patch.
1i n t a b 2s a f e l s h i f t f u n c i n t tsu short p1 p2 f p1 0jjp1 ?
p1 p2 4g 6main f klee make symbolic a sizeof a i f a i n t k l e e s i l e n t e x i t i n t i a a s a f e l s h i f t f u n c i n t tsu i ijjb 12g listing .
program triggering a segmentation fault in klee due to incorrect handling of some modulo expressions.
in listing for which llvm .
generates a memory access of size to run the optimisation path and thus behave incorrectly.
the bug has now been fixed.
incorrect handling of division by .
when executed natively the code in listing loops indefinitely.
the if statement at line keeps evaluating to true and therefore the execution jumps back to line .
in klee the ifstatement evaluates to false so klee terminates after a single iteration.
this bug was caught by both the output and function call chain oracles.
the bug was found in sp mode but the reported program does not constrain the symbolic variable to have a single value as we realised this is not needed to expose the bug so the automatically reduced program was several lines longer .
we also note that prior to running c reduce the csmith program exposed the bug without containing an infinite loop.
we initially managed to avoid this bug by disabling division expression generation in csmith but the bug was later1s t a t i c i n t a 2s t a t i c i n t b f1g 3void fn1 short p1 fp1 g 5s t a t i c long fn2 p1 f return p1 ?
7g 9i n t main f long c i n t d a c fn2 b d fn1 c 14g listing .
program that triggers a floating point exception in klee due to a missing division by zero check.
debugged and fixed by the developers.
the problem was that division by a constant is optimised prior to invoking the solver using multiplication and shift operations.
however the optimisation is incorrect for constants and .
the fix was to disable the optimisation for these special cases.
segmentation fault due to operator.
the code in listing causes a segmentation fault in klee.
the bug was found in sp mode and diagnosed by the developers to be caused by an incorrect semantics assigned to the operator when negative numbers were used as divisors.
the second part of the code that constrained variable ato have a single value was manually removed by us prior to reporting the bug as it was not needed to expose this bug.
floating point exception.
the code in listing triggers a floating point exception in klee.
the bug now fixed is due to a missing division by zero check when processing constant expressions that are not folded in the llvm bitcode.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv function call divergence in grep .
native fillbuf close stdout klee fillbuf grepbuf egexecute kwsexec close stdout grep case study we have also considered applying the techniques presented in this paper to real programs.
for this purpose we used the popular unix utility grep which finds lines of text matching a certain string pattern.
we found several mismatches in mp mode which were caught by the function call chain oracle.
an example of the difference between the function call chains executed on one path explored by klee and the corresponding native run can be seen in table iv.
we did not report this bug yet as we found it difficult to reduce c reduce works on a single c file and debug given the much larger size of grep .
overall this experience has reinforced our initial preference for using generated programs which present the advantages discussed in ii a. however with more engineering work our approach could be applicable to real programs too.
b. crest and fuzzball to show the generality of our technique we also applied it to two other symbolic execution engines.
we chose crest and fuzzball because they are different from klee in important ways crest is a concolic execution tool a variant of symbolic execution which differs significantly at the implementation level from the one used by klee while fuzzball is a symbolic execution for binary code which again results in significant differences in the way the tool is implemented.
at the implementation level to apply our framework to a new tool one obviously has to be aware of the way the code is compiled and run with each new symbolic executor.
also one needs to know the api the tool uses to mark inputs as symbolic.
we have defined a general interface for creating and constraining variables which enables us to use the same transformed program with multiple symbolic execution engines by simply changing the library we link with appropriately.
crest implements the concolic form of symbolic execution in which the code is executed on concrete values and constraints are gathered on the side.
to generate a new path one constraint is negated a new concrete input is generated and the process is repeated.
therefore one important difference with klee is that paths are explored one at a time.
a second important difference but orthogonal to the first is that crest instruments programs for symbolic execution using cil as opposed to interpreting them like klee.
we faced several practical difficulties when applying our approach to crest.
first crest is less feature complete than klee.
for example it does not support symbolic bit integers and its solver does not support some arithmetic operations such as modulo.
however we were able to work aroundtable v summary of bugs found in crest and fuzzball including the mode used and the oracle that detected them .
the sizes of the reduced programs vary between 8and 15lines of code .
issues in bold have been fixed .
issue bug description mode oracle crest github.com jburnim crest issues issue return struct errror c crash big integer in expression sp output non bit wide bitfields sp output fuzzball github.com bitblaze fuzzball fuzzball issues issue stp div by zero failure1sp crash strange term failure sp crash wrong behaviour sp output 1fixed in the upstream version of stp.
1unsigned i n t a 2i n t main f crestuint a p r i n t f a dnn a i f a f e x i t 7g 8g listing .
crest explores two branches in both of which ais smaller than .
these limitations by slightly tweaking our instrumentation and csmith configuration.
second and more importantly crest is not an actively developed project and the tool does not seem to expose many options to enable or disable various sub components like klee does.
therefore we found it difficult to find ways around the bugs we discovered in order to find new bugs.
in spite of these difficulties our approach found three bugs in crest within the first runs or about hours worth of computation time.
further experiments were not run with crest due to the pervasiveness of the bugs already found.
note that crest runs program paths significantly faster than klee or fuzzball which accounts for the short total computation time.
a summary of the bugs found in crest is shown in table v. the first bug is exposed in c mode by a program with functions that return structs or unions.
here the crest compiler throws an error when given such programs as input.
interestingly klee had a similar problem with structs and function calls.
the other two bugs are exposed in sp mode.
for instance the code in listing makes crest explore two branches with both having the same constraints.
the bug was caused by an incorrect use of the api of the constraint solver yices and has now been fixed.
fuzzball is similar to klee in that it implements the nonconcolic style of symbolic execution where execution starts with unconstrained symbolic variables.
on the other hand like authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1unsigned i n t g893 2i n t safe sub long long p1 i n t p2 f return p1 9223372036854775807ll p2 ?
p2 4g 5s t a t i c unsigned i n t magic symbols f0g 7i n t main f g893 magic symbols i f g893 e x i t i f g893 e x i t p r i n t f unn safe sub 1ul g 12g listing .
reduced program for which the native run correctly prints where the fuzzball run prints .
crest fuzzball executes paths one at a time keeping only a lightweight execution tree in memory.
finally like klee fuzzball interprets the code rather than instrument it for symbolic execution but does this at the binary rather than llvm bitcode level.
these design decisions make fuzzball an interesting complement to klee and crest for our technique.
the only engineering challenge we had to address to use our technique on fuzzball was related to the fact that unlike klee and crest fuzzball does not provide an api for marking variables as symbolic.
instead one has to specify on the command line the address range s that the tool should mark as symbolic e.g.
bytes starting with 0xdeadbeef .
therefore the library we created for fuzzball defines a large static array which we mark as symbolic from the command line.
at runtime when a variable is supposed to be marked as symbolic we get unused bytes from the static array and copy them to the variable to emulate the behaviour of make symbolic functions that symbolic execution engines like crest and klee provide.
with runs or about a day worth of computation time our approach has found three bugs in fuzzball all of which have been fixed.
further experiments were not run with fuzzball as the bugs have not been fixed promptly enough to run more batches.
a summary of the bugs found in fuzzball is shown in table v. like klee fuzzball uses stp as its main constraint solver and we managed to trigger the same stp bug while testing fuzzball.
the crash bug that we found stems from the fact that fuzzball is unable to distinguish between pointers and integers well due to the nature of machine code at which it operates.
however it still finds this distinction useful for various reasons therefore it employs some heuristics to classify words either into integers or pointers.
the program we generated causes this heuristic to fail.
the developers added further simplification rules and another command line option to help mitigate this issue.
the last bug causes fuzzball to compute the wrong results and is illustrated in listing .
the bug was debugged to a formula simplification rule that was incorrect when signed overflow occurred.
developers removed the rule to fix the bug.iv.
d iscussion and lessons learned the approach of combining program generation with our novel way of creating program versions in three different modes to be crosschecked by appropriate oracles was successful in finding important bugs in three different engines operating in different ways e.g.
concolic variant vs. keeping all paths in memory interpretation vs. instrumentation etc.
and at different levels source llvm bitcode and binary .
adapting compiler testing techniques.
overall we found existing compiler techniques to be a great match for testing symbolic execution engines.
in many ways both compilers and program analysis techniques like symbolic execution take as input programs so program generation techniques for compiler testing such as csmith can be easily reused in this new context.
on the other hand we found that the differential testing part where csmith programs compiled by different compilers are checked to ensure that they produce identical results is not easily translatable for checking symbolic executors.
the main problem is that different symbolic executors may explore different paths in a given time budget and also that the same code may have different number of paths at different levels e.g.
source binary and llvm .
therefore instead of performing differential testing between different symbolic execution engines we crosschecked native and symbolic execution versions of the same program with the symbolic execution versions carefully constructed in three different modes ii b .
we believe this approach could be applicable for testing other types of program analysers but the way in which different versions are generated would have to be guided by the specifics of each program analysis.
generated programs vs. real ones.
we noticed some of the bugs we found were also reported by users while running real programs but debugging large programs under symbolic execution is often incredibly difficult due to the many different variables involved.
for instance if symbolic execution fails to cover a part of the program this could be due to a bug in the constraint solver or a bug in the interpretation instrumentation or a limitation of the search heuristic used.
instead the programs generated by csmith and c reduce are small and the way we generate program versions for differential testing makes it easy to debug the root cause of the problem for instance program versions created in sp mode must follow a single path when executed symbolically and the path should be the same as the one executed by running the program natively on corresponding program inputs.
however as we discuss in section iii a5 our approach could be used to test symbolic execution engines with real programs too.
while we found it difficult to do so with grep developers familiar with the program might be able to more easily diagnose issues such as the function call divergence that we report in table iv.
finally the fact that some of the bugs we found were also reported by users suggests that our approach finds bugs that matter while also having the advantage that the bug reports are more easy to understand and debug.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
oracles.
overall the output oracle found almost half of the bugs followed closely by the crash oracle and at some distance by the function call oracle.
as explained in the paper we ended up using the coverage oracle only for a small number of runs despite optimising its performance as described in ii c4 it is still very expensive often involving more than 10x instructions when used see iii a3 .
we also experimented with a performance oracle which flagged generated programs on which the symbolic execution engine spent disproportionately more time.
for instance the 520k c mode runs for klee have a mean performance slowdown compared to native execution of 120x with a standard deviation of .
however we had programs on which the slowdown was over 8000x.
such outliers might point to program bugs or at least highlight features which result in high overhead in symbolic execution engines.
however after reporting two such anomalies to klee developers without receiving a response we realised that such performance reports are not too actionable and decided not to include the performance oracle in the experiments we describe.
false positives.
by design our approach has no false positives any program flagged by our oracles is a real bug.
one exception is the function call oracle which assumes that the order in which the arguments to a function are evaluated which could be functions themselves is the same across versions.
only the crest experiments generated such false positives as crest is based on the cil compiler infrastructure which evaluates arguments in a different order from the gcc compiler with which the native versions were created.
however we found it easy to filter out such false positives.
another solution would be to force csmith not to generate programs with function calls as function arguments.
manual effort.
our approach involves manual work in only two cases.
first to reconfigure the experiments before running a new batch so that the previously found bugs are not triggered again.
second to configure c reduce to shorten the program while preserving the essence of the bug e.g.
that it prints a certain wrong value or stack trace .
fortunately such manual effort is only needed whenever we discover a bug and we found the overall effort to be relatively modest.
v. r elated work as far as we know this is the first approach specifically targeted toward testing symbolic execution tools and the first paper to present the experience of adapting compiler testing techniques to check mature symbolic execution engines.
more generally however the research community has started to invest effort into ensuring the correctness and reliability of program analysis tools .
cuoq et.
al.
s approach is the closest related work in which csmith generated programs are used to evaluate the frama c static analysis framework.
static analysis and symbolic execution tools present different challenges in this context which require different version creation strategies and different oracles.daniel et al.
s work on testing refactoring engines combines program generation by providing developers with a declarative way of constructing abstract syntax trees for java code using a bounded exhaustive approach with differential testing between refactoring engines and appropriate oracles.
roy and cordy evaluate clone detection tools using program generation their approach starts from real programs which are mutated to create code clones.
wu et al.
present a system for checking pointer alias implementations which validates the results of pointer alias analysis tools against the pointer values observed at runtime.
this is a form of differential testing between dynamic and static information.
our approach takes advantage of the recent work on testing compilers especially the work of regehr et al.
on program generation and reduction .
combined with our technique for generating program variants in three different modes and a set of appropriate oracles we show that these techniques are effective at finding bugs in symbolic execution engines.
with respect to creating oracles based on differential testing weyuker proposed the use of pseudo oracles in which one creates an independently written program that meets the same specification as the program under testing .
a similar approach is used for fault tolerance and reliability by the n version programming approach in which multiple versions of the same program are run in parallel and their behaviour compared at runtime .
other types of crosschecking oracles exploit equivalences in the specification or redundancies in the code .
vi.
c onclusion symbolic execution has seen significant interest in the last few years across a large number of computer science areas such as software engineering systems and security among many others.
as a result the availability and correctness of symbolic execution tools is of critical importance for both researchers and practitioners.
in this paper we have described our experience extending compiler testing techniques to checking the correctness of symbolic execution tools.
we have evaluated our technique via case studies on the klee crest and fuzzball symbolic execution engines where it has found subtle errors involving structures division modulo casting vector instructions and more as well as issues having to do with constraint solving compiler optimisations and test input replay.