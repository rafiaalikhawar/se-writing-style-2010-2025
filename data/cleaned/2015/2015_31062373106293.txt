understanding the impact of support for iteration on code search lee martie andr van der hoek thomas kwak university of california irvine department of informatics irvine california u.s.a. lmartie andre tkwak1 uci.edu abstract sometimes when programmers use a search engine they know more or less what they need.
other times programmers use the search engine to look around and generate possible ideas for the programming problem they are working on.
the key insight we explore in this paper is that the results found in the latter case tend to serve as inspiration or triggers for the next queries issued.
we introduce two search engines codeexchange and codelikethis both of which are specifically designed to enable the user to directly leverage the results in formulating the next query.
codeexchange does this with a set of four features supporting the programmer to use characteristics of the results to find other code with or without those characteristics.
codelikethis supports simply selecting an entire result to find code that is analogous to some degree to that result.
we evaluated how these approaches were used along with two approaches not explicitly supporting iteration a baseline and google in a user study among developers.
we find that search engines that support using results to form the next query can improve the programmers search experience and different approaches to iteration can provide better experiences depending on the task.
ccs concepts software and its engineering software notations and tools keywords code search internet scale iterative acm reference format lee martie andr van der hoek thomas kwak.
.
understanding the impact of support for iteration on code search.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
introduction unlike when people search on the internet to be aware of the latest news or current temperature a distinctly informational activity programmers routinely search for source code on the internet when they are looking for solutions to aid in their current programming problem .
sometimes the programmer uses a search engine to find one specific code snippet.
for example the programmer might need to remember how to write a few lines of code e.g.
the code to open a database in php .
other times the programmer uses a search engine when she is not quite sure what she is searching for and there is not exactly one code snippet she has in mind.
for example the programmer might need to learn a concept such as database transactions and needs to look at multiple examples illustrating different aspects of databases and alternative examples to clarify her understanding .
for another example the programmer might need to get ideas such as when designing a new game and wants to see and sometimes compare how other code handles game characters board state or visualization.
given how important searching for code on the internet is to programmers researchers are investigating how to improve code search engines.
some for instance have been investigating how to support more expressive queries e.g.
searching by test case or method signatures that afford more precise matching of code compared to keywords e.g.
.
others have investigated new matching and ranking algorithms e.g.
ranking code higher with method names or class names matching the keywords so that more results presumed to better match the topic described by the keywords are returned and appear towards the top of the list e.g.
.
while many different approaches for improving code search exist these approaches are generally similar in one very visible design decision they are non iterative approaches.
they expect a query and optimize on returning the best matching results for the query occasionally offering filters to help scope the results e.g.
programming language or file type filters .
this focus on a non iterative design for search engines is mirrored in how search engines are evaluated .
typically a group of experts score the performance of search engines by the results returned for some representative set of queries with the score reflecting how on topic the results are.
while a search engine that returns the code the programmer is looking for after the first query appears ideal many times the programmer is not sure what she is looking for and does not search for code with a single query.
instead the programmer issues multiple queries where after receiving results the esec fse september paderborn germany lee martie andr van der hoek thomas kwak programmer modifies their query by removing keywords adding keywords or some combination of both and repeats this process multiple times .
that is search looks like an iterative process where programmers often submit a query get results reflect on and learn from the results submit a modified query in response to the results get new results and so on until the programmer stops searching.
cognitive processes in which programmers engage possibly explain why code search is often iterative.
particularly when programmers are working on a programming problem what they are working on a solution is often not immediately understood .
however as programmers begin to look at some code or consider possible ideas they are faced with constraints or different perspectives not previously considered changing their understanding and a new understanding will often change the next code and ideas considered .
the implication of this on code search is that when programmers search for code not clearly understood e.g.
cases when learning or needing ideas code results can cause them to change their understanding of what they are looking for and thus the next code searched for making the search iterative.
our research investigates what happens when programmers are explicitly supported in searching iteratively for code.
it particularly answers the following research question what is the impact of explicitly supporting software developers in searching iteratively on the experience time and success of the code search process on the internet?
the key insight we explore to support iteration is that the code returned for a query tend to serve as inspiration or triggers for the next queries issued.
we introduce two search engines codeexchange ce and codelikethis clt specifically aimed to enable the user to directly leverage the results in formulating the next query.
ce previously developed but now built on the specificity ranking algorithm provides a set of four features supporting the programmer to use characteristics of the results to find other code with or without those characteristics.
for example if a result is undesirable because it is too complex then the user can refine her query to find code that is less complex than the undesirable result.
rather than using particular characteristics clt supports simply selecting an entire result to find code that is analogous to some degree to that result.
for example if the user receives an implementation of an ai for chess but wants to see other similar approaches to learn from then she can select the entire result to find other similar approaches.
we conducted a user study with developers evaluating the iterative approaches with two non iterative approaches a baseline and google .
the baseline was a control used to measure the impact of a lack of iteration support while maintaining the same code index used in the iterative approaches.
as such the baseline was created by removing the iterative features from ce leaving a traditional looking search engine.
while google is not a code search engine per se and indexes a much greater amount code on web pages than our iterative approaches it is important to evaluate the mostpopular form of search today to gain an understanding of how developers iteratively search with it.
the rest of the paper is organized as follows.
section presents relevant background in code search.
section introduces each of the search engines used in the user study.
in section we discuss the design of the experiment.
section presents the results in detail.
section presents threats to validity.
in section we conclude with the implications of the results and future work.
background previous research in code search can be divided into empirical studies on how developers search for code on the internet and tool research that seeks to provide new ways of supporting code search on the internet.
in this section we present a summary of both groups of research.
.
empirical studies on internet code search several types of studies e.g.
surveys search log analysis field studies and lab studies have been conducted to understand why and how developers search for code.
surveys asking programmers why they search for code on the internet have been conducted by simet al.
sadowski et al.
stolee et al.
and hucka and graham .
overall these survey studies find that the motivations to search for code on the internet include getting ideas inspiration learning remembering clarifying knowledge and finding code to reuse as is.
lab studies have been conducted looking at how programmers search for code by scott henninger sim et al.
and brandt et al.
.
henninger and sim et al.
s findings suggest that searching for code is highly iterative spanning a sequence of queries from .
to .
on average where each new query is often a modification of the previous often making it more specific called a refinement or less specific called a generalization .
further brandt et al.
s findings confirm the motivation to search found in the survey studies above.
studies by bajracharya et al.
brandt et al.
and holmes examined patterns in search engine logs to understand how and why programmers search for code.
overall these studies confirm that programmers submit multiple queries on average and some of their motivations include learning new concepts or being reminded of how to accomplish a programming task.
lastly rosalva gallardo valencia et al.
conducted a field study onsite at a company in peru where they observed employees search for code on the internet.
the study found that the majority of searches were concerned with learning remembering gaining a deeper understanding solving a bug translating from english to spanish and comparing candidate solutions.
.
tool support for code search on the internet research has explored a wide range of tools and techniques to support code search on the internet.
these tools are organized in the following six subsections.
.
.
more expressive queries.
recognizing that keywords do not allow developers to easily target their search to the content 775understanding the impact of support for iteration on code search esec fse september paderborn germany of code several search tools support structural queries usually submitted with an advanced query form.
these approaches support search by the code s method signature packages framework and language constructs e.g.
if statements and relationships e.g.
one method calls another .
rather than searching for functionality based on the structure of the code several approaches have investigated how to support developers in more meaningfully searching for specific functionality by supplying semantic queries.
a common approach is to use test cases as queries to find code passing them .
several approaches support the user to write part of the code she needs at the method or statement granularity and to submit it as a query to get results that complete it.
this approach is intended to more seamlessly go from code to results with no keyword query in between .
.
.
better ranking algorithms.
other research has investigated how to improve the ranking of the code that is returned.
to return more on topic results one approach automatically adds related words to the current keywords to match topically related code that would be missed by matching only against the programmer s keywords.
the terms added can come from a variety of thesauruses rule systems mapping keywords to related terms related java documentation or code the developer is currently writing .
a similar but different approach is to index code in the search engine not only with terms occurring in it but also with descriptive terms elsewhere .
linstead et al.
found that it is possible to improve ranking performance for code by matching keywords against the most qualified parts of fully qualified type names in code e.g.
class names in an algorithm called specificity .
.
.
query creation support.
several approaches attempt to eliminate the effort of formulating queries by automatically constructing queries on behalf of the user and continuously pushing results to the user.
the insight behind these approaches is that the context e.g.
opened projects of the developer can determine in part some initial queries .
while not internet code search approaches local code search approaches for various maintenance tasks e.g.
finding a method to change in a local project support the programmer in replacing or completing their keyword queries when results are too few or deemed inadequate for the maintenance task.
these approaches utilize issue tracking systems and various statistics in the project .
.
.
result usability.
while returning topically related code to a query is crucial other research has noted that the usability of the results in terms of their quality understandability and ease of integration are also important for search.
to control quality several approaches match against code that is more popular.
measuring popularity has been done by counting the number of times code is used by other code and extracting high level patterns from the code indexed and counting how often those patterns occur in the search engine .
another critical part of code search is the ability of the user to understand the code results.
one very early approach supported the user to select parts of the code to issue why questions to retrievemanually created documentation explaining the selected parts .
another approach collapses code results into groups by different functionalities in the code and supports annotations .
some other methods include documentation and comments from the web with the results summarizations or examples of usage .
.
.
result navigation.
traditionally navigation of code search engine results is done by paging through ranked results at a time.
however some code search engines many commercial support navigating the results by scoping them with descriptive fields called filters.
for example the commercial search engine krugle supports scoping results by known projects file types and authors of the code indexed.
.
.
iteration support.
little preexisting work supports how developers search.
in particular little work exists on using the results to create the next query.
henninger s work around was first to present iteration as an issue and demonstrated in codefinder that it is possible to recommend keyword refinements from the results by using the spreading activation algorithm on a lisp repository of snippets .
henninger showed the recommendations helped find code for ill defined code search tasks.
mica offers java sdk specific refinement recommendations by recommending keywords in the results that also occur in the java sdk libraries shown to be used in half the queries in a field study .
more recently bajracharya et al.
presented ideas yet to be evaluated on recommending query refinements by function calls and types used in functions occurring in the results .
however much more research can be done beyond refinement recommendations and it is important to do so given that in of the empirical studies that looked at the behavior of code search suggest that code search on the internet is often iterative.
summary of search engines in this section we describe the details and rationale behind the iterative approaches and briefly introduce the baseline approach.
since google is well known in general we do not include a description.
.
codelikethis clt sometimes it is easier for people to recognize something that resembles what they want rather than to say what they want .
to support using a result that does or does not resemble helpful code in order to find other helpful code we designed a new method of search by similarity implemented in clt.
after the first keyword query clt presents the user with a diverse set of results using the hybrid diversity ranking algorithm where the results are on topic but diverse across other characteristics e.g.
libraries used authors and implementations .
from this diverse set of results the developer has different kinds of results to select as a query called a like this query to find code that is more somewhat or less similar to the selected result.
code returned from the like this query can continually be used to issue another like this query to support iterative search.
a screen shot of clt is presented in figure illustrating how to use a quick sort example to find many different kinds of quick sort implementations and other ways of sorting.
on the bottom 776esec fse september paderborn germany lee martie andr van der hoek thomas kwak figure codelikethis clt .
left in figure is the main page showing the top results after a developer issued the keyword query quick sort.
at the bottom of each code result are buttons to issue a query to find other code that is less somewhat or more similar to that result.
shown above and to the right of the main page are the top two results after clicking on each of like this buttons for the highlighted implementation of quick sort on the bottom left.
when the programmer selects the more like this button she gets results a that are also quick sort implementations but use different styles and methods to implement quick sort i.e.
similar quick sort implementations but not exact clones .
when the programmer clicks somewhat like this on the quick sort implementation she gets results b that rely more on other classes e.g.
extending parent classes to implement quick sort or include comments in other human languages.
lastly when the programmer clicks less like this she gets results c that are no longer quick sort implementations but are examples of other kinds of sorting algorithms in this case merge sort and heap sort .
.
.
like this ranking algorithm.
to process a like this query qon selected result r clt performs the following algorithm find and order the top ncode snippets by their similarity tor where similarity is calculated with the simst 2function .
if qis a more like this query return the top of n. ifqis a somewhat like this query return the code snippets that are an average distance away from r. if qis a less like this query return at the tail of n.in our implementation we set n 300in an attempt to limit completely off topic results from a less like this query and to speed up our processing of queries.
.
codeexchange ce sometimes particular characteristics of a code result appear helpful and sometimes not.
to support using characteristics of the results to find other code with or without those characteristics ce provides four features.
each of these features are presented in figure a partial screen shot in the context of ce after the user has been searching for an implementation of an http servlet.
each feature is discussed next.
.
.
language constructs feature.
language constructs a support the developer in searching by structural characteristics she likes about a code result.
in particular language constructs highlight the structural properties of the code results so that they can be clicked on to refine the query by that structural property.
for example the user can click on a method call e.g.
setcontenttype or an import e.g.
javax.servlet in a result to refine the query to find all code that also has that method call or import.
.
.
critiques feature.
critiques b support the developer to search by what she does not like about a code result.
in particular the user can issue a query that the results need to have more less size complexity or number of imports than the result she does not like.
this is done by clicking an up down arrow above the size complexity or number of imports appearing above the result and when clicked will refine the query to find results with more less 777understanding the impact of support for iteration on code search esec fse september paderborn germany figure codeexchange ce .
size complexity or imports.
for example if a code result is simply too long for a user to want to read through she can click the down arrow below the size value for that result and the next results will be shorter in size compared to that result.
clicking the down arrow below the size value for the snippet in figure would refine the query to find code less than characters.
.
.
refinement recommendations feature.
refinement recommendations c use the results after each query to present ways for refining the current query by domain related keywords or common imports parent classes and interfaces implemented.
these recommendations alleviate the work for the developer trying to see what is commonly used or related in the entire set of results returned often in the thousands .
for example if the developer issues the keyword query http servlet she gets keyword refinement recommendations request andresponse both having a domain specific meaning in http servers and parent class recommendation httpservlet .
when the recommendation for the parent class httpservlet is taken the query will be refined for code that extends the class httpservlet and the recommendations are updated using the latest results.
in this way the developer can iteratively take recommendations to refine her query to steer the search engine toward desired results.
.
.
query parts feature.
query parts d decompose the query by the result characteristics and keywords used to refine the query and can be toggled on off.
when a part is toggled off it acts to generalize the query by deactivating the refinement and when toggled on reactivates it to refine the query.
when a query part is on it appears appear yellow and when it is off it appears white.
in figure the user has generalized the query by toggling the keyword query part off.
in this way the programmer can quickly modify her query by previous result characteristics to try different combinations in response to the current results.
ce s features are orthogonal to any ranking algorithm for keywords.
in this study it uses the specificity ranking algorithm because specificity is a successful code ranking algorithm compared to more basic ranking algorithms e.g.
tf idf .
.
baseline the baseline search engine shown in figure was constructed to resemble a traditional search engine while controlling for confounding factors.
our method to do so was to remove all the iterative features of ce leaving basic search features but preserving the same ranking algorithm of ce and the same code index used by ce and clt.
the basic features included a keyword text box with autocomplete a list of code results and a paging mechanism.
we called our baseline search engine searchit when introducing it to participants in order to hide the fact we were using it as a baseline.
experiment design to answer our research question what is the impact of explicitly supporting developers in searching iteratively we conducted a user study measuring the experience time and success of each participant in searching for code with each approach .
further we logged how each approach was used as an indication of what features helped and we collected reasons why code was chosen to give insight into why code is used on the internet when the search for code is initially uncertain.
the participants in the study consisted of developers who reported to have approximately years of professional development experience on average s .
above intermediate java skill level median of skill level on an ordinal scale of as beginner and as expert and with s .
an average age of .
s .
and a male female ratio.
we recruited the participants by sending out advertisements to industry affiliated mailing lists targeted towards developers .
the user studies were held in a closed lab setting where the participants sat alone in a room completing eight different and independent search tasks in sequence.
each participant was assigned two search engines for the entire experiment and completed each search task using only one.
we chose to set the number of search engines to two per person to reduce the learning curve effect with using all four search engines but still allowing them to make comparisons between the search engines in their feedback.
we designed the experiment as follows 778esec fse september paderborn germany lee martie andr van der hoek thomas kwak we used the latin square design for our experiment to evenly distribute the tasks among the search engines and participants.
as such each search engine was used in tasks in total and used for each task six times which yielded a total of data points.
to address ordering effects the search engines alternated with each task and all the tasks came in a random order for each participant.
this was accomplished by assigning each search engine to a task done with latin square creating pairs like s1 t1 s2 t2 s1 t3 s2 t8 and when a participant finished a task then a pair with the other search engine was chosen at random and used as the next task and search engine to use.
each participant received a different task for each search engine so each participant never repeated a task on two different treatments making the experiment a between subject design to reduce carry over effects.
in addition each participant used different search engines making it also a within subject design.
as such we had a mixed design.
to control for differences in code indexed by the search engine ce clt and the baseline search engine all index the same million java classes mined from github.com.
with respect to google in section we discuss implications about its index.
lastly to push participants to give each task some thought and effort we asked them to include explanations for what the code does and why they chose it.
this was a tactic to get the participants to genuinely attempt each task.
the search tasks were designed to cover a space of tasks that are broad to more focused.
the broad tasks were designed to model situations when the programmer is looking for multiple and possibly different examples that can help.
the more focused tasks were designed to model situations when the programmer is looking for one example or examples of a particular kind.
this space of tasks is presented in a 2x2 matrix shown in table .
the broader tasks are found in the find row and the no specific role for code column.
the more focused tasks are found in the find row and the algorithm data structure column.
the tasks in the upper right and lower left are a mix of the broad and focused tasks.
the participants had minutes for the find tasks and minutes for find tasks.
we set the time limits for completing tasks based figure baseline bl .on our pilot studies where we found our participants could finish tasks in the given time limits.
the topics of the tasks were created to mirror real world topics for code search.
the topics were derived by reverse engineering plausible topics from real queries tic tac toe t1 mail sender t2 awt events t3 combinations n per k t4 array multiplication t5 database connection manager t6 jspinner t7 and binary search tree t8 found across four different code search engine logs .
with the topics we created the tasks in a style similar to those used in other code search studies where the tasks do not give the participant a query or the actual code snippet to find as is not usually done in the real world and are composed only of one or two sentences expressing a high level problem for which the participant needs to find code to help solve.
to start the experiment the participants watched a tutorial video on each of their assigned search engines that explained all features including the advanced search feature for google .
further to warm up each participant had a few minutes to play around with the search engines as they pleased.
once done each participant used a survey system which presented the time she had for a question a search engine hyper link indicating which search engine to use when clicked opened the search engine the search task five tabs each containing an editor to paste the code she finds for the search task a text box to explain what the code does and a text box to explain why she chose the code.
we gave the participants five tabs in case they wanted to find more than the required number of snippets.
when a participant hit the done button to indicate finishing or when time ran out the participant then rated her experience from to for using the assigned search engine for the given task where was labeled bad was labeled neutral and labeled great .
once the participant was done giving her experience rating she hit submit and received the next task and treatment.
finally once the participant finished all eight tasks she filled out a questionnaire about the treatments used and then had an open interview with us.
from the entire experiment we collected a total of experience scores time durations to find one snippet also counting time to find first snippet in the find tasks time durations to find four snippets and interviews.
further we logged the search behavior across all the search engines giving us data for what features were used and how often.
we also collected reasons why code was chosen each participant was asked to find snippets in total and give a reason why she chose each snippet .
results in this section we examine the impact of supporting iterative search on the experience time and success of searching for code.
further we look at how the search engines were used and the reasons people reported for searching for code.
for significance tests we set alpha to .
as done in smaller scale experiments .
.
experience time and success our first analysis compared the experience scores for using each search engine for each search task.
to compare experience scores we observed when one approach had a higher median score than others.
it is standard practice to use the median and not mean when the data is ordinal such as the experience scores.
we created the 779understanding the impact of support for iteration on code search esec fse september paderborn germany table task matrix no specific role for code broader algorithm data structure more focusedfind broader min limit t3scenario you are building a sketching application.
task find snippets of java source code that you think will help.t1scenario you are making your favorite video game.
task find snippets of java source code that you think will help implement the algorithms and data structures.
t7scenario you are building a program to survey people s preferences.
task find snippets of java source code that you think will help.t5scenario you are building a program to help teach students basic algebra.
task find snippets of java source code that you think will help implement the algorithms and data structures.find more focused min limit t2scenario you are building a new email client.
task find java source code that counts new messages.t4scenario you are teaching a class and need to split your class up into groups of four.
task find java source code that implements an algorithm and data structures to find all possible groups of students.
t6scenario you are building a large healthcare patient record keeping system.
task find java source code to add or edit records in the system.t8scenario you are building the world s first online phone book.
task find java source code that implements an algorithm and data structures to retrieve phone numbers by name.
box plot summary shown in figure of the experience scores for each search engine by task.
each box is color coded by search engine shows the median score with a black horizontal bar through it sometimes on top or bottom and has a height summarizing the spread of the scores.
for each task the search engine with the highest median scores has its plot annotated with its initials.
if there are ties between search engines then both names appear above their corresponding plots.
we found that an iterative approach existed with a higher median than the baseline for six tasks and equal median for two tasks p .
where p .002with 2on a 3contingency table comparing best medians .
these results suggest supporting iterationwith the features of ce and clt can significantly using bonferroni correction to set alpha to .
for comparing iterative twice improve the developers experience in searching for code.
we found that an iterative approach existed with a higher median than google for three tasks equal median for two tasks and lower median for three tasks p 1with 2on a 3contingency table comparing best medians .
these results suggest that by supporting the technique of iteration in a code search engine can provide an experience comparable to a large scale web search engine like google.
however it is also clear that the participants sometimes had a better experience with google.
whether this is a consequence of the different indexes kinds of content participant familiarity or ranking algorithms is uncertain.
figure box plot comparing experience scores of search engines across all eight tasks.
780esec fse september paderborn germany lee martie andr van der hoek thomas kwak table ce and clt median comparison.
no specific role algorithm data structure find ce t3 ce t7 ce t1 clt t5 find ce t6 clt t2 clt t4 clt t8 interestingly we found that ce and clt complemented each other in the types of tasks they support.
in table each cell displays which iterative approach had a higher experience median for each task.
the table shows that ce provided a better experience for tasks that were broader find and no specific role and that clt provided a better experience for tasks that were more focused find and algorithm data structure .
such a complementary pattern as shown in table only has a .
chance of occurring given equal probability of ce clt or ties occurring in each cell .
the data in table suggests that using characteristics supported by ce of the results supports finding code when initially the search task is broad but as the search task becomes more focused then using the entire result to search with supported by clt provides a better search experience.
time differences to find code were examined by measuring how long it took to paste code for each of the tasks by search engine time writing why what explanations was not counted .
if the task was not completed the max time allotted was used.
we used anova to find significant differences among the groups of search engines for each task.
if we did find a significant difference we conducted a post hoc pair wise analysis on the corresponding group using tukey s honest significant difference to see what might be causing the difference.
the time analysis is presented in table .
in most cases we did not find significant differences.
however we did find that google was significantly faster than clt for finding the first code snippet on task three and clt was significantly faster than google for finding the first code snippet on task seven.
we were not able to find any significant differences in time for finding four snippets.
finally we looked at the number of task incompletions no code found by search engine as a measure of unsuccessful searches.
we found that the iterative search approaches had less incomplete tasks than the others with clt having the least number of incomplete tasks baseline having and ce and google each with .
however we did not find these differences statistically significant with 2. further we found that the find tasks had higher incompletion rates than the find tasks .
further the algorithms data structure tasks had a higher incompletion rate than the no specific role tasks .
.
feature usage we looked at how the features of the search engines were used and some participant explanations of the usefulness of the features.
in table mean seconds until first paste.
t1 t2 t3 t4 t5 t6 t7 t8 ce clt clt g p .
bl g g clt p .
anova p .8p .
p .
p .8p .2p .
p .
p .2table codeexchange search behavior.
t1 t2 t3 t4 t5 t6 t7 t8 t rfreq.
cfreq.
lcfreq.
qpfreq.
kfreq.
asfreq.
hfreq.
copies after only keywords10 .
.
.
.
.
.
.
.
.
copies after r c lc14 .
.
.
.
.
.
.
.
.
copies after qp3 .
.
.
.
.
.
.
.
.
copies after as0 .
.
this section we report what we found for ce clt and google.
since the baseline is limited to keywords and paging we leave it out of this section.
.
.
codeexchange ce .
to understand which features of ce helped we looked at how often features were used when feature usages were used to find code that was copied and what the participants had to say during our interview.
the logs for ce recorded when the participants used iterative features recommendations critiques language constructs query parts keywords history andadvanced search.
table presents the usage frequency counts of features by task.
the features that support iteration were used most often .
and then keyword text box .
second advanced search .
third and history .
fourth.
further we found the iterative features were used significantly more often than keywords p .
where p .01with 2on a 1contingency table .
to get a better idea of the iterative features impact on searching we looked at how many copies happened after only keywords versus after queries that include a recommendation critique or a language construct.
we separated counting query parts from the other iterative features in this part of the analysis because counting copies after query part usages also counts copies after a query composed only of keywords which we are trying to separate out in this analysis.
further we look at the copy keyword and copy iterative feature ratios these ratios measure how many copies happen per keyword query and how many copies happen per query created with an iterative feature .
the ratios appear in parenthesis after the copy counts in the table.
we found that when the iterative features were used to refine a query they lead to higher number of copies on average .
than when only keywords were used .
.
our participants told us that at a high level codeexchange was better for drilling down.
.
.
codeexchange helped me go in a particular direction where codelikethis did not tell me .
they found language constructs useful saying i liked clicking the import.
.
.
if i found a project that seemed to do what i needed.
.
.
i could just click.
.
.
and my search is in the project .
they felt query parts helped saying query parts helped explore .
they reported that refinement recommendations gave them ideas and helped them remember saying initially i typed in smtp and got suggestion for a mail validator then i added import and it guided me to think of ideas and i typed just draw in here and it recommended awt.
.
.
i was like oh yeah it was awt .
781understanding the impact of support for iteration on code search esec fse september paderborn germany table codelikethis search behavior.
t1 t2 t3 t4 t5 t6 t7 t8 t back freq.
forward freq.
more freq.
somewhat freq.
less freq.
keywords freq.
like this freq.
copies after keywords17 .
.
.
.
.
.
.
.
.
copies after a like this5 .
.
.
.
.
.
.
.
.
.
.
codelikethis clt .
feature usage of clt data was examined to look at how often features were used and when using a feature was used to find code that was copied.
the logs for clt recorded when any of the like this queries were used keywords issued back forward buttons pressed and copies that came after keywords or after a like this query.
table shows the usage frequency counts of features by task.
we found keywords were used twice as much as the like this queries p .
where p 7with 2on a 1contingency table which could suggest that like this queries were less helpful.
however we looked at how many copies happened after keywords versus after like this queries and the copy keyword and copy likethis ratios.
the ratios appear in parenthesis after the copy counts.
we found that keywords and like this queries lead to an equal number of copies on average when they were used .
.
this suggests that keywords and like this queries both had an equally important impact in searching for code.
some example event sequences in the logs recorded using clt were keyword query back button keyword query somewhat like this query more like this query code copied andkeyword query more like this query code copied .
at a high level participants explained like this queries helped them get a new perspective.
they said with clt you get to see different codes and different ideas.
.
.
andit gave me a new perspective.
.
.
andit was sort of a way of exploring .
they explained the like this queries were helpful because i wasn t sure exactly what i was looking for.
.
.
and that it works well for queries that are common and precise quicksort hash table game loop or game examples for instance .
however it is clear that like this queries do not always work one participant explained more like this is pretty much what you expect but the other two doesn t really follow the semantics in my mind and another saying i felt a little lost .
.
.
google.
for google we recorded normal keyword queries advanced keyword queries e.g.
restricting search to a site with the site qualification and domains visited by clicking hyperlinks.
we found that keyword queries were used .
about five times as much advanced queries .
with p .
p .
with 2on a 1contingency table.
this suggests either keywords sufficed or advanced search was less helpful or harder to use for the participants.
we looked at the number of domains that were visited by clicking a hyperlink and how often those domains were visited across participants we do not double count a visit when one participant clicks the same link multiple times .
we found that different domains were visited a total of times with the frequency following along tail distribution.
github.com visits and stackoverflow.com visits were visited most often but thereafter a sharp drop in number of visits to other domains appears.
however while individually the other domains are visited much less frequently collectively they are visited more than github.com or stackoverflow.com.
this suggests that the size and variety of google s index was helpful for participants in their search.
participants told us they appreciated google for the context and comments they would find on web pages.
some said sometimes i was like oh man i wish i could use google at this point just to get some context so i can understand what i need to search in codeexchange.
.
.
and i use google to find best practices and google had comments .
however there are times when google did not help.
our participants told us sometimes they asked why am i getting this?
andgoogle is lacking in digging down.
.
.
andfor simple straight forward i felt codelikethis was better .
lastly we looked at the query behavior of search with google and present the results in table .
each row presents on average how many queries were issued per user the average number of terms in the keyword queries and the average number of terms deleted and added when modifying a query.
the results support the hypothesis that code search on the internet even with a largescale web search engine is iterative and can have a vast range of queries .
to .
.
these results suggest google could benefit from features that explicitly support iterative code search.
.
why code was searched for using the explanations given by our participants that stated why they chose code one explanation for each snippet they found we present categories of reasons for selecting code being searched for.
to create these categories three graduate students two of the authors and another software engineering graduate student participated in an affinity diagramming session to cluster the why explanations.
each graduate student took a why explanation and either assigned it a category if one had already been created by the group or created a new category to assign it to.
the group was free to discuss names of categories and modify them if needed.
from the why explanations categories emerged.
the majority of reasons fell into five clusters we show the top clusters in figure the other clusters had only to explanations in them .
often programmers searched for code because it helped implement a feature the participant had in mind e.g.
a user would want to save their sketch so we need .
.
.
save and load .
.
.
to support a design decision the programmer made about what the code should do e.g.
i want to support 3d too.
meets the problem specifications e.g.
.
.
.
performs the job really well and hence i choose it table google search behavior.
t1 t2 t3 t4 t5 t6 t7 t8 queries per user .
.
.
.
.
.
terms per query .
.
.
.
.
.
.
.
terms deleted per query2.
.
.
.
.
.
.
terms added per query2.
.
.
.
.
.
.
782esec fse september paderborn germany lee martie andr van der hoek thomas kwak figure why programmers selected code.
serves as a starting point to solve the programming problem e.g.
.
.
.
an ideal starting point for building connect four.
.
.
contains the correct sequence of gameplay.
.
.
serves as an example or a reference for how to solve the programming problem e.g.
.
.
.
demonstrates how calculators work.
.
.
these results suggest that when the code being searched for is not completely specified as in our tasks that the programmer will make decisions on what to search for as they search.
often she makes decisions related to design features she thinks are needed or other design decisions .
making design decisions is often argued as an iterative process suggesting that making decisions might play a role in making search iterative.
further it is clear that often programmers found code simply because they felt it satisfied requirements or would serve as a useful starting place to write code that would satisfy requirements for the problem described in the search task.
threats to validity several possible threats to validity exist with our study.
first while we put in our best effort to make this lab study realistic it still lacks the realism one would find in a field study with each of the search engines.
as such further studies need to be performed to examine whether our results hold in real world environments.
second as all of our participants have used google for years and google indexes more code and different information than our prototypes our experiment inherently is unbalanced.
however we felt it was important to tolerate this imbalance since google is so ubiquitous and represents a gold standard for how developers search.
it is not surprising to us that google performed better on a number of cases even though ce and clt offer the same ability to search with keywords only.
what is more important however is that ce and clt did outperform google on a sufficient number of cases to show the promise of dedicated support for iteration in search.
third the search tasks we used by no means cover all possible types of search tasks.
we intentionally focused on broader search tasks given the goal of this paper of addressing code search when developers do not know exactly what they want and search aroundmore exploratorily.
however even within this narrower focus we could have chosen to use other search tasks.
while we attempted to ameliorate this issue by modeling our tasks on real searches in real code search engines a longitudinal study with ce and clt is needed to examine if their features apply beyond the eight search tasks we used.
fourth it is possible that participants did not seriously attempt the tasks.
two of the authors and a colleague graduate student not involved with the research each individually inspected all snippets and explanations assessing if they represented genuine attempts.
in .
of the cases unanimous agreement was that they were genuine attempts result was ranked not genuine by all people results by and results by these were spread across search engines and participants .
this gives us confidence that most of our results represent genuine attempts by our participants.
conclusion in this paper we investigated code search on the internet from the point of view that it often is an iterative process because the developer does not always know in advance what she may need.
our results suggest that providing features explicitly designed to support iterative code search can improve the search experience.
compared to the baseline we found that both ce and clt lead to higher median experience scores.
compared to google we found that that ce and clt each can on a number of occasions lead to an experience that is comparable to that of using google even as participants were much less versed in ce and clt than google which they use daily.
our results are also nuanced as ce and clt provide better experiences for opposing kinds of search tasks.
ce provides a better experience for broader searches looking for multiple and possibly different examples that can help the programmer.
clt tended to better support tasks that were more focused looking for examples of a particular kind.
this in many ways is surprising as clt was designed to support diversity in results and ce to focus more on refinement of results.
further research will be necessary to determine why the difference emerged.
regardless it is clear that both ce and clt offer features that assist at important times when keyword searches seem to not lead to the desired or at least less desirable results.
overall we believe that our results point at the need to explore the design of novel search engines combining traditional keyword search with the distinctive features of both ce and clt.
this is not a trivial undertaking yet if successful would offer developers multiple ways of jumping out of a current search path without having to think of how to formulate a new keyword query.
that is an important ability given the premise of this paper developers do not always know exactly what they are looking for and need help formulating what they search for as they search.
our experiment has identified two particular ways of so but we expect other approaches to need to be explored as well.