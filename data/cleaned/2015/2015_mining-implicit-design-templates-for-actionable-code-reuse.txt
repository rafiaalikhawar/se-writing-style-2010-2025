mining implicit design templates for actionable code reuse yun lin guozhu mengy yinxing xuey zhenchang xingz jun sunx xin peng yang liuy wenyun zhao and jinsong dong k national university of singapore singapore ynanyang technological university singapore zaustralia national university australia xsingapore university of technology and design singapore fudan university china kgriffith university australia abstract in this paper we propose an approach to detecting project specific recurring designs in code base and abstracting them into design templates as reuse opportunities.
the mined templates allow programmers to make further customization for generating new code.
the generated code involves the code skeleton of recurring design as well as the semi implemented code bodies annotated with comments to remind programmers of necessary modification.
we implemented our approach as an eclipse plugin called micode.
we evaluated our approach with a reuse simulation experiment and a user study involving participants.
the results of our simulation experiment on open source java projects show that to create a new similar feature with a design template on average of the elements in the template can be reused and on average code of the new feature can be adopted from the template.
our user study further shows that compared to the participants adopting the copy paste modify strategy the ones using micode are more effective to understand a big design picture and more efficient to accomplish the code reuse task.
i. i ntroduction programmers usually adopt copy paste modify practice when implementing similar features .
once a feature involves several related classes methods or fields such practice causes more a design duplication than several pieces of duplicated code.
empirical studies have shown that design duplication often occurs among classes packages and subsystems .
recurring or duplicated designs usually indicate projectspecific programming conventions and future reuse opportunities.
programmers can efficiently implement a new similar feature if they are aware of a general skeleton of related recurring designs.
however such recurring designs are usually implicit and undocumented and the programmers usually have to reinvent the wheel without knowing the potential reuse opportunities .
moreover even if the programmers discover such reuse opportunities copy paste modify practice is hardly a sound and systematic approach for reuse .
many approaches have been proposed to extract recurring designs based on code clone.
basit et al.
first proposed to extract structural clone as recurring design.
structural clone is extracted from simple cloned code with frequent item set mining technique .
they are reported as a set of files modules sharing multiple clone sets1.
following their work qian et al.
proposed a technique to detect logic 1a clone set consists of multiple pieces of duplicated code.clone which aims to capture similar business logics by code clone.
their logic clone is described as a graph in which a node represents a set of methods sharing code clones and an edge represents abstract invocation between the method sets.
potentially useful as the above approaches are they still suffer from some insufficiencies for practical reuse tasks.
first they cannot describe a sophisticated design in practice for missing important concepts such as interface class association etc.
second these techniques are designed for comprehension their reported designs cannot facilitate actionable code reuse tasks in an explicit way.
alternatively reverse spl software product line engineering techniques have good potential to meet the reuse need.
fisher et al.
and martinez et al.
proposed different techniques to recover a generalized software product line model from a set of software variants.
however the challenges to adopt their approaches lie in two fold.
first these approaches assume the variant products as its input.
however in our case the code for variant design is unknown in advance.
second these approaches extract spl model in the grain of component or product e.g.
feature model while we need the recurring designs to be extracted on the finer level e.g.
class and method for facilitating actionable code reuse tasks.
in this paper we propose an approach to detecting and extracting recurring designs in code base into a list of design templates to facilitate template based code generation.
in our approach we first identify each set of correspondent program elements across the code base into a program multiset.
then we construct a graph by building various relations e.g.
declare invoke etc.
between program multisets.
finally we heuristically split such a graph into a set of subgraphs each of which is abstracted into a design template.
as a result each design template captures various types of object oriented program elements and their relations and can be visualized in the form of uml class diagram some extracted templates can be checked at our website .
programmers can manage the design templates and customize them to generate code skeleton for the reusable features.
the generated code skeleton contains semi implemented code that is annotated with hints and comments to remind programmers of necessary modification.
we implemented our approach as an eclipse plugin called micode mining implicit code design .
we evaluated our .
c ieeease urbana champaign il usa technical research394 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
drawview main drawapplication model drawapplication model main init createtoolbars geteditor call createdraw model netview main netapplication model netapplication model main init createtoolbars geteditor createnet model pertview main pertapplication model pertapplication model main init createtoolbars geteditor call createpert model drawfigure factory constructor netfactory constructor pertfactory constructorcall calldraw application net application pert application application model application model application model abstract viewextend abstract viewextend abstract viewextenddeclared declareddeclared abstract classlegend concrete class method fig.
.
a recurring design in jhotdraw projects approach with a reuse simulation experiment and a user study involving participants.
the results of our simulation experiment on open source java projects show that for creating a new similar feature with a design template on average of the elements in the template can be reused and on average code of the new feature can be adopted from the template.
our user study further shows that compared to the participants adopting the copy paste modify strategy the ones using micode are more effective to understand a big design picture and more efficient to accomplish the code reuse task.
the contributions of this paper are listed as follows.
first we propose an approach to detecting and extracting recurring design from code base as design templates and support template based code generation second we implement an eclipse plugin micode for practical use of our approach the tool demo video and snapshots are now published at third we evaluate our approach with both simulation experiment and a user study to reveal the effectiveness of our approach.
the results show that the extracted design templates are both accurate and practical for code reuse task.
ii.
m otivating example fig.
shows a design recurring in the jhotdraw7.
project a drawing framework for java language.
all the designs showed in fig.
aim to create a customized drawing application according to project convention.
according to fig.
when programmers intend to create a new drawing application they need to construct several java classes e.g.
class main and factory make some of them inherit existing class e.g.
class applicationmodel and view and make them cooperate with each other by implementing various methods.
if we do not know such recurring designs in fig.
in code base creating a customized application is effort consuming.
nevertheless it is still a non trivial task even when we know these recurring designs.
one straightforward way is to copy all the code of one design e.g.
draw project and modify it to satisfy our own need.
however we have to address the following challenges q1 what are the code files to copy?
apart from the classes shown in fig.
each application involves other classes not shown in fig.
.
without a big picture of how the code isorganized we may either miss copy some code files or copy additional unnecessary code files.
q2 which design shall we copy?
intrinsically we can copy the most similar design as the draft code to save the follow up customization effort.
however it is hard to know the similarity unless we go through all the code of those designs.
q3 what parts of design do we need to customize?
even if we have copied the most similar design we still need to consistently customize the copied classes.
for example after copying draw project in fig.
we have to consistently customize our own applicationmodel class view class etc.
moreover we may also need to remove the irrelevant classes or check other designs to integrate their relevant code.
q4 how do we customize the code?
table i shows the method body of init methods of class drawview pertview and netview in fig.
.
their differences are very helpful hints for code customization.
suppose we copy and modify the draw project it is easy to miss modifying thedrawfactory line into a customized factory class or miss setting scale factor line when necessary which leads to bugs.
nevertheless comparing across code in multiple designs takes tremendous effort if not impossible.
table i corresponding init m ethods in jhotdraw project drawview.
java void i n i t f super .
i n i t .
.
.
seteditor new draweditor view .
setfactory new drawfigfactory .
.
.
10gpertview .
java void i n i t f super .
i n i t .
.
.
seteditor new draweditor view .
setfactory new pertfactory setscalefactor .
.
.
.
gnetview.
java void i n i t f super .
i n i t .
.
.
seteditor new draweditor view .
setfactory new netfactory setscalefactor .
.
.
.
g in order to customize our own design with regard to existing program convention we usually need to understand the general design structure take different existing implementations as reference and be aware of their differences as potential customization points.
the copy paste modify practice can hardly meet this end.
we propose micode a tool supported approach which can both detect andsummarize the recurring designs in fig.
into a design template.
the template is visualized as a uml class diagram sample snapshots are available at our website authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
which captures the structural commonalities of the instances of the recurring design.
micode supports further customization on the template to generate both code skeleton and the method body.
the generated method bodies are annotated with comments to indicate what modification could be adopted.
iii.
a pproach figure shows an overview of our approach.
our approach takes the source code of a code base as input and generates customizable design templates as output.
the design templates can be instantiated and customized to generate code skeletons.
source code .
determining correspondence program multisets .
connecting multisets multiset clusters .
abstracting design design template .
customizing template and generating code code skeleton and body input output .
reverse engineering program model fig.
.
approach overview given the source code we first reverse engineer it into a program model which captures various program elements e.g.
class and method and their relations e.g.
declare and invoke .
second we identify corresponding program elements by clustering technique.
we regard each set of corresponding program elements as a program multiset.
third we build the relation e.g.
declare and invoke among the program multisets so that they can be connected into a graph.
then we heuristically split subgraphs of connected program multisets into a set of multiset clusters as potential designs.
fourth we abstract each multiset cluster into design templates.
finally the generated design templates will be manifested as uml class diagrams and programmers can manage the templates and customize them to generate code skeleton and body.
in the following we present the details of each step.
a. reverse engineering we reverse engineer the source code of a code base into a program model consisting of program elements and their relations.
fig.
shows the meta model of program model which describes the program elements i.e.
class interface method and field and their relations i.e.
declare extend implement invoke and access .
each program element in the model is attached with its inherent program attributes.
for example a method program element will be attached with the attributes such as method name return type and parameters.
moreover each mined design template is also represented as a program model.
b. determining correspondences we determine corresponding program elements in order to identify the program elements playing the similar role in each instance of a recurring design.
for example in fig.
the type member interface class1 field methodextend implement1 extend 11invoke declare access1 declare1 fig.
.
the meta model of program model three classes i.e.
drawview netview and pertview are considered as corresponding elements.
we call a set of corresponding program elements as a program multiset.
in order to generate a set of program multisets from the program model we first construct a declaration tree over the model based on the declare relation defined in our meta model see fig.
.
in a declaration tree each node represents an entity in the meta model and the parent child relation represents a declare relation in the meta model.
for example a class can declare fields methods and inner classes and the inner class can further declare its fields methods and sub inner classes.
the correspondence of program elements is determined in a top down manner.
we first determine correspondences of top level program elements i.e.
type as multisets.
next for each of multiset we correspond the declaration children of its elements to form new multisets in the next level.
corresponding top level elements we determine the correspondences of the top level program elements by clustering them with regard to code similarity and heuristic rules.
we adopt the hierarchical clustering strategy with complete linkage to cluster all the top level classes and interfaces.
a similarity the similarity between two types class or interface is defined in terms of type name shared super types and type body i.e.
sim p wi simi in whichi2 fname supertype bodyg.wname wsupertype wbody represents respective weight for the three factors which requires wname wsupertype wbody wname wsupertype wbody2 the similarity of type name super types and type body is computed as follows.
the type name of t1andt2is split into token sequences ts1andts2according to some program convention e.g.
camel convention .
let len 1andlen 2be the length ofts1andts2 and letlenlcsbe the length of the longest common subsequence of ts1andts2.
name similarity issimname lenlcs len len .
letst1andst2be the set of super types of the type t1andt2.
super type similarity is the jaccard coefficient of the two sets of super types i.e.
simsupertype jst1tst2j jst1sst2j.
type bodies of the two types are compared at the textual level.
let len 1andlen be the length of the two source code token sequences and let lencbe the length of their shared cloned code source code similarity is simbody lenc len len .
b heuristics similarity sometimes is not sufficient to ensure a correspondence relation.
thus we enforce the following heuristic rules to improve the accuracy the similarity between a class and an interface is .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the similarity between a type and its super type is .
as a result we can obtain some clusters such as fdrawview pertview netviewg andfdrawapplicationmodel pertapplicationmodel netapplicationmodelg.
we regard each cluster as a top level multiset.
recursively generating new multisets given a multiset ms fe1 e2 e ng n we generate new multisets from the declaration children of ei i n so that eacheicontributes at most one declaration child to a new multiset.
the recursive process stops when the new generated multiset has no declaration children.
for the example in fig.
given the multiset classset fdrawview pertview netviewg we determine the correspondence of the declaration children of elements in classset i.e.
their inner classes methods and fields.
when we generate a new multiset in which each element is an inner class we will further determine the correspondence of the declaration children of its elements.
when we generate a new multiset in which each element is method e.g.
fdrawview.init pertview.init netview.init g the recursive process stops as the init methods have no declaration child.
the same case applies for the multiset of fields.
algorithm corresponding children require a multiset set entity similarity threshold tsim ensure a set of multisets msset dcset retrieve declaration children sets of set msset foreach set of declaration children dc2dcset do foreach not yet corresponded element e2dcdo ms add etoms candset dcsetnfdcg while candset6 do find a not yet corresponded element ec2cand cand2candset with maximum sim ec ms ifsim ec ms tsim then break end if add ectoms candset candsetnfcandg end while mark all nodes in ms as corresponded ifjmsj 2thenmsset add ms end for end for return msset algorithm shows the details of corresponding the declaration children of elements in a given multiset setwith threshold tsim.
in algorithm we mark an element as corresponded if it has been used to form a new multiset.
we first construct a setdcset feje is a set of declaration children of an element i.e.
type in setg line .
then we iteratively process each dcindcset line .
we start with processing each declaration childe2dc.
ifehas not been used to generate any multiset i.e.
not yet corresponded we add it as a seed entity to an empty multiset ms line .
then we try to add declaration children from the rest sets candset dcsetnfdcg toms.
for each set cand2candset we attempt to find the most similar childec2cand toms line .
if the similarity betweenecandms i.e.
sim e c ms at line is above the threshold we add it into ms. the similarity between acandidate element and elements in the multiset sim e c ms is computed as the average similarity of ecand each entity e2ms i.e.
sim e c ms p e2mssim e c e jmsj finally we return all the multisets containing at least two elements line .
c. connecting multisets given multisets of corresponding program elements we connect the multisets by the relations of program elements across multisets.
we regard each set of connected multisets as a potential design for abstracting design template.
first we build the relations i.e.
declare invoke access extend and implement see section iii a between multisets.
second we form a graph of multisets and detect its connected components as potential designs.
finally we refine the results with frequent item mining technique .
determining multisets relations we determine the relations of two multisets with regard to the relations in meta model.
let mssandmstbe two multisets of program elements.
let reltbe a type of relations from an element es2mssto another element et2mst.
then mss mst and all the relations of type reltfrommsstomstcan form a bipartite graph gbi ms s ms t relt .
letmatch be the set of the maximum number of matchings of gbi.
we define the connectivity strength frommsstomstof relation type reltas strength ms s ms t relt jmatchj min jms sj jms tj given a user specified threshold tabrel tabrel we create a relation reltfrommsstomstif the following requirements are satisfied strength ms s ms t relt tabrel jmatchj mss mst fig.
.
an example of connecting multisets in fig.
jmatchj min jms sj jms tj .
thus the connectivity strength from msstomstis .
forming graph after determining the relations among multisets we build a graph of multisets gm v e in which vdenotes all the multisets of top level program elements i.e.
top level class or interface as its elements and edenotes the relations between the multisets in v. in order to reflect the association such as invoke andaccess relation among top level multisets we further enhance the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
edges ingmby building invoke andaccess relations.
if a multisetmdis reachable by a top level multiset mtopthrough declare relation we call mdas the descendent multiset ofmtop.
for example in fig.
the multiset fdrawview.init pertview.init netview.init g is a descendent multiset of multiset fdrawview pertview netviewg.
given two top level multisets mtop1 andmtop2 we build a relation of type reltfrommtop1 tomtop2 if there exists a descendent multiset md1ofmtop1has the relation of type relt with a descendent multiset md2ofmtop2.
by this means we enhance the set of edges from etoe0ande e0.
given the enhanced graph g0 m v e0 we regard each maximal connected component ing0 mas a potential design consisting of top level multisets.
fig.
shows the example of an extracted maximal connected component.
in fig.
each node represents a toplevel multiset and each edge represents an invoke relation between two multisets.
we can see that a maximal connected component could be over large and involve multiple duplicated designs.
in fig.
the multisets c fmysqldb oracledbg andd fmysqlconfig oracleconfigg can form a more independent design template and so can the multisetse fexcelgen xmlgeng andg fexcelformat xmlformatg.
we adopt a frequent item based approach to refining the maximal connected components into more independent clusters of multisets.
c mysqldb oraceldb d mysqlconfig oracelconfig g excelformat xmlformat f excelgen xmlgen b basicutil advancedutil a adminmanger usermanger e simpleview normalview fig.
.
an example for maximal connected components refining connected components the rationale of refinement is to split commonly invoked multisets from the maximum connected components.
given a maximal connected component g v e we selectvsrc fvjv2vandv s in degree is 0g.
for each v2vsrc we traverse gfromvwith the depth first strategy through invoke andaccess edge and all the visited nodes in g can form a traversing node set vtr v denoted as vtr v .
for example in fig.
vsrc fa e fg and vtr a fa b c dg vtr e fe b c dg and vtr f ff g c dg.
next we regard each traversing node set as a transaction and each of its contained nodes i.e.
multiset as an item and apply the fp growth algorithm with support of .
it means that among all the transactions we consider an item set as frequent if it appears at least twice.
typical frequent item sets in our example are fc dg andfb c dg which appear three times and twice among vtr a vtr e andvtr f .
among the frequent item sets we use the following heuristics to filter trivial item sets and rank the rest in terms of their independence.
filter given a list of frequent item sets list a frequent item setset12listis removed if9set 22listwhich is a super set of set1and has the same support with set1.
for example the set fcg is removed as there exists a setfc dg with the same support.
rank given two frequent item sets set1andset2 set1is ranked over set2if the support of set1is over that ofset2.
ifset1andset2have a tie in terms of support set is not a super set of set2 and vice versa we rank set1overset2ifjset 1j jset 2j.
namely the stronger support and the larger size a frequent item set has the more independent we deem it is.
in our example the ranked list of frequent item sets is fc dg fb c dg .
algorithm refine clustering results require a list of traversing node sets tralist an ranked list of frequent item set flist ensure a list of refined clusters of multiset clusters tmpclusters foreach item set is2flist do ifist6 then add isintotmpclusters foreach traversing node set tset2tralist do tset tsetnis end for foreach item set set2flist do set setnis end for end if end for add all the non empty traversing node set in tralist intotmpclusters clusters foreach cluster cluster2tmpclusters do clset splitcluster into a set of connected components add all the clusters in clset intoclusters end for return clusters given a list of traversing node sets i.e.
transaction tralist derived from a maximum connected component g v e and a ranked list of frequent item sets flist we splitgas described in algorithm .
in algorithm we go through the ranked item sets from the most independent item set to the least independent one line .
each time when we process a non empty item set is2flist we first add isinto a cluster list tmpclusters then we remove the elements in is from the set in tralist andflist line .
after processing all the frequent item sets we add all the non empty traversing node sets in tralist intotmpclusters.
finally in order to ensure the elements of each cluster can form a connected component we further split each cluster in tmpclusters if its elements i.e.
multisets are not connected line .
for the example in fig.
we will have three traversing node sets i.e.
fa b c dg fe b c dg and ff g c dg and the ranked list of frequent item sets consisting of two elements set1 fc dg andset2 fb c dg.
then we first process set1 which will create a new cluster fc dg and make all the three traversing node sets into fa bg fe bg andff gg andset2intofbg.
afterwards we process set2 which will create a new cluster fbg and make the traversing node sets intofag feg andff gg.
therefore we can have authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the clusters as fag feg ff gg fbg andfc dg.
given all the clusters with its elements connected these clusters are the final clusters we obtain.
d. abstracting design templates given a list of clusters of multisets we generate design templates consisting of template classes template interfaces template fields and template methods.
generating template entities involves abstracting name parameters and super types.
given the names of a multiset of corresponding entities we generalize these sequences by wildcards.
for example an abstract name view can be generalized from the multiset of three classesfdrawview netview pertviewg.
in addition we further abstract the parameters of corresponded methods and super types of corresponded classes and interfaces.
we abstract the parameters of corresponded methods by computing the intersection of their parameter type sets.
for example given a multiset of methods as mset fm1 m2 m3 g and the set of parameters are fstring int floatg fstring intg and fstring intg respectively the abstracted parameters for mset isfstring intg.
in the same vein we abstract the super types of corresponded classes or interfaces by computing the intersection of their super types.
e. managing templates and generating code the mined templates can be further managed i.e.
refined and customized and used to generate code.
managing and customizing template we support the following template refinements.
programmers are allowed to remove template entities or relations they consider irrelevant add template entities or relations and split a large template into several smaller ones or merge some templates into a larger one load design templates and select the template they wants to reuse.
customization involves fixing name placeholders adding or removing super types etc.
our tool provides a wizard that guides the programmer through all customizable entities and relations.
once the programmer customizes all the template entities the tool prompts the programmer that the template is ready for code generation.
generating code apart from generating the code skeleton we also generate semi implemented method bodies if the text similarity of original method bodies is above a threshold.
when the text similarity is above the threshold we apply the mcidiff technique on these similar method bodies to analyze their difference.
it reports the difference as token sequence based differential multiset such asf setscalefactor .
setscalefactor .
g. we regard each differential multiset indicates a potential customization point in the body.
we copy the body of the longest method into the generated method and generates todo comments for each of the copied statements involved in differential multisets.
for example assume the first method in table i is the longest one we will generate a comment such as todo you may additionally have the code like setscalefactor .
orsetscalefactor .
before the empty line.iv.
t ool support a snapshot and a demo video of our tool micode are available at our website .
micode stores mined design templates as eclipse modeling framework emf models.
it lists all mined design templates in template view.
template visualization and customization.
to facilitate the refinement and customization of design templates micode visualizes design templates in a class diagram like template editor.
different types of template entities i.e.
class interface method and field in different status i.e.
configured and un configured are represented by rectangles with different colors.
for example abstracted super classes are represented by bright orange rectangles which cannot be configured template classes are represented by the dark green rectangles which are to be customized.
similarly template method and template field are represented by dark blue and dark yellow rectangles which are to be customized respectively.
doubleclicking a template entity opens a wizard dialogue which allows programmers to customize the entity by specifying its detailed information such as class name package name parameters etc.
after the user customizes a template entity micode will turn the color of the entity into a bright one e.g.
bright green bright blue etc.
.
in addition the user can delete or add some entities or relations to the template.
the newly added entities and relations will be used to generate code in the same way as the template entities mined from the code.
code detail comparison.
right clicking a template entity and choosing show supporting entities menu item open the mcidiff view that presents the differencing results of corresponding entities from which the template entity is abstracted.
themcidiff view shows corresponding methods side by side and highlights their differences using different colors.
code generation.
after a user finishes customizing the template he or she can utilize micode to validate the instantiated template by checking whether all the template entities are customized.
if the customized template is valid the user can click the generate code menu item to generate the code.
v. s imulation experiment we aim to answer the following questions in the experiment rq1.
whether the extracted design templates are reusable for a new similar feature?
rq2.
how many duplicated designs are there in existing large code base?
a. experiment setup we answer the above research questions by applying micode on open source java projects see table ii to detect their recurring designs.
we simulate code reuse tasks on those design templates supported by over three design instances.
suppose a design template tis supported by n n design instances we choose one of its design instances iand generate a new design template t0from the other n 1instances.
then we compare the template t0and design instance ito see how similar they are.
in other words we regard the instance ias a design implementing a new similar feature the similarity authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii recurring designs in open source java projects project versionproject profile extracted templates evaluation subject evaluation result loc class method field template class method field trial template trials precision recall apache commons math .
.
.
.
freehep .
.
.
jfreechart .
.
.
.
jhotdraw .
.
.
.
jmental .
.
.
jmeter .
.
.
log4j .
.
.
.
soot .
.
.
.
xchart .
.
.
.
xerces2 j .
.
.
.
total average .
.
.
.
.
.
.
.
.
.
.
.
median .
.
.
.
.
.
.
betweent0andiindicates how reusable t0is to createi.
in this experiment we call each of such comparisons as a trial.
given a design template supported by ninstances we can haventrials.
we calculate the similarity between a design template t and a design instance ias follows.
tcan be considered as a declaration tree gt v t et defined in section iii b where each node in vtcorresponds to a program multiset i can be considered as a declaration tree gi v i ei where each node in vicorresponds to a program element.
therefore a nodevt2vtis considered reusable for creating design i if9vi2viso thatvtmatchesvi.
given a design template gt vt et a design instance gi v i ei and let the set of matched nodes be vm vm vi we calculate the precision asjvmj jvtjand the recall asjvmj jvij.
we use precision and recall to evaluate how reusable a design template for creating a new design instance.
for a trial i.e.
simulated reuse task precision means how many program elements in the template can be used for creating a new similar feature while recall means how many program elements in the new similar feature can be reused from the template.
high precision indicates that we do not need to delete many program elements in the template.
high recall indicates that apart from the code adopted from the template we do not need to additionally add much code to accomplish the similar feature.
we match the nodes in gtandgiin a top down manner by progressively matching the nodes in the same layer in the declaration tree.
for example we first match the nodes in the top layer then for each pair of matched nodes we proceed to match their children.
when matching the set of nodes in the same layer i.e.
v0 t vtandv0 i vi we construct a bipartite graph gb v0 t v0 i e where an edge eexists between two nodes vt vt2v0 t andvi vi2vi if the similarity between vtandvi see equation is above a threshold.
then we use the blossom algorithm to get the best matching in the bipartite graph gb.
in this experiment we set the field similarity threshold to be .
method similarity threshold to be .
and type similarity threshold to be .
.
b. result table ii shows the details of the java open source projects in terms of project profiles by lines of code number ofclasses methods and fields extracted template by number of extracted templates number of involved classes methods and fields number of used templates for simulating reuse tasks t templ number of trials trials average precision and average recall.
all the extracted designs are available on our website .
in this experiment the recurring designs involve out of files which is a considerable number.
micode reports templates among all projects of which i.e.
.
involve over three design instances.
in table ii we can see that the summarized templates can be reused with a reasonably good accuracy.
the average precision and recall are .
and .
respectively.
it means that on average of the elements in a template can be reused to accomplish the similar feature and code of new similar feature can be adopted from a template.
we further inspect the trials with low precision or recall.
low precision trials low precision usually happens when the design template is enriched with more elements than a design instance needs.
fig.
shows a reuse trial with a low precision i.e.
in the jmeter project.
fig.
a shows a template captures the interaction of template classes such as samplergui sampler configgui and client.
fig.
b shows a design instance used to evaluate the template.
client configgui sampler samplergui examplesampler examplesampler gui a b fig.
.
an example of low precision in the jmeter project some sampler guis such as tcpsamplergui interact with a configure gui while others such as smtpsamplergui do not.
micode aims to capture the design structure of all the design instances comprehensively.
thus it reports a super set of four abstracted classes and their relations.
for the trial in fig.
the design instancefexamplesamplergui examplesamplerg only matches samplergui and sampler and configgui and client declare a large number of abstracted methods authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
and fields.
in such a case the design instance is only a subset of the template which leads to a low precision.
nevertheless in practice micode allows programmers to manually customize the template for their own need.
moreover once the programmers find the additional abstracted class not useful they can simply delete it on template which is not effort consuming.
low recall trials low recall lies in that some design instances involve additional functions other than that adopted from the template.
still in jmeter project one design instance involves two classes proxycontrolgui andproxycontrol which has a low recall i.e.
after compared to the design template of f controlgui controlg.
in this trial compared to template control class proxycontrol class additionally declare a great number of new fields methods such as cert alias cert alias startproxy etc.
for implementing proxy relevant features.
nevertheless the precision of this trial i.e.
is fairly acceptable.
in practice it is usual for programmers to enhance additional features based on existing template code.
therefore we deem the performance of micode average is acceptable.
in conclusion the experiment shows that recurring designs are frequent in open source code projects and the templates extracted by micode are generally reusable.
c. threats to validity one threat is that our simulation cannot be applied on the templates with only instances.
without authoritative template benchmark of the open source projects it is hard to avoid subjectiveness and bias when evaluating the reusability or meaningfulness of design templates.
we will cooperate with industrial partners and deploy micode in real developing environment to generalize our results.
the other threat is that we can generate different templates with different similarity thresholds.
in this experiment we set the thresholds by our preliminary observation and experience.
we will conduct a more comprehensive study for the impact of thresholds.
vi.
u serstudy micode aims to enable easy and systematic reuse of existing code designs in code base.
to evaluate whether micode achieves this goal we conducted a user study to investigate the programmers efficiency in completing reusebased development task when they are with and without the micode tool.
a. study design we recruited graduate students from fudan university china.
we conducted a pre study survey for these participants to understand their programming experience and capability.
these participants were matched in pairs by experience and capability and then randomly allocated into experimental or control group.
the experimental group g1 participants p1 p8 used the micode tool to perform the software development task while the control group g2 participants p9 p16 usedeclipse ide to perform the same task.
we provided a hour tutorial for the experimental group and training session of the micode tool is conducted hours before the experiment.
the chosen training example in our tutorial is irrelevant to the task assigned to participants in the experiment so that we can make the participants familiarize themselves with the tool features while avoid introducing experimental bias.
according to our survey all the participants are familiar with eclipse ide thus we did not provide tutorial and training on eclipse ide.
we chose a jhotdraw template of creating a new jhotdraw based web applet as our subject system in the user study.
the reason for choosing this template lies in two fold.
first such a template is extracted from a demo package of jhotdraw showing users how to build their own drawing application based on jhotdraw api.
since none of the participants have experience in jhotdraw project it is more comprehensible than other design templates involving more detailed jhotdraw framework knowledge.
second the size of the template is appropriate consists of template classes template methods and template fields which is neither too trivial so that the task can be finished without sufficient thought nor too complicated so that everybody is exhausted to fail .
the demo package from which the selected template is extracted provides examples of implementing a jhotdrawbased applets for drawing application within web browser namely pert applet net applet draw applet svg applet odg applet and teddy applet.
in this user study we asked the participants to develop a pert applet based on the other five applet samples.
the participants of the control group were given five existing applet samples draw net odg svg andteddy along with their clone information.
they were free to reuse any code example in these five samples that they deemed relevant.
the participants of the experimental group were given the template mined from the jhotdraw project withpert applet sample removed.
they needed to customize the template to generate code for the pert applet.
they also have access to the original applet samples.
we asked the participants to complete the task in two hours.
the participants were required to run a full screen recorder while they were working on the task.
after the participants finished the task or the time run out they submitted task videos and the java applets they developed.
the task videos allow us to time the task completion process and analyze the participants behaviors during the task.
furthermore each participant was requested to fill in a post experiment survey for us to collect their feedbacks on the task and tool usage.
we evaluated the participants task efficiency by comparing time to complete basic features e.g.
applet lifecycle management and basic jhotdraw framework extension time to complete advanced features e.g.
pert specific visualization and total task completion time of the participants in the two study groups.
advanced features involve cross cutting code among different applets which requires good understanding of alternative solutions in different applets.
for the micode group total task time also includes template customization authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time.
these time metrics were estimated from the participants task videos.
b. results table iii and table iv show the results.
overall the micode users completed basic features advanced features and the whole task more efficiently.
micode users completed the development task i.e.
implemented all basic and advanced features and passed all our test cases while eclipse users completed the task.
the micode user p8 and the eclipse user p12 failed to complete some advanced features.
the eclipse user p16 failed to complete the basic feature and did not submit a working applet.
the relevant time metrics of these three participants were invalid for comparison because these participants would need more time to complete the task.
table iii task efficiency of micode group participant configtime m basictime m advancetime m totaltime m success p1 .
.
.
.
yes p2 .
.
.
.
yes p3 .
.
.
.
yes p4 .
.
.
.
yes p5 .
.
.
.
yes p6 .
.
.
.
yes p7 .
.
.
.
yes p8 .
.
no average .
.
.
.
std.dev.
.
.
.
.
table iv task efficiency of eclipse group participant configtime m basictime m advancetime m totaltime m success p9 .
.
.
yes p10 .
.
.
yes p11 .
.
.
yes p12 .
no p13 .
.
.
yes p14 .
.
.
yes p15 .
.
.
yes p16 no average .
.
.
std.dev.
.
.
.
we used wilcoxon s matched pairs signed ranked tests to to evaluate the difference of the two groups in terms of time on basic features basictime time on advanced features advancetime and total task time totaltime .
the results are shown in table v. at the .
significance level we reject the null hypothesis for advancetime i.e.
there is a significant difference between the two study groups in terms of the time on accomplishing advanced features.
moreover themicode group outperformed the eclipse group in advancetime metrics.
thus we conclude that the micode users accomplished the advanced features of jhotdraw based pert applet in significantly shorter time.
c. analysis based on the recorded video and interviews with the participants we summarize the reason as follows.
some micode users e.g.
p5 p6 have not significantly advantage in completing basic features compared with the eclipse users with similar program experience e.g.
p13 p14 .
although the number of the basic features is large the implementations oftable v significance test for userstudy h var group samples p decision h0basictimemicode .
accepteclipse advancetimemicode .
rejecteclipse totaltimemicode .
accepteclipse basic features are usually straightforward which requires little comparison between multiple applet samples for reference.
thus copy paste modify is an efficient way for reusing basic features.
furthermore the eclipse tools such as text replacement and rename refactoring can save the eclipse users a part of time in modifying copied code.
nevertheless the micode users outperformed the eclipse users in advanced features.
the eclipse users had to spend more time to understand design structure and implementation alternatives of the reused code in order to properly develop the advanced features.
in contrast the design template presented bymicode tool shows the design structure of the to bereused feature.
this makes it easier for the micode users to compare understand and customize the code of the advanced features.
note that the basictime accounts for a large portion of the total task time as the number of basic features is large which reduces the differences of total task time between the micode users and the eclipse users.
nonetheless micode users accomplished the task about minutes faster than eclipse users on average.
in addition the difference of two groups in totaltime is near significant p value is .
slightly higher than the set .
significance level .
thus we deem that micode users had better performance than eclipse users in this task.
thus we conclude that micode tool can help programmers more efficiently accomplish reuse based development tasks when the tasks require understanding a big design picture and comparing implementation alternatives.
d. threats to validity there are three threats to our user study.
first we assume that two study groups are equivalent despite that individual difference always exists.
to address this threat we carefully compared participants experience and capabilities and randomly allocate comparable participants into the two groups.
second our training session might introduce additional warm up experience for experimental group on using micode which can introduce experimental bias.
according to our pre study survey all the participants are familiar with eclipse ide have eclipse as their most frequent ide .
therefore we deem that such a threat is largely mitigated.
last we conducted the controlled experiment only on one java design as the experimental session had time limitation.
further studies are required to generalize our findings on more systems.
vii.
d iscussion in this section we discuss the difference between design template and design pattern and both reuse and refactoring opportunities conveyed by design templates.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
difference with design pattern.
our mined design template can also be regarded as a pattern of design which is however different from design pattern.
a design pattern is usually intentionally created for code abstraction.
in contrast a design template is usually unintentionally created by code duplication.
therefore the form of design patterns are more fixed while that of design templates are more dynamic.
hence they must be detected with different techniques and convey different information.
technically the design patterns can be detected by matching code with enumerable rules while design templates should be mined with a more generalized way.
semantically the design pattern describes general and project independent design structure while design template describes recurring designs implementing similar project specific feature.
despite of their difference they are not exclusive.
we observe that some of our mined design templates can involve design pattern such factory pattern and strategy pattern .
reuse vs refactoring opportunities.
in this work design templates are largely regarded as reuse opportunities.
the reason lies in as follows.
despite that design templates are usually caused by duplication as showed in fig.
abstraction has already been adopted.
thus the duplication occurs in terms of code structure rather than code text.
with the well organized duplication recurring designs usually convey project specific convention for implementing a similar feature.
nevertheless when the duplicated classes lack sufficient abstraction they can also convey refactoring opportunities indeed.
therefore we deem that it is important to detect recurring templates in the first place so that we can decide the follow up maintenance measure of either reuse or refactoring.
viii.
r elated work a. clone detection both our work and clone detection techniques base on the code similarity measurement.
many researchers transfer code into an abstract form such as string token list ast and pdg to compare their similarity.
a comprehensive survey of code clone reach can be found in .
clone detection techniques aim to detect similar code fragments across software systems.
in contrast our approach detects and extracts correlated similar program elements which unveils a bigger picture in terms of similarity i.e.
recurring designs reusable for code generation.
b. code structure pattern our approach starts at clustering or corresponding relevant program elements for abstraction which is similar to a set of code structure pattern mining work.
basit et al.
leverage frequent mining technique to mine structural clones indicating possible correlation between groups of code clones.
qian et al.
proposed a technique to mine logical clones to reveal similar high level business logic in code base.
moreover lin et al.
proposed a technique to summarize syntactic patterns of code clones and aggregate the code clones with similar patterns.
our approach is different from these techniques in two folds.
first the patterns mined from abovetechniques are less expressive for the purpose of revealing recurring designs.
in contrast our approach is able to capture a rich set of program elements and program relations so that the mined template could represent sophisticated design in practice.
second the patterns of the above techniques are generated as knowledge meanwhile our mined design templates are customizable for code generation which can better facilitate programmers in real reuse based software maintenance tasks.
c. reverse engineering and spl re engineering many reverse engineering methods have been proposed to recover system design or architecture from the source code of a software system.
we consider reverse engineering methods as a basis and leverage it for the purpose of template mining.
with similar purpose some research work reverse engineers source code for reengineering legacy variant products into software product line .
haslinger et al.
extracted spl feature models by analyzing configuration scripts of variant products.
valente et al.
proposed a semiautomatic approach to identify the code of optional features in spls.
martinez et al.
proposed an approach to migrate existing similar model variants into a software product line.
in addition fischer et al.
developed a tool called ecco to utilize reusable features from existing similar products to help programmers systematically compose a new variant product.
these spl re engineering approaches often aim to recover a system level spl architecture for systematically developing and maintaining a set of variant products in a specific domain.
our work is similar with the above technique for the same purpose of code reuse.
nevertheless our main differences with these approaches lie in that we take code base instead of variant products or model as input and the design template is extracted in more finer grain.
ix.
c onclusion and future work the paper presents an approach to detecting and extracting implicit recurring code designs in code base into customizable design templates for code generation.
we developed template editor to manage and customize design templates and code generator to generate code skeleton filled with semiimplemented code.
our simulation experiment shows that the design templates are useful to facilitate design level reuse task.
our user study shows that the micode tool helps the programmers to reuse recurring designs in code base more efficiently compared with copy paste modify practice.
in the future we aim to apply our approach to crowdsourced code examples available online e.g.
github to build featureoriented template libraries.
acknowledge this research has been supported by the national research foundation singapore no.
nrf2015ncr ncr003 the national key research and development program of china under grant no.
2016yfb1000801 and the national natural science foundation of china under grant no.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.