effective and precise dynamic detection of hidden races for java programs yan cai state key laboratory of computer science institute of software chinese academy of sciences beijing china ycai.mail gmail.com lingwei cao state key laboratory of computer science institute of software chinese academy of sciences beijing china lingweicao gmail.com abstract happens before relation is widely used to detect data races dynamically .
however it could easily hide many data races as it is interleaving sensitive.
existing techniques based on randomized scheduling are ineffective on dete cting these hidden races .
in this paper we propose drfinder an effective and precise dynamic technique to detect hidden races .
given an execution drfinder firstly analyzes the lock acquisitions in it and collect s a set of may trigger relations.
each m ay trigger relation consists of a method and a type of a java object.
it indicates that during execution the method may directly or indirectly acquire a lock of the type.
in the subsequent executions of the same program drfinder actively schedules the execution according to the set of collected may trigger relations.
it aims to reverse the set of happens before relation that may exist in the previous executions so as to expose those hidden races.
to effective ly detect hidden race s in each execution drfinder also collects a new set of may trigger relation during its scheduling which is used in its next scheduling .
our experiment on a suite of realworld java multithreaded programs shows that drfinder is effective to detect new data races in runs .
many of these races could not be detected by existing techniques i.e.
fasttrack contest and pct even in runs .
categories and subject descriptors d. .
program verification d. .
testing and debugging testing tools d. .
processing management synchronizations threads.
general terms reliability verification .
keywords data race thread scheduling hidden race synchronization order .
introduction a data race or race for short occurs when two or more threads access a same memory location concurrently and at least one of these accesses is a write .
data race occurrences often indicate other concurrency bugs in the same program .
many dynamic d ata race detectors are based on the locking discipline or the happens before relations hbr for short .
the locking discipline requires every two concurrent access es one of them is a write to a shared memory location to be protected by a common set of lock s. but such lockset based detectors are imprecise .
hbr based detectors or hb detectors for short precisely report a data race only if they observe the two accesses involving in a race not ordered by any hbr in an execution trace .
in this paper we use the two terms execution and trace interchangeably.
some races in a program can be easily exposed in many traces and hb detectors can effectively detect them.
there are other races that are difficult to be detected due to reasons like conditional variables and ad hoc synchronizations .
they can be detected by two most recent technique s rvpredict through data flow analysis offline and racageddon through generating specific test input s for each predicted race .
hb detector s are interleaving sensitive .
they may miss to detect a race if the two accesses of this race are ordered by hbr s in an execution but the same race can be detected in another execution with a different thread interleavi ng such that no hbr orders the two accesses .
that is such a race is hidden by hb edges in some executions .
some of these races even on repeated executions can still be hard to detect .
for ease of reference we refer to such a race as a hidden race also known as a hard race .
this paper focuses on the detection of hidden races.
existing online techniques e.g.
are ineffective to detect hidden races.
randomized scheduling technique s e.g.
pct and contest only randomly identify changed point s or insert random time delays to modify thread priorit ies.
they are ineffective in exposing races whose accesses are separated by consecutive sequence s of locking order s among threads.
active testing e.g.
racageddon and rvpredict techniques are built on top of random or native scheduling and or concurrency bug patterns to produce a predictive trace for potential race analysis.
it fails to be successfully applied if no hidden race can be predicted in the predictive run.
besides they need many runs to deem a potential race as a false positive with confidence .
coverage driven testing techniques or using adequacy criteria demand either patterns of problematic memory accesses as well as synchronization operations or applicable adequacy criteria as inputs.
to the best of our knowledge there is no effective patt ern or adequacy criterion for hidden races discovered yet.
as such a key challenge for dynamic race detectors is to generate execution s that effective ly expose hidden races .
offline techniques to may infer hidden races .
the causally precedes cp detector can interestingly predict hidde n races in a given trace under limited scenarios .
cp is however inapplicable if a hidden race is separated by hbr i.e.
hb edges having conflicting data accesses .
also a nalyzing large traces e.g.
corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
esec fse august september bergamo italy acm.
... .
running eclipse for hour of code development by cp is still impractical besides no online cp detector has been invented yet .
rvpredict confirm s each predicted data race via constraint solving .
like other predictive technique s it needs to solve the scheduling constraint s for each predicted data race which may fail .
our work exploit s two observation s many races hidden in one execution can be detected by reversing the direction of one or more consecutive hbrs in another execution and in real world programs only a small proportion of methods generate s lock acquisition events and these methods usually generate events on designated instead of arbitrary lock objects .
in this paper we propose drfinder data races finder a dynamic technique to detect hidden races by reversing possible hbrs.
drfinder is based on may trigger relation .
this relation relates a method to a type of lock object in java programs .
it represents that the method may directly or indirectly by calling several other methods trigger a lock acquisition on a lock object of that type.
drfinder consists of two phases.
figure shows an overview of drfinder .
in phase i drfinder analyzes each lock acquisition event in a given trace to relate each selected method to the type of the lock object of the event and takes them as a set of may trigger relations i.e.
mtr in figure .
in phase ii it generates a trace for hidden race detection based on the collected set of may trigger relation .
specifically if a thread generates a lock acquisition event e1 on a lock of type c and some other thread may trigger a lock acquisition event e2 on a lock of the same type c drfinder postpones the execution of e1 until an expected event e2 occurs .
as such the locking order on these two events that they may form in the trace analyzed in phase i is reversed .
in this way the races originally hidden by such hb rs are exposed in the later trace .
drfinder also collects a set of new may trigger relations in each scheduled execution which is used in the next scheduled execution.
this feedback mechanism makes drfinder effective to detect new hidden races in each its scheduled execution.
we have implemented drfinder in the jikes rvm and evaluated it on the dacapo benchmarks .
the experi mental result shows that drfinder finds races that cannot be effectively detected by both native runs contest and pct configured with fasttrack .
in total drfinder detects new data races on dacapo benchmarks within runs each.
besides many of these new races could not be detected by existing techniques in runs.
in summary the main contribution s of this paper are this paper propose s a may trigger relation and a novel hidden data race detector drfinder .
drfinder predicts locking orders and makes decisions on the reversal s of locking orders at the may trigger relation level.
it profile s no memory accesses in phase i and only carries forward the may trigger relations between phases.
it reports the feasib ility of drfinder by implement ing it as a prototype tool in the jikes rvm .
it presents an experiment to evaluate drfinder .
in the experiment drfinder detect s new races and is promising in exposing hidden races.
drfinder is scalable to large scale java programs e.g.
eclipse .
in the rest of this paper section reviews preliminaries followed by a motivating exampl e in section .
section s and present the design rationales and the details of drfinder respectively.
section reports the evaluation of drfinder .
in sections and we discuss the related work and conclude this paper respectively .
.
preliminaries a multithreaded java program p contains a set of c lasses denoted as c. each class c in c consists of a set of fields and a set of methods.
we denote the set of all methods of p as m. an object o o is an instance of a class c and the type of o denoted as type o is c. each lock is an instance of a class.
each thread t in program p executes a nested sequence of methods.
each method may execute a set of operations op rd wr acq rel enter return where rd and wr mean read and write to a field of a class instance respectively acq and rel mean acquisition and release of a lock respectively and enter and return mean a call and a return to and from a method respectively .
an event e t op o mean s that a thread t performs an operation op op on an object o o m. we denote o in e by object e .
a trace is a sequence of events.
the happens before relation hbr in a trace is defined by three rules if two events and are performed by the same thread and appeared before then .
if two events t rel m and t acq m are performed by two different threads and appeared before then .
if and then .
two memory events e1 t1 op1 v1 and e2 t2 op2 v2 form a race on v1 if t1 t2 v1 v2 wr op1 op2 and neither e1 e2 nor e2 e1.
the relation e1 e2 is called a n hb edge if e1 t1 rel l e2 t2 acq l and t1 t2 .
for instance the two arrow s in figure depict two hb edge s e1 e9 and e3 e6 where sync o ... denotes a pair of events acq o ... rel o and we will use this short form in section .
given two traces and and a pair of events e1 and e2 if e1 and e2 form a race in but does not form any race in then the race is called a hidden race in .
in a java program each thread starts its execution from its method run .
.
motivating example figure shows our motivating example where each threa d i.e.
t1 t2 or t3 executes a sequence of events from top to bottom.
these events are memory accesses i.e.
m1 to m4 to the locations x and y and lock acquisition release events i.e.
e1 to e9 on seven lock objects k n and o1 to o1.
the two hb edges e1 e9 and e3 e6 on the two lock objects n and k respectively are denoted as arrows.
we denote the trace as 1 ... e1... e9... e3... e6... .
the two pairs of accesses to locations x and y i.e.
m1 may trigger collector data raceshb race detectordrfinder scheduleracquire release enter return acquire release enter returnphase i mtr mt f c trace 2trace phase iia depth value d a data race is hidden by a hb edge.
a data race is exposed by drfinder .acquire release read write figure .
an overview of drfinder .
and m4 and m2 and m3 are ordered by the hb edges e1 e9 and e3 e6 respectively.
hence no hb detector can detect any race in the trace 1. next we reverse the direction of each hb edge shown in figure to sketch figure which represents the trace 2 ... e9... e1... e6... e3... of the same program.
a n hb detector can now report the two hidden races on x and y in 1. if a native schedule exhibits the trace 1 as shown in figure the probability to observe the trace 2 shown in figure is very low .
hence the two races may not be easily detected.
na ve strategy a naive strategy is to suspend every lock acquisition event observed in a trace before executing the event.
for trace 2 it suspends the three threads from executing e1 e4 and e7 respectively producing an occurrence of the suspension of all the threads of the trace known as thrashing .
thrashing is typically resolved by randomly resuming one of the suspended threads .
there is no thoughtful design to ensure e9 e1 in order to expose the hidden race on x effectively.
offline techniques cp can infer these two races from 1 providing that no conflicting memory accesses exist inside the synchronization bod ies of e1 and e9.
that is if z is a new location where e1 protects a write access to z i.e.
e1 sync k ... wr z ... and e9 protects a read access to z i.e.
e9 sync k ... rd z ... .
then the race on x cannot be detected by cp and the case on y is similar .
this is restrictive.
in their experiment on only out of programs can cp detect and more races than fasttrack an online hb d etector .
online randomized schedulers contest inserts a small amount of random time delays on some lock acquisitions.
suppose that e1 is generated but not executed by t1 yet.
a small time delay in between the generation and execution of e1 may not be long enough for t3 to have generated and executed e9 which depends on both the underlying native or randomized scheduler and the sequence of operations performed by t3 in between the current execution point and e9.
the design of contest is insensitive to both factors.
pct provides a theoretical guarantee to find a concurrency bug but this guarantee is very low even for the illustrating example .
its guarantee d probability i.e.
n kbugdept h where n is the number of threads and k is the number of instructions executed also decrease s exponentially as bugdept h increases .
from our first hand experience many bugs can be d etected using as bugdept h and yet a significant amount of races still cannot be detected using much deeper depths with runs.
our technique drfinder can effectively reverse the two hb edges e1 e9 and e3 e6 observed in the trace 1 when generating the trace 2. when observing e1 it effectively foresee s the execution of the event e9 and similarly when observing e3 it effectively foresee s the execution of the event e6.
drfinder achieves this prediction via a novel strategy.
we denote the types of the lock objects k n o1 to o5 as ck cn c1 to c5 respectively and the methods that contain above events as f1 to c8 as shown in figure where an upper method in a column invokes the method immediately below it e.g.
f1 invokes f2 .
specifically in phase i drfinder constructs every may trigger relation mt f c see section .
for definition between a method f and a lock object type c observed in 1. each may trigger relation mt f c means that f may trigger a lock acquisition event on a lock object of type c. table shows the set of may trigger relations constructed from 1 in figure .
note that may trigger relation also considers program call stack not a single function.
in phase ii firstly s uppose that t2 is executing some event s in the method f3 and t3 is execu ting some event s in the method f6.
when drfinder observes the event e1 produced by t1 it checks the maytrigger relations involving f3 and f6 i.e.
the two methods being executed by the other two threads t2 and t3 respectively and finds a may trigger relation mt f6 ck meaning that f6 may trigger a lock acquisition event o n an object of type ck which is the same type as that of e1.
drfinder thus suspends t1 depicted as a solid rectangle in figure and sets t1 to wait for an event of th is object type ck.
it further escort s t3 to execute all its events until t3 executes the event e9 which is the first encountered event on a lock object having the type ck.
drfinder then resumes t1 to execute e1 to form the targeted hb edge e9 e1.
a further execution of the two threads will execute memory accesses on x which expose the hidden race on x. next it is feasible for t1 to execute e2 or for t2 to execute e4.
because neither mt f4 type o1 nor mt f2 type o2 matches any may trigger relation drfinder resolves the tie randomly suppose that t1 is selected .
when t1 generates e3 drfinder finds that mt f4 type n is a may trigger relation.
thus it suspends t1 and escorts t2 to execute until t2 has executed e6.
after that t1 executes e3 and the hb edge e6 e3 is formed.
when t2 executes m3 the race on y is detected.
suppose that t2 executes e4 first.
table .
the may trigger relation for methods and lock object types of program shown in figure .
may trigger relation may trigger relation mt f1 ck mt f1 c1 mt f1 cn mt f5 cn mt f2 c1 mt f2 cn mt f6 c4 mt f6 c5 mt f6 ck mt f3 c2 mt f3 c3 mt f3 cn mt f7 c4 mt f7 c5 mt f7 ck mt f4 c2 mt f4 c3 mt f4 cn mt f8 ck t1 e c ... e2 sync o1 ... e c ... t2 e4 sync o2 ... e5 sync o3 ... e c ... t3 e7 sync o4 ... e8 sync o5 ... e c ... f1 f2f3 f4 f5f6 f7 f8 figure .
a trace generated by drfinder exposed two races on x and y. t1 e c ... e2 sync o1 ... e c ... t2 e4 sync o2 ... e5 sync o3 ... e c ... t3 e7 sync o4 ... e8 sync o5 ... e c ... f1 f2f3 f4 f5f6 f7 f8 figure .
a trace hiding two races on x and y as two hb edges e e and e e order the two accesses of each race respectively.
when t2 further generates e5 drfinder finds that mt f2 type o3 does not match any may trigger relation.
thus both threads t1 and t2 may proceed further .
so drfinder resolves the tie randomly.
if t1 is selected to execute first a race on y is detected.
otherwise no race is reported because the hb edge between e3 and e6 is still e3 e6.
.
design rationales in this section we present the design rationales of drfinder with the help of two traces 1 and 2 and the ir corresponding set of hb edges are and respectively.
besides t here are two threads t1 and t2 in two traces and they produce two events e1 and e2 respectively in trace 1 however the two events may not be produced by two threads in trace 2. .
basic requirements we recall that a hidden race is difficult to expose in a trace generated by a native scheduler or a pure randomized scheduler.
that is although the two accesses involving in a hidden race may appear in a trace yet the pair of accesses may be separated by non trivial numbers of hb edges e.g.
the two accesses m1 and m4 in figure .
for ease of reference we refer to such a native or pure randomized scheduler as a default scheduler.
a strategy modeled after the above i ntuition is as follows in phase i a technique observes the set of hb edges in the trace 1 produced by a default scheduler.
then in phase ii it aims to reverse the directions of some hb edges in on generating the trace 2. that is if the two events e1 e2 it aims to produce e2 e1 if possible as shown in figure a and b respectively .
as such a dynamic hidden race detector should aim to phase i keep a sub set of hb edges i.e.
in trace 1 phase ii and schedule a subsequent execution generating trace 2 to reverse hb edges in to expose race s hidden in trace 1. however drfinder does not target to keep any hb edges as which usually incur s high runtime overhead .
it tries to predict hb edges dynamically via the type of locks.
in the next two subsections we present how drfinder achieves this aim to reverse hb edges .
.
reversing happens before edges suppose that e1 e2 is an hb edge in as depicted in figure a there is a good chance that using the default scheduler e1 e2 may also exist in .
that is most of hb edges in cannot be easily reversed in .
therefore our target is to actively produce e2 e1 as depicted in figure b .
suppose that during the execution to generate the trace 2 both events e1 and e2 exist.
in theory a precise but hypothetical strategy can be formulated as follows however implementing such a strategy is challenging if there is no such an event e2 in trace 2 then the hb edge e2 e1 will not exist and no hb edge needs to be reversed.
hence above strategy will suspend the thread t1 until the thread t2 terminates.
if all events or at least lock acquisition events in trace 1 are logged to check the existence of an event e2 it is necessary to compute an object abstraction e.g.
a unique id for each event.
however before the occurrence of e2 there is no way to compute an object abstraction for e2.
therefore an effective technique must address a problem given an event e1 to be executed by a thread t1 how to determine whether some other thread t2 will execute an event e2 such that object e2 object e1 without computing a n object abstraction for each event ?
.
stack and type based events predictions let us refine the problem further as the two events e1 and e2 should be ca usally related otherwise there is no need to consider them to form a n hb edge .
suppose that when t1 is about to execute e1 thread t2 is executing an event e within the body of a method fk as shown in figure a .
to ease our explanation we refer to the current call stack of thread t2 as stack s. if the event e2 will occur in future in the execution of t2 there will be another call stack fragment s1 in the below backward case or s2 in the below f orward case backward case shown in figure b after thread t2 returns from method fk recursively to a method f1 and then calls some other methods an event e2 from a method fd is executed.
we refer to the two call stack fragments f1 ... fk and f1 ... fd as s and s1 respectively as depicted .
forward case shown in figure c before thread t2 returns from its execution in method fk it further calls some methods and then an event e2 from a method fd is executed.
we refer to the call stack fragments fk ... fd as s2 as depicted.
therefore to predict the existence of event e2 thread t2 should be aware of the method fd in backward case or the method fd in forward case that execute s an event e2.
to do so it is necessary to record the events that a given method will execute directly or indirectly i.e.
via calling other methods .
with such information given an event e from a method fk it becomes easy to know whether there will be an event e2.
however directly implementing above idea to detect hidden race s is ineffective or even does not work.
it is b ecause each method once called directly for event within this method or indirectly for events out of this method executes all later events.
for example the method run executes all events.
therefore to make the prediction of an event effective for detection of hidden races via reversing hb edges the used stack should be limited.
in other words only some methods in a stack should be used to do prediction but not all.
let s further review the two cases.
for backward case we can observe from figure b that the effective call stack to predict the event e2 when thread t2 is executing an event e in method fk is only the stack fragments s and s1.
similarly for forward case the effective stack is the stack fragment s2.
therefore we only use the stack fragments s and s1 or s2 to predict events.
in theory the size of the stack s can range from to infinite.
in this paper we aim to prese nt the basic model of to reverse an hb edge from e1 e2 to e2 e1 the thread t1 should be suspended when it generates but does not execute the event e1 until the thread t2 has executed the event e2.
t2t e1 e2 a observed trace 1 b targeted trace 2e1 e2t2t figure .
reversing an hb edge.
drfinder .
hence we choose the size of s to be which is a minimal setting .
in this case we have fk f1.
therefore the two cases i.e.
backward case and forward case are actually the same one.
and the prediction of event e2 is based on one stack fragment i.e.
s1 or s2 to be formed.
thus we propose our stack based events prediction model m to predict the event e2 as follows we refer to the size of the above stack s1 plus the method fd as the depth d of model m. model m looks forward to see whether there will be a sequence of at most d methods i.e.
s1 with the last method containing an above discussed event e2.
however for above prediction model w e still need to address a new problem given an event e1 by t1 and a stack s of t2 does there exist a method fd in the stack contains an event e2?
we propose the may trigger relation to further predict whether a given method will trigger a certain event.
suppose that there is an event e from a method f such that e e2.
then we must have object e object e2 and type object e type object e2 .
our insight is that in real world java programs most methods only acquire specific instead of arbitrary lock objects and their method instances often follow the same locking patterns.
we propose to use the type of a lock object in a lock acquisition event to predict the possible occurrence of the event e2 to achieve the reversal of the hb edges from e1 e2 in to e2 e1 in .
formally may trigger relation is defined as follows given a method f a type c and an execution trace .
if a method f is reachable from f during the generation of a trace by a sequence of at most d methods and f produce s an event e t acq o such that type o c then we sa y f and c forms a may trigger relation mtr for short denoted as mt f c .
drfinder is developed on top of m using mtr to predict occurrence s of event s like e2 to schedule a program to detect hidden races.
it uses two pieces of information for its prediction an event e1 from a thread t1 and a method f1 from a second thread t2 and a depth d. it interestingly predict s the presence of an event e2 by check ing whether mt f1 type e1 is a mtr identified from 1. .
effective scheduling via feedbacks from above discussion drfinder execute s a program once to collect a set of mtr and then schedule s the program execution based on the relation set.
however races in a program cannot be dynamically detected in merely one run.
therefore it is necessary for drfinder to execute a program multiple times to detect more hidden races.
on the other hand if a same set of mtr relation is used in each execution by drfinder the increment of new races detected is marginal.
actually after the first scheduling execution by drfinder the probability to detect new hidden races for drfinder at its other subsequent executions is the same as the existing dynamic techniques e.g.
fasttrack and may be even lower than existing active schedulers e.g.
pct .
it is because the subsequent executions are similar to the first scheduled execution as they are scheduled by drfinder based on a same set of mtr .
therefore we design drfinder at each of its executions to both schedule the execution and collect a new set of mtr from the execution being scheduled .
the newly collected set of mtr is regarded as a feedback to be used in the next execution by drfinder .
as such drfinder is able to effectively schedule each execution based on a set of mtr exactly from the previous execution to detect new hidden races .
this feedback mechanism is also depicted in figure .
.
drfinder in details .
phase i may trigger relation collector the mtcollector algorithm is responsible to collect may trigger relations shown in algorithm .
given a program p and a depth d mtcollector executes the program and collects a set of may trigger relations i.e.
mtr in algorithm from the observed trace.
algorithm first assigns the set of all threads in p to the set enabled null to mtr and assigns stack t for each thread t in enabled to empty at line s .
it uses t he data structure stack t to keep track of the call stack fragment.
it then uses randomized scheduling to execute the program p by selecting the next event e during the generation of a trace 2 if a thread t2 is executing an event e from a meth od fk and there exists a method fd such that the method fd contains an event e2 and is reachable by thread t2 via a sequence methods s1 after executing the event e then thread t2 will execute the event e2.
algorithm drfinder .mtcollector .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
input p a given program output mtr may trigger relations enabled all threads in p mtr stack t for each thread t enabled method stack while enabled do let t be a random thread from enabled .
let e t op o be the next event of t. if op enter then push o into stack t o is a method else if op return then pop out from stack t else if op acq then for i to min d stack t .size do let f stack t .get i collect lock type mtr mtr mt f type o end for end if execute e end while t2t1 e1 e2 a current execution of two threadse f1 fkfd e2 b backward casef1 fk fd s run s s1 fk fd e e2 c forward casesrun s2 e stack s figure .
call stack based prediction of event e .
i.e.
t op o from a random thread lines and check s the operation op of the event e if op is either enter or return algorithm pushes the method o into the stack t or pops out the topmost method from the stack t respectively lines .
if op is acq algorithm updates mtr mtr mt f type o for each method f in the top d methods in the stack t lines to maintain may trigger relations .
then the algorithm executes the event at line .
.
part a of phase ii drfinder agent the agent algorithm is responsible to execute each event .
for the acq events their executions depend on scheduler .
algorithm accepts the given program p the set mtr i.e.
maytrigger relations from phase i and a n hb race detector rd.
it returns a set of new may trigger relations i.e.
mtr .
algorithm firstly assigns the set of all threads of p to the set enabled which is shared by both agent and scheduler and set mtr to be empty line .
it then starts scheduler i.e.
algorithm to be presented in section .
through a fork call line .
next it takes a next event e t op o from a random thread t lines and checks the operation op of the event e. if op is acq agent asks scheduler whether t is allowed to execute e through a function call to requestalock of scheduler line .
if the function returns a false value agent simply keeps e from execution.
note the thread t has been removed from enabled by scheduler at line in algorithm .
if requestalock does not return a false value line agent will both execute and pass e to the race detector rd lines .
finally if e is an acq event agent also informs scheduler that the thread t has acquired the lock object specified in e via function lockacquired lines .
it also collects a new set of mtr at line which is based on algorithm as the input mtr of the next scheduling execution.
.
part b of phase ii drfinder scheduler scheduler algorithm maintain s four data structures aths rths allowedth and allowedlk lines to make scheduling decision aths is a set of all the threads in the program p. rths is a set of pairs of a thread t and a lock object o each of which representing that t is requesting to acquire the object o but scheduler suspends this acquisition.
thus all the threads in this set are waiting to be scheduled by scheduler .
for ease of our presentation we use rths .get t to denote the lock o paired with the thread t. allowedth keep s a particular thread t that both i is escorted by drfinder with a top priority to execute its lock acquisition events and ii is the thread expected by drfinder to acquire a lock object defined by allowedlk .
allowedlk keeps a lock object o. drfinder expects the thread defined by allowedth to acquire a lock object having the same type as this lock object.
scheduler consists of four functions requestalock lockacquired maytrigger and schedule .
in section .
we have presented that agent algorithm invoke s the first two functions.
we first ly present them followed by presenting schedule which is the core part of drfinder .
the function requestalock is called by agent on determining whether to execut e the event e i.e.
the lock acquisition on o by t .
it checks whether the given thread t is a chosen thread to execute any event i.e.
allowedth at line .
as such a targeted hb edge may be formed as soon as it can.
if a true value is returned it indicates that the event e is allowed to execute line otherwise the thread t is added to the set rths and is also removed from the set enabled lines so that agent will not pick any event of it for execution line in algorithm .
next the function notifies scheduler that there is a thread to be scheduled see line to be explained below .
on the other hand if it return s a false value at line it indicates that the event e is not allowed to be executed .
the function lockacquired is called by agent right after a lock acquisition event e is executed lines in algorithm .
it checks whether the executed lock acquisition event e is an event expected by scheduler line .
an event e t op o is an expected event if t is the thread defined by allowedth i.e.
t allowedth and e operates on a lock object defined by allowedlk i.e.
type o type allowedlk at line .
if so an expected event occurs and scheduler resets both allowedth and allowedlk to null line .
it then notifies function schedule that there is no thread marked as allowedth line .
we are going to explain the function schedule .
scheduler is started by agent at line in algorithm .
if no thread is requesting any lock object i.e.
rths .size or there is no event expected by scheduler i.e.
allowedth at line the function schedule just waits for notifyscheduler to notify it at either line or line .
once schedule is notified the same function selects a random thread t from the set aths.
it then checks whether there is any thread whose current ly executing method f and the type of the given object o match any may trigger relation kept in mtr via maytrigger lines .
all the threads that match this condition are collected as the set ct line in which a thread t is randomly selected and escorted by drfinder to execute all its events before t is allowed to continue its execution line .
the function then assigns the thread t and the lock object o to allowedth and allowedlk respectively lines .
if the thread t is also in the set rths t will be removed from rths and added to enabled lines .
scheduler then waits until the thread t being escorted by drfinder has acquired a lock object having the type algorithm drfinder .agent .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
input p a given program.
input mtr may trigger relations returned by mtcollector input rd an hb race detector e.g.
fasttrack output mtr a set of new may trigger relations feedbacks enabled all threads in p mtr fork schedule start scheduler in algorithm while enabled do let t be a random thread from enabled .
let e t op o be the next event of t. if op acq then allow drfinder .scheduler.
requestalock t o if allow false then continue while loop end if end if execute e rd.onevent e for detection of data races if op acq then drfinder .scheduler.
lockacquired t o end if update mtr according to algorithm end while type allowedlk see the function lockacquired lines .
otherwise if ct is empty line the thread t is allowed to execut e lines .
the function maytrigger accepts two threads t and t as its parameters.
this function firstly gets the lock object o being requested by t i.e.
paired with t in rths and the current executing method f of t line .
it then checks whether the tuple f type o is a valid may trigger relation i.e.
in the set mtr and returns a true or false result accordingl y lines .
.
discussion drfinder is an active scheduler.
it suffers from thrashing and may lead the execution to form deadlocks .
similar to existing techniques when a thrashing occurs drfinder randomly selects a suspended thread to execute and when a deadlock occurs the whole execution is restarted see section .
.
drfinder actively sc hedules an execution to produce hb edges that cannot be easily formed in normal executions to expose races.
it drives a happens before based detector e.g.
fasttrack to detect races precisely and report all races.
therefore like other hb detectors drfinder is also precise .
.
experiment this section present s our evaluation on drfinder and its comparison with the state of the art hb race detector fasttrack a random delay scheduler contest and a state of the art randomized scheduler pct .
all these techniques are reviewed in sections and .
.
implementation and benchmarks implementation .
we implemented drfinder fasttrack contest and pct in jikes rvm .
jikes rvm is a java virtual machine developed almost in java language and could be run on linux and mac osx systems.
these tools report a race at the java class field level .
our tool uses the shadow mechanism to track the state of an execution and adds a shadow lock to each object instance to keep the vector clock data and type information .
for each memory location i.e.
an instance of a field of a java class it allocate s a shadow memory to track the read s and write s to this memory location .
for each thread it adds a member in the rvmthread class to keep the java thread data.
to generate memory and synchronization events in runtime our tool instruments each class wh en it is loaded except those jikes rvm classes and java standard library classes .
it uses a static escape analysis to identify access es to provably thread loc al memory locatio n. it also fully tracks happens before relation s on other program semantics e.g.
accesses to volatile field s .
our implementation periodically monitors the state s of all threads by tracking various synchronizations events and scheduling of drfinder as well as other functions calls e.g.
sleep .
such monitor ing i s helpful to identify deadlock ocucrrences and thrashing occurrences.
benchmarks .
we used the dapaco benchmark suite to evaluate drfinder .
we selected two multithreaded programs from dacapo m1 xalan and eclipse and five multithreaded programs from dacapo xlan09 pmd09 sunflow luindex and lusearch .
dacapo includes other multithreaded benchmarks however they cannot be run on the latest jikes rvm .
.
even without our tool .
in total we selected multithreaded benchmarks including a large scale real word program eclipse eclipse .
table shows the descripti ve statistics of the benchmarks .
the first two column s show the benchmark name and size .
the third column table .
descriptive and execution statistics of benchmarks .
benchmark jar files size kb of locks threads of methods with sync of hb edges xalan .
.
eclipse .
.
xalan .
.
pmd .
.
sunflow .
.
luindex .
.
lusearch .
.
total .
.
algorithm drfinder .scheduler .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
aths all threads in p rths a set of pairs of threads and locks allowedth a thread that is expected to acquire a lock allowedlk the lock expected to be acquired function requestalock t o if allowedth t then return true else rths .add t o enabled enabled t notifyscheduler return false end if end function function lockacquired t o if allowedth t and type allowedlk type o then allowedth allowedlk notifyscheduler end if end function function maytrigger t t let o rths .get t f getcurrentmethod t if mt f c mtr such that c type o then return true end if return false end function function schedule while agent does not exit do while rths .size or allowedth do wait end while t a random thread from aths candidatethread ct for each thread t aths do if t t and maytrigger t t then ct ct t end if end for if ct then t a random thread from ct allowedth t allowedlk rths .get t if t rths then enabled enabled t rths .remove t end if while allowedth do wait end while end if enabled enabled t rths .remove t allowedth t let t to acquire the lock rths .get t allowedlk rths .get t end while end function show s the number s of locks and threads in the benchmarks .
the last two columns show the number s of methods all and those containing lock acquisitions and the mean number of hb edges in each benchmark over runs .
all dynamic data are collected under native schedul ing.
.
experiment al setup our experiment was performed on an apple mac pro with .6ghz intel core i5 and 8gb memory ru nning os x .
.
.
we compiled jikes rvm with gnu class path .
.
we configured fasttrack with the native os scheduler with contest with pct and with drfinder which are refer red to as ft ct pct and dr respectively .
we follow ed the previous experiments and ran each technique on each subject for times .
.
experiment al results table summaries the experimental results.
the first column shows the benchmark name.
the second major column shows the number of distinct data races reported by each technique in runs .
the third major column shows the number of new data races detected by dr but not detected by ft ct and pct .
the fourth major column shows that the total number of distinct races detected by all four techniques.
the fifth major column shows the number of races not detected by each technique compared to the total number of distinct races i.e.
the data in the fourth major column .
the sixth major column shows the mean time in second s for each technique to run each benchmark .
it also show s the time of native run i.e.
without any testing tool and the time needed by both phases of dr as p i and p ii respectively .
the overhead of each technique is also calculated .
the last column shows the thrashing rate thrash.
rate of dr. the last row shows either the total sum or the mean value avg of each column.
.
.
summary of results effectiveness .
from table the second and third major columns dr detect s more races on out of benchmarks by .
to .
.
on the remaining two benchmarks all four techniques detect the same set of data races.
in total dr detects more new races from all benchmark s. we find that ft ct and pct detect almost the same set of data races where the difference is at most .
this is consistent with an intuition that the random sleep strategy used by ct is not quite effective and randomized scheduling strategy used by pct is also not quite effective without a larger number of runs.
performance .
from the column on time we observe that ft has the best performance which is expected.
the overhea d of ct on top of ft ranges from .
1x to .28x except on eclipse .
for pct it incurs about .2x higher overhead than dr on average .
note that there is a parallel version of pct known as ppct that has the same effectiveness but runs faster than pct .
hence the time overhead of pct in table is for reference only and we do not discuss the overhead of pct in the next paragraph.
we believe our drfinder could also be implemented in parallel and we leave it as a future work.
the overhead of the phase i of dr is only .
x. the overhead of dr phase ii on top of ft ranges from .
x to .
x. on average dr only incurs .65x on top of ft. on eclipse ct incurs a heavy overhead which is .5x on top of ft but dr only incurs .1x on top of ft. although eclipse include d threads in most of the execution time there are only two active thread s. we find that dr is able to suspend these two threads according to their locking orders most of the time .
but ct has to delay each lock acquisition by a random period .
as a result the total time overhead of ct is much heav ier than that of dr on this benchmark.
thrashing rate .
from the last column of table dr is able to make successful thread suspension decision s in nearly of all cases.
in the remaining cases .
thrashing occurred.
we have in spected these thrashing occurrences and found that about half of them were caused due to the type of the unique and global instance of class loader class used by the dacapo t est harness to load each class instead of the program under test.
this harness strictly speaking is not a part of each benchmark.
in our experiment we have not seen any deadlock occurrence.
.
.
comparison on not detected races table also show s the total number of distinct races detected by all four techniques in the fourth major column .
it also shows the number of races that are not detected by each technique but detected by other three techniques in the fifth major column.
overall speaking among all detected races detected by all four techniques on all the benchmarks dr only miss es races however ft ct and pct misse s and races respecti vely.
from above analyses we find that dr is effective in exposing hidden races but it may be unable to expose some races that can be detected by hb detectors with random ized or native schedul ing.
we argue that this is not a major issue.
it is because in practice one may run a program with random or native scheduling to detect these races e.g.
configured in phase i of dr followed by detecting the hidden races in phase ii of dr. we have checked the races not detected by dr and found that almost all races have been detected by ft in each of runs and the remaining ones can be detected by ft in at least one run .
.
.
comparison on races detected in runs figure shows the cumulative number of races detected in the experiment by the four techniques on each benchmark except on luindex on which all three techniques detected exactly one race in each run .
the x axis shows these runs and y axis shows the cumulative number of races detected .
table .
summary of results on runs for fasttrack ft contest ct pct and drfinder dr depth d .
bench mark total races by new races by dr total races missed races time in seconds slowdown factor thrash .
rate ft ct pct dr ft ct pct dr native ft ct pct dr p i dr p ii xalan .
.
.
.
.
.
.
.
.
.
.
.
.
eclipse .
.
.
.
.
.
.
.
.
.
.
.
xalan .
.
.
.
.
.
.
.
.
.
.
.
.
pmd .
.
.
.
.
.
.
.
.
.
.
.
sunflow .
.
.
.
.
.
.
.
.
.
.
.
.
luindex .
.
.
.
.
.
.
.
.
.
.
.
.
lusearch .
.
.
.
.
.
.
.
.
.
.
.
.
sum .
avg .
.
.
.
.
.
figure shows that ft ct and pct almost always detect the same number s of races except on eclipse .
this indicate s that they have similar race detection ability among all runs where the detected races are almost the same ones .
whereas dr has an increasing trend on the number of detected races .
apparently dr may detec t fewer races in some runs e.g.
the first five runs on xalan09 .
but we have shown in table that dr actually expose s more races.
to measure the ability of dr on the detection of new races with increasing number of runs we further analyze the cumulative number of new data races detected by dr in the first i where i is from to runs.
we normalize this cumulative number by the total number of new races detect ed by dr on the correspond ing benchmark.
the result is shown in figure .
note that we do not show the result on luindex and lusearch in figure as no new races is detected on them .
figure shows that on each benchmark except eclipse all the new races detected by dr were detected in the first runs.
on eclipse almost on each run more new races were detected by dr and moreover more than .
new races were detected in the first runs.
therefore we tend to believe that dr is able to effectively detect hidden races even on large scale multithreaded programs e.g.
eclipse which cannot be detected by ft ct and pct in runs or even up to runs see section .
.
.
.
.
drfinder with different depths in our main experiment we have set the depth to .
to evaluate the ability of dr on its detection of hidden races with different depths we repeated the main experiment for dr but set the depth from to with step in turn where each configuration was also conducted for runs.
the results are summarized in table .
in each data cell the format is x y where the x is the total number of races detected by dr with corresponding depth and the y is the number of new races that cannot be detected by ft ct and pct in their10 runs.
on each benchmark if dr is able to detect mo st new races among all its depths we mark the corresponding cell with gray color.
similarly we do not mark cells corresponding to luindex and lusearch as the data in the either entire row shows that there is no new race detected .
from table we observe that with different depths dr is generally able to detect more races than that detected by ft ct and pct .
dr also detects new races in almost all these depths where the exception is on sunflow .
another observation from table is that when depth values are within and dr is likely to detect a significant amount of new races on top of ft ct and pct .
and these depths values also lead to a larger amounts of total races.
we also highlight these cells in gray color in the last row of table .
in future we will study both how the depth values affect the ability of dr and non parametric strategies to determine the depth .
.
.
further evaluation on new races in the runs by all techniques dr detect s new races.
we further repeatedly ran other three techniques more times until either figure .
number of distinct races detected in runs by ft ct pct and dr. of data racesft ct pct dr of data races of data races of data races of data races of data races a xalan06 b eclipse06 c xalan09 d pmd09 e sunflow09 f lusearch09 figure .
cumulative number of new races detected by dr in each run but missed in all the runs by ft ct and pct.
10percentage of accumulated number of new data races runsxalan06 eclipse06 xalan09 pmd09 sunflow09 table .
the total number of data races detected by dr with depths from to with step in runs.
bench mark dr with a different depth total number of races and number of new races xalan eclipse xalan pmd sunflow luindex lusearch sum they detect the same number of distinct races as that detected by dr or the number of runs is up to on each benchmark except on luindex and lusearch .
on these two benchmarks other three techniques already detect the same set of races as dr in runs.
we found that on eclipse xalan xalan and pmd09 other three techniques could not detect as many races even exhausting all runs as what dr detects in the runs .
on sunflow all three techniques need more than runs to catch up with dr. because eclipse is the largest one in our benchmarks w e further analyze d the ability of ft ct and pct on detect ing the new races from eclipse that are only detected by dr but missed by all the other three in their runs in the main experiment .
the result is shown in figure where we also list the races for comparison .
it shows that ft ct and pct were able to detect only and races out of the races in all runs .
note that in a run ft detect s races.
excluding thes e races it detect s less races than that by pct in all runs.
this experiment o nce more illustrates that dr is effec tive on detecting hidden races.
.
related work many techniques on data race detection have been proposed .
they mainly fall into two groups static techniques and dynamic techniques .
static techniques like relay and locksmith rely on statica lly but imprecisely identifying memory accessing statements that may concurrently visit same memory location s without the protection of the same locksets.
chord reduces the number of false warnings by using several stages of refinement on the entire data race warning set.
but it loses the soundness guarantee of reporting all data races in a program.
many dynamic detectors use the locking discipline to predict races .
however this discipline is not necessarily to be obeyed even for data race free programs so that many false positives may be generated using such a strategy .
hb based dynamic ones can precisely report data race s. however they are sensitive to particular thread interleaving even with improvement which provides less coverage than those using the lockset strategy .
racemob statically detect s data race warnings and distribut es them to a large number of user processes to validate real races.
however racemob only works on limited scenarios where a distributed user site computation is available.
active testing techniques need runs for confirmation after an imprecise race detection phase .
in such a run the schedules are guided by the set of data race warnings to trigger real data races.
this kind of approach is able to confirm real races but cannot eliminate false positives.
drfinder takes another approach by using a precise data race detector i.e.
fasttrack in the first place.
with the inherent limitation of the sensitivity on thread interleaving a n effective thread scheduling technique such as drfinder is a desirable complement with hb detectors if used in our phase i to provide precise data race reports with high coverage.
thread scheduling techniques are more promising to detect races than pure stress testing .
systematic scheduling techniques such as model checking are in theory able to exhaustively execute every schedule.
however due to the state explosion problem enumerating each schedule is not practical for real world programs.
chess sets a heuristic bound on the number of pre emption s to explore the schedules.
also although systematic approaches avoid executing previously explored schedules and are more scalable than pure model check ing techniques they usually incur large overhead s and fail to scale up to handle long running programs.
although improvement for chess exists finding the positions for such bounded exhaustive exploration from a large trace to effectively expose hidden races is challenging .
another type of scheduling technique is based on some coverage criteri a of concurrent programs .
for example maple relies on patterns i.e.
iroots to mine certain coverage to expose concurrency bugs.
however maple is insensitive to detect races requiring reversing more than one hb edge .
existing experiments e.g.
have shown that on a large benchmark like chromium there may be million or more hb edges in a trace.
it is challenging to select an effective subset of all such hb edges to confirm given patterns as maple is designed to confirm one pattern per confirmation run .
besides the relation between the coverage of a specific metric and targeted concurrency bugs cannot be verified in theory.
a previous empirical study has shown that different criteri a have different effectiveness on different testing techniques.
this increases the difficulty of choosing a suitable criterion.
drfinder is specially designed to detect hidden races based on our may trigger relation .
unlike above reviewed systematic scheduling techniques or coverage based techniques that have to restrict their scheduling bound s drfinder is able to scale up to large scale programs i.e.
eclipse in our ben chmark and does not require any bug patterns.
.
conclusion this paper present s a dynamic technique drfinder to detect hidden races in multithreaded java programs .
it tries to revers e possible hb edges based on a type based may trigger relation .
the experiment shows that drfinder is promising in detecting hidden races and detected news races that were missed by existing techniques fasttrack contest and pct .
many new races detected by drfinder in runs cannot be detected by other techniques even in runs.
drfinder is also efficient as it incurs less overhead than other active scheduling techniques ct and pct .
in future we will extend our basic model of drfinder proposed in this paper to further validate its ability on detection of hidden data races.
.