bprove a formal verification framework for business process models flavio corradini fabrizio fornari andrea polini barbara re francesco tiezzi school of science and technology university of camerino camerino italy firstname.lastname unicam.itandrea vandin dtu compute technical university of denmark lyngby denmark anvan dtu.dk abstract business process modelling has acquired increasing relevance in software development.
available notations such as bpmn permit to describe activities of complex organisations.
on the one hand this shortens the communication gap between domain experts and it specialists.
on the other hand this permits to clarify the characteristics of software systems introduced to provide automatic support for such activities.
nevertheless the lack of formal semantics hinders the automatic verification of relevant properties.
this paper presents a novel verification framework for bpmn .
called bprove.
it is based on an operational semantics implemented using maude devised to make the verification general and effective.
a complete tool chain based on the eclipse modelling environment allows for rigorous modelling and analysis of business processes.
the approach has been validated using more than one thousand models available on a publicly accessible repository.
besides showing the performance of bprove this validation demonstrates its practical benefits in identifying correctness issues in real models.
index terms business processes bpmn structural operational semantics maude software verification.
i. i ntroduction a business process bp model generally describes a set of activities that an organisation should perform to fulfil a specific business goal .
in addition it is possible to use such kinds of models in particular the so called collaborations in order to describe the coordination of different organisations that cooperate to achieve a shared goal.
a bp model results from the synthesis of perspectives related to different aspects of an organisation and on the activities that should be performed .
among these the following kinds of information are particularly relevant in order to derive an effective bp model.
the functional perspective describes those units of work also referred as activities included in a bp that may be needed to reach a particular objective.
the behavioral perspective specifies the behavior of the bp defining the control flow relationships between the included activities.
the organisation perspective describes the different actors that are involved in a bp and their message exchange.
such modelling approach has not specifically emerged in relation to the development of software systems.
instead it has initially acquired consensus as an effective way to reflect on how an organisation operates also in relation to possible collaborations with others.
on the other hand such kind ofmodelling activity constitutes an important thrust toward the introduction of software systems.
as it happens for any modelling activity the usage of a modelling notation to describe the reality of interest permits to reduce the communication gap between the different users of the model so to keep the focus just on the relevant aspects.
interestingly possible different users of bp models are domain experts and it professionals.
therefore in the last years bp modelling has emerged as an effective approach in relation to requirements engineering activities in particular for the development of those software systems supporting the bp execution.
the relevance of bp modelling for software development is probably even more evident if we consider the notations inspired by bp modelling that have been proposed with different levels of success as executable languages.
this is for instance the case of service orchestrations expressed using the web services business process execution language .
another common use of bp languages in driving complex software systems concerns process aware information systems which dynamically coordinate different resources people applications and information sources according to what is defined in bp models.
in summary bp modelling has evolved to become an effective way to specify software characteristics and even to program software systems.
as a consequence the relevance of formal verification for bp models has become more and more evident.
in the last years the business process modeling notation bpmn .
an object management group omg standard emerged as one of the most accepted proposals to define bp models.
bpmn success comes from its versatility and capability to represent bp for different purposes.
the notation acquired at first acceptance within business analysts and operators.
successively it has been more and more adopted by it specialists to lead the development and settlement of it systems supporting the execution of a specified process model.
this shift in the usage of the notation is particularly relevant and poses the basis for our work.
indeed omg does not provide a precise definition for the semantics of the notation.
the lack of a precise semantics may not represent a big issue when the notation is used just for communication purposes.
instead its adoption for shaping it systems and even more importantly to apply model driven approaches to .
c ieeease urbana champaign il usa technical research217 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automatic code generation does require the definition of a precise semantics.
to overcome such semantic gap many different proposals can be found in the literature.
use of encodings and composition rules permitting to derive a petri net inspired model is a quite popular approach to provide the semantics of a bp see e.g.
the seminal work in .
in this case the analysis will be conducted on the derived petri net.
other approaches provide instead denotations of bpmn elements with terms in a given process algebra see e.g.
.
in this paper we provide an alternative verification framework that is based on the definition of a native semantics according to a structural operational semantics sos style .
the framework as detailed in the following has some distinctive characteristics it does not make any assumption on the structural properties of the original model.
indeed in order to make the definition of semantic rules easier some approaches assume that models are defined according to good modelling practices.
well structuredness which informally asks for the usage of nested structures is probably the most common assumption.
on the other hand it is quite common in practice that bp designers in particular less experienced ones do not generally follow such a recommendation.
on the other hand some authors suggest that modellers should not be constrained by structural characteristics so to freely represent the reality .
thus it is not uncommon to find models with an arbitrary topology.
it permits easy handling of bpmn elements that can have non local effects and that are difficult to handle with other approaches.
it considers also bpmn communication elements thus dealing with bpmn collaborations.
hence it enables the checking of issues possibly related to messages exchange.
it makes easier to re conduct the results of verification activities to the elements of the original model.
the semantics has been concretely implemented using the formal framework maude .
this implementation has been integrated with the maude model checker to allow the automatic verification of properties of bpmn collaborations.
the resulting verification component has been wrapped as a publicly available web service and a specific plug in for the eclipse modelling environment has also been developed.
in particular the resulting tool allows the user to select the collaboration properties he wants to verify out of a predefined list of intuitive behavioral properties expressed in natural language and then to automatically generate logical formulas and to model check them over the bpmn model.
this makes transparent to the user the use of formal methods by offering a modern integrated development environment equipped with verification facilities for bpmn models.
the result is a complete tool chain for bp modelling and verification which we called bprove.
the verification strategy has been also extensively validated using models from an open repository in order to derive its performance characteristics in relation to bp properties i.e.
soundness and safeness relevant in software implementations.
notably we report on a large set of publicly available models that do not satisfy such properties witnessing the need of enriching bpmn modelling with rigorous analysis techniques.
summing up the major contributions of this paper are an efficient implementation of a formal operational semantics for bpmn within the maude environment which enables the formal analysis of bpmn models a complete tool chain presenting a modelling environment and a service for the automatic verification of properties over the designed bpmn models an extensive validation of the approach.
the rest of the paper is organised as follows.
section ii provides an overview of bpmn.
section iii discusses the main features of the verification framework we propose focusing on its implementation and on the supported verification strategies.
section iv provides an overview of the tool chain.
section v illustrates the results of the validation experiments.
section vi reviews related works mainly focusing on existing tools.
finally section vii concludes by also touching upon directions for future work.
ii.
b ackground notions having understood the rationale of considering business process management on software development for it systems in this section we introduce some basic notions.
in particular we first discuss the phases of the bp life cycle and we introduce bpmn as the reference language for modelling bp.
then we present relevant properties to be checked.
there are many proposals for the generic life cycle of bps deployed within it infrastructures here we refer to a slightly revised version of the one proposed in .
it consists of four phases i design and modelling where domain requirements are collected to produce a model suitable to represent as is or to be scenarios in organisations ii analysis where syntactic structural and behavioral issues of the model are detected iii enactment and execution where the model is deployed based on the underlying it infrastructure iv monitoring and improvement where functional traces and non functional measures from the process execution are collected in order to identify bottlenecks.
in this paper we mainly concentrate on the design and modelling andanalysis phases which are usually completed in an iterative method till reaching a stable release of the model.
focusing on design and modelling several languages and graphical notations have been proposed to represent process models with differences in the level of formality.
bpmn which has been standardised by omg is currently acquiring a clear predominance thanks to i its intuitive and graphical notation that is accepted by industry and academia and ii the support provided by a wide spectrum of modelling tools currently more than see for a detailed list .
here we discuss the bpmn elements supported by bprove see fig.
.
pools represent participants or or218 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
notation pool taskandxorconnecting edgeseventsgatewaysendstartintermediateevent basedterminatesequence flowmessage flowfig.
.
bpmn notation an excerpt .
ganizations involved in the collaboration and provide details on internal process specifications and related elements.
pools are drawn as rectangles.
tasks represent specific jobs to be performed within a process.
tasks are drawn as rectangles with rounded corners.
gateways manage the flow of a process both for parallel activities and choices.
gateways are drawn as diamonds and act as either join nodes merging incoming sequence edges or split nodes forking into outgoing sequence edges .
different types of gateways are available an xor gateway describes choices an and gateway enables parallel execution flows and an event based gateway activates its outgoing branches according to the taking place of catching events.
events are used to represent something that can happen.
an event can be a start event representing the point from which the process starts an intermediate event representing something that happens during process execution or an end event representing the process termination.
events are drawn as circles.
we also refer to a particular type of end event theterminate end event displayed by a thick circle with a darkened circle inside it stops and aborts the running process.
connecting edges connect process elements in the same or different pools.
sequence edge is a solid connector used to specify the internal flow of the process thus ordering elements in the same pool while message edge is a dashed connector used to visualise communication flows between organisations.
notably we consider a subset of bpmn elements regularly used to design process models in practice.
indeed we have selected such subset of bpmn elements by following a pragmatic approach and only retained the features actually used in practice corresponding to less than of its vocabulary .
therefore even if we focus on a restricted number of elements we do not consider such design choice a major limitation of the work.
also we remark that if necessary we might extend our framework to cover further elements.
the only element that could present some challenges is probably theor join gateway.
for such an element the bpmn standard provides a quite articulated description in which the behavior depends on the possibility that an upstream token could reach or not one of the flows entering the gateway itself.
given that we focus on properties for bp analysis in this paper we stress the importance of formal verification to check behavioral correctness.
in the experimental section we consider the most relevant properties from the point of view of implementing a software system based on a bp model.
in particular we refer to soundness and safeness as formally defined in and and for which we provide consistent ltl characterisations in section iii c. informally soundness can be described as the combination of three basic characteristics concerning the dynamic behaviorof a process model i option to complete requiring that a process instance can always complete once started ii proper completion requiring that there exists no running or enabled activity for this instance when the process instance completes iii no dead activities requiring that a process model does not contain any dead activity i.e.
for each activity there exists at least one producible trace which contains the activity.
on the other hand safeness refers to the occurrence of no more than one token at the same time along the same sequence edge of a process instance.
these properties naturally extend to process collaborations requiring that the process instances of all involved organisations satisfy them.
the satisfaction of these properties is generally considered a minimal guarantee to avoid unexpected behavior of a bp model .
iii.
bp roveframework this section presents the proposed verification framework.
first we summarise the distinctive aspects focusing on bpmn modelling principles.
then we exemplify the defined structural operational semantics and its implementation in maude.
finally we discuss the properties we check.
a. distinctive aspects of the proposed framework our approach relies on a direct formalisation of bpmn semantics that as a main distinctive aspect supports models with an arbitrary topology.
we are aware that this is not in line with good modelling practices and recommendations to use structuredness in modelling as a guideline to avoid errors .
however in the real world modelling practice most bps designers do not follow such a guideline as witnessed by a study we carried out on the bpm academic initiative repository.
in fact by following an arbitrary topology designers are free to model the process according to the reality they feel without needing to provide structured models .
in this way the modelling activity results to be less complex and more expressive .
therefore we believe that considering models with an arbitrary topology will facilitate our verification framework in having a real impact on the development of process aware systems because all process designers are supported in their usual modelling activities without imposing them any restriction or forcing them to follow a specific modelling style.
nevertheless given that we consider a wider class of models we can obviously verify those bps that comply to the structuredness recommendation.
another relevant contribution comes from the use of a direct formalisation of bpmn avoiding typical problems given by encodings where the semantics is not given in terms of features and constructs of the language but in terms of lowlevel details of their translations.
more specifically in these approaches petri nets are often used as target language for mapping bpmn .
while for the basic bpmn modelling elements the encoding in petri nets is rather straightforward for others such encodings are quite difficult to define.
for example the management of termination end events permitting to abort a running process is usually not supported.
this is due authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to the inherent complexity of managing non local propagation of tokens in petri nets which instead is natively supported by our semantics.
moreover the main motivation to use petri nets is the availability of already developed tools supporting verification .
however it is worth noticing that such tools work well for the basic petri nets formalism but they are not anymore valid when considering extended versions of petri nets needed to support all the bpmn features such as the management of task state evolution e.g.
enabling running and complete or different types of tasks.
our semantics provides an extensible framework that is able to potentially support all the features of bpmn as structural operational semantics permits to apply language extensions to cover any other bpmn feature without affecting the verification technique.
another advantage of our framework when compared to approaches based on encodings is that it makes the verification of bpmn models more effective.
this is because with the encodings the verification results refer to the lowlevel implementation of the models and may be difficult to interpret them at bpmn level.
on the other hand our direct semantics enables formal reasoning on model properties at a level as close as possible to bpmn diagrams so that diagnostic information can be directly reported on the diagram in a way that is understandable by process stakeholders.
this is especially useful when many parties need to properly and quickly interact on the base of the models.
concerning bp analysis we provide a further novel contribution since we reason at collaboration level.
this enables inter organisational correctness which is still a challenge .
thus results of checking safeness and soundness with respect to bpmn collaborations differ from results obtained through encodings which usually introduce a mapping at process level and then compose the processes in a collaboration by means of an inner transition .
in particular differently from these approaches and in accordance with the bpmn standard we do not impose any a priori upper bound on the number of pending messages which however has to be finite in order to perform the intended model checking analysis.
b. maude implementation of the semantics to practically enable verification of bpmn collaborations we implemented within the maude environment the operational semantics for bpmn presented in .
maude is an instantiation of rewriting logic that has been used to specify the formal semantics of a wide variety of formalisms and languages including c11 java .
and javascript es5 .
since maude specifications are executable we obtained a formal interpreter for bpmn specifications.
this enables formal verification of bpmn collaborations e.g.
by means of the maude state space generator or the maude ltl model checker .
1our maude implementation of the bpmn semantics is available at fig.
.
minimal collaboration example.
a detailed presentation would require to describe the semantics from and rewriting logic which is out of the scope of this paper.
rather we summarise the main ideas used in our implementation by exemplifying the bpmn syntax and semantics that we implemented in maude.
we do this using a simple example consisting of a pool containing a start event a task and an end event.
the example is depicted in fig.
while its maude encoding is provided in listing .
collaboration pool customer proc start enabled e1 .
task disabled e1 .
o1 .
check offer end o1 .
in emptymsgset out emptymsgset .
listing .
the maude encoding of the collaboration in fig.
as we can see from listing a collaboration is specified using the operator collaboration which takes a set of pools as arguments only one in listing .
a pool defined by means of the operator pool takes as argument its name a bpmn process and a set of incoming and outgoing messages to communicate with other pools both empty in listing .
a bpmn process is specified using the operator proc having as arguments the set of bpmn elements separated by that compose it.
the control flow is specified by the presence of tokens in the process elements which are allowed to act only when enabled by tokens.
in the example we see that the start element is enabled meaning that it has a token in input denoted by the dot within the start event in fig.
and hence it is allowed to initiate the process.
the topology of the process is defined by the edges specified as arguments of the process components.
in the example the start node operator start is connected via sequence edge e1to the input of the task operator task whose output is in turn connected to the end node operator end via sequence edge o1.
the number 0associated to the sequence edges specifies that the sequence edges do not have a token associated yet.
in maude the semantics is specified in terms of rewriting rules which are exhaustively applied by pattern matching on each generated state until no new state can be generated.
a rewriting rule has the following form c r l term term i fcondition s .
the keyword crl stands for conditional rewriting rule whose optional name is specified in the square brackets.
the body of the rule term term specifies that if term can be matched on part of a state then a new state will be obtained by i removing the matched part from the state and ii adding term to the remaining part of the state.
in the example one of such terms can be the entire collaboration a pool a process or a bpmn element.
the ifdefines a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
guard that has to be satisfied by the considered state in order to enable the application of the rule.
in case no condition is required then the ifclause is omitted and the keyword rl is used rather than crl.
c r l el1 restofprocess el2 restofprocess i fel1 el2 .
c r l pool name proc proc1 pool name proc proc2 i fproc1 proc2 .
listing .
sketch of rules for part of the semantics of processes and pools.
the bpmn semantics from is multi layer in the sense that it has rules for collaborations layer that depend on rules for pools layer which in turns depend on rules for processes layer triggered by rules for single bpmn elements layer .
roughly the semantics is given in this form if a bpmn element el1 can evolve in an element el2 then a process proc1 containing el1 can evolve in a process proc2 containing el2 and similarly for the higher layers if necessary keeping into account interactions with other processes or pools.
this can be mimicked in maude using the condition if el1 el2 shown in the abstract sketch of rules for processes and pools provided in listing .
for easiness of presentation we just report simplified versions of the rewriting rules that are applied in order to let the collaboration in listing evolve in the new collaboration and hence in the new state in listing where the start element consumed the input token propagating it to the sequence edge e1 and consequently changed status from enabled to disabled.
the resulting state is depicted in fig.
.
fig.
.
minimal collaboration example after one step of execution.
collaboration pool customer proc start disabled e1 .
task disabled e1 .
o1 .
check offer end o1 .
in emptymsgset out emptymsgset .
listing .
a successor state of listing corresponding to fig.
.
first of all we need a rule specifying the semantics of start elements shown in listing .
r l start enabled iename .
ietoken tupd iename .
ietoken start disabled iename .
ietoken .
listing .
sketch of rule for task elements.
in the rule start enabled iename .
ietoken is the element on which the rule acts.
it is a start element with status set to enabled.
the symbols iename and ietoken are variables that can be matched with any edge name and value of token respectively.
the rule establishes that the matched start element will change status to disabled and will increase the counter of its outgoing sequence edge.the term tupd iename .
ietoken is a label containing information on the executed action which will be used by the rules of the higher layers.
intuitively in the example the label is used to propagate the update on the token to all occurrences of the sequence edge appearing in other bpmn elements.
to give a hint on the strict relationship between the maude implementation of the bpmn semantics and its formal presentation given in just for this rewriting rule we report below the corresponding sos rule e start e n e n e n the one to one correspondence between the rewriting rule and the sos one is clear despite the different notation which we do not explain here .
the rule for tasks triggers the execution of the rule for the processes sketched in listing .
roughly such rule propagates the changes from a single bpmn element to the entire process i the label is associated to the entire process rather than to the single bpmn element and ii the token counter in all copies of the interested sequence edge occurring in other bpmn elements is updated using the auxiliary functionmarkingupdate.
we do not present in details the markingupdate as it just scans all bpmn elements within restofprocess.
note that this rule can be applied only in case the execution of the bpmn element creates a label tupd.
other rules at the process level not shown here are provided in order to handle other kinds of labels.
c r l procelem1 restofprocess tupd edges1 procelem1 markingupdate restofprocess tupd edges1 i fprocelem1 tupd edges1 procelem1 .
listing .
sketch of rule for processes that propagates token updates.
listing shows how the dynamics from lower layers propagate at pool level.
essentially as discussed above the rule in listing establishes that if the process procelem1 of the pool can evolve in the new process procelem1 by creating label action1 then the entire pool evolves in a new pool where procelem1 is substituted by procelem1 generating a new label collab orgname1 action1 recording the organisation name to be considered at the level of collaboration.
the condition internal action1 imposes that this rule handles only actions internal to the pool while actions that regard communications with other pools are handled by other rules omitted here.
c r l pool orgname1 proc action1 procelem1 in inputmsgset out outputmsgset collab orgname1 action1 pool orgname1 proc action1 procelem1 in inputmsgset out outputmsgset i fprocelem1 action1 procelem1 internal action1 listing .
sketch of rule for pools.
finally the rule for collaboration level shown in listing propagates the updates at the level of collaboration.
as in the case of the layer of pools exemplified in listing this rule authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
focuses on action internal to the pool.
other rules are defined to handle interactions between pools.
c r l collaboration pool1 coll2 collaboration pool1 coll2 i fpool1 collaction1 pool1 internal collaction1 listing .
sketch of rule for collaborations.
c. verification verifying properties of bpmn collaborations is useful to ensure their correct execution.
using our maude implementation of bpmn we can verify those properties that can be expressed in terms of ltl formulas successively checked using the maude ltl model checker .
the formulas we show here are obtained as composition of the following basic cases where the operator corresponding to the ltl operatorf is used to verify if a formula eventually holds.
that is in any possible execution path we always encounter a state where holds.
where the operator corresponding to the ltl operatorg is used to verify if a formula globally holds.
that is holds in all states encountered in any possible execution path.
where the operator is the standard boolean implication.
in order to verify the properties mentioned above of a model say bpmodel we have to execute the following maude command red modelcheck bpmodel .
listing .
maude command to run ltl model checking.
in our tool we focus on verifying the soundness and safeness properties of bpmn models.
in the rest of the section we exemplify the formulas we used to study those properties.
as we know from section ii the soundness property can be encoded in terms of three simpler ones option to complete proper completion andno dead activities.
notably as these properties refer to a single pool they have to be checked for each pool in the collaboration.
anyway such checks are carried out over the overall collaboration model in order to take into account the message exchange among organisations.
option to complete.
this property relies in turn on two properties apoolcanstart andapoolends.
the former checks if a token is present in a start element of a given pool.
instead the latter checks if a token is present in an end element of a given pool implying that the pool completed the execution.
the property is encoded has shown in listing .
apoolcanstart poolname apoolends poolname listing .
property option to complete.
the above formula verifies that from any state in which the pool can start apoolcanstart poolname we eventually reach a state where the pool completes its execution apoolends poolname .
interestingly this formula adheres to the well known responseproperty pattern see e.g.
documentation patterns response.shtml proper completion.
this property checks that a pool always correctly completes its execution.
in particular we check that whenever a token reaches the end of the pool then no other token remains unused within the pool.
to verify this property we rely on two properties apoolends andnodanglingtoken.
the latter checks that the pool does not contain other tokens.
the property is encoded has shown in listing .
apoolends poolname nodandlingtoken poolname .
listing .
property proper completion.
in words we verify that whenever a pool completes its execution then no other token remains in the pool.
differently from listing now the right hand side of the implication does not have a operator because we check the nodanglingtoken condition on the same state that satisfied apoolends.
no dead activities.
this property relies on the verification of the condition ataskrunning which establishes that a given task can be set at least once in the status running meaning that the task is currently being executed .
if this property holds for all the tasks in the model then the model has no dead activities.
the property is encoded as shown in listing .
ataskrunning taskname .
listing .
property no dead activities.
safeness.
this property can be encoded in terms of one single condition only safestate as shown in listing .
safestate poolname .
listing .
property safeness.
as shown in listing safestate evaluates to true in states that satify the auxiliary function nomultipletoken which verifies that on each sequence edge there is at most one token.
ceq collaboration pool org1name proc action1 procelements1 in inputmsgset out outputmsgset coll1 safeness org1name true i fnomultipletoken procelements1 true .
listing .
safeness implementation iv.
bp rovetool chain to better clarify the contribution of our tool chain we report in the sequence diagram of fig.
a typical usage scenario while the interested reader can find further information on the tool and its usage in .
the considered scenario shows all the interactions between a user and the tool chain main components.
the user after designing a bpmn model with the modelling environment requests a check on the designed model see screenshot in fig.
.
then the modelling environment sends a request to the bprove webservice asking for a parsing of the bpmn model.
the bprove webservice evaluates the model verifying that in the model are not present bpmn elements that cannot be handled by the considered bpmn operational semantics.
based on the evaluation result the sequence of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
bprove sequence diagram.
interaction may differ.
this is represented in the sequence diagram by an alternative block delimited by the horizontal dashed line .
the part labeled ok contains all the interactions that normally occur if the result of the model evaluation is positive which means that the bpmn model contains only elements that are supported by our framework.
in this case the model is parsed and sent back to the modelling environment which asks the user to specify a property he she wants to verify over the model.
after the user specifies a property the modelling environment sends a verification request to the bprove webservice which transforms the property in an ltl formula compatible with the maude ltl model checker and it passes the property together with the models to the bprove framework.
this latter component starts an instance of maude loaded with the ltl maude model checker and the maude modules containing the semantic rules.
then it verifies the property and sends the result back to the bprove webservice which properly formats the result and sends it to the modelling environment that will display it to the user.
when the property verification result is negative it means that the property is not verified over that bpmn model if a counterexample is present this is shown to the user.
this information is visualised directly on the bpmn model see the elements coloured in magenta in the screenshot shown in fig.
thus facilitating the interpretation of the verification result to users especially for those not familiar with the underlying formal verification technique.
instead if the property verification result is positive it means that the property is verified and a message stating this is displayed to the user.
the part labeled ko contains the interactions that occur if the model presents elements that are not supported by our framework.
in this case the bprove webservice informs the modelling environment on the model ineligibility for parsing and in turn the modelling environment informs the user.
v. v alidation this section presents the experimentation we ran using our bprove verification framework.
the set up and the results of the performed experiments are described below.
the experiments can be replicated using a virtualbox virtualmachine containing an installation of our framework available at our validation has been shaped considering the following research questions are soundness and safeness already correctly handled by modellers or instead modellers do release models violating such properties?
can bprove actually and effectively support modellers in the verification of their models specifically in relation to soundness and safeness properties?
a. experimentation set up in order to validate our verification framework against realword processes we consider bpmn collaboration models provided by the bpm academic initiative .
this is a collection including almost thirty thousand models codified using various process modelling languages.
we chose it because it is particularly suited to investigate modelling practices thanks to its heterogeneity .
the raw dataset consists of bpmn models but we restricted to the latest revision of the models with of connectedness2.
a model without this level of connectedness includes disconnected fragments which typically means that the model has not been finalized.
including such models in our validation would have resulted in verification data difficult to interpret.
this gave us a dataset of models with reasonable quality assurances.
from these models we selected models with more than bpmn elements.
this is because our focus is on collaboration and is the minimum number to have a pool exchanging a message with another.
considering our reference dataset we perform a preliminary transformation step from .json the repository format to .bpmn the format we manage and then we check soundness and safeness.
verification has been carried out on the above mentioned virtual machine located into the garr cloud platform the machine runs ubuntu .
.
lts bits and it has vcpu and gb of ram.
b. experimentation results to collect data we ran a massive analysis checking if the models satisfy the properties discussed in section iii c. from the models more than pass the parsing phase meaning that they include elements we consider in our framework.
this confirms that the selection of elements we did allows to deal with most practical cases.
the main analysis outcome is described in table i. the table shows that only of the considered models are sound.
in particular this is mainly due to the fact that option to complete and proper completion are satisfied by two different sets each containing of the models while the percentage of models without dead activities is higher and accounts to .
in addition we found that about of the models is safe.
these results are emblematic in proving the need of formal analysis techniques to verify the correctness of bpmn models.
2connectedness evaluates the size of the largest connected sub graph against the size of the overall model.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
bprove user interface.
table i fraction of models satisfying soundness and safeness .
property models satisfying it soundness option to complete proper completion no dead activities safeness table ii provides more insights on the complexity of the considered models and on the time necessary to parse them.
in particular we classified the models in terms of the number of bpmn elements they contain column class .
column avg elements provides the average number of elements of models in the class while column time provides the average time in milliseconds necessary to parse each model in order to derive the format needed by maude.
as it can be observed the parsing time slightly increases with the dimension of the model.
table ii complexity of the considered models and parsing time .
class avg elements models time ms table iii provides more information on the complexity of the verification in terms of the time needed to check the considered properties.
in particular for each class of models the columns of the table report minimum maximum average and median time as well as standard deviation.
time values are indicated as milliseconds needed to verify each property.
it is worth mentioning that the values observed for classtable iii experimental results in ms .
a option to complete.
class min max avg median std dev.
b proper completion.
class min max avg median std dev.
c no dead activities.
class min max avg median std dev.
d safeness.
class min max avg median std dev.
are not fully significant given the small number of models belonging to such a class.
overall the observed data shows that properties can be verified in reasonable time and we were able to assess the properties on all the models in less than minutes.
we also report the trend related to the time needed to check soundness fig.
a c and safeness fig.
d .
in the diagrams the time required by the tool to verify properties is on the y axis while the class of the models is on the x axis.
the diagrams provide a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a option to complete.
b proper completion.
c no dead activities.
d safeness.
fig.
.
experimental results visual representation of some of the data reported in table iii.
overall we can observe that as it can be expected times increase with the dimension of the models.
there is also a high variability justified by the rather high values assumed by the standard deviations.
this is not a surprise since it is wellknown that verification activities are particularly affected by the presence of notation elements leading to the interleaving of activities such as parallel or pool statements that are not always included in models.
nonetheless the tool was able to provide an answer in reasonable time also for the most complex models in the repository.
the analysis of the maximum values observed for each class somehow tell us that the maximum complexity of models in terms of checking is rather independent from dimensional characteristics.
indeed as we also observed looking at the models associated to the maximum values modellers tend to reach a sort of maximum complexity in the usage of elements leading to interleaving and such complexity can be easily reached defining a model including elements.
finally considering the median values we discover that the used repository includes for a large fraction very simple models.
the value of the median is indeed much smaller up to times than the average.
this tells us that most of the considered models are rather simple and that few models present real issues for checking.
summing up and answering the research questions posed at the beginning of this section the usage of an open and widely used repository confirmed that it is not seldom to find models that violate relevant behavioral properties also after their release.
in addition the experiments show that our approach seems to be applicable in practice to realistic bp models.
vi.
r elated work much effort has been devoted to the formalisation and verification of business processes .
nevertheless none of the cited works takes into account at the same time all the following key requirements i enabling a direct formalisation being close to the bpmn standard thus avoiding abstraction issues given by use of encodings ii taking intoaccount the collaboration aspects as key features of bpmn in large software development iii providing a tool chain suitable to enable soundness and safeness verification on real scenarios.
in this section we refer to the most relevant tool supported approaches available in the literature that inspired our work.
we first consider the other direct formalisations enabling formal verification and then we discuss those approaches supporting verification via encodings from bpmn to other well known formalisms.
a. bpmn direct formalisations with regard to direct formalisations our contribution was mainly inspired by the one presented in .
the authors propose a bpmn formalisation based on in place graph transformation rules these rules are defined to be passed as input to the grgen.net tool and are documented visually using bpmn syntax.
with respect to our work the used formalisation techniques are different since we consider an operational semantics in terms of lts which allows us to apply verification techniques well established for this underlying model such as model checking.
the definition of an operational semantics gives us the possibility to be tool interdependent rather than be constrained to tools specific for graph transformation rules.
this is confirmed by the same authors that for using their bpmn formalisation in the compliance verification between global and local process models need a further transformation .
focusing on verification the grgen.net tool aims to be used to verify workflow engines and service orchestration choreography engines using bpmn .
the benefits of the solution are illustrated by means of a simple scenario that showcases the approach.
other approaches are also proposed considering direct formalisations.
el saber and boronat proposed in a formal characterisation of well formed bpmn processes in terms of rewriting logic using maude as supporting tool.
they discuss soundness of the well formed bpmn models without introducing verification into practice which is postponed as future work.
this formalisation refers to a subset of the bpmn specification considering elements that are used regularly such as flow nodes data elements connecting flow elements artefacts and swimlanes.
differently from our approach it can be only applied to well structured processes.
another direct formalisation is that proposed by borger and thalheim in .
they define an extensible semantical framework for bpmn using abstract state machines.
it is based on the version .
of bpmn which does not include notation meta model and gives more freedom to the authors in the interpretation of the language.
few years later kossak et al.
proposed a semantics based on abstract state machines for bpmn single process diagrams differently from our proposal where collaboration aspects such as pools and message exchange play a key role in they are overlooked.
it is worth noticing that none of the approaches and supporting tools mentioned above has been properly validated so authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
it is not clear which advantages and contributions they provide on real scenarios.
b. bpmn formalisation via encodings the most common formalisations of bpmn are given via encodings to various formalisms such as petri nets or their extensions such as yawl and ecatnets and process calculi .
regarding the encodings from bpmn to petri nets the one proposed by dijkman et al.
in is probably the most relevant contribution.
the petri net resulting from the encoding of a bpmn model can serve as input to a petri net based verification tool for the static analysis of the model.
the main contribution of the proposed tool is the transformation rather than the verification.
indeed the tool has been validated focusing on the transformation of only models.
the authors just state that they detected errors in some of the analysed models without giving details on effectiveness of the approach.
moreover the approach proposed by dijkman et al.
is based on the version .
of bpmn and as the authors stated it suffers from deficiencies that impact on the proposed formalisation.
moreover differently from our approach even if the encoding deals with messages it does not properly consider multiple organisation scenarios.
other relevant encodings are those from bpmn to yawl a language with a strictly defined execution semantics inspired by petri nets and able to support verification .
among the proposed encodings we would like to mention the ones by ye and song and dumas et al.
.
the former is defined under the well formedness assumption which instead we do not rely on.
moreover although messages are taken into account in the mapping pools and lanes are not considered thus it is not possible to identify who is the sender and who is the receiver in the communication.
this results in the lack of capability to introduce verification at message level considering the involved organisations.
the latter encoding instead formalises a very small portion of bpmn elements.
in particular limitations about pools and messages are similar to the previous approach pools are treated as separate business process while messages flow is not covered by the encoding.
focusing on supporting tools the two solutions permit to transform bpmn to yawl nets enabling verification.
ye and son implemented an open source plug in called bpmn2yawl that uses ilog bpmn modeler as a graphical editor to create bpmn models and implements transformation and verification as prom .
plug in .
as a proof of concept the tool has been tested using simple models.
decker et al.
also consider bpmn as source language and yawl as target language .
in this case both the transformer and the modeller are eclipse plugins while the verification is supported by prom .
.
again as a proof of concept the tool has been tested to a limited number of models.
more recently kheldoun et al.
proposed an encoding from bpmn to recursive ecatnets which can be expressed in term of conditional rewriting logic and given ininput to the maude ltl model checker.
even if we use the same model checker the approach in suffers from the encoding problems discussed above and in particular it does not consider messages in the encoding as well as the event based gateway.
moreover the authors illustrate the approach through three simple examples only without extensively validating it.
process calculi have been also considered as means for formalising bpmn.
among the others wong and gibbons presented in a translation from a subset of bpmn process diagrams under the assumption of well formedness to a csp like language based on z notation using haskell.
this enables the introduction of a formal verification to check properties based on the notion of messages like consistency between bpmn diagrams with different levels of abstraction and compatibility between participants within a business process collaboration .
benefits of the solution are illustrated by means of a simple scenario.
even if our proposal differs from the above ones as it relies on a direct semantics rather than on an encoding it has drawn inspiration from those based on process calculi for the use of a compositional approach in the sos style.
vii.
c oncluding remarks and future works thanks to the wide adoption of bpmn business process modelling has acquired increasing relevance in the development of software systems.
this is mainly due to the capability of bpmn to fill the communication gap between domain experts and it specialists.
however the lack of a formal semantics prevents its full adoption making unavailable the automatic verification of relevant properties impacting on the behavior of business processes.
several approaches are available in the literature providing a formalisation to the bpmn standard.
in this paper we rely on a native formal semantics for bpmn models avoiding typical problems due to the encoding in different formalisms such as the low accessibility of the analysis results.
regarding verification of business processes although the research community provided many proposals only few of them are tool supported.
most of such tools are prototypes resulting from research projects developed just for demonstration purposes and hence are rarely used in practice.
validations on real case studies or wide model sets are also not available.
in addition some of the prototypes are not even anymore maintained.
in this paper we presented a framework provided with a mature and easy to use tool support which we validated against more than one thousand models available on a publicly accessible repository.
the results of the validation are reported and discussed in detail.
validation proves practical benefits and effectiveness of the approach.
in the future we plan to extend our framework to other bpmn relevant characteristics such as data management time constraints and resource allocation so to enable also a quantitative analysis for bpmn models.
finally we intend to evolve the prototype now implemented in maude using a classic programming language so to further improve its performance.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.