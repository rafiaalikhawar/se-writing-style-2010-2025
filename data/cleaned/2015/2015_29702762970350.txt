finding access control bugs in web applications with cancheck ivan boci c and tevfik bultan department of computer science university of california santa barbara usa bo bultan cs.ucsb.edu abstract access control bugs in web applications can have dire consequences since many web applications store private and sensitive data.
in this paper we present an automated veri cation technique for access control in ruby on rails rails applications.
our technique starts by automatically extracting a model that captures the ways the data is accessed and modi ed by the application the access control policy of the application and the authorization checks used for access control policy enforcement.
then it automatically translates this model to rst order logic and uses automated theorem provers to check whether the declared access control policy is correctly enforced by the implementation.
we implemented our technique in a tool called cancheck.
using cancheck on open source rails applications we found numerous previously unknown exploitable access control bugs as well as several de ciencies in access control policies.
ccs concepts software and its engineering !access protection model checking software veri cation automated static analysis formal software veri cation software veri cation and validation keywords access control logic based veri cation web applications .
introduction due to the increasing amount of digital information that individuals produce and the convenience of cloud based data stores people increasingly trust their private and sensitive data to web applications.
web applications are becoming the digital banks that store people s data currency.
this makes access control one of the most critical concerns for modern web applications.
this work is supported in part by the nsf grant ccf1423623.web applications execute actions in order to respond to user requests.
actions typically modify or read data from the data store and present it to the user in some format.
access control in web applications ensures that access to the data store both in terms of reads and writes is restricted according to the role of the current user.
the access control policy speci es the permissions for each role.
when executing actions before an operation read or write is executed on a data item the access control policy should be enforced using authorization checks in order to prevent unauthorized access.
errors in the implementation of authorization checks i.e.
errors in the enforcement of the access control policy result in access control bugs.
in order to increase programmer productivity and to prevent common design and implementation errors modern web applications are written using web application frameworks such as ruby on rails rails and django.
rails does not natively support access control.
instead access control is implemented either in an ad hoc manner or by using third party libraries gems .
web applications written in rails most commonly use gems called cancan cancancan and pundit for access control.
in this paper we present an automated veri cation approach for access control policy enforcement in applications that use role based access control.
we rst automatically extract an access control model from the application containing information about the database schema actions and authorization checks implemented inside actions.
we infer a formal access control policy from the informal access control speci cation developers have do specify to implement access control.
we translate the extracted access control model to a set of rst order logic fol formulas.
after this logic translation using o the shelf fol theorem provers we can identify actions that violate the access control policy by not enforcing it correctly or we can con rm to the developer that the access control policy is correctly enforced at all times.
veri cation of access control in rails applications has been studied .
the contributions in this paper are using instrumented execution to extract access control models from rails applications that use cancan.
translating an access control policy and authorization checks for policy enforcement to rst order logic.
evaluating our veri cation technique on open source rails applications.
in section we introduce rails and overview our method.
in section we de ne data store models with regards to access control policies.
in section we explain extraction of access control models from rails applications that use permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
1class user activerecord base devise database authenticable enum role has many articles foreign key author id 5end 6class article activerecord base belongs to author class user 8end class ability def initialize user can article if user.admin?
can manage all else can manage user id user.id can manage article author id user.id can article end end end class articlescontroller actioncontroller base def destroy article article.find params raise unless can?
destroy article article.destroy!
respond to ... end def create article article.new params article.author current user article.save!
respond to ... end end class userscontroller actioncontroller base def index users user.all respond to ... end end figure rails application example.
cancan.
in section we de ne authorization properties and translate them to fol.
in section we experimentally evaluate our approach.
in section we discuss related work and in section we conclude the paper.
.
overview let us examine a segment of a rails application presented in figure .
we split this application into three sections the list of model classes lines the ability class lines and three actions lines and .
model classes de ne the types of objects that are stored by the application.
users typically use a web application to browse and manage these objects.
in this example we have two classes the user class lines and the article class lines .
objects of the user class correspond to users of the application and whenever a user logs in an instance of the user class that corresponds to that user is loaded from the database declaration in line .
users have two possible roles admin and nonadmin line and can have articles associated with them as authors line .
the article class represents articles users can write and they can be authored by users line .
we omit all other details for brevity.in cancan the access control policy is speci ed using ability objects.
the developer has to implement the ability class in order to use cancan.
every time an action is invoked an ability object that corresponds to that user request is created.
typically the way this object is initialized depends on the role of the user making the request.
once this object has been created it can be queried during the action s execution to check if certain operations are permissible for the current user.
in our example the ability class is de ned in lines and the access control policy is speci ed in the constructor lines .
the constructor takes a single argument the user object representing the current user line .
inside the constructor we see branches and canstatements.
these statements whitelist certain operations on certain objects.
for example in line the current user is permitted to execute operations index and show on all article objects.
these operations by convention correspond to action names.
if the user has the admin role line then in line he is permitted to execute all operations special keyword manage on all objects of all types special keyword all .
if the user does not have the admin role line he is permitted to manage his own user object line all articles he authors line and to like and dislike any article object line .
finally we see three actions two in the articles controller and one in the users controller.
the rst action is used to delete an article object lines .
it reads an article object from the data store using the unique identi er supplied with the request parameters line then it aborts the action unless the current user can execute the destroy operation on said article line .
this check will implicitly query the ability object generated for the current user before the action started executing.
afterwards assuming the operation was permitted the article is deleted line .
line synthesizes the response and is omitted for brevity.
the second action is used to create an article object lines .
this action creates an article object from request parameters line then assigns the author of this new article to be the current user line and saves the article line .
note that even though authorization is not checked anywhere in the action this action cannot violate the policy either the current user is an admin and is permitted to create articles line or the current user is the author of this new article line .
finally the third action is used to present all user objects to the user lines .
it does so by loading all user objects from the database and storing them in an instance variable denoted by the pre x line .
because this is an instance variable and not a local variable its value is exposed to the view.
this action may violate the access control policy by giving a non admin user the ability to read all user objects.
this action is problematic even if the web interface does not expose this action to non admins as it is easy to create http requests that invoke actions with any set of parameters.
our approach.
in order to detect access control bugs in rails applications we implemented the approach outlined in figure in a tool called cancheck1.
this is an extension of our previous work to include access control.
1the tool is available at 156logic translationrails cancan model extraction verification using fol theorem proversaccess control modelfol formulasverified inconclusivefalsifiedfigure cancheck tool architecture.
first we automatically extract an access control model from a given rails application.
this model is speci ed in an intermediate speci cation language that is based on earlier work in data model veri cation .
it includes information about the model classes the set of possible roles and the access control policy as well as actions de ned in a high level imperative language.
this model is an abstraction of the analyzed application focusing only on how model objects are read and modi ed and how authorization checks are implemented in the application.
in addition to extracting the model we extract authorization properties from the application.
these properties represent the correct enforcement of the access control policy.
the follow the form for every action for any object possibly manipulated by this action and for every operation done on this object this operation must be authorized by the access control policy .
we translate these authorization properties the model schema and the action including authorization checks to rst order logic fol .
we use o the shelf fol theorem provers to check whether the resulting formulas are valid or satis able depending on the encoding and the prover .
if yes then access control is correctly enforced.
if no the access control policy is incorrectly enforced.
fol theorem provers respond in one of three ways either they validate access control in which case it is guaranteed that the inferred authorization property is correctly enforced by the application or they invalidate access control in which case there exists an execution that violates access control .
alternatively since fol is in general undecidable the theorem prover might not terminate.
if the theorem prover does not produce a result in minutes we halt its execution and mark the result as inconclusive.
however we have not observed any inconclusive results in our experiments on open source rails applications.
in all cases a conclusive result was produced in a matter of seconds.
.
access control model in this section we overview the access control model that cancheck extracts from a web application.
the access control model consists of the classes and associations between them actions which can be used to update the state user roles which are used to distinguish di erent types of users and the access control policy.
figure shows the access control model that corresponds to the rails application in figure .
section .
de nes data stores and section .
denes the correct enforcement of access control in data stores.
.
data store adata storedsis a tuplehc l a r piwherecis a set of classes lis a set of associations ais a set of actions r is a tuple de ning user roles and pis a set of permissions.1authenticable class user article articles 4class article user author inverseof articles 8roles admin nonadmin 9axiom inusergroup admin xor inusergroup nonadmin permit admin nonadmin read allof article permit admin read create delete allof user permit admin read create delete allof article permit nonadmin read create delete current user permit nonadmin read create delete current user.articles action articles destroy article oneof allof article if not inusergroup admin or inusergroup nonadmin and article in current user.articles raise delete article action articles create article create article article.author current user action users index users allof user figure an access control model.
adata store state is a tupleho t uiwhereois the set of objects tis the set of tuples denoting associations among objects and uis the set of role assignments for users.
we de nedsto be the set of all data store states of ds.
classes and objects.
given a data store ds hc l a r pi cis the set of classes and it identi es the types of objects that can be stored in the data store.
each class has a set of superclasses superclass c c and transitively the superclass relation cannot contain cycles.
one classcu2cis called the authenticable class .
the authenticable class is the class whose objects represent users of the application.
typically it is called just user.
the concept of the user class is used in rails whenever authorization and or authentication take place and it makes it straightforward to associate users with data that belongs to them.
given a data store state ho t ui2ds ois the set of objects that are stored in a data store at some point in time.
each object o2ois an instance of a class c2c.
we use the notation octo encapsulate all objects in owhose class iscor any subclass of c. we de ne oto be the set of all sets of objects that appear in ds.
in each data store state ho t ui2ds there exists a special object ou2ocuthat represents the current user object .
the current user is the currently logged in user who is executing an action.
in the example speci cation in figure cis de ned in lines c fuser articlegwith user denoted as the authenticable class cu user.
associations and tuples.
associations de ne how objects of particular classes can be related to one another.
an association l hname c o ct 157cardi2lcontains a unique identi er name an origin class co2c a target class ct2cand a cardinality constraint card such as one to one one to many etc.
.
similarly to how objects are instances of classes tuples are instances of associations.
each tuple t2tis in the form t hl oo otiwherelis an association l hname c o ct cardi2 landoo2ocoandot2oct.
for a tuple t hl oo otiwe refer toooas the origin object and otas the target object.
in the example speci cation in figure lis de ned in lines and .
lcontains just one one to many association between users and articles l fh user.articles user article one to manyig even though lines and both declare associations line shows that article.author is an inverse of user.articles .
as such lines and refer to the same association.
actions.
given a data store ds hc l a r pi adenotes the set of actions.
actions are used to query and or update the data store state.
each action a2ais a set of executions hs s0 i ds ds owheres ho t uiis the prestate of the execution s0 ho0 t0 u0iis the post state of the execution and o0is the set of objects shown to the user as the result of this action s execution.
given an action a2aand an execution hs s0 i2a we can de ne the sets of objects this execution created deleted and read as follows o2created hs s0 i o62s o2s0 o2deleted hs s0 i o2s o62s0 o2read hs s0 i o2 in access control models an action is a sequence of statements.
statements are state transitions speci ed using a combination of boolean and object set expressions.
boolean expressions have the usual semantics and object set expressions represent a set of objects of a common class.
to illustrate how statements correspond to state transitions let us show the semantics of the delete expr statement.
note that this statement operates with an object set expression.
assuming that is the set of objects that the expr argument evaluates to and that hs s0i2ds dsare the pre and post states of the statement this statement transitions from s ho t uitos0 ho0 t0 u0iif and only if all three constraints below hold 8x x2o0 x2o x62 8x x2t0 x hl xo xti2t xo62 xt62 u0 u in other words xis an object in the post state if and only if it is an object in the pre state that is not in xis a tuple in the post state if and only if it is a tuple in the pre state and neither the origin or the target object of xare in and role assignments do not change.
roles and role assignments.
in a data store ds hc l a r pi ris a tuplehr r xi whereris the set of roles andrxis arole constraint .
roles are used to distinguish di erent types of users.
for example a role could be de ned to distinguish administrators from other users or employees etc.
in a data store state ho t ui u ocu ris a set of role assignments.
each role assignment ho ri2ude nes that user object ohas user role rin this data store state.the role constraint rxis a function that maps a data store state to a boolean rx ds!ftrue falseg.
the rule constraint ensures a data store state s role assignments are semantically correct.
this is application dependent and can be an arbitrary condition but in practice it often declares that each user has to have exactly one user role.
for example line of figure de nes the set of roles r to befadmin nonadming.
the constraint in line de nes that roles admin and nonadmin are mutually exclusive rx ho t ui 8o2ocu ho admini2u ho nonadmini62u permits.
given a data store ds hc l a r pi pis the set of permits.
permits are used to whitelist operations on a data store depending on the role of the user executing the operation and the object the operation is executed on.
each permit p2pis a tuplehg ops eiwhereg r is a non empty set of roles to which the permit applies ops fcreate delete read gis a non empty set of operations permitted by this permit and eis an expression e ds!othat maps a data store state to a set of objects e ho t ui such that o. the expression eis used to determine the set of objects to which the permit applies to.
note that for simplicity we treat update operations as an atomic sequence of delete and create operations.
for example line of figure de nes that all admin s and nonadmin s are permitted to read all objects of the article class.
this corresponds to the following permit p hfadmin nonadming freadg ei whereo2e ho t ui o2oarticle similarly line of figure de nes that all nonadmin s can do any operation on all articles for which the current user is the author.
let lbe the user.articles association andouthe current user object.
formally this corresponds to the following permit p hfnonadming fcreate read delete g ei whereo2e ho t ui hl ou oi2t .
access control correctness authorization is fundamentally about ensuring that users can view and modify only data that they have been permitted to view and modify using a set of methods that are permitted to them.
the goal of our tool is to check whether all operations that could be executed by any action and for any user are permissible with respect to the access control policy.
we formalize this below.
given a data store ds hc l a r pi a permit p hg ops ei2paccepts an operation opon an object oin states denoted as p if and only if the current user ouhas at least one role from g the operation opis inops an inside the set that eevaluates to in data store state s. formally p 9r2g hou ri2u op2ops o2e s now that we de ned how to check permissions for a given operation in a given state for a given set of objects we need to extend this check to cover all possible behaviors.
one question we need to answer before we can do that is in which state of an action s execution should we check for permissions?
if we choose the pre state it becomes impossible to check permissions for object creation because the created objects do not yet exist in the pre state as well 158as tuples that might be necessary to check the access control policy correctly.
similarly it is impossible to evaluate permissions for the delete operation in the post state of an execution.
in order to handle all possible scenarios we chose to evaluate creation permissions in the post state once all the objects and tuples have been created deletion permissions in the pre state before any objects or tuples have been deleted and read permissions in the post state as this is the state shown to the user of the application .
we de ne whether an action a2aof a data store ds hc l a r picorrectly enforces the access control policy as follows.
an action correctly enforces the access control policy if and only if for every execution in a there exists a permit that accepts the creation of every object created by this execution there exists a permit that accepts the deletion of every object deleted by this execution and there exists a permit that accepts the read operation on every object read by this execution.
formally an action acorrectly enforces the access control policy if and only if 8hs ho t ui s0 ho0 t0 u0i i2a 8o2created hs s0 i 9p2p p 8o2deleted hs s0 i 9p2p p 8o2read hs s0 i 9p2p p for example let us take a look at the articles destroy action in figure .
this action will read one article and store it in a variable in line .
then lines will attempt to check whether deleting this variable is authorized for the current user.
if the user is neither an admin line nor a normal user and article is a member of the articles of the current user then the action is aborted line .
finally said object is deleted in line .
logically if any object is deleted then the action has not been aborted in line .
therefore the current user is either an admin in which case the permit in line accepts the object and the operation or the current user is a nonadmin but is also the author of the article which is covered by the permit in line .
since there exists no execution in which an article is deleted without proper authorization this action correctly enforces the access control policy.
now let us examine the articles create action in lines of figure .
this action creates an article object line and assigns the current user to be the author of the new article line .
in every execution of this action the created article s author must be the current user.
therefore if the current user is an admin the permit in line accepts this operation.
otherwise if the current user is a nonadmin the permit in line will accept this operation.
hence this action does not violate the access control policy.
finally the action in lines of figure reads all user objects in line and stores them in a variable.
in the case the current user is a normal user and if there is more than one user in the database no permit accepts this read operation.
hence this action violates the access control policy.
.
extraction from cancan in this section we describe the extraction of access control models from rails applications that use cancan or cancancan.
the extraction technique we use is based on instrumented execution which has been developed for model ex traction from dynamically typed languages such as ruby.
in this paper we extend the instrumented execution technique to speci cally address extraction of access control models.
for access control veri cation three components related to access control need to be extracted the authenticable class and the user role set the access control policy and the authorization checks implemented in actions.
.
user role extraction neither rails nor cancan implement authentication by default.
instead they rely on third party libraries to de ne the authenticable class and roles.
cancan is usually paired with devise for this purpose.
extracting the authenticable class and roles is straightforward from an application that uses devise.
if an application does not use devise we rely on the convention that the authenticable class is called user and de ne roles according to branch conditions in the ability object see section .
.
.
access control policy extraction in cancan the access control policy is declared in the ability class for example lines in figure .
every time an action is executed an ability object is implicitly generated with the current user in mind.
a typical ability class constructor is de ned with a sequence of if elsif else branches where branch conditions query the user role of the current user.
canstatements outside these branches apply to all roles.
each canstatement permits the current user to execute a set of operations on a class type with optional quali ers that restrict the set of objects the canstatement applies to.
the process of access control policy extraction is essentially no di erent from the instrumented execution we use to extract actions just altered for the purpose of extracting cancan policies.
for example any interactions that the constructor might have with the database will be extracted and modeled instead of executed concretely making this process insensitive to the state of the database.
in order to extract the policy we instrument the ability constructor as follows.
all branches are instrumented for the runtime to execute both branches associating encountered canstatements with the user groups from the branch condition.
we override the candirective to generate permits in the access control model based on its arguments.
then we initiate instrumented execution by creating an ability object.
as for the current user argument that the constructor requires we use a symbolic value that corresponds to the current user object set expression.
in order to extract the set of roles a canstatement applies to during instrumented execution of the ability constructor each branch is associated with a set of roles.
any can statement executed under a branch is assigned roles that correspond to the branch condition or branch conditions in case branches are nested .
the root block of the constructor applies to the entire set of roles.
for example the canstatement in line of figure is in the root block of the constructor and as such applies to both roles.
in line we have a branch condition that only accepts admin s meaning that the statement in line only applies to admin s. finally in line we have an else statement which means that the statements in lines refers to all roles associated with the root block but that were 159not expected by the branch condition fadmin nonadmingn fadming fnonadming.
the second piece of information that needs to be extracted is the set of operations.
the operation symbols used in canstatements by convention correspond to action names.
moreover rails has a strong convention on action names that correspond to create read update delete crud operations each model class typically has a separate action for each crud operation.
therefore if we recognize that a user is permitted to execute an action that by convention corresponds to a crud operation on objects of a model class then we infer that the user is permitted to execute the corresponding crud operation on objects of the corresponding model class.
table presents our mapping of action names to operations.
for example newand create actions by convention serve to create a new object of a given model class.
if a user is permitted to execute these actions we infer that the user is permitted to create objects of corresponding type in general.
note that we treat object updates as a composite operation of deleting an object and subsequently creating a new one.
this is su cient because we abstract basic types away so objects contain no internal state.
modifying foreign keys corresponds to deleting a tuple and creating another.
table mapping actions to crud operations operation symbols implied crud operations manage create delete read create new create destroy delete index show read update create delete finally extracting the expression of a permit is straightforward.
if a canstatement refers to a class without any additional constraints it applies to all objects of said class in a given data store state.
in case there are additional constraints such as in lines and in figure considering that we use instrumented execution we can simply evaluate the condition to extract the symbolic representation of the set of objects the canstatement refers to.
for example the canstatement in line of figure is executed in the root block and as such applies to all user roles admin andnonadmin .
it lets users of these roles to execute index and show operations implying the read operation in the resulting permit.
it refers to the article class without any additional limitations.
therefore this canstatement translates to the permit in line of figure .
the canstatement in line of figure is executed in a code block that refers to the admin role.
it allows the user to manage do any crud operation to all objects.
it translates to two permits in lines and of figure .
the two statements in lines and of figure directly translate to the two permits in lines and of figure .
finally the canstatement in line of figure does not translate to a cancheck permit as like anddislike are not crud operations.
however as we explain later cancan authorization checks may still refer to this canstatement.
.
authorization check extraction extracting the access control policy is not enough for veri cation of access control in a web application.
runtime enforcement of the policy via authorization checks is an integral part of access control in rails.
our goal is to ensure that actions considering implemented authorization checks correctly enforce the access control policy at all times.
there are two ways to check authorization using cancan explicitly using the can?
method inside action code and implicitly using automatically generated authorization checks.
both explicit and automated authorization checks are extracted during action extraction via instrumented execution as described below.
explicit checks.
the can?
method takes two arguments an operation symbol and the subject of the authorization check.
for example line of figure checks if the current user can execute operation destroy with the subject being article .
the operation is a symbol that matches an operation in the ability object.
the subject of the authorization check might be an object a set of objects or a class denoting all objects of that class .
the can?
method queries the current ability object to check if at least one canstatement covers the operation symbol and the subject.
we extract can?
checks into boolean expressions in our model as follows.
we can extract the subject of the check directly using instrumented execution.
next we inspect the ability class to identify all canstatements that are relevant to the authorization check at hand.
letopsbe the list of operations checked.
for each role r we identify all canstatements that apply to role rand whose operations correspond to opsand whose expression type corresponds to the type of the subject of the can?
check.
assuming that e1 e2 ekare expressions of these canstatements we extract inusergroup r and subject in union e1 ... ek .
we generate this conjunction for each role and disjoin the results to get the complete boolean expression of the can?
check.
for example let us extract the can?
check in line of figure .
the extracted boolean expression should evaluate to true if and only if the current user is permitted to execute operation destroy on the article object.
for each role we identify canstatements that are relevant to the check and union their expressions if there are multiple.
first for the admin role there is only one canstatement that could permit this operation on an article the canstatement in line .
this canstatement permits all operations on all objects so its expression trivially covers all objects.
then for the user role we again union the expressions of allcanstatements that might permit this operation.
again there is only one canstatement that could permit this operation in line .
since there is only one such canstatement the union of all the expressions is equal to the expression of thiscanstatement.
this expression translates to cancheck ascurrent user.articles .
at this point we have de ned the set of objects each role is permitted to operate on.
if every object we are checking authorization on is inside one of the above sets of objects and the user has the appropriate roles then the check passes.
in our example the resulting translation of this check is in lines of figure the user is permitted to execute the destroy operation if he is an admin line or if he is a nonadmin line and if the article in question is a member ofcurrent user.articles line .
automated checks.
cancan can automatically generate access control checks using controller level declarations that prepend authoriza160tion checks to actions.
in our experience most access control checks are created using these declarations.
since these checks are automagical we found bugs related to misuse or misunderstanding of these automated checks.
since we use instrumented execution for model extraction we do not need to treat automated checks di erently from explicit checks.
we extract automated checks by allowing cancan to follow its own logic and heuristics to determine which checks need to be executed then we extract these generated checks as they are executed.
.
limitations the extraction method we presented is not sound in general .
it extracts a cancheck speci cation from a rails application fully automatically and does so precisely in all applications we experimented on.
however considering the excessive exibility ruby allows and the amount of dynamic features libraries tend to employ imprecision in extraction is possible.
in addition our tool relies on heuristics to extract user role information in case devise is not used.
similarly we assume that the ability class constructor will investigate the role of the current user in branch conditions.
considering that the rails community strongly promotes convention over con guration basing heuristics on conventions often yields the correct result and it always did in our experiments.
our tool lets developers manually alter the extracted model in case conventions are not followed.
.
authorization properties we want to use fol theorem provers to verify that regardless of the role of the current user all objects created deleted or read by any possible execution of an action are permitted for creation deletion and reading respectively.
we generate a set of authorization properties to express this expectation.
an authorization property is a tuple ha op cithat denes the expectation that action a2acorrectly enforces the access control policy with respect to the operation op2 fcreate read delete gfor all objects of type c2c.
we generate an authorization property for every action every operation and every class where the action might possibly execute that operation on objects of that class.
for example we will not generate an authorization property for creating articles in an action that never creates an article as this authorization property is vacuously valid.
our goal is to given an authorization property ha create ci generate a formula that veri es whether the access control policy is correctly enforced with regards to this property.
to do this we need to rst express the set of objects created deleted or read by an action in fol.
we also need to translate permits to fol.
with these two we can express the expectation that all objects created deleted or read by an action are accepted by at least one permit in fol.
create delete and read sets of an action.
as a consequence of translating an action to fol using existing techniques we have access to a predicate sc o that determines whether object oof classcexists in the action s pre state s. similarly we have access to a predicate s0 c o that determines whether object oof classcexists in the action s post state s0.
we can use these predicates to de nenew predicates created canddeleted cthat identify objects of classcthat have been created or deleted by an action 8o2oc created c o sc o s0 c o 8o2oc deleted c o sc o s0 c o in order to identify all objects read by an action we look for objects stored in any variable whose name begins with .
in rails these variables are referred to by the view in order to synthesize the response.
when translating an action to fol after static single assignment every variable v corresponds to a predicate v o that determines whether an object is stored in the variable.
formally given an action a classc and a set of variables v1 vi2vthat are of type c and whose name starts with 8o2oc read c o s0 o v1 o vi o translation of permits and permit acceptance.
given a permit p hg ops ei a speci c operation opand state predicate s o we can generate a predicate pop s o that accepts objects oif and only if p .
this predicate should be satis ed by oif and only if three conditions hold op2ops the current user has a role in g andobelongs to the result of expression ein states.
the rst condition is the easiest to translate.
if op62ops this permit does not accept o. we can at this point stop translating pop s o to rst order logic and declare that it will accept no object o. the second condition checks the role of the current user.
in our fol translation each role r2rcorresponds to a predicater o whereo2ocu.
therefore if g fr1 rkg the second condition is r1 cu rk cu .
finally we need to translate the expression eto fol.
all expressions e in actions and permits alike translate to formulas with a single free variable x denoted as f x such thatf x is satis ed by all xthat correspond to objects that the expression evaluates to .
therefore the third condition is directly de ned as e o .
with that in mind we can de ne the permit predicate pop s. ifop62ops 8o2oc pop s o otherwise 8o2oc pop s o r1 ou rk ou e o translation of authorization properties.
finally we have all the tools we need to synthesize fol formulas that correspond to authorization properties.
in order to check whether an action is valid with regards to authorization property ha create ci we use the theorem prover to check whether the following formula is implied from the definition of the action.
let p fp1 pkg 8o2created c o p1create s0 o pk create s0 o in other words an action is valid with regards to authorization property ha create ciif and only if every object of classccreated by ais accepted by at least one permit p p .
we similarly de ne the condition for whether an action is valid with regards to authorization properties ha read ci andha delete cias 8o2read c o p1read s0 o pk read s0 o 8o2deleted c o p1delete s o pk delete s o note that in accordance with our discussion in section .
the condition for deleted c o refers to the pre state while 161the conditions for created c o andread c o both refer to the post state.
.
experiments to evaluate cancheck we conducted experiments on a set of rails applications.
we looked for largest rails applications we could nd that are supported by the current implementation of the extraction module.
our implementation is restricted to applications that use rails .
or up to .
use cancan or cancancan for authorization using hash based conditional authorization use activerecord as the object relational mapping orm .
in order to nd these applications we examined two collections of rails applications the list of most starred open source rails applications on github according to the opensourcerails.com website and a compilation of open source rails applications categorized by domain .
in total we found applications that satisfy all constraints listed above corm a customer relationship manager kandan an online chat service quant a personal health tracker sprintapp project manager and time tracker and trado e commerce platform .
in addition we included applications were used to evaluate previous work .
these are small and tutorial applications.
we included only for technical reasons these applications were written before rails .
and used library versions that are no longer available.
we managed to upgrade these applications to .
in working order.
table summarizes the results of our experiments for all applications.
we obtained these results on a computer with an intel core i5 2400s processor and 32gb ram running 64bit linux.
memory consumption never exceeded 200mb.
the memory and time performance indicates that cancheck is usable on commonly available hardware.
as we described above the rst phase of our approach is instrumented execution for extracting cancheck speci cations from the given applications.
during the extraction phase in several cases we had to manually alter implementation of a method when the developers deviated from the rails coding style.
these modi cations were necessary only in applications that were seemingly designed by developers not versed in rails coding style trado and corm .
in addition we had to exclude one action of corm which is used for logging in.
this action attempted to communicate with a third party server over a network during extraction and was blocking the process.
the column labeled extraction time sec presents the time it took to completely extract the model from the application.
as described in section for each extracted action for each class and for each operation done on objects of this class read create or delete cancheck generates an authorization property and translates it to a fol theorem that is examined by theorem provers.
the authorization properties column in table represents the number of generated authorization properties.
whenever access control is proven to be invalid for a given authorization property cancheck outputs a human readable message that describes the action the unauthorized operation and the type of the object that this unauthorized operation is executed on.
when access control is proven to be valid cancheck outputs a similar human readable message that con rms validity for an action operation and object type.cancheck generates formulas both for z3 an smt solver and spass a fol theorem prover.
we express our fol theorems in smt using problem group uf which includes free quanti cation free sorts and uninterpreted functions.
z3 checks satis ability so when cancheck constructs a formula to be sent to z3 if a satisfying model exists for the formula then there exists an execution of the application that violates the access control policy.
if on the other hand z3 reports that the formula is unsatis able then we can conclude that no execution that violates the access control policy exists.
spass on the other hand checks whether a conjecture implies from a set of axioms.
this conjecture is the authorization property itself.
if spass reports that the conjecture implies from the axioms then we can conclude that no execution that violates the access control policy exists.
however if spass reports that the conjecture does not always imply from the axioms then we can conclude that an execution that violates the access control policy exists.
note that fol is undecidable in general and cancheck generates formulas without restrictions on quanti cation nesting without a bound on the number of arguments for predicates and without a bound on the domains.
so the formulas generated by cancheck are not in a known subset of fol that is decidable.
this implies that z3 and spass may not be able to produce a conclusive result for some of the formulas generated by cancheck.
cancheck uses z3 and spass concurrently waiting for either theorem prover to produce a result after which the other prover is terminated.
in our experiments we observed that z3 is faster and is more likely to report conclusive results for the formulas cancheck generates.
in fact z3 always produced results rst and produced conclusive results for every set of formulas generated by cancheck.
as such table reports performance results for z3 only.
column avg.
time per check shows the average amount of veri cation time per authorization property.
veri cation time was about a second or less for all applications other than corm.
for corm average veri cation time was about seconds per authorization property.
this is likely due to the large number of roles and permits in the corm data model.
in table the correct column lists the number of cases where the access control policy was correctly enforced with respect to an action an operation and a class type.
the bugs column lists the number of instances where a user is allowed to execute operations that are not allowed by the policy.
for example in corm any user is allowed to delete entire chunks of the database that administrators have imported into the database.
non admins are explicitly forbidden from so in ability object however the policy is incorrectly enforced.
similarly in sprintapp anyone can change user data of any other user including their password.
this is explicitly forbidden by the policy and the option to do so is not visible in the user interface but the policy is incorrectly enforced and it is possible to target these restricted pages by manually entering a url in a web browser.
the policy errors column lists the number of theorems that certain possible operations are not covered by the access control policy.
these errors were caused by the policy not mentioning certain operations and in all cases the policy was not checked in the corresponding action.
when we investigated these applications manually we concluded that it is ok for these applications to allow these operations and they implicitly do so by not checking the policy.
we cate162table experiments application summary.
application kloc extraction time sec actions roles permits authorization propertiesavg.
time per check sec correct bugs policy errorsfalse positives corm .
.
.
kandan .
.
.
quant .
.
.
sprintapp .
.
.
trado .
.
.
avare .
.
.
communautaire .
.
.
illyan .
.
.
bootstrap .
.
.
s2l .
.
.
wm app .
.
.
gorize these errors separately as they do not cause a breach of privacy or elevate user privilege however they point out a de ciency in the access control policy itself.
for example kandan s policy does not explicitly refer to attachment and activity classes nor does it ever check permissions related to these two classes.
finally there are three false positives our tool reported in sprintapp.
all three correspond to the same faulty behavior as sprintapp automatically creates an administrator user account if there are no users in the database.
this implies that anyone could potentially create a user account that would belong to someone else and the policy only allows operations on one s own user object.
this is a clear violation of the policy.
however this bug does not elevate ones privilege nor expose private information since there are no users in the database when this behavior occurs.
.
discovered bugs and policy errors there are actions in corm that violate the access control policy in a total of di erent ways.
in accountscontroller and contactscontroller destroy actions can be used to as a side e ect delete tasks and aliases.
the policy explicitly forbids the superuser role from deleting these objects yet superusers are allowed to execute these actions.
furthermore none of the actions in the emails controller ever checks policies accounting for several access control violations.
the same holds for the imports controller mentioned above.
our tool found access control violations in sprintapp all ultimately caused by poor communication between cancan and activeadmin a library sprintapp uses for action generation.
in sprintapp activeadmin pre loads data relevant to the action and cancan subsequently authorizes operations on this data.
however in four actions cancan fails to capture the pre loaded objects and proceeds to authorize the action ignoring pre loaded objects.
activeadmin then proceeds with the pre loaded objects that were not correctly authorized.
using this exploit any user can access the private information of any user and change their information including their password.
what is speci cally interesting about this bug is that it is not caused by a developer error but by a con guration error.
the action and the controller source code both look like they authorize data correctly.
there is a total of policy violations in kandan.
the policy does not refer to attachment and activity classes implicitly disallowing operations on them.
however the policy is never checked with regards to these classes.
semantically all operations should be allowed on them and as such this represents a de cient policy.quant uses a simple access control policy.
there is only one user group and every user can access only their own objects.
this policy is simple enough to correctly be enforced using automated checks that are present in every controller.
as such this application has no access control violations.
trado is an e commerce platform letting users browse items add them to their carts and place orders.
however the policy only mentions a few of these classes most notably not mentioning orders and order related classes at all.
in addition it attempts to enforce this policy in only a few controllers and as such is enforced inconsistently.
for the sake of consistency we categorized these errors as policy errors as the policy is too sparse to be usable however even a more complete policy wouldn t be correctly enforced on the application as is.
the policy and the enforcement of the policy are both amateurish but show that our tool is useful for detecting basic errors in addition to esoteric ones.
the other applications have numerous access control bugs in them but these applications are typically developed by beginners and abandoned mid development.
illyan the only application still in development has no bugs or policy errors.
wm app also has no bugs or policy errors and is a nice example of how automated access control can be used correctly and uniformly.
all other applications had either policy errors or invalid access control enforcement.
.
related work access control in ruby on rails has been examined before .
this work provides an interactive tool that let the developer traverse the tree of all data exposed by an application and interactively generate a desired policy while noticing exceptions to this policy.
our method is fully automated.
their model represents actions as direct transitions from the pre to the post state whereas we represent them in an imperative model language.
they use alloy to power veri cation while we use fol theorem provers.
rubyx is a tool for symbolic execution rails that can be used to nd access control bugs.
it uses manually written scripts each of which has to setup a database with symbolic values execute an action manually capture relevant output of the action and check whether speci c post conditions hold.
we require no manual e ort from the developer both in terms of specifying expectations of correctness and scenarios under which these expectations should be met.
our extraction method does not rely on smt solvers and a custom symbolic runtime.
furthermore they use drails to make speci c usages of rails code explicit whereas we capture metaprogramming natively.
safeweb is a rails middleware tool for access control.
it stands as a layer between the web application and the 163data.
at runtime it tracks data items and propagates associated permissions in a way that is similar to dynamic taint analysis raising errors if a user gains access to restricted information.
we statically ensure that access control is implemented correctly while safeweb incurs a runtime overhead.
in addition in order to use safeweb existing rails applications to be fundamentally overhauled.
our goal was to examine existing applications.
railroadmap is an automated tool for veri cation of access control in rails using cancan and pundit.
the similarities between our approach and theirs end at trying to achieve the same goal.
their program analysis is limited to parsing a few speci c rails les and examining the ast not even taking le dependencies into account.
they expect the ability class to be declared in a limited manner not allowingelsif branches or branch nesting or method calls in the constructor.
they naively assume that not showing url links to actions is su cient to prevent unrestricted execution of actions.
finally they evaluated their method on small applications all but a few had a single developer and were abandoned in weeks.
we could not directly compare our results to theirs because their reported results are not speci c enough to compare they report the number of bugs but no speci c description of bugs.
in addition we are confused by them reporting access control bugs in two applications artdealer and shiroipantsu that as far as we can see had never in their history of development used access control.
access control bugs are sometimes found with techniques not speci cally tailored for nding access control bugs .
these methods typically require more e ort than our automated method and may miss bugs.
the contributions in this paper extend our previous work on data model veri cation .
this work focuses on verifying whether all actions in a rails application preserve a set of user speci ed invariants that refer to data integrity.
we do this by extracting a data model from a ruby on rails application translating the model to fol and using rst order logic theorem provers to ensure that no execution of an action can violate a manually speci ed invariant.
we use a similar approach for extraction of cancheck speci cations and translation to fol.
however access control models are signi cantly di erent than data models used in these earlier approaches.
access control models besides access control related constructs support conditional branches and exceptions.
the formal modeling of access control in rails applications inference of access control properties and the conditions under which access control is deemed correct or incorrect are all original contributions of this paper.
moreover the approach presented in this paper does not require manual speci cation of invariants.
our basic access control model maps each user operation and object to a boolean .
there are more elaborate access control systems .
our model can be considered a simpli ed version of role based access control rbac .
our model of access control re ects the access control mechanisms used in real world rails gems like cancan cancancan and pundit.
there is an extensive body of research that focuses on veri cation of access control policies as well as aiding the creation of access control policies .
this work describes and investigates policies speci ed using standards such as xacml.
in our work rather than focusing on policy correctness in isolation we are focusing on inconsisten cies between policy speci cation and policy enforcement.
in most cases such inconsistencies point to bugs in policy enforcement even though policy speci cation might itself be de cient.
in addition we focus on verifying access control policies in rails applications and xacml is not used in any rails application we came across.
the problem of access control policy enforcement has been tackled before.
for example there exists work that checks whether a user of a particular role could access a restricted webpage .
their work requires manual speci cation of user roles and categorizing pages based on which roles can access them.
we automatically extract this information from existing code.
instead of just ensuring authorized actions are accessible we also ensure that all operations executed by accessing these actions conform to the policy.
as an other example access control can be veri ed on java objects given an appropriate policy .
our problem domain level of automation and approach are all di erent.
alloy is a formal language for specifying object oriented data models and their properties.
alloy analyzer is used to verify properties of alloy speci cations.
alloy analyzer uses sat based bounded veri cation techniques as opposed to the fol based unbounded veri cation technique we use.
dynalloy is an extension of alloy that adds support for actions achieved by translating dynamic speci cations onto alloy.
while they talk about actions in their work those actions do not correspond to actions in web applications.
instead they are more similar to statements in programming languages .
their work has focused on veri cation of data structures not behaviors in data models of web applications.
veri cation of software using theorem provers has been explored before in projects such as boogie dafny and esc java .
these projects focus on languages such as c c and java and typically require user guidance in the form of explicit pre and post conditions explicit data structure constraints and loop invariants.
our method is fully automated and focuses on access control in modern web applications.
.
conclusions and future work we presented a technique for access control veri cation in rails applications.
we extract a formal model from the application that captures the schema actions that update the state user roles the access control policy and the way the access control policy is enforced by the application.
we automatically generate authorization properties from this formal model which if violated point to access control bugs.
we implemented this approach in a tool called cancheck that can automatically check for access control bugs in rails applications written using access control gems cancan and cancancan.
using cancheck we found numerous real bugs in multiple open source web applications as well as de ciencies in access control policies.
our results indicate that automated theorem provers can e ectively reason about access control violations in real applications when the access control model is extracted appropriately and access control properties are encoded in logic.
we would like to investigate rails language extensions that support direct semantic encoding in logic which would eliminate the need for extraction and logic translation and enable direct application of the veri cation technology to web application development.
.