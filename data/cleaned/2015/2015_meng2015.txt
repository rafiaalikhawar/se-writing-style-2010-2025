does automated refactoring obviate systematic editing?
na meng lisa hua miryung kim kathryn s. mckinley the university of texas at austin university of california los angeles microsoft research mengna09 cs.utexas.edu lisahua utexas.edu miryung cs.ucla.edu mckinley microsoft.com abstract when developers add features and fix bugs they often make systematic edits similar edits to multiple locations.
systematic edits may indicate that developers should instead refactor to eliminate redundancy.
this paper explores this ques tion by designing and implementing a fully automated refactoringtool called r ase which performs clone removal.r ase extracts common code guided by a systematic edit createsnew types and methods as needed parameterizes differencesin types methods variables and expressions and insertsreturn objects and exit labels based on control and data flow.
toour knowledge this functionality makes r ase the most advanced refactoring tool for automated clone removal.
we evaluate r ase with real world systematic edits and compare to method based clone removal.
r ase successfully performs clone removal in of method pairs n and of 30method groups n with systematic edits.
we find that scopingrefactoring based on systematic edits rather than theentire method increases the applicability of automatedclone removal.
automated refactoring is not feasible in the other42 cases which indicates that automated refactoring does notobviate the need for systematic editing.
i. i ntroduction developers often apply similar changes to multiple locations.
systematic editing tools automate this task to reduce theprogramming burden of these tedious error prone changes.for instance simultaneous text editing automates edit actionsin one context by replicating them in other pre selectedcontexts .
linked editing and clever keep trackof code clones and propagate changes from one clone to otherclones.
sydit and lase infer context aware abstracttransformations from user selected examples and then use thetransformations to apply custom changes to user specified orautomatically suggested locations.
these systematic editingtools help developers to make coordinated changes in multiplelocations.
however this practice may encourage developers tocreate or maintain duplicated code when perhaps programswould be easier to maintain and understand if developersinstead refactored their code.
if programmers should alwaysrefactor then systematic editing tools may be encouragingpoor practices.
this paper examines this question that is if systematic edits are obviated by using automated cloneremoval refactoring.
we first design and implement a new completely automated refactoring approach r ase which takes as input two or more methods with systematic edits to scope target code andthen performs clone removal.r ase combines extract method pg.
in add parameter pg.
in introduceexit label parameterize type form template method pg.
in and introduce return object refactorings to extract and remove similar code.
it creates an abstract refactoring template that abstracts differences in types methods variables and expressions from the multiple locations.
based on thistemplate as well as control and data flow r ase creates new types and methods inserts and assigns return objects and exitlabels adds parameters to the new extracted method andintroduces customized calls to it.
to our knowledge r ase implements state of the art refactoring with respect to its capability to factor and generalizecode.
existing clone removal refactoring tools only implementsome but not all of the refactoring techniques in r ase .
nor do they combine and study the effectivenessof automated clone removal.
furthermore prior work that doesstudy clone removal did not actually construct an automated refactoring tool to investigate the refactoring of systematicallychanged code .
the lack of automation inprior work introduces the possibility of subjectivity bias.
byautomating refactoring our study substantially improves onprior methodology for determining the feasibility of cloneremoval refactoring.
we evaluate r ase on real world systematically edited method pairs n from prior work and systemati cally edited method groups n drawn from two open source projects.
r ase automatically refactors of method pairs and of method groups when scoping withsystematic edits.
r ase applies sophisticated refactorings with all six techniques and in multiple different combinations of upto four techniques at once.
on average r ase automatically applied lines of edits in our examples ranging from to285 with modest code size increases of up to lines ofcode and reductions of up to lines.
not surprisingly r ase is most effective at reducing code size for multiple methods.manual transformation to attain the same results would requireinserting deleting or modifying up to lines of code.
ourevaluation results add to the evidence that removing commoncode with variations is challenging in practice and needsautomated tool support.
we compare r ase scoped by systematic edits to r ase scoped by entire methods scoping with systematic edits im proves the feasibility of automatic clone removal compared tomethod level scoping.
with method level scoping r ase only refactors method pairs and method groups.
however with systematic edit scoping r ase refactors method ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee icse florence italypairs and method groups.
systematic edits thus are a good clue for refactoring rather than being obviated by method level refactoring.
however r ase cannot automate refactoring in of pairs and of groups mainly because of languagelimitations semantic constraints and lack of common code.we manually checked software version histories after system atic edits and found that in many cases systematically editedmethods are not refactored.
they either co evolve diverge orstay unchanged.
our tool evaluation and software repositoryobservations indicate that both automated systematic editingand refactoring are necessary to support software evolution.
this paper designs and implements an automated clone removal refactoring algorithm and demonstrates refactoringfeasibility.
predicting refactoring desirability is a hard problem because it depends on complex factors such as code read ability the frequency and types of changes future changesin requirements and code size.
since r ase automates the feasibility step and quantifies code size impact it should helpdevelopers determine refactoring desirability andhelp with cost and benefit analysis but we leavethat investigation to future work.
in summary this paper makes the following contributions.
we design and implement r ase an advanced automated clone removal tool.
it takes methods with systematic editsas inputs and fully automates refactoring to extract com mon code with variations in types methods variables and expressions.
evaluation on real world pairs and groups of methodsshows that r ase effectively automates clone removal in many cases.
this tool evaluation together with our manualsoftware repository examination reveals that refactoringis not always applicable or actually applied to every sys tematically edited method.
thus automated refactoringis unlikely to obviate systematic editing.
previous studies find that clone refactoring is not neces sary or feasible but they did not construct an automatedrefactoring tool .
the lack of automa tion introduces potential subjectivity bias.
by automatingrefactoring our study improves on the prior methodologyand shows that refactoring is often feasible.
ii.
m otiv ating example this section overviews our approach with an example basedon org.eclipse.compare.compareeditorinput revisions v20061120 and v20061218.
figure shows a systematic editon two methods.
the unchanged code is in black addedcode is in blue with and deleted code is in red with .
the two methods perform very similar input processing and experience similar edits adding a variable declarationand updating statements.
however the changes involve usingdifferent type method and variable names iactionbars vs. islocator getactionbars vs. getservicelocator findactionbars vs. findsite offset vs. offset2 and actionbars vs.slocator .
given two changed methods our refactoring tool r ase first invokes l ase which creates an abstract edit script.
.
public class compareeditorinput .
private icomparecontainer fcontainer .
private boolean fcontainerprovided .
private splitter fcomposite .
public iactionbars getactionbars int offset .
if offset .
return null .
if fcontainer null .
iactionbars actionbars fcontainer.getactionbars .
if actionbars null offset!
!fcontainerprovided .
return utilities.findactionbars fcomposite offset .
.
return fcontainer.getactionbars .
return actionbars .
.
public islocator getservicelocator int offset2 .
if fcontainer null .
islocator slocator fcontainer.getservicelocator .
if slocator null offset2!
!fcontainerprovided .
return utilities.findsite fcomposite offset2 .
.
return fcontainer.getservicelocator .
return slocator .
.
fig.
.
an example of systematic changes based on org.eclipse.compare.
compareeditorinput from revisions v20061120 and v20061218 .
... ...method declaration ... ... nonmarkingreturn .
... ... nonmarkingreturn3.
insert t v fcontainer.m nonmarkingreturn4.
update if fcontainer null nonmarkingreturn nonmarkingreturn5.
to if v null v !
!fcontainerprovided nonmarkingreturn6.
... ... nonmarkingreturn7.
nonmarkingreturn8.
update return fcontainer.m nonmarkingreturn nonmarkingreturn9.
to return v nonmarkingreturn10.
fig.
.
abstract edit script inferred by l ase .
t v fcontainer.m .
if v null v !
!fcontainerprovided .
return utilities.m fcomposite v .
.
return v fig.
.
abstract refactoring template of common code created by r ase the script describes abstractly the edit applied to both methods.
it represents edit operations with ast node inserts updates moves and deletes.
figure shows the inferredabstract edit script for this example.
given an edit script rase identifies edited statements related to the systematic changes.
it uses the ranges of edits toscope its automated factorization and generalization extractingthe maximum common contiguous clone which encompassesall systematically edited statements.
if similar edits are sur rounded by cloned statements rase expands the refactoringscope to the entire method.
for our example in figure r ase selects lines and to refactor.
note that r ase includes the unchanged lines and in order to extract syntactically valid ifstatements.
next r ase creates an abstract refactoring template for the selected code snippets by matching expressions and identifiersbetween them as shown in figure .
it uses the original codewhen identifiers or expressions are identical and otherwiseabstracts them e.g.
offset vs.offset2 .
it records a map of abstract names to their original concrete identifiers andexpressions to use later.
icse florence italybased on the template r ase creates an executable refactoring plan and applies it to transform code as shown in figure .
rase performs a parameterize type refactoring because the type variation t must be handled to work correctly for the different type variables.
the method variations m and m 1require a form template method refactoring to invoke the correct methods depending on the callers.
the variation in the use of a variable name v 1requires the corresponding variable to be passed as a parameter to the extracted method.
thevariable wildcard v 0does not need such processing because the variable is locally defined and used and thus invisible tothe extracted method s callers.
r ase performs static analysis that determines identifier scopes to differentiate these cases.
iii.
o pportunistic refactoring rase takes systematically edited methods as input.
it works in two phases.
phase i scopes code regions for refactoring analyzes variations between them and outputs an abstract refactoring template.
phase ii constructs and then applies anexecutable refactoring plan by handling type method variable and expression variations in the template and by analyzingcontrol flow data flow and the class hierarchies of originalmethods.
r ase uses a combination of six different refactoring operations to extract common code and parameterize differ ences while preserving semantics.
a. phase i abstract template creation we use l ase to create an abstract edit script that describes the input systematic changes .
l ase represents the difference between before and after versions with ast node inserts deletes updates and moves.
it then extracts the commonchanges among all methods and creates a generalized programtransformation.
we call this transformation an abstract edit script.
it contains a code pattern describing the context wherethe edit is applicable and a list of edit operations describinghow to make the edit.
it also abstracts identifiers used inthe exemplar edits to generally represent those edits eventhough they manipulate different identifiers.
figure showsan exemplar edit script.
to refactor code undergoing systematic edits r ase identifies the maximum code clone enclosing the edit in eachmethod s new version.
r ase requires contiguity in the code clones thus it identifies a single ast node and all its childsubtrees or a set of contiguous subtrees under the same parentnode.
these restrictions guarantee that there is only one entryto the code region and the cloned code can be extracted asa method.
the maximum code clone identification algorithmconsists of three steps merge abstract and expand.
merge r ase creates an initial subtree set by identifying all trees rooted at the edited code.
for instance if a return statement is edited r ase selects the return statement itself.
however given an edited condition in an if statement r ase selects the if statement which includes the conditional andthe subtrees rooted at the then branch and else branch.
it thencreates a contiguous region of ast nodes by merging treesuntil there is a single tree left or a sequence of adjacentnewly created classes and methods through clone removal .
public abstract class templateclass t0 .
public t0 extractmethod int v1 splitter fcomposite .
icomparecontainer fcontainer .
boolean fcontainerprovided .
t0 v0 m0 fcontainer .
if v0 null v1 !
!fcontainerprovided .
return m1 fcomposite v1 .
.
return v0 .
.
public abstract t0 m0 icomparecontainer fcontainer .
public abstract t0 m1 splitter fcomposite int v1 .
.public class concretetemplateclass0 extends15.
templateclass iactionbars .
public iactionbars m0 icomparecontainer fcontainer .
return fcontainer.getactionbars .
.
public iactionbars m1 splitter fcomposite int v1 .
return utilities.findactionbars fcomposite v1 .
.
.public class concreteclass1 extends24.
templateclass islocator .
public islocator m0 icomparecontainer fcontainer .
return fcontainer.getservicelocator .
.
public islocator m1 splitter fcomposite int v1 .
return utilities.findsite fcomposite v1 .
modifications to the original methods .
public class compareeditorinput .
private icomparecontainer fcontainer .
private boolean fcontainerprovided .
private splitter fcomposite .
public iactionbars getactionbars int offset .
if offset .
return null .
return new concretetemplateclass0 .extractmethod .
offset fcomposite fcontainer .
fcontainerprovided .
.
public islocator getservicelocator int offset2 .
return new concretetemplateclass1 .extractmethod .
offset2 fcomposite fcontainer .
fcontainerprovided .
fig.
.
code refactoring based on systematic edits ones under the same parent node in the set.
the merging algorithm picks two subtrees t1and t2with the longest paths from the root such as path root n n2 t1 and path root n n3 t2 .
note that n1 n2 and n3represent parent and ancestor nodes of t1ort2.r ase identifies the lowest common ancestor where the two paths diverge n1in this case.
next it adds all subtrees of n1 such as trees rooted atn2andn3 into the set of extractable code.
for conciseness it also moves the original t1andt2out of the set because they are now covered by the newly added trees.
in this way r ase makes the code regions to extract closer to each other.
bymerging subtrees iteratively r ase finally forms the minimum contiguous code region involved in the edit.
rase relies on systematic edits to scope refactoring.
if a systematic edit only deletes code or it cannot find edited codein any method s new version r ase will not refactor.
abstract rase then tries to create an abstract template to guide further refactoring.
to successfully create such atemplate r ase requires that a the code regions extracted from different methods have the same number of statements icse florence italyand b the statements are either identical or differ only in their use of types methods variables and expressions.
requirement a guarantees that the template reflects the skeleton of allextracted code.
requirement b guarantees that we extractsyntactically similar code.
r ase abstracts any differences in type names method invocations variable names and expressions in the target methodsby using wildcards t m v andu respectively.
it attempts to establish a mapping between each concrete identifier and theabstract version making sure all methods consistently use anddefine these identifiers.
if not r ase does not refactor them.
this analysis checks for syntactic equivalence and consistentdef use relations between the methods.
expand to extract as much common code as possible between similarly changed methods r ase expands the identified code clones by tentatively including the subtrees parent nodes or siblings.
for instance if the identified codeclones from different methods have similar parent nodes aswell as siblings r ase expands the refactoring scope to the tree rooted at the parent node and then updates the abstracttemplate without invalidating any established concrete abstractmappings.
r ase applies steps and iteratively until no more common code is appended.
b. phase ii clone removal refactoring based on the abstract template and identifier mappings described in the previous section r ase leverages control and data flow analysis to determine how to extract common codeand parameterize differences without altering semantics.
itcreates and applies an executable refactoring plan whichconsists of one or more of these six refactoring operations extract method extracts common code into a method.
add parameter handles variations in variables and expressions.
parameterize type handles variations in types.
form template method handles variations in method calls.
introduce return object handles multiple output variables of extracted code.
introduce exit label preserves control flow in the original code.
type v ariations given a type wildcard t i nt h e abstract template r ase applies a parameterize type refactoring.
it declares a generic type for the newly created classand modifies each original location to call the extractedmethod with type parameters.
we define this new term becausefowler s catalog does not include it and current refactoringengines such as eclipse do not support it.
figure shows anexample.
when the target code differs in terms of type identi fiers r ase adds explicit type parameters to the new extracted method.
the applicability of this refactoring is affected bylanguage support for generic types.
in our implementation forjava the refactoring is not applicable when any parameterizedtype creates an instance by calling its constructors e.g.
new t performs an instanceof check e.g.
v instanceof t or gets the type literal e.g.
t.class because java does notpublic void ma ic c nonmarkingreturn ... nonmarkingreturn insert e getedit c nonmarkingreturn ... nonmarkingreturn nonmarkingreturnpublic void mb rc c nonmarkingreturn ... nonmarkingreturn remove e getedit c nonmarkingreturn ... nonmarkingreturn code to extract code to extractclass c t0 t1 nonmarkingreturn public void extractmethod t1 c nonmarkingreturn ... nonmarkingreturn t0 e getedit c nonmarkingreturn ... nonmarkingreturn nonmarkingreturn nonmarkingreturnpublic void ma ic c nonmarkingreturn new c insert ic nonmarkingreturn .extractmethod c nonmarkingreturn nonmarkingreturnpublic void mb rc c nonmarkingreturn new c remove rc nonmarkingreturn .extractmethod c nonmarkingreturn t e getedit c generalize fig.
.
parameterize type refactoring public void add nonmarkingreturn ... nonmarkingreturn input.addcompareinput nonmarkingreturn ... nonmarkingreturn nonmarkingreturnpublic void remove nonmarkingreturn ... nonmarkingreturn input.removecompareinput nonmarkingreturn ... nonmarkingreturn abstract class template nonmarkingreturn public void extractmethod nonmarkingreturn ... nonmarkingreturn ... nonmarkingreturn m input nonmarkingreturn ... nonmarkingreturn nonmarkingreturn public abstract void m nonmarkingreturn input input nonmarkingreturn nonmarkingreturnclass add extends template nonmarkingreturn public void m input input nonmarkingreturn input.addcompareinput nonmarkingreturn nonmarkingreturnclass rem extends template nonmarkingreturn public void m input input nonmarkingreturn input.removecompareinput nonmarkingreturn nonmarkingreturnpublic void add nonmarkingreturn new add .extractmethod ... nonmarkingreturn nonmarkingreturnpublic void remove nonmarkingreturn new rem .extractmethod ... nonmarkingreturn code to extract code to extract input.m generalize fig.
.
form template method refactoring public void foo nonmarkingreturn ... nonmarkingreturn string str1 ... nonmarkingreturn ... nonmarkingreturn string str2 ... nonmarkingreturn system.out.println str1 str2 nonmarkingreturn code to extractclass retobj nonmarkingreturn public string str1 nonmarkingreturn public string str2 nonmarkingreturn public retobj string str1 string str2 nonmarkingreturn this.str1 str1 nonmarkingreturn this.str2 str2 nonmarkingreturn nonmarkingreturn nonmarkingreturnpublic retobj extractmethod ... nonmarkingreturn ... nonmarkingreturn return new retobj str1 str2 nonmarkingreturn nonmarkingreturnpublic void foo nonmarkingreturn retobj retobj extractmethod ... nonmarkingreturn string str1 retobj.str1 nonmarkingreturn string str2 retobj.str2 nonmarkingreturn system.out.println str1 str2 nonmarkingreturn fig.
.
introduce return object refactoring public void bar nonmarkingreturn while !stack.isempty nonmarkingreturn ... nonmarkingreturn elem stack.pop nonmarkingreturn if elem null nonmarkingreturn continue nonmarkingreturn if elem.equals known nonmarkingreturn break nonmarkingreturn push elem.next nonmarkingreturn nonmarkingreturn code to extractenum label continue break fallthru public label extractmethod ... nonmarkingreturn ... nonmarkingreturn elem stack.pop nonmarkingreturn if elem null nonmarkingreturn return label.continue nonmarkingreturn if elem.equals known nonmarkingreturn return label.break nonmarkingreturn return label.fallthru nonmarkingreturn nonmarkingreturn public void bar nonmarkingreturn while !stack.isempty nonmarkingreturn flag flag extractmethod ... nonmarkingreturn if flag.equals label.continue nonmarkingreturn continue nonmarkingreturn else if flag.equals label.break nonmarkingreturn break nonmarkingreturn push elem.next nonmarkingreturn nonmarkingreturn fig.
.
introduce exit label refactoring support these cases.
even if developers may handle such cases manually with smart tricks the resulting refactored code wouldhave poor readability.
method call v ariations given a method wildcard m in the abstract template r ase applies the form template method pg.
in refactoring.
it creates uniform apis that encapsulate the variations and changes the extractedmethod to invoke these apis instead.
figure shows an icse florence italyexample.
r ase declares an abstract class which contains the extracted method and a sequence of abstract methods.
each abstract method corresponds to a method wildcard.
foreach original location the refactoring declares a concreteclass extending the abstract class so that all abstract methodsare implemented to call the correct corresponding concretemethods.
each original location is modified to invoke theextracted method with the corresponding concrete class.
when a method wildcard represents a non static method and is invoked via an object e.g.
input.m the corresponding method is declared to place the receiver ob ject e.g.
input as an argument e.g.
m1 input input .
then the actual method e.g.
input.addcompareinput or input.removecompareinput is invoked correctly inside each newly defined method.
if any of the variant methodsdoes not have a modifier public in its method declaration the refactoring is not applied because the method is not accessibleby newly defined methods in the template class.
if variantmethods have different numbers of parameters e.g.
foo int offset vs.bar object obj boolean flag the refactoring is not applied.
although it is possible to create a long methodsignature by merging different input signatures we believe theresulting code is too hard to read.
v ariable and expression v ariations given variations in variable names and expressions r ase uses an add parameter pg.
in refactoring.
we use data dependence analysisto identify variables which have local uses but no local defi nitions in the extracted code.
we consider variable wildcards v as candidates for input arguments of the extracted method.
for each variable wildcard we check whether it is purely localto the extracted code meaning that it is declared defined and used only in the extracted code.
if so r ase assigns it a concrete identifier and does not include the variable as an inputparameter since it is invisible to caller methods.
for example r ase declares the variable v 1in figure as a parameter but does not include v 0because it is purely local.
we consider expression wildcards u as candidates for input arguments of the extracted method.
since the wild cards map to different ast node type expressions indifferent methods each caller can pass appropriate ex pressions as arguments.
for instance if u is mapped togetconfiguration in one method but is mapped tofcompareeditorinput.getconfiguration in another method r ase compares the types of both expressions.
if the types are the same it declares an input parameter with thecommon type.
if the types are different r ase records the type mapping and later applies parameterize type refactoring to accommodate the variation.
compared with prior work which solves expression variations by declaring new methods our approach creates cleaner code by avoiding extra methoddeclarations and invocations.
return v alue r ase uses data dependence analysis to determine the variables that have local definitions and externaluses.
it converts these variables to output variables of theextracted method.
when there is more than one such variable r ase applies introduce return object refactoring.
as shownin figure r ase encapsulates all return values into one object and inserts code at each call site to read appropriatefields of the returned object.
fowler s catalog does not includethis refactoring and current refactoring engines do not supportit.
control flow r ase uses control flow analysis to determine the statements that exit the code in addition to the fall through exit in the extracted code such as a return break o r continue .
these non local jump nodes either terminate execution or jump execution from one location to another.
naivelyputting them in the extracted method may cause compilererrors or incorrect control flow.
r ase applies introduce exit label refactoring to correctly implement non local jumps.
it replaces non local jumps with exit label return statements andmodifies each original location to interpret the return labels.fowler s catalog does not include this refactoring nor is itimplemented in current refactoring engines such as eclipse.we borrow the approach from komondoor and horwitz sprior work on automated procedure extraction .
figure 8shows an example with multiple exits.
r ase replaces a nonlocal jump statement with a return statement to terminatethe execution of the current method and adds a return labelindicating the exit type.
r ase inserts code at each call site to handle non local jumps correctly.
placing extracted code rase uses class hierarchy analysis to discover the relationship between classes declaringthe originally edited methods.
the relationships help r ase decide where to put the extracted method and which inputparameters or output variables to add.
for instance if thesystematically changed methods are in the same class andthere are no method or type wildcards in the abstract template r ase places the extracted method in the same class.
if the methods are in sibling classes extending the same super class rase puts the extracted method into their common super class.
if the methods are in classes which do not have any typehierarchy relation r ase must put the extracted method into a newly declared class.
all fields that the extracted code readsfrom or writes to should be passed as input parameters andoutput variables separately since they may not be accessibleto the extracted method defined by the newly defined class.for correctness r ase checks that all methods invoked by the extracted method are declared as public and none of the method calls are unmovable such as super .
iv .
e v aluation this section evaluates r ase with systematic editing tasks.
it explores if automated refactoring eliminates the need forsystematic editing and if systematic editing guides the scopeof refactoring better or worse than method clones.
it also takesa first look at whether automated refactoring is desirable whenit is feasible.
our data set consists of similarly changed method pairs and similarly changed method groups.
these real worldsystematic editing tasks are drawn from version historiesof jedit eclipse compare jdt.core core.runtime debug jfreechart andelasticsearch .
the method pairs are drawn icse florence italyfrom prior evaluation of systematic editing .
each pair of methods have at least syntactic similarity and shareat least one common ast edit operation.
most are multi lineedits and require identifier abstraction.
each method groupcontains at least three similarly changed methods.
the data isavailable at mengna09 projects.html.
we use four variants of refactoring for our evaluation.
the default r ase refactors as much code as possible given a systematic edit.
r ase minchooses the smallest amount of code that includes the systematic edit.
r ase marefactors the entire method after the edit and r ase mbrefactors the entire method before the edit.
we apply r ase and its variants to the test suites.
table i and table ii present the results.
in the tables each task has a unique identifier id.
if a task is automatically refactored we characterize the refactoring withedit operations edits refactoring types and resulting code size change code .
r ase applies the following six refactoring types e extract method r introduce return object l introduce exit label t parameterize type f form templatemethod and a add parameter.
n a means refactoring isnot automated.
we omit pairs with no refactoring in anyconfiguration.
in code size column a positive number means that refactoring increases the code size and a negativenumber means that code size decreases.
a. method pairs default r ase columns automatically refactors out of cases.
r ase ma columns in the middle is restricted to the method scope after edits and automates refactoring for nineteen cases a strict subset of those refactored by r ase.
rase mb columns on the right automates refactoring of methods before editing for eighteen cases all of which arerefactored by both r aseand r ase ma.
these method pairs are clones which experience similar changes and produceclones.
case is not handled by r ase mb because the original version has no statements in the method and thus no clonescan be extracted.
this comparison shows that systematic editsbetter scope refactoring and increase refactoring opportunitiescompared to applying clone removal to the entire methodseither before or after edits.
r ase min extracts the minimum common code enclosing systematic edits as opposed to the maximum common codein default r ase.
if we mark the minimum common code for extraction we may have fewer variations between counter parts which may cause less extra code added as necessary forspecialization.
on the other hand we may extract less codethan the actual commonality shared between changed methods leaving redundant code after refactoring.
the comparisonbetween r ase min and r ase shows that r ase min performs differently from r ase in eight cases.
in seven of the eight cases r ase minis less effective at reducing code size because less common code is extracted.
however in case r ase min reduces code size more because the extracted method doesnot include control flow jumps which eliminates the need forcode to interpret various flow jumps.table iii reasons rase does not refactor 26cases m ethod pairs reason number of cases limited language support for generic types unmovable methods no edited statement found no common code extracted table iv reasons rase does not refactor 10cases m ethod groups reason number of cases limited language support for generic types unmovable methods no edited statement found no common code extracted in out of the cases r ase only uses the extract method to perform its refactoring tasks.
all the other cases need acombination of different types of refactoring.
the code sizechange varies between an increase of lines and a decreaseof lines.
r ase s automated refactoring reduces the code size in eight cases for the method pairs.
b. method groups to explore whether our conclusions based on method pairs generalize to multiple similarly changed methods we apply rase to systematically edited method groups.
each group contains at least three methods and at most nine methods.we apply r ase ma rase mb and r ase min to the same data set and compare refactoring capabilities.
the results aremostly similar comparing table i and table ii.
the columnlabeled in table ii shows the number of changed methods in each group.
r ase refactors out of cases.
similar to table i we observe that r ase automates refactoring more than r ase ma and r ase mb.rase produces more concise code than r ase minin out of cases.
one difference from the method pair results is that r ase decreases code size more consistently and frequently reducing code size in of the20 refactored cases and on average reducing code byeight lines.
this result is expected because the refactored codeappears in just two methods with method pairs whereas formethod groups the refactored code originally appears in threeor more methods.
c. reasons for not refactoring we examined by hand the method pairs that r ase did not refactor and found four reasons which table iii summarizes.
for seven cases r ase failed to refactor due to java s limited support for generic types.
it is very difficult to convert somegeneralized statements like v instanceof t t .m and v new t into code that compiles.
for five cases r ase did not refactor because some statements cannot be moved correctly into an extracted method.for instance the super constructor super ... is only valid in constructors and cannot be moved to any other method.
icse florence italytable i method pairs clone remov al refactorings rase rase min rase ma rase mb id edits types code edits types code edits types code edits types code e a e a e a n a 6e a 6e a 6e a 6e e f e f e f e f e r e n a n a e e l e e e f e f e f e f e f e f e f e f e f e f e f e f e 7e n a n a e e r e e e f e f e f e f e l r e l r n a n a 9e a 6e n a n a e a e a n a n a 9e 9e n a n a e a e a n a n a e e n a n a e l e l n a n a 6e 6e n a n a 6e a 6e a 6e a 6e e l r e l r n a n a e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f t e f e f e f e f e f e f e f e f e f e f e f e f e f e f e f e f average .
.
.
.
.
.
.
.
total automated table ii method groups clone remov al refactorings rase rase min rase ma rase mb id edits types code edits types code edits types code edits types code e a f t e a f t e a f t e a f t e e e e e e a n a n a e t e n a n a e t e t n a n a e a f e a f e a f e a f e l r e l r n a n a e f e f e f e a f e e n a n a 9e 9e n a n a e a e n a n a e 9e n a n a e e e e e f e f r e f e a f t e r e r e r 8e e r e r n a n a e a e a n a n a e t e t e t e a t e e n a n a e a e a e a e a t average .
.
.
.
.
.
.
.
total automated cases ids from meng et al.
r ase by default includes as much code as possible.
r ase min chooses the smallest scope that includes the systematic edit.
rase ma refactors the entire method after the edit and r ase mb refactors the entire method before the edit.
the edits column is ast statement edit operations for refactoring.
refactoring types are e extract method r introduce return object l introduce exit label t parameterize type f form template method and a add parameter.
r ase uses all the refactoring types in many combinations.
both tables show r ase automates refactoring in many cases out of pairs and out of method groups but not all.
systematic edits scope clone removal opportunities better r ase and r ase min than methods r ase ma and r ase mb .
icse florence italyanother example is when attempting to put an extracted method into a newly declared class calls to private methods by the extracted method are not semantically valid because private methods are only accessible for methods defined in the same class.
for eight cases no edited statement is identified in the new version of each changed method.
r ase depends on l ase to create an abstract edit script representing the input systematicchanges.
if l ase fails to create such an edit script or the edit script only deletes statements from old versions r ase cannot locate code to extract nor can it automate refactorings.
in six cases the marked code snippets in different methods are not generalizable to create an abstracttemplate.
four possible reasons explain this result.
first the code snippets contain different numbers of statements.although some existing clone removal refactoring techniquesleverage program dependence analysis and heuristics toshift irrelevant variant code and put together extractablecode these techniques cannot handle all the cases inthis category either indicating the difficulty of fullyautomated refactoring .
second the ast nodetypes of some extracted statements do not match suchas expressionstatement vs.returnstatement .
third the number of parameters in method calls do not match such as foo v vs.bar a b c .
although we may create a single method by merging input signatures of different methods theresulting code may have poor readability.
fourth there is atleast one identifier mapping conflict.
for instance identifier vis mapped to an identifier ain one statement but mapped to another identifier xin another statement.
ignoring these conflicts to apply refactoring would incorrectly modify theprogram semantics.
similar to table iii table iv showsthat limited language support for generic types no editedstatement and no common code extracted are the three mainreasons.
in summary clone removal refactoring does not eliminate the need for systematic editing.
scoping refactoring based on systematic edits improvesrefactoring applicability over refactoring the entire meth ods either before or after the edits.
extracting the maximum common code instead of theminimum common code usually creates a refactoredversion with a smaller code size.
d. software evolution after systematic edits to understand how r ase s refactoring recommendations correlate with developer refactorings we manually examine how developers evolved methods after these systematic edits bygoing through the version histories.
for our test suite theaverage time interval in the version history starting at thesystematic editing version and ending at the latest version is1.
years.
table v shows the results for method pairs and ta ble vi for method groups.
the feasible column corresponds to cases when r ase can automate clone removal refactoring and infeasible corresponds to the rest.
the refactored rowtable v manual ev aluation of version history after systematic edits method pairs feasible infeasible refactored unrefactoredco evolved divergent unchanged table vi manual ev aluation of version history after systematic edits method groups feasible infeasible refactored unrefactoredco evolved divergent unchanged shows cases when developers either by hand or with the help ofsome other tool refactored code later in the version history.
theother rows break down cases without developer refactoring.co evolved means the methods are systematically edited at least one more time in later versions and may indicatethat refactoring is desirable.
divergent means the methods evolved in divergent ways and may indicate that refactoring isundesirable.
for example one method was deleted or only onemethod changed.
refactoring unchanged methods may not be worthwhile because they are quite stable or it is prematureto judge desirability due to lack of information.
table v shows that developers only refactored out of cases.
r ase automates refactoring for the same cases.
additionally r ase refactors cases which were not refactored by developers.
in this test suite cases have versionhistories and do not because they were specially craftedto test systematic editing .
among these cases notrefactored by developers had no code changes includingthe without version histories.
when code does not need tochange to fix bugs or add features developers are unlikelyto aggressively remove clones.
in of cases developersevolved code differently by either changing both methodsdifferently or deleting only one of the two methods.
in of 26cases developers did not refactor code for some reason butsimilarly changed code once again.
such repetitive systematicedits on method pairs may indicate refactoring is desirable.
there are six cases in which methods were co evolved by developers but are not automatically refactored by r ase.
the major reason is the code invokes certain methods which arenot accessible by an extracted method contain non contiguouscloned code or have conflicting identifier mappings.
it is noteasy to automatically refactor these cases.
if developers wantto refactor them they need to first apply some tricks to makethe common code extractable.
table vi summarizes the version history for systematically edited method groups and shows similar results to the methodpairs in table v. developers refactored one case which r ase also handles.
methods co evolved in two cases and divergedin four cases all of which r ase can refactor.
there is one icse florence italycase where methods were co evolved by only deleting code but r ase does not refactor in this case.
manually observing the version history reveals that there is no obvious correlation between the feasibility of r aseenabled refactoring and manual refactorings performed by developerson systematically edited code although there are cases whenautomatic and manual refactoring overlaps.
whether develop ers refactor or not they do not base their decision solely oncode similarity and similar edits.
they consider other factors such as readability code size future plans for features and bugfixes.
although r ase cannot decide for developers whether to refactor or not by creating an executable refactoring plan when developers decide to refactor it helps reduce developerburden when applying code transformations.
to explore the reasons developers do not refactor while performing systematic edits we randomly pick several examplesand ask project owners for their expert opinion.
one developer is conservative about aggressive refactoring and merging commonality between methods i will not refactor because this pair of methods is not a pain pointduring maintenance evolution of jdt.
that particular classis very stable and the readability of the code as it is nowoutweighs potential benefits of refactoring.
we have otherduplications that are more likely to cause pain e.g.
by beingforgotten during maintenance.
...i n these classes potential gain might be greater but then a refactoring to avoid re dundancy would certainly introduce a significant amount ofadditional complexity.
we don t typically refactor unless wehave to change the code for some bug fix or new feature.
another developer refactors more proactively to reduce cloned code but prefers reducing four duplicated methodsto two instead of the single method that r ase suggests to simplify the class hierarchy.
the feedback from developers illustrates that the decision to remove clones depends on many criteria including codesimilarity co evolution events the effectiveness of cloned codein bug fixing and feature additions the software architecture readability and maintainability of the resulting refactoredcode.
based on our experience with software version history and communication with developers we envision r ase as a refactoring recommendation tool when developers thinkabout refactoring duplicated code.
r ase will help further research on recommendations and cost benefit analysis ofclone removal.
r aseshould also serve to complement existing systematic editing tools because developers do not always ag gressively reduce duplicated code but often maintain redundantcode for various reasons.
v. t hreats to validity our results are based on systematic editing examples.further evaluation with more subject systems longer versionhistories and larger scope of systematic edits beyond themethod level remains as future work.
the refactoring capability of r ase is affected by the systematic editing tool l ase it uses.
given multiple similarlychanged methods if l ase fails to generalize an abstract edit script for them r ase cannot provide any refactoring suggestion.
the six types of refactorings implemented in r ase do not cover all possible code transformations applicable toclone removal.
however it is the state of the art in terms ofthe number of clone removal refactorings it automates.
when handling variations in expressions we promote expressions as input parameters of an extracted method.
if thepromoted expressions cause side effect such as i w em a y alter semantics in some cases although the alteration is notobserved in our test suites.
r ase determines concrete refactoring transformations based on an abstract template without considering the globalcontext such as the extent of code duplication across the entirecodebase or the class relationship among methods.
there fore r ase may not suggest the best possible transformation.
however r ase is the first automated tool that mechanically examines if systematic edits in multiple locations indicaterefactoring opportunities.
our results focus on automated refactoring feasibility instead of desirability.
we leave developers to decide whether to refactor or not.
we believe that it is difficult to choosebetween systematically editing methods and reducing clonesto edit a single copy.
to assess refactoring desirability therefactoring cost benefit analysis should account for factorssuch as how frequently future systematic edits may occur to fixbugs and add features whether complexity increases whetherit is worthwhile to reduce future edits and whether the relatedmethods are likely to change and or diverge in the future.
vi.
r elated work systematic editing.
systematic editing tools automatically apply similar changes to multiple locations.
simultaneous textediting tools replicate the exact same users actions in one coderegion to other user selected code regions .
clone tracker takes the output of a clone detector as input mapscorresponding lines in the clones and then echoes edits in oneclone to another upon a user s request .
the clever versioncontrol system monitors code clones detects changes to them and then recommends edit propagation among clones .
s ydit infers an abstract ast edit script from an exemplar changed method and applies it to user selected methods .
lase generalizes a partially abstract context aware edit script from multiple examples uses the edit script to find additionaledit locations customizes the edit script to each new location and then applies the result .
all these systematic editingtools automate repetitive changes to multiple locations whichmay encourage the bad practice of creating and maintainingcode duplications.
clone removal refactoring.
based on code clones detected by various techniques many tools identify or rank refactoring opportunities .
for instance balazinska et al.
define a clone classification scheme basedon various types of differences between clones and automatethe classification to help developers assess refactoring oppor tunities for each clone group.
higo et al.
and goto et al.
rank icse florence italyclones as refactoring candidates based on coupling or cohesion metrics .
others integrate evolution information insoftware history to rank clones that have been repetitivelyor simultaneously changed in the past .
while thesetools detect refactoring opportunities for clones they do notautomatically refactor code.
a number of techniques automate clone removal refactorings by factorizing the common parts and by parameterizingtheir differences using a strategy design pattern or a form template method refactoring .
similar to r ase these tools insert customized calls in each original location touse newly created methods.
juillerat et al.
automate introduce exit label and introduce return object refactorings supported by r ase .
however for variable and expression variations juillerat et al.
s approach and clort define extra methodsto mask the differences while r ase passes these variations as arguments of the extracted method.
clort was applied tojdk .
to automatically reengineer class level clones.
similarto our results they find this reengineering effort led to anincrease in the total size of code because it created numeroussimple methods.
hotta et al.
use program dependence analysisto handle gapped clones trivial differences inside code clonesthat are safe to factor out and such that they can apply theform template method refactoring to the code .
krishnan et al.
use pdgs of two programs to identify a maximum commonsubgraph so that the differences between the two programsare minimized and fewer parameters are introduced .unlike r ase none of these tools handle type variations when extracting common code.automatic procedure extraction.
komondoor et al.
extract methods based on the user selected or tool selected statementsin one method .
the extract method refactoring in the eclipse ide requires contiguous statements whereas thesetools handle non contiguous statements.
program dependenceanalysis identifies the relation between selected and unselectedstatements and determines whether the non contiguous codecan be moved together to form extractable contiguous code.similar to r ase komondoor et al.
apply introduce exit label refactoring to handle exiting jumps in selected statements .tsantalis et al.
extend the techniques by requiring developersto specify a variable of interest at a specific point only .they use a block based slicing technique to suggest a programslice to isolate the computation of the given variable.
theseapproaches are only focused on extracting code from a singlemethod.
therefore they do not handle extracting commoncode from multiple methods and resolving the differencesbetween them as r ase does.
empirical studies of code clones.
many empirical studies on code clones find that removing clones is not necessarynor beneficial .
bettenburg et al.
report thatonly to of inconsistent changes to clones introducesoftware errors indicating that developers are currently able toeffectively manage and control clone evolution .
kim et al.observe that many long lived consistently changed clones arenot easy to refactor without modifying public interfaces .these empirical studies show that removing code clones isnot always necessary nor beneficial.
while these studies uselonger version histories or larger programs than our evaluation none of these studies automatically refactor code to removeclones as we do in this paper.
our work thus improvesover their methodology by eliminating human judgment whendetermining the feasibility of edits.
vii.
c onclusions similar edits in similar code may indicate an opportunity toremove redundancy.
to investigate this question we designand implement r ase an automated refactoring tool that consists of six clone removal refactoring techniques extract method parameterize type form template method and add parameter to tackle variations in types methods variables and expressions respectively and introduce exit label and introduce return object to handle non local jumps and multiple output variables.
by applying r ase to real world systematic editing tasks we observe that r ase improves refactoring feasibility by refactoring the region surrounding systematic edits as opposedto refactoring the entire method.
this finding corroboratesthe community s understanding that the evolutionary charac teristics of clones may be a better indicator for refactoringneeds than the clones themselves.
despite this improvement automated refactoring is feasible only in of the cases inour test suite.
we show it is very difficult to automate cloneremoval for the remaining .
hand examination indicatesthat language semantics and lack of common code are mainreasons when refactoring is infeasible while refactoring is notalways applied by developers even if refactoring is feasible.we conclude that developers need tool support for bothsystematic editing and automated refactoring.
while r ase automates clone removal based on systematic edits the decision of whether to refactor or not depends onmultiple complex factors such as readability maintainability and types of anticipated changes.
systematic edits serve onlyas one factor.
therefore they are not sufficient to indicateclone removal is desirable.
however we believe that r ase s automated refactoring capability will support further researchon refactoring cost benefit analysis and recommendations.
a cknowledgments this work was supported in part by the national science foundation under grants ccf ccf shf ccf ccf cns and agoogle faculty award.
r eferences l. aversano l. cerulo and m. d. penta.
how clones are maintained an empirical study.
in csmr pages .
m. balazinska e. merlo m. dagenais b. lague and k. kontogiannis.
measuring clone based reengineering opportunities.
in metrics page .
m. balazinska e. merlo m. dagenais b. lague and k. kontogiannis.
partial redesign of java software systems based on clone analysis.
in wcre page .
icse florence italy g. bavota a. de lucia a. marcus r. oliveto and f. palomba.
supporting extract class refactoring in eclipse the aries project.
in proceedings of the 34th international conference on software engineering .
n. bettenburg w. shang w. ibrahim b. adams y .
zou and a. e. hassan.
an empirical study on inconsistent changes to code clones atrelease level.
in wcre pages .
e. duala ekoko and m. p. robillard.
tracking code clones in evolving software.
in icse pages .
m. fowler.
refactoring improving the design of existing code.
addison wesley professional .
n. g ode.
clone removal fact or fiction?
in iwsc pages .
a. goto n. yoshida m. ioka e. choi and k. inoue.
how to extract differences from similar programs?
a cohesion metric approach.
iniwsc pages .
ieee .
y .
higo and s. kusumoto.
identifying clone removal opportunities based on co evolution analysis.
in iwpse pages .
y .
higo s. kusumoto and k. inoue.
a metric based approach to identifying refactoring opportunities for merging code clones in a javasoftware system.
j. softw.
maint.
evol.
.
k. hotta y .
higo and s. kusumoto.
identifying tailoring and suggesting form template method refactoring opportunities with programdependence graph.
15th european conference on software maintenance and reengineering .
l. jiang g. misherghi z. su and s. glondu.
deckard scalable and accurate tree based detection of code clones.
in icse pages .
n. juillerat and b. hirsbrunner.
toward an implementation of the form template method refactoring.
scam .
t. kamiya s. kusumoto and k. inoue.
ccfinder a multilinguistic token based code clone detection system for large scale source code.tse pages .
c. kapser and m. w. godfrey.
cloning considered harmful considered harmful.
in wcre proceedings of the 13th working conference on reverse engineering pages washington dc usa .
ieeecomputer society.
m. kim v .
sazawal d. notkin and g. murphy.
an empirical study of code clone genealogies.
in esec fse pages .
r. komondoor and s. horwitz.
semantics preserving procedure extraction.
in popl pages .
r. komondoor and s. horwitz.
effective automatic procedure extraction.
in iwpc pages .
j. krinke.
identifying similar code with program dependence graphs.
in wcre page .
g. p. krishnan and n. tsantalis.
refactoring clones an optimization problem.
icsm .
e. mealy d. carrington p. strooper and p. wyeth.
improving usability of software refactoring tools.
in proceedings of the australian software engineering conference .
n. meng m. kim and k. mckinley.
lase locating and applying systematic edits.
in icse page .
n. meng m. kim and k. s. mckinley.
systematic editing generating program transformations from an example.
in pldi pages .
r. c. miller and b. a. myers.
interactive simultaneous editing of multiple text regions.
in usenix annual technical conference pages .
m. mortensen s. ghosh and j. bieman.
aspect oriented refactoring of legacy applications an evaluation.
ieee t rans.
softw.
eng.
.
t. t. nguyen h. a. nguyen n. h. pham j. m. al kofahi and t. n. nguyen.
clone aware configuration management.
in ase pages .
d. silva r. terra and m. t. valente.
recommending automated extract method refactorings.
in proceedings of the 22nd international conference on program comprehension .
r. tairas and j. gray.
increasing clone maintenance support by unifying clone detection and refactoring activities.
inf.
softw.
technol.
.
m. toomim a. begel and s. l. graham.
managing duplicated code with linked editing.
in vlhcc pages .
n. tsantalis.
identification of extract method refactoring opportunities for the decomposition of methods.
j. syst.
softw.
.
n. tsantalis and a. chatzigeorgiou.
ranking refactoring suggestions based on historical volatility.
in proceedings of the 15th european conference on software maintenance and reengineering pages washington dc usa .
ieee computer society.
s. a. vidal and c. a. marcos.
toward automated refactoring of crosscutting concerns into aspects.
j. syst.
softw.
.
n. zazworka c. seaman and f. shull.
prioritizing design debt investment opportunities.
in proceedings of the 2nd workshop on managing technical debt .
icse florence italy