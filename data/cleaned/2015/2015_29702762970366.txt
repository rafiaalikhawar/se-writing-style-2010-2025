supporting oracle construction via static analysis junjie chen1 y anwei bai1 dan hao1 2y lingming zhang3 lu zhang1 bing xie1 hong mei1 1key laboratory of high confidence software technologies peking university moe 2institute of software eecs peking university beijing china chenjunjie byw haodan zhanglucs xiebing meihong pku.edu.cn 3department of computer science university of texas at dallas usa lingming.zhang utdallas.edu abstract in software testing the program under test is usually executed with test inputs and checked against a test oracle which is a mechanism to verify whether the program behaves as expected.
selecting the right oracle data to observe is crucial in test oracle construction.
in the literature researchers have proposed two dynamic approaches to oracle data selection by analyzing test execution information e.g.
variables values or interaction information .
however collecting such information during program execution may incur extra cost.
in this paper we present the rst static approach to oracle data selection sods static oracle data selection .
in particular sods rst identi es the substitution relationships between candidate oracle data by constructing a probabilistic substitution graph based on the de nition use chains of the program under test then estimates the fault observing capability of each candidate oracle data and nally selects a subset of oracle data with strong fault observing capability.
for programs with analyzable test code we further extend sods via pruning the probabilistic substitution graph based on cfa call graph analysis.
the experimental study on subject systems written in c or java demonstrates that our static approach is more e ective and much more e cient than state of the art dynamic approaches in most cases.
ccs concepts software and its engineering !software testing and debugging keywords test oracle oracle data selection static analysis .
introduction in software testing a test oracle is a mechanism determining whether a program executes as expected for the given test inputs and it intuitively consists of variables to be observed during testing and their expected values.
for the ycorresponding author.same test inputs di erent test oracles may demonstrate di erent fault detection capability.
therefore high quality test oracles are essential for detecting software faults.
in the literature although researchers proposed various techniques to automatically generate test inputs the test oracle problem is still recognized as one of the most di cult problems in software testing .
generally speaking test oracle creation requires the variables for observation and their expected values.
as a program usually consists of various internal and output variables which may be observed at various positions in software testing the program has many candidate oracle data1 to be included in the test oracle.
the more oracle data a test oracle contains the more powerful the test oracle is in detecting faults .
however it can be extremely costly to construct a test oracle with all or a large portion of oracle data because developers need to specify the expected values of these variables.
therefore the problem of oracle data selection arises aiming at reducing the number of oracle data in constructing a test oracle .
in the literature two dynamic approaches i.e.
maods and dodona have been proposed to select oracle data by analyzing the execution information i.e.
variables values or interactions of many tests.
however it may incur extra cost to collect the dynamic execution information .
to address this issue we present the rst static approach sods to selecting oracle data for observation in software testing.
our approach de nes and constructs a probabilistic substitution graph based on the de nition use chains for the program under test.
the probabilistic substitution graph is a graph that presents to what extent i.e.
in terms of probability a candidate oracle data may be a substitute for others.
then sods estimates the capability of each candidate oracle data on observing faults in each statement by considering to what extent substitution relationships transfer measured by .
finally sods determines the selection order of candidate oracle data based on their fault observing capability and the impact of selected oracle data measured by fp .
furthermore for any programs with analyzable test code e.g.
junit tests we extend our static approach by tailoring the program under test based on cfa call graph analysis of its tests to improve the e ectiveness of oracle data selection.
for ease of presentation we call the former asbasic sods and the latter extension as extended sods.
to evaluate sods we conducted an experimental study on real world subject systems including two c subjects 1in this paper the oracle data refer to the variables to be observed in software testing.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
and nine java subjects .
through the study on the impacts of andfp our sods techniques are more e ective when is set to and fpis set to be di erentiated explained in section .
.
.
through the study on comparing dynamic approaches and our static approach our sods is more e ective than the dynamic approaches including maods and dodona in most cases and is also much more e cient than the dynamic approaches especially maods.
in summary the contributions of this paper are as follows.
the rst static approach to selecting oracle data based on probabilistic substitution graph constructed from de nition use chain analysis.
a further extension for programs with analyzable test code based on cfa call graph analysis.
an extensive experimental study on real world subjects demonstrating that our static approach is more e ective and much more e cient than the existing dynamic approaches in most cases.
furthermore for programs with analyzable test code e.g.
junit tests our extended static technique can be even more e ective than our basic static technique.
.
an example figure presents an example program where the method factorial is to calculate the factorial of a number using the method multiply .
to observe faults in this program during software testing developers need to construct a test oracle which consists of oracle data including internal variables and output variables.
as variables may be de ned more than once e.g.
factorial is de ned at lines and respectively we use a tuple between a variable and its de nition statement to represent a candidate oracle data.
note that in this paper the concept of de ning a variable does not refer to variable declaration but refers to the fact that a variable is assigned a value by some statement.
this concept is adopted by the terminology of data dependency analysis .
at line variable nis de ned which means that line assigns a value to nand that variable nis viewed as a candidate oracle data denoted as o1 .
similar variableiat line is also a candidate oracle data denoted aso3.
however variable nat line is not viewed as a candidate oracle data in our approach because line does not assign a new value to variable nbut uses its value which is assigned at line .
that is in order to decrease the number of candidate oracle data we consider only the de ned variables as candidate oracle data.
in inter procedural analysis we also regard the variable whose value is assigned through method call or return as a candidate oracle data.
for example num1 de ned at line and factorial de ned at line i.e.
the rst factorial at line are two candidate oracle data which are o7ando5.
by analyzing statements especially the variables de ned by these statements we construct a set of candidate oracle data.
for the set of candidate oracle data we analyze their de nition use chains which are used to measure the faultobserving capability of candidate oracle data.
in dataow analysis a de nition use chain is the structure that consists of the de nition of one variable and the use of the variable and the former variable reaches the latter use without other intervening de nitions .
for example the relation between variable nat line and variable nat line is regarded as a de nition use chain.
as this paper targets or void factorial f compute factorial of a non negative integer n i.e.
n!
intn factorial i read enter the number n o1 factorial o2 i n o3 if n print wrong input is n elsef if n factorial o4 elsef while i f factorial multiply factorial i o5 i i gg o6 print the result is factorial gg intmultiply intnum1 intnum2 f o7 o8 intresult return result num1 num2 g o9 figure example program acle data selection among candidate oracle data we adapt the de nition of a de nition use chain as a structure that consists of two oracle data oiandojsatisfying that the definition of the variable in oiuses the value of the variable de ned inojwithout other intervening oracle data.
in the remaining of this paper a de nition use chain refers to such a structure on oracle data.
for example variable iat line and variable nat line form a de nition use chain.
moreover observing the value of variable iat line may detect faults resulting from the wrong value of variable nat line .
therefore variable iat line can be used as a substitute fornat line in software testing.
that is based on de nition use chains we can construct substitution relationships between candidate oracle data.
software faults are typically induced via erroneous code and errors in code can be observed through oracle data.
for example variable iat line is useful in detecting faults resulting from line because an error in this statement e.g.
i n may produce a wrong value for i. furthermore this oracle data is also useful in detecting faults resulting from other statements i.e.
line which de ne the value for variable nused by line .
therefore observing the value ofiat line may detect faults resulting from lines and .
based on this insight for a candidate oracle data it is feasible to statically identify the statements whose faults may be observed by this oracle data.
based on this information we can further estimate the capability of candidate oracle data on observing faults.
as it is costly to construct a test oracle with all the candidate oracle data it is necessary to determine the selection order of these candidate oracle data so that developers may construct a high quality test oracle with a small number of oracle data.
intuitively the candidate oracle data with large capability on observing faults tend to be selected early when constructing a test oracle.
however it may be less e ective to select oracle data just based on the descendent order of their fault observing capability because some candidate oracle data observe the faults resulting from the same statements.
for example observing either the value of the rst iat line or the value of num2 at line may detect the faults resulting from line .
although both of these oracle data may have large capability on observing faults it is not so necessary to select both of them because their fault observing capability may overlap with each other.
179therefore during oracle data selection it is necessary to identify the set of statements in which each candidate oracle data may detect faults so as to avoid selecting oracle data with signi cantly overlapping fault observing capability.
that said oracle data selection should aim to maximize the fault observing capability of the set of selected oracle data not to maximize the fault observing capability of each selected oracle data individually.
in practice tests are usually not su cient and test a program partially .
therefore we can further improve the e ectiveness of static oracle data selection by focusing on only the partial program being tested.
for example testers want to test only the method multiply in figure using some junit test.
as the source code in the method factorial is not tested by this junit test the candidate oracle data in factorial i.e.
from o1too6 should be excluded when constructing a test oracle for the junit test.
similarly the de nition use chains occurring on these candidate oracle data should also be excluded.
following this intuition we extend static oracle data selection for programs with analyzable test code because the partial program tested by the tests can be statically identi ed by program analysis.
.
static oracle data selection in this section we rst present the details of our basic static technique including probabilistic substitution graph construction section .
fault observing capability calculation section .
and oracle data selection section .
.
then we present our extended static technique in section .
.
finally we present the complexity analysis in section .
.
.
constructing the probabilistic substitution graph for any program under test our static oracle data selection rst takes the de nition use chains of the whole program as inputs to construct a probabilistic substitution graph which presents the probability that a candidate oracle data may be a substitute for others.
in particular the de nition use chains can be automatically generated by using o the shelf inter procedural program analysis tools e.g.
crystal and wala .
suppose the set of candidate oracle data is denoted as fo1 o2 o ng each of which is a de nition of a variable.
in other words a candidate oracle data can be viewed as a tuple between a variable and its position denoting the observation of the variable at the position.
for any two oracle data oiandoj i6 j n we represent their de nition use chain by oi oj which shows that the de nition of the variable in oiuses the value of the variable de ned in oj.
for figure the set of candidate oracle data isfo1 o2 o 9g e.g.
o1refers to observing nafter line and o9refers to observing result after line .
based on the de nition of de nition use chains section the example has the following de nition use chains o3 o1 o7 o2 o6 o3 o8 o3 o9 o7 o9 o8and o5 o9.
we regard the process of method call or return as an assignment from one variable to another and thus get inter procedural de nition use chains like o7 o2 o8 o3 ando5 o9.
then we de ne the probabilistic substitution graph to represent substitution relationships between candidate oracle data.
for any program we de ne its probabilistic substitution graph abbreviated as psg g v e w as follows.
vis the set of vertices each of which represents a candidate oracle data.
that is vis denoted asfo1 o2 o ng.
eis the set of edges each of which denotes a substitution relationship between two candidate oracle data.
for any two candidate oracle data oiandoj ifoi oj the former may be a substitute for the latter which is denoted as oi oj and there is an edge from ojtooi.
wis the set of weights on edges.
each weight denotes the probability that each substitution relationship occurs between a pair of candidate oracle data.
if oi oj with some probability denoted as p oi oj there is an edge from ojtooiwhose weight is p oi oj .
intuitively for any edge from ojtooiwhose weight is p oi oj faults resulting from the wrong values of the variable in ojmay be caught by oiwith the probability p oi oj .
that is the candidate oracle data oiis likely to be a substitute for ojwhen constructing a test oracle.
for any program we construct its psg as follows.
first our basic static technique constructs vertices and edges of its psg based on its de nition use chains.
although a variable may be in more than one statement including its de nition statements and use statements we take only the tuple between the variable and the position immediately after its de nition statement as a candidate oracle data.
for any two candidate oracle data oiandoj ifoi oj we construct an edge from ojtooi.
second our basic static technique assigns weights on edges to re ect the probability on the substitution relationships.
as some substitution relationships occur on some executions not all the executions our basic static technique uses the probability on the substitution relationships to estimate how likely the wrong value of the variable in ojmay be observed by the value of the variable in oifor any edge from ojtooi.
in particular if the two statements in ojan always executed together e.g.
o1ando3in figure p oi oj is set to .
otherwise p oi oj is set to the probability that the statement in oiis executed given that the statement in ojis executed i.e.
the execution probability of the corresponding branch.
note that since our analysis operates on static controlow graphs and dataow graphs the dynamic loop iteration number cannot be obtained and all the loops will be treated as having one iteration.
for example the while statement while i in line of figure is treated as if i in our basic static technique.
thus p o6 o3 b1 b2 b3 where b1 b2 and b3represent the execution probability of the false branch of line the execution probability of the false branch of line and the execution probability of the true branch of line .
although this treatment is a coarse simpli cation it avoids producing circles in the psg for analyzing dependencies between oracle data.
to illustrate figure a presents the psg of the example in figure with additional dashed edges.
.
estimating fault observing capability from the macroscopic perspective faults are induced by developers errors in programming which are demonstrated by erroneous statements.
from the microscopic perspective faults are re ected by variables values during execution.
therefore observing oracle data may detect faults resulting from erroneous statements.
for any candidate oracle data oi observing it may detect faults resulting from the statement in oibecause any faults read enter the number n o1 i n o3 i i o6 multiply int num1 int num2 o7 multiply int num1 int num2 o8 factorial o2 return result num1 num2 o9 factorial multiply factorial i o5 l substitution l substitution l substitution l substitution 1 2b3 a before selection fp read enter the number n o1 i n o3 multiply int num1 int num2 o8 factorial o2 return result num1 num2 o9 factorial multiply factorial i o5 1 2b3 i i o6 l substitution l substitution l substitution l substitution multiply int num1 int num2 o7 b after selection figure example probabilistic substitution graph psg with transitive substitution in this statement may yield a wrong value to the variable in oi.
for any other candidate oracle data oj ifoi oj the de nition of the variable in oiuses the value of the variable inojdirectly.
observing oican potentially also detect faults resulting from the statement in ojbecause a fault in this statement may produce an incorrect value which in turn may propagate to the de nition of the variable in oi.
for any other candidate oracle data ok1andok2 i6 k1 i6 k2 ifoi ok1andok1 ok2 i.e.
the de nition of the variable in oiuses the variable in ok1and the de nition of the latter uses the variable in ok2 observing oimay also detect faults resulting from the statement in ok2because a fault in this statement may produce an incorrect value that may propagate to the de nition of the variable in oi through the de nition of the variable in ok1.
ifoi ok1 oks i6 k1 ... i6 ks it is likely to detect faults resulting from the statements in ok1 ... oksvia observing oi.
note that due to our simpli cation on loop statements the preceding analysis on transitive substitution relationships does not produce circles like oi ok1 oi.
for any candidate oracle data oi we traverse the psg to nd the set of statements whose faults are likely to be detected via observing oi.
we denote this set as w oi .
obviously w oi includes the statement in oi.
for anyoj belonging to w oi it is likely to detect faults resulting from the statement in ojvia observing oi.
that is oihas the capability on observing faults resulting from the statement inoj.
we denote this capability as foc i j .
in particular given two candidate oracle data oiandoj we estimate the value of foc i j as follows.
if oiandojare the same oracle data i.e.
i j foc i i because oiis the most suitable oracle data to detect faults resulting from the statement in oiitself.
if there is an edge from ojtooiin the psg we use the weight on this edge i.e.
p oi oj to measure foc i j becausep oi oj shows how likely faults resulting from the wrong values of the variable in oj may be caught by oi.
in this circumstance foc i j p oi oj .
supposing oi ok1 oks ojis a path denoted as path fromojtooiin the psg we use formula to estimate the foc value resulting from this path.
foc path s p oi ok1 p oks oks here which may be a constant or variable is a parameter on measuring to what extent the substitution rela tionship transfers between two adjacent edges in paths with length .
note that for any path of length i.e.
s the foc value for the path would be p oi ok1 .
we will empirically investigate the impact of in section .
the dashed edges in figure a also illustrate the transitive substitution relationship along paths between oracle data e.g.
thel i substitution edge denotes the transitive substitution relationship along paths with length i. in particular l substitution represented by solid edges in the gure is actually a substitution relationship without transition.
since there may be more than one path from ojtooiin the psg we sum up the estimated foc values resulting from all the paths to calculate foc i j .
in particular supposing there arelpaths denoted as path path ... path l fromojtooi in the psg formula calculates the value of foc i j considering all paths from ojtooi.
in particular as these paths share the same starting vertex i.e.
oj and ending vertex i.e.
oi the value of foc i j cannot be larger than .
furthermore we are always able to consider all paths from ojtooibecause psg is acyclic.
foc i j lx t 1foc path t we adopt a variant of the floyd algorithm by enumerating new paths from ojtooiand updating foc i j when a vertex in vis added to the set of intermediate vertices along paths.
as a psg may be represented by a sparse matrix by discarding zero elements we plan to re ne our basic technique via further optimizations e.g.
orthogonal list representation and johnson s algorithm which target storing and operating sparse matrices.
.
selecting oracle data using the values of foc i j we can calculate the total capability of oion observing faults in statements of the program under test denoted as foc i via formula .
foc i x oj2w oi foc i j values offoc i provide a basic guideline for selecting oracle data.
however given two oracle data oiandoj if foc i k andfoc j k bothoiandojcan help detect faults resulting from the statement in ok. therefore ifoiis already selected for detecting faults resulting from the statement in ok it may be less necessary to select oj 181for the same purpose.
we use fpto measure the impact of selected oracle data on unselected oracle data.
furthermore di erent numbers of oracle data may be used in di erent circumstances.
therefore we propose several heuristics for oracle data selection in the following sub sections algorithm oracle data selection foreachi i n do selected false foc end for foreachi i n do foreachj j n do iffoc 0then foc foc foc end if end for end for foreachj j m do current k foreachi i n do if not selected then iffoc current then current foc k i end if end if end for selected true foc foreachi i n do iffoc 0then foreachs s n do ifk6 s foc notselected then foc foc foc fp30 foc foc fp end if end for end if end for end for .
.
selection algorithm algorithm depicts our heuristics on determining the selection order of candidate oracle data.
suppose that there are totally ncandidate oracle data to be selected.
in the algorithm we use a boolean array selected i n to record whether the candidate oracle data oihas been selected an array foc i j n to record the fault observing capability of oifor observing faults in the statement in oj andfoc i n to record the total fault observing capability of oi.
in algorithm lines to perform initialization.
lines to calculate the values of foc i n based on the values offoc i j n according to formula .
lines to perform oracle data selection.
in particular the loop body repeats m m n times to select moracle data.
within this loop lines to look for the candidate oracle data whose index is assigned to k with the largest fault observing capability line selects this oracle data by assigning true to its variable selected line assigns to the total fault observing capability of selected oracle data to avoid duplicate selection.
lines to adjust the fault observing capability of other candidate oracle data on the basis that candidate oracle dataokis selected.
here we use fp fp to parameterize how selected oracle data impact the faultobserving capability of other candidate oracle data.
thus for di erent values of fp algorithm yields di erent oracle data selection strategies.
intuitively the larger fpis the larger impact the selected oracle data okhas on any uns elected oracle data os and thus the smaller the values of foc andfoc are.
figure b presents the updated psg after selecting o6 marked as grey node based on figure a where the grey areas represent adjusted foc values.
for example the foc value between o3ando1is now updated to fp sinceo1has been tested to some extent by the selected o6.
.
.
choice of the parameter fp asfpprovides a means to control the impact of previous selections of oracle data on unselected oracle data we provide two strategies on the choice of the value of fp.
in an optimistic perspective since the selection of okin algorithm would help observe faults in the statement of any oi wherefoc there is no need to consider observing faults for these statements.
thus we can set the value of fp to so that lines to in algorithm can ensure not to consider faults resulting from the statements of oiwhere foc .
furthermore since the foc values of an oracle data already re ect how the oracle data can help observe faults in statements we can utilize these values when setting the value offp.
in particular we make fpa di erentiated value for di erent oracle data because selected oracle data have various impact on di erent unselected oracle data.
that is we use an array fp i n to record the fpvalue ofoi in this algorithm.
initially the fpvalue for any oracle data is because no oracle data is selected.
in algorithm we implement this initialization by adding fp between lines and .
as soon as okis selected we update the fp value for any oracle data oiwherefoc by adding fp fp foc andfp fp between lines and .
that is as okis selected it adds more impact of the selected oracle data on the fault observing capability of unselected oracle data and thus we increase the fpvalue of any oracle data oiwherefoc .
moreover for oi the more times its fpis updated due to the selection of some oracle data the larger its fpvalue is and the smaller the value of foc is osrepresents any unselected oracle data where foc .
that is by increasing the fp value ofoi algorithm prefers to not select the oracle data oswherefoc to observe faults in the statement ofoibecause these faults may already be detected by the selected oracle data.
.
further extension in practice tests are usually not su cient and actually test a program partially.
therefore it is not necessary to consider all the substitution relationships between candidate oracle data because some of them are not covered by existing tests.
furthermore considering all these substitution relationships our basic static technique may select useless oracle data and become less e ective.
fortunately for some modern unit testing frameworks e.g.
junit each test is a code snippet including sequence of method invocations.
thus it is possible to statically identify the parts of source code tested based on the call graph analysis of the test code snippets.
that is for any program with tests in the form of analyzable code snippets e.g.
junit tests we further extend the static technique to tailor the program based on static call graph analysis.
in particular our extended technique rst extracts a static call graph of the tests denoted as t by using cfa al182gorithm which has been demonstrated to be e cient and more precise than other common static algorithms e.g.
class hierarchy analysis or rapid type analysis .
based on the static call graph our extended technique constructs de nition use chains by removing the candidate oracle data that are not within the static call graph of t. based on these de nition use chains our extended technique constructs a psg which is actually a tailored psg for the whole program.
based on this psg our extended technique estimates the fault observing capability of candidate oracle data section .
and selects oracle data section .
.
further discussion on the comparison between the basic and extended static techniques is referred to section .
.
.
complexity analysis supposing that the total number of candidate oracle data isnand the number of selected oracle data is m we analyze the time complexity of our basic static technique as follows.
the time complexity for constructing the psg is o n .
since our basic static technique calculates paths in the psg based on a variant of the floyd algorithm the time complexity for estimating the fault observing capability iso n3 in the worst case.
when this complexity can be further reduced to o n .
the time complexity for oracle data selection in the worst case is o mn2 .
generally speaking the time complexity of our basic static technique iso n3 in the worst case since m n. our extended static technique has the same stages as our basic static technique when taking de nition use chains as inputs.
thus the time complexity of our extended static technique is also o n3 in the worst case.
in particular our extended static technique needs to construct a static call graph oftby cfa which may incur extra cost .
on the other hand our extended static technique may also reduce overheads due to the its tailored psg.
in particular as the psg used by our extended static technique is more sparse our extended static technique may reduce overheads during calculating fault observing capability and selecting oracle data.
furthermore the cost of constructing a psg is also reduced as the program under test can be viewed as being tailored.
we further investigate the cost of the basic static and extended static techniques in section .
.
.
.
experimental study our study addresses the following research questions.
rq1 how do di erent con gurations i.e.
andfp impact the e ectiveness of sods?
rq2 how does sods compare to the existing dynamic approaches in terms of both e ectiveness and e ciency?
rq3 how does the number of selected oracle data in uence the e ectiveness of sods?
.
implementation and supporting tools when implementing our sods approach we adopted the static analysis tool crystal2for c subjects and the analysis tool wala3for java subjects to identify de nitionuse chains.
moreover we do not analyze the de nition use chains in libraries and take them as a black box in implementing our sods approach.
in total we spent two months implementing the sods approach.
more details are available at the sods homepage4.
we also reimplemented maods and dodona due to the lack of existing tool support.
maods is the rst approach to oracle data selection which runs test inputs against a large number of mutants and selects variables based on the number of mutants distinguished from the original program by these variables.
later targeting only object oriented programs dodona is proposed to select oracle data via analyzing the network centrality metrics of variable relationship graph in execution traces.
in particular we use mutgen5to generate mutants to implement maods and use java pathfinder to analyze dynamic data ow relations to implement dodona strictly following the prior work .
in total we spent about three months in implementing dodona and maods.
any of the preceding approaches including our sods and the compared dodona and maods outputs a list of selected oracle data which can be manually augmented with expected outputs to construct complete test oracles.
the same as the prior work testers can construct a complete test oracle for java subjects by adding an assertequal call for each oracle data in each given junit test and construct program oracles for c subjects since its tests are actually system tests.
furthermore following prior work if a selected oracle variable is unstable e.g.
a random variable that may yield di erent values during di erent executions of the same test input we removed it from the set of selected oracle data.
.
subjects tests and faults we used two c subjects and nine java subjects in this study.
the two c subjects are two unix utilities available at software artifact infrastructure repository sir .
the nine java subjects have been widely used in the literature of software testing including the prior work on oracle data selection .
each subject has a test suite accumulated during software development.
the tests for the c subjects are system tests which are actually test inputs without test oracles.
the tests for the java subjects are junit tests which consist of test inputs and assertions on test outputs.
to evaluate fault detection e ectiveness of selected oracle data we ignore these original assertions by using the asm bytecode manipulation framework.
table presents the basic information of these subjects where columns present the loc without libraries and test code the total candidate oracle data number6 test number and test coverage.
following prior work we removed the tests incuring compilation errors in java pathfinder the test coverage for c java subjects was collected using gcov eclemma7.
in the literature mutation testing has been shown to be e ective in simulating real faults for software testing experiments .
so do the prior work on oracle data selection .
therefore we also constructed faulty programs using mutation testing .
in particular we used mutgen major to generate all mutants for c java subjects.
similar with the prior work for each subject mutgen.zip 6only candidate oracle data in the source code are considered here.
183table subjects subject version loc odata test coverage gzip .
.
.
flex .
.
.
csv .
.
jdkim .
.
jct .
.
cli .
.
tam .
.
.
jmime .
.
.
cio .
.
dig .
.
.
jgt .
.
.
total table strategies of our static approach approachsods a b x .
.
.
.
fp d d d d program we constructed mutant groups each of which consists of di erent randomly selected mutants i.e.
mutation faults in total for each subject.
.
independent variables ivs we consider the following independent variables.
iv1 oracle data selection approaches.
we compare our sods approach with two state of the art dynamic approaches maods and dodona .
iv2 sods con gurations.
we consider various congurations of our sods approach by varying the values of the two parameters andfp.
table summarizes the sixteen strategies of our static approach with various values on andfp.
for ease of representation we use sodsa x sodsb x x .
.
.
to denote the strategies of our basic extended static technique with various settings on andfp.
for we assign its value as .
.
respectively and for fp we assign a di erentiated value abbreviated asdin this table or an uniform value i.e.
.
iv3 sizes of selected oracle data.
this variable concerns with the number of oracle data selected when constructing a test oracle.
similar with previous work we use oracle data as the default con guration.
in addition in practice testers typically construct assertions for each test input .
therefore we also investigate whether the comparison results between our approach and the existing approaches are in uenced by di erent sizes of selected oracle data from to .
.
dependent variables dvs the dependent variables considered in our study consist of the rate of faults detected by the selected oracle data and the total time in oracle data selection.
the former measures the e ectiveness whereas the latter measures the e ciency.
.
experimental process first we applied our basic technique to each subject our extended technique to each java subject the dynamic approach maods to each c subject8 and the dynamic approach dodona to each java subject9 recording the oracle data selection order and the total time spent on oracle data selection.
8we did not apply maods to java subjects because prior work has shown that dodona is more e ective than maods for java programs .
in particular for each c subject we generated mutants using mutgen and then fed all the mutants and the whole test suite to maods.
9we did not apply dodona to c subjects because it was designed for object oriented programs .to evaluate the fault detection e ectiveness of selected oracle data we applied each test input with the selected oracle data to the faulty programs recording the faults detected by each oracle data.
in particular we rst obtained its expected value for the corresponding test input by recording its actual value through code instrumentation during the original program execution.
then we checked whether the actual value of this oracle data on the faulty program is the same as the corresponding expected value.
if not this oracle data detects the corresponding fault.
for each subject based on the faults that each oracle data detects we calculate the rate of faults detected by the set of oracle data selected by each approach on di erent mutant groups i.e.
faults .
all the experiments were conducted on a workstation with intel e5504 quad core processor .0ghz and 100g memory running ubuntu .
.
.
threats to validity the main threat to construct validity is concerned with the metrics used to evaluate the e ectiveness and e ciency of the studied approaches.
to reduce this threat we used the widely used metrics in software testing i.g.
the rate of fault detection as well as the approach overhead.
the threats to internal validity mainly lie in the implementations of the dynamic and static approaches.
since the implementation and raw experimental data of maods dodona are not accessible with the aid of their authors we strictly followed the prior work and also ensured that our implementation produced similar results with prior work .
to reduce the threat of implementing our static approach we used existing static analysis tools i.e.
crystal and wala .
however we introduced the following simpli cations when implementing our approach.
first we assumed that every branch within a conditional statement has the same execution probability because it is extremely hard to predict the execution probabilities of branches statically and precisely.
second aliasing is not handled.
third each array variable object variable heap variable or member variable of a class is treated as a single variable in constructing the set of candidate oracle data.
in the future we will further improve these simpli cations by adopting more advanced analysis techniques.
the threats to external validity mainly lie in the used subjects faults and tests.
although we used more subjects than the prior work and the subjects are widely used in the literature of software testing they may not be representative of other programs.
although mutation faults have been demonstrated to be reasonable in the evaluation of testing techniques mutation faults may still not be representative of real faults in practice.
to reduce these threats we will conduct experiments on practical programs with real faults in the future.
furthermore another external threat lies in the used tests following the dodona work we removed some tests that incur compiling errors on java pathfinder.
.
results and analysis .
.
rq1 configuration impacts table presents the average fault detection rate of sods with various values of andfpfor a given oracle data set.
the results in this section are based on selected oracle data.
rows to present the average fault detection rate of our static approach for each subject respectively 184table average rate of faults detected by the oracle data selected by sods approachsodsa x sodsb x gzip .
.
.
.
.
.
.
.
flex .
.
.
.
.
.
.
.
csv .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jdkim .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jct .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
cli .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tam .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jmime .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
cio .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
dig .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jgt .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table overall fault detection rates maods dodona sodsa sodsb subject avg.
sd.
avg.
sd.
avg.
sd.
gzip .
.
.
.
flex .
.
.
.
avg.
.
.
csv .
.
.
.
.
.
jdkim .
.
.
.
.
.
jct .
.
.
.
.
.
cli .
.
.
.
.
.
tam .
.
.
.
.
.
jmime .
.
.
.
.
.
cio .
.
.
.
.
.
dig .
.
.
.
.
.
jgt .
.
.
.
.
.
avg.
.
.
.
and the last row presents the average fault detection rate of our static approach for all the subjects.
in particular as sodsb targets only java subjects its results for the c subjects are not available.
the bold numbers in columns to columns to represent the top largest average fault detection rate of sodsa sodsb for each subject.
from table the average fault detection rate of sodsa is mostly larger than the other strategies of sodsa.
even when sodsa is not within the top implementations i.e.
for gzip flex csv cio and jgt the di erence between sodsa and the best technique is at most .
.
in summary for sodsa the best con guration of the two parameters is that andfp d. similarly for sodsb all con gurations with fp dare usually at least as e ective as all con gurations with fp while all con gurations with usually perform better than the other con gurations.
thus for sodsb the best con guration of the two parameters is also that andfp d. this observation indicates that substitution relationship transfer does not tend to improve the e ectiveness of oracle data selection but considering di erentiated impacts of selected oracle data on the unselected oracle data can improve the e ectiveness.
through the preceding analysis the default values of the two parameters are set to be that and fp d i.e.
sodsa and sodsb when applying our static approach for the rest of this paper and practical usage.
.
.
rq2 comparison with dynamic approaches table presents overall fault detection rates for our default static techniques and state of the art dynamic techniques.
in the table avg and sd stand for average fault detection rates and standard deviations.
note that the sodsb technique does not apply to the c subjects.
from the table sodsa is more e ective than maods for the c subjects on average.
for the java subjects both sodsa and sodsb are more e ective than dodona on average.
more speci cally sodsa sodsb is able to outperform dodona for out of the java subjects.
to learn whether our static approach is signi cantly di erent from the dynamic approaches we further perform statistical analysis.
we rst performed the kolmogorov smirnov test whose results demonstrated that the population ontable paired sample t test subjectsodsa sodsb sodsa sodsb 2dodona dodona maods sodsa gzip flex csv jdkim jct cli tam jmime cio dig jgt the faults detected by the selected oracle data follows the normal distribution which is the precondition of the paired sample t test.
then we performed a paired sample t test with the signi cance level of .
on the raw faultdetection rates of the selected oracle data i.e.
on mutant groups for each subject.
table lists the p values of the t test where indicates that the former approach signi cantly outperforms the latter and indicates that the latter approach signi cantly outperforms the former.
in other words the results without any marks i.e.
and indicate that the compared approaches have no signi cant di erence.
from the table sodsa and dodona have no signi cant di erence for four java subjects i.e.
jdkim jct cli and tam .
sodsb and dodona also have no signi cant di erence for four java subjects.
sodsa and maods have no signi cant di erence for gzip.
generally speaking for almost half subjects our static approach has no signi cant di erence with the dynamic approaches.
for the remaining subjects sods and the dynamic techniques have signi cant di erence.
in particular sodsa signi cantly outperforms maods for flex while maods cannot signi cantly outperform sodsa for any c subject.
for java subjects sodsa signi cantly outperforms dodona for subjects i.e.
jmime cio and jgt whereas dodona signi cantly outperforms sodsa for subjects i.e.
csv and dig .
furthermore sodsb signi cantly outperforms dodona for subjects i.e.
jct jmime cio and jgt whereas dodona only signi cantly outperforms sodsb for csv.
in summary sodsa is at least as e ective as maods for all c subjects while sodsb is at least as e ective as dodona signi cantly better than dodona for of the java subjects except for the smallest subject csv.
furthermore as our extended technique aims to improve the e ectiveness of our basic static technique for programs tested under the junit testing framework we further compare our basic technique and our extended technique based on the same paired sample t test.
from the last column of table we observe that these two techniques have no signi cant di erence for subjects i.e.
csv cli tam and cio .
for all the remaining java subjects sodsb signi cantly outperforms sodsa .
that is through tailoring the psg by removing the de nition use chains that are 185table execution time minutes approachsodsa x sodsb xmaods dodona2 max max gzip .
.
.
flex .
.
.
csv .
.
.
.
.
jdkim .
.
.
.
.
jct .
.
.
.
.
cli .
.
.
.
.
tam .
.
.
.
.
jmime .
.
.
.
.
cio .
.
.
.
.
dig .
.
.
.
.
jgt .
.
.
.
.
not covered by tests our extended static technique further improves the e ectiveness of our basic static technique.
table presents the execution time of the static and dynamic approaches on selecting oracle data.
as the space is limited and the execution time for di erent con gurations of our approach is close we present the time cost of only our default con guration i.e.
x and the maximum time cost among all con gurations of our approach.
the results show that the cost for dodona ranges from .
minutes to .
minutes and the cost for maods ranges from .
to .
minutes.
in contrast the execution time for our default sodsa and sodsb only ranges from .
minutes to .
minutes and even the cost for the most expensive con guration of our approach only ranges from .
minutes to .
minutes.
it is clear that our techniques are much more e cient than maods.
comparing our techniques with dodona on java subjects the execution time of our static techniques with default con gurations is much smaller than that of dodona on subjects i.e.
csv jmime cio and jgt whereas for the remaining java subjects the execution time of our static techniques is close to that of dodona.
we suspect the reason for the later observation to be that the source code of the latter subjects contains few complex structures such as loops so that it is less time consuming to run these subjects with tests and analyze the execution information.
in general our sodsa and sodsb techniques cost less than minutes for any java subject whereas dodona is not stable and can cost more than minutes.
therefore our static techniques clearly demonstrate their superiority to the dynamic approaches in terms of e ciency.
.
.
rq3 impacts of selected oracle data size in this section we further investigate the e ectiveness of all the studied techniques when selecting to oracle data.
table presents the average fault detection rate of each studied technique for each subject when using different numbers of oracle data10.
in the table each column presents the results for di erent techniques m d sa and sb denotes maods dodona sodsa and sodsb respectively with di erent sizes of oracle data set.
from this table sodsa outperforms maods for both c subjects when using more than oracle data.
when using no more than oracle data either sodsa or maods outperforms the other only in one of the two c subjects.
the reason is that maods is directly based on the dynamic effectiveness of oracle data and tend to be more precise when using a smaller number of oracle data.
surprisingly on the average of all java programs our sodsa and sodsb techniques consistently outperform dodona for all the di erent oracle data set sizes demonstrating the promising future of static oracle selection.
for example when or10the results of size are the same with the average fault detection rates in table .table comparison using same di erent test suite size same different acle data size is dodona detects .
faults while sodsa and sodsb detect .
and .
faults respectively.
another interesting nding is that sodsa is competitive comparing to sodsb when using oracle data further demonstrating the e ectiveness of sods.
.
discussion .
general v.s.
test specific based on whether oracle data are selected for some speci c tests or any tests oracle data selection can be classied into general approaches e.g.
sodsa and test speci c approaches e.g.
maods dodona and sodsb .
general approaches may be more applicable at an early stage of software development without test inputs.
for example in practice modern code base usually contains a large number of assertions and the developers typically start to construct the test oracle at an early stage of software development when no test inputs have been given yet.
on the contrary test speci c approaches may be more applicable for any speci c test suite consisting of only test inputs.
furthermore in software evolution where test suites are continuously re ned it is cost e ective to use general approaches rather than test speci c approaches because testspeci c approaches may be less e ective for test suites that are not used in oracle data selection.
to verify this hypothesis we took maods as a representative of test speci c approaches and conducted a small experiment on flex using two randomly constructed test suites each of which consists of randomly selected test inputs.
then we fed one test suite to maods and evaluated the oracle data selected by maods with this test suite as well as with the other test suite on randomly selected mutants.
table presents the number of faults detected by each oracle data set where same di erent denotes the situation where the same di erent test suite is used in oracle data selection and evaluation.
maods performs much worse when di erent test suites are used in oracle data selection and evaluation.
therefore in test suite evolution general approaches tend to be more e ective than test speci c approaches because the latter require testers to re select oracle data from time to time to keep the selected oracle data e ective.
.
should we go with more oracle data?
section .
.
shows that our static approach is stable and more e ective than dynamic techniques in most cases for various oracle data sizes from to .
however it is not clear how the comparison results change in case of even larger oracle data sizes.
therefore we further investigated the effectiveness of all the studied techniques when selecting to oracle data.
due to the space limitation we show the results of using to oracle data on two java subject programs in figure since the other subjects follow a similar pattern.
in each sub gure the xaxis represents the sizes of selected oracle data e.g.
s10denotes using oracle data the yaxis represents the fault detection rates the white gray and red boxplots represent the dodona sodsa and sodsb respectively.
we can nd that the e ectiveness of di erent oracle data selection techniques tends to become saturate when using larger oracle data sizes.
in addition using more than oracle data cannot provide 186table impacts of di erent oracle sizes from to size size size size size size size size size sub.
m d sa sb m d sa sb m d sa sb m d sa sb m d sa sb m d sa sb m d sa sb m d sa sb m d sa sb gzip .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
flex .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
csv .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jdkim .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jct .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
cli .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tam .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jmime .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
cio .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
dig .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jgt .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
s5 s10 s15 s20 s25 s30 s35 s40 s45 s50 cli .
.
.
.
s5 s10 s15 s20 s25 s30 s35 s40 s45 s50 jmime figure results for large oracle data sizes much improvements in fault detection.
therefore given the costs of manually determining the expected value for each oracle data in practice our default setting of using oracle data can be cost e ective.
.
practical values of oracle data selection shown in a recent survey the oracle costs of human involvement include two aspects writing test oracles and evaluating test outcomes and prior work on oracle data selection same for our work can e ectively reduce e orts for the rst aspect by guiding testers to code location variables when writing test oracles .
with our approach testers can identify a set of oracle data which may serve as the variables to be observed in test assertions.
to create a complete test oracle testers need to de ne the expected value for each oracle data.
note that there can be little human involvement in the case of regression testing since the values of selected oracle data for an old version can be automatically recorded and then utilized to automatically generate the expected values of oracle data for a new version.
in the future we will further reduce the oracle cost for evaluating test outcomes beyond regression testing.
.
related work our work is mostly related to oracle data selection.
staats et al.
proposed the rst dynamic approach based on mutation testing.
later targeting object oriented programs loyola et al.
proposed another dynamic approach which selects oracle data via analyzing the network centrality metrics of variable relationship graph in execution traces.
similar to oracle data selection voas and miller proposed to identify some positions that traditional software testing can hardly detect faults by mutation analysis like staats et al.
and add assertions at these positions.
our work presents the rst static approach to the same oracledata selection problem.
unlike dynamic approaches our approach does not rely on execution traces and thus can overcome intrinsic limitations of dynamic approaches.
as the oracle data selected by our approach can be used for constructing test oracles our work is also related to test oracle generation .
most work in the literature automates test oracle generation based on speci cations .
fraser and zeller proposed test to generate assertions not oracle data by comparing the trace information of a correct program and its mutants.
furthermore program invariants generated by various tools e.g.
daikon dysy and idiscovery can also serve as test oracles.
fully automated oracle generation techniques usually either require formal program speci cations or cannot discover faults for the current program version since those techniques summarize the behaviors of the current version as test oracles.
therefore following existing work for oracle data selection this work aims to support the creation of test oracles rather than completely generate it.
besides our work is also related to testing adequacy criteria based on test oracles.
ken and david de ned state coverage criterion which decides whether all output de ning statements are covered by an oracle through investigating program slicing.
schuler and zeller proposed the concept of checked coverage which measures the extent to which the code is checked by the test oracle through dynamic slicing.
recently zhang et al.
utilized oracle related features also other features to predict test adequacy.
.
conclusion and future work in this work we propose the rst static oracle data selection approach sods and its extension.
the experimental study demonstrates that our static approach is more e ective and much more e cient than state of the art dynamic approaches in most cases.
for java programs with junit tests our extension further improves the e ectiveness of our basic technique.
in the future we will extend our work by investigating how to help testers determine the expected values of oracle data.
furthermore as our static approach may also su er from the intrinsic limitation e.g.
missing dynamic class loading of static analysis we plan to further combine the advantageous of dynamic and static approaches.
.
acknowledgement this work is partially supported by the national basic research program of china under grant no.
2015cb352201 and the national natural science foundation of china under grant no.
.
this work is also partially supported by nsf grant no.
ccf google faculty research award and ut dallas start up fund.
.