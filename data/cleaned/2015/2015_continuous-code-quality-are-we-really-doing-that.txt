continuous code quality are we really that?
carmine vassallo university of zurich zurich switzerland vassallo ifi.uzh.chfabio palomba university of zurich zurich switzerland palomba ifi.uzh.ch alberto bacchelli university of zurich zurich switzerland bacchelli ifi.uzh.chharald c. gall university of zurich zurich switzerland gall ifi.uzh.ch abstract continuous integration ci is a software engineering practice where developers constantly integrate their changes to a project throughanautomatedbuildprocess.thegoalofciistoprovide developers with prompt feedback on several quality dimensions aftereachchange.indeed previousstudiesprovidedempiricalevidence on a positive association between properly following ci principles and source code quality.
a core principle behind ci is continuous code quality alsoknownasccq whichincludesautomated testing andautomated code inspection mayappear simple andeffective yetweknowlittleaboutitspracticaladoption.inthis paper weproposeapreliminaryempiricalinvestigationaimedat understandinghowrigorouslypractitionersfollowccq.ourstudy revealsastrongdichotomybetweentheoryandpractice developers do not perform continuous inspection but rather control for qualityonlyattheendofasprintandmostofthetimesonlyonthe release branch.
preprint data and materials ccs concepts software and its engineering maintaining software keywords continuous integration code quality empirical studies acm reference format carmine vassallo fabio palomba alberto bacchelli and harald c. gall.
.continuouscodequality arewe really proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm new york ny usa 6pages.
introduction improving software quality and reducing risks .
this is how continuous integration ci has been put forward by duvall et permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
and is widely perceived by developers and students .
concretely ciisanagilesoftwaredevelopmentprocessaimedat continuouslyintegratingchangesmadebydevelopersworkingona sharedrepository abuildserverthatisusedtobuildeverycommit run all tests and assess source code quality .
duvalletal.
haveproposedasetofprinciplesthatdevelopersshouldmethodicallyfollowtoadoptci.forinstance ciusers shouldbuildsoftwareassoonasanewchangetothecodebaseis performed instead of building software at certain scheduled times e.g.
nightlybuilds .akeyprincipleofci asadvocatedbyduvallet al.
iscontinuous inspection which includes running automated testsandperformingstatic dynamicanalysisofthecodeatevery build as a way to ensure code quality.
this aspect of ci is also known as continuous code quality ccq .
previousworkprovidedevidenceonthepotentialofciinachieving its stated goals.
vasilescu et al.
quantitatively explored the effectofintroducingcionthequalityofthepullrequestprocess finding that it improves the number of processed pull requests.khohm et al.
studied whether and how shifting toward a shorterreleaseworkflow i.e.
monthlyreleases hadaneffectonthe software quality of firefox reporting significant benefits.
othersfound evidence of reduced time to market associated with ci and the possibility to catch software defects earlier .
however empiricalknowledgeisstilllackingontheactualpracticeofccq howstrictlydopractitionersadoptccq?whatare theeffectsresultingfrompractitioners approachtoccq?toscien tificallyevaluateccqanditseffects aswellastohelppractitioners in their software quality efforts one has to first understand and quantifycurrentdevelopers practices.infact anupdatedempirical knowledge on ccq is paramount both to focus future research on the most relevant aspects of ccq and on current problems in ci adoption as wellasto effectivelyguide thedesignof toolsand processes.
to this aim we conduct a large scale analysis that involves atotalof148 734buildsand5yearsofthedevelopmentchangehistoryof119javaprojectsminedbysonarcloudandtravisci two well knownprovidersofcontinuouscodequalityandcontinuous integrationdata respectively.westudytheadoptionofcontinuous codequalitybymeasuringmetricslikethenumberofbuildssubject to quality checks and frequency of the measurements.
ourfindingsrevealthatonly11 ofthebuildsaresubjecttoa code quality check and that practitioners do not apply ccq rather runmonitoringtoolsjustattheendofasprint.moreover only36 of branches are checked.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france carmine vassallo fabio palomba alberto bacchelli and harald c. gall background and related work this section provides an overview of the principles behind continuous code quality as well as the related literature.
.
continuous code quality there are a few basic principles at the basis of continuous integration .
besides maintaining a single source code repository the idea behind ci is to automate the correct integration of code changesappliedbydevelopersasmuchaspossible.thisisnormally obtained by having a dedicated build server responsible for taking all the new commits as input and automatically build test and deploy them.
in addition code quality assessment tools are used inordertocontrolhowmuchtheperformedchangerespectsthe qualitativestandardsoftheorganization.thus theprincipleof continuous code quality translates into having a development pipeline composed of a repository a ci build server and a ccq service.
the developer commits a change to a repository e.g.
hosted on github triggering a new build on the ci build server e.g.
travisci .theservertransfersthechangetoadifferentserver called ccq service that is in charge of performing the quality analyses and reporting back the outcome to the ci build server.
based on its configuration the ci build server decides on whether the build fails depending on the results of the ccq service.
ci build server users can configure the build in a customized way e.g.
sendingonlyspecificbuildsorbuildsonspecificbranches to the ccq service for inspection.
this configuration allows users to depart from the continuous quality practice as prescribed andto followadifferent strategy.the decisiontodepart fromthe prescribedccqpracticeisatthebasisofourwork whichisfocused on a deeper understanding of the actual ccq practices.
.
related work inthelastyears researchershaveproposedagrowingnumberof studies targeting ci practices also thanks to the increasing availability of publicly available ci data .
hiltonetal.
employedamixed methodapproachtostudy the use of ci in open source projects.
they first mined the change history of systems finding that ci is already adopted by the mostpopularprojectsandthattheoverallpercentageofprojects usingciisgrowingfast.inthesecondplace theresearcherssurveyed developers on the perceived benefits of ci.
the main perceived advantage is that ci helps projects release more often.
hilton et al.
proposed a qualitative study targeting the barriers developers face when using ci.
the study comprised twosurveys with industrial developers with the main findingspresenting the trade offs between i speed and certainty ii informationaccessandsecurity and iii configurationoptionsand usability.
the authors motivated the need for new methods andtoolsabletofindacompromisebetweenthoseperspectives.theresults discussed so far were also confirmed by laukkanen et al.
and kim et al.
who reported on industrial experiences when using ci.
complementing the studies mentioned above our investigation aims at understanding how rigorously developers adopt ccq.
other researchers investigated the use of automated static analysistools knowasasats inci.specifically zampettietal.
observed that a low number of builds fail because of warnings raisedbyasats whilevassalloetal.
reportedthatdevelopers configuredstaticanalysistoolsonlyatthebeginningofaproject.
ourstudyfurtherelaboratesonhowdevelopersuseasatsinci by exploring how they use them in order to perform ccq.
overview of the research methodology as duvall et al.
stated in previous work the time between discoveryandfixofcodequalityissuescanbesignificantlyreduced bycontinuouslyinspectingthecode.thus theapplicationofthecontinuous inspection principleisstatedtobecrucialforfulfilling the main advantage of ci i.e.
improving software quality and reducing risks .
the goalof the study is to quantify the gap if any between thecontinuous inspection principle also known as continuous code quality andtheactualpracticesappliedbydeveloperswiththe purposeof providing initial guidelines and tools for future research in the field of continuous integration.
thus our investigation isstructured around one research question how is ccq applied to projects in ci?.
the perspective is of researchers and practitioners interested in understanding whether code quality assessment is performed continuously in ci.
in order to answer our research question and guide future researchonccqpractice wefirstneedtoconstructadatasetcontaining projects developed through a ccq pipeline.
the contextof our study consists of such a dataset which includes projects selected as reported in section .
.
then we devise a set of ccq metrics for assessing the actual ccq adoption described in section .
and measure them over the history of the projects in our dataset section .
.
continuous code quality data collection to conduct our investigation we need to study projects that not only use ci but also i adopt a ccq pipeline ii adopt a static analysis tool that stores the quality measurements performed over theirhistory and iii haveci relatedeventsavailable sothatwe can contextualize ccq measurements in their evolution.
sinceanalreadybuiltdatasetthatfulfillsourcriteriaisnotavailable we build our own.
the definition of an ad hoc data collection strategy is necessary because ccq and ci events are stored on different servers and the alignment of the ccq change history overthechangehistoryrecordingalltheeventsoccurredontheci build server required the definition of heuristics to properly match the two sources.
in the next sections we describe the procedure we follow to build the dataset which is composed of three main steps such as i collecting data from the ccq server ii collecting data fromthe ci buildserver and iii aligning thechange history coming from the two sources.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
continuous code quality are we really that?
ase september montpellier france .
collecting ccq data sonarcloud1is a cloud service based on sonarqube that continuouslyinspectscodequalityanddetectsbugs vulnerabilities andcodesmells.sonarqubeisoneofthemostwidelyadoptedcodeanalysistoolsinthecontextofci .sonarqubeisasonarsource productthatisadoptedbymorethan85 000organizationsandthat support more than languages including the most popular ones accordingtothetiobeindex .sonarqubeprovidesdevelopers with its own rules and incorporates rules of other popular static and dynamic code analysis tools .
as an example sonarqube runs all the most popular code analysis tools i.e.
checkstyle pmd findbugs cobertura by default on java projects.
thus the relevance of sonarqube in the context of ci motivates the decision to focus on systems using sonarcloud as ccq service.
overall projects are actively using sonarcloud even thoughsomeofthemareprivateand thus notaccessible.wequery sonarcloud using the available web apis and extract the list of all the open source projects that use the free analysis service reaching candidate systems2.
.
collecting ci data starting from the initial population of candidate systems we keepprojectsthatusetravisciasbuildserver asthisensures thattheprojectactuallyadoptsaccqpractice.weselecttravisci as it provides the entire build history as opposed to other buildservers e.g.
jenkins where only the recent builds are typically stored .
selectingprojectsusingtravisciasciserverandsonarcloud as ccq service is not trivial.
while travisci provides a direct andeasyintegrationwithsonarcloud3 thereisnoexplicitlink betweenthosetwoservices meaningthatonecannotdirectlyinfer which projects use both services at the same time.
thus weneed to create such a link.
among the information available on sonarcloud theprojectsreporttheurlreferringtothesource code repository this url provides us with an exploitable solution toidentifythedesiredsystems.inparticular travisciisusedto build projects hosted on github therefore we first consider all the projects available on sonarcloud that expose a github url.
this step reduces the number of candidate projects to i.e.
of all sonarcloud systems .
subsequently using the github url we query the travisci apis and check if a certain url is presentontheplatform 390projectsmatchtheselectioncriteria i.e.
sonarcloud systems that are on travisci.
as a final step we removeprojectshavinglessthan20ccqchecksovertheirhistory4.
this filter is needed to avoid the analysis of projects that do not really integrate a ccq service in their pipeline in other words we onlyconsider projectsthat activelyapplyccq.atthe endofthis process our dataset comprises projects.
.
overlaying ccq and ci information once the explicit link between sonarcloud and travisci is available thefinalstepofthedatacollectionprocessistooverlaythe 2the complete list is available in our online appendix .
4the threshold of is fixed in a similar way as done in previous work .separate change history information available in two sources.
also inthiscase thereisnoexplicitwaytolinkadatapointavailable sonarcloudtooneontravisci.wesolvethisasinthefollowing.for each of the builds available on travisci we first collect i build id ii triggering commit i.e.
commit message and id iii build status i.e.
failed errored passed iv starting date and v ending date .then weusethe starting date parameter of the build to identify the corresponding data point on sonarcloud.
specifically let bi tibeabuilddoneonthebranch brintheci historytiof the project iavailable on travisci and let mik sik beameasurementofacertainmetric kforproject ionthebranch br in the ccq history hikavailable on sonarcloud we considered mikto be the measurement corresponding to biif the following relation held date mik startin date bi date mik startin date bi in other words for each of the considered projects we compute the time interval in which two subsequent builds i.e.
biand bi are performed on travisci and assign a quality measurement to the build biif it was started within that time window.
for eachconsideredproject thefinalresultisan overlaid change history whichcontainsinformationaboutthemeasuredmetric s and value s for each measured build i.e.
a build subject to a measurement on sonarcloud .
continuous code quality in practice inthissection wediscusshowcontinuouscodequalityisappliedin the selected projects.
specifically we first present the ccq metrics thatweconceivetoautomaticallyassesstheccqpractice.then weshowhowourprojectsperformagainsttheccqmetricsover their development s history.
.
definition of ccq metrics our study aims at assessing the practical use of ccq.
based on the constructed overlaid change history of the subject projects we devise four indicators for measuring the actual ccq usage cqcr code quality checking rate number of builds subject to a code quality check divided by the total number of builds.
efc elapsed frame between checks average number of builds between two builds subject to a code quality check.
etc elapsedtimebetweenchecks averagenumberofdays between two builds subject to a code quality check.
cb percentage of checked branches number of branches containingatleastonebuildsubjecttoacodequalitycheckdivided by the number of total branches scheduled for build.
we design these ccq usage indicators based on the guidelines byduvalletal.
tounderstandhowwellccqisperformedfrom different perspectives.
cqcr is the basic metric that reveals the fractionofbuildsthatarequalitativelymeasuredduringthehistory of a project thus giving a view on the extent to which developers use to check builds in their projects.
efc and etc measure the frequencyofthequalitychecksintheconsideredprojects interms authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france carmine vassallo fabio palomba alberto bacchelli and harald c. gall table ccq usage indicators applied to our projects.
project set ccq usage indicators feature level projects cqcr efc etc cb agelow .
.
.
.
medium .
.
.
.
high .
.
.
.
contributionlow .
.
.
.
medium .
.
.
.
high .
.
.
.
popularitylow .
.
.
.
medium .
.
.
.33high .
.
.
.
overall .
.
.
.
of the average number of builds and days respectively that are waitedbeforeperforminganewqualitycheck.cbindicatesifthere are branches that are not checked at all in this case we want tomeasure whether there are branches that are more prone to be subject of qualitative checks.
.
on the current application of ccq table1reports the results of our study aimed at investigating how ccqisappliedinpractice.thetablereportstheoverallvalues row overall ofeachconsideredmetric i.e.
code quality checking rate cqcr elapsed frame between checks efc elapsed time between checks etc and percentage of checked branches cb .moreover withtheaimofdeeperunderstandingwhetherthecharacteristicsof the projects influence our observations we also report the overall metric values when splitting the systems by age contribution and popularity.
weexploitthegithubapis toidentify i thenumberof performed commits ii the number of contributors and iii thenumbers of stars of a certain repository respectively.
for each considered perspective i.e.
age contribution and popularity we split projects into three different subsets i.e.
low medium and high.
specifically we calculate the first q and the third q quartile of the distribution representing the number of commits contributors and stars of the subject systems.
then we classify themintothefollowingcategories i lowiftheyhaveanumberof commits contributors stars nlower than q ii mediumifq1 n q3 and iii highifnis higher than q .
as shown in table column projects we inadvertently achieved a good balance amongthedifferentsubsetsintermsofthenumberofcontained projects.
looking at the results we can first observe that overall only ofthebuildsarequalitativelychecked cqcrvalue .thisis aquitesurprisingresult becauseitclearlyindicatesthatprojects arenotcontinuously inspected.
in the lights of this finding we canclaimthatthe continuous inspection principleisgenerallynot respected in practice.
when considering projects split by categories i.e.
low medium andhighforage contribution andpopularity wecanperceivea trend in the results.
young and medium age projects exhibit higher values for cqcr with respect to the more mature projects yet still have a pretty low percentage of monitored builds and respectively .
this finding seems to suggest that the application of ccqbecomesevenharderwhenincreasingthenumberofcommits andconsequentlythenumberofbuildsofasoftwareproject.we findthatonly6 ofthebuildspassforaqualitycheckinlong lived systems while the percentage is in case of an high number ofcontributors.thisresulttriangulatesthefindingsbyhiltonetal.
revealing that developers are still not very familiar with all the ci principles and tend to not apply them properly.
at the sametime itseemsthatcommunity relatedfactorsplayarolein theapplicationofccq.indeed ourfindingssuggestthatcommunitieswithalargenumberofcontributorsarelesspronetoapply ccq this is in line with previous work that showed how largecommunities generally have more coordination communication issues possibly resulting in technical pitfalls .
the most popular projects are generally more likely to use ci however accordingtoourresults theydonotapplyccq properly.
this isvisible in table wherewe observe that only ofthebuildsofpopularprojectsarequalitativelymonitored.conversely low and medium popular systems exhibit a higher number of measured builds.
finding .
the projects using ci do not continuously inspect the source code.
moreover the percentage of qualitatively monitoredbuilds is lower for systems with large numbers of commits and contributors.
elapsed frame between checks efc measures the average number of builds between two builds subject to a code quality checkon the same branch.
the overall result for efc strengthens ourinitial findings on the lack of ccq.
on the average developersperform a code quality check every builds.
this number still increaseswheretakingintoaccountthesizeoftheprojects.indeed systems with a high numberof commits and contributors have an efc score of and respectively.
it is important to highlight thatsuchprojectshaveahighernumberofbuildswithrespectto smallprojects andthereforemightbenefitmoreofacontinuous check of code quality.
looking at and elapsed time between checks etc we can confirm what we observe for the elapsed time between quality checks developersdonotperformacontinuouscodequalityassessment butrathertheymonitorthequalityattimeintervalsof17days.this number is very close to the usual duration of a scrum sprint whichisoftenusedinthecicontext thus ourfindingssuggest that likely the current practice merely consists of checking code qualityattheendofasprint.thisobservationholdswhensplitting projectsbasedontheircharacteristics asweconfirmthatquality checks are performed at fixed intervals.
finding .
developers perform a code quality inspection after several builds on average every builds and most likely at the end of a sprint.
as the last indicator we compute the percentage of checked branches cb .
table 1shows a similar trend as for the other ccq usageindicators.alsointhiscase thehigherthenumberofcommitsandcontributors thelowerthepercentageofbranchesthatare subject to a quality check.
this result confirms the possible role of community related factors as large communities tend to be more reluctant to apply ccq.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
continuous code quality are we really that?
ase september montpellier france overall only36 ofbranchesarechecked meaningthatmost of them are developed without a formal quality control.
finding .
a low percentage of branches follow ccq.
discussion and future work our results highlight a number of points to be further discussed and in particular ccqisnotappliedinpractice.
aclearresultofourstudy demonstratesapoorusageofcontinuouscodequality and thatindeedonlyaverylownumberofbuilds arequalitativelymonitored.thisfindingopensupanumberofobservations.inthefirstplace thelowuseofccqmaybeduetoa general biased perception that developers have with respect to source code quality code quality is not the toppriorityfordevelopers whoprefernottoimprovethe existingcodefordifferentreasons includingtimepressure or laziness .
most of the time developers and product managersdonotconsideraqualitydecrementenoughtofailthebuildprocess ortheydonotknowhowtoproperlysetupqualitygates .besidesthis ourstudysomehowconfirms the findings reported by hilton et al.
highlighting once again that developers face several barriers when adopting ci principles.
the relevance of a development community.
ak e y findinginourstudyreportsthatthesizeofaprojectplays a role in the adoption of continuous code quality.
while projectshavingfewdevelopersperforma slightly higher percentage of code quality checks systems with a larger communityface moredifficulties.this canbeexplained by thepresenceof community relatedfactorsthat mightprecludeaneffectivemanagementofthedevelopmentactivities.indeed wrongcommunicationandcoordinationwithinsoftware communities have been not only largely associated to the emergence of socio technical issues but also related to continuous integration aspects.
in particu lar kwan et al.
reported a strong negative impact of socio technical congruence i.e.
a measure indicating the alignmentbetweentechnicaldependenciesworkrelations amongsoftwaredevelopers onbuildsuccess.ourfindings confirm the importance of studying such factors and how theyinfluencetechnicalaspectsofsoftwaresystemsmore deeply.
on the size of change history.
according to our results projects having a longer change history are less likely toapply ccq.
this may suggest that a possible co factor in fluencing the lack of continuous code quality control fallsin the difficulty of developers to switch toward such new continuous monitoring in case the project is already mature.
ourinitialfindingspavethewaytofurtherstudythatweplan to conduct in future work on thevalue of continuous codequality.
despite previousworkintheareaofagileprocesses thereisstill a lack of study empirically assessing the benefits derivingfrom the actual practice of code quality assessment in ci.
webuildadatasetofprojectsusingbothciserverandccqservice asexplainedinsection .thus comparedtopreviouswork weareabletoanalyzethedecisionsof developers i.e.
whether perform code quality or not and the obtained measurements without rerunning the analysis onprojects snapshotsthatmightcauseseveralthreats such astheunavailabilityoftheconfigurationfileortheimpossibility to build a snapshot .
as future work we plan tomeasuretheeffectivenessoftheactualccqpracticein maintaining software quality.
key scenarios in continuous code quality.
given the fact that code quality is not continuously assessed in ci we are interested in determining the circumstances e.g.
development tasks where the use of ccq should be particularly encouraged as they can lead to significantly decrease the qualityofsourcecode.it mightbethatccqisparticularly effective in certain scenarios compared to others.
codequalityrecommendationinci.
slowbuildsareserious barriers faced by developers using ci .
automated testing and code quality assurance tasks and are possible causesinslowingdownbuilds.codequalitytasksareusually postponedandscheduledin nightly builds thuspreventing ccq to be performed.
we aim at finding a good trade off between scheduling code quality tasks at every new change andslowingdownthebuild.ourvisionistopredictwhich qualitymeasurementsperformbeforetriggeringanewbuild.
given the actual build context described in terms of several features e.g.
checked outbranch typeofdevelopmenttask etc.
arecommenderwillautomaticallyscheduleanewcode quality task enabling the proper warnings.
threats to validity this section discusses possible threats that might have affected the validity of our observations.
we mined information from different sources and combined themusingheuristicsthatwereneededbecauseofthelackofan explicit link between them.
to infer projects using both sonarcloud and travisci we used theirgithub url exposed on the firstplatform asameansforunderstandingwhethertheyalsouse travisci as build server.
this linking process can be considered safe as the github url of a project is unique and thus therecannot be cases where the history of a project on sonarcloud wasoverlaidwiththeoneofanotherprojectontravisci.asfor theoverlayofthechangehistoryinformationofthetwoplatforms we exploited the build and measurement dates to understand to whichbuildacertainmeasurementreferredto.also inthiscase the linking procedure cannot produce false positives because there are not cases in which different builds might have been performed between the dates considered.
asforthegeneralizabilityoftheresults weconductedthisstudy on a large dataset composed of projects.
we also made some precautionstotakeintoaccountonlyprojectsthatactivelyadopt ci and ccq.
we limited our study to java projects since someof the exploited platforms e.g.
sonarcloud mainly contained informationonthistypeofsystems.replicationsaimedattargeting projects written in different programming languages as well as industrial ones would be desirable.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france carmine vassallo fabio palomba alberto bacchelli and harald c. gall conclusion inthispaper weanalyzedthecurrentpracticeofcontinuouscode quality ccq .
our findings showed that the theoretical principles reported by duvall et al.
are not followed in practice.
we found that only of the builds are subject to a quality control.
more importantly the current ccq practice merely consists of checking code quality at the end of a sprint thus basically ignoring the ccq principle.
based on the dataset that we built overlaying change history informationcomingfromsonarcloudandtravisci weplanto investigate the impact of the current ccq practice on the software quality and the circumstances where developers are particularly encouragedtocheckcodequalitymorefrequently.ourfutureresearchagendaincludesalsothedefinitionoftechniquesforassisting developers during continuous monitoring of code quality.