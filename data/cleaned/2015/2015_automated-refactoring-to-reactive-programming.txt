automated refactoring to reactive programming mirko k ohler reactive programming technology technische universit at darmstadt darmstadt germany koehler cs.tu darmstadt.deguido salvaneschi reactive programming technology technische universit at darmstadt darmstadt germany salvaneschi cs.tu darmstadt.de abstract reactive programming languages and libraries such as reactivex have been shown to significantly improve software design and have seen important industrial adoption over the last years.
asynchronous applications which are notoriously error prone to implement and to maintain greatly benefit from reactive programming because they can be defined in a declarative style which improves code clarity and extensibility.
in this paper we tackle the problem of refactoring existing software that has been designed with traditional abstractions for asynchronous programming.
we propose 2r x a refactoring approach to automatically convert asynchronous code to reactive programming.
our evaluation on top starred github projects shows that 2r xis effective with common asynchronous constructs and it can provide a refactoring for .
of their occurrences.
keywords refactoring asynchronous programming reactive programming java i. i ntroduction asynchrony is essential for long running tasks or computations that involve intensive cpu load or i o such as network communication and database access.
hence asynchronous programming has become more and more important over the last years to allow a large class of software web applications e.g.
with ajax mobile apps or internet ofthings applications to stay responsive to user interaction and to environmental input.
also in a number of cases like event driven scenarios where event streams originate from touch screens gps or sensors asynchrony is the natural programming model as events can be processed concurrently .
most programming languages offer means for developers to define asynchronous computations.
a widespread solution is to fork concurrent asynchronous executions using basic thread process mechanisms e.g.
with java.lang.
thread in java.
however this approach is very low level and complicates the communication with the main thread.
for this reason modern programming languages provide abstractions for asynchronous computations.
for example c provides theasync andawait keywords and the java concurrency package has been continuously enhanced through various java releases to support high level abstractions such as futures and the fork join execution model .
similarly popular libraries provide their own constructs for asynchronous computations such as asynctask for android and swingworker for the java gui swing library.
these solutions significantly improveover low level abstractions like threads but come with their own limitations.
for example asynctask does not easily support composition like sequencing multiple asynchronous computations.
recently reactive programming rp has emerged as a programming paradigm specifically addressing software that combines events .
crucially rp allows to easily express computations on event streams that can be chained and combined using high order functional operators.
this way each operator can be scheduled independently providing a convenient model for asynchronous programming.
as a result rp provides means to describe asynchronous programs in a declarative way.
previous research showed that rp improves software design of reactive applications .
also empirical studies indicate that rp increases the correctness of program comprehension while requiring neither more time to analyze the program nor advanced programming skills .
this feature has been crucial in popularizing recent rp languages including elm bacon.js and rx reactivex originally developed by microsoft which received major attention after being adopted for the redesign of netflix s streaming server backend.
unfortunately most existing software still implements asynchronous computations with traditional techniques.
while the benefits of rp design are widely recognized and new projects can easily adopt rp abstractions right away this technology is not portable to existing software without a manual refactoring that is tedious and error prone .
as a result a number of software applications do not benefit from the design improvements provided by rp .
in this paper we propose an approach to automatically refactoring asynchronous code to the rp style based on reactivex s observable which is a programming abstraction that emits events that are asynchronously handled by observers.
reactivex uses operators from rp to compose computations on observable s. using these operators it is straight forward to extend asynchronous computations thus increasing extensibility.
our methodology applies to common abstractions for defining asynchronous computations in java including future and swing s swingworker .
we implemented our approach in 2r x an extensible eclipse refactoring plugin.
our evaluation on a number of third party popular github projects including apache zookeeper jabref junit and mockito shows the broad applicability of our technique 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1observable data data getdatafromnetwork 2data .filter d d !
null .map d d.tostring transformed .subscribeon schedulers.computation .subscribe d system.out.println onnext d fig.
rxjava example adapted from reactivex s introduction to rp .
on more than 7k projects as well as its correctness as the technique was able to correctly refactor .
of the occurrences of asynchronous constructs the other cases where ruled out by refactoring preconditions .
in summary the contributions of the paper are as follows we propose a technique to refactor common java asynchronous constructs to rp .
we design 2r x an extensible approach implemented as an eclipse plugin that provides such technique for rxjava.
we evaluate our approach with automatic testing and code inspection showing that it is broadly applicable it provides a large coverage of construct instances and exhibits acceptable execution time.
we release a new large dataset of third party projects suitable for research on asynchronous programming in java.
in this paper we do not address the problem of refactoring synchronous code to asynchronous code an issue addressed elsewhere nor we aim at refactoring imperative programming into functional programming which has been tackled e.g.
in .
also formally proving the correctness of refactorings is an open research question .
as a first step we provide supporting evidence for the soundness of our refactoring technique using standard methods like manual inspection and automated testing .
ii.
r eactive programming for asynchronous applica tions in this section we first introduce reactivex then we demonstrate refactoring to rp through a running example.
a. reactive programming in a nutshell reactivex is a library for asynchronous rp that provides abstractions and operators to process and combine event streams.
reactivex is available for several languages.
in this paper we consider the java implementation rxjava.
the main abstraction in reactivex is an observable which is the source of an event stream.
similar to the observer design pattern an observer can register to an observable and it can be notified of event occurrences.
in addition however observable s can be chained and executed on different threads.
hence asynchronous programs can be specified in a pipeline fashion with operators such as map orfilter .
fig.
juneiform application.
figure demonstrates this design.
initially we obtain a stream of data from the network as an observable line .
next all data that is null gets filtered out line and the data is transformed to a string and transformed is appended line .
the observable is executed using the default scheduler line reactivex provides a multitude of schedulers to enable asynchronous operations.
finally the result is printed to the command line line .
this approach has several advantages the computations over the stream are extensible by adding new operations to the stream and composable via combining streams through functional operators.
since data flow gets disentangled from control flow programs are easier to comprehend and maintain .
b. refactoring an ocr application figure shows juneiform an application for optical character recognition ocr .
in juneiform users load image files in the ui.
the application uses asynchronous programming to load the documents and to process them in a separate thread than the ui.
asynchrony in juneiform the document loading functionality is shown in figure 3a.
the documentloader class which extends swingworker loads the images into juneiform.
the swingworker class is provided by the swing java gui library to help programmers implementing asynchronous tasks.
in swingworker the asynchronous functionality is defined in the method which is executed when the execute method is called.
the method can both return a value after the computation has finished and publish intermediate values during its execution.
in the example documentloader inherits from the swingworker class line and it assigns two type parameters.
the first one is for the return type of the asynchronous call list document as we want to load a list of documents.
the other one is for intermediate results of the asynchronous execution document to start handling documents to the ui thread before the loading of all documents completes.
when the user selects the images from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1public abstract class documentloader 2extends swingworker list document document 4private file files 10protected list document 11throws exception list document results ... ... for file f files ... document d new document ... f ... results.add d publish d ... return results 27public void load file... files this .files files execute 31protected void process list document chunks fetchresults chunks 34protected void done ... list document documents get ... 39public abstract void fetchresult list document result ... a original swingworker implementation.1public abstract class documentloader 2extends swsubscriber list document document 4private file files 6private observable swevent list document document getobservable 8emitter list document document emitter new swemitter list document document protected list document throws exception list document results ... ... for file f files ... document d new document ... f ... results.add d publish d ... return results return observable.fromemitter emitter emitter.backpressuremode.buffer 27public void load file... files this .files files executeobservable 31protected void process list document chunks fetchresult chunks 34protected void done ... list document documents get ... 39public abstract void fetchresult list document result ... b refactored to reactivex.
changes are marked.
fig.
asynchronous file loading in juneiform.
the file chooser dialog and clicks open the load method lines of documentloader is invoked with the selected files as arguments.
the files are cached in the private files field line .
finally execute line invokes line in a background thread.
each document holds the information for an image file e.g.
name absolute path and file content.
to load the images the program iterates through all files creates a document object for each of them and adds it to the results list.
each document is sent to the ui thread as an intermediate result with the publish method line .
before being processed the results are stored in a buffer not shown .
then the callback method process is invoked with the buffer as argument line .
the buffer is necessary as the ui thread may not be able to execute process before multiple results have been published.
to display the selected images in the ui theprocess method invokes the fetchresults method line with the intermediate results of the asynchronous operation as argument.the asynchronous operation ends when the method returns.
the return value of the method results can be accessed from the done method using get lines .
these methods are declared by the swingworker class.
the refactoring the refactoring replaces the swingworker class with reactivex s observable introduced in section ii a. there are three aspects to consider when refactoring swingworker to reactive code generate emissions on each publish invocation rather than only on the result to capture the data stream nature ofswingworker such that an observer in the rp implementation reacts to each emission of the observable all methods available in the swingworker api must be available in the observer and the observable must stop sending items to the observer if the latter has not finished processing the last emission.
the result of the refactoring is in figure 3b.
the getobservable method lines creates a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1documentloader loader new documentloader setup observable 4observable document observable 5loader.getobservable .flatmap ev observable.from ev.getchunks .filter doc doc.getname .contains .jpg .subscribeon schedulers.computation display document names 11observable .observeon swingscheduler.getinstance .subscribe doc label.settext doc.getname upload document to server 16observable .observeon schedulers.io .map doc jpgtobitmap doc .subscribe doc uploadtodropbox document connect observable with subscribers 22loader.load files fig.
extending the juneiform application.
swemitter object that emits a value whenever the method produces a result lines .
the observable emits values of type swevent .
swevent objects carry either an intermediate value or the final result of the asynchronous computation.
swingworker has functionalities not available in observable such as starting the asynchronous operation with the execute method or storing the current state of the execution i.e.
whether it has completed .
in our approach theswsubscriber class implements these functionalities in the refactored version documentloader is a subclass ofswsubscriber line .
the load method remains unchanged except calling the executeobservable method line to start the asynchronous computation instead of theexecute method of the swingworker class.
similarly theprocess method line and the done method line override the methods in the swsubscriber class with the same semantics as the corresponding methods in swingworker .
the body of all these methods remains unchanged in the refactoring.
the user defined method fetchresults line remains unchanged as well.
extending juneiform the refactoring described above is of limited interest per se the approach in figure 3b is arguably not better than the solution in figure 3a.
however the refactoring is beneficial because it enables taking advantage of rp s support for extensibility and asynchronous programming via event stream combination.
let s consider the case in which a developer wants to extend the juneiform application such that only files with jpg extension are loaded the gui displays the name of the file currently processed to provide the user feedback on the loading progress and the image file is converted from jpg to bitmap and uploaded to dropbox for backup.
implementing these changes in the case of figure 3a is challenging.
first the steps in the computation exhibit de pendencies e.g.
transform an image to a bitmap and then upload it to dropbox .
hence a programmer needs to store intermediate results hiding the logic of the processing sequence.
a harder problem is that the long running tasks in should be executed in separate threads and processing should happen as soon as new files are available.
finally should be executed on the gui thread to avoid race conditions on the non synchronized gui components.
these functionalities can be of course achieved with a complex combination of non composable imperative transformations intermediate state asynchronous constructs for the execution on separate threads and callbacks to achieve responsive push based processing of new files.
alternatively developers can implement these features right away with rp operators such as filter .
figure shows an implementation of these features that extends the refactored version from figure 3b.
first the getobservable method retrieves the observable line previously defined in the documentloader class.
for load only jpg files the flatmap operator applied to the observable line provides a stream of documents since the observable produces events containing values of type list document .
from this stream the filter method produces a stream with only jpg files line .
these functionalities are executed in a background thread as specified byschedulers.computation line .
for display in the gui the name of the file currently processed lines directly specify to execute this operation in the ui thread.
finally for the file is converted from jpg to bitmap as well as uploaded to dropbox lines .
these operations are executed asynchronously and independently of each other the latter executes as soon as a result from the former is available.
loading the files starts the emission line .
further extensions are also trivial to support and can be implemented adding new operators to the pipeline.
discussion we have shown that thanks to the refactoring to rp the asynchronous juneiform application benefits from the advantages of rp design extensibility and composability.
the refactoring we just described requires some observations.
in the example the refactored code is slightly longer and it introduces new concepts such as observable orsubscriber which may harden program comprehension for developers.
however here is no way around learning new concepts when switching to a new programming paradigm and our target are developers who are already familiar with rp .
on the other hand automated refactoring may help novices to adapt to rp without the burden to manually introduce the new concepts in the codebase.
another potential downside is that the refactored code may not be as performant.for example one factor that influences performance is the configuration of the scheduler for the asynchronous computations e.g.
futures which cannot be faithfully reproduced in the refactored code.
yet rxjava provides access to the scheduler configuration so that the developer can easily tune the scheduling policy e.g.
by subscribing an observable to a different scheduler.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
iii.
r x r efactoring to reactive programming we designed 2r x a tool that automatically refactors selected asynchronous constructs to reactivex.
the key idea of the refactoring is to transform the values generated by asynchronous computations into an event stream that emits an event whenever a new value is generated.
for example swingworker produces several intermediate values and a final result both of which can be represented as an event stream.
2r x s refactoring strategy is to replace the asynchronous construct with a reactivex observable .
the observable emits an event for each results generated by the asynchronous computation.
we target two java constructs for asynchronous programming javax.swing.
swingworker swingworker is a construct defined in the java swing library.
it asynchronously executes the code in its method which returns the result of the computation.
also swingworker can emit intermediate values during the asynchronous execution.
java.util.concurrent.
future a future is a value that has not been computed yet but is available eventually .
in java the future interface has several implementations.
although future does not emit multiple values refactoring to rp relieves developers from handling the emission of the value explicitly and enables rp s support for functional composition and asynchronous execution.
the constructs above are not the only way to define an asynchronous task.
for example a primitive way to implement asynchronous execution of long running computations is via threads i.e.
by implementing the java.lang.
runnable interface or by subclassing the java.lang.
thread class.
2rxdoes not support refactoring threads because threads are not only used for asynchronous computations but also for e.g.
parallel execution and scheduling.
threads expose a general interface to programmers which enables executing any computation in the thread.
the communication with other threads takes place through shared state.
crucially threads do not provide a well defined interface for asynchronous computations that return values making them unsuitable for refactoring to rp as there is no return value that can be processed by theobservable chain.
unfortunately the cases in which threads express proper asynchronous computations are hard to distinguish because assignment to shared state can equally be due to thread communication in a concurrent application or to synchronization among parallel tasks without the programmer intention being explicit.
many modern libraries languages provide dedicated support for asynchronous computations like c s async wait java s java.util.concurrent.
future and scala s async substantially deprecating the use of raw threads for concurrency.
our approach targets these cases.
1for this reason rxjava already provides a fromfuture method to convert a future into an observable .for the java.util.concurrent.
executors class considerations similar to those made above for threads apply.
the class provides an api to submit asynchronous computations and to decouple task submission from the mechanics of running the task i.e.
thread use and scheduling.
yet in some cases theexecutors class produces java future s. in the cases where the return value is used by the rest of the program hence the future object is available 2r xperforms the refactoring for java.util.concurrent.
future .
a. refactoring asynchronous constructs in this section we provide an overview of our refactoring approach for each asynchronous construct.
swingworker refactoring swingworker to observable requires to consider two major differences between the two constructs swingworker does not only emit a final result but also intermediate results with a different type and swingworker keeps track of the current status of the computation if it is still running or if it has already finished.
to achieve the functionalities of swingworker with observable we implemented an extension to reactivex consisting of three helper classes figure 3b swemitter emits an event for each call to thepublish method and for the final result line swsubscriber implements the swingworker api on top of the emitter line swevent is the type of events produced by the observable holding either an intermediate or a final result line .
these three classes are added to the project s class path during the refactoring.
the actual refactoring consists of replacing swingworker withswsubscriber .
the swingworker definition is split into two parts by 2r x. the observable is wrapped around the swemitter class to support further asynchronous computations.
the swsubscriber class subscribes to theobservable and provides the swingworker api.
the body of the swingworker class is then rewritten such that the method is placed in the swemitter .
the other methods remain unchanged.
java futures figure 5a shows the use of a future in conjunction with an executorservice to schedule asynchronous tasks.
the example is taken from elasticsearch a distributed search engine.
first the executorservice is initialized line and a list of future is created line .
a task is submitted to the executorservice line .
the task is defined in thecall method of callable lines which returns a future for the task result that is then added to the list.
in the example the task waits for the result of another executor and retrieves the result the list t returned by the future line .
the task is executed asynchronously i.e.
it does not block the execution of the main thread.
the computation only blocks when the result of the future is retrieved to store it in a list of results line .
figure 5b shows the refactored version.
the initialization of theexecutorservice does not change line .
the list now stores observable instead of future line .
an authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1executorservice pool ... 2list future list t list 3new arraylist future list t 5for int i i numtasks i 6list.add 7pool.submit new callable list t override public list t call throws exception list t results new arraylist t latch.await while count.decrementandget results.add executor.run return results ... 19for future list t future list results.addall future.get a original code.1executorservice pool ... 2list observable list t list 3new arraylist observable list t 5for int i i numtasks i 6list.add observable.fromfuture 7pool.submit new callable list t override public list t call throws exception list t results new arraylist t latch.await while count.decrementandget results.add executor.run return results schedulers.computation ... 19for observable list t future list results.addall future.
blockingsingle b refactored code.
changes are marked.
fig.
refactoring java future .
code extracted from the elasticsearch search engine .
observable is created from the same callable that was submitted to the executor lines .
the observable uses a scheduler line to run asynchronously.
note that the future is still executed according to the executorservice only the observable operates on thescheduler .
discussion the drawback of the helper classes used in theswingworker refactoring is that they are an extension to the reactivex library while a clean refactoring should be based on reactivex only.
helper classes enable refactoring more cases as they take over some of the responsibility of preserving the functionality during the refactoring.
but helper classes also complicate the code introducing additional classes and functionalities.
we believe that the satisfactory refactoring results for java future do not justify the loss of such clean approach for those cases.
b. checking preconditions before applying a refactoring it is crucial to check whether certain conditions refactoring precondition are satisfied to guarantee that the refactoring is possible and the result is correct.
figure shows a problematic case.
the original code is in figure 6a.
two futures are created line and .
the first future does not use the standard future interface but the future subclass scheduledfuture on which the cancel method is invoked line .
this configuration leads to a non refactorable future instance because observable does not support the equivalent of a cancel method in the future class and thescheduledfuture subclass provides additional functionalities that are not supported by a refactoring that targetsfuture .
the precondition check finds non refactorable future instances and excludes them from the refactoring.
the refactored code is in figure 6b.
because of the problem above the first future is not refactored line and ourtool issues a warning for it.
the second future instance passes the precondition check as contrary to the first future it uses the default future interface and it only calls the get method.
the refactoring for this instance is correct line and .
the example demonstrates the need for flowsensitive source code analysis in 2r x e.g.
to find out on which instances cancel is invoked and to selectively reject refactoring those instances.
our preconditions are defined to disallow using functionalities of asynchronous constructs that can not be translated into corresponding functionalities of observable .
we define similar preconditions as yin and dig asynchronous constructs are only used by executing and retrieving their result and subclasses are disallowed.
preconditions are defined onoccurrences of asynchronous constructs.
an occurrence is the coherent usage of a construct.
for example in figure there are two occurrences of future .
concretely we define three preconditions for our refactoring approach.
occurrences where at least one precondition is not satisfied are excluded from the refactoring.
the asynchronous computation is not cancelled.
reactivex provides no way to cancel asynchronous computations of observable s but only to unsubscribe an observer which does not cancel the running computation .
the state of an asynchronous execution is not retrieved.
asynchronous constructs often provide ways to directly retrieve the current state of an asynchronous execution e.g.
future.isdone checks whether an asynchronous computation has completed.
observable s lack such functionality.
the asynchronous construct is not used through a subclass that provides additional functionalities.
this case includes classes specific to a single project as well as unsupported library constructs like e.g.
scheduledfuture from figure .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1scheduledfuture void cleanup 2executor.schedule ... ... 4future string futureresult 5executor.submit ... ... 7string result futureresult.get ... 9cleanup.cancel false a original code.1scheduledfuture void cleanup 2executor.schedule ... ... 4observable string futureresult observable.fromfuture executor.submit ... ... 7string result futureresult.
blockingsingle ... 9cleanup.cancel false b refactored code.
changes are marked.
fig.
precondition example.
code extracted from the dropwizard restful web service framework.
c. implementation we designed 2r xas an eclipse plugin for refactoring java projects.
the plugin consists of an extensible core that provides eclipse integration and an api for the basic functionalities required by all refactorings.
the api allows retrieving the ast of a compilation unit performing static data flow analyses identifying a specific java construct manipulating the ast and outputting the refactored code.
we implemented an extension for the two asynchronous constructs in section iii javafuture andswingworker .
each extension uses the api to search for a specific construct and to implement the associated transformation.
we have implemented an automatic precondition checker for both the constructs currently supported.
the checker is based on a flow sensitive static analysis on java source code .
the extensible architecture simplifies adding new refactorings for other constructs which is ongoing work.
iv .
e v alua tion in this section we evaluate our refactoring approach.
first we define our research questions.
a. research questions our evaluation answers the following research questions.
first we want to evaluate which fraction of all asynchronous constructs available in java can be targeted by 2r x. q1 applicability which fraction of asynchronous constructs used in real world projects is supported by 2r x?
second we want to know among the occurrences of asynchronous constructs supported by 2r x how many cases satisfy the preconditions that 2r xrequires to perform the refactoring and lead to refactored code that is correct and achieves the same functionality of the original code.
q2 correctness how many occurrences of the supported asynchronous constructs can 2r xcorrectly refactor?
finally we want to ensure that our refactoring tool is usable e.g.
the refactoring process must complete in a reasonable time even for large projects.
q3 efficiency i s2 r xfast enough to be usable by developers?next we present the methodology for creating the datasets to evaluate our work.
finally we present the answer to the research questions above e.g.
the evaluation results on applicability correctness and efficiency of our solution.
b. methodology in the following we describe the methodology to answer the research questions.
global dataset first we identified the asynchronous constructs that are used in java.
we looked for documentation and tutorials that introduce asynchronous programming in java and we considered the documentation of frameworks such as spring which provide asynchronous constructs to users.
further we talked to other researchers and developers personally and over stackoverflow about which asynchronous constructs they use.
with this process we have identified the asynchronous constructs listed in table i. we used boa a language and infrastructure for mining software repositories to identify projects that contain these constructs.
boa provides a snapshot of all public github projects from consisting of projects.
we considered the projects containing java source files.
we found java projects that contain at least one asynchronous construct.
the global dataset is composed of github opensource projects that use one of the constructs above.
we identified projects containing an asynchronous construct by searching for the class name and the corresponding import in the ast.
we also searched for classes that are created by the factory classes akka.dispatch.
futures and java.util.concurrent.
executors such as future executor executorservice and scheduledexecutorservice respectively.
for the class javax.enterprise.concurrent.
managedtask we also considered projects that use one of the associated classes managedexecutorservice or managedscheduledexecutorservice .
this approach ensures that we find constructs that are adopted in the project even if they do not appear syntactically in the code e.g.
in case they are returned by a method call and used without assigning them to an intermediate variable .
we used the global dataset to evaluate applicability of our methodology.
refactoring dataset we filtered the global dataset to select relevant projects for each of the two constructs supported by 2r x generating the refactoring dataset .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
first we filtered out all projects that do not contain one of the two constructs supported by 2r x swingworker and javafuture .
out of the java projects in the global dataset we found a total of projects that use at least one of the two supported constructs projects use java future and projects use swingworker projects use both .
next we removed projects that do not use one of the popular build tools maven or ant to at least partially automate the evaluation as we automatically tested the refactored code as well as checked whether the refactored code compiles.
we identified projects that use a build tool based on the respective build file i.e.
pom.xml for maven andbuild.xml for ant.
we ended up with projects forfuture and projects for swingworker .
on github projects can be starred by other users to follow their updates.
we used github stars as a metric for the popularity of a project .
as stars are not included in the boa dataset we counted them checking the respective online github project.
we took the projects for future and swingworker and sorted them by their number of github stars.
then we took the top ranked projects that we were able to compile resulting in the refactoring dataset .a s w e use the boa dataset some projects required dependencies that were no longer available.
we filtered out these projects as we were not able to compile them.
for future this is the case for projects for swingworker it is the case for projects.
the datasets that we created are available to researchers interested in studying java asynchronous constructs.
automatic test generation to evaluate the correctness of the refactorings we ran unit tests for each project.
we assume that when the unit tests pass before as well as after the refactoring the refactoring does not change the functionality of the code.
unfortunately for many projects existing tests provided in the project already failed even with the original code or did not cover the refactored code.
for this reason we opted for automatic test generation to create tests for exactly the parts of the code that were refactored.
to automatically test the refactored code we implemented a framework based on randoop .
the generated tests capture the behavior of the original code and are run again on the refactored code to ascertain that programs are behaviorally equivalent to the original code.
automatic test generation to assess correct refactorings has been used before e.g.
by soares et al.
.
formal verification of the correctness of refactorings is a very recent research direction .
to ensure that test generation remains feasible for large projects the testing framework accurately generates tests only for methods changed by the refactoring.
when the refactoring changes the signature of a method i.e.
name parameter or return types the framework generates tests for methods that call the changed method.
the same holds for methods that are not directly accessible e.g.
because they are private.
methods that are nondeterministic or have side effects across method calls such as writing reading from a file are not amenable for automated testing because calls to the same method resulttable i asynchronous constructs in java global dataset.
for each asynchronous construct the absolute number of projects column total and the percentage over all projects that use at least one asynchronous construct column is given.
projects can contain multiple asynchronous constructs.
constructs total java.lang.
thread .
java.util.concurrent.
executors .
java.util.concurrent.
future .
javax.swing.
swingworker .
java.util.concurrent.
futuretask .
com.google.... listenablefuture .
javafx.concurrent.
task .
akka.dispatch.
futures .
java.util.concurrent.
forkjointask .
javax.ejb.
asyncresult .
javax.ws.rs.container.
asyncresponse .
javax.enterprise.concurrent.
managedtask .
java.util.concurrent.
completablefuture .
org.springframework.scheduling.annotation.
async .
projects with asynchronous constructs .
all java projects .
in different behaviors.
the framework detects nondeterministic methods by recognizing varying test results for those methods.
all tests for nondeterministic methods are discarded.
evaluation methodology for q1 applicability we determined the most common asynchronous constructs used by developers in the global dataset and reported which percentage of them is supported by 2r x. for q2 correctness we checked which fraction of the occurrences of asynchronous constructs in the refactoring dataset are correctly refactored by 2rx.
correctness is evaluated by checking that the project still compiles after the refactoring and by executing the generated tests.
for compilation and testing we use the boa version of the projects.
we only considered occurrences that 2r x actually refactors i.e.
occurrences that are not rejected by the preconditions.
for q3 efficiency we measured the time that 2r xrequires to refactor a project.
this time includes parsing the source code and constructing the ast finding the appropriate constructs analyzing them and generating the refactored code.
c. results table i and table ii summarize the evaluation results from respectively the global dataset and from the refactoring dataset.
we describe the tables and then we refer to them to answer our research questions.
in table i for each construct we show the total and relative number of projects where the construct is used.
we found a total of projects that use at least one asynchronous construct.
table ii provides the results of the refactoring for each asynchronous construct in the refactoring dataset.
a q1 applicability table i shows that thread andexecutor are the two most used asynchronous constructs in java.
similar to thread the executor interface can be used for arbitrary concurrent computations usually via its executorservice extension.
however contrary to thread executor provides an api to submit authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii refactoring popular github projects refactoring dataset.
column stars shows the number of stars i.e.
followers on github.
column cond shows how many occurrences pass y or violate n the preconditions respectively.
column time indicates how long it takes to refactor the whole project.
loc are the lines of code and files the number of source files in the pre refactored project both measured with cloc .
columns c?andt?
indicate whether the refactored program has been successfully compiled or tested respectively.
indicates that the compilation testing was successful and diameterin the t?column indicates that the automatic test generation failed.
stars projectcond timeloc files c?t?y n ms zookeeper diameter disunity gitblit optaplanner diameter jabref nodebox a tlauncher diameter cookiecadger pipe burpsentinel a swingworker.
stars projectcond timeloc files c?t?y n ms elasticsearch junit dropwizard mockito diameter springside4 titan diameter asynchttpclient diameter graylog2server java websocket b3log b java future.
asynchronous computations which return a java future .
we are able to refactor these occurrences of future with 2r x. these occurrences are already included in the projects using future s in table i. java future i.e.
the java.util.concurrent.
future interface provided in the java standard library is the next most used construct.
standard ways to create a future are either through executorservice as we already mentioned or by directly instantiating one of the various future implementations futuretask swingworker andasyncresult implement the future interface.
the other constructs are responsible for the remaining asynchronous computations.
2rxprovides refactoring support for swingworker and java.util.concurrent.
future as well as futuretask .
futuretask is an implementation of the future interface that does not add any further functionality.
for this reason 2rxis able to refactor this construct.
as already discussed section iii thread andexecutor are excluded from the refactoring because they express computations that are not suitable for the rp model.
as a result 2r xtargets a total of projects which is .
of all projects and .
ofall projects that contain at least one asynchronous construct.
we conclude that 2r xis applicable to some of the most used java constructs for asynchronous computations.
b q2 correctness table ii presents the refactoring dataset with the amount of asynchronous constructs refactored for each project and the results of the automatic testing.
as described in section iii b the code needs to fulfill refactoring preconditions to ensure that the refactoring can be applied correctly.
we evaluate the correctness of the refactoring by checking that the refactored code can be compiled ensuring that the refactoring produces valid java and passes the automatically generated tests.
in the swingworker case table iia all occurrences of asynchronous constructs pass the preconditions.
compilation after refactoring succeeds for every project.
automatic test generation fails for projects.
the reason is that the methods under test are within inner classes hence it is not possible to automatically generate tests with randoop section iv b3 .
for the other projects all tests succeed.
in the case of future table iib we were able to refactor .
of the occurrences.
as mentioned in section iii b the precondition check excludes asynchronous constructs that are subclasses of future that are cancelled via future.cancel or that retrieve the state of the asynchronous computation via future.iscancelled orfuture.isdone .
the precondition check rejects occurrences where are cancelled are subclasses and is both.
the compilation of all projects succeeds after refactoring but the automatic test generation fails for projects because of inaccessible methods and abstract classes.
for the other projects tests are generated successfully and the tests succeed.
the evaluation shows that the use of helper classes in the case of swingworker allows us to perform significantly more refactorings than in the case of future for which no helper classes are used.
in summary 2r xis capable of refactoring .
of cases.
all refactored cases can be compiled correctly.
for projects the automatic test generation failed but for the other projects all tests are executed successfully.
c q3 efficiency at last we discuss the efficiency of our approach.
we present the run time for each refactoring in table ii.
the times were measured on an intel core i5 7200u with gb memory running linux kernel .
.
on average our approach requires ms 1k loc for swingworker and ms 1k loc for java future .
theswingworker refactoring is faster than the future refactoring because the precondition analysis of future is more involved since the helper classes in the swingworker refactoring obviate the need of preconditions.
the upper bound of the refactoring time the elasticsearch project in the java future refactorings requires seconds.
this relatively high amount of time is due to the size and the complexity of the code base.
the elasticsearch project consists of a total of compilation units and loc.
we still consider this time acceptable as the refactoring only has to be done once for the entire project it is faster than the time that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
would be required for a programmer to find the asynchronous constructs and to manually refactor them.
for smaller projects the refactoring is faster and only takes a few seconds.
v. t hrea ts to v alidity in this section we discuss the threats to the validity of our work.
internal v alidity the results of the evaluation of correctness rely on our testing framework described in section iv b3.
the framework generates extensive tests that increase the confidence in the behavioral equivalence of the original code and of the refactored code.
testing is however by definition not complete and it could be that some differences are not detected.
to mitigate this threat we also inspected all refactorings manually and found them correct.
the manual inspection has been done independently by two scientific staff members not involved in the project and by the authors.
when necessary we investigated conflicts in the inspection by manually writing small code examples which capture the essence of the inspected code.
we then tested that after refactoring the examples behave the same as before.
it is possible that refactored methods cannot be tested directly because e.g.
methods are not accessible or the refactoring changes a methods signature.
for this reason the test generation framework creates tests for methods that call the refactored methods.
this approach increases the number of methods that can be tested.
some refactoring cases however cannot be automatically tested because they rely on nondeterministic methods.
in these cases the evaluation of the refactoring has to rely on manual inspection and on ensuring that the project compiles correctly.
nondeterministic methods are detected by the testing framework and are excluded from the automatic test generation.
in summary we use the automated testing approach to increase our confidence in the soundness of our work rather than relying on it.
there exist ad hoc testing techniques that specifically target certain refactorings but none of them directly apply to the refactorings used in this paper opening an interesting direction for future work.
external v alidity another threat to validity is whether our results can be generalized.
the projects considered for the evaluation are open source projects available on github.
we considered projects that have a high amount of stars followers which is on one hand an indication of popularity but also of a certain code quality .
the refactoring dataset contains software applications that belong to different domains including a distributed database titan a computer game launcher a tlauncher and a testing framework junit .
in addition since we adopt projects in the wild for our evaluation we consider codebases developed by different teams which promises variety in coding style.
in particular manual inspection showed a diverse usage of asynchronous constructs e.g.
future is used with executor custom implementations or as part of collections amongst others.
these considerations increase our confidence that the results presented in this paper generalize to most java projects that include the supported asynchronous constructs.vi.
r ela ted work we organize related work into languages for functional reactive programming recent results on refactoring techniques and approaches to refactor existing software to asynchronous execution.
reactive programming functional reactive programming has been introduced in the fran animation system.
over the last years abstractions from frp such as event streams time changing values and combinators to support their modular composition have been introduced in a number of extensions of mainstream languages.
these include bacon.js javascript flapjax javascript frtime scheme rescala scala scala.react scala and rxjava java .
such approaches differ among the other features in the abstractions they support e.g.
event streams and behaviors or events only as well as in the consistency guarantees they provide e.g.
glitch freedom eventual consistency or multiple consistency levels .
some approaches e.g.
use synchronous rp .
for a complete overview of rp the reader can refer to the survey by bainomugisha et al.
.
tool support for reactive programming is still in an early stage with recent proposals to support interactive debugging .
refactoring refactoring refers to the process of modifying a program usually to improve the quality of the code such that the behavior remains the same .
in a broader sense refactoring can also change nonfunctional requirements of programs e.g.
performance.
studies have shown that refactoring can improve maintainability and reusability of existing software.
unfortunately despite the availability of dedicated tools developers tend to apply changes manually to fulfill the new requirements .
operationally refactoring consists of a series of transformations after checking that the refactoring candidate satisfies some preconditions.
if any step in the sequence fails all the transformations already done should be rolled back .
due to space reasons it is not possible to provide a complete overview of previous research on refactoring.
we only focus on recent work in representative areas.
wloka et al.
propose a refactoring to transform global state of java programs to thread local state where possible to introduce parallelism .
sch afer et al.
propose a refactoring from java s built in locks to a lock implementation that can be fine tuned to improve performance.
sch afer et al.
found that many refactorings are not safe for concurrent code and propose a technique to make refactoring concurrent java source code more reliable.
tsantalis et al.
propose to use java lambda expressions to refactor clones with small behavioral differences .
other recent refactoring approaches target introducing java default methods into legacy software automatic detection of refactorings for object oriented models clone refactoring as well as performance improvement using a database with an ad hoc representation of source authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
code.
liebig at al.
address refactoring with preprocessor directives and propose an approach to preserve the behavior of all variants.
meng at al.
propose to use refactoring for clone removal .
jongwook et al.
investigate scripting refactorings to retrofit design patterns in java .
lambdaficator is a tool that motivated by the new features of java converts anonymous inner classes to lambda expressions and converts for loops that iterate over collections to high order functions.
none of these works tackles the issue of refactoring existing applications to rp .
refactoring asynchronous code the line of work by dig and colleagues addressed the issue of refactoring asynchronous code in the context of mobile applications.
this line of research starts from the observation that most available documentation focuses on creating asynchronous apps from scratch rather than on refactoring existing synchronous code.
hence not enough tools are available to support developers to perform the refactoring .
with asynchronizer developers select certain statements of a program and the tool creates an asynctask which executes the selected code asynchronously.
a static analysis informs the programmer in case the generated code introduces data races.
lin et al.
found that many developers use the wrong construct when dealing with the gui in android the asynchronous construct intentservice is more efficient than asynctask which uses shared memory.
lin et al.
developed asyncdroid a tool for refactoring asynctask into intentservice .
okur et al.
propose a tool to refactor asynchronous c programs based on two components.
asyncifier transforms legacy code that uses callbacks into code that uses the built in async await constructs.
corrector recognizes performance anti patterns and issues like deadlocks of async await constructs.
the tool corrects most cases of undesirable behavior found through an empirical study based on github public repositories.
brodu at al.
propose a tool to transform callbacks to dues a construct similar to promises based on the observation that callbacks lead to code that is hard to understand an issue known as callback hell .
all these approaches either introduce asynchronous execution for otherwise sequential code or refactor asynchronous code to use more specific constructs e.g.
async await intentservice promises .
our approach is complementary to as it can refactor applications to rp after asynchronous execution has been introduced.
conceptually our approach targets the output of and to convert it to rp .
vii.
c onclusion in this paper we presented a method to refactor asynchronous programming constructs to rp .
we implemented an eclipse plugin which automates the refactorings and we evaluated it on popular third party projects from github.the results show that our tool correctly refactors some common constructs for asynchronous programming in java.
we are currently extending 2r xto support more constructs and improve its applicability.
we hope that equipped with 2r x more and more programmers can bring the design benefits of rp to their projects.
acknowledgment this work has been performed in the context of the loewe centre emergencity and it has been supported by the german research foundation dfg within the collaborative research center crc maki and crossing by the dfg projects and by the hessian loewe initiative within the software factory .
project by the german federal ministry of education and research and by the hessian ministry of science and the arts within crisp and by the aws cloud credits for research program.