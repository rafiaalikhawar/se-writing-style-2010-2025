fib squeezing loop invariants by interpolation between forward backward predicate transformers shang wei lin jun sun hao xiao yang liu david san an and henri hansen school of computer science and engineering nanyang technological university singapore singapore university of technology and design singapore tampere university of technology finland abstract loop invariant generation is a fundamental problem in program analysis and verification.
in this work we propose a new approach to automatically constructing inductive loopinvariants.
the key idea is to aggressively squeeze an inductive invariant based on craig interpolants between forward and backward reachability analysis.
we have evaluated our approach by a set of loop benchmarks and experimental results show that our approach is promising.
i. i ntroduction in program verification loops are challenging to handle.
one way to prove that a loop satisfies its postcondition under a precondition is based on inductive loop invariants .
intuitively an inductive loop invariant is a property which holds in each iteration of the loop.
given an inductive loop invariant as long as it is weaker than the precondition andits conjunction with the negation of the loop condition isstronger than the postcondition we can conclude that the loopestablishes its postcondition if it terminates.
however program verification based on loop invariants does not come for free.
the key challenge is how to construct inductive loop invariantsautomatically which is a fundamental problem in programanalysis and verification.
given a loop with precondition pand postcondition q traditional forward analysis tries to obtain thereachability of the loop after each iteration as shown infig.
a .
let f t p be the set of forward reachable states starting from the precondition pafter thet th iteration of the loop where f0 p p. notice that fi p fi p for alli does not necessarily hold if we consider the strongest condition after the loop is executed c.f.
section iii for moredetails .
assume that the loop terminates after titerations for somet i.e.
f t p does not satisfy the loop condition.
if ft p q then we can conclude that the loop satisfies its postcondition after it terminates.
however this approachmay not terminate in general or it may take a large numberof forward iterations to find such a f t p for some t .
similarly traditional backward reachability analysis tries to obtain the set of backward reachable states denoted by b t q from the postcondition qaftertiterations assume the loop condition is still satisfied .
notice that bi q bi q for alli 0does hold if we consider the weakest condition after the loop is executed backward c.f.
section iii for more details .
if we can find a backward ... ... a b fig.
.
traditional a forward and b backward reachability ... i... fig.
.
our approach reachability bt q for some t 0such that p bt q then we conclude that the loop satisfies its postcondition asshown in fig.
b .
however this backward approach maynot terminate in general as well or it may take a large numberof backward iterations to find such a b t q for some t .
in this paper1 we propose an approach to automatically constructing inductive loop invariants in the form of bool ean combinations of linear integer constraints over programvariables.
our approach is to squeeze an invariant betweenforward and backward reachability of the loop.
althoughthe forward and backward approaches may not terminate ingeneral they do provide some hints to construct inductiveinvariants.
the intuitive idea behind our approach is as follows.instead of starting from the postcondition q we perform the backward reachability analysis from q the negation of the postcondition.
if the loop does have an inductive invariant i to establish the postcondition q as shown in fig.
then t 0ft p will not intersect with bt q otherwise iwould not be inductive.
in addition t 0ft p will be included in the inductive invariant i.e.
t 0ft p i .
furthermore iwill not intersect with bt q as well otherwise iwould not be an invariant to establish q. based on the above observation an inductive invariant iis actually 1the corresponding author shang wei lin can be contacted via the following e mail address shang wei.lin ntu.edu.sg.
.
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research793 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a craig interpolant c.f.
definition for t i 0fi p with respect to bt q .
that is we can squeeze an inductive invariant between the forward reachability from pand the backward reachability from qby obtaining an interpolant in between.
if the number of forward backward steps is sufficient an inductive invariant in between should be squeezed out.this observation gives a systematic way to construct an inductive invariant.
the details of our approach is described in section iv.
to summarize this work makes the followingcontributions we propose a novel approach to automatically con structing inductive loop invariants for loop structuresconsisting of multiple paths inside.
the generated inva riant is in the form of boolean combinations of linearinteger constraints over program variables.
the proposedapproach squeezes loop invariants between forward and backward analysis by obtaining interpolants in between.
to the best of our knowledge this is the first workto combine interpolation techniques with forward andbackward predicate transformers in hoare logic .
we have implemented our approach in a tool called fib.
we compared fib with other state of the art invariant generation tools blast invgen inter proc cpachecker itp and hola .
ourexperimental results show that our approach is promisingfor advancing the state of the art invariant generation fornumeric loops.
the rest of this paper is organized as follows.
section ii illustrates our approach with motivating examples.
section iiireviews preliminary backgrounds.
the details of the proposedapproach is introduced in section iv.
evaluations of ourapproach are presented in section v. section vi summarizesrelated works and section vii concludes this work.
ii.
m otiv ating examples in this section we illustrate the intuitive idea behind our approach using two example programs.
the first exampleis shown in fig.
a .
the precondition of the loop isp x y and the postcondition assertion isq y .
traditional forward analysis based on strongest postcondition requires to execute iterations of the loop to reach f p x y .
since f100 p x q we can conclude that the assertion qis satisfied if the loop terminates.
similarly traditional backward analysis based on weakest precondition also requires iteration to find b100 q logicalortext100 i x i y i .
sincep b100 q w ec a n conclude that the assertion is satisfied if the loop terminates.
if we change the constant from to100000 traditional approaches require a huge number of iterations to prove theassertion.
fig.
b shows the second example which isalmost the same as the first one except that the constant is replaced by a variable n .
in this example traditional either forward or backward approaches do not terminatebecause the bound is now a variable instead of a constant.assume x assume y while x !
x y assert y a assume x assume y assume n while x !
n x y assert y n b fig.
.
simple examples stmt triangle skip stmt stmt x exp x nondet ifbexp then stmt else stmt exp triangle n x exp exp exp exp exp n exp n bexp triangle false b nondet bexp bexp bexp exp exp exp exp fig.
.
syntax of imp our approach works as follows for the second program.
let us first consider the case where the loop executes without any iteration.
in this case the forward reachability f0 p is p x y n .
then we perform the backward analysis.
notice that unlike traditional backward approach starting from the postcondition q we obtain backward reachability from the negation of the postcondition i.e.
q. if the loop executes backward without any iteration from q the backward reachability b q would be the conjunction of qand the negation of the loop condition i.e.
y negationslash n x n .
then we use an smt solver to check the satisfiability of f0 p b0 q .
that is we check whether the loop violates its postcondition in zero iteration.obviously the formula is not satisfiable and we can obtainan interpolant i x y c.f.
definition for f p with respect to b0 q from the smt solver.
intuitively the interpolant iis an abstraction of f0 p i.e.
f0 p i andiis still inconsistent with b0 q .
then we check whether the interpolant iis inductive i.e.
if iholds initially in the loop no matter how many iterations the loop executes istill holds.
the formula for the inductiveness checking is x y x prime x y prime y x negationslash n x prime y prime .
we can check the validity of this formula by an smt solveras well c.f.
sections iii and iv and x y is inductive and strong enough to prove the postcondition q. thus x y is the loop invariant obtained by our approach.
however if i is not inductive we consider the second case where the loopexecutes for one iteration.
the same procedure is performed check the satisfiability of f p f1 p b1 q obtain an interpolant iif the formula is not satisfiable and check the inductiveness of i. we keep increasing the number of iterations and performing the same procedure untilwe find an inductive invariant.
the details of our approach isintroduced in section iv.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
wp skip q q wp x e q q wp x nondet q x q wp s1 s2 q wp s1 wp s2 q wp ifbthen s1else s2 q b wp s1 q b wp s2 q wp if nondet then s1else s2 q wp s1 q wp s2 q fig.
.
rules for weakest precondition iii.
b ackground in this work we consider the imperative imp language whose syntax is shown in fig.
.
in the imp language programs consist of one or more statements.
statements denoted by the symbol stmt include skip sequencing assignment and conditional statements.
the keyword nondet denotes an arbitrary value in the type of the assigned variable.
the imp language supports two basic types booleans and integers.there are two kinds of expressions in imp language namelyinteger expressions denoted by the exp symbol and boolean expressions denoted by the bexp symbol .
a term in exp is of the type of integers where xis an integer variable and nis an integer constant while a term in bexp is of boolean type wherebis a boolean variable.
to reason about the correctness of an imp program we use the interpretation of hoare logic .
a hoare triple isa formula of the form p s q where sis astmt formula representing a statement in an imp program and pandq are the precondition and postcondition of the statement s respectively.
the hoare triple p s q ispartially correct if the statement sis executed in a state in which pholds and then it terminates in a state in which qholds unless it aborts or runs forever.
in this work we consider two predicate transformers wpand sp.
the function wptakes as inputs an imp statement sand a postcondition qand returns the weakest precondition ofswith respect to q denoted by wp s q .
the function sptakes as inputs an imp statement and a precondition pand returns the strongest postcondition ofs with respect to p denoted by sp p s .
the rules to calculate the weakest precondition and strongest postcondition for eachprimitive statement are given in fig.
and fig.
respecti vely .
a hoare triple p s q can be proved if either p wp s q holds or sp p s qholds.
the target loop structure in this work is a single loop with multiple paths which can be represented as an annotated loop of the form p while do s done q .
the bexp formula is the loop guard.
the loop body sis a stmt 2total correctness requires that the statement shas to terminate.
we only consider partial correctness because the target statement in this work is a loop which may not terminate in general.sp p skip p sp p x e x0 p x e sp p x nondet x0 p sp p s1 s2 sp sp p s s2 sp p ifbthen s1else s2 sp p b s1 sp p b s2 sp p if nondet then s1else s2 sp p s1 sp p s2 fig.
.
rules for strongest postcondition formula representing a sequence of statements.
the bexp formulas pandqare the precondition and postcondition of the annotated loop respectively.
one way to validate the hoare triple for an annotated loop is based on the sppredicate transformer in which we need to prove that sp p while dosdone q. traditionally it is done by approximating the strongest postcondition of the loop.
we can define the strongestpostcondition of a loop in a recursive way as follows sp p while dosdone arrowdblbothv p sp sp p s while dosdone however the above recursive construction of the strongest postcondition may not terminate in general which is notpractical to validate an annotated loop.
furthermore even if itterminates it may take a large number of iterations to convergeto a fix point.
another way to validate an annotated loop is based on the wppredicate transformer in which we need to prove that p wp while dosdone q .
similarly we can approximate the weakest precondition of the loop byconsidering the number of iterations required to establish thepostcondition q. letb tbe a predicate describing the set of states from which the loop terminates within titerations and establish q. we can define btin a recursive way as follows whereb0 q bt b0 wp s bt it means that to establish qwithintiterations the loop can either terminate immediately without any iteration and then establish q or perform one iteration and reach a state where it terminates within t 1iterations and then establish q. theoretically wp while dosdone q is equivalent tolimk bt.
sincebtis an under approximation of wp while dosdone q for allt in practice as long as we can find btfor some t 0such that p btholds then we can conclude that p wp while dosdone q holds.
however this approach may not terminate in general or it may take a large number of iterations to find such a btfor some t .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a promising way to validate an annotated loop is based on loop invariants as formulated in definition .
however the main problem of validating an annotated loop based onloop invariants is how to generate inductive loop invariantsautomatically.
in the next section we are going to introduceour approach to generating loop invariants automatically basedon craig interpolation as formulated in definition .
definition aloop invariant iof an annotated loop is a formula satisfying the following conditions p i i q and i s i .
definition given two boolean formulas aandbsuch thata bis unsatisfiable a craig interpolant forawith respect to bis a formula asatisfying the following properties ais an abstraction of a i.e.
a a a bis unsatisfiable and arefers only to the common variables ofaandb.
the craig interpolation lemma states that an interpolant always exists for inconsistent unsatisfiable formulas in firstoder logic.
modern sat or smt solvers e.g.
z3 andmathsat support craig interpolation from unsatisfiableformulas.
iv .
s queezing loop inv ariants in this section we introduce how an invariant of a loop can be squeezed based on interpolation between forward backwardreachability analyses.
we propose two approaches.
the firstone introduced in section iv a is based on interpolationwith respect to forward reachability.
the second introduced in section iv b is based on interpolation with respect to backward reachability.
section iv c discusses some extensions.
a. f orward interpolation given an annotated loop p while dos done q we can consider its forward reachability with the precondition pby calculating its strongest postcondition.
let us use a i sp ai s fori 1to denote the strongest postcondition after thei th iteration where a0 p. if the loop does have an inductive invariant i then the reachability after each iteration must be contained in i otherwise iwould not be inductive i.e.
the condition logicalortext i 0ai i must hold.
on the other hand we can also consider the backward reachability of the loop by calculating the weakest precondition.
however for the backward reachability we start from q the negation of the postcondition.
let bi b0 wp s bi fori 1be the predicate representing the set of states from which the loop terminates within iiterations and violates the postcondition q where b0 q represents that the loop violates its postcondition qwithout performing any iterations.
if the loop does have an inductive invariant ito establish its postcondition q then the formula i bimust be unsatisfiable for all i otherwise iwould not be inductive and establish q. based on the above observations we can find that an inductive invariant i if it exists of a loop is actually an interpolant for logicalortext i 0ai with respect to b because logicalortext i 0ai i andi b is unsatisfiable.
notice thatalgorithm squeeze invariant forward input an annotated loop p while dos done q output yes no i whereiis a loop invariant 1a0 p 2b0 q 3t r 4while true do if parenleftbig logicalortextti 0ai parenrightbig bris not satisfiable then letitbe the interpolant for logicalortextti 0at w.r.t.br if it s it then return yes it at sp it s t t br b0 wp s br r r else ifatis concrete then return no else whileatis not concrete dot t at sp at s t t the inverse is not true i.e.
the interpolant iis not necessary to be inductive.
however it does provide a way to find an inductive invariant of a loop.
the basic idea is as follows.firstly we calculate for titerations the forward reachability logicalortext t i 0ai as well as the backward reachability bt.
secondly we obtain an interpolant ifor logicalortextt i 0ai with respect to bt and check whether iis inductive or not.
thirdly if iis an inductive invariant then we are done.
otherwise we increase the value of tand repeat the first and second steps until we find an inductive invariant.
algorithm shows the pseudo codeof squeezing an inductive invariant of a loop by interpolationbetween the forward and backward reachabilities.
the detailsof algorithm are described as follows initially we set a0to bep andb0to be q respectively lines .
and we use tto denote the number of forward iterations and rfor the number of backward iterations.
their initial values are set to be zero respectively line .
notice that the values of tandr might become different during the following process.
a decision procedure is performed to check whether the formula logicalortextt i 0ai bris satisfiable or not line .
if the formula is not satisfiable we can further obtain an interpolant itfor logicalortextt i 0ai with respect to br.
according to the characteristic of interpolants c.f.
definition we are guaranteed to have the following twoproperties logicalortext t i 0ai i tand it bris not satisfiable.
that is the forward reachability for t iterations from the precondition pis included in it anditis not going to violate the postcondition qin riterations as illustrated in fig.
a .
then we check whetheritis inductive.
if yes we are done and the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b0b1br...a0 a1 at ... i it b0b1br...br 1 sp it a b it b0b1br ...br sp i b0b1br ...a0 a1 at ... at br c d fig.
.
squeezing invariants inductive invariant itis returned line .
ifitis not inductive we advance forward for one more iteration based on it lines8 .
the reason for advancing forward fromitis that we may converge toward an inductive invariant more quickly than from the concrete reachability logicalortextt i 0ai becauseitis an over approximation of the concrete reachability as illustrated in fig.
b .
similarly for backward reachability we advance backward for onemore iteration from b r lines10 .
notice that for the sequence of forward reachabilitya a1 ... a t if there exists j tsuch that ajis an over approximation i.e.
ajis obtained by the strongest postcondition operator from the interpolanti j 1instead of from the concrete reachability aj a s shown in fig.
b then every amforj m t would be an over approximation as well.
thus if the formula logicalortextt i 0ai bris satisfiable line there could be two cases.
the first case is that atis concrete which means that a0 a1 ... a tare all concrete.
in this case we conclude that the loop violates its postcondition qbecause the solution to the satisfiability problem of logicalortextt i 0ai bris such a counterexample starting from pand violating qwithint riterations line .
the second case is shown in fig.
c where atis an over approximation.
we cannot conclude anything for this case becauseatmay contain spurious counterexamples.
to be sound and simplify the process we backtrack to the latestconcrete forward reachability line from which we advance forward for one more iteration lines as illustrated in fig.
d .
after that the new forward and backward reachability layout will be analyzed in the next iteration of algorithm .
we repeat the process until either a counterexample or an inductive invariant is found.
the soundness of algorithm is proved by lemma and theorem .
notice that algorithm does not guarantee itstermination.
in practice we can set an upper bound on thenumber of forward or backward iterations.
lemma ifa b c is unsatisfiable then a bis also unsatisfiable.
theorem algorithm is correct.
proof given a loop p while dos done q w e want to prove that the invariant i treturned by algorithm satisfies the following three conditions p i t it q and it s it .
sinceitis returned by algorithm only if condition holds we only have to prove conditions and .
condition we know that p a0 logicalortextt i 0ai and logicalortextt i 0ai i tbecauseitis an interpolant for logicalortextt i 0ai with respect to br.
thus condition holds.
condition since itis an interpolant for logicalortextt i 0ai with respect to br we know that it bris unsatisfiable.
according to algorithm b0 q is one of the disjuncts ofbr.
by lemma we know that it q is also unsatisfiable.
so its negation it q is a tautology.
in addition it qis equivalent to it q. thus condition holds.
we also want to prove that if algorithm returns no the loop violates its postcondition q. according to algorithm it returns no only when logicalortextt i 0ai bris satisfiable and atis concrete.
since atis concrete we can conclude that a0 a1 ... a tare all concrete and logicalortextti 0ai represents the set of concrete states which the loop can reach from pwithint iterations.
in addition bris the predicate representing the set of states from which the loop terminates within riterations and violates the postcondition q. thus a solution to the satisfiability problem of logicalortextti 0ai bris a counterexample starting from pand violating qwithint riterations.
squaresolid discussion.
in our implementation of algorithm we use an smt solver to solve the formula logicalortextti 0ai brin each iteration and directly obtain an interpolant from the solver if the formula is not satisfiable.
however the interpolant foran unsatisfiable formula is not unique i.e.
we may havemany candidates fulfilling the three conditions in definition .which one is better is worthy of further investigation and ofcourse we need to define what better means first.
currently our implementation relies on the quality of the interpolantsreturned by the smt solver which dominates the performanceof our approach.
in fact initially we have tried the z3 smt solver.
however z3 always returns the trivial interpolant logicalortext t i 0ai which makes our approach degenerate into traditi797 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
onal forward backward analysis.
thus we have tried another smt solver mathsat and it returns better interpolantsthan trivial ones which makes our implementation effective tofind inductive invariants c.f.
section v .
techniques providingquality interpolants like beautiful interpolants could helpto further improve the performance of our approach.
b. backward interpolation in the previous approach we obtain interpolants from forward reachability.
in this section we introduce another approach in the reverse direction.
the basic idea is ba sed on the following observation.
given an annotated loop p while dos done q if it does have an inductive invariant i then the negation of the invariant i must be inductive as well.
that is starting from i no matter how many iterations we take backward for the loop we will stillbe in the set of states satisfying i i.e.
wp s i i .
if it were not the case icould cross over to iafter some backward iterations so that iwould not be inductive.
this observation provides us another way to squeeze an inductiveinvariant.
the intuition is that when we do the interpolationbetween the forward backward reachabilities i.e.
the unsa tisfiable formula logicalortext t i 0ai br we obtain an interpolant iforbrinstead of for logicalortextti 0ai .
then we check whether the negation of the interpolant i is inductive or not.
if yes then iis an inductive invariant and we are done.
otherwise we increase the values of tandrby one respectively and repeat the same process until we find an inductive invariant.
algorithm shows the pseudo code of the backward approach.since algorithm is very similar to algorithm by symmetry we omit its detailed descriptions here.
the soundness of algorithm is proved by lemma and theorem .
notice that algorithm does not guarantee itstermination.
in practice we can set an upper bound on thenumber of forward or backward iterations.
theorem algorithm is correct.
proof we want to prove that i rreturned by algorithm satisfies the following three conditions p i r ir q and i r s i r .
since iris returned by algorithm only if condition holds we only have to prove conditions and .
condition since iris an interpolant for brwith respect to logicalortextt i 0ai we know that ir logicalortextti 0ai is unsatisfiable.
by lemma ir pis also unsatisfiable because a0 pis one of the disjuncts of logicalortextti 0ai .
thus p i ris a tautology.
in addition p i ris equivalent to p i r. therefore condition holds.
condition since iris an interpolant for brwith respect to logicalortextti 0ai we know br i r. let us consider the sequence of b0 b1 ... b r. sincebj bj wp s b j for0 j r we know b0 b1 ... br.
thus b0 q i r which is logically equivalent to q ir.
according to the associativity law q ir is equivalent to ir q which is also logically equivalent to i q. therefore condition holds.
squaresolidalgorithm squeeze invariant backward input an annotated loop p while dos done q output yes no i whereiis a loop invariant 1a0 p 2b0 q 3t r 4while true do ifbr parenleftbig logicalortextti 0ai parenrightbig is not satisfiable then letirbe the interpolant for brw.r.t.
logicalortextti 0ai if i r s i r then return yes ir br i r wp s ir r r at sp at s t t else ifbris concrete then return no else whilebris not concrete dor r br b0 wp s br r r c. extensions our approaches have been proposed to handle one singlelevel loop.
in this section we discuss how to extend our approaches to handle general loop structures e.g.
nested loopsor a sequence of loops.
fig.
a shows the general structure ofa two level nested loop where we only have the preconditionand postcondition of the outer loop.
in this case we are notable to perform our approaches on the inner loop because wedo not know its precondition and postcondition.
to handlethis case one straightforward solution is to flatten the nestedloops into one single level loop.
fig.
b illustrates how theflattening can be done.
briefly we just introduce an auxiliaryvariable block indicating which loop is active now.
one can easily verify that the flattened loop is equivalent to the original one.
if the outer loop has more than one loop inside we can inductively perform the flattening.
once the loop isflattened our approaches apply.
the second case that our approaches are not directly applicable is a sequence of loops.
fig.
a shows the general structure of two loops in a sequence.
we can see that thepostcondition of the first loop as well as the precondition ofthe second are missing.
to bridge the gap we can combinethem into one single level loop.
fig.
b illustrates howthe translation is done.
similarly we use auxiliary variable block to indicate the active loop.
one can easily verify thatthe translation is correct.
if we have more than two loops ina sequence we can inductively perform the translation suchthat our approaches apply.
in a general program we may havenested loops and sequence loops mixed together.
in such asituation we can inductively perform the translation based on authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
while s1 while s2 s prime int block while block !
if block if s1 block else block else if block if s2 else s prime block a nested loops b flattened loop fig.
.
flattening nested loops into a flattened loop while s1 s while s2 int block while block !
if block if s1 else s block else if block if s else block a sequential loops b combined loop fig.
.
translation of a sequence of loops into one loop the two primitive cases in fig.
and fig.
.
one more interesting extension is to combine the forward and backward approaches into a bidirectional one.
that is in each forward backward advancing iteration we obtain theforward interpolant as well as the backward interpolant si multaneously.
if either of them is inductive we are done otherwise we start from them to advance in the next iteration.if they intersect with each other we backtrack to the concretecases and then continue from there.
the process is repeateduntil an invariant is found.
v. e v aluation the proposed approach to automatically generating inductive loop invariants has been implemented in a tool calledfib.
in the implementation we use the smt solver mat hsat to solve the satisfiability problems as well as toobtain interpolants if the formula is not satisfiable.
to evaluate our approach we compared fib with six existing state of the art invariant generation tools blast invgen interproc cpachecker itp and hola .
each of the compared tools represents a different family of invariant generation techniques.
blast is acegar based model checker that generates loop invariantsfrom counterexamples based on interpolations.
invgen as sumes that the invariant is of a given template form andgenerates loop invariants by solving constraints with unknown parameters.
interproc generates loop invariants based on ab stract interpretation.
cpachecker is a configurable software1i n tx 2i n ty 4while x !
x x y y 9assert y i x y pc t1 pc x negationslash pc prime x prime x y prime y t2 pc x pc prime x prime x y prime y t3 pc pc prime x prime x y prime y t4 pc pc prime y prime y x prime x t5 pc pc prime x prime x y prime y t t1 t2 t3 t4 t5 pc y negationslash fig.
.
transition relation construction model checker which supports cegar based verification approaches.
hola generates loop invariants based on logicalabduction and quantifier elimination.
itp is a transition relation based model checking technique which calculatesfixpoints by interpolation.
for our experiments on itp weadopt the standard approach chapter 2of to encode the transition relation of a program.
fig.
shows an exampleillustrating the encoding.
an auxiliary variable pcis required to indicate the program counter line number .
for example if the next statement to be executed is x x that is pc then the statement is encoded as t 3in fig.
.
the overall transition relatioin would be t t1 t2 t3 t4 t5.
the initial condition would be i x y pc and the assertion checking problem becomes the reachability problemof the formula pc y negationslash .
we have implemented the itp approach in our fib tool for exeperiments.
both itp andour approach use mathsat as their satisfiable checking andinterpolation engine with the same configuration.
hola was already compared with blast invgen and interproc in through a set of benchmarks collectedfrom other loop invariant generation papers invgen test suite necla verification bench marks and the hola test suite .
considering thatthe set of benchmarks is rather comprehensive we adoptedthe same set for evaluation.
all the details of benchmarksand tools are collected and can be found in .
out of theoriginal46benchmarks we filtered out those with assertions postconditions inside the loops and selected the 41benchmarks for evaluation.
each benchmark has at least one loopand at least one assertion and some benchmarks have nestedloops or sequence of loops.
if the benchmark has nested orsequence loops it is manually translated into a single loopusing the translation mentioned in section iv c. table i showsthe experimental results that are obtained on a machine with an intel xeon .5ghz cpu and 16gb memory running the bit ubuntu version .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i experimental results no.
loc blast invgen interproc cpachecker itp hola fib f fib b fib bi time time time time time time time time time sec sec sec sec sec sec sec sec sec .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
clock .
.
clock .
.
.
.
.
.
.
.
clock clock .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
clock .
.
.
.
clock .
.
clock .
.
.
.
.
.
.
.
.
.
.
.
.
.
clock .
.
clock .
.
.
.
.
clock .
.
clock clock .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
clock .
.
.
.
clock .
.
clock .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
clock .
clock .
clock .
.
.
.
.
.
.
.
.
clock .
.
clock .
.
.
.
.
.
.
.
.
clock .
.
.
.
.
.
.
clock clock .
.
.
.
.
.
.
clock .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
clock .
.
.
.
.
clock .
.
clock .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
clock clock .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
clock .
clock .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
clock .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
clock clock .
.
.
.
.
.
.
.
.
.
.
.
.
each benchmark number in the first column of table i corresponds to that in and all the assertions in benchmarks are satisfied.
for each tool the symbol indicates that the tool is able to verify all assertions in the benchmark while thesymbol indicates that the tool is not able to infer the loop invariants to verify the assertions or the verification result iswrong.
the columns labeled time indicate the executiontime in seconds to generate loop invariants for verifyingthe assertions.
the symbol clockindicates that the tool did not terminate in seconds.
we mark the least execution time of correct verification in gray color for each benchmark.
as table i shows the proposed approaches are very effective to construct loop invariants to prove the assertionswithin2seconds for each benchmark especially the backward interpolation approach fib b .
the forward interpolation ap proach fib f and the bidirectional approach fib bi failed to prove the assertion in benchmark 21within200 seconds.
among the other six tools hola performs the best whichonly failed to verify three benchmarks wrong verification results in no.
15and no.
and timeout in no.
.
generally we found that the backward interpolation approach f ib b outperforms the forward approach fib f and bidirectional approach fib bi especially for benchmarks and41.
table ii shows the statistics of our three approaches including the number of forward iterations f the number offorward backtracks fb the number of backward iterations b the number of backward backtracks bb whether theinvariant is obtained based on abstract interpolants or concretestates a c and whether the obtained invariant is disjunctive ?
.
the size of the obtained invariant refers to the number of nodes in its syntax tree e.g.
the size of x y is three.
if the benchmark has more than one assertion to be checked we listthe average size of the invariant for all the assertions.
we also show the size of the fixpoints found by the itp approach.
sinceitp aims to find a fixpoint instead of an inductive invariant we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii experiment statistics no.
itp fib f fib b fib bi abortk size f fb b a c size ?
f b bb a c size ?
f fb b bb a c size ?
c 2no a yes c no c135 no a193 yes c150 no a yes c 7yes c 7yes c yes a yes c450 no c yes a yes c yes c yes a no c no c yes c 8yes c 8yes c 3no c 4no c 4no c yes a no c no c yes a no c no c529 yes a408 yes c221 no c yes a yes c no c yes a no c no c yes a no c no c yes c yes c yes c115 yes a475 yes c115 no c yes a no c no c yes a yes c yes c yes c yes c yes a yes c yes a yes c yes c345 no a no c yes c yes a no c yes c157 no a209 yes c143 no c 3no c 3no c 3no c no c no c no c208 no a no c no c104 yes a126 no c no c yes a no c no a406 no a242 yes c182 no c 8yes c 8no c 8no a no c no c yes c yes c yes c yes a no c no c yes c yes c yes c508 yes a no c236 yes c yes a no c yes c 8yes c 8no c 8no a yes c 9yes c 9yes c yes c yes c yes c yes a no c no can observe that the size of a fixpoint is usually much larger than that of an inductive invariant.
more discussions about whyour approach outperforms itp can be found in section vi.
we can also observe that the backward fib b approach has zero backtracks except benchmarks no.
17and34 which explains why it performs the best among the proposed three approaches.
after our investigation based on the statisticsgiven in table ii we summarize the reasons why fib b is the best the assertion postcondition to be proved is usuallymore symbolic abstract e.g.
x than the precondition of the loop e.g.
x y .
thus the interpolant for the backward reachability would converge to be inductive more easily.
for the assignment statement the weakestprecondition wp calculation is faster than the strongest postcondition sp calculation because wpdoes not require quantifier elimination except the nondeterminism assignmentstatement but spdoes.
considering the assertion of a loop is usually more symbolic than its precondition after thesame number of iterations the backward analysis based onwpprovides more general information than forward analysis based on sp.
thus the interpolant for the backward direction would be more close to an inductive invariant which canbe confirmed in the a c column in table ii by the fact thatfib b often obtains an inductive invariant based on abstractinterpolants from previous iterations.
that is why f ib b has much less backward backtracks than fib f. vi.
r elated works and discussions automatic loop invariant generation is a fundamental problem in program analysis and verification.
theoretically it is an undecidable problem.
to tackle this problem in practice both static and dynamic analysis based techniques have beenproposed.
static analysis based techniques can be furtherclassified to the following categories based on the underlyingtechniques that are used abstract interpretation smt solving based techniques such as counterexample guided abstraction refinement cegar constraint based methods craig interpo801 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
lation abduction learning based approach and algebraicapproaches .
dynamic analysis based techni ques include guess and check techniques and learning based techniques .
our approachbelongs to the static analysis category.
the very related work to ours is itp in which a transition system i t whereiis the initial condition and tis the transition relation as well as a safety property are considered.
given a value k their approach constructs a bmc formula in k 1steps i t t k and obtains an interpolant ifori twith respect to tk .
that is iis an over approximation of states that can be reachable within one step and not going to violate withinksteps.
then i is considered in the formula i t tk .i fi ti sn o t satisfiable an interpolant i primefori twith respect to tk is an over approximation of state that can be reachable in two steps and not going to violate withinksteps.
however if the formula is satisfiable then nothing can be concluded and the algorithm aborts.
the value of kneeds to be increased by a certain value and the same process is repeated until a realcounterexample is found or the obtained interpolant reaches afix point.
if itp advances tsteps and then aborts we increase kbytin the next iteration.
table ii shows the number of aborts and the sufficient value of kto have a conclusive result.
in our experiments we start with k which is small but sufficient to find fix points e.g.
benchmark no.
and43.
our approach is different from itp in several aspects.
we list the differences and try to analyze why our approachoutperforms itp in the followings our approach obtains the concrete forward backward reachability and tries to squeeze out an inductive inva riant based on the interpolation in between itp over approximates the set of reachable states for each step with ak lookhead to see if a fixpoint can be quickly reached based on the abstraction.
if our approach fails tofind an inductive invariant in one iteration we only haveto advance one further step from the current reachabilityfor the next iteration because the reachability is concreteand can be accumulated.
however if itp fails to find afixpoint in one iteration it has to be restarted from scratchwith a new klarger than the previous one whose value is tricky to decide because if the increment of kis too small many restarts may be required if the increment istoo big the satisfiability checking problem may becomedifficult to solve.
our approach handles program statements compositio nally.
as we know quantifier elimination is computationally expensive .
however in our approach we process one program statement at a time thus only onequantified variable has to be eliminated at a time.
in addi tion only assignment statements require quantifier elimi nation.
thus quantifier elimination is not a performancebottleneck in our approach which is also confirmed in our experiments.
on the contrary the itp approach considersthe global transition relation of all program statements.if there are nvariables in the program the k step bmc problem consists of k nvariables.
if the value of k is large solving the bmc formula takes longer time asevidenced by benchmark no.
19and32.
furthermore if the transition relation of a program is lengthy the bmc problem also becomes difficult to solve.
another closely related work is dar which also considers a transition system i t and a safety property .
their approach obtains two interpolation sequences theforward interpolation sequence angbracketleft f i f1 f2 ... f k angbracketright satisfying fi t fi 1for0 i k andfi for0 i k. the backward interpolation sequence angbracketleft b0 b1 b2 ... b k angbracketrightsatisfying bi t bi for0 i kandbi ifor0 i k. the two interpolation sequences are strengthened or extended by the localand global strengthening procedures until a counterexample is found or either interpolation sequence reaches a fix point.
our approach is different from dar in several aspects.
we list the differences as follows our approach handles program statements compositionally while the dar approach similar to itp considersthe global transition relation.
what dar maintains are sequences of abstractions inter polants .
once each interpolation sequence is changed orextended some subsequent process has to be performedso that the properties mentioned above are still valid.what our approach maintains are concrete forward andbackward reachable states step by step whose validity isnot changed.
they can be accumulated for the followingiterations without any recalculations.
we have tried to obtain the dar tool on internet for evaluation but failed.
according to the experimental results reportedin the performance of dar and itp are evenly balanced.we are interested in implementing the dar approach byourselves in the future for evaluation.
vii.
c onclusion and future work in this work we propose an novel approach to automatically constructing inductive loop invariants which solvesthe fundamental problem in program analysis and verification.
our approach squeezes an inductive invariant based on craig interpolants between forward and backward predicate trans formers.
in the future we would like to investigate the qualityof interpolants.
a cknowledgment this research is mainly supported by the startup grant m4081588.
.
of school of computer science andengineering in nanyang technological university and parti ally supported by the national research foundation primeministers office singapore under its national cybersecurityr d program award no.
nrf2014ncr ncr001 andadministered by the national cybersecurity r d directorate.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.