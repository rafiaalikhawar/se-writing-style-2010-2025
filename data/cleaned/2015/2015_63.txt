jens knoop uwe zdun hrsg.
software engineering lecture notes in informatics lni gesellschaft f ur informatik bonn hidden truths in dead softwar epaths michael eichberg1ben hermann2mira mezini3and leonid glanz4 abstract approaches and techniques for statically finding amultitude of issues in source code havebeen de veloped in the past.
acore property of these approaches is that the yare usually targeted towards finding only avery specific kind of issue and that the effort to de velop such an analysis is significant.
this strictly limits the number of kinds of issues that can be detected.
in this paper w ed iscuss ageneric approach based on the detection of infeasible paths in code that can disco veraw ide range of code smells ranging from useless code that hinders comprehension to real bugs.
the issues are identified by computing the difference between the control flo wgraph that contains all technically possible edges and the corresponding graph recorded while performing amore precise analysis using abstract interpretation.
the approach wasevaluated using the ja vadevelopment kit as well as the qualitas corpus a collection of over100 ja vaapplications and enabled us to find thousands of issues.
1o verview since the 1970s man yapproaches ha vebeen de veloped that use static analyses to identifyamultitude of different types of issues in source code .
the techniques used by these approaches range from pattern matching to using formal methods and vary widely w.r.t.
their precision and scalability .but the yhave in common that each one only targets avery specific kind of issues.
those tools e.g.
findbugs that can identify issues across awide r range of issues are typically just suits of relati vely independent analyses.
in all cases the issues that can be found are limited to those that are identified by some tool de veloper.
wepresent ageneric approach that detects control and data flo wdependent issues in javabytecode without targeting an yspecific kind of issues per se.
the approach applies abstract interpretation based techniques to analyze the code and while so records the paths that are taken.
afterwards the analysis compares the recorded paths with the set of all paths that could be taken according to an a vecontrol flo wanalysis that does not consider an ydata flows.
the paths computed by the latter analysis butnot found in the former graph are then reported along with ajustification wh ytheywere not taken.
the rationale underlying this approach is that man yissues such as null dereferences or array inde xout of bounds accesses lead to executions that lea veinfeasible paths behind.
1technische uni versit at darmstadt fachbereich informatik fachgebiet softwaretechnik hochschulstra e darmstadt eichberg cs.tu darmstadt.de 2hermann cs.tu darmstadt.de 3mezini cs.tu darmstadt.de 4glanz cs.tu darmstadt.de64 michael eichber ge ta l. hence the hypothesis underlying the approach is threefold.
first in well written code every path between an instruction and all it sdirect successors is eventually taken and second apath that will ne verb et aken indicates an issue.
third alarge class of rele vant issues manifests itself sooner or later in infeasible paths.
though we opted for analyzing the code as precisely as possible we deliberately limited the scope of the analysis to mak ei ts calable.
westart with each method of aproject and then perform acontext sensiti veanalysis with avery small maximum call chain size.
this makes the analysis unsound i.e.
we may miss certain issues but it enables us to use it for large industrial sized libraries and applications.
tovalidate our approach we analyzed the ja vadevelopment kit jdk .
.
and also the applications of the qualitas corpus .
the issues that we found range from seemingly benign issues to serious bugs that will lead to exceptions at runtime or to dead features.
howe ver even at first sight benign issues such as unnecessary checks that test what is already guaranteed can ha ve e.g.
an impact in code reviews such code generally hinders comprehension.
2c onclusion the proposed approach is based on the idea that infeasible paths in software are agood indication of code issues and that alarge class of rele vant issues manifest themself sooner or later in infeasible paths.
the implementation relies on anewstatic analysis technique thatexploits abstract interpretation and is parametrized overabstract domains as well as the depth of call chains to follo winter procedurally .this enables us to mak einformed reasonable trade offs between scalability and soundness.
the validity of the claims is evaluated by acase study of industrial size software the issues re vealed during the case study constitute themselves avaluable contribution of the paper and are publicly available.