exploring and exploiting the correlations between bug inducing and bug fixing commits ming wen the hong kong university of science and technology hkust hong kong china mwenaa cse .ust.hkrongxin wu department of cyber space security xiamen university xiamen china wurongxin xmu .edu .cnyepang liu shenzhen key laboratory of computational intelligence sustech shenzhen china liuyp1 sustech .edu .cn yongqiang tian hkust hong kong china ytianas cse .ust.hkxuan xie sun yat sen university china xiex27 mail2 .sysu .edu .cnshing chi cheung hkust hong kong china scc cse .ust.hk zhendong su eth zurich switzerland zhendong .su inf .ethz .ch abstract bug inducing commits provide important information to understand when and how bugs were introduced.
therefore they have been extensively investigated by existing studies and frequently leveraged to facilitate bug fixings in industrial practices.
due to the importance of bug inducing commits in software debugging we are motivated to conduct the first systematic empirical study to explore the correlations between bug inducing and bug fixing commits in terms of code elements and modifications.
to facilitate the study we collected the inducing and fixing commits for bugs from seven large open source projects.
the empirical findings reveal important and significant correlations between a bug s inducing and fixing commits.
we further exploit the usefulness of such correlation findings from two aspects.
first they explain why the szz algorithm the most widely adopted approach to collecting bug inducing commits is imprecise.
in view of szz s imprecision we revisited the findings of previous studies based on szz and found that out of previous findings are significantly affected by szz s imprecision.
second they shed lights on the design of automated debugging techniques.
for demonstration we designed approaches that exploit the correlations with respect to statements and change actions.
our experiments on defects4j show that our approaches can boost the performance of fault localization significantly and also advance existing apr techniques.
this work was conducted when the first author was a visiting student at sustech southern university of science and technology .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august tallinn estonia association for computing machinery.
acm isbn .
.
.
.
.org .
.3338962ccs concepts software and its engineering maintaining software empirical software validation software evolution .
keywords empirical study bug inducing commits fault localization and repair acm reference format ming wen rongxin wu yepang liu yongqiang tian xuan xie shing chi cheung and zhendong su.
.
exploring and exploiting the correlations between bug inducing and bug fixing commits.
in proceedings of the 27th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august tallinn estonia.
acm new york ny usa pages.
.org .
.
introduction software evolves by means of code changes committed to fix bugs introduce new features refactor existing code and so on.
such committed code changes however can also induce new bugs .
commits that induce software bugs are known as bug inducing commits which embed important information about when and how bugs are introduced.
due to the importance of bug inducing commits they have been extensively studied by researchers.
for example various studies have been conducted to understand the characteristics of bug inducing commits e.g.
predict buggy prone commits during software evolutions e.g.
and locate bug inducing commits e.g.
and so on.
bug inducing commits are also leveraged to ease debugging in industrial practices.
particularly we observe that developers from open source projects often look for the information of bug inducing commits when devising the fixing patches of a bug see section for more details .
exploring the correlations between bug inducing commits and bug fixing commits is important.
the reasons are two fold.
first existing studies mostly leveraged the szz algorithm and its variants to infer bug inducing commits based on bug fixing commits with an implicit assumption that bug inducing and bug fixing commits 326esec fse august tallinn estonia ming wen rongxin wu yepang liu yongqiang tian xuan xie shing chi cheung and zhendong su are highly correlated in the code hunks e.g.
modifying the same code elements .
to ease presentation we refer to these approaches as szz and the implicit assumption as szz assumption .
while the szz assumption plays a critical role in previous studies it has not been systematically validated in practice.
unexamined assumptions can result in questionable research claims and wasted research effort .
second although bug inducing commits provide contextual clues for debugging in practice see section the way to leverage them effectively for debugging is not well studied.
understanding the correlations between bug inducing and bug fixing commits is a fundamental step towards this target enabling us to design better automatic debugging techniques.
although several existing studies have explored certain correlations between a bug s inducing commits and fixing commits their findings mainly focused on the metadata e.g.
the authorship of a commit or the metrics of commits e.g.
the complexity of the committed code hunks .
unfortunately these findings are insufficient to answer the questions on the validity of the szz assumption and provide few guidance on the applications of buginducing commits in bug fixing.
therefore in this work we propose to study the correlations between bug inducing and bug fixing commits in terms of code elements and modifications.
specifically we investigate the following research question rq1 do bug inducing commits and bug fixing commits modify the same code elements e.g.
source files statements and do they involve similar change actions?
here change actions refer to the code modifications made to a program such as inserting an ifstatement .
inferring change actions a.k.a.
mutation operators is an important step in designing automated program repair apr techniques .
to answer rq1 we created a benchmark dataset containing the information of bug inducing commits and the associated bugfixing commits.
specifically we analyzed substantial bug reports from large open source projects and manually recovered the links between the inducing and fixing commits for hundreds of bugs.
studying rq1 offers benefits in two aspects.
first as above mentioned many existing studies e.g.
leveraged szz to collect bug inducing commits.
unfortunately recent studies have pointed out that szz suffers from a low precision .
however neither of these studies explained why szz is imprecise nor investigated the effect of such imprecision on the findings of existing studies because szz s underlying assumption has not been systematically validated.
the answers to rq1 together with our benchmark enable us to validate the szz assumption and further answer the following question.
rq2 what are the major causes for the imprecision in szz?
does such imprecision result in a significant bias in the findings made by previous studies?
second the answers to rq1 can shed lights on the design of better automated debugging techniques.
for instance if the statements modified by a bug s fixing commits and inducing commits are correlated we can leverage a bug s inducing commits to better infer the program locations that need to be modified to fix faults fault localization or fl in abbreviation .
if the change actions performed to fix a bug are correlated with those actions that introduced the bug we can better infer the required mutation operators when devisingautomated program repair tools.
to investigate the feasibility of these ideas we further study the third research question rq3 can bug inducing commits and our findings be leveraged to advance existing automated debugging techniques?
to answer rq3 we recovered the bug inducing commits of bugs in defects4j via bisect testing on version histories following the strategy adopted by an existing study .
driven by the answers of rq1 we devise novel debugging approaches incorporating the information of bug inducing commits and compare them with the state of the art techniques.
via studying the three rqs we obtained several major findings software bugs can be fixed in a source file but introduced in another due to different reasons such as faulty configurations incomplete changes and so on section .
.
.
around .
of the statements modified by the bug fixing commits were also modified by the associated bug inducing commits and the ratio can be enhanced to .
if data flow and control flow analyses are performed section .
.
.
the majority of the change actions that are required to fix bugs can be inferred via reverting those change actions made in the corresponding bug inducing commits section .
.
.
previous findings have been significantly affected by the biased bug inducing commits identified by szz.
specifically significant differences and non negligible effect sizes have been observed for out of previous findings section .
the information of bug inducing commits can boost the performance of automated debugging techniques significantly.
based on the evaluations on defects4j we found that our fl approach can significantly outperform existing ones around improvement in terms of map and mrr section .
this paper s contributions and organization are as follows we created a benchmark dataset containing the bug inducing and bug fixing commits for bugs from seven large opensource projects.
the dataset is publicly available and can facilitate future research section .
we conducted empirical studies based on the collected dataset.
the results reveal significant correlations between a bug s inducing and fixing commits section .
we analyzed szz and revisited previous findings based on bug inducing commits identified by szz section .
we devised approaches exploiting the correlations revealed by our studies and evaluated them on defects4j .
results show that these approaches are promising to advance existing automated debugging techniques section .
dataset construction .
data collection characterizing and understanding the correlations between buginducing commits and bug fixing commits require a vast collection of these commits for real bugs.
however the information of a bug s inducing commits is rarely available and there is no large dataset in public.
b hme et al.
identified the bug inducing commits via software testing for only bugs from four subsystems make grep findutils andcoreutils of gnu project.
due to the requirement of bug revealing tests their approach to collecting bug inducing commits is difficult to generalize since bug revealing 327exploring and exploiting the correlations between bug inducing and bug fixing commits esec fse august tallinn estonia table the benchmark dataset collected in this study project description stars files kloc changes major critical blocker minor trivial bugs bic bfc accumulo data storage and retrieval ambari system administrators for hadoop lucene text search engine library hadoop distributed system jackrabbit content repository management oozie web services for hadoop corebench projects from gnu operating system summary bfc denotes the number of bug fixing commits bic denotes the number of bug inducing commits means the data is not available tests are rarely provided in bug reports.
an alternative is to collect bug inducing commits that are flagged by domain experts i.e.
the corresponding developers as pointed out by a recent study .
fortunately we found that many developers of large open source projects e.g.
those from the apache ecosystem often leave the messages of their debugging activities in bug reports and those messages might contain the information of bug inducing commits.
we show two examples of such messages as follows i m fairly certain this is caused by the enhancements made in solr to add sorting functions this is an unintended bug introduced by commit bc56c03 we also observed that developers often conduct software testing to find the bug inducing commits.
the test passes before this commit lucene and fails after such information provided by the domain experts enables us to identify the bug inducing commits precisely for software bugs and thereby to create a ground truth dataset.
in this study we adopted the following three steps to build our dataset.
in the first step we analyzed bugs associated reports and collected those candidates of bugs that potentially contain the information of bug inducing commits.
specifically we collected a bug as a candidate if it satisfies one of the following two conditions.
first we checked whether a bug s report has the specific attribute which indicates that other issues introduced this bug.
for example jira records such information in the field of is broken by under the category of issue links .
second we examined the description and comments of the bug reports via keyword searching.
specifically we used the following regular expression started with caused by introduced by commit .
?
r w project d by manually checking a portion of bug reports that are sampled randomly we observed that developers from apache often used keywords started with caused by commits and introduced by to deliver the information of bug inducing commits.
expression r w matches the hash id of a commit directly.
expression project d matches an issue id where project refers to the concerned project.
for example lucene is an issue id for the project lucene.
a bug is collected as a candidate if its descriptions or comments match the regular expression.
in the second step we manually examined all the candidates to ensure the data quality.
we found that the candidates such identified in the first step might contain noises.
for instance a matched comment the problem is caused by stack overflow in solr might be a noise and thus has been filtered out.
this is because we were unsure whether the bug was caused by the commits to fix solr or it was just caused by the same stack overflow problem similar to issue solr .
similar candidates were filteredout.
two phd students were involved in the manual checking.
a candidate bug was discarded if any one of them was unsure that the matched texts indeed deliver the information of the commits that introduced the bug.
in the third step we built the links between bugs and the associated bug fixing commits following the practices adopted by existing studies .
this step served two purposes.
first we used these links to identify the bug fixing commits for all the collected bugs.
second since some bug reports may contain indirect information of the bug inducing commits i.e.
a pointer to another issue whose fixing commits introduced this bug we resolved such indirect information using the built links.
therefore we built the links between issues and commits by matching the issue id in the commits log messages.
a candidate was discarded if such links cannot be recovered via referring to the unified format project issue as mentioned before.
even if the link can be successfully recovered the identified bug fixing commits might still contain noises since the tangling issue of commits is prevalent as revealed by existing studies .
for such cases the code changes made in the fixing commits might not all be related to the bug and such noises will prevent us from understanding the correlations between the inducing and fixing commits of a bug correctly.
therefore we further manually checked each fixing commit via investigating its log messages to see if it serves for multiple purposes a.k.a.
non atomic besides fixing the bug.
for instance commit 4f9c470 of lucene serves to fix multiple issues i.e.
lucene andlucene .
commit 5e0f6a4 of accumulo serves seven agendas as indicated by its log messages.
candidates with non atomic bug fixing commits have been discarded to control the data quality of our empirical study.
rigorous strategies have been adopted in these three steps to collect the information of bug inducing and bug fixing commits.
the reason is that our goal in this study is to collect a bug s inducing and fixing commits with high confidence to avoid bias in our empirical studies.
we did not intend to collect the bug inducing commits for all bugs in this study.
in total we analyzed all the bug reports from six popular large open source projects i.e.
hadoop lucene ambari jackrabbit accumulo and oozie and successfully identified the bug inducing commits for bugs.
we also analyzed the bug reports for other large scale open source projects such as spark struts and tomcat.
however the number of bug inducing commits successfully identified after manually checking was less than for each project.
this falls short of the minimum of instances for the statistically significance tests in our subsequent empirical studies.
therefore we did not include those projects in this study.
note that our collected bugs contain but are not limited to regression bugs.
for example bug solr is not a regression 328esec fse august tallinn estonia ming wen rongxin wu yepang liu yongqiang tian xuan xie shing chi cheung and zhendong su bug which is introduced by code changes made to add new features .
we also included the benchmark dataset collected by b hme et al.
which contains the information of bug fixing and bug inducing commits for bugs from the gnu project.
the descriptions of the selected seven projects including bugs in total are listed in table .
these projects are popular i.e.
with over stars in github and large scale i.e.
over source files and over commits .
our collected dataset is publicly available1.
note that there might be multiple bug inducing commits for a bug.
for example there are in total bug inducing commits for the bugs of project hadoop.
previous studies have also revealed that a bug might be jointly introduced by multiple changes .
.
threats to validity collection of bug inducing commits the major threat of this study comes from the dataset used in our empirical analysis.
that is whether the bug inducing commits identified as oracles truly introduced the corresponding bugs and whether all the bug inducing commits have been identified for a bug.
we addressed this threat from two aspects.
first we collected the data of bug inducing commits based on the knowledge from domain experts i.e.
the developers assigned to the bug .
this data collection methodology has been suggested by a recent study .
besides each candidate was manually checked involving two graduate students and potential noises have been filtered out following strict rules.
second we also included a benchmark dataset i.e.
corebench in our empirical study.
the bug inducing commits in corebench were collected via software testing and thus were validated to be real bug inducing commits.
more importantly the empirical analysis results derived from our collected dataset are consistent with those derived from corebench see section and .
the consistency confirms the high quality of our collected dataset.
missing links of bug fixes the links between bugs and the corresponding fixing commits need to be recovered in this study.
the bias of such links have been pointed out and systematically evaluated by an earlier study .
to mitigate such threat we chose those projects that are well maintained and whose bug tracking systems are maintained by jira.
for these projects developers often leave the issue id following a unified format e.g.
project issue in the log messages of a commit for the issues that it has resolved .
those bugs without such links are excluded from our study.
empirical investigation in this section we investigate the correlations between bug fixing commits and the bug inducing commits at the code level.
specifically we aim at answering the following two research questions rq1 a do bug fixing commits modify the source files and statements that are modified by bug inducing commits?
inferring the code elements e.g.
source files and statements that are required to be modified in order to fix a bug is critical in debugging especially for fault localization andautomated program repair .
existing studies often infer such code elements based on the information of a program s current version such as the test coverage information collected via executing the test suite against the current program.
as mentioned 1data available at in section developers often identify the information of buginducing commits during debugging.
such practice provides a new direction for debugging in terms of version histories other than a program s current version.
therefore in this rq we investigate the correlation between bug fixing commits and bug inducing commits in terms of the modified source files and statements.
rq1 b do bug fixing commits perform similar change actions compared with those by the bug inducing commits?
inferring the change actions i.e.
mutation operators that are needed to fix a bug is critical in designing automated program repair techniques .
a change action is represented as a pair of operation node .
there are four kinds of operation which are change add delete andmove .
the node represents the type of the changed ast node.
we keep all but those types referring to non source code changes e.g.
modification of javadoc .
in total out of distinct node types defined by jdt are kept.
the strategy widely adopted by existing studies to infer frequent change actions is to learn from substantial real bug fixes collected from open source projects .
in this rq we investigate whether such change actions can be directly inferred from a bug s inducing commits.
to ease our explanation let bdenote a bug collected in our dataset fbdenote the set of the corresponding bug fixing commits andibdenote the set of the corresponding bug inducing commits.
.
methodology and measurement measuring file coverage to answer rq1 a in terms of source files we investigate how many source files that are modified by the bug fixing commits are modified by the associated bug inducing commits.
specifically suppose sfbdenotes all the source files modified by the bug b s fixing commits fb and sibdenotes those by b s inducing commits.
we measure the file coverage as follows file co vera e b sib sfb sfb measuring statement coverage to answer rq1 a in terms of statements we investigate how many statements that are modified by the bug fixing commits are introduced by or evolved from the associated bug inducing commits.
however the real bug inducing commits ibmight be checked in a long time before the bug fixing commits fb and thus the lines of source code might be misaligned between ibandfb.
for example a statement at line modified by ibmight be evolved to line in fb.
therefore directly checking the overlap of changed statements between ibandfbis inappropriate.
we adopt the following strategy to resolve this challenge which maps the code modified in the bug inducing commits to the one in the version before the bug fixing commits are submitted.
for each bug inducing commit ib ib suppose libis the set of all its modified statements we track the evolution history of these statements from ibto each bug fixing commit fb fbto see if these statements can be mapped to the statements modified by any of the bug fixing commits.
let us further suppose the version history is v1 ... vj vj ... vn where v1is the version after bug inducing commit ibandvnis the version before the fixing commit fb.
for each pair of two consecutive versions vj vj we use the function mj7 j s to retrieve the statement in vj that is mapped from the statement sinvj.
to find the optimum mappings ofmj7 j s we follow an existing work of history slicing and approach it as the problem of finding the minimum 329exploring and exploiting the correlations between bug inducing and bug fixing commits esec fse august tallinn estonia matching of a weighted bipartite graph.
the weight between any two statements is computed as their levenshtein edit distance .
our ultimate goal is to obtain m17 n s which finds the statement invnthat is traced from the statement sinv1.
using the function mj7 j s for each two consecutive versions we can gradually calculatem17 n s mn n m n n ... m s .
note that not all statements in v1can be mapped to vnsince some statements might be deleted during evolution and the mapping function will return null for such cases.
using the function m17 n we can successfully map the modified statements by the bug inducing commit to statements in the version before the bug fixing commit is made.
we then examine whether the mapped statements in vn have been further modified by the subsequent bug fixing commits.
for a bug b we use lfbto denote all the modified statements byfb and libto denote all the statements introduced by ib.
we useli fbto denote those statements mapped from the bug inducing commits to the bug fixing commits.
specifically li fb m n s s lib .
we then compare lfbwith li fbto see how much they overlap which is denoted and computed as follows.
statement co vera e b li fb lfb lfb for those overlapped statements we further examine whether these statements have been modified by any other commits.
the reason is that we want to understand whether the bug fixing statements are directly modified by those statements that introduced the bug.
specifically we compute the direct coverage ratio which is the ratio of the statements that are modified by the bug fixing commits and can be directly traced from the statements introduced in bug inducing commits as follows statement direct co vera e b ldcb lfb where ldcb s s li fb lfband s has not been modified by other commits between ibandfb .
measuring change action coverage to answer rq1 b we leverage gumtree to conduct change analysis for all commits in ibandfb.
for each commit we can obtain a set of change actions each of which is denoted as a pair operation node as mentioned before.
we use afbto denote all the change actions extracted from the bug b s fixing commits fb and aibto denote the change actions extracted from b s inducing commits.
we then measure the change action coverage as follows action co vera e b aib afb afb we also observe that a bug can be repaired via reverting the actions performed in the bug inducing commits .
for instance if the inducing commits inserted a statement the action performed to fix the bug might be deleting the statement.
therefore it motivates us to investigate whether the change actions performed in the bug fixing commits can be covered by the inverse change actions applied in the inducing commits.
in particular the inverse of insert node is delete node and the inverse of delete node is insert node accordingly.
as for operations of update and move the inverse actions are themselves.
here suppose the inverse actions of aibis denoted as iaib.
we then measure the inverse coverage of change actions as follows action in verse co vera e b iaib afb afb .
empirical results .
.
rq1 a file and statement coverage.
figure shows the results of file coverage for the seven subjects.
on average .
.
.
.
.
accumuloambariooziehadoopjcrlucenecorebenchaveragefigure file coverage between bug fixing and buginducing commits of the source files modified to fix bugs have also been modified by the associated bug inducing commits ranging from .
to81.
across different projects .
this result suggests that the majority of bugs are fixed in the same source files where they are introduced.
however a non negligible proportion of bugs still can be fixed in a source file but introduced in another.
we further investigated those .
of the cases to see why bugs are fixed and induced in different files and made the following observations.
configuration log related .
one reason that a bug s inducing and fixing commits modify different source files is that this bug relates to configurations or logging statements an example of which is shown in figure .
in this example the bug s inducing commit modified the functionalities in source file nativemap.java .
in the bug fixing commits the configuration related source file configurablemacbase.java was modified to change settings related to nativemap .
since the configuration related source files usually configure the settings of functionalities implemented in other source files the inducing and fixing commits of a configuration related bug might modify different source files.
this accounts for17.
of the cases.
incomplete changes .
another important cause is related to incomplete changes in which case developers made required changes with respect to fix bugs add features and etc.
but forgot to perform similar necessary changes elsewhere.
figure shows an example of such case.
the bug inducing commit modified source fileauthurlclient.java which changed the encoding format toutf .
however it forgot to perform similar changes in source filedummylogstreamingservlet.java .
the bug fixing commit fixed this issue via changing the decoding format to utf .
the case of incomplete changes will be more prevalent if a system contains multiple modules since there might be similar functionalities implemented in different modules.
an update in one module often requires an update accordingly to similar functionalities in other modules e.g.
see example of accumulo .
for the rest of the cases i.e.
.
no unified patterns can be observed.
however for the majority of them i.e.
.
accounting for50.
with respect to the total number the source files modified by a bug s fixing and inducing commit are directly dependent even though they are different.
for such cases the classes where the bug was fixed have directly used those classes where the bug reside e.g.
superclass and subclass imported classes and etc.
.
based on the above results we can distill the following finding cfg.setproperty property.tserv nativemap enabled true .tostring 659a33e8e ... tserver nativemap .java 4cffe0290 ... functional configurablemacbase.java stu vwxtyzwu z stu z zwu z string accumulonativelibdirs system.getproperty native .lib.path figure bug inducing and fixing commit of accumulo 330esec fse august tallinn estonia ming wen rongxin wu yepang liu yongqiang tian xuan xie shing chi cheung and zhendong su lastquerystring request .getquerystring lastquerystring urldecoder.decode request .getquerystring utf stringbuilder .append value stringbuilder.append urlencoder.encode value utf 10549ef2 ... util authurlclient.java b5524c90 ... service dummylogstreamingservlet.java uvw xyzv uvw a b yw figure bug inducing and fixing commit of oozie finding .
the majority of bugs .
are fixed in the same source files as where they were introduced.
however bugs can be fixed in a source file but introduced in another due to faulty configurations incomplete changes and so on.
the majority of source files modified by a bug s fixing and inducing commit have directly class dependency even though they are different.
figure shows the results in terms of statement coverage.
for .
of the statements modified by the bug fixing commits on average ranging from .
to68.
across different projects they were also modified by the associated bug inducing commits.
the direct coverage is .
on average ranging from .
to .
for different projects .
these results indicate that for .
.
.
.
of the statements modified by both the buginducing and bug fixing commits they were also modified by other irrelevant commits in between.
we further investigate whether the coverage can be enhanced if those statements affected by buginducing statements are considered.
specifically we conducted dataflow and control flow analysis to slice those dependent statements based on li fb and then augment li fbwith those sliced statements.
statement coverage is then recomputed based on equation and the results are shown in figure displayed as coverage flow .
the coverage considering data flow and control flow reaches .
on average which has been improved by .
compared with the original coverage.
two major reasons attribute to the incomplete coverage of statements.
first the source files are not covered for a portion of bugs.
as a result the modified statements cannot be covered.
second we only conducted intra procedural analysis to identify data and control dependent statements.
however the statements modified to fix the bugs might reside outside of the function where those bug inducing statements are modified e.g.
in javadoc other dependent functions or source files .
for example bughadoop was introduced by modifications to function skipfully .
the bug was fixed via updating statements of the associated javadoc .
such statements cannot be retrieved by intraprocedural data flow or control flow analysis.
based on the these results we can distill the following finding finding .
for the statements modified by bug fixing commits .
of them can be traced from the statements introduced by the corresponding bug inducing commits on average.
such coverage can be improved to .
if we consider those statements affected by i.e.
control or data dependent on bug inducing statements.
finding and finding shed lights on understanding why the szz algorithm is imprecise see section .
these findings also provide valuable guidance to advance existing automated fl techniques.
for example for fl at the source file level we might need to refer to those source files that implement similar functionalities relate to configurations or those have direct class dependencies.
for fl at the statement level we can infer the fixing statements .
.
.
.
.
.00accumuloambariooziehadoopjcrlucenecorebenchcoveragedirect coveragecoverage flowfigure statement coverage with flow analysis and direct coverage between bug inducing and fixing commits largely from bug inducing commits and more statements can be inferred if we consider data or control dependencies.
.
.
rq2 b change action coverage.
figure shows the coverage and inverse coverage of change actions between a bug s inducing and fixing commits.
the coverage ranges from .
to70.
over different projects with an average value of .
.
the inverse coverage of change actions ranges from .
to73.
with an average value of .
.
these results indicate that around .
of the change actions performed in the fixing commits can be inferred from the associated inducing commits and that value is higher if we infer from bug inducing commits inverse change actions.
we further investigated the coverage and inverse coverage for each type of change action and figure shows the results of the top frequently observed change actions averaged over the seven projects.
we can see that for certain change actions i.e.
those displayed at the leftmost in figure the inverse coverages are higher than the direct coverage.
this indicates that these change actions are more likely to be inferred by reverting the change actions observed in the bug inducing commits.
examples of such change actions are insert prefix expression and insert array type .
on the contrary for some other change actions i.e.
those displayed at the rightmost in figure the direct coverage is higher than the inverse coverage.
examples of such change actions are insert initializer and insert character literal .
based on the above results we can distill the following finding finding .
around .
of the change actions used to fix bugs can be inferred from change actions that introduced the bug and .
of them can be inferred via reverting the change actions performed in bug inducing commits.
besides some change actions performed in bug inducing commits are more likely to be directly applied to fix bugs while some others are more likely to be reverted.
.
.
.
.
.
accumulo ambari oozie hadoop jcr lucene corebenchcoverage figure change action coverage between bug fixing and bug inducing commits.
the green bar denotes coverage and the white bar denotes inverse coverage .
.
.
.
100coverage inversecoverageordered by the value inversecoverage coverage figure coverage and inverse coverage of change actions 331exploring and exploiting the correlations between bug inducing and bug fixing commits esec fse august tallinn estonia lastquerystring request.getquerystring lastquerystring urldecoder.decode request.getquerystring utf 39b5524c90 jan 2015git blame 128d7d20 aug 2013commitsidentified by szz b5524c90 jan 10549ef2 jan 2015real bug inducing commitsintroduced the source file... service dummylogstreamingservlet.java figure identifying the bug inducing commits of oozie by szz implications on earlier findings in this section we discuss the implications of our empirical findings on existing studies.
plenty of research studies have been proposed to characterize and learn useful knowledge based on bug inducing commits e.g.
since it helps understand how bugs were introduced and thus subsequently how to repair them.
collecting bug inducing commits is the foundation of the aforementioned studies.
the current widely adopted approach to collecting buginducing commits is szz or its variants .
unfortunately recent studies have pointed out that szz suffers from the limitation of being imprecise.
however these two studies have neither explained why szz is imprecise nor investigated the effect of such imprecision on previous studies.
motivated by this we aim at answering the following research questions rq2 a can our findings explain why szz is imprecise?
rq2 b will our findings affect previous studies which characterize bugs based on bug inducing commits?
.
implications on the szz algorithm the szz algorithm generally blames the statements modified by the bug fixing commits and assumes the latest commit that modified those statements introduced the bug.
for the previous example displayed in figure szz will blame statement modified in b5524c90 and assume 128d7d20 is bug inducing since it last modified this statement as shown in figure .
however the commit 128d7d20 is the one that introduced source file dummylogstream ingservlet.java years ago which is not the one that introduced the bug.
the real bug inducing commit 10549ef2 is made only several days before the bug was fixed.
this example demonstrates the limitation of szz which motivates us the systematically evaluate the performance of szz.
specifically we apply szz based onfbfor each bug as shown in table and denote the results as iszz b. we then compared iszz bwith ibto evaluate the performance of szz and found that szz can retrieve .
ranging from .
to78.
for different projects of the bug inducing commits recall while .
ranging from .
to72.
of the identified bug inducing commits are not the real ones for the corresponding bug precision .
note that there are five variants of szz as summarized by a recent study and our results are based on ag szz since it achieves the optimum performance in terms off measure .
besides it was used by most of the earlier studies e.g.
.
to explain such imprecision of szz we investigated its working mechanisms and found that szz is actually subject to the following two implicit assumptions assumption .the lines of code which are modified by the commits with respect to fixing a bug are the same as or evolved from the lines of code that are modified by the bug inducing commits.
assumption .for each line that is modified by the commits with respect to fixing a bug the commit that last modified the line introduced this bug.if any of the two assumptions is invalid szz cannot identify the bug inducing commits correctly via blaming the statements modified by the bug fixing commits as shown by the example displayed in figure .
indicated by file coverage andstatement coverage we can see that .
of the source files modified by the bug fixing commits have not been modified by the associated bug inducing commits on average and that ratio is .
at the statement level.
therefore the first assumption is not hold for a non negligible portion of cases.
for such cases the bug inducing commits cannot be correctly identified if we only blame the modified statements in the bug fixing commits.
this explains the low recall of szz.
as suggested by finding we can refer to those statements that are data orcontrol dependent and those source files that are directly dependent to improve the recall.
indicated by direct statement coverage we can see that for those statements modified by the bug fixing commits and also modified by the bug inducing commits previously a non negligible portion of them i.e.
.
were last modified by other irrelevant commits instead of bug inducing commits.
therefore the validity of the second assumption is seriously affected.
as a result if we pick the last commit that modified the fixing statements as bug inducing commits as adopted by the szz algorithm irrelevant commits might be identified as bug inducing commits.
this explains the low precision of szz.
based on these results we answer rq2 a via distilling the following finding finding .
current szz implementations can only identify around .
of the real bug inducing commits recall and .
of the commits identified by them are not the real ones precision .
the reason is that the implicit assumptions of the szz algorithm are violated by the insufficient file coverage andstatement direct coverage between bug inducing and bug fixing commits.
.
effects on previous findings plenty of researches have been conducted to understand the characteristics of software bugs based on bug inducing commits.
for example life span of software bugs has been investigated which is measured from the time when the bugs were introduced to the time when they were fixed.
existing studies rely on the szz algorithm to identify the bug inducing commits .
however such measurements can be biased if the bug inducing commits identified by szz are imprecise.
for instance in the example as shown in figure the life span is nearly two years if the commit 128d7d20 is identified as the bug inducing commit.
however the life span of this bug is only three days since it got fixed thjan soon after it was introduced thjan .
therefore we are motivated to propose rq2 b. to answer this question we revisited previous findings based on the real bug inducing commits ib i.e.
the oracle dataset and the ones identified by ag szz denoted as iszz b .
characteristics selection we choose the most representative findings involving bug inducing commits investigated by recent studies as shown in table .
in particular the developer s experience is measured by the number of prior commits submitted .
the time scatter is the gap of the time 332esec fse august tallinn estonia ming wen rongxin wu yepang liu yongqiang tian xuan xie shing chi cheung and zhendong su table bias and effect sizes of the findings based on bug inducing commits revealed by earlier studies id findingsaccumulo ambari lucene hadoop jcr oozie corebench p value effect p value effect p value effect p value effect p value effect p value effect p value effect 1lthe number of bug inducing commits per bug .
.
.
.
.
.
.
.
.
.
.
.
.
.
2lthe number of inducing source files per bug .
.
.
.
.
.
.
.
.
.
.
.
.
.
3uthe time of the bug inducing changes in terms of the hours .
.
.
.
.
.
.
.
.
.
.
.
.
.
4uthe time of the bug inducing changes in terms of the weekdays .
.
.
.
.
.
.
.
.
.
.
.
.
.
5gthe experiences of the developers who submitted the buggy commit .
.
.
.
.
.
.
.
.
.
.
.
.
.
6lthe life span of software bugs .
.
.
.
.
.
.
.
.
.
.
.
.
.
7lthe time scatter among bug inducing commits for a bug .
.
.
.
.
.
.
.
.
.
.
.
.
.
8lthe code churn of added lines of bug inducing commits .
.
.
.
.
.
.
.
.
.
.
.
.
.
9lthe code churn of deleted lines of bug inducing commits .
.
.
.
.
.
.
.
.
.
.
.
.
.
10lthe change entropy of the bug inducing commits .
.
.
.
.
.
.
.
.
.
.
.
.
.
value .
indicates the p value is less than .
.
emphasis on cohen s d indicates effect size large d .
medium .
d .
small .
d .
and negligible d .
bold values indicate the difference is significant p value .
.
superscript ldenotes the findings measured based on ibareless thansb gdenotes greater and udenotes unequal distribution between the earliest and latest bug inducing commits for a same bug .
the code churn measures the number of added or deleted lines of codes of a commit and the change entropy measures the distributions of the modified code across each file in a commit .
measurement we investigated those selected findings based on ibandiszz bseparately and then examined whether they are significantly different.
specifically we used the pearson s x2test applied to those characteristics with categorical values such as id and and mann whitney u test applied to characteristics other than id and since they are numerical values to test whether the differences are significant p value .
as well as the cohen s d effect size to test whether the effects caused by such differences are non negligible.
result table shows the statistical results.
among the findings no significant differences have been observed for two of them id and id and the differences for these two characteristics are mostly negligible with respect to effect size.
these two characteristics measure the time when bug inducing commits are more frequently submitted on friday and 00am .
for the other eight findings the differences are significant pvalue .
for most of the cases and most of the differences for the seven subjects are non negligible with respect to effect size.
compared with the oracle data ag szz labels a significantly larger number of bug inducing commits for each bug id .
as a result significantly more source files will be marked as bug inducing id .
this will hinder us correctly understand the percentage of buggy source files in a project and further affect prioritizing software maintenance efforts.
the experiences of developers who submitted the bug inducing commits measured by ibare significantly higher than those measured by sszz b id .
as such the earlier conclusion that junior developers are more likely to introduce bugs might be biased .
the life span of software bugs measured by sszz bis significantly longer than that measured by ib id and the effect sizes are all large for the seven projects.
this can introduce bias in understanding the long lived software bugs i.e.
those bugs whose life spans are longer than a year .
the practical impact of long lived bugs is significant since experiencing the same failure repetitively over a year can be particularly frustrating to end users.
however we observed that the proportion of long lived bugs measured in terms of the oracle data is .
while the one measured by ag szz is .
.
in other words using ag szz .
of the bugs are mistakenly regarded as long lived.
such biased dataset will further lead to the bias of long lived bugs characteristics investigated by the previous study .
for example oracleag szzcriticalmajorblockerminortrivialfigure comparison of the severities of long lived bugs as shown in figure over .
of the long lived bugs have high severity levels of major or critical measured based on ib while this ratio is only .
based on the results of ag szz.
the characteristics in terms of code churn andchange entropy are significantly affected with non negligible effects id and which will affect just in time quality assurance since these are frequently used metrics to build prediction models.
we answer rq2 b via distilling the following finding finding .
the biased dataset of bug inducing commits used in previous studies significantly affects their findings.
specifically significant differences p value .
and non negligible effect sizes have been observed for out of previous findings.
5implications on automated debugging as revealed in section developers in practice often look for buginducing commits to facilitate bug triaging and debugging.
however such information has never been leveraged in the design of automated debugging techniques.
therefore we are motivated to study the following research question in this section rq3 can bug inducing commits and our findings be leveraged to advance existing automated debugging techniques?
to facilitate this study we selected the defects4j benchmark since it has been widely adopted in fault localization and automated program repair researches e.g.
.
however the information of bug inducing commits for the bugs in defects4j is not available and cannot be found in the associated bug reports neither.
to identify bug inducing commits we conduct binary search which executes the bug revealing test cases provided bydefects4j on the complete version history automated by git bisect .
the first commit on which the bug revealing test cases start to fail is considered as the bug inducing commit.
this heuristic follows an existing study and the debugging practice observed in open source projects e.g.
see bug report of solr .
in total we have collected the bug inducing commits for out of the bugs in defects4j as shown in table .
.
implications on fault localization our finding indicates that the majority i.e.
.
of the bugfixing statements are evolved from or dependent on the bug inducing 333exploring and exploiting the correlations between bug inducing and bug fixing commits esec fse august tallinn estonia table subjects from the defects4j dataset subject recovered total kloc test kloc test cases commons lang jfree chart commons math joda time closure compiler total statements.
this observation suggests that it is possible to leverage such knowledge to advance existing spectrum based fault localization sbfl techniques .
current sbfl techniques typically leverage test coverage collected via executing test cases on the current version.
on the contrary bug inducing commits provide the information from another dimension in terms of version histories.
to investigate whether such information can boost the performance of sbfl we devise the following approach inspired by finding .
methodology the same as section .
for a bug b we use libto denote the statements introduced by the bug inducing commits andli fbto denote those statements on the buggy version that are evolved from lib.
we further conduct data flow and control flow analyses based on li fb and obtain a set of statements affected by them denoted as afi fb .
supposeadenotes the set of statements identified by sbfl with the suspiciousness score of sbfl s for each statement sina.
we adopt the approach specified in equation to compute the suspiciousness score of statements via exploiting the information of bug inducing commits.
our insight is intuitive.
if a statement identified by sbfl is evolved directly from the associated bug inducing commits we raise its suspiciousness score by .
.
if it is affected by those statements i.e.
control or data flow dependent evolved from the bug inducing commits we raise its suspiciousness score by .
.
otherwise we keep the original score as identified by sbfl.
be noted that the original scores denoted by sbfl s have been normalized to the range of before applying our strategy.
boost s sbf l s .0s a s li fb sbf l s .5s a s li fb s ali fb sbf l s otherwise we then use the boost model to rank all suspicious statements.
results pearson et al.
have evaluated multiple sbfl techniques on defects4j recently .
they provided the oracle i.e.
the buggy statements and the coverage spectrum for each bug.
therefore we leverage these publicly available data to generate the results of sbfl.
specifically we leverage the formula of ochiai since it has been reported to be the best formula for sbfl .
we leverage two well known metrics namely map and mrr to evaluate the performance of our boost model.
figure shows the results of the recovered bugs.
our boost model can achieve an average map of .324and mrr of .
these results are weighted averages over the bugs from five projects .
the improvement of .
.
.
.8mathlangcharttimeclosureaveragemap boostmap sbflmrr boostmrr sbfl figure comparing our boost model and sbfl !options.skipallpasses compilerinputprevious inputsbyid.put id input compilerinputprevious putcompilerinput id input a4c526da... jscomp compiler.java 0a670cb5... jscomp compiler.java buginducingcommit bugfixingcommit482482if options.dependencyoptions.needsmanagement if options.dependencyoptions.needsmanagement !options.skipallpasses options.closurepass if options.dependencyoptions.needsmanagement 12851284options.closurepass 1286figure bug inducing and fixing commit of closure map over the ochiai technique is .
on average ranging from .
to210.
.
the improvement for mrr is .
on average ranging from .
to390 .
.
these results are very promising which indicates that we can identify the root causes of bugs more precisely via leveraging the information of bug inducing commits than merely using sbfl.
however the statement coverage of bugfixing statements is still only around .
as indicated by finding .
in future we plan to design more sophisticated approaches such as considering dependent functions and classes as indicated by finding and finding to better locate bugs.
based on the above results we can distill the following finding finding .
the information of bug inducing commits can boost the performance of automated fl significantly.
specifically the map can be improved by .
and mrr by .
.
.
implications on automated program repair selecting appropriate change actions a.k.a.
mutation operators is critical in designing effective apr techniques .
our finding indicates that the majority i.e.
.
of the change actions that are performed to fix bugs can be inferred via reverting those change actions performed in the corresponding bug inducing commits.
this finding can guide the search of mutation operators in designing apr.
figure shows the bug fixing patch and the identified buginducing commit of bug closure from defects4j .
as we can see code element !options.skipallpasses at line is deleted to fix this bug and this code element was inserted at line by the corresponding bug inducing commit.
therefore we can simply revert partial of the bug inducing commit to fix this bug if the information of the bug inducing commit can be identified.
on the contrary this bug cannot be repaired by the state of theart apr techniques i.e.
capgen simfix elixir fixminer and ssfix as reported by .
this example also demonstrates the new challenges when leveraging bug inducing commits.
as shown in figure the bug inducing commit also introduced other change actions such as replacing the method name at line which is not required to be changed to fix the bug.
therefore new searching strategies are required to be devised to identify those change actions that are needed to be reverted among all the ones that are performed by the bug inducing commit.
to achieve such a goal we plan to further investigate the correlations between the change actions performed by the bug inducing commit and those performed by the bug fixing commit.
for instance we observe that change action delete expression statement in buginducing commits is significantly correlated with change action insert field declaration in bug fixing commits.
this suggests 334esec fse august tallinn estonia ming wen rongxin wu yepang liu yongqiang tian xuan xie shing chi cheung and zhendong su that if a bug is introduced via deleting an expression statement it is more likely to be fixed via inserting a field declaration .
we plan to leverage such correlations to design more sophisticated strategies to search appropriate mutation operators for apr in the future.
based on the above example we distill the following finding finding .
it is promising to leverage bug inducing commits in designing apr techniques.
as revealed by finding and finding it is highly recommended to consider the information of bug inducing commits which can be obtained automatically via testing on version histories when devising new automated fl and apr techniques.
related work many researches have been conducted involving bug inducing commits which can be broadly classified into the following categories characterizing bug inducing commits.
liwerski et al.
studied on which weekdays developers are more likely to submit bug inducing commits.
bernardi et al.
investigated over bugs from eclipse and mozilla and found that developers who are more likely to introduce bugs seldom communicate with other developers through analyzing developers social networks.
researchers are also interested in whether the experience of developers will affect their possibility of introducing software bugs .
eyolfson et al.
found that developers who make commits on a daily basis are less likely to introduce bugs which indicates that daily committing is a good developing practice.
the life span of software bugs has also been investigated .
for instance kim et al.
analyzed the duration between the check in time of the bug inducing commit and that of the bug fixing commit and found that the life span of bugs is usually to days.
based on this saha et al.
later investigated the characteristics of long lived bugs i.e.
those bugs whose life spans are over a year .
bavota et al.
investigated when a refactoring code change will induce a bug.
recently asaduzzaman et al.
also investigated the characteristics of bug inducing commits for android systems.
just in time quality assurance.
based on the characteristics of bug inducing commits many existing studies propose to predict whether a commit will introduce bugs at check in time.
such a process is known as just in time quality assurance .
it enables developers to timely identify the introduced bugs if any and prevents these bugs from spreading.
aversano et al.
proposed to learn from bug inducing commits to prevent error prone code.
specifically they used a weighted term vector to represent a commit where each term is extracted by considering a sequence of alphanumeric characters separated by non alphanumeric characters.
machine learning algorithms e.g.
knn and svm are then leveraged to predict whether a commit is error prone.
kim et al.
also proposed to predict whether a commit is bug inducing .
instead of extracting features from the tokens of a commit they proposed to extract features from the log message file names and the complexities of the changes made in the commit.
kamei et al.
later conducted a large scale empirical study of just in time quality assurance.
they extracted the following five categories of features from each commit the diffusion of the commit the size of the commit the intention of the commit the history of the files modified in the commit and the experience of the developer who committedthe changes.
more recently yang et al.
leveraged deep learning techniques to predict whether a commit is error prone.
in addition to the techniques for single projects cross project just in time quality assurance has also been investigated by a recent study .
debugging involving bug inducing commits.
wen et al.
proposed a fault localization technique which leverages information retrieval methods to locate bug inducing commits based on bug reports.
wu et al.
conducted an empirical study to understand the characteristics of the inducing commits for crashes and then proposed an approach to locating crash inducing commits automatically based on crash reports.
tan et al.
derived a set of code transformations obtained from the bug inducing commits for real regressions via manual inspection and proposed relifix to repair regression bugs.
the szz algorithm and its variants have been proposed to locate bug inducing commits based on the code changes made by the bug fixing commits.
however recent studies have pointed out that szz suffers from the problem of being imprecise .
for instance b hme et al.
found that for nearly one third of their studied bugs szz cannot identify any real bug inducing commits via blaming the statements modified by the bug fixing commits.
costa et al.
later proposed a framework to evaluate the results of szz.
they found that for .
of their studied bugs the bug inducing commits identified by szz are years apart from one another while it is unlikely that code changes committed years apart will induce the same bug .
unfortunately these two studies have neither explained why szz is imprecise nor investigated the effect of such imprecision.
our study bridges this gap.
conclusion in this study we collected the bug fixing commits and the associated bug inducing commits for bugs from seven large open source projects.
based on this dataset we conducted empirical studies to understand the correlations in terms of code elements and modifications between a bug s inducing and fixing commits.
the empirical findings explain why the szz algorithm the most widely adopted approach to collecting bug inducing commits is imprecise.
we also observed that most of the findings revealed by previous studies that leveraged szz are significantly affected by szz s imprecision.
furthermore by conducting experiments on defects4j we observed that leveraging the information of bug inducing commits can significantly boost the performance of existing automated fault localization and program repair techniques.
in this study the design of using bug inducing commits in fault localization and program repair shows its effectiveness but is still preliminary.
in the future we plan to devise more sophisticated approaches based on our empirical findings to further improve the performance of fault localization and automated program repair.