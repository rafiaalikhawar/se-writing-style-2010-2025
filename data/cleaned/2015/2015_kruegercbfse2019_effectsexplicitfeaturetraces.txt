effects ofexplicitfeaturetraceability on program comprehension jacobkr ger otto von guerickeuniversity magdeburg germany jkrueger ovgu.deg l al kl chalmers universityof gothenburg gothenburg sweden calikli chalmers.sethorsten berger chalmers universityof gothenburg gothenburg sweden bergert chalmers.se thomasleich harz university metop gmbh wernigerode magdeburg germany tleich hs harz.deguntersaake otto von guerickeuniversity magdeburg germany saake ovgu.de abstract developers spend a substantial amount of their time with program comprehension.
to improve their comprehension and refresh their memory developersneedtocommunicatewithotherdevelopers readthedocumentation andanalyzethesourcecode.manystudies show that developers focus primarily on the source code and thatsmall improvementscan have a strong impact.
assuch it is crucial to bring the code itself into a more comprehensible form.
a particulartechniqueforthispurposeareexplicitfeaturetracesto easily identify a program s functionalities.
to improve our empiricalunderstandingabouttheeffects offeaturetraces wereportan online experiment with professional software developers.
we studied the impact of explicit feature traces namely annotations and decomposition on program comprehension and compared them to the same code without traces.
besides this experiment we also asked our participants about their opinions in order to combine quantitative and qualitative data.
our results indicate that as opposedtopurelyobject orientedcode annotationscanhave positive effects on program comprehension decomposition can have a negative impact on bug localization and our participants perceive both techniques as beneficial.
moreover none of the three code versions yields significant improvements on task completiontime.overall ourresultsindicatethatlightweighttraceability suchasusingannotations providesimmediatebenefitsto developersduringsoftwaredevelopmentandmaintenancewithout extensivetrainingortooling andcanimprovecurrentindustrial practices that rely on heavyweight traceability tools e.g.
doors and retroactive fulfillment of standards e.g.
iso do 178b .
ccs concepts generalandreference empiricalstudies softwareandits engineering softwaredesign tradeoffs maintainingsoftware .
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse august 26 30 tallinn estonia copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
program comprehension feature traceability software maintenance separationofconcerns acmreference format jacobkr ger g l al kl thorstenberger thomasleich andguntersaake.
.effectsofexplicitfeaturetraceabilityonprogramcomprehension.in proceedingsofthe27thacmjointeuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec fse august 26 30 tallinn estonia.
acm new york ny usa 12pages.
introduction developersoftenneedtounderstandthepurposeandthedetailsof specific parts of a codebase which is a time consuming and cognitively demanding activity during software engineering .
a developerperformsthisactivity knownas program comprehension when they are new to a program or forgot details that are requiredfortheirtask .consequently togainimplicitknowledgeaboutaprogram developersneedtoreadandcomprehendthe code whichcanbefacilitatedbymentoringandbyexplanations from other developers.
however communicating knowledge in such a way requires considerable effort from other developers and interrupts theirownactivities.
totacklesuchproblems severaltechniqueshavebeenproposed to reverse engineer information or to improve program comprehension oftenuponempiricalstudies.contemporarytechniques comprise for instance creating on demand documentation topic modeling and visualizing execution traces .
still developers are known to mainly focus on the source code itself rather thandocumentationandotherartifacts .
consequently bringing the source code into a more understandable form is crucial to support program comprehension and to improve the software design.
several concepts and techniques have been proposedforthispurpose suchasprogrammingparadigms e.g.
object orientation feature orientation code recommendations e.g.
on identifier names decomposition strategies and other supportive techniques e.g.
source code comments documentation traceability .
in this paper we are concerned with a design decision that is oftenarguedtopositivelyimpactsoftwaredevelopmentandmaintenance explicittraceabilityofsoftwarefeaturesinthesource code.explicit traceability refers to code styles that explicitly mark 338esec fse august 26 30 tallinn estonia jacob kr ger g l al kl thorstenberger thomas leich andgunter saake whatpartsofthecodebelongtowhatfeature.suchexplicitlocationshelpdeveloperstofasteridentifyrelevantcodeandunderstand what the corresponding feature does.
as we report in section somestudiesindicateapositiveeffectofexplicittracesonprogram comprehension.however thesestudiesareusuallyconductedas controlled experiments with a small number of students and involve specialimplementationtechniques suchas feature oriented programming .
in contrast we i conducted an experiment including experienced professional software developers ii used feature traces that are independent of implementation techniques and iii comparedboth types oftracesnot onlytoeachother but alsoto object orientedcode withoutany traces.
forthisexperiment werandomlydistributedallinviteddevelopers into three groups each of which had to perform six tasks on java code that comprised no feature traces annotated features or decomposed features.
we refer to annotating i.e.
features were commented and decomposing i.e.
features were implementedinseparateclasses as separationoffeatures .
by using lightweight designs to incorporate feature traces we did notneedtoteachourparticipantsanewimplementationtechnique.
we did this to reduce learning efforts which we argue to benefit the usability andintroduction of explicit feature tracesin practice.
the results indicate that compared to pure object oriented code annotations can have a positive impact on understanding features while decomposition can potentially hamper bug localization.
still due to our sample size we have to be careful with interpreting these results but qualitative responses also indicate a strong favor ofmostparticipantstowardsexplicitfeaturetraces.incombination withfindingsofotherresearchersonmorespecializedimplementationtechniques wearguethatexplicitfeaturetraces andespeciallyannotationscanimproveprogramcomprehension andsupportautomationwithoutnegativelyimpactingthetimethat developers needto analyze code.
in summary our contributionsare as follows wereportanddiscussquantitativedataonthecorrectness and completion time of our participants for six program comprehensiontasks.
wediscussqualitativeresponsestoshedfurtherlightinto the benefitsandproblems that our participants faced.
weprovideareplicationpackagethatincludesourexperimental design the source code of our subject system and allanonymizedresponses inarepository.
our results provide empirical insights into the impact of explicit featuretracesondevelopers taskperformance.especially aswe confront our participants with unfamiliar code they have no previous knowledge about it and face the scenario of familiarizing with newcode andthe assignedtasks.
related work thenotionoffeatureshasbecomeafundamentalconcept notonly to implement variability in software product lines but for software engineering in general used to communicate document and structure systems .
in particular an extensive body of researchinvestigatesthetaskoflocatingfeaturesinthesourcecode automatically aswellasmanually .feature location is a time consuming and costly task that is necessary tomaintainorfix essentially comprehend afeaturethatisnot made explicit in the code.
the benefits of explicit feature traces are apparent astheyfreethedeveloperfromlocatingfeaturesinthe code savingtimeandprovidingfocuspointsfordevelopers .
research in the related area of requirements traceability is concerned with tracing requirements throughout various artifacts downtothesourcecodeofasystem.tothisend severaltechniques have been proposed to recover traces to the source code .
moreover empiricalstudies suggestthatsuchtraces cansignificantlyfacilitatedevelopers tasks.however mostofsuch techniques rely on external tools and requirements are a different abstractionthanfeatures.bothcanbeinanyrelationtoeachother for example afeature needsto fulfill multiple requirements.
duetothevarietyoftechniquesthatcanbeusedtoenablefeature traceability an important question arises what technique is suitable in what situation to support developers understand source code?inthisregard researchershavecompareddifferentfeature characteristics and traceability techniques to gain insights.
for instance liebig et al .
passos et al.
melo et al .
and we investigated the characteristics of feature implementations and how these impact maintainability evolution and the architectureofasystem.furthermore feigenspanetal .
analyzed whetherbackgroundcolorsinsteadoftextualannotationsfacilitate program comprehension.
in contrast parnas discusses how to decompose a system into modules or components another widely usedtechniqueto separate andtrace features.
despitesuchtechniquesandstudies itisstillanopenissuehow toseparatefeaturesmosteffectively.severalauthorsargueabout potential advantages and disadvantages of annotating features in a singlecodebaseversusseparatingthemintomodules .
due to the complexity of comparing such implementation techniquesandduetopsychologicalbiases onlyfewresearchers report empirical studies.
siegmund et al .
conducted a controlled experiment in which they compare preprocessor annotationsandfeature orientedprogramming.however thisexperiment includes only eight students limitingmore generalinterpretation.
in a follow up experiment on bug fixing students have beeninvolved buttheresultsshownosignificantbenefitsofeither technique.
our previous works on this topic include a survey with 34developers apreliminaryanalysisofdevelopercommunities and a case study .
during these works we have been concernedwithannotatinganddecomposingfeaturestoprovide insightsinto the opinionsandexperiences of developers but they donotprovideexperimentalevidenceonprosandconsofeither technique.allthesestudiesfocusonspecializedimplementation techniquesforvariability addingcomplexityandeffortforpractical usage.
moreover none of these studies analyzes pros or cons of using any ofthesetechniques comparedto not using it.
overall it is still not clear to what extent separating features with one of the basic techniques annotations or decomposition impacts a developer s ability to understand a program.
ourgoalistoimprovetheempiricalevidenceconcerning theimpactofsuchexplicitfeaturestraces.incontrasttoprevious works we are not concerned with implementation techniques that 339effects of explicit feature traceability onprogram comprehension esec fse august 26 30 tallinn estonia allowvariability butrelyoncommentsandclassesthatdonotrequiredeveloperstolearnnewconcepts.thisalsoexcludestheusage of external tools as these add further abstractions and developers may be reluctantto use them .
moreover we are interestedin understandingtheprosandconsoffeaturetracescomparedtocode that does not comprise any.
nonetheless our experimental design ispartlyinspiredbyprevious studiesandguidelines .
experimentaldesign inthissection wedescribethe goal subjectsystem implementation distribution ofparticipants and tasksofour experiment.
.
goal research questions we aimed to empirically assess the impact of explicit feature traces in source code.
to this end we have been concerned with two establishedtechniques annotationsanddecompositionintocomponents cf.
section .
arguably both techniques facilitate feature location as features are separated and can be easily found through searchingtheiridentifiersinannotationsorfilenames respectively.
inordertoinvestigatetheirimpactonprogramcomprehension we consideredthedifferentcodeversionsas independentvariables comprisingthethreelevelsobject oriented annotated andcomponents.
moreover weaimedtocontroltheparticipants programmingexperience meaning that we considered the experience as independent andnot as confoundingvariable.
toaddressour goal we definedthree researchquestions rq1to what extent does feature traceability impact the effectiveness ofprogram comprehension?
weinvestigatedwhetherannotationsordecompositionimproveourparticipants abilityto correctlyunderstandcode i.e.
effectiveness .
to this end we used the number of faults as metric dependent variable and compared the ratios of correctsolutions between allthree code versions.
rq2to what extent does feature traceability impact the efficiency ofprogram comprehension?
we investigated whether annotations or decomposition facilitateourparticipants abilitytounderstandcode faster i.e.
efficiency .tothisend wemeasuredtheircompletiontime dependentvariable for eachtask.
rq3what is our participants perception of feature traceability on theperformed tasks?
besidesquantitative measures we were concerned withour participants perception of explicit feature traces.
in particular we wanted to understand what problems or benefits they experienced while understanding the source code.
consequently weaddressedthisresearchquestionbasedonqualitativeresponsesandmappedthosetoourquantitativedata.
based on existing studies wehypothesized that annotations and decomposition perform comparable to each other.
in contrast we assumed that the explicit traceability of features would facilitate all tasks compared to pure object oriented code while the correctness should remain similar.
overall we defined ournull hypotheses thatweaimedtorefutewithourdataasfollows for the corresponding researchquestions h1the correctness of our participants task solutions does not differbetween groups.h2the efficiency of our participants to complete tasks does not differbetween groups.
we tested each hypothesis by comparing two groups to each other pair wise forallofoursixtasks cf.
section3.
resultinginatotal of18testsforeachhypothesis e.g.
object orientedcomparedto annotations annotations compared to composition .
we corrected ourtestresultstoaddressmultiplehypothesistesting cf.
section4 .
.
subject system as our subject system we selected mobile media which has been developed by researchers of the software product line community andwaslaterextendedwithfeatureannotations using thecpreprocessor thatweusedasbaseline .duetoitscareful designandusageofstandardcodingtechniques itisanappropriate subject system that has been used in several studies .
moreover it is implemented in java which is one of the most common programming languages.
the software provides a content management system for media files on mobile devices.
in our experiment we used a single file namelymediacontroler.java that implements ten features of the software.
thesefeatures are related to storing and managing photos music and videos.
to avoid biases we removed all existing commentsinthefile.moreover weremovedlibraryimports which contributetoapproximately10 ofthetotallinesofcode andan sms feature of which only a small part is implemented in this file.
we did this tolimit the code sizethatour participants had toread whichwasaround 400lines inthe end.
finally we refactoredthe file intothree differentversions object oriented inthisversion weonlyremovedtheexisting preprocessorannotations e.g.
ifdef toprovidethesource code without any feature traces.
thus we obtained pure object orientedcode that we usedfor the controlgroup.
annotated for annotation based feature traces we replaced existing preprocessor annotations with traceability annotations based on existing studies i.e.
begin end .wedecidedtodothis i as cpreprocessorannotationsarerarelyusedinjavaprograms ii toavoidconfusionoverpotentialvariabilitywearenot interestedin and iii to not introduce newconcepts.
components toobtainthedecomposedversion weextracted each feature into a class and added static methods that comprise the feature s code.
for each class we used the corresponding feature s name as file name and removed all existing annotations.
due to these code designs the participants did not need to learn anynewconceptsforanyversion.knowledgeaboutcommentsand object orientationaresufficienttounderstand suchfeature traces after ashort introduction.
.
distributionofparticipants we personally invited software developers from different countriesandaskedthemtosharetheinvitationwithothers.ourgoal was to include developers with industrial experiences and increase their motivation to participate.
after accepting the invitation each 340esec fse august 26 30 tallinn estonia jacob kr ger g l al kl thorstenberger thomas leich andgunter saake table questions to quantifyprogramming experience.
id question answeringoptions a q1howdo youestimateyour programmingexperience?
a very inexperienced 10 very experienced q2howexperiencedareyouwiththejavaprogramminglanguage?
a very inexperienced 10 very experienced q3forhowmanyyearshave youbeen programming?
a q4for how many years have you been programming for larger software projects e.g.
incompanies ?
a q5what is your highest degree of education that is related to programming?
a multiplechoice optional text developerhadtofillinasurveytoassesstheirprogrammingexperience.
we provide an overview of the survey questions and possible answers in table1.
thesequestionsarebasedonanempiricallyderivedproposal .
webasedtheanswerclassificationsforq 3andq4onalargeuser survey of stack overflow.2in this survey approximately one quarter of the participants has been in each of the classes we show intable .
we mapped the classes to a scale from one to ten i.e.
aligning them to the first two questions.
considering the degree we only identified whether a developer received one ornot asitishardlypossibletosaywhichonesmayindicate better developers.
for the experience value we computed the averageofallscalesandconsideredadeveloperasnoviceiftheresult wasbeloworequalto5.5 orasexpert otherwise.werandomly distributed our participants into three groups one for each code version i.e.
object oriented annotated components withequal ratiosofnovices andexperts andsentthe actual experiment.
.
tasks questions for the first part of our experiment we selected six tasks that involve but are not directly concerned with feature location for tworeasons participants of the annotated andcomponents groups can quicklylocate features bysearching the names.
we aimed to limit learning effects that may impact our subjects performances incompleting theirtasks.
incontrasttothestraight forwardtaskoffeaturelocation wewere interestedintheimpactoffeaturetraceabilityontasksthatrequire actualcomprehension.therefore wedesignedtwosectionswith three tasks each.
in the firstsection wewere concernedwithcomprehending features and their interactions which does not only require to locate the corresponding code but to alsounderstand it.
feature interactions represent different system functionalities that interact and may influence each other.
thus feature interactionsare an importantchallengethatcaneasilyresultinproblemsduringprogram comprehension and bug fixing .
the tasks that we defined for the firstsection were questions to evaluate the participants experiences with thetasksandon feature traceability.
id question answering options a eq1did you have any problems in answering the survey e.g.
understandingthe questions or concepts?
a yes no eq2whatwasyourstrategyforcomprehendingthecodeinordertodo the tasks?
a freetext eq3whathavebeenyourmainproblemsorchallengesduringthetasks?
a freetext eq4 annotated do you thinkthattheannotations provided for each featurehelped youunderstand the code?
components do you think that the separation of features into classeshelped youunderstand the code?
object oriented doyouthinkthatadifferentcodedesignconcerningthe features e.g.
annotating theirbegin and end implement theminseparateclasses wouldhavefacilitatedyourprogramcomprehension?
a freetext eq5did you face an interruption more than minutes for anyof the tasks?
a checkboxfor eachtask eq6doyouhaveanycommentson the survey?
a freetext outoffourfeature pairs selectthosethat interact selectthe lineswhere twodescribedfeatures interact and out of four statements about this feature interaction select thosethat are correct.
in the second section we asked our participants to locate bugs whichwe inserted intoafeature cannotcapture photos intoafeature interaction wrongcounter for videos and intothe basecode cannotdelete photos .
these bugs resemble simple faults i.e.
copy paste errors increments similartomutations .eachtaskwasaboutadifferent feature to mitigate learningbiases.
at the end of our experiment we asked our participants to elaborate on their experiences and to describe whether they faced any problems.
we show the corresponding questions in table .
eq1 wasasimplecheckquestiontoverifyiftherewereanymisunderstandings which could also be elaborated on in eq .
we used eq to verify whether a participant was interrupted during any task meaning that we considered the corresponding results differently.
with the remaining three questions we were concerned with gatheringqualitativedatatoanswer rq3.weremarkthateq 4exists inthree differentversions one for eachcode version.
.
implementation testing due to the tasks we defined i.e.
marking lines of code and the design of our experiment i.e.
accessible via internet we were notabletoreuseexistingsurveytoolswithoutconsiderablecosts andadaptations.forthesereasons wedecidedtoimplementour own solution that was based on a simple server client architecture and fulfilled the requirements of our experiment.
we tested our 341effects of explicit feature traceability onprogram comprehension esec fse august 26 30 tallinn estonia table experiencevaluesofour participants.
versionexperienceparticipantsmin median mean max annotated .
.
.
.
components .
.
.
.
object oriented .
.
.
.
total .
.
.
.
implementation extensively with own test runs.
code reviews and additionaltestsofourimplementationwereperformedbythreecolleagues consisting of a software developer a system administrator and a phd student.
moreover two of these colleagues tested the actualsurveytoevaluateformulationsandthetasks complexity.
none of the three colleagues participated in the actual experiment.
we decided to conduct our experiment via the internet to increase our range provide the opportunity to conduct the tasks at any time and have access to developers all around the world without extensive traveling.
thus this is not a fully controlled experiment butanunsupervisedonethatwasconductedinrealworld settings in which developers may be distracted or switch tasks.withthisdesign weaimedtoincreasetheexternalvalidity ofour results.
results and discussion inthissection wereportdetailsabouttheparticipantsofourexperimentandtheresults.weseparatelyreportanddiscussobservations for eachofour researchquestions.
.
participants unsurprisingly notalldevelopersthatweinvitedparticipatedin our experiment.
overall we received responses from around the world mostly from turkey germany and the united states .
in table we show the distribution of our participants experience values based on our rating scale cf.
table .
only two participantsstatedthattheyhaveworkedforlessthentwoyears onlarge scaleprojects.aswecansee themedianandmeanvalues areclosetoeachotherandamongthegroups.whilethedistributionofparticipantsforeachprogramversionisnotidentical the differencesaresmall.moreover mostparticipantsareconsidered experts according to our analysis with only three of them in the componentsgroup not achievingthis rating.
overall we can see small differences between the groups of participants.
nonetheless we had at least participants and expertsforeachcodeversionofourexperiment.consideringthis information the responses we analyzed represent a diverse and experiencedsetofpractitioners.thus wearguethatnoneofthe differences threatens the results of our study but we have to be cautious withour interpretations.
validity of responses.
as aforementioned we aimed to attract experienced software developers and intended to focus on external validity.
due to our study design there have been several participants who reported disruptions while they worked on a task or problems in understanding some details however most elaboratedabout code issues rather than the experiment itself .
to address this issue we firstperformed a sanitycheck inthecontext of rq1 for developers stating comprehension problems.
considering rq2 we removed all completion times for which interruptions were reported as these measures would not accurately represent the requiredeffort.
due to technical issues single data points for some participants aremissing.first threeparticipantsreportedproblemswithtask or were just missing the entry.
we decided not to count these responses wherefore task for the annotated group comprises only responses cf.
figure .
second one participant of the components group did answer all questions except the elaboration cf.table .
we decided to include this response but to put it into thegroupwithcomprehensionproblemsforthesanitycheck assuming that there have been misunderstandings .
except for these four we excludedallotherunfinishedorincompleteresponses.
.2rq1 effectiveness infigure we show how many of our participants were able to correctly solve each task.
we distinguish between three groups according to our first independent variable the version of the code the participants investigated a annotated c components oo object oriented .
moreover we considered whether the participantsindicatedproblemsinunderstandinganypartoftheexperiment cp or not ncp .
we applied hypothesis testing to test whether our observations may be significant.
in particular we tested observation that represents our sanity check and based on whichwe scopedour remaining observations analyses andtests.
observation difficulties in understanding the survey had no impactontheresults.
comparingthecorrectandincorrectanswers oftheparticipants withandwithoutcomprehensionproblemsfor eachtask wecanseethatthedistributionsaresimilar.moreover in some tasks the ratio of correctly solved tasks with comprehension problems is identical compared to those without problems e.g.
for task of the annotated group both have eight correct and one incorrectanswer .thus itseemsthatproblemsinunderstanding ourexperimenthadonlylimitedimpactonourparticipants ability to correctly solve a task.
this is reasonable as the code was unknowntoourparticipants meaningthattheyhadtounderstand it anew anyway.
as in daily life they can still understand code even if facing a potentially vague assignment.
in addition most participantsstatedthatthecodewastheproblemforunderstanding e.g.
toolong ratherthanthetasksthemselves.however thecode anditsdesignwerethesubjectweaimedtounderstand meaning that the results should be comparable.
hypothesistesting.
basedonourobservation wehypothesized thattherearenothreateningdifferencesbetweentheparticipantswho did have and who did not have problems in understanding our experiment.to test our hypothesis we applied fisher s exact test asimplemented inthe rstatistics software .weused fisher s exacttest becauseitcanbeappliedonsmallsamplesizes butwe still have to be careful with interpreting the results.
to account for multiplehypothesistesting wereliedonabonferroni holmcorrection withaglobalconfidenceintervalof0.
.intheremaining paper wereportthep valuesofallsignificantresultsandalsostate 342esec fse august 26 30 tallinn estonia jacob kr ger g l al kl thorstenberger thomas leich andgunter saake 7414task task task task task task a c oo a c oo a c oo a c oo a c oo a c oo0.
.
.
.
.
grouprepsonses incorrect cp incorrect ncp correct cp correct ncp feature comprehension bug localization figure1 distributionofcorrectlyandincorrectlysolvedtasksforeachcodeversion a annotated c components oo objectoriented andtask.moreover wedisplaywhetherthecorrespondingparticipantsstatedcomprehensionproblemsornot cp comprehensionproblems ncp nocomprehensionproblems .
theapproximated bonferroni holmcorrectedthresholdthathadto befulfilled.the null hypothesis isthatcorrectandwrongresponses are equally distributed.
in total we tested 18hypotheses one for eachpair wise combinationofgroupsforeachofthesixtasks.noneofthetestsindicated that the differences are significant wherefore we cannot reject our null hypothesisso wecontinuedundertheassumptionwederived from our observation namely that participants who had problems inunderstandingthesurveydidnotperformworsethanthosewho didnot.duetothisobservation wefocusedonallparticipantsand did not separate those that had comprehension problems for our remaining analyses.
observation explicit feature traces result in higher effectiveness forcomprehending featureinteractions.
consideringthe firstthree tasks we can see in figure 1that the pure object oriented code performs worse compared to annotations and components.
for the firstandthirdtask onlyoneparticipantwhoworkedontheobjectoriented version was able to correctly identify and understand the feature interactions.
moreover concerning task only three moreparticipantshavebeenabletocorrectlysolvethetask.this result seems unsurprising as explicit feature locations facilitate understanding interactions considerably developers canfocus on certain parts ofthecodeand do nothave toidentify thecodethat implementsthefeaturefirst which istimeconsumingandcanbe faulty as every developer has an own potentially different notion ofwhat afeature comprises .however it is surprising that participants who analyzed componentshadconsiderablymoreproblemswhileidentifyingfeatures that interact task .
the data shows that participants selected multiplewronginteractions.incontrast theyweremoreoftenable to correctly explain how features interact task .
for this task the faulty responses usually show that it seems unclear for the annotatedgroup towhatextentfeaturesinteract whichfeature doesmodifywhichfeatureinwhatway?bothgroupsperformed comparable for locating asinglefeature interaction task .
potentially it is easier to identify that features interact at all if their code is close to each other annotated code rather than separatedintodifferentclasses resultinginthecodeloosingitssurrounding context and potentially leading to the anti pattern action at a distance .
in contrast this loss of context may be better to identify how features interact in the data flow method calls can already indicate whether a functionality is only used or whether variables are changed.
by inspecting the separated features developerscanmoreeasilyidentifygloballyaccessibleandpotentially interacting variables.
annotated code may complicate this analysis asallcontext evenirrelevantone isconnectedtothefeature.identifying and understanding the actual data flow interactions of featuresremainschallenging evenwithexplicitfeaturetraces as wasexplicitly statedbysomeparticipants cf.
section .
.
observation3 decompositionresultsinlesseffectivenessforbug localization.
forthelastthreetasks wecanseethatparticipants who faced the decomposed code identified fewer bugs correctly 343effects of explicit feature traceability onprogram comprehension esec fse august 26 30 tallinn estonia comparedtoothergroups.surprisingly theyevenperformedworse for a faulty named label within a feature task .
as this bug is connected to and thus directly placed in a feature we expected that the participants could easily identify the bug.
the wrongly selected answers show that most participants identified the correct class but selected a wrong line after the actual bug.
as is also highlighted by participants feedback cf.
section .
this problem seemsconnectedtothefactthattheclassesrepresentedfeatures andnotlogicalobjects asintendedinobject orientedprogramming.
again the same issueof lost context andunderstanding data flow we described for our previous observation seems to have impacted our participants ability to locate bugs.
however to understand theseeffectsinmoredetail werequireadditionalstudiesonlocating andfixing bugsindecomposedcode.
observation4 annotationsdonotresultinmoreeffectivebuglocalization.
forannotations weobservethattheratioofcorrectly localizedbugsissimilarcomparedtotheobject orientedversion.
thus annotationsseemtohavenonegativeimpactonbuglocalization.
as the bugs are rather simple the annotations may not behelpfulinthisscenario ortheanalysisofobject orientedcode mayhaveresultedinbetterknowledgeofourparticipants.more extensivestudiesofthesefactorsareneededtobetterunderstand howthey influencedevelopers program comprehension.
hypothesistesting.
foreachtask wecomparedallgroupsagainst eachother pair wisetests .toaccountforlearningeffectsofour participants weconductedall18testssimultaneouslyandcorrected them together instead of testing each task individually.
again we used fisher s exact test and the bonferroni holm correction.
to this end we always assumed as null hypothesis that the ratio of correct and incorrectanswersbetweentwogroupsis equal cf.
h1 .
the test results include three significant outcomes for which we can refute our nullhypothesis.
for tasks1 and2 we foundsignificantdifferences betweentheannotated and object oriented group p .0001andp .001with corrected thresholds of p .0028and p .
respectively .
this supports our second observation that explicit feature traces support comprehending feature interactions.
however this is solely limited to annotations and does not significantlyapplytothedecomposedcodeversion.inaddition wefound significant differences between components and object oriented code for task4 supporting ourthird observation p .001and a correctedthreshold of p .
.
to summarize rq1 our results indicate that explicit feature traceability can have positive but also negative effects on program comprehension.
still we have to be careful with interpretationsandmustconductindustrialstudies forwhich annotations seem to be more promising.
o1understanding problems donot biasthe results.
notrejected.
o2explicittraces improve interaction comprehension.
accepted twice forannotated code.
o3decomposition hampers buglocalization.
accepted once.
o4annotations have noeffectonbuglocalization.
notrejected.
.3rq2 efficiency intable we display statistics about the times our participants in each group needed to complete a task regardless of correctness.
weonlyconsideredparticipantsthatdidnotstateinterruptionsfor atask undisturbed .nonetheless wefoundfewextremeoutliers where some participants worked for several hours on a single task.
theseoutliersindicatethatthecorrespondingparticipanthadbeen interrupted butdidnotstateso.
inordertoaddresssuchextreme cases we removed entries that were more than twice above the thirdquartileofeachtaskandgroup.thisledtotheexclusionof22 data points from our analysis the differencebetween undisturbed andincludedparticipants in table4.
observation explicit feature traceability does not influence efficiency.theresultsdonot varyheavilybetweendifferentversions of the code.
moreover only the first task required considerably more time compared to the others.
this is rarely surprising as our participants had to get familiar with the code and its structure.
for all other tasks all groups needed between .
and .
minutes tocompleteatask onaverage.likewise theminimumandmaximum timesare similarthroughoutalltasks.
thus explicitfeature traceability seems to have neither a positive nor a negative impact on the analysis time especially compared to the time needed to familiarizewiththe code.
hypothesis testing.
we compared the completion time distributions of our groups within each task with the kruskal wallis test .
thistest does not require normal distributions and can comparemultiplegroupsagainsteachother.the null hypothesis whichwe aimed torefute wasthattherearenosignificantdifferencesbetweenthecompletiontimes cf.
h2 .asnoneofthetests resultedinap valuebelow0.
wecannotrejectournull hypothesis andarguethat our observationisreasonable.
to summarize rq2 the results show no impact of explicit featuretraceabilityonthecompletiontimes.consideringthat annotationsseemtoimproveprogramcomprehension this indicates an overallpositive effectof these.
o5explicitfeature traces do not influence efficiency.
notrejected.
.4rq3 participants perception intable we summarize the qualitative responses we received from our participants which are particularly important to practitioners .partly thenumbers donotaccumulate tothe total number of participants as we allowed each participant not to elaborateindetail buttheycouldalsoprovidemultipleinsightswith their response.
we read all their comments and summarized the mentioned analysis strategies challenges and opinions on code designforeachgroup.oursummarizingstrategyfollowedtheidea ofopen cardsorting .
analysis strategies.
concerning their analysis strategy many participantsineachgroupstatedthattheystartedwithageneral exploration of the source code .
they aimed to understand the structure of the code and its behavior on an abstract level.
how these tasks have been performed is quite different among the participants somesimplyskimmedthroughthecodetogetarough 344esec fse august 26 30 tallinn estonia jacob kr ger g l al kl thorstenberger thomas leich andgunter saake table statistics on thecompletiontimes in minutes ofour participants.
task task task task task task a c oo a c oo a c oo a c oo a c oo a c oo und.
part.
incl.
part.
times mins min2.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mean13.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
median .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
max25.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
sd8.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
part.
participants und.
undisturbed incl.
included sd standarddeviation table5 summaryofourparticipants qualitativeresponses concerning analysis strategies challenges and code design meansnotapplicable .
response mentioned annotations components object oriented participants analysis strategy getpicture ofcode lookforkeywords use search function follow annotations follow class names challenges code quality code length missing ide feature location missing knowledge code design positive unsure negative components comments explicitlocations understanding while others focused on specific code constructs such as labels andmethods.
unsurprisingly participants relied on the explicit feature traces to address their tasks if these were available.
in some cases the participants mentioned that they also focused on keywords mostly to understand details and used their browser s search function .keywordsandsearcheswerealsoexplicitlymentioned andusedbyparticipantsthatworkedontheobject orientedcode.
thisbehavioralignswiththeresultsofpreviousstudiesonmanual feature location .
challenges.
consideringchallenges 21participantsmentioned quality issues of the code.
mostconcerns were connectedto design decisions of our experiment that they did not like for example the long code length missing comments or inappropriate identifiers.
we specifically removed comments to avoid biases and reduced the code size but the code had to be large enough for feature traces to be useful.
other general concerns were the intentionally missing ide support avoiding too many biases that would make any meaningfulassessmentimpossible.fiveparticipantsalsomentionedtheir missingknowledgeaboutthesystemasaproblemthathampered theircomprehension.however thiswasalsointendedtohaveequal preconditionsforeveryparticipant.interestingly notonlytwoparticipants of the object oriented group but also two participants oftheannotated grouphad problems to identify feature locations.
for example in the annotated group one participant indicated the needfor decomposing features to avoid cluttering hebiggestchallengefor mewasthatallofthefeatures are inasingleplace justwritten one after another.
opinions.
concerningthefeaturetraceabilitytechniquesontheir own most of our participants stated a positive perception after the experiment.
for example out of participants in the annotated group argue that the annotations helped some stating that they were elementary to locate and understand features conflicting somescientificbeliefs aboutannotations yes they did.
in fact without the annotations provided that theyarecorrect itwouldhavebeensignificantlymoredifficult to understandwhichpart of the code does what.
the few critics of annotations were not focusing on the actual annotations but arguethat comments indicatepoorcode o adding comments in the code is a bad sign it screams that code isnot self explanatory enough.
similarly nine of participants stated a positive effect of decomposing the system into features.
most participants stated that it helpedto fastertrace features ithelps logical aid to decidewhere to start.
the negative experiences were connected to identifying which featuretolookat.suchissuesmainlyarosebecauseourparticipants hadnot been familiar withthe system 345effects of explicit feature traceability onprogram comprehension esec fse august 26 30 tallinn estonia yes i understood the intent with this sorting naming and separation.
it was still unfamiliar and took more time than it wouldhave withfamiliar code.
this indicates that decomposition has to be used carefully the right separation strategy is important and especially to new developers we have to explain how it is used.
for developers who are familiarwiththestructureofthecodeanditsfeatures thisproblem will arguably diminish.
one participantspecifically explained their experienced pros and cons of decomposition and may best summarize our overallresults i.e.
rq1 on the one hand it made the classes small and locating possiblyrelevantcodeeasy.ontheotherhand interactionswere more difficult to spot because i had to switch between different classes.
for theobject oriented group we did not ask about the anticipated impact of the code design but whether annotations or decomposition wouldhave been helpful features could have been implemented in a more organized way.
eclearlyneedmore thanone class here.
more precisely four participants were in favor of decomposing the code and five were in favor of adding comments i.e.
annotations to indicatefeature locations more comments and better restructuring of the code should be more helpful.
overall 11outof16participantsmentionedthatanyexplicitfeature traces inthe code wouldhave been helpful.
to summarize rq3 the results show that most of our participants have a positive perception of explicit feature traces.
thus introducing traces in practice may not be a problem andespeciallyannotationsare simpletoadopt.condensing the qualitative responses we can derive three observations o6explicitfeatures extend generalanalysisstrategies.
o7feature traces themselves are unproblematic to use.
o8making features explicit has apositive perception.
threats to validity the goalof our study was toprovide empiricalinsights into a fundamentaldesign decision based on studying experienced software developersintherealworld.duetothetrade offsbetweeninternal and external validity and the magnitude of interacting factorsthatimpactprogramcomprehension wecanhardlyaddress allbiases resultinginmoreinternalthreats.inthefollowing we reportthreatstothevalidityofourstudybasedontheguidelines ofwohlin etal.
.
constructvalidity.
concerningtheconstructvalidityofourstudy some participants indicated that they had problems understanding the survey or the concepts of annotations and decomposition to separate features.
to mitigate this threat we provided small examples and used check questions to identify whether any confusions occurred.moreover weperformedasanitycheckonthecorrectness oftasks andfound no differences for participants whostated comprehension problems.
so we argue that this threat is properly addressedinourdesign.in addition mostparticipantsstatedthatthey had problems with the code and not the experimental design meaningthat the constructvalidity wouldnot be threatened.
internal validity.
we aimed to reduce the impact of different development environments by using a web interface to display the code.
still we kept identifier names as well as syntax highlighting and did not control for tool usage e.g.
searches .
while we cannot ensure that our participants conducted the experiment with the exact same set ups e.g.
noise level using additional tools web searches wearguethatdevelopersinreal worldsettingsalsohave amulti foldoftools environments anddifferentcomprehension patterns.thus theset upmaybiasourresults butreflectspractice.
our code examples comprise different techniques to trace features namely annotations and decomposition.
we relied on the existingpreprocessordirectivesintheoriginal mobilemedia system to add our own annotations.
for the decomposition we separated the corresponding code into different classes.
both techniques are inspiredbytheusageofpreprocessorsinopen sourceandindustrialsystems whicharesimilarlystructured .togetherwiththe additionalchangesthatweappliedtothecode i.e.
removingone feature deleting imports and comments the nature of our code exampleschanged.suchchangesmayhaveinfluencedtheresults.
we did all changes in order to keep our participants motivated and to control biases.
still we cannot fully avoid this threat to our study and for example another decomposition may have resulted inbetterresults for our participants inthe corresponding group.
aconcerninginternalthreatarelearningeffectsofourparticipants meaning that they may got more familiar with the code.
we addressedthisthreatintwoways first whileweusedasinglecode example we asked about different features for each task.
this way ourparticipantsmayhaveachievedbetterunderstandingaboutthe overallcode butnotthespecificfeature.mostoftheparticipants also indicated that they did neither focus on nor did achieve an understandingoftheoverallcode besidesageneraloverview.second wedecidedagainstarandomorderofthesurveytasks.so foreach task the experience with the source code should be comparable between our participants.
based on this we argue that learning effects are mostly impacted by the different traceability techniques for features whichisthe concernof our research questions.
externalvalidity.
softwaredevelopershavevariousbackgrounds expertise with a programming language and experiences with certaintasks.toaddressthesethreats weinvitedagroupofexperiencedsoftwaredevelopersfromseveralcountriesandorganizations.
besidesmostofthemworkingonlargerprojectsforalongtime we also evaluated theirprogramming experience based onwhichwe randomly sampled them into equally distributed groups.
while the responsesresultedinthreenovicesbeingpartofthesamegroup theywereclosetoexpertlevel.overall ourparticipantsarearather homogeneousgroupconsidering their experiences wherefore we arguethat such threatsare diminished but mayhave occurred.
severalbackgroundfactors suchasage gender ormotivation may have an impact on the results.
moreover program comprehensioncomprisescognitiveprocessesthathighlydependonthe individual developer as they learn and understand based on different patterns and rates.
we aimed to address such factors partly by measuring them i.e.
programming experiences and by personally invitingparticipants e.g.
increasing motivation .
still wecannot 346esec fse august 26 30 tallinn estonia jacob kr ger g l al kl thorstenberger thomas leich andgunter saake controlallofthesefactorsperfectly.consequently theyremaina threatto the external validity ofour study.
severalstudiesused mobilemedia toprovidecodeexamplesfor empirical studies.
the code is also designed to reflect a real world system and thus we argue that our examples can be considered as realistic.nonetheless mobilemedia isanacademicsystem which is why our results may not be completely transferable to industrial practice.still ourparticipants activitiesduringprogramcomprehension will most likely not have changed since such systems are similarlystructuresinindustrial open source andacademiccontexts .
in addition all participants faced the same system independent variable meaning that our analysis of feature traces dependent variable remainsvalid.
conclusion validity.
we have to be careful with the conclusions wederivedfromour observations.while theyare interesting our statistical testsrevealedonly fewsignificantcorrelations.
however duetotheproblemsofsuchtests weonlyusedthemassupportive means and focused more on our actual observations.
to this end we carefully investigated different variables and analyzed their impact on program comprehension.
this way we aimed to mitigate threatsto the conclusion validity.
despitethediscussedthreats wearguethatourstudyisvalid and provides reliable and interesting insights into an important design decision.
we used quantitative and qualitative methods combining measured data with subjective responses and tested our observationsstatistically.still weencourage otherresearchersto conductfurtherstudiesinthisdirectiontostrengthentheempirical evidenceandgaininsightsintotheimpactofexplicitfeaturetraces.
in this regard we arguethat our study can be replicated.
conclusion in this paper we reported an online experiment with experienced software developers concerning explicit feature traceability whichweimplementedbasedonannotationsanddecomposition.
webasedourdesignonexistingstudiesandrecommendations with a particular focus on increasing the external validity of our results.
to this end we invited especially practitioners from various countriesandorganizations.wereliedonquantitativeandqualitative analysesto find indications for the following fourconclusions annotationspositivelyimpacttheeffectivenessofdevelopers when comprehending features and their interactions whilenot negativelyimpactingbuglocalization.
decompositionintocomponentshasnosignificantimpact on the effectiveness of developers when comprehending features but resulted in less correct bug localization.
however thisisarguablyconnectedtothestructure size andcohesion ofthe decomposedfeatures.
explicit feature traces do not impact the efficiency of developers duringprogram comprehension.
explicit feature traces do not result in comprehension problems and practitioners have a positive perception of such explicit traces.
weremarkthatthereareseveralthreatstoourresultsandwehighly encouragefurtherstudies.however wearguethat especiallyfor annotations our results indicate that explicit feature traces can be ahelpful meanstosupport program comprehension.in particular this may be the case if developers are facing unfamiliar code.
as theyare alsosimpletointroduce annotationsmaybeagoodway for organizations to implement and test feature traceability as well as for researchersto conduct further studiesinthis direction.
in future work we aim to extend our analysis and focus on additional variables particularly extending our investigations to programmers memory.moreover weplantodesigndifferentexperimentsandobservationalstudiesthatmaximizeinternalorexternal validity includingcollaborationswithindustrialpartners.thisway we can consolidate the empirical knowledge about explicit feature traces provide more precise recommendations to practitioners andidentifyopenresearchproblems.furthermore wearguethat differenttracingtechniquesshouldbecomparedtoidentifywhat impact they may have.
similarly our study was focused on programcomprehensiontasks.inthefuture wealsoaimtoanalyze the impact of explicit feature traces on other activities that we did notconsider forexample onmaintainingandevolvingasystem e.g.
introducing newfeatures .