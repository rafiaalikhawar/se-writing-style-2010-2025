towards efficient and effective automatic program repair xuan bach d. le school of information systems singapore management university singapore dxb.le.
phdis.smu.edu.sg abstract automatic program repair apr has recently been an emerging research area addressing an important challenge in software engineering.
apr techniques if effective andefficient can greatly help software debugging and maintenance.
recently proposed apr techniques can be generally classified into two families namely searchbased and semantics based apr methods.
to produce repairs searchbased apr techniques generate huge populations of possible repairs i.e.
search space and lazily search for the best one among the search space.
semantics based apr techniques utilize constraint solving and program synthesis to make search space more tractable and find those repairs that conform to semantics constraints extracted via symbolic execution.
despite recent advances in apr search based apr still suffers from search space explosion problem while the semantics based apr could be hindered by limited capability of constraint solving and program synthesis.
furthermore both apr families may be subject to overfitting in which generated repairs do not generalize to other test sets.
this thesis works towards enhancing both effectiveness and efficiency in order for apr to be practically adopted in foreseeable future.
to achieve this goal other than using test cases as the primary criteria for traversing the search space we designed a new feature used for a new search based apr technique to effectively traverse the search space wherein bug fix history is used to evaluate the quality of repair candidates.
we also developed a deductivereasoning based repair technique that combines search based and semantics based approaches to enhance the repair capability while ensuring the soundness of generated repairs.
we also leveraged machine learning techniques to build a predictive model that predicts whether an apr technique is effective in fixing particular bugs.
in the future we plan to synergize many existing apr techniques improve our predictive model and adopt the advances of other fields such as test case generation and program synthesis for apr.
ccs concepts software and its engineering !software creation and management keywords automatic program repair deductive reasoning mining software repository genetic programming .
introduction software bugs are one of the primary challenges in software development which usually incur significant cost in software production.
given short time to market mature commercial software systems are delivered with both known and unknown bugs despite the support of multiple developers and testers dedicated for such projects.
to maintain the quality of software bug fixing is thus an important task.
yet it is notoriously hard time consuming and laborious process which usually dominates developer time and software maintenance cost .
thus there is a dire need to automate bug fixing process to help reduce the burden and cost on software debugging and maintenance.
substantial recent works on automatic program repair apr have been proposed to repair real world software making the oncefuturistic idea of apr become gradually materialized.
these repair techniques generally fall into two categories search based methodology e.g.
genprog par spr prophet and hdrepair and semantics based methodology e.g.
semfix nopol directfix and angelix .
searchbased repair techniques generate a large pool of possible repair candidates i.e.
search space of repairs and then search for correct repair within that search space using an optimization function.
meanwhile semantics based techniques leverage constraint solving and program synthesis to generate repairs that satisfy semantics constraints extracted via symbolic execution and provided test suites.
despite recent advances in apr current approaches are limited in several ways .
to truly make apr adoptable in practice an apr technique must be effective i.e.
able to correctly fix many bugs and efficient i.e.
able to do so at affordable costs .
although being able to fix general bugs potentially renders search based apr more effective the efficiency of these techniques could be hindered by the search space explosion problem wherein correct repair candidates sparsely occur which may consume several hours to complete the search for correct repairs .
semantics based apr on the other hand attempts to fix less generic bugs on some restricted categories e.g.
assignments if conditions and makes use of program synthesis with restricted components like in to render the search space more tractable.
thus it is more efficient than search based apr e.g.
angelix can fix bugs in minutes on average .
however its effectiveness could be hampered by limited capability of constraint solving and program synthesis e.g.
non linear constraints are hard to solve .
furthermore both searchbased and semantics based apr may generate plausible repairs permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
those that do not generalize beyond the provided test suites due to the incomprehensiveness of the given test suites.
the goal of this research is to work towards enhancing both effectiveness and efficiency in order for apr to be potentially adopted in practice.
to achieve this goal we have done the followings first we developed a history driven repair technique namely hdrepair that performs far better than its counterparts in the same search based apr family.
the results also showed that hdrepair generates good quality repairs at reasonable time cost.
second we developed a repair technique based on deductive reasoning to marry the strengths of both search based and semanticsbased apr together .
while search based apr alone may be ineffective and inefficient due to a sparse search space cultivating the search space with repair ingredients generated by light weight semantics analysis could help condense correct repairs in the search space.
third to better utilize the wealth of apr techniques we developed a predictive model that is able to predict whether an apr technique is effective in fixing particular bugs helping developers choose the best apr that suites their need.
the structure of the remainder of this paper is as follows.
section describes contributions that the thesis contributes to the field.
section describes discussion and future work of the thesis including synergizing many existing apr techniques bug fixes specification mining improving predictive model for apr s effectiveness and tests generation and program synthesis.
section concludes the paper.
.
contributions this section provides further details on published research work on program repair that the thesis focuses on.
.
history driven program repair a recent study on program repair showed that test suites alone may not be adequate for apr techniques to generate correct repairs addressing the important need of seeking other features that could help apr generalize.
to this end we proposed to use bug fix history to effectively guide and drive the program repair process .
an important feature that differentiates our new technique from previous work is that it evaluates the fitness or suitability of a repair candidate by the degree to which it is similar to various prior bug fixing patches in the bug fix history.
also different from work like par which mines bug fix history to construct and apply repair templates we use fix history as the primary criteria for assessing potential qualityof generated repair candidates.
this is in contrast with previous apr techniques which by and large use only input test suites as the only criteria for assessing patch suitability.1the main intuition for using bug fix history to inform patch suitability quality is that bug fixes are often similar in nature and past fixes can be a good guide for future fixes .
human fix fa fb .
if fa fb .
throw new convergenceexception ... figure bug in math version to illustrate consider the buggy code snippet in figure taken from math version in defects4j benchmark .
the convergenceexception will be thrown when one of the test cases is ex1we use the words patch and repair candidate interchangeablyecuted causing the test to fail.
one naive way to fix the problem is to simply delete the throw statement which eliminates the bad symptom and causes the failing test to trivially pass.
however this is a nonsensical solution.
unfortunately prior apr techniques would not be able to identify such a solution as nonsensical due to the reliance on test cases as the only yardstick for patch quality.
our history driven approach on the other hand can effectively identify those nonsensical patches since those candidate patches rarely occur in the history and thus would be received very low patch suitability scores.
those candidates that receive low scores are likely to be filtered out during the search for repair in our approach.
our history driven apr technique works on there phases bug fix history extraction bug fix history mining and bug fix generation .
in the first phase historical bug fixes are mined from several revision control systems of hundreds of projects in github.
in the second phase we mine the frequent bug fix patterns in the historical data extracted in the first phase.
these mined bug fix patterns are then used as knowledge base for the third phase.
in the third phase we iteratively generate repair candidates using existing mutation operators borrowed from program repair and mutation testing.
candidates suitabilities are then assigned by querying the constructed knowledge base e.g.
candidates that match many frequent bug fix patterns in the knowledge base would receive higher scores.
candidates with higher suitability scores are more likely to be chosen and ranked higher during the search process.
finally we return a ranked list of possible repair candidates that pass previously failed test cases as recommendation to developers.
we performed an experiment on hdrepair par and genprog on bugs taken from defects4j dataset.
as compared to the baselines the advantage of hdrepair is two fold better effectiveness and efficiency.
that is hdrepair repairs far more bugs bugs than par bugs and genprog bug can repair.
also hdrepair takes minutes on avarage to generate fixes for these bugs.
manual inspection of the results suggests various reasons for why hdrepair performs better than others.
this includes the power of mutation operators time needed to generate repairs and the correctness of repairs.
that is genprog and par sometimes lack the necessary mutation operators to create repairs causing the techniques to timeout without finding any repairs.
other than that genprog and par generate incorrect repairs which trivially cause all provided tests to pass but fail to match with the desired behaviours as patches submitted by developers.
hdrepair on the other hand utilizes the strengths of many mutation operators to diversify the set of possible candidates and leverages bug fix history to assess suitability of generated candidates.
thus hdrepair normally is able to find repairs that are close to the developers fixes.
in the future we expect that the history driven approach in complement with test driven approaches would be able to help avoid generating plausible fixes also known as overfiting .
.
program repair based on deductive reasoning test driven and history driven repair approaches generate patches that are susceptible to overfitting.
in other words generated patches may not be correct in the sense that they are not automatically verified for correctness but rather relying on developers experts for correctness assessment.
we address the problem of patch correctness soundness by utilizing a deductive reasoning method .
given a buggy program with specifications written in separation logic we generate syntactic andsemantics repair candidates.
syntactic candidates are generated by borrowing mutation operators from genprog to syn877tactically change the original program e.g.
delete a statement replace a statement with another etc.
semantic candidates are generated from the provided specifications as repair templates e.g.
expected output values conditional structure if then else etc.
the reason for incorporating syntactic and semantic candidates together is that these candidates could help one another in tandem to condense the search space with more valuable candidates.
for example the search space with syntactic repair candidates alone is sometimes very sparse since real fixes could lie beyond the syntactic candidates.
semantic candidates however could cultivate the search space with more useful candidates.
with this combined search space we then validate candidates by an underlying deductive verifier and select best candidates which receive fewer number of warnings issued by the verifier for patch evolution through genetic programming.
the process is repeated until a patch that receives no warnings from the verifier is found.
this way patches generated by our system are automatically guaranteed correct following the correctness of the underlying verifier.
table shows the details of the bugs in our experiments with our approach and angelix a current state of the art semanticsbased apr.
in the table loc column shows the number of lines in each program including specification lines .
the mutated loc column indicates the name of the function where the bug is seeded.
in this column dupp stands for do upgrade process prio ncl stands for numeric case loop and ibc is a short form of inhibit biased climb .
the time column shows the time in minutes needed by our approach to fix the bugs.
the category column shows the type of the error either missing implementation or incorrect implementation.
we note that we reused sir program specifications constructed by le et al.
and injected seeded bugs to the original programs by mutating the original programs in various different ways.
initial experiment results show that our approach can fix these bugs while angelix can only fix one out of these bugs tcas2 .
for all bugs except one our approach can successfully fix the bugs in less than minutes.
the bug that took the most time to fix was the print tokens bug which requires .
minutes.
our further observation on the results is that angelix by default cannot fix bugs that require adding new statements.
that is its synthesis engine is geared towards synthesizing only guards assignments if conditions and loop conditions and is not able to produce new code out of thin air e.g.
inserting new statements.
also some bugs involve nonlinear constraints which are hard for angelix s synthesis engine to solve.
our cultivated search space including both syntactic and semantic candidates however comes in handy in this place.
that is our approach can generate candidates that lie beyond the search space of angelix and thus is more likely to be able to find the correct fixes with the help of the optimization function which assesses patch suitability by the number of warnings issued by the underlying verifier.
in the future we expect a greater success of combining syntactic and semantic repair candidates to potentially enhance repair capability of apr and ensure patch quality.
.
predicting effectiveness of apr recent years have seen the proliferation of many different apr techniques with various strengths and weaknesses e.g.
one might fix bugs that others cannot ever fix.
to better utilize the wealth of apr we developed a predictive model that is able to predict whether an apr technique is effective at fixing particular bugs .
our idea is somewhat similar to the idea of predicting correct program in programming by example proposed by gulwani et al.
whereby correct programs that meet user defined specifications e.g.
table evaluation of our proposed approach on programs from the sir benchmark with manually seeded bugs.
program mutated loc loc time category uniq gline loop .
incorrect replace addstr .
missing replace stclose .
missing replace stclose .
incorrect replace locate .
incorrect replace patsize .
incorrect replace esc .
incorrect schedule3 dupp .
incorrect print tokens ncl .
missing tcas2 ibc .
incorrect input output examples are ranked higher in the search space of possible candidates.
in our setting we would like to suggest the best apr technique that could fix given bugs from users.
thus users can either proceed with the effective apr returned by our predictive model or switch to traditional way of manually fixing bugs rather than desperately hoping for an inefficient apr technique to automatically fix the bugs for them.
our predictive model was built for search based apr approaches e.g.
genprog.
at an early stage of running the repair tool we extract a number of features that are potentially related to the effectiveness of the tool e.g.
the size of input program the number of test cases etc.
we then leverage machine learning technique to process these features and learn a discriminative model that can predict whether continuing the search process would result in a repair within a desired time limit.
it is worth noting that the features are extracted only a few seconds after the repair tool is run.
we perform our experiment on real world bugs taken from in which genprog can generate fixes for bugs.
experiment results showed that our model can identify effective cases from ineffective ones i.e.
bugs for which the repair tool cannot produce correct fixes after a long period of time with a precision recall f measure and auc of and respectively.
comparing with other studies solving various prediction tasks in the software engineering research literature e.g.
the performance of our approach is comparable or higher.
we also highlighted the important features that help our model achieve good performance.
these include the diversity of the pool containing possible repair candidates generated by the repair tool the number of faulty areas considered to be fixed the input program and test cases etc.
.
discussion future work currently the test driven and history driven techniques are being developed alone leaving the potentially interesting combination of them untapped.
we envision however that test driven and historydriven approaches can significantly help one another to mitigate current issues with apr.
particularly our history driven technique could potentially help test driven approaches to mitigate the overfitting issue since history based approach does not directly use test cases as the primary criteria for assessing patch suitability.
testdriven approaches e.g.
angelix on the other hand can help cultivate the search space with more useful repair candidates.
thus synergizing these techniques could be an interesting line of work that this thesis would tackle in the future.
program repair based on deductive reasoning wherein searchbased and semantics based apr are merged together has shown promising results.
however complete specifications are required in order to completely ensure the soundness of generated patches.
878we expect that employing advances in specification inference and mining could help reduce this burden.
in future work we would like to use the history of bug fixes to mine specifications of past patches and inform the future patch generation process in a way that generated patches are likely to conform to desired behaviours.
our predictive model is currently designed specifically for searchbased apr techniques.
future work would be to design more useful features e.g.
features that characterize patch quality to generalize our model for both search based and semantics based apr techniques.
also we could augment our model to further help apr predict correct patches in a huge search space of possible candidates as similarly proposed by program synthesis work in .
this potentially helps render the search space of apr more tractable since correct patches could be more easily identified among the search space increasing both efficiency and effectiveness of apr techniques.
automated test case generation and program synthesis have been proven helpful in the domain of program repair .
we believe that further tapping into these research areas would be an interesting direction to help advance current apr techniques.
for instance tests generation tools could help generate more comprehensive test suites and thus would help mitigate the overfitting issue e.g.
a well tested patch would less likely to be a plausible one.
incomprehensive test suites may render program synthesis generate spurious solutions.
strong program synthesis techniques e.g.
lazy synthesis would help semantics based apr techniques e.g.
angelix cope with incomplete specifications making apr amenable to incomprehensive test suites.
an interesting future work would be to explore the effectiveness of many different program synthesis techniques and find the best way to adopt the synthesis techniques for apr.
.
conclusion automated program repair addresses an important challenge in software engineering.
recent years have seen this field growing rapidly with many proposed techniques.
our research contributes to the field in several aspects to mitigate current issues with apr e.g.
efficiency and effectiveness.
in sum we developed a new history based apr technique that performs far better than other techniques in the same family.
we also developed a deductivereasoning based apr technique which merges search based and semantics based approach together for ensuring patch correctness.
to better utilize many existing apr techniques we developed a predictive model that is capable of predicting apr s effectiveness assisting users in choosing the best apr that suites their need e.g.
fixing bugs in a desired time budget.
as future work we will continue working towards enhancing both effectiveness and efficiency of apr rendering it to be adopted in practice in foreseeable future.
.