is this class thread safe?
inferring documentation using graph based learning andrew habib andrew.a.habib gmail.com department of computer science tu darmstadt germanymichael pradel michael binaervarianz.de department of computer science tu darmstadt germany abstract thread safe classes are pervasive in concurrent object oriented software.
however many classes lack documentation regarding their safety guarantees under multi threaded usage.
this lack of documentationforcesdeveloperswhouseaclassinaconcurrent programtoeithercarefullyinspecttheimplementationoftheclass to conservatively synchronize all accesses to it or to optimistically assumethattheclassisthread safe.toovercomethelackofdocumentation we present tsfinder an approach to automatically classify classes as supposedly thread safe or thread unsafe.
thekey idea is to combine a lightweight static analysis that extracts agraphrepresentationfromclasseswithagraph basedclassifier.
aftertrainingtheclassifierwithclassesknowntobethread safe andthread unsafe itachievesanaccuracyof94.
onpreviously unseen classes enablingthe approach to infer thread safety documentationwithhighconfidence.theclassifiertakesabout3secondsperclass i.e.
itisefficientenoughtoinferdocumentationformany classes.
ccs concepts softwareanditsengineering synchronization reusability documentation automated static analysis object oriented development software maintenance tools keywords inferring documentation thread safe class graph based learning acm reference format andrewhabibandmichaelpradel.
.isthisclassthread safe?inferring documentationusinggraph basedlearning.in proceedingsofthe201833rd acm ieeeinternationalconferenceonautomatedsoftwareengineering ase september montpellier france.
acm new york ny usa 12pages.
introduction thread safeclassesarepervasive.theyarethecornerstoneofconcurrent object orientedprograms.athread safeclassencapsulates allnecessarysynchronizationrequiredtobehavecorrectlywhen permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
without additional synchronization from the calling side.
developers of multi threaded object oriented programs often rely on thread safe classes to cast away the burden of ensuring the thread safety of their applications.
unfortunately it is not always clear to a developer who uses aclasswhethertheclassisthread safeornot.thereasonisthat many classes do not provide any or only partial information about their thread safety.
instead it is common to find questions on web forums such as stack overflow about the thread safety of a specific class.
for example one developer asked about the thread safety of the widely used javax.xml.parsers.documentbuilder class.1anotherdeveloperquestionedthethreadsafetyofthecrucial jdkclass java.util.random .2developersoftencomplainabout the lack of thread safety documentation.
for instance the developerwhoreportedthatearlierversionsofjdkformatclassesare notthread safenotesthat notbeingthread safeisasignificant limitation on a class with potentially dire results and not documenting the classes as such is dangerous.
3eventually the accepted fix was to explicitly state in the documentation that jdk formatclassesarenotthread safe.anotherdevelopercomments onthethread safetyof java.beans.propertychangesupport and java.beans.vetoablechangesupport and writes however thedocumentationdoesnotindicateeithertheirthread safetyor lack thereof.
in keeping with the current documentation standards this point should be indicated in the class documentation.
the lack of adequate documentation about the thread safety of classeshasseveralnegativeconsequences.first adevelopermay solve the problem by manually analyzing the classes she wants to reuse.however thisapproachspoilssomeofthebenefitsofreusing an existing class because it forces the developer to inspect and understandtheclassimplementation breakingtheencapsulation provided by the class api.
second a developer may conservativelyassume that a class is not thread safe and carefully synchronize all concurrentaccessestotheclasstoavoidconcurrencybugs such asdataraces atomicityviolations anddeadlocks.however ifthe classisalreadythread safe thisadditionalsynchronizationimposes additional runtime overhead and may unnecessarily limit the level ofparallelismachievedbytheprogram.finally adevelopermay optimisticallyassumeaclasstobethread safe .however iftheclass turns out to not provide this guarantee the program may suffer fromconcurrencybugs e.g.
whichoftenbecomeapparent authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france andrew habib and michael pradel only under specific interleavings and therefore may easily remain unnoticedduringtesting.inallthreescenarios thedevelopertakes apoorlyguideddecisionthatreliesonherlimitedunderstanding of an implementation or on luck.
this paper addresses the problem of missing thread safety documentation by automatically classifying a given class as thread safe or thread unsafe.
our approach called tsfinder is a statistical graph based learning technique that learns from a relatively small setofclassesknowntobethread safeorthread unsafethedistinguishing properties of these two kinds of classes.
the approach is enabled by two contributions.
first tsfinder uses a lightweight staticanalysisofthesourcecodeoftheclasstoextractinformation andrepresentthisinformationinagraph.second weusegraphbasedclassificationtechniques graphkernels combinedwith supportvectormachine svm tolearna classifierforpreviously unseen classes.
tsfinder helps developers assess the thread safetyofanotherwiseundocumentedclass enablingadeveloper to take an informed decision on whether and how to use the class.
our work is complementary to techniques for finding concurrencybugs whichhasbeenextensivelystudiedinthepast in particular in the context of thread safe classes .
these approaches consider supposedly thread safe classes and try to find corner cases in theirimplementationthatadeveloperhasmissed.instead tsfinder addressesclassesforwhichitisunknownwhethertheclassiseven supposed to be thread safe and tries to answer that question in anautomaticway.applyingexistingbugdetectiontechniquesto answerthisquestionwouldlikelyresultinmissingthread unsafe classes bytesting basedapproaches ormissingthread safeclasses bysoundstaticanalyses .ourworkalsorelatestoexistingworkon inferring and improving documentation.
we extend this stream of work to concurrency related documentation which has not yet been studied.
ourevaluationconsistsoftwoparts.first wevalidateourhypothesis that existing classes lack thread safety documentation bysystematicallysearchingall179 239classesinthequalitascorpus .wefindthatthevastmajorityofclassesfailstodocument whether it is thread safe or not.
second we evaluate our classifier with training classes that were manually labeled as thread safe or thread unsafe.
we find that .
of tsfinder s classification decisions are correct.
in particular the precision and recall of identifying thread safe classes are .
and .
respectively.
onaverage adding documentation to a new class takes about seconds.theseresultsshowthattheapproachisaccurateenoughto significantlyimproveoverguessingwhetheraclassisthread safe and efficient enough to scale to large sets of classes.
in summary this paper makes the following contributions asystematicstudyofthread safetydocumentationinrealworld java classes showing the lack of such documentation.
the first automated classifier to distinguish supposedly thread safeandthread unsafeclasses anunderstudiedproblem that addresses the lack of thread safety documentation.
a novel combination of static analysis and graph based classification that accurately and efficiently predicts the threadsafety of a class.
!
!
figure overview of tsfinder inferring thread safety using static analysis and graph kernels.
in section we give an overview of tsfinder.
sections 3and4 fillinthedetails.sections 5and6summarizetheimplementation andevaluation.sections 7and8discussthelimitationsoftsfinder andandrelatedwork.finally insection 9weconcludethepaper and discuss future work.
challenges and overview thegoal ofthis workis toautomatically documentclasses assupposedlythread safeorthread unsafe.theapproachshouldbeefficientenoughtoscaletohundredsofclasses e.g.
allclassesina 3rd partylibrary andaccurateenoughtoprovidereliabledocumentation.
achieving this goal is challenging for several reasons.
first there are different approaches for ensuring that a class is thread safe e.g.
making the class immutable using language level synchronizationprimitives buildingonotherthread safeclasses using lock free data structures and combinations of these approaches.
becauseofthisdiversity asimplecheck e.g.
forwhetheraclasshas synchronized methods is insufficient to determine thread safety.
second the thread safety of a class may depend on other classes.
in particular inheriting from a thread unsafe class may compromisethethreadsafetyofthechildclass.third extensivereasoning about concurrent behavior e.g.
to reason about different inter leavings can easily require large amounts of computational resources which conflicts with our scalability goal.
figure1providesanoverviewofourapproachtoinferthread safetydocumentation.theapproachconsistsofatrainingphase whereitlearnsfromasetofclassesknowntobethread safeand thread unsafe and a prediction phase where it infers thread safetydocumentation for a previously unseen class.
both phases combine a lightweight static analysis that extracts graph representations of classeswithagraph basedclassifier.thegraph basedclassification converts graphs into vectors by computing the similarity between graphsofato be classifiedclassandgraphsinthetrainedmodel.
these vectors are then classified using a model based on a support vector machine svm .
the following illustrates the main steps of tsfinder using the java class in figure 2a.
extractingfield focusedgraphs.
toapplymachinelearningtothe threadsafetyclassificationproblem weneedtorepresentclasses inasuitableform.ourapproachexploitsthestructurednatureof programs by representing a class as a set of graphs.
since multithreadingismainlyaboutsharingandallowingmultipleconcurrent authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is this class thread safe?
ase september montpellier france public class sequence private volatile int seq private int max public sequence int m m a x m reset public synchronized int next if !ismax return seq return boolean ismax return seq max void reset s e q a java class.
next sequence int ismax seq next sequence int max ismax next sequence int ismax seq reset max reset b extracted graphs.
the graphs from left to right correspond to fields seq max and the pair seq max respectively.
the identifier names in italic and blue font are not used for classification but shown only for illustration.
1 2... 4860 1 2... 4860 1 2... 4860 bracketleftbig .
.
... .
bracketrightbig bracketleftbig .
.
... .
bracketrightbig bracketleftbig .
.
... .
bracketrightbig c vectors of the three graphs in figure 2b.
the trained model has graphs in it.
min 1 max 1 av 1 min 2 max 2 av 2 ...av 4860 bracketleftbig .
.
.
.
.
.
... .
bracketrightbig d class vector of the entire class.
figure a java class and graphs extracted from it by our analysis.
tsfinder predicts this class to be thread safe.
accessestoresources thegraphsrepresentsharedresourcesand how these resources are accessed.
for the example class figure 2b shows the graphs extracted by tsfinder.
each graph focuses on a single field or a combination of fields of the class.
the graphs represent read and write accesses to the fields call relationships between methods and the use of synchronization primitives such as the synchronized keyword.
for example the first graph in figure 2b which focuses on the seq fieldshowsthatthefieldisreadbythe ismaxmethod writtenby theresetmethod and both read and written by the nextmethod.
furthermore the graph represents the call relationship between nextandismax.
computing graph kernels.
after extracting a set of graphs for each class under analysis tsfinder checks for each graph whether itissimilartographsthatcomefromthread safeorfromthreadunsafeclasses.tothisend weusethegraphkernels i.e.
mathematical functions that compute the pairwise similarity of graphs.
tsfindercomputesthesimilarityof eachgraphofaclassandthe graphs of classes known to be thread safe or thread unsafe.
the similarity values yield a vector of numbers called the graph vector orembedding.
for the running example the approach computes three graph vectors one for each graph as illustrated in figure 2c.
learning a classification model.
to train a classifier that can distinguishthread safeclassesfromthread unsafeclasses tsfinder trains a model using a corpus of classes with known thread safety.
the approach combines all graph vectors of a class into a singlevector called classvector thatrepresentstheentireclass figure2d along with a label denoting whether the class is thread safe or not.
finally the labeled class vectors are used to train a classification model that distinguishes between the two kinds of classes.
classifyinganewclass.
givenanewclass ourapproachextracts graphsandcomputesaclassvectorasinthepreviousstep.basedon thetrainedmodel tsfinderthenclassifiestheclassbyqueryingthemodelwiththisvector.for figure2 tsfinderinfersthattheclassis thread safe and adds this information to the class documentation.
extracting field focused graphs the first step of our approach is to extract graphs from classes via alightweightstaticanalysis.thissectionexplainstheproperties extractedbythestaticanalysis .
andhowwesummarizethese properties into graphs .
.
.
static analysis tsfinderperformsalightweightstaticanalysisthatextractsvarious properties of a class under analysis.
we focus on two kinds ofproperties unaryproperties whichdescribeprogramelements of the class and binary properties which describe relationships between program elements and properties of program elements.
we choose properties relevant for concurrency e.g.
memory locations accesses to memory locations and memory visibility guarantees of these accesses.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france andrew habib and michael pradel .
.
unaryproperties.
thestaticanalysisextractsthefollowing unary properties from each class definition .
unary properties .
letcbe the class under analysis.letcfbethesetoffields cmbethesetofmethods and cconst bethesetofclassconstructorsandstaticconstructorsdefinedby c. the set of unary properties of cis cunary cf cm cconst forexample ourapproachextractsfromtheclassin figure2a the following set of unary properties cf seq max cm next ismax reset and cconst sequence int .
.
binary properties.
to capture relationships between program elements and properties of program elements the analysis extracts several binary properties definition3.
binaryproperties .
letcbetheclassunderinspection andcconst cm cfasdefinedabove.wedefinethefollowing binary relations rels calls cconst cm cconst cm reads cconst cm cf writes cconst cm cf sync cm this lock mod cconst cm cf public protected private static volatile final the set of binary properties of cis cbinary calls reads writes sync mod the binary properties capture a rich set of relations relevant to our thread safety prediction task e.g.
whether a method is public what fields a method reads and writes and whether a method is synchronized.
the set this lock represents objects that the class uses as locks where thisrepresents a self reference to the current instance and lockrepresents any other object.
for our running example in figure 2a the binary properties include that the public class constructor sequence int writes to thefield max thatthemethod next readsandwritesthefield seq and that the method next issynchronized onthis.
note that theabsenceofpropertiesalsoconveysinformation.forexample the absence of a binary relation max volatile modindicates that the maxfield is non volatile.
.
.
flatteningtheclasshierarchy.
thethreadsafetyofaclass notonlydependsonitsownimplementation butalsoontheimplementationofitssuperclasses.e.g.
aclassmayinheritamethodthat doesnotsynchronizedataaccessesandthereforebecomethreadunsafe eventhoughthesubclassalonewouldbethread safe .
our static analysis addresses this challenge by flattening the class hierarchy.specifically theanalysisrecursivelymergestheunary andbinarypropertiesofeachclasswiththoseofitssuperclassuntil reachingtherootoftheclasshierarchy.themergingfollowsthe inheritance rules of the java language.
for example the properties relatedtoasuperclassmethodthatisnotoverriddenbythesubclass are merged into the properties of the subclass.
.
field focused graphs given the properties extracted by the static analysis tsfinder summarizesthisinformationintoasetofgraphsforeachclass.traditionally programs have been represented by a variety of graphs suited for different purposes.
for example abstract syntax trees control flowgraphs andprogramdependencygraphshavebeen usedtoanalyzethesyntax controlflow anddataflowofprograms.
thefollowingpresentstwokindsofgraphsdesignedspecificallyto reasonaboutconcurrency relatedpropertiesofclasses.thebasic idea is to summarize in each graph how clients of the class may accessafieldoracombinationoffieldsoftheclass.wecallthese graph representations field focused graphs.
before presenting field focused graphs we define a single graph per class which conflates all properties known about this class definition .
class graph .
given a class c letcunaryand cbinarybe the unary and binary properties of c respectively.
the class graph of cis a directed multi graph c vc ec where vc vrels cunary this lock public protected private static volatile final areverticesthatrepresentprogramelements and properties of them and vrels calls reads writes sync mod are special nodes that represent the different relations in cbinary.eachspecialnodeislabeledwiththenameoftherelation i.e.
withcalls reads writes sync ormodandisconnectedtoits binary operands by the set ecof directed unlabeled edges.
onepossible approachwould betopredict thethread safetyof a class based on its class graph.
however most class graphs are dissimilar from most other class graphs independently of whetherthe classes are thread safe because classes and therefore also their class graphs are very diverse.
an important insight of our work is thatthisproblemcanbeaddressedbyderivingsmallergraphsfromtheclassgraph sothateachsmallgraphcapturesacoherentsubsetofconcurrency relatedproperties.theintuitionisthatthesesmaller graphscapturerecurringimplementationpatternsofthread safe andthread unsafeclasses enablingtsfindertolearntodistinguish them.
tsfinderderivessmallergraphsfromtheclassgraphbyfocusing on a single field or a combination of fields definition .
field focused graph .
given a non empty subsetf cfof the fields of a class cand a class graph c where c vc ec the field focused graph f vf ef contains all vertices reachable from f i.e.
vf v vf fs.tt.reachable c vf v andreachable c v vf and contains all edges connecting these vertices.
for a directed graph v e whereuandv v reachable u v there exists a directed edge from utov.
iftheset fcontainsasinglefield thenthefield focusedgraph captures all program elements related to this field as well as the relations between them.
such a single field graph summarizes how clients of the class may access the field and to what extent these accesses are protected by synchronization.
for the example in figure 2a tsfinder extracts two graphs that focusonsinglefields shownasthefirsttwographsin figure2b.
they focus on the fields seqandmax respectively.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is this class thread safe?
ase september montpellier france somecharacteristicsofthread safeclassescannotbecaptured by single field graphs.
for example a thread safe class may update twosemanticallyrelatedfieldstogetheranduseasinglelockora synchronizedmethodtoprotecttheaccesstothesefields.tsfinder capturessuchbehaviorbyalsoconsideringsets fofmultiplefields whichyieldsmulti fieldgraphs.specifically theapproachconsiders all pairs of fields for which there exists at least one method that reads or writes from both fields.
to bound the overall number of graphsextractedperclass wefocusonfield focusedgraphswith f i.e.
single fields or pairs of fields.
asanexampleofamulti fieldgraph considerthethirdgraph infigure2b.becausetheclassmethod ismax readsbothfields the approach extracts a graph that captures both fields together.
intuitively the reason why field focused graphs are effective at characterizing the thread safety of a class is that they capture various patterns for making a class thread safe.
whether a class is thread safedepends on howthe class accessesits internalstate i.e.
its fields and in what ways these accesses are protected by synchronization.
field focused graphs capture the various ways to implementthreadsafety e.g.
usingsynchronizedmethods volatile fields or by making a class immutable.
by capturing these im plementation patterns the graphs enable tsfinder to determine whether a class is thread safe.
graphcanonicalization.
thefinalstepofextractingfield focused graphsfromclassesistocanonicalizethegraphs.themotivation is that to learn recurring patterns in implementations of thread safe and thread unsafe classes the extracted graphs need to be comparableacrossdifferentclasses.inparticular theyshouldnot contain identifier names such as method and field names as these vary across different classes and projects.
therefore our approach renameseachnodethatrepresentsamethodto m whiletwospecial node names initandclinitare reserved for class constructors andstaticconstructors respectively.similarly allfieldsarerenamed tof.
classifying classes classifyinggraphsisaclassicalprobleminseveraldomainssuch asbio andchemo informatics imageanalysis and web and social network analysis .
traditional approaches to this problem use a so called kernel method a function tocomputethesimilaritybetweentwographs.thepairwisesimilarities between graphs are then used as vector embeddings to represent the graphs for classification.
weadoptavariantofthisapproachtoourproblemofclassifying thread safe classes.
tsfinder first builds several graphs per class .
.
it then uses the kernel method through a graph kernel function to generate vectors embeddings for graphs .
.
.
instead of training a machine learning model on several individual graphs from each class we combine embeddings of graphs extracted from the same class into one single embedding per class for the machinelearningmodeltolearn .
.
.thisstepallowstsfinderto classify thread safe classes using all generated graphs from a class.
basedonthefield focusedgraphsextractedforeachclass tsfinderlearnshowtoclassifyclassesintosupposedlythread safeand thread unsafe classes.
to this end the approach combines a graphkernel whichcomputesthesimilarityoftwographs witha svm which classifies each class based on the similarity of its graphstoothergraphsfromclassesknowntobethread safeornot.
the basic idea is to perform three steps givenaclass compareitsgraphstographsofclassesknown tobethread safeorthread unsafe.foreachpairofgraphs computeasimilarityscoreandsummarizeallscoresintoa vector per graph.
combine all graph vectors of a class into one single class vector that summarizes the similarity of graphs extracted from the class to graphs in the trained model.
classify a class by querying a vector based binary classifierusing theresultingclass vector.the classifierhasbeen trained with the class vectors of the classes with known thread safety.
the remainder of this section presents these steps in detail.
.
background graph kernels checking whether two graphs are isomorphic is a computationally hardproblemforwhichnopolynomial timealgorithmisknown.in contrast graph kernels offer an efficient alternative that compares graphsubstructuresinpolynomialtime.inessence agraphkernelis a function that takes two graphs and yields a real valued similarityscore.givenalistofgraphs 1 .. nandakernel k onecancompute a matrixk k i j i j i j n that contains all pairwise similarityscoresofthegraphs.thismatrix calledthe kernelmatrix is symmetric and positive definite.
inthiswork webuilduponafast scalable stateoftheartkernel theweisfeiler lehman wl graph kernel .
it is based on the weisfeiler lehmangraphisomorphismtest whichaugments each labeled node by the sorted set of its direct neighbors andcompresses this augmented label into a new label.
this step is repeateduntilthesetsofnodelabelsofthetwographsaredifferentoruntilreachingamaximumnumberofiterations h.givenagraph werefertothesequenceofgraphsobtainedbythisaugmentation and compression step as 0 1 .. h where 0 and his the maximallyaugmentedandcompressedgraph.wecallthissequence of graphs the wl sequence of .
given two graphs and their wl sequences we compute the graph kernel as follows definition .
weisfeiler lehman kernel .
the graph kernel of and primeis k prime ksub 0 prime ksub 1 prime ksub h prime h the function ksubis a subtree kernel function.
definition .
weisfeiler lehman subtree kernel .
the subtree graph kernel of and primeis ksub prime angbracketleft prime angbracketright where the notation angbracketleft.
.
angbracketrightdenotes the inner product of two vectors.
the function vectorizes a labeled graph by counting the original and compressed node labels of the graphs in the wl sequences of and prime.specifically let ibethesetofnodelabelsthatoccurat leastoncein or primeattheendofthe i thiterationofthealgorithm andletci ij bethenumberofoccurrencesofthelabel ij i in the graph .
based on the counter ci we compute as follows authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france andrew habib and michael pradel parenleftbigc0 01 ... c0 0 0 ... ch h1 ... ch h h parenrightbig .
training the goal of the training step of tsfinder is to create a binary classificationmodelthatpredictswhetheragivenclassisthreadsafe or thread unsafe.
we use a supervised learning technique and thereforerequiretrainingdata.astrainingdata weusetwosets of classes ctsandc tildewiderts which consist of known thread safe and knownthread unsafeclasses respectively.foreachoftheseclasses the static analysis extracts a set of graphs.
.
.
graphsvectors.
tsfinderfirstcomputesavectorrepresentationofeachgraphbasedonthegraphkernelfunctionin .
.
intuitively thevectorcharacterizesagraphbysummarizinghow similar it is to other known graphs in the training data.
more technically the approach computes the vector representation of a graph in three steps fix the order of all graphs in gcts c tildewidesttsto obtain a list of graphs 1 .. n. thespecific order does notmatter as long as it remains fixed.
compute the kernel matrix of all graphs k k i j i j for i j n. foreachgraph i thei throwof kisthevectorrepresentation of called graph vector.
.
.
combiningclassgraphs.
giventhegraphsvectorsofa class wecombinethesevectorsintoasingleclassvector.intuitively the class vector should summarize to what extent the individual graphsofaclassresemblethegraphsofclassesinthetrainingdata.
ifaclasshasgraphsthatareverysimilartographsthattypically occur in thread safe classes then the class is more likely to threadsafe.
likewise a class with graphs that mostly resemble graphs fromthread unsafeclassesismorelikelytoalsobethread unsafe.
to encode this intuition we create a class vector by computing the minimum maximum and average similarity of all the graphs of the class against all graphs extracted from the training classes.
letn gcts c tildewidestts be the total number of graphs extracted from all classes in the training data.
for a specific class c letgc bethesetofallgraphstsfinderextractedfrom candm gc be the total number of these graphs.
for each graph i gcwhere i m letfj iwhere j nbe thejth feature of graph iof the classc.
our approach computes the class vector by calculating j ... n min fj i i ... m max fj i i ... m mean fj i i ... m and concatenating these n values into a single vector.
for example the class vector in figure 2d has elements.
the first three elements are the minimum maximum and mean similarity of the graphs in figure 2b compared to the first graph in the list of graphs extracted from the training classes.
the next three elements are the minimum maximum and meansimilarity of the graphs in figure 2b compared to the second graph extracted from the training classes ...etc.
.
.
classifier.
giventheclassvectorsandtheircorresponding labelsl1 .. lnthatindicatewhetheraclass cisfromctsorfrom c tildewiderts we finally feed the labeled vectors into a traditional vectorbased classification algorithm.
by default tsfinder uses a svm for learning the classifier.
our evaluation also considers alternative algorithms.
.
classifying a new class once tsfinder has learned a model we use it to predict the thread safety of a new class.
let cnewbe the new class for which we wish to infer its supposed behavior regarding thread safety.
the approachcomputesaclassvectorof cnewinthesamewayasfor training.atfirst tsfinderextractsfield focusedgraphsfrom cnew which yields a set gcnewof graphs.
for each graph gcnewthe approachcomputesthegraphvectorof bycomputingitsgraph kernel against all graphs in our training data vec k j 1j j ... n where j gcts c tildewidesttsisthesetofgraphsinthelearnedmodeland n gcts c tildewidestts is the total number of graphs in the model.
given thesetofgraphsvectors tsfindercombinesthesegraphsintoasingle class vector as described in .
.2and queries the trained modeltoobtainaclassificationlabelfortheclass cnew.thelabel indicates whether the model predicts the class to be thread safe or thread unsafe.
implementation weimplementtsfinderintoafullyautomatedtooltoanalyzejava classes.
the static analysis builds on the static analysis framework soot .
given a class either as source code or byte code the analysis extracts field focused graphs by traversing all program elements byqueryingthecallgraph andbyanalyzingdefinitionuserelationshipsofstatements.weusethegraphmlformat tostoregraphs.tocomputethewlgraphkernel webuildonan existing python implementation .
the svm model is implementedontopofthewekaframework .ourimplementation is available as open source.
evaluation the evaluation is driven by four main research questions rq1 how many classes come with documentation about their thread safety?
.
rq2 how effective is tsfinder in classifying classes as thread safe or thread unsafe?
.
rq3 how efficient is tsfinder?
.
rq4 how does tsfinder compare to variants of the approach and to a simpler approach?
.
.
rq1 existing thread safety documentation tobetterunderstandthecurrentstate of theartindocumenting thread safety we systematically search all classes from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is this class thread safe?
ase september montpellier france the qualitas corpus for thread safety documentation.
we focus on documentationprovidedaspartofthejavadoccommentsofaclass and its members and ignore any other documentation e.g.
on projectwebsitesorinbooks.mostreal worldclasseshavejavadoc documentationanditisacommonsoftwareengineeringpractice to document class level properties such as thread safety there.
ourinspectionproceedsintwo steps.atfirst wegeneratethe javadochtmlfilesforallclassesandautomaticallysearchthem for keywords related to concurrency and thread safety.
specifically wesearchfor concu thread sync and parallel .wechoose these terms to overapproximate any relevant documentation.
in total the search yields hits in of the classes.
asthesecondstep wemanuallyanalyzearandomsampleof120 of the classes.
for each sampled class we inspect the javadoc andsearchforanydocumentationrelatedtothethreadsafetyof theclass.basedonthisinspection weclassifytheclassinoneof the following four categories.
documentedasthread safe.
thedocumentationexplicitlyspecifies that the class is supposed to be thread safe or this intention can be clearly derived from the available information.
examples include the class level documentation states this class is threadsafe .
the name of the class is synchronousxychart and the project also contains a class xychart indicating that the former is a thread safe variant of the latter.
the class level documentation states mutex that allows only one thread to proceed other threads must wail until the one finishes .
the semantics of a mutex implementation imply that the class is thread safe because mutexes are accessed concurrently without acquiring any additional locks.
documentedasthread unsafe.
thedocumentationexplicitlyspecifiesthattheclassisnotsupposedtobethread safeorthisintention can be clearly derived from the available information.
examples include theclass leveldocumentationstates thisclassisnotthreadsafe or not to be used without synchronization .
the class level documentation states we are not using any synchronized so that this does not become a bottleneck .
theclass leveldocumentationstates theclass .. shallbe usedaccordingtotheswingthreadingmodel whichimpliesthat only the swing thread may access instances of the class and that the class is not thread safe .
documented as conditionally thread safe.
the documentation specifiestheclasstobethread safeundersomecondition.examples include the class depends on another class and has the same thread safety as this other class.
all static methods of the class are thread safe whereas nonstatic methods are not necessarily thread safe.
no documentation on thread safety.
the documentation does not mentionthreadsafetyandwecannotderivefromotheravailabletable existing thread safety documentation.
documented as number percentage thread safe .
not thread safe .
conditionally thread safe .
no documentation .
total inspected .
information whether the class is supposed to be thread safe.
examples of documentation that matches our search terms but does not document thread safety include the class implements a graph data structure and its documentation says that it permits paralleledges .
themethod leveldocumentationspecifiesthatanargument orthereturnvalueofthemethodissupposedtobethreadsafe.whilesuchastatementisaboutthreadsafety itdoes not specify this property for the current class.
table1summarizes the results of this classification.
we find that most .
of the inspected classes do not document the threadsafetyoftheclass buthitoursearchtermsforsomeother reason.inthedocumentedsubsetofclasses whichsumsupto20.
roughlythesamenumberofclassesisdocumentedasthread safe and thread unsafe respectively.
under the assumptions that our search terms cover all possible thread safety documentationand that the 120sampled classes are representativefortheentirepopulationofclassesinthecorpus we can estimate the percentage of documented classes in the corpus documented searchhits total classes .
.
in summary the vast majority of real world java classes do not documentwhether theyare thread safe ornot.
among thefewdocumentedclasses .
and52.
aredocumented as thread safe and thread unsafe respectively.
we conclude thatthecurrentstateofthreadsafetydocumentationispoorandwillbenefitfromautomaticinferenceofdocumentation.
.
rq2 effectiveness of tsfinder .
.
data set and graph extraction.
for the remaining evaluation weuseasetof230classesgatheredfromjdkversion1.
.0 152. these classes are documented to be either thread safe or threadunsafe providing a ground truth for our evaluation.
table 2shows the number fo fields methods and lines of code of these classes.
in total the classes sum up to lines of java code.
the last three columnsof table2providestatisticsaboutthegraphsthattsfinder extracts.
on average the static analysis extracts .
graphs per class which yields a total of graphs that the approach learns from.
althoughthenumberofthread safeandthread unsafeclasses is equal thetotal number of extracted graphs from thread unsafe classes is about .
the number of graphs extracted from thread safe classes.
since tsfinder uses the entire set of graphsto construct the class vector for any class this imbalance does authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france andrew habib and michael pradel table classes and extracted field focused graphs used for training and cross validation.
fields methods loc extracted graphs classes count min max avg min max avg min max avg graphs vertices edges thread safe .
.
.
thread unsafe .
.
.
all .
.
.
table effectiveness of classification via fold cross validation across classes with h .
thread safe thread unsafe accuracy precision recall precision recall .
.
.
.
.
not prevent the approach from learning an effective classifier.
the numberofgraphspercategoryin table2isdisproportionatetothe numberoffieldsandmethodsinthesamecategoryduetoflattening the class hierarchy .
.
.
.
.
results.
to evaluate the effectiveness of tsfinder we applyittothe230classesandmeasureprecision recall andaccuracy.
we perform fold cross validation a standard technique to evaluate supervised machine learning.
the technique shuffles and splits all labeled data i.e.
our thread safe and thread unsafe classes into ten equally sized sets.
for each set it then trains a model with theclassesintheotherninesetsandpredictsthelabelsoftheremaining classes using the trained model.
we measure accuracy as thepercentageofcorrectclassificationsamongallclassifications madebytsfinder.wemeasureprecisionandrecallbothforpredictingthreadsafetyandforpredictingthreadunsafety.withrespecttothread un safety precision meansthe percentage ofcorrect thread un safetypredictionsamongallpredictionssayingthataclassis thread un safe.recallmeansthepercentageofclassesclassifiedas thread un safe among all classes that are actually thread un safe.
table 3shows the results of the fold cross validation.
the classification accuracy is .
i.e.
tsfinder correctly predicts the thread safety of the vast majority of classes.
the precision and recall results allow the reader to further understand how incorrect predictions are distributed.
for example the fact that the precision for thread safety is .
means the following when the approach predicts a class to be thread safe then this prediction is correct in94.
ofthecases.similar therecallforthread safetyof94.
meansthattsfinderfinds94.
ofallthread safeclassesandmisses the remaining .
.
.
manualinspection.
tobetterunderstandthelimitations of tsfinder we inspect some of the mis classified classes.
thread safeclasspredictedasnotthread safe.
tsfindermistakenly predicts the thread safe concurrentlinkedqueue class to bethread unsafe.thisqueueimplementationbuildsuponanon blocking algorithm .
since our training set includes only six classes that use a similar lock free implementation the trainingdata may not be sufficient for the classifier to generalize to the concurrentlinkedqueue implementation.
nevertheless tsfinder correctlypredicts someoftheother classesthatusenon blocking implementations.
thread unsafeclasspredictedasthread safe.
theapproachpredicts treesetandenumsetas thread safe even though they are thread unsafe implementations of the abstract class abstractset .
we suspect these misclassification to be due limitations of the the learned model to generalize to previously unseen cases.
inaccurate documentation.
tsfinder classifies pkixcertpathvalidatorresult asthread safe eventhoughitsdocumentation labelsitasnotthread safe.manuallyinspectingtheimplementationshowsthattheclassisindeedthread safe.theprivatefields of the class are initialized by the constructor and after that cannotbewrittento.thiscaseillustratesthattsfindercannotonly add otherwise missing documentation but could also be useful for validating existing documentation.
in summary our classifier correctly predicts the thread safety of a class in .
of the cases.
the precision and recallforidentifyingthread safeclassesare94.
and94.
respectively.weconcludethattheapproachachievesitsgoal of automatically and precisely identifying whether a class is supposed to be thread safe.
.
rq3 efficiency of tsfinder weevaluate theefficiency ofourapproach bymeasuring thetime required for the different steps.
all experiments are performed on amachinewith4inteli7 4600ucpucoresand12gbofmemory.
training the classifier with a set of training classes is a one time effort.
for the training classes that we use in this evaluation thetrainingtakesapproximately11.7minutes includingallcomputationsteps suchasextractinggraphs computinggraphkernels and training the svm model.
when querying tsfinder with a new class theapproachextractsgraphsfromthisclassandclassifiesthe classbasedonthegraphs.theformersteptakesabout3seconds and it dominates the latter which is negligible on average over all training classes.
tsfinderstoresgraphsextractedfromtrainingclassesaspartof itstrainedmodel.thesegraphsareusedtocomputethepairwise similarity of graphs extracted from the class under inspection to buildthevectorembeddingoftheclass.forourmodeltrainedwith 230graphs thetotalsizeofthecompressedgraphsis0.6mb i.e.
the space consumed by the model graphs is negligible.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
is this class thread safe?
ase september montpellier france table effect of the wl kernel iterations parameter hon classification.
h accuracy .
.
.
.
.
.
.
table effectiveness of the graph based tsfinder against the simpleclassifier classifier.
accuracy classifier tsfinder simpleclassifier svm sgd6with hinge loss .
.
random forest .
.
svm smo7 .
.
svm sgd with log loss .
.
additive logistic regression .
.
weconcludethattsfinderistimeandspaceefficientenough todocumenthundredsofclasses e.g.
ofathird partylibrary in reasonable time and with minimal space overhead.
.
rq4 comparison with alternative approaches asthedefaultclassificationalgorithm weuseasvmwithstochastic gradient decent sgd and the hinge loss function.
we empirically set the learning rate to .
and the number of wl iteration h to .
the following compares this configuration with alternative approaches.
.
.
configuration of the wl graph kernel.
to compare fieldfocusedgraphswitheachother tsfinderusesthewlgraphkernel which hasa parameter hthat determinesto what extentshould it compressnodelabels.
table4showstheeffectof hontheclassificationaccuracy.theresultssuggestthat h 3isanappropriatevalue forhandthatsmallvariationsoftheparameterdonotsignificantly change the accuracy.
.
.
classification algorithm.
tsfinder uses a classification algorithm that determines whether a given class vector is likely thread safe or not .
.
.
we evaluate several other popular algorithmsinadditiontoourdefaultofsvmwithstochasticgradient descent and hinge loss.
table 5shows the accuracy of tsfinder with four other classification algorithms each with the default configurationofhyperparametersprovidedbyweka.theresults show that the accuracy is only slightly influenced by the choice of classification algorithm as it ranges between .
and .
.
.
.
simple class level features.
we evaluate whether our graph based view on classes could be replaced by a simpler approachthatsummarizesclass levelfeaturesintoavector.theintuition behind this set of features is that as a human we tend to 6stochastic gradient descent 7sequential minimal optimizationbelievethat forexample aclass withhighpercentage ofsynchronizedmethodsisprobablymorelikelyintendedtobethread safe than a class with fewer synchronized methods.
specifically we consider the following class level features percentage of fields that are volatile.
percentage of fields that are public and volatile.
percentage of methods that are either synchronized or contain a synchronized block.
percentage of methods that are either public and synchronized or public and contain a synchronized block.
basedonafeaturevectorforeachofour230classes wetrainand evaluateaclassifierusingthesame10 foldcrossvalidationstrategy asabove.wecallthisapproach simpleclassifier.thelastcolumn intable5showstheaccuracyobtainedbysimpleclassifierusing different learning algorithms.
all algorithms are used with their default configurations as provided by weka.
the highest accuracy that simpleclassifier achieves is .
using the random forest learning algorithm which is significantly lower than the accuracy of tsfinder.
in summary we find that the choice of classification algorithm has little influence on the accuracy of tsfinder.
comparingtheapproachwithaclassifierbasedonsimple class level features shows that our graph based representation of classes yields a significantly more accurate classifier .
versus .
.
limitations onelimitationisthatthetrainingclassesmaynotcomprehensively coverallpossiblepatternsofthread safeandthread unsafecode.
as a result the analysis may not be able to correctly classify a previously unseen class that relies on a completely new way to implement thread safety.
we try to address this problem by selecting a diverse set of training classes that are used in various application domains and that cover different concurrency related implementationpatterns e.g.
immutableclasses classesthatusesynchronized methods and classes that use synchronization blocks.
another limitation is that some of the supposedly thread safe training classes may have subtle concurrency bugs.
if such bugs were prevalent the approach might learn patterns of buggy concurrent code.
to mitigate this potential problem the training set contains well tested and widely used classes for which we assume that most of their implementation is correct.
related work .
analysis of concurrent code the analysis of concurrent software has been an active topic for several years.
analyses that target thread safe classes are particularlyrelatedtoourwork.contege andballerina have pioneeredtestgenerationforsuchclasses.othertestgeneratorsimprove upon them by considering coverage information by steeringtestgenerationbasedonsequentialtestexecutions bycomparingthread safeclassesagainsttheirsuperclasses or bytargetingteststhatraiseexceptions .speedgun aimsat detecting performance regression bugs in thread safe classes.
concrash creates tests that reproduce previously observed crashes.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france andrew habib and michael pradel lockpeeker tests api methods to find latent locking bugs.
all theseapproachesfindcorrectnessorperformancebugsinthreadsafeclasses.instead ourworkaddressestheorthogonalproblem of inferring whether a class is even supposed to be thread safe.
beyondthread safeclasses variousdynamicanalysestofindconcurrency bugs have been proposed such as data race detectors analysestodetectatomicityviolations and analyses to find other kinds of concurrency anomalies .
whilethesetechniquesanalyzeagivenexecution anotherdirection is to influence the schedule of an execution to increase the chance totriggerconcurrency relatedmisbehavior.workoninfluencing schedulesincludesrandom basedscheduling systematic explorationofschedules andforcingschedulestotrigger previously identified potential bugs .
all these approaches aim at bug detection whereas tsfinder infers documentation.
finally there are various static analyses of concurrent code e.g.
to find deadlocks atomicity violations locking policies andconflictingobjects .onestrengthofourwork compared to existing static analyses of concurrent code is the use of a relatively simple static analysis and complementing it with graph based machine learning.
.
api documentation lethbridge et al .
study how documentation is used in practice.
theyfindthatdocumentationisoftenoutdatedandinconsistent.
inferringdocumentationfromsourcecodealleviatestheseproblems.
another study focuses on problems that developers face when learning a new api .
their results include that many apis need more and better documentation.
our work addresses this problembyprovidingan automated waytogenerateconcurrency specifications.
improvingdocumentationandhowdevelopersuseitisanactive area of research.
mcburney et al .
investigate how to prioritize documentationeffortbasedonsourcecodeattributesandtextual analysis.
treude and robillard augment api documentation with relevant and otherwise missing information from stack overflow.
apibot is a bot created to answer natural language questions by developers based on the available documentation .
other workfindsrelevanttutorialfragmentsforanapitohelpdevelopers better understand that api .
another line of work searches for mistakes in existing documentation by comparing it to the documented implementation or by pinpointing comments that risk becoming inconsistent when changing identifier names in the code .ourworkalsocontributestoimprovingandaddingotherwise missing documentation yet we tackle the so far understudied problem of inferring concurrency related documentation.
.
specifications mining specification mining automatically extracts a formal specification fromsourcecodeorfromprogramsexecutions.minedspecification include finite state specifications of method calls algebraic specifications temporal specifications of api usages implicit programming rules and locking disciplines .
one benefit of mined specifications is to use them as documentation.
tsfinder can be seen as a form of specificationmining.incontrasttoexistingtechniques ourworkfocusesonconcurrency documentation and uses machine learning to learn fromknown examples how to infer this specification documentation .
.
graph kernels kondor and lafferty and g rtner et al .
introduced graph kernels and others have been proposed since then e.g.
randomwalk kernels shortest path kernels and subtree kernels .thesegraphkernelshavebeenmainlyusedinbioinformatics in chemoinformatics and in web mining e.g.
to find similar web pages and to analyze social networks.
some existing work applies graph kernels to software.
wagner et al.
analyze process trees with graph kernels to identify malware.another approach uses markovchains constructedfrom instructiontracesofexecutables .furthermore graphkernels have been applied to statically identify malware by applying aneighborhood hash graph kernel on call graphs and by using graph edit distance on api dependency graphs .
our work tackles a different problem the lack of documentation regardingmulti threaded behavior.
another difference is the kind of information that tsfinder extracts from classes and then feeds into graphkernels.finally tothebestofourknowledge ourexperimental setup is orders of magnitude larger than any other study that utilizes graph kernels in the context of program analysis.
conclusion this paper addresses the understudied problem of inferring concurrency related documentation.
tsfinder is an automatic approachtoinferwhetheraclassissupposedtobethread safeornot.
our approach is a novel combination of lightweight static analysis and graph based classification.
we show that our classifier has an accuracy of .
and therefore provides high confidence documentation while being efficient enough to scale to hundreds of classes e.g.
in a third party library.
we envision the long term impact of this work to be twofold.
first developersofconcurrentsoftwarecanuseourapproachto decideifandhowtousethird partyclasses.second webelievethat thetechnicalcontributionofthispaper combininglightweight staticanalysisandgraph basedclassification generalizestoother problems.forexample futureworkcouldadapttheideatoother class levelproperties suchasimmutability andtoothercodeproperties such as whether a piece of code suffers from a particular kind of bug.