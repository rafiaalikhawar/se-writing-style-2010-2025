putback based bidirectional model transformations xiao he school of computer and communication engineering university of science and technology beijing beijing china hexiao ustb.edu.cnzhenjiang hu national informatics institute the university of tokyo tokyo japan hu nii.ac.jp abstract bidirectional model transformation bx plays a vital role in modeldriven engineering.
a major challenge in conventional relational andbidirectionalization based bx approaches is the ambiguity issue i.e.
the backward transformation may not be uniquely determined by the consistency relation or the forward transformation.
a promising solution to the ambiguity issue is to adopt putback based bidirectional programming which realizes a bx by specifying the backward transformation.
however existing putback based approaches do not support multiple conversions of the same node namely a shared node .
since a model is a graph shared nodes are very common and inevitable.
consequently existing putback based approaches cannot be directly applied to bidirectional model transformation.
this paper proposes a novel approach to bx.
we define a new model merging based bx combinator which can combine two bxs owning shared nodes into a well behaved composite bx.
afterwards we propose a putback based bx language xmu to address the ambiguity issue which is built on the model merging based bx combinator.
we present the formal semantics of xmu which can be proven well behaved.
finally a tool support is also introduced to illustrate the usefulness of our approach.
ccs concepts software and its engineering domain specific languages specification languages keywords bidirectional transformation model ambiguity shared node acm reference format xiao he and zhenjiang hu.
.
putback based bidirectional model transformations.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
this work was partially supported by the national key research and development program of china nos.
2017yfb0202303 2017yfb0202300 by the japan society for the promotion of science jsps grant in aid for scientific research s no.
17h06099 and by the national natural science foundation of china nos.
2015cb352200 .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
introduction in model driven engineering mde developers employ various models to capture different views of the system under development.
those models are probably interrelated and may evolve independently.
when one is updated the changes should be propagated to the related models.
how to keep these models synchronized is known to be a crucial issue in a round trip development.
it has been argued for a long time that bidirectional transformation bx could provide a software foundation for model synchronization.
a bx program is a single program but can be viewed as a pair of forward and backward transformations namely getand put respectively where getcreates a view model from a source model and putconverts a source model into an updated source model according to a view model.
we have seen good progress in bx and its application to model synchronization particularly in the theoretical foundation the languages and or the algorithms and the applications .
there are basically two approaches to writing bx.
one is to ask users to write a declarative consistency relation e.g.
qvt relations between models from which a suitable bx forward and backward transformations is derived and the other is to ask users to write a forward transformation in a traditional unidirectional language e.g.
atl or a domain specific language e.g.
lens from which a backward transformation is derived.
despite the promising features of bx for model synchronization there is a big issue that prevents it from being used in practice.
as argued in the existing bidirectional model transformation languages have inherited ambiguity in their semantics and they never provide any effective way to remove the ambiguity to gain full control of the synchronization behavior.
to be concrete consider the classic bidirectional model transformation between uml class diagrams to relational database namely uml2rdbms1.
we may ask the user to write a forward transformation in atl from which a backward transformation is derived or a more general flexible consistency relation in qvt from which both forward and backward transformations are derived.
the atl rule and the qvt relation are presented in figure .
in forward transformation a table is created for each non abstract class.
but what about the backward transformation?
there are many possibilities that cause ambiguity.
for instance if we delete a table and attempt to propagate the table deletion back to the class model we may either delete the class that corresponds to the deleted table or keep it by changing the class into an abstract one.
the existing approaches automatically return one as the result.
however if it is not the one we wish to have for the backward transformation behavior we have no way to specify our intention in atl or in qvt .
1theuml2rdbms transformation has been implemented using qvt and atl http esec fse november lake buena vista fl usa xiao he and zhenjiang hu atl rule rule classtotable from c uml!class c.isabstract false to t rdbms!table t.name c.name do inner updates qvt r rule relation classtotable cn string when packagetoschema p s domain uml p package classes c class name cn isabstract false domain rdbms s schema tables t table name cn where inner updates the first extended xmu rule rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates extension delete the unpaired class unmatchs delete c unmatchv enforce c uml!class the second extended xmu rule rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates unmatchs enforce c uml!class isabstract true extension check whether we can turn an abstract class into a non abstract one before creating a new class unmatchv switch p case p uml!package classes c uml!class name cn isabstract true enforce c uml!class isabstract false otherwise enforce c uml!class xmu rule rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates unmatchs enforce c uml!class isabstract true unmatchv enforce c uml!class pats and patv are defined as follows pats p uml!package classes c uml!class name cn isabstract false patv s rdbms!schema tables t rdbms!table name cn updatewithby pats patv index sc st index tc tt replace pats patv delete assoc condition p.classes exists sc sc.name sn do nothing enforce sc uml!class name sn condition p.classes exists tc tc.name tn do nothing enforce tc uml!class name tn enforce assoc uml!association name an source sc uml!class target tc uml!class ur ua b figure atl and qvt realization of classtotable fortunately we have an important fact about bx that is little known while there are generally many possible backward transformations for a forward transformation there is at most one forward transformation for a backward transformation without ambiguity.
in other words the essence of bidirectional transformation is nothing but putback backward transformation .
this putback based bx approach has been applied to build useful bidirectional transformations between tree like data .
inspired by the success of the putback based bx on tree like data we want to go further to see whether we can extend it to bidirectional model transformation where models are basically graphs that may contain shared nodes and cycles .
as a matter of fact the shared nodes introduce a new challenge.
consider the following two putback based backward transformation rules r1converts bacabdcdbacbdc into bacabdcdbacbdc given view node x and r2converts bacabdcdbacbdc into bacabdcdbacbdc given view node y. when the original source model is bacabdcdbacbdc and the view model consists of xandy we expect to convert the original source and the view model into bacabdcdbacbdc where the shared node ain the source model is converted twice by r1andr2.
it could not work if we would apply the two rules in a trivial sequential manner say one after another.
if r1is applied first then the intermediate output is bacabdcdbacbdcbdc which cannot trigger r2.
similarly if r2is applied first then the intermediate output is bacabdcdbacbdcbdcbdc which rejects r1.
to resolve this problem we carefully investigated the behavior of multiple rule applications on graphs and found that if we could merge bacabdcdbacbdcbdc and bacabdcdbacbdcbdcbdc well then we could get the expected result.
based on this observation we propose to treat multiple conversions of a shared node as independent bxs in each bx this node is converted with an index label and then merge their outputs.
in this paper we propose a novel bidirectional model transformation language xmu that can effectively handle both the ambiguity issue and the shared node issue.
xmu is a putback based bx language enabling developers to define a bx over models in the form of a backward transformation and automatically deriving the unique forward transformation from the backward transformation and thus avoiding the ambiguity issue .
in addition xmu is established on a new model merging based bx combinator rather than the existing parallel and sequential combinators supporting multiple conversions of the same node.
the main contributions of this paper are twofolds a model merging based bx combinator to address the shared node issue and xmu a putback based bx language for ambiguity free model synchronization.
the preliminary results showed the practical feasibility of our approach.the reminder of this paper is organized as follows section introduces the background and the related work of this paper section proposes the model merging based bx combinator section proposes xmu a bidirectional model transformation language section presents the formal semantics of xmu section introduces the tool support the last section concludes the paper and briefly discusses the future work.
background and related work .
background a bidirectional transformation bx can be viewed as a pair of a forward transformation getand a backward transformation put between two models.
the forward and backward transformations getandput can be defined symmetrically or asymmetrically .this paper mainly focuses on asymmetric bxs because in theory a symmetric bx can be composed of two asymmetric bxs.
without loss of generality getandputcan be defined as follows et s v put s v s where getreads a source model of type metamodel s and creates a view model of type metamodel v and putyields an updatedsource model by taking the original source and an updated view model as inputs.
a bx is well behaved if it satisfies the following round trip properties ets puts ets s getput puts v et puts v v putget puts v put puts v v puts v puttwice where denotes a runtime error or an undefined value in this paper.
thegetput property says that if getsucceeds then no update on the view leads to no update on the source the putget property says that if putsucceeds then update on the view should be fully put back to the source such that the updated view can be recovered from the updated source and the last puttwice property which is derivable from the getput andputget properties says that putting back twice has the same effect of putting back once.
one important fact that is used in this paper as formally proven in is that if putis well defined then there is exactly one get that can be paired with the putto form a well behaved bx.
we say putis well defined iff.
s v put puts v v puts v puts is injective on view type and uncurry putis surjective on source type.
this is the foundation of the putback based bidirectional programming and the key to ambiguity issues.
.
related work diskin et al.
proposed an algebraic framework of model synchronization.
their work focused on the theoretical aspect of model synchronization e.g.
the correctness properties .
giese et al.
proposed an incremental model synchronization approach based on triple graph grammar tgg .
lauder et al.
also proposed tgg based incremental bx approach based on the node precedence analysis.
ehrig and hermann et al.
discussed the correctness of tgg based bx approaches.
lamo et al.
putback based bidirectional model transformations esec fse november lake buena vista fl usa proposed a graph grammar based bx approach which shares many ideas with tgg based approaches.
these approaches are typical relational bx approaches that cannot deal with ambiguity issues properly.
xiong el al.
proposed an atl based model synchronization framework.
they derive a backward transformation automatically from a forward atl transformation.
their approach imposed some restrictions on the transformation specification and view updating e.g.
element deletion is not allowed in the view model to avoid the ambiguity issue.
solvers are intensively used to realize bxs.
macedo et al.
proposed an alloy based approach that turns qvt relations and atl rules into bxs over models.
the basic idea is to encode qvt relations and atl rules into alloy constraints that can be solved by the alloy solver.
their approach uses a customizable graph edit distance ged or an operation based distance obd to guide the solver to find possible solutions.
semer th et al.
also proposed an alloy based backward change propagation approach.
they derive a backward change propagation operation from a model query.
cicchetti et al.
proposed a relational bx language named jtl and mapped jtl onto answer set programming.
in solverbased approaches developers may have to iterate the result sets returned by the solver to obtain the required result.
besides solverbased approaches usually do not scale.
some technologies such as those in support uncertainty andvariability in bxs.
those approaches can be adapted for dealing with the ambiguity issue by asking the user to pick a required result from a number of candidates.
there are also some research efforts in bidirectional transformation on tree like data formats such as xml.
bixid is a relationbased bidirectional xml transformation language .
however bixid cannot handle ambiguity and shared node issues.
biflux is a putback based bidirectional xml transformation language .
bigul is a general purpose putback based bx language which is a revision of the core of biflux .biflux and bigul enable us to specify put i.e.
how to update a source according to a view.
afterwards a unique getcan be computed automatically from put.
biflux and bigul are free from the ambiguity issue but they do not support multiple conversion of the same node in a graph.
so they cannot handle shared nodes well.
in summary the state of the art approaches to bx over models cannot avoid the ambiguity issue.
existing ambiguity free bx approaches are mainly designed for tree structures and do not handle shared graph nodes properly.
model merging based bx combination this section address the shared node issue in bidirectional model graph transformation as discussed in the introduction.
the basic idea of our solution is to treat the multiple conversions transformations of the same node as independent component bxs each of which converts this node only once.
these component bxs are then combined by merging their outputs.
in this way a bx over models suffering from the shared node issue can be viewed as a combination of component bxs which do not suffer from the shared node issue.
this section proposes a model merging based bx combinator.
.
metamodel model and merging we start by explaining metamodels models and model merging used in this paper.
generally a metamodel written as a b etc .
describes a type of graphs and a model written as a b etc .
is viewed as a typed graph that confirms to a metamodel.
concretely a model consists of objects e.g.
o1 o2 and links e.g.
l1 l2 .
we assume that typeof is a function that can return the type of an object or a link i.e.
a class or a relationship defined in a metamodel .
in this paper a model mis regarded as a typed graph with indices in which each object is associated with a set of indices.
index m o returns the indices of o.object m i returns the object in mthat owns the index i. we assume that each index appears once i.e.
o1 o2 o1 o2 index m o1 index m o2 .
we do not assume that indices are persistent attributes.
they can be transient information that is maintained at runtime by bxs.
given two models aandb we say a bifbcontains all objects including attribute values and links in a and we say a biff a b b a. we identify two types of model merging denoted by and .
one is the three way model merging m1 m0m2 denoting merging m1andm2based on a common model m0.
the basic idea is to compute the delta i.e.
changes 1and 2from m0tom1and m2 respectively.
then we compute the result by applying both 1 and 2tom0.
intuitively three way model merging will preserve all the changes from m0tom1andm2 i.e.
m1 m1 m0m2 m2 m1 m0m2 when there is no conflict.
it is not difficult to verify that m mm mandm m m. to determine which objects in m1 andm2should be merged and to calculate the delta we use object indices to align models and objects.
if index a o index b o then oando are aligned.
we may define other alignment strategies e.g.
using key properties as indices to extend .
it is our future work to investigate other possibilities.
the three way merging may fail when there is a conflict.
for example assuming that a link l l o o and an object osatisfy l m1 l m0ando m0 o m2 m1 m0m2fails namely m1 m0m2 because ois required to be preserved by m1but is deleted in m2.
the other type of model merging is the additive merging m1 m0 denoting merging m1intom0.
for every object o m1 if there exists o0 m0andindex m1 o index m0 o0 then replace o0with o and preserve all compatible attributes and links otherwise add oto the result.
for each link l m1 merge copy lto the result.
obviously m1 m1 m0.
.
a model merging based combinator now we show how to lift the model merging operation from models to bxs which is the key step towards our put based bidirectional model transformation.
as required in for a well defined put puts vmust be injective for all v i.e.
all information in the view should appear in the new updated source.
in this paper we relax this condition because we intend to allow a putto use part of the view to convert the source model and leave the unused information to other bxs.
for anyput s v s we assume that there exists a function core s v vto capture the partial view from the current esec fse november lake buena vista fl usa xiao he and zhenjiang hu source and view core s v v which should satisfy the following properties puts v puts core s v core s v core puts v v intuitively core extracts the necessary view information needed byput.
note that such function core always exists because we can know from putwhat view information is needed.
we refine the original putget intoputget as follows puts v et puts v core s v putget where denotes graph isomorphism.
if a bx satisfies putget law it is not difficult to verify that the following condition also holds v1 v2 core s v1 core s v2 puts v1 puts v2 .
this condition is the refined condition for injective put.
we can also prove that under the new definitions and conditions the uniqueness ofget2for a well behaved putstill holds.
in brief due to the uncurry putis surjective on source and puttwice for any s there must exist a certain vthat makes puts v s. afterwards we can define ets core s v where vsatisfies puts v s i.e.
the existence .
furthermore for any s we choose vsuch that puts v s. if there is another get that can be paired with this put due to putget et s et puts v core s v ets i.e.
the uniqueness .
we are now ready to define our model merging based bx combinator to combine two bxs bx1 et1 put andbx2 et2 put into a composite bx bx bx1 bx2 et put as follows ets et1s et2s puts v put 1s v sput 2s v the core function of bxis defined as core 1s v core 2s v where core 1andcore 2are core functions of bx1andbx2.
note that bx1 andbx2can be successfully combined only when the following equations hold for any sandv i putis etis putis et1s et2s core i putis v v core i put 1s v sput 2s v v puti put 1s v sput 2s v v put 1s v sput 2s v core is v core is core 1s v core 2s v et1 put 1s v et2 put 2s v core 1s v core 2s v now we can prove that a composite bx that is constructed by using is also well behaved i.e.
theorem .
.
theorem .
correctness of .given two well behaved bxs namely bx1andbx2 and their core functions namely core 1and core when equations hold bx bx1 bx2is a well behaved bx and the core function of bx i.e.
core 1s v core 2s v satisfies equations .
in brief equations and ensure that the composite core function works properly and equations and ensure that the composite bx is well behaved.
due to space limitation the details of the proof are omitted in this paper and are presented at our project website3.
2getis unique in terms of graph isomorphism.
abcxyview vsource sput1dbcupdated sources s1 and s2 intermediate updated source final put2d1bcd2bcs1 ss2 latexit sha1 base64 c92 h bm09wqrxt38d7bx8ofoji aaae73iclvrfaxqxee bu v5p1d99cw4cbwk3f4f9a0oii8vpfu4pzzsdvyuxda7jrn3puo hw8ivij4tfwkfhuze1fwtkvoygey8 v9zjkzsvjkybdf 7o1vdo5cfpw7u3unbv37u 19h98newloqx5iqt9ljaduigyokajz6uglicstppzmzp ogdtrke 4lkecc4msmscm suunczcuijqpsviq018sdubf3dfrpozsncgwfzr5n4f d3lba8ykehl8yyudgvcwyzrselug5ugsgzn7ejjlypwa5mbjvshx3ipsnncu0 hbtx suwlddmmscemtocmnasdl4zm5gzvdtpvcfrhdnlsrwqrbaux1wrvzjiqesm0vro4cix3mbcc38qyqdmm46 lrtpriztuk7bjrqsejhntku2uki6gygci6ktn24z7qc1c6pb2ftmtstyihtpbdbwkw72lthqkyoegbsdjw2nxq mrqv0ia3ycd5vtnrgyfnnk0ne4tiautrjau2wakoirvngo6mn6qq2izt7y41cd4qa6vgnqdc3vi8lgvez7efzusnrlafotrmjlwav73ktcdet74nzf9emfrpswsaqyvqplkns0amjkrpf xkgdfwpq v616yn52322txy2sjt099ej ls0aa vgz9tlhr6uwx6qnqdokxqp9g5fvklyy5rop83q bn 2ymrwcvjom3z8pjg wj8aueuqekwmskhfkmlwjj2riojmtr qh dnrns db53vk j21przkgyszq tpk7wa latexit latexit sha1 base64 c92 h bm09wqrxt38d7bx8ofoji aaae73iclvrfaxqxee bu v5p1d99cw4cbwk3f4f9a0oii8vpfu4pzzsdvyuxda7jrn3puo hw8ivij4tfwkfhuze1fwtkvoygey8 v9zjkzsvjkybdf 7o1vdo5cfpw7u3unbv37u 19h98newloqx5iqt9ljaduigyokajz6uglicstppzmzp ogdtrke 4lkecc4msmscm suunczcuijqpsviq018sdubf3dfrpozsncgwfzr5n4f d3lba8ykehl8yyudgvcwyzrselug5ugsgzn7ejjlypwa5mbjvshx3ipsnncu0 hbtx suwlddmmscemtocmnasdl4zm5gzvdtpvcfrhdnlsrwqrbaux1wrvzjiqesm0vro4cix3mbcc38qyqdmm46 lrtpriztuk7bjrqsejhntku2uki6gygci6ktn24z7qc1c6pb2ftmtstyihtpbdbwkw72lthqkyoegbsdjw2nxq mrqv0ia3ycd5vtnrgyfnnk0ne4tiautrjau2wakoirvngo6mn6qq2izt7y41cd4qa6vgnqdc3vi8lgvez7efzusnrlafotrmjlwav73ktcdet74nzf9emfrpswsaqyvqplkns0amjkrpf xkgdfwpq v616yn52322txy2sjt099ej ls0aa vgz9tlhr6uwx6qnqdokxqp9g5fvklyy5rop83q bn 2ymrwcvjom3z8pjg wj8aueuqekwmskhfkmlwjj2riojmtr qh dnrns db53vk j21przkgyszq tpk7wa latexit latexit sha1 base64 c92 h bm09wqrxt38d7bx8ofoji aaae73iclvrfaxqxee bu v5p1d99cw4cbwk3f4f9a0oii8vpfu4pzzsdvyuxda7jrn3puo hw8ivij4tfwkfhuze1fwtkvoygey8 v9zjkzsvjkybdf 7o1vdo5cfpw7u3unbv37u 19h98newloqx5iqt9ljaduigyokajz6uglicstppzmzp ogdtrke 4lkecc4msmscm suunczcuijqpsviq018sdubf3dfrpozsncgwfzr5n4f d3lba8ykehl8yyudgvcwyzrselug5ugsgzn7ejjlypwa5mbjvshx3ipsnncu0 hbtx suwlddmmscemtocmnasdl4zm5gzvdtpvcfrhdnlsrwqrbaux1wrvzjiqesm0vro4cix3mbcc38qyqdmm46 lrtpriztuk7bjrqsejhntku2uki6gygci6ktn24z7qc1c6pb2ftmtstyihtpbdbwkw72lthqkyoegbsdjw2nxq mrqv0ia3ycd5vtnrgyfnnk0ne4tiautrjau2wakoirvngo6mn6qq2izt7y41cd4qa6vgnqdc3vi8lgvez7efzusnrlafotrmjlwav73ktcdet74nzf9emfrpswsaqyvqplkns0amjkrpf xkgdfwpq v616yn52322txy2sjt099ej ls0aa vgz9tlhr6uwx6qnqdokxqp9g5fvklyy5rop83q bn 2ymrwcvjom3z8pjg wj8aueuqekwmskhfkmlwjj2riojmtr qh dnrns db53vk j21przkgyszq tpk7wa latexit latexit sha1 base64 c92 h bm09wqrxt38d7bx8ofoji aaae73iclvrfaxqxee bu v5p1d99cw4cbwk3f4f9a0oii8vpfu4pzzsdvyuxda7jrn3puo hw8ivij4tfwkfhuze1fwtkvoygey8 v9zjkzsvjkybdf 7o1vdo5cfpw7u3unbv37u 19h98newloqx5iqt9ljaduigyokajz6uglicstppzmzp ogdtrke 4lkecc4msmscm suunczcuijqpsviq018sdubf3dfrpozsncgwfzr5n4f d3lba8ykehl8yyudgvcwyzrselug5ugsgzn7ejjlypwa5mbjvshx3ipsnncu0 hbtx suwlddmmscemtocmnasdl4zm5gzvdtpvcfrhdnlsrwqrbaux1wrvzjiqesm0vro4cix3mbcc38qyqdmm46 lrtpriztuk7bjrqsejhntku2uki6gygci6ktn24z7qc1c6pb2ftmtstyihtpbdbwkw72lthqkyoegbsdjw2nxq mrqv0ia3ycd5vtnrgyfnnk0ne4tiautrjau2wakoirvngo6mn6qq2izt7y41cd4qa6vgnqdc3vi8lgvez7efzusnrlafotrmjlwav73ktcdet74nzf9emfrpswsaqyvqplkns0amjkrpf xkgdfwpq v616yn52322txy2sjt099ej ls0aa vgz9tlhr6uwx6qnqdokxqp9g5fvklyy5rop83q bn 2ymrwcvjom3z8pjg wj8aueuqekwmskhfkmlwjj2riojmtr qh dnrns db53vk j21przkgyszq tpk7wa latexit figure example of merging based combinator consider the shared node example in the introduction as shown in figure .
the original source must be converted by the two rules r1andr2 i.e.
put 1andput simultaneously as explained previously.
after applying put 1andput we get two intermediate results namely s1ands2.s1ands2contain two d elements namely d1andd2 respectively which were created during put 1andput .
if we assign the same index to d1andd2 then by using our modelmerging based bx combinator we finally obtain the expected output and the putget law holds.
xmu a bidirectional model transformation language this section proposes a novel bidirectional model transformation language namely xmu which extends the putback bx approach with the unique model merging based bx combination.
xmu is a rule based language.
the main concrete syntax of xmu is listed in figure .
an xmu rule is defined as a sequence of formal parameters and a body statement.
each formal parameter is declared as a source view normal variable associated with a type for a normal variable its type can only be a primitive type .
xmu statements which are bidirectional include update with by switch case and rule call statements.
an update with by statement which aligns the matches of source and view patterns first has at most three clauses to indicate how to construct the updated source model according to the result of alignment.
a switch case statement consists of some branches.
a branch condition can be a pattern or a boolean expression.
unidirectional statements ustmt of xmu include enforce delete node link and unidirectional switch case statements.
an enforce statement is responsible to construct the updated source model while a delete statement is used to delete an object or a link from the updated source model.
a unidirectional switch case statement is similar to its bidirectional version however its branch actions must be unidirectional statements.
the definition of a model pattern its syntax and meaning in xmu is similar to that in qvt .
a pattern consists of a set of nodes and expressions.
in the implementation we extend the syntax presented in figure with some syntax sugar and variants to ease the bx specification.
figure also omits some common language constructs that are shared by existing programming languages such as basic arithmetic relational and boolean expressions.
putback based bidirectional model transformations esec fse november lake buena vista fl usa take the classic conversion between classes and tables as an example.
figure shows the xmu rule for this conversion which corresponds to the atl rule and qvt relation presented in figure .
this xmu rule can be read as follows update each non abstract class cwithin package pwith a table twhose table name is identical to the class name within schema s ifcis paired with t then perform the inner updates i.e.
the match clause if ccannot be paired with any table then turn cinto an abstract class i.e.
the unmatchs clause if tcannot be paired with any class then create a new class cthat is intended to be paired with tto continue the conversion i.e.
the unmatchv clause .
by comparing figure with figure we can easily discover the syntactic correspondence between xmu atl and qvt.
nevertheless xmu is semantically different from atl and qvt because an xmu rule specifies the backward transformation rather than a forward transformation or a consistency relation between source and view.
from the backward transformation our approach is able to derive the unique forward transformation from source to view.
for instance in the forward direction the behavior of the xmu rule classtotable is identical to that of the atl and qvt rules in figure this xmu rule creates a table for each non abstract class.
in the forward semantics the update with by statement can be roughly viewed as the from to structure in atl.
elimination of ambiguity.
a benefit of xmu is that it allows developers to explicitly specify the behavior of putto avoid the ambiguity issue.
compared with other bx technologies xmu provides developers with better control over their bxs.
for example the xmu rule in figure can be substituted with either of the two rules in figure .
the first alternative rule will delete the unpaired class rather than turning it into an abstract one.
the second alternative rule will try to find and change an abstract class into a non abstract one before creating a new class for an unpaired table.
note that forward transformations which are derived from the initial xmu rule in figure and the two alternative rules in figure are identical to each other.
if we specify this rule as a mapping or a relation we are unable to tell the transformation engine which backward semantics is required and the ambiguity issue arises.
addressing shared nodes.
consider a more complicated conversion between associations and foreign keys.
we define an xmu ruledef rulerulename fpars vardec stmt fpars fpars fpars sourcev type viewv type v typevardec vardec vardec v type stmt updatepatswithpatvbyclause switch v case stmtwhere index rulename apars stmt1 stmt2 stmt clause clause clause match stmt unmatchs ustmt unmatchv ustmtcase case case casepat stmt caseboolexp stmtindex index index index vs vv apars apars apars exprustmt enforcepats deletev deletev.feature expr switch v ucase ustmt1 ustmt2 ustmt ucase ucase ucase casepat ustmt caseboolexp ustmtpat patnodepatnode v type patexp patexp feature patnode feature expr patexp patexpexpr constant v latexit sha1 base64 qla20qaiex3souodare2ttv783i aaaimniclvvbaxnbfn5wbwks2ir6og dxuskmsr9usqv0lzqhflptcigmds72yzdgzozaunc j3 ax hz2b2kmws0iu2m9 5f fmjb37hhedzu v1xv3h6zv6g8bj9yfp3m6sfnskkcji scrh7eftiyu98l6yxwhe9 xiziwpbplx1zjovxi8q4f4xnyhztfocvq8 1cbyadtbxflk9y6bxxjgr2e58zniji37asibszcnkiu pqwui7b29 w1kwolecsemek8tjh9oceatlauagloxzryedtj8zu3sewbhlfiii0aucjqaltuwlv0rqukllts2kfntldprxibwlcn7qsy1ojby6o1spv6ohhelsj 25xvlfjr3isg8lbxwrip2 e6jrlbwre3rfjlj7gahs4ixgjyvjd96ypihlyvqjwejpk54tuyobmtytiscdobwaunrirrjb1vzwn vitlmkdkkwm4lhxo3bahj5r1vytmlnqyvpgbdsli1362kb05v21g173kxga96u6tgaeoj6n0nph1vpemo5fwrjgdsy67givkoomxkxspkseofzyuiid2ckrxlaww6dht59c5epc jksalwdp8t9jmoonwydduaw nbmxtnal45jcpxekntx0kyigpc81adthp6eb6gknprktguj q0r0tferio3upfgkrpne zupp92bhkcdhlvnwivxe09onguxjpyrz86f8fltpkcgd 63nmrr aho5becsca3rk8ihoa7wcnczliy5w6awup4mmaapyxwabjye5jpqrjgpl5crdum6zmo0spgqv62vryfryauorezzjfwy98siovo8na2r3xhsbhxahfwh uu3w2wz2xc62fxztzyijaenbvwqnpe6nvj0j5gjj8cb1ldgzogxuchxtafleo4q3p opzjfbwfxeaw0 egccp22moca83fggybcdunelulwoqwomwzj5iws9hlhfujday0tquois3ath4kiyt4ix2ouch8mc0yyb4ugmsqmewfp90wyzxvdgqbawrfk0fzicrfd7bs733e3dg4z urgk on0ts6xnvjwphinboxbln7u1uvvai9rl uh9a 1r9p1dwvzoa5mfpvz 8cjnnifa latexit latexit sha1 base64 qla20qaiex3souodare2ttv783i aaaimniclvvbaxnbfn5wbwks2ir6og dxuskmsr9usqv0lzqhflptcigmds72yzdgzozaunc j3 ax hz2b2kmws0iu2m9 5f fmjb37hhedzu v1xv3h6zv6g8bj9yfp3m6sfnskkcji scrh7eftiyu98l6yxwhe9 xiziwpbplx1zjovxi8q4f4xnyhztfocvq8 1cbyadtbxflk9y6bxxjgr2e58zniji37asibszcnkiu pqwui7b29 w1kwolecsemek8tjh9oceatlauagloxzryedtj8zu3sewbhlfiii0aucjqaltuwlv0rqukllts2kfntldprxibwlcn7qsy1ojby6o1spv6ohhelsj 25xvlfjr3isg8lbxwrip2 e6jrlbwre3rfjlj7gahs4ixgjyvjd96ypihlyvqjwejpk54tuyobmtytiscdobwaunrirrjb1vzwn vitlmkdkkwm4lhxo3bahj5r1vytmlnqyvpgbdsli1362kb05v21g173kxga96u6tgaeoj6n0nph1vpemo5fwrjgdsy67givkoomxkxspkseofzyuiid2ckrxlaww6dht59c5epc jksalwdp8t9jmoonwydduaw nbmxtnal45jcpxekntx0kyigpc81adthp6eb6gknprktguj q0r0tferio3upfgkrpne zupp92bhkcdhlvnwivxe09onguxjpyrz86f8fltpkcgd 63nmrr aho5becsca3rk8ihoa7wcnczliy5w6awup4mmaapyxwabjye5jpqrjgpl5crdum6zmo0spgqv62vryfryauorezzjfwy98siovo8na2r3xhsbhxahfwh uu3w2wz2xc62fxztzyijaenbvwqnpe6nvj0j5gjj8cb1ldgzogxuchxtafleo4q3p opzjfbwfxeaw0 egccp22moca83fggybcdunelulwoqwomwzj5iws9hlhfujday0tquois3ath4kiyt4ix2ouch8mc0yyb4ugmsqmewfp90wyzxvdgqbawrfk0fzicrfd7bs733e3dg4z urgk on0ts6xnvjwphinboxbln7u1uvvai9rl uh9a 1r9p1dwvzoa5mfpvz 8cjnnifa latexit latexit sha1 base64 qla20qaiex3souodare2ttv783i aaaimniclvvbaxnbfn5wbwks2ir6og dxuskmsr9usqv0lzqhflptcigmds72yzdgzozaunc j3 ax hz2b2kmws0iu2m9 5f fmjb37hhedzu v1xv3h6zv6g8bj9yfp3m6sfnskkcji scrh7eftiyu98l6yxwhe9 xiziwpbplx1zjovxi8q4f4xnyhztfocvq8 1cbyadtbxflk9y6bxxjgr2e58zniji37asibszcnkiu pqwui7b29 w1kwolecsemek8tjh9oceatlauagloxzryedtj8zu3sewbhlfiii0aucjqaltuwlv0rqukllts2kfntldprxibwlcn7qsy1ojby6o1spv6ohhelsj 25xvlfjr3isg8lbxwrip2 e6jrlbwre3rfjlj7gahs4ixgjyvjd96ypihlyvqjwejpk54tuyobmtytiscdobwaunrirrjb1vzwn vitlmkdkkwm4lhxo3bahj5r1vytmlnqyvpgbdsli1362kb05v21g173kxga96u6tgaeoj6n0nph1vpemo5fwrjgdsy67givkoomxkxspkseofzyuiid2ckrxlaww6dht59c5epc jksalwdp8t9jmoonwydduaw nbmxtnal45jcpxekntx0kyigpc81adthp6eb6gknprktguj q0r0tferio3upfgkrpne zupp92bhkcdhlvnwivxe09onguxjpyrz86f8fltpkcgd 63nmrr aho5becsca3rk8ihoa7wcnczliy5w6awup4mmaapyxwabjye5jpqrjgpl5crdum6zmo0spgqv62vryfryauorezzjfwy98siovo8na2r3xhsbhxahfwh uu3w2wz2xc62fxztzyijaenbvwqnpe6nvj0j5gjj8cb1ldgzogxuchxtafleo4q3p opzjfbwfxeaw0 egccp22moca83fggybcdunelulwoqwomwzj5iws9hlhfujday0tquois3ath4kiyt4ix2ouch8mc0yyb4ugmsqmewfp90wyzxvdgqbawrfk0fzicrfd7bs733e3dg4z urgk on0ts6xnvjwphinboxbln7u1uvvai9rl uh9a 1r9p1dwvzoa5mfpvz 8cjnnifa latexit figure concrete syntax of xmu atl rule rule classtotable from c uml!class c.isabstract false to t rdbms!table t.name c.name do inner updates qvt r rule relation classtotable cn string when packagetoschema p s domain uml p package classes c class name cn isabstract false domain rdbms s schema tables t table name cn where inner updates the first extended xmu rule rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates extension delete the unpaired class unmatchs delete c unmatchv enforce c uml!class the second extended xmu rule rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates unmatchs enforce c uml!class isabstract true extension check whether we can turn an abstract class into a non abstract one before creating a new class unmatchv switch p case p uml!package classes c uml!class name cn isabstract true enforce c uml!class isabstract false otherwise enforce c uml!class xmu rule rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates unmatchs enforce c uml!class isabstract true unmatchv enforce c uml!class pats and patv are defined as follows pats p uml!package classes c uml!class name cn isabstract false patv s rdbms!schema tables t rdbms!table name cn updatewithby pats patv index sc st index tc tt replace pats patv delete assoc condition p.classes exists sc sc.name sn do nothing enforce sc uml!class name sn condition p.classes exists tc tc.name tn do nothing enforce tc uml!class name tn enforce assoc uml!association name an source sc uml!class target tc uml!class ur ua bfigure xmu rule classtotable rule assoctofkey as shown in figure to update each association between two classes with a foreign key between two tables.
if an association cannot be paired with any foreign key we must delete this association.
if a foreign key cannot be paired with any association we must create an association.
before creating a new association we must check whether the related classes exist in the source model and create the absent class es if necessary to ensure the successful creation of this association.
the execution of an xmu program is based upon the modelmerging based bx combination.
informally each xmu statement rules e.g.
an update with statement is viewed as a primitive bx.
a sequence of xmu statements rules are combined by defined in section .
however when an object is converted multiple times the shared issue may arise and the bx combination may fail.
assume that we merge the xmu rules classtotable in figure and assoctofkey in figure i.e.
classtotable assoctofke y .
given the source model m0and the view model as shown in figure we obtain two updated source models m1andm2by applying classtotable andassoctofkey respectively.
although a human can easily know that class s3inm1and class s4inm2are conceptually identical they are both derived from table t3 the model merging operator will treat them as two distinct objects because they have different indices.
consequently m1 m0m2will contain three classes and the combination of classtotable andassoctofkey is invalid putget law will be violated .
atl rule rule classtotable from c uml!class c.isabstract false to t rdbms!table t.name c.name do inner updates the first alternative rule rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates delete the unpaired class unmatchs delete c unmatchv enforce c uml!class qvt r rule relation classtotable cn string when packagetoschema p s domain uml p package classes c class name cn isabstract false domain rdbms s schema tables t table name cn where inner updates the second alternative rule rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates unmatchs enforce c uml!class isabstract true check whether there is an abstract class that can be turned into a non abstract one before creating a new class unmatchv switch p case p uml!package classes c uml!class name cn isabstract true enforce c uml!class isabstract false otherwise enforce c uml!class xmu rule rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates unmatchs enforce c uml!class isabstract true unmatchv enforce c uml!class figure alternative xmu rules to classtotable esec fse november lake buena vista fl usa xiao he and zhenjiang hu s1 packages2 classname a isabstract falseclasses t1 schemat3 tablename b tablest2 tablename a tablest4 foreignkeyname r foreignkeysrefertos1 packages2 classname a isabstract falseclassess3 classname b isabstract falseclasses s1 packages2 classname a isabstract falseclassess4 classname b s5 associationname r associationssourcetargetclasstotable assoctofkeyduplicateviewm0sourcem1updated source m2updated sourceclassesrule assoctofkey source p uml!package view s rdbms!schema sn tn an string update p uml!package associations assoc uml!association name an source sc uml!class name sn target tc uml!class name tn with s rdbms!schema tables st rdbms!table name sn foreignkeys f foreignkey name an referto tt rdbms!table name tn by match unmatchs delete assoc unmatchv switch p case p uml!package classes sc uml!class name sn otherwise enforce sc uml!class name sn switch p case p uml!package classes tc uml!class name tn otherwise enforce tc uml!class name tn enforce assoc uml!association name an source sc uml!class target tc uml!class figure rule assoctofkey to ensure that works properly xmu provides an index function to compute object indices.
for instance during the backward transformation index c t computes an extra index iaccording to the indices of candtand maps ionto cin the result.
if the index of cis unused in the source model its index is treated as nil during the computation.
in forward transformation index c t computes and maps an index onto taccording to the index of c. figure shows the use of the index function.
we add some index functions within where clauses appended to the match branches.
when constructing the updated source models from the same source and view in figure we compute an extra index for each class the extra index computed by the index function is denoted as the concatenation of the function parameters .
class s3inm1 and class s4inm2are mapped onto the same index namely nil t3 since neither s3nors4exists in m0 .
in this way m1 m0m2will contain only two classes and classtotable assoctofke yis valid.
it is worthwhile to notice that rule classtotable and rule assoctofkey cannot be applied sequentially.
otherwise we will not get the expected result.
as shown in figure assume that the original source model m0contains two classes namely aandb that are connected by an association r the view model contains table duplicatet1 schemat3 tablename b tablest2 tablename a tablest4 foreignkeyname r foreignkeysrefertoviews1 packages2 classname a isabstract falseclassesm0sources1 packages2 classname a isabstract falseclassess3 classname b isabstract falseclassesm1updated source s1 packages2 classname a isabstract falseclassess4 classname b s5 associationname r associationssourcetargetm2updated sourceclassesclasstotable assoctofkeyrule assoctofkey source p uml!package view s rdbms!schema sn tn an string update p uml!package associations assoc uml!association name an source sc uml!class name sn target tc uml!class name tn with s rdbms!schema tables st rdbms!table name sn foreignkeys f foreignkey name an referto tt rdbms!table name tn by match unmatchs delete assoc unmatchv switch p case p uml!package classes sc uml!class name sn otherwise enforce sc uml!class name sn switch p case p uml!package classes tc uml!class name tn otherwise enforce tc uml!class name tn enforce assoc uml!association name an source sc uml!class target tc uml!class figure a shared node issue in uml2rdbms rule assoctofkey source p uml!package view s rdbms!schema sn tn an string update p uml!package associations assoc uml!association name an source sc uml!class name sn target tc uml!class name tn with s rdbms!schema tables st rdbms!table name sn foreignkeys f foreignkey name an referto tt rdbms!table name tn by match where index sc st index tc tt ... rule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates where index c t ... mergeables1 packages2 s2 t2 classname a isabstract falseclassess3 nil t3 classname b isabstract falseclassesm1updated sourcem2updated sources1 packages2 s2 t2 classname a isabstract falseclassess4 nil t3 classname b s5 associationname r associationssourcetargetclassesfigure index computation s1 packages2 classname a isabstract falseclassess1 packages2 classname a isabstract falseclassess3 classname b isabstract falseclasses assoctofkeyduplicatet1 schemat2 tablename a tablesview m0sourcem1updated sources1 packages2 classname a isabstract falseclassess3 classname b s4 associationname r associationssourcetargetm0sourceclassesclasstotables1 packages2 classname a isabstract falseclasses s4 associationname r associationssourcem1updated source figure assoctofkey will fail after classtotable aonly and table band the foreign key from table ato table bwere removed please refer to the view model as shown in figure .
if we apply classtotable against m0in the backward direction first then we get an intermediate updated source m1in which class b was removed.
however in this case we cannot continue to perform assoctofkey backward against m1because the source pattern of the update statement in assoctofkey as shown in figure cannot be matched.
this source pattern matches an association that connects two classes while in m1in figure the association rconnects class aonly.
the final result which is equal to m1and contains class aand an unwanted association r is incorrect.
the only way of obtaining the expected result is to combine classtotable and assoctofkey by using our model merging based bx combinator i.e.
applying classtotable andassoctofkey against m0in parallel and then merging the two results.
putback based bidirectional model transformations esec fse november lake buena vista fl usa b updatewithbypatspatvbucur ifthenelsefb1b2u enforcepats replacepatspatv matchspatsb matchvpatvb deletev deletevf e a t u r ee indexvsvvb p e1 .
.
.
en b1 b2 conditioneu1u2 u1 u2 latexit sha1 base64 ql0ba3p ycidlhixqlbv2qg40nc aaag5niclvtnjts2efacxkndn2tbyy9e7qybygfyziffiglbfg1y6gglzh8a0xaoamqtpiivphbx1fiveihq5jac8hj9gx76cr31utquvlu2vciwbeqnh9 3zwigvfxiyexo9m dzt2p7nxvp i498mnn33 8nhof0cmlzwhq57lxj eziaucg6tsbjocg0siyucx4sf p7xkwgjcvxglguyzmymrco4s ikdjr3aawzosrl4liy7srn5qu rkfnxrq3iafkmxn hucb9tcubw2kouewtgwdr6 djquzeavm9crjtelzct9pcm5oossjni3c1a sgnisrexhx4ae 1beumuugmon3kzyebpj baxmwaram1fjjda68ywquemcvnr68r8fbukbv bj9ne2cttaisri9yukfed6fabkmbemiyfuy2khuqgxop9mmcrgqgcge7eiv7w fwdyl1phb5cq1y37lvpbay4rlkho8maokveuincs1qrgug0ye16isflvx1pxruhw1h9sdbrrgy i9 vovf4mgoih27v5nk5yxgsjljtnmeo4ko62ytojlwnntgigyx7aztnbulamzreod68g36ekinhcfzuntxwduldnmmcwixm7mtxvpo2 cmzzjeqmtmzynpu2 nwl5i9kc4k0wasmjzym giqrgrivszqy11hstvicacytxqcnmck1ejjdr0cvnpe8yxjwkiohxxvzbr9wm ty9owbjkdomtwtupvdt1f1x47qet2cwy0y0dnwk6ftymnpwcjsrbvtwgnepirclywtvf pqxwgh6ywswpwey z2i3rwthmdrq1pp4ndwwtd4qwm4qionv38iolqg wlou14leodusvndyrphguhqhpevpilb3g5smppkoflpuw0askvnfxxb0ikeozy 0xyek jftr1apnj8 b7jnbsnozpe1 ezvgi7m2ff8w9mvzq736nfiukhakl6j wciblfoys63j737yvunbxtf4gi6g4c 4e9gpmveg cr4otgnwubz8cj4frwehwhvym7vnxed991597fuh923dbrzz8x5mtgy3q ayuazyq latexit latexit sha1 base64 qsstoa3iqbhyos djmeazj arby aaag5niclvrpj m0fm922bkubxbgymwizturjaqme9jvrpbwg0acoazant9sxuwo89jadzys7cxmyvh8aw5iiamc bkcuxdgk3dlk afee46m206wmksxxl v1 u9o3ehhbgj0t93onffudd99 57vfcffpdhrw93pj4yeak5hpjc5vokzgakuhbohzvwumhgwszhof586fept0ebkavxdlnangmzjvlbmuvxtno5r2oycvvzfpesavdpli wct0696k9qtwgj8jz51 gpkawzq21vvkkzmkxspp9paokydz61byokikpkspuj03jbswxjjg nop6shpasoq4kptt2ospyhuigepz mzlaankewqhii4gzb2oozdsgnivyvrwjfk f3wnild3j9z1j hsmjhryrkqyh2u0w3yujsfzksnlect7soylaxqczx7te jdfuwldvyhsjcgw6hexcpx7xlv2jfeufwldrkiucqeb6bqam 6qgfxrvaus6atp uqq8uvhlv9ehhfzqc1ynsg hk6l 89o v3vhz8pop27f9mk52ugynljjjmeo8jok6at4blw9jqgcsyxbaytnbxlweyr sa68jl6eolnxudzunvxgrxljflmmskxm3pt3vpog emzzhe6usmzulp02dtlh9rwlc8ysitjbe58vedjeidt3kjbumas8ojnzpnumultbfgpbzpsuv1qiiznmczw1psjasrlsvtf25zh8u cjpxfc2mzhkqfuj2qv7yuv2vw3crrqz6bm7yzfp5lc0lwzqook14wituuxhtmln1n7jkyxdicrs0yj33ok deq0vbv6nuwvqedlanngnalljicbadwevwil6butswco h2q3 lldvcpj59qb8jsnjvbza2ye mgzwuhscqnnqoobf8fviqkpldhwfwgw9enctv6t2vt4vm0 uqu7puva9k9ve3xx1qbv34k oguov78t3xxstves9ramvemphthbov7uh 2bvm0cjyfhabh hz b aaz94npg8 c3samngyvg2 cg aw4b3z anza e37rz7y fn7i8nthnnxfkk2bjd3 8h xzpvw latexit latexit sha1 base64 kcrgsrr5iazrlobumfdy0xwyjao aaag5niclvtnjts2efacxk3cn2tbyy5e7qybygfyzqffiglbbi163clzh8a0bioa2yqpsiwp3xw1fiueahq9tic tl hb9ohpn215uwbjsbqopy b0yzpojccmmnk38f9b5 9kj 8emng08 ezzp8 2vjgxeak5hpnc5voszgakuhbshzvwvmhgwszhnf699fun56cnynv7uy5gnrgfeqngzkir2us9ojeshkosi0vjtks0l1f4uafdethbkb6rf t16 9xhlell9baqiwszufu2oxh2lfsmbu9a14nlmsulbh3k6bkipjrkkjfl0h9ia0gjuvcfppp6vvh5r1rqku5fuz1gbgla4idevcjsgnuueh2c7zjzcn4xixfvrtfxlu7j 72e3w2tzynmalisd7k rz5050cs6ugsqdj9gxzsvaobc492qdx3hym5y72iqopxupxautqze3yfwpz37m2ujtz8vwlwnctncfxpftttbyonwxq6znq 0pbjtddj54nj njpciuebbgmgjhubt38b a5lzmqfkumtgzcflyecw0fvwcnp7sqmh4ii1ghqzigzh5vr9yr75gt0kwufgos2rvjqnimthrleykdmzpunveeeeesrnta53cttkrbfrthmtflbyub7jis0lstvzviinqwk1co8g4xpjywpdmm27xam2feanfk wga6rggudzxrcwvanpquty 4xb3seyr9xsokelqyweahi6g2o4dvtx6w7capgbxocbvzpxhkvlqpymqmgthvaivrr kzmshq9c5ta4zivdg7doe5zx7ojwijav06g19tjpynu4c7tcleqqrbudvyxbfyn1kawrv0k1x3 p4v7lpxpdqhjk0xkr7dw2t37kgr10qysbjid1jyvj6hibvmoy678cs4yhovq3qy49vuyyz 7bti slv3h wrfxxtph egry4a6s3vxhefdfo8rv0prt6l1mgyxr1 98putd81tqbjcdiof54m3xy2f4hhwfpgq2a cinvgjfbt8frcbzwnux96p3z 6u 7p w rwptpwg5xwzbo 3fwepzd8 latexit figure core language of xmu semantics of xmu the concrete syntax of xmu in figure is designed for users but it would be too complex to define the semantics directly on it.
rather we propose a core language for xmu namely xmu core whose semantics is easier to define.
xmu core is defined in figure where bdenotes a bidirectional statement and udenotes a unidirectional statement.
the conversion between the concrete syntax of xmu and xmu core is straightforward as follows update with by is converted intoupdatewithby switch case is converted into ifthenelse a pattern used as a branch condition can also be viewed as a boolean condition where index is converted into index replace matchs andmatchv are used to realize bidirectional conversions implied by update with by andswitch case .
take rule assoctofkey as a concrete example.
the concrete syntax of assoctofkey has been presented in figure and figure .
this rule can be equivalently translated into an updatewithby statement in xmu core as shown in figure .
the bidirectional statement b of the updatewithby statement is a replace statement wrapped by two index statements.
the two unidirectional statements ua andurof the updatewithby statement are a delete statement and a chain of two condition s and an enforce statement.
atl rulerule classtotable from c uml!class c.isabstract false to t rdbms!table t.name c.name do inner updates qvt r rulerelation classtotable cn string when packagetoschema p s domain uml p package classes c class name cn isabstract false domain rdbms s schema tables t table name cn where inner updates the first extended xmu rulerule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates extension delete the unpaired class unmatchs delete c unmatchv enforce c uml!class the second extended xmu rulerule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates unmatchs enforce c uml!class isabstract true extension check whether we can turn an abstract class into a non abstract one before creating a new class unmatchv switch p case p uml!package classes c uml!class name cn isabstract true enforce c uml!class isabstract false otherwise enforce c uml!class xmu rulerule classtotable source p uml!package view s rdbms!schema cn string update p uml!package classes c uml!class name cn isabstract false with s rdbms!schema tables t rdbms!table name cn by match inner updates unmatchs enforce c uml!class isabstract true unmatchv enforce c uml!class pats and patv are defined as follows pats p uml!package classes c uml!class name cn isabstract false patv s rdbms!schema tables t rdbms!table name cn updatewithby pats patv index sc st index tc tt replace pats patv delete assoc condition p.classes exists sc sc.name sn do nothing enforce sc uml!class name sn condition p.classes exists tc tc.name tn do nothing enforce tc uml!class name tn enforce assoc uml!association name an source sc uml!class target tc uml!class ur ua b figure translation of rule assoctofkey an xmu transformation can be compiled into an xmu core program which can further be executed according to the semantics defined in figure .
it is worthwhile emphasizing that we do not claim that the core language we proposed is complete.
in fact xmu core should be further refined and extended to cover more application scenarios such as delta based bxs .
the reminder of this section will discuss the semantics of the core language in detail.
.
variable environment and pattern a variablevin xmu core is viewed as an identifier associated with a type.
a variable type can be a primitive type e.g.
integer or an index type if this variable will be pointed to an object .
an environment is a set of mappings from variables to values.
denotes the set of all environments.
we assume that v returnsthe value assigned to v and adds a mapping from vtoc.
besides v means that vis unassigned in .
in xmu core model patterns are used to find matches and to create model fragments.
xmu core adopts the conventional semantics of pattern matching and instantiation that is widely used in existing model transformation languages such as qvt .
we mainly explain some properties in this subsection.
we term an environment a match of a pattern patif all the variables occurring in pat namely pattern variables denoted by vars pat are assigned in and if the values assigned to pattern variables satisfy all the constraints implied by pat as explained in a pattern can be viewed as some constraints .
given an initial environment pat m returns all matches of a pattern patin a model mbased on .
each returned environment satisfies the condition v v vars pat v v v .
instantiating a pattern patbased on an environment denoted as m pat .new is to create a model fragment mthat matches pat using the information provided by .
obviously pattern matching and instantiation satisfy the following properties pat m m pat .new m m pat .new m pat m for simplicity given variable v if the type of vis the index type and v then we assume that is automatically replaced by during pattern instantiation where idxa fresh and unused object index.
.
unidirectional statements a unidirectional statement can convert a source model into an updated source model without considering the view model.
unidirectional statements will never be executed in the forward transformation.
given a unidirectional statement u u juk s s denotes the semantics of uunder the environment .
for an expression e the notation e val means given environment e evaluates to value valand a new environment .
if we do not care about the new environment we may say e val.
the semantics of unidirectional statements is discussed as follows.
enforce patsensures that a match of patsexists in the result.
if the given environment is not a match of pats this statement creates a new instance of patsand merge it into the source model i.e.
ujenforce patsk .
deletevremoves the object referenced by variable vfrom the model i.e.
ujdeletevk .
after the object removal the indices mapped onto the removed object cannot be mapped onto other objects again.
deletevf eature e removes an attribute value or a link from the model i.e.
ujdeletevf eature e k .
we also view attribute values as links for simplicity.
for the node link deletion if the node link does not exist in the input the output is identical to the input.
esec fse november lake buena vista fl usa xiao he and zhenjiang hu u jenforcepatsk s pat.new bs u ju1 u2k s let s0 u ju1k s inu 0ju2k s0 f jreplacepatspatvk s if pats s thenpatv.new else?endifb jreplacepatspatvk s v ifpats s patv v patv v 1thenselse if patv v pats s thenpats.new bselse?endif endiff jindexvsvvbk s letiv indexv vs v f jbk s invwhereivis mapped ontoobjectv vv invb jindexvsvvbk s letis indexs vs vv s0 b jbk s v ins0whereisis mapped ontoobjects0 vs ins0 x jp e1 ... en k let vi vali ei vali inx 0jbkwherebis the body statement ofpf jmatchspatsbk s if pats s thenf 0jbk s else?endifb jmatchspatsbk s v if pats s then lets0 b 0jbk s v inif pats s0 thens0else?endifelse?endif u jconditioneu1u2k s if e true 0thenu 0ju1k s else if e false 0thenu 0ju2k s else?endifendifu jdeletevk s s objects v u jdeletefeature ek s s l where e val l objects v v a l typeof l featuref jifthenadaptionfbuk s getbranch f b s b jifthenadaptionfbuk s v if f s v truethen lets0 b jbk s v inif f s0 v truethens0else?endifelse let sa a u juk s inif f sa v truethen lets0a b jbk sa v inif f s0a v truethens0aelse?endifelse?endifendif latexit sha1 base64 bczjp0jbzpncq pdlrlpravq2mo aaahlhiclvrrbxm5ef4auedgjvzo4gfelmjduxrv2fjw9wbsad0jeecg0lipdphxo5ty8xox29s0wp5v an av8gezdb7da015wijge wb2mx1howdkdwzfr2y0rl77px39rufmrv9 u7259furygpj4zbmpjphevhamybdztsh41wcssmo76pzcx9 fwjssuy804scrimzcjywsrrzjbc2pumijkwywtleplsdv3ayjxwkbiezuwhjuymipzhjpdwmgeuyffydnpa0jb2dhqwfc3acjqcfsslotfdf kk 6rsodnzrbp6 fphs8yy82nb4mwaxdy9vewqiezjhavxppgwbwch0o7alngo2h5sp1mvjuofugd0yo8lzq zvb7qwby3gsuwomp0yqoi9hs13iveqqvewzj0k ix2xmcc8f8hzvjl9mfi7xaitfzq0wvul7arsv igryoyt1ayhzrnylr4pd dvdlzzhewoygednckl0q2wz5vxvusljjnapca05uspytji9cgqqrnl4oglbtmhmzkbotmfsugntllefv3ppdfkmul qqps 2ogialsizryyjtoqwrgvhnttomuyiwm1wwhhu7 gbnj5iugqasukoijnsg ychmeqjmc2cqkpl7eusnrbkq3brxyrckne2ngwxmaeag6ltegnfrsiztrbxxb1upuxtlzod7i2crmefguqhtm 6exbi8n bashtkbozw0ch4lc5yxqixwvv5p2njd5tw031kjxxfic31qrkv1hus526qlow6k9sooeu0rmb13imz7db0ifxox0iihb9yuurasu9geuwbkupzdqxtfmiitgqnsudyaej8cgrhpqobrpa2avvbrze5dedmeet0n4fg3rbhkzenznp02sw vkr2dt3x0v 7tphygqilp7te mxepakvsn4qqnnicnuohq9jamduwr7rdj9sbvpz42hvnxzshm 3uvsplrfa9ebecd obwhwd7afvajebicbbd1t7bdetl6177qft5 62gg1ewox8etaf9 htiqlkc latexit latexit sha1 base64 bczjp0jbzpncq pdlrlpravq2mo aaahlhiclvrrbxm5ef4auedgjvzo4gfelmjduxrv2fjw9wbsad0jeecg0lipdphxo5ty8xox29s0wp5v an av8gezdb7da015wijge wb2mx1howdkdwzfr2y0rl77px39rufmrv9 u7259furygpj4zbmpjphevhamybdztsh41wcssmo76pzcx9 fwjssuy804scrimzcjywsrrzjbc2pumijkwywtleplsdv3ayjxwkbiezuwhjuymipzhjpdwmgeuyffydnpa0jb2dhqwfc3acjqcfsslotfdf kk 6rsodnzrbp6 fphs8yy82nb4mwaxdy9vewqiezjhavxppgwbwch0o7alngo2h5sp1mvjuofugd0yo8lzq zvb7qwby3gsuwomp0yqoi9hs13iveqqvewzj0k ix2xmcc8f8hzvjl9mfi7xaitfzq0wvul7arsv igryoyt1ayhzrnylr4pd dvdlzzhewoygednckl0q2wz5vxvusljjnapca05uspytji9cgqqrnl4oglbtmhmzkbotmfsugntllefv3ppdfkmul qqps 2ogialsizryyjtoqwrgvhnttomuyiwm1wwhhu7 gbnj5iugqasukoijnsg ychmeqjmc2cqkpl7eusnrbkq3brxyrckne2ngwxmaeag6ltegnfrsiztrbxxb1upuxtlzod7i2crmefguqhtm 6exbi8n bashtkbozw0ch4lc5yxqixwvv5p2njd5tw031kjxxfic31qrkv1hus526qlow6k9sooeu0rmb13imz7db0ifxox0iihb9yuurasu9geuwbkupzdqxtfmiitgqnsudyaej8cgrhpqobrpa2avvbrze5dedmeet0n4fg3rbhkzenznp02sw vkr2dt3x0v 7tphygqilp7te mxepakvsn4qqnnicnuohq9jamduwr7rdj9sbvpz42hvnxzshm 3uvsplrfa9ebecd obwhwd7afvajebicbbd1t7bdetl6177qft5 62gg1ewox8etaf9 htiqlkc latexit latexit sha1 base64 bczjp0jbzpncq pdlrlpravq2mo aaahlhiclvrrbxm5ef4auedgjvzo4gfelmjduxrv2fjw9wbsad0jeecg0lipdphxo5ty8xox29s0wp5v an av8gezdb7da015wijge wb2mx1howdkdwzfr2y0rl77px39rufmrv9 u7259furygpj4zbmpjphevhamybdztsh41wcssmo76pzcx9 fwjssuy804scrimzcjywsrrzjbc2pumijkwywtleplsdv3ayjxwkbiezuwhjuymipzhjpdwmgeuyffydnpa0jb2dhqwfc3acjqcfsslotfdf kk 6rsodnzrbp6 fphs8yy82nb4mwaxdy9vewqiezjhavxppgwbwch0o7alngo2h5sp1mvjuofugd0yo8lzq zvb7qwby3gsuwomp0yqoi9hs13iveqqvewzj0k ix2xmcc8f8hzvjl9mfi7xaitfzq0wvul7arsv igryoyt1ayhzrnylr4pd dvdlzzhewoygednckl0q2wz5vxvusljjnapca05uspytji9cgqqrnl4oglbtmhmzkbotmfsugntllefv3ppdfkmul qqps 2ogialsizryyjtoqwrgvhnttomuyiwm1wwhhu7 gbnj5iugqasukoijnsg ychmeqjmc2cqkpl7eusnrbkq3brxyrckne2ngwxmaeag6ltegnfrsiztrbxxb1upuxtlzod7i2crmefguqhtm 6exbi8n bashtkbozw0ch4lc5yxqixwvv5p2njd5tw031kjxxfic31qrkv1hus526qlow6k9sooeu0rmb13imz7db0ifxox0iihb9yuurasu9geuwbkupzdqxtfmiitgqnsudyaej8cgrhpqobrpa2avvbrze5dedmeet0n4fg3rbhkzenznp02sw vkr2dt3x0v 7tphygqilp7te mxepakvsn4qqnnicnuohq9jamduwr7rdj9sbvpz42hvnxzshm 3uvsplrfa9ebecd obwhwd7afvajebicbbd1t7bdetl6177qft5 62gg1ewox8etaf9 htiqlkc latexit latexit sha1 base64 bczjp0jbzpncq pdlrlpravq2mo aaahlhiclvrrbxm5ef4auedgjvzo4gfelmjduxrv2fjw9wbsad0jeecg0lipdphxo5ty8xox29s0wp5v an av8gezdb7da015wijge wb2mx1howdkdwzfr2y0rl77px39rufmrv9 u7259furygpj4zbmpjphevhamybdztsh41wcssmo76pzcx9 fwjssuy804scrimzcjywsrrzjbc2pumijkwywtleplsdv3ayjxwkbiezuwhjuymipzhjpdwmgeuyffydnpa0jb2dhqwfc3acjqcfsslotfdf kk 6rsodnzrbp6 fphs8yy82nb4mwaxdy9vewqiezjhavxppgwbwch0o7alngo2h5sp1mvjuofugd0yo8lzq zvb7qwby3gsuwomp0yqoi9hs13iveqqvewzj0k ix2xmcc8f8hzvjl9mfi7xaitfzq0wvul7arsv igryoyt1ayhzrnylr4pd dvdlzzhewoygednckl0q2wz5vxvusljjnapca05uspytji9cgqqrnl4oglbtmhmzkbotmfsugntllefv3ppdfkmul qqps 2ogialsizryyjtoqwrgvhnttomuyiwm1wwhhu7 gbnj5iugqasukoijnsg ychmeqjmc2cqkpl7eusnrbkq3brxyrckne2ngwxmaeag6ltegnfrsiztrbxxb1upuxtlzod7i2crmefguqhtm 6exbi8n bashtkbozw0ch4lc5yxqixwvv5p2njd5tw031kjxxfic31qrkv1hus526qlow6k9sooeu0rmb13imz7db0ifxox0iihb9yuurasu9geuwbkupzdqxtfmiitgqnsudyaej8cgrhpqobrpa2avvbrze5dedmeet0n4fg3rbhkzenznp02sw vkr2dt3x0v 7tphygqilp7te mxepakvsn4qqnnicnuohq9jamduwr7rdj9sbvpz42hvnxzshm 3uvsplrfa9ebecd obwhwd7afvajebicbbd1t7bdetl6177qft5 62gg1ewox8etaf9 htiqlkc latexit getbranch f b s letv f jbk s inif f s v truethenvelse?endiff jifthenelsefb1b2k s letv2 getbranch f b2 s inletv02 if f s v2 truethen?elsev2endif inifv02 ?thengetbranch f b1 s elsev02endifb jifthenelsefb1b2k s v if f s v truethenlets01 b jb1k s v inif f s01 v truethens01else?endifelse lets02 b jb2k s v in if f s02 v falsethenifgetbranch f b1 s02 ?thens02else?endifelse?endifendif latexit sha1 base64 dlnf5n eq75xdwzfnyiyrrlmy aaai53iclvxnjts2efysn3xdv2x77iwo28rbgatlobsxbyiulxpmsvlnadmvkimscvouqllrdqu qw8fih7aq9 mr9c36vdsei1zm2qf2b4nv lmvhmsdnlolj7n rt3 8hgvyfvdz8yffjrx598 ujos7nkchns8zdjmbwiikkccxqumeb0ipeupagnr4l193b91swvimxipd7mdjmsrlcyhusdyz8apmqbtzgocwej mamhidup5dehksjtkiakmk8daznx5i ltgljtebklnt5qc43kskpmvgfqmbewbxwgbcydx6jf8xjkrwldayq0krqyeyxzoz6fwyh1gmkzyfxydskyrm3fquk2pwkonqruq23hi2crvol4d wsjjjalftv efimden3v9eazfjrbim 3pn217wq0be9o3yth9 oe7wtysggzj0n15tvvwp2zyajo obju7b6vrxpkil7jqvwm3dunj3lteveyxr8jxwjvsad a4vuzca dqp3tqdw ta17957ep7 3t6sootetcvevsvdppxvs1ulce7kscmqhwz 9tv3tzhidtutxxzh3q7ri6222bq5xth n0de rehyyqx50alinmxaa54v 9obfhgvhkvkhq06uwrizxc9lijuloqx6qtgchgus0awygqrulcvqxjloa bekm4kfirglxc oisputs0agrk9ep116yzd03plmitjpowf4wov1vcmpncuxhwvcqfrzpd9m5eezm01hwlbgklayeoxbfjqg03acsni6vhjezwhwzcdcyivcsccvnita 01qv9me11uktxzuetwsii4bqcu2zajj2dzfxegwvjuiotahzpl6xf4ilnhfjlxke3ky7tysw8hd81pyhknm31vsgmth5jutukfapoqjiqtrmkalgbdwmwwbgawtv0skkj4ffql1wr9istj5vsfvqwy2o6izii4gk6bdmuewi emv8g9fbf4lb6avbdnbbuj4dehmeqp xvkoxi7cuzvs3pljqrl cibr y2mf 3ix5nxn0qp fofw9ayordddslnb3rkvuw a8d6mdkyd8hg4 273pb8ac enz24p3vjz181t8dq cl50pk4rvot88z5yxnhndvhib38pvhr8peqdx8b jh8s4bev9fefo60nue wpoatlk latexit latexit sha1 base64 dlnf5n eq75xdwzfnyiyrrlmy aaai53iclvxnjts2efysn3xdv2x77iwo28rbgatlobsxbyiulxpmsvlnadmvkimscvouqllrdqu qw8fih7aq9 mr9c36vdsei1zm2qf2b4nv lmvhmsdnlolj7n rt3 8hgvyfvdz8yffjrx598 ujos7nkchns8zdjmbwiikkccxqumeb0ipeupagnr4l193b91swvimxipd7mdjmsrlcyhusdyz8apmqbtzgocwej mamhidup5dehksjtkiakmk8daznx5i ltgljtebklnt5qc43kskpmvgfqmbewbxwgbcydx6jf8xjkrwldayq0krqyeyxzoz6fwyh1gmkzyfxydskyrm3fquk2pwkonqruq23hi2crvol4d wsjjjalftv efimden3v9eazfjrbim 3pn217wq0be9o3yth9 oe7wtysggzj0n15tvvwp2zyajo obju7b6vrxpkil7jqvwm3dunj3lteveyxr8jxwjvsad a4vuzca dqp3tqdw ta17957ep7 3t6sootetcvevsvdppxvs1ulce7kscmqhwz 9tv3tzhidtutxxzh3q7ri6222bq5xth n0de rehyyqx50alinmxaa54v 9obfhgvhkvkhq06uwrizxc9lijuloqx6qtgchgus0awygqrulcvqxjloa bekm4kfirglxc oisputs0agrk9ep116yzd03plmitjpowf4wov1vcmpncuxhwvcqfrzpd9m5eezm01hwlbgklayeoxbfjqg03acsni6vhjezwhwzcdcyivcsccvnita 01qv9me11uktxzuetwsii4bqcu2zajj2dzfxegwvjuiotahzpl6xf4ilnhfjlxke3ky7tysw8hd81pyhknm31vsgmth5jutukfapoqjiqtrmkalgbdwmwwbgawtv0skkj4ffql1wr9istj5vsfvqwy2o6izii4gk6bdmuewi emv8g9fbf4lb6avbdnbbuj4dehmeqp xvkoxi7cuzvs3pljqrl cibr y2mf 3ix5nxn0qp fofw9ayordddslnb3rkvuw a8d6mdkyd8hg4 273pb8ac enz24p3vjz181t8dq cl50pk4rvot88z5yxnhndvhib38pvhr8peqdx8b jh8s4bev9fefo60nue wpoatlk latexit latexit sha1 base64 dlnf5n eq75xdwzfnyiyrrlmy aaai53iclvxnjts2efysn3xdv2x77iwo28rbgatlobsxbyiulxpmsvlnadmvkimscvouqllrdqu qw8fih7aq9 mr9c36vdsei1zm2qf2b4nv lmvhmsdnlolj7n rt3 8hgvyfvdz8yffjrx598 ujos7nkchns8zdjmbwiikkccxqumeb0ipeupagnr4l193b91swvimxipd7mdjmsrlcyhusdyz8apmqbtzgocwej mamhidup5dehksjtkiakmk8daznx5i ltgljtebklnt5qc43kskpmvgfqmbewbxwgbcydx6jf8xjkrwldayq0krqyeyxzoz6fwyh1gmkzyfxydskyrm3fquk2pwkonqruq23hi2crvol4d wsjjjalftv efimden3v9eazfjrbim 3pn217wq0be9o3yth9 oe7wtysggzj0n15tvvwp2zyajo obju7b6vrxpkil7jqvwm3dunj3lteveyxr8jxwjvsad a4vuzca dqp3tqdw ta17957ep7 3t6sootetcvevsvdppxvs1ulce7kscmqhwz 9tv3tzhidtutxxzh3q7ri6222bq5xth n0de rehyyqx50alinmxaa54v 9obfhgvhkvkhq06uwrizxc9lijuloqx6qtgchgus0awygqrulcvqxjloa bekm4kfirglxc oisputs0agrk9ep116yzd03plmitjpowf4wov1vcmpncuxhwvcqfrzpd9m5eezm01hwlbgklayeoxbfjqg03acsni6vhjezwhwzcdcyivcsccvnita 01qv9me11uktxzuetwsii4bqcu2zajj2dzfxegwvjuiotahzpl6xf4ilnhfjlxke3ky7tysw8hd81pyhknm31vsgmth5jutukfapoqjiqtrmkalgbdwmwwbgawtv0skkj4ffql1wr9istj5vsfvqwy2o6izii4gk6bdmuewi emv8g9fbf4lb6avbdnbbuj4dehmeqp xvkoxi7cuzvs3pljqrl cibr y2mf 3ix5nxn0qp fofw9ayordddslnb3rkvuw a8d6mdkyd8hg4 273pb8ac enz24p3vjz181t8dq cl50pk4rvot88z5yxnhndvhib38pvhr8peqdx8b jh8s4bev9fefo60nue wpoatlk latexit latexit sha1 base64 dlnf5n eq75xdwzfnyiyrrlmy aaai53iclvxnjts2efysn3xdv2x77iwo28rbgatlobsxbyiulxpmsvlnadmvkimscvouqllrdqu qw8fih7aq9 mr9c36vdsei1zm2qf2b4nv lmvhmsdnlolj7n rt3 8hgvyfvdz8yffjrx598 ujos7nkchns8zdjmbwiikkccxqumeb0ipeupagnr4l193b91swvimxipd7mdjmsrlcyhusdyz8apmqbtzgocwej mamhidup5dehksjtkiakmk8daznx5i ltgljtebklnt5qc43kskpmvgfqmbewbxwgbcydx6jf8xjkrwldayq0krqyeyxzoz6fwyh1gmkzyfxydskyrm3fquk2pwkonqruq23hi2crvol4d wsjjjalftv efimden3v9eazfjrbim 3pn217wq0be9o3yth9 oe7wtysggzj0n15tvvwp2zyajo obju7b6vrxpkil7jqvwm3dunj3lteveyxr8jxwjvsad a4vuzca dqp3tqdw ta17957ep7 3t6sootetcvevsvdppxvs1ulce7kscmqhwz 9tv3tzhidtutxxzh3q7ri6222bq5xth n0de rehyyqx50alinmxaa54v 9obfhgvhkvkhq06uwrizxc9lijuloqx6qtgchgus0awygqrulcvqxjloa bekm4kfirglxc oisputs0agrk9ep116yzd03plmitjpowf4wov1vcmpncuxhwvcqfrzpd9m5eezm01hwlbgklayeoxbfjqg03acsni6vhjezwhwzcdcyivcsccvnita 01qv9me11uktxzuetwsii4bqcu2zajj2dzfxegwvjuiotahzpl6xf4ilnhfjlxke3ky7tysw8hd81pyhknm31vsgmth5jutukfapoqjiqtrmkalgbdwmwwbgawtv0skkj4ffql1wr9istj5vsfvqwy2o6izii4gk6bdmuewi emv8g9fbf4lb6avbdnbbuj4dehmeqp xvkoxi7cuzvs3pljqrl cibr y2mf 3ix5nxn0qp fofw9ayordddslnb3rkvuw a8d6mdkyd8hg4 273pb8ac enz24p3vjz181t8dq cl50pk4rvot88z5yxnhndvhib38pvhr8peqdx8b jh8s4bev9fefo60nue wpoatlk latexit xjupdatewithbypatspatvbucurk xjifthenadaptionfb uakfjb k s let .
.
.
n pats s vi f ijbk s v0 v1 ... vninifs b ijbk s v0 thenv0else?endifb jb k s v let .
.
.
n pats s si b ijbk s v s0 s1 s... ssn vi f ijbk s v0 v1 ... vninifvi f ijbk s0 s0 b ijbk s0 v si b ijbk s v0 .
.
.
n pats s0 thens0else?endifisaligned l r 8v l v ?
r v ?
l v r v wherethe value ofvis considered as?whenvis an unused index latexit sha1 base64 4idadwdb2q3z50wdpax d6km i8 aaajp3icrvxpj m0fm7ufijlx 7akytfgbarqmpmd3cptltiiooi7mrgqjurkzitvcfjxe47jfifxwgjf4g gams4gahbjw76dc0syngeglsx 7vvf82x4tzjxjnr7 odho9zbb7 tfrfz3vsffpj4yclhnkylpkrnycrt cigknim6jliitollkckctg9d1zfm j5muaspek12mz0npcfydeliyip 6r1iqo6ykiknc3eu935agfxkiyljlebssgioug5u8uxw40yovwptj8ergfghr av64xvsryep j4tdlkl5ejdn5niqbcpnuoinggllem8iayvljbuks0p8oahnd51rpxfyr3x2orqnh sgwnthk txecdoyyut5bhkjqs93tkb7jmwsxhuksi k9sae7 ii44x0s0yttg0l5imkx5mejormqui3zaqxxaqetncw2tyse j1bgajwazt9cyqckk1dljlzamigg vdwrgyoxokqh3x0yzglpevnirldpezpqpldn9o6z66ovh3r7 d7zwb0ffkqfc3nboqu2xb1hzz3hwg 5ap0g199ny q29e9sktdy1r0y mfelrjxx5zvvfle3avv0czzmhho0voh11wms6jwvrgqrafsblkcxobltksz7uihrhjqd3ixpdpuqeq3matca8ikinez6xu0ijlgycskiaeaisfstqwocxtsgrkbcfbkqtet0gpqbig7aif kox6n7yoob2496dr188o efqtjtkwskhqisdsztxxpuylyruloduddkkyeq7igs5gkehc5by0nvcjz20dycx8cyxs7d6jjimu2yqazeluuh7gzostmakskm z6lbgrfdxv3m4ylmhqairkukci5ui03nrxhiakr6faqlzbgtb4zlkjftqmrtpwgypvkcdg7wju9hg8bilxnvpdveqnb 6gyfmv9kz0zmmifhwwnzdpsy7pxrn9vsarnkw0hxb9ezzvdtym tzptcnutrhk cy 0yxwu9dxdojjfabqfvuqs3daublqii1cwsy6zkligx3p4qjbvosfmmuzn tsm9xkkojmtd6mbecsrgal43gzppq4pmgcyaubipbx4hnxgvbeqzazhka q oql0x4tyvvw7p9j9ag31xd3bvwxr0b 6t3haubv3lpeirtuvfo5fmrqddeneoozd8nqudjdzw0xd33cobfjzwtkfueor d9p9 lndbdroj86ntt9xns d5863zivnzalbp7z bf3r rp9q ux9m t3yvowwc152on8bt hujglmr latexit latexit sha1 base64 4idadwdb2q3z50wdpax d6km i8 aaajp3icrvxpj m0fm7ufijlx 7akytfgbarqmpmd3cptltiiooi7mrgqjurkzitvcfjxe47jfifxwgjf4g gams4gahbjw76dc0syngeglsx 7vvf82x4tzjxjnr7 odho9zbb7 tfrfz3vsffpj4yclhnkylpkrnycrt cigknim6jliitollkckctg9d1zfm j5muaspek12mz0npcfydeliyip 6r1iqo6ykiknc3eu935agfxkiyljlebssgioug5u8uxw40yovwptj8ergfghr av64xvsryep j4tdlkl5ejdn5niqbcpnuoinggllem8iayvljbuks0p8oahnd51rpxfyr3x2orqnh sgwnthk txecdoyyut5bhkjqs93tkb7jmwsxhuksi k9sae7 ii44x0s0yttg0l5imkx5mejormqui3zaqxxaqetncw2tyse j1bgajwazt9cyqckk1dljlzamigg vdwrgyoxokqh3x0yzglpevnirldpezpqpldn9o6z66ovh3r7 d7zwb0ffkqfc3nboqu2xb1hzz3hwg 5ap0g199ny q29e9sktdy1r0y mfelrjxx5zvvfle3avv0czzmhho0voh11wms6jwvrgqrafsblkcxobltksz7uihrhjqd3ixpdpuqeq3matca8ikinez6xu0ijlgycskiaeaisfstqwocxtsgrkbcfbkqtet0gpqbig7aif kox6n7yoob2496dr188o efqtjtkwskhqisdsztxxpuylyruloduddkkyeq7igs5gkehc5by0nvcjz20dycx8cyxs7d6jjimu2yqazeluuh7gzostmakskm z6lbgrfdxv3m4ylmhqairkukci5ui03nrxhiakr6faqlzbgtb4zlkjftqmrtpwgypvkcdg7wju9hg8bilxnvpdveqnb 6gyfmv9kz0zmmifhwwnzdpsy7pxrn9vsarnkw0hxb9ezzvdtym tzptcnutrhk cy 0yxwu9dxdojjfabqfvuqs3daublqii1cwsy6zkligx3p4qjbvosfmmuzn tsm9xkkojmtd6mbecsrgal43gzppq4pmgcyaubipbx4hnxgvbeqzazhka q oql0x4tyvvw7p9j9ag31xd3bvwxr0b 6t3haubv3lpeirtuvfo5fmrqddeneoozd8nqudjdzw0xd33cobfjzwtkfueor d9p9 lndbdroj86ntt9xns d5863zivnzalbp7z bf3r rp9q ux9m t3yvowwc152on8bt hujglmr latexit latexit sha1 base64 4idadwdb2q3z50wdpax d6km i8 aaajp3icrvxpj m0fm7ufijlx 7akytfgbarqmpmd3cptltiiooi7mrgqjurkzitvcfjxe47jfifxwgjf4g gams4gahbjw76dc0syngeglsx 7vvf82x4tzjxjnr7 odho9zbb7 tfrfz3vsffpj4yclhnkylpkrnycrt cigknim6jliitollkckctg9d1zfm j5muaspek12mz0npcfydeliyip 6r1iqo6ykiknc3eu935agfxkiyljlebssgioug5u8uxw40yovwptj8ergfghr av64xvsryep j4tdlkl5ejdn5niqbcpnuoinggllem8iayvljbuks0p8oahnd51rpxfyr3x2orqnh sgwnthk txecdoyyut5bhkjqs93tkb7jmwsxhuksi k9sae7 ii44x0s0yttg0l5imkx5mejormqui3zaqxxaqetncw2tyse j1bgajwazt9cyqckk1dljlzamigg vdwrgyoxokqh3x0yzglpevnirldpezpqpldn9o6z66ovh3r7 d7zwb0ffkqfc3nboqu2xb1hzz3hwg 5ap0g199ny q29e9sktdy1r0y mfelrjxx5zvvfle3avv0czzmhho0voh11wms6jwvrgqrafsblkcxobltksz7uihrhjqd3ixpdpuqeq3matca8ikinez6xu0ijlgycskiaeaisfstqwocxtsgrkbcfbkqtet0gpqbig7aif kox6n7yoob2496dr188o efqtjtkwskhqisdsztxxpuylyruloduddkkyeq7igs5gkehc5by0nvcjz20dycx8cyxs7d6jjimu2yqazeluuh7gzostmakskm z6lbgrfdxv3m4ylmhqairkukci5ui03nrxhiakr6faqlzbgtb4zlkjftqmrtpwgypvkcdg7wju9hg8bilxnvpdveqnb 6gyfmv9kz0zmmifhwwnzdpsy7pxrn9vsarnkw0hxb9ezzvdtym tzptcnutrhk cy 0yxwu9dxdojjfabqfvuqs3daublqii1cwsy6zkligx3p4qjbvosfmmuzn tsm9xkkojmtd6mbecsrgal43gzppq4pmgcyaubipbx4hnxgvbeqzazhka q oql0x4tyvvw7p9j9ag31xd3bvwxr0b 6t3haubv3lpeirtuvfo5fmrqddeneoozd8nqudjdzw0xd33cobfjzwtkfueor d9p9 lndbdroj86ntt9xns d5863zivnzalbp7z bf3r rp9q ux9m t3yvowwc152on8bt hujglmr latexit latexit sha1 base64 4idadwdb2q3z50wdpax d6km i8 aaajp3icrvxpj m0fm7ufijlx 7akytfgbarqmpmd3cptltiiooi7mrgqjurkzitvcfjxe47jfifxwgjf4g gams4gahbjw76dc0syngeglsx 7vvf82x4tzjxjnr7 odho9zbb7 tfrfz3vsffpj4yclhnkylpkrnycrt cigknim6jliitollkckctg9d1zfm j5muaspek12mz0npcfydeliyip 6r1iqo6ykiknc3eu935agfxkiyljlebssgioug5u8uxw40yovwptj8ergfghr av64xvsryep j4tdlkl5ejdn5niqbcpnuoinggllem8iayvljbuks0p8oahnd51rpxfyr3x2orqnh sgwnthk txecdoyyut5bhkjqs93tkb7jmwsxhuksi k9sae7 ii44x0s0yttg0l5imkx5mejormqui3zaqxxaqetncw2tyse j1bgajwazt9cyqckk1dljlzamigg vdwrgyoxokqh3x0yzglpevnirldpezpqpldn9o6z66ovh3r7 d7zwb0ffkqfc3nboqu2xb1hzz3hwg 5ap0g199ny q29e9sktdy1r0y mfelrjxx5zvvfle3avv0czzmhho0voh11wms6jwvrgqrafsblkcxobltksz7uihrhjqd3ixpdpuqeq3matca8ikinez6xu0ijlgycskiaeaisfstqwocxtsgrkbcfbkqtet0gpqbig7aif kox6n7yoob2496dr188o efqtjtkwskhqisdsztxxpuylyruloduddkkyeq7igs5gkehc5by0nvcjz20dycx8cyxs7d6jjimu2yqazeluuh7gzostmakskm z6lbgrfdxv3m4ylmhqairkukci5ui03nrxhiakr6faqlzbgtb4zlkjftqmrtpwgypvkcdg7wju9hg8bilxnvpdveqnb 6gyfmv9kz0zmmifhwwnzdpsy7pxrn9vsarnkw0hxb9ezzvdtym tzptcnutrhk cy 0yxwu9dxdojjfabqfvuqs3daublqii1cwsy6zkligx3p4qjbvosfmmuzn tsm9xkkojmtd6mbecsrgal43gzppq4pmgcyaubipbx4hnxgvbeqzazhka q oql0x4tyvvw7p9j9ag31xd3bvwxr0b 6t3haubv3lpeirtuvfo5fmrqddeneoozd8nqudjdzw0xd33cobfjzwtkfueor d9p9 lndbdroj86ntt9xns d5863zivnzalbp7z bf3r rp9q ux9m t3yvowwc152on8bt hujglmr latexit f jmatchvpatsbk s letv f jbk s inif patv v v f 0jbk s thenvelse?endifb jmatchvpatsbk s v let .
.
.
patv v inif9!i b ijbk s v s06 ?
thenif9!i b ijbk s0 v ?
thens0else?endifelse?endif latexit sha1 base64 9hn kdsrlndiphklsnhfx4lrtum aaahhxiclvtnjuneepzmiszhbweoxboctgy1iulsgt3sscuqemdfw2rhsoeobzetvtptt3d7mqhvz8kbz0eccxgaa jtqlbj3bvnndcwbfvxffxvx5ejqnbtjpn 7vxuv fm 60hbw eefe99z94epdhtoeliueszkwuziomqxajz4ybaeefapzfal5em6 culkm1z b3zfbdi2erylmfmogp50htki1hxazngk nidb6g6tbrkfmabry2yyzezxwpmfmeuhk5h ikzrkbnr5rucj5zyusynzsphfsgqsauxsuivffyzl645146qitgyfunfgis1f9pp4d0s0kkyat1gbtpdeymdvin msca2orrmp4ofmplkpgw22 6mwh69dtzpzmjzec9pj8xh8q563fwhxoel9cr81mbwqy8ldffnk9jbkupdz12xvwr0 yenk lp2kof2uvshhmd3darv9fer5e2jkl08q4mlg hk gkesh1idwlw2d pf8e3p vjnlczibnljjw83bsmivlyvbygbvqukpb4g1bwrxfytlqc1vdc0c r01c0lzhkw2ptk97wjzpvcsirokw17pr88obbdpkto1ucpnxxpr0yqjnxjqgzfxnkzacmjz4jsijvxabsuobxypjisrem8vig3vxcsptag6dac5mg c4lwwmlvw4sw1cgwosp7i2hvd74 btbupmrgtyyeio7xdqqkrohbhrpao1ajd vlaes8tclhppar3et9b6686eht521mfwyaqz03jvvcz57g5pxwjyko2ku62tgtbgxalk5igcadudqybbfo19kyzmp4idvzxq2lmcodcnxgwslthlz9h0bhvw5zbeo4mujcfbx4p94klinigqchfh zdgydakvkn9qesexxw9z gxf ywu7f3cv4tbkt96 u4l7z1q6k6zkfcumm2kbuwyibmdoyfz3h4e6h3u2 lsym43aydr bdp99tv8lpag dj4nrkeyfbk8c74nngdnqdz7ufdb78 ex 2f r 0f uun79 y hwwtp 3v0ckkmk latexit latexit sha1 base64 9hn kdsrlndiphklsnhfx4lrtum aaahhxiclvtnjuneepzmiszhbweoxboctgy1iulsgt3sscuqemdfw2rhsoeobzetvtptt3d7mqhvz8kbz0eccxgaa jtqlbj3bvnndcwbfvxffxvx5ejqnbtjpn 7vxuv fm 60hbw eefe99z94epdhtoeliueszkwuziomqxajz4ybaeefapzfal5em6 culkm1z b3zfbdi2erylmfmogp50htki1hxazngk nidb6g6tbrkfmabry2yyzezxwpmfmeuhk5h ikzrkbnr5rucj5zyusynzsphfsgqsauxsuivffyzl645146qitgyfunfgis1f9pp4d0s0kkyat1gbtpdeymdvin msca2orrmp4ofmplkpgw22 6mwh69dtzpzmjzec9pj8xh8q563fwhxoel9cr81mbwqy8ldffnk9jbkupdz12xvwr0 yenk lp2kof2uvshhmd3darv9fer5e2jkl08q4mlg hk gkesh1idwlw2d pf8e3p vjnlczibnljjw83bsmivlyvbygbvqukpb4g1bwrxfytlqc1vdc0c r01c0lzhkw2ptk97wjzpvcsirokw17pr88obbdpkto1ucpnxxpr0yqjnxjqgzfxnkzacmjz4jsijvxabsuobxypjisrem8vig3vxcsptag6dac5mg c4lwwmlvw4sw1cgwosp7i2hvd74 btbupmrgtyyeio7xdqqkrohbhrpao1ajd vlaes8tclhppar3et9b6686eht521mfwyaqz03jvvcz57g5pxwjyko2ku62tgtbgxalk5igcadudqybbfo19kyzmp4idvzxq2lmcodcnxgwslthlz9h0bhvw5zbeo4mujcfbx4p94klinigqchfh zdgydakvkn9qesexxw9z gxf ywu7f3cv4tbkt96 u4l7z1q6k6zkfcumm2kbuwyibmdoyfz3h4e6h3u2 lsym43aydr bdp99tv8lpag dj4nrkeyfbk8c74nngdnqdz7ufdb78 ex 2f r 0f uun79 y hwwtp 3v0ckkmk latexit latexit sha1 base64 9hn kdsrlndiphklsnhfx4lrtum aaahhxiclvtnjuneepzmiszhbweoxboctgy1iulsgt3sscuqemdfw2rhsoeobzetvtptt3d7mqhvz8kbz0eccxgaa jtqlbj3bvnndcwbfvxffxvx5ejqnbtjpn 7vxuv fm 60hbw eefe99z94epdhtoeliueszkwuziomqxajz4ybaeefapzfal5em6 culkm1z b3zfbdi2erylmfmogp50htki1hxazngk nidb6g6tbrkfmabry2yyzezxwpmfmeuhk5h ikzrkbnr5rucj5zyusynzsphfsgqsauxsuivffyzl645146qitgyfunfgis1f9pp4d0s0kkyat1gbtpdeymdvin msca2orrmp4ofmplkpgw22 6mwh69dtzpzmjzec9pj8xh8q563fwhxoel9cr81mbwqy8ldffnk9jbkupdz12xvwr0 yenk lp2kof2uvshhmd3darv9fer5e2jkl08q4mlg hk gkesh1idwlw2d pf8e3p vjnlczibnljjw83bsmivlyvbygbvqukpb4g1bwrxfytlqc1vdc0c r01c0lzhkw2ptk97wjzpvcsirokw17pr88obbdpkto1ucpnxxpr0yqjnxjqgzfxnkzacmjz4jsijvxabsuobxypjisrem8vig3vxcsptag6dac5mg c4lwwmlvw4sw1cgwosp7i2hvd74 btbupmrgtyyeio7xdqqkrohbhrpao1ajd vlaes8tclhppar3et9b6686eht521mfwyaqz03jvvcz57g5pxwjyko2ku62tgtbgxalk5igcadudqybbfo19kyzmp4idvzxq2lmcodcnxgwslthlz9h0bhvw5zbeo4mujcfbx4p94klinigqchfh zdgydakvkn9qesexxw9z gxf ywu7f3cv4tbkt96 u4l7z1q6k6zkfcumm2kbuwyibmdoyfz3h4e6h3u2 lsym43aydr bdp99tv8lpag dj4nrkeyfbk8c74nngdnqdz7ufdb78 ex 2f r 0f uun79 y hwwtp 3v0ckkmk latexit latexit sha1 base64 9hn kdsrlndiphklsnhfx4lrtum aaahhxiclvtnjuneepzmiszhbweoxboctgy1iulsgt3sscuqemdfw2rhsoeobzetvtptt3d7mqhvz8kbz0eccxgaa jtqlbj3bvnndcwbfvxffxvx5ejqnbtjpn 7vxuv fm 60hbw eefe99z94epdhtoeliueszkwuziomqxajz4ybaeefapzfal5em6 culkm1z b3zfbdi2erylmfmogp50htki1hxazngk nidb6g6tbrkfmabry2yyzezxwpmfmeuhk5h ikzrkbnr5rucj5zyusynzsphfsgqsauxsuivffyzl645146qitgyfunfgis1f9pp4d0s0kkyat1gbtpdeymdvin msca2orrmp4ofmplkpgw22 6mwh69dtzpzmjzec9pj8xh8q563fwhxoel9cr81mbwqy8ldffnk9jbkupdz12xvwr0 yenk lp2kof2uvshhmd3darv9fer5e2jkl08q4mlg hk gkesh1idwlw2d pf8e3p vjnlczibnljjw83bsmivlyvbygbvqukpb4g1bwrxfytlqc1vdc0c r01c0lzhkw2ptk97wjzpvcsirokw17pr88obbdpkto1ucpnxxpr0yqjnxjqgzfxnkzacmjz4jsijvxabsuobxypjisrem8vig3vxcsptag6dac5mg c4lwwmlvw4sw1cgwosp7i2hvd74 btbupmrgtyyeio7xdqqkrohbhrpao1ajd vlaes8tclhppar3et9b6686eht521mfwyaqz03jvvcz57g5pxwjyko2ku62tgtbgxalk5igcadudqybbfo19kyzmp4idvzxq2lmcodcnxgwslthlz9h0bhvw5zbeo4mujcfbx4p94klinigqchfh zdgydakvkn9qesexxw9z gxf ywu7f3cv4tbkt96 u4l7z1q6k6zkfcumm2kbuwyibmdoyfz3h4e6h3u2 lsym43aydr bdp99tv8lpag dj4nrkeyfbk8c74nngdnqdz7ufdb78 ex 2f r 0f uun79 y hwwtp 3v0ckkmk latexit f jb1 b2k s letv1 f jb1k s v2 f jb2k s v0 v1 v2inifs b jb1k s v0 b jb2k s v0 thenv0else?endifb jb1 b2k s v lets1 b jb1k s v s2 b jb2k s v s0 s1 ss2 v1 f jb1k s1 v2 f jb2k s2 v0 v1 v2 vc1 core1sv vc2 core2sv vc vc1 vc2inifcore1s1v core1s0v core2s2v core2s0v s0 b jb1k s0 v s0 b jb2k s0 v vc1 core1svc vc2 core2svc v1 v2 vcthens0else?endif latexit sha1 base64 ynhb3qad8a780gtho1upooefrac aaaigxiclvrtb9s2efybb w8t3b7uc cvm3j4aawcqwdigbfbwz72mglgsd0biqihmlus0gqjkfwv tn9c woyyklqweiwptx7rnnehfkrqvnus1mhx89php89vmt4rejl7 ptvnz77lpb5kqg9jznpxuwejeuso ekku4vckfxgnh6llr ye3vrqmqlm uducllo8yljccfagcp8dvucrxbfmy85w2a9m9atknrgkqy5cd8n1rr8yueibf9ekpyk np8gelwya5saivnlgta723pza06rg4t nthvgcdnsamwurgigmgmll7rbnggzplbca5zvek4xmxalpj5gyrwm4no02bysmfx2xyevuqsziaywjfysq2kclwfolkmvfw0o a 1kdbn m5tb7 odbduu2 0yveb8ac1uaus3a3ezbqbufrhho3vvl0l vzodrnphmgckfhfzdoxhok6xfkp1gasosfqd1nlrg9nawaz57s26x4c7wbhzoq mvdw9d2sw4i1xb2idupgwd 5owsq3rgfi9kj70q9ifskcoak1s tdagu6qau0uos3nezdxhod 9j2owqfj2ems txdwwuesdn8b fnf0bxtsquzopwloxcmxvqqbfqjhak kwkbszrvkiledocurnu1swx7s gid0kf dllftp9z00tqxcphegu6wuzddmlb02qvistilumy5klfy hcttlipmpd5funjx5a6dwm7mbcwkb0hardbixcwxwgciyla1wrckqu9ohdk6itl0gyqjmsanrorekkw03zi2hcbn2iz8jug4w3gqx56z6rfvkkj2hfiuywbxyqktfpufl2wour3etlxbwyg5hr agwdbavqoryshytxgcndik0avv8eoomvlxmpauguqzmidekq6owwngv9cxqol2x9uh1ezsmjztozpbmjznjrqzcuxqwno6i0jruchxwymnk0nto2lin0oqmr5bpvfu woprcj0ey67tfn1 viad71vgu5 mq4nwtb7m eyd7elo7ursq2a643spuupdgeb9tbympeqy8fa 70g fwd 1zqfe3 749u nfbg6pzg oseo57x0xjt ow dc4cmngyed34bvbwedu gs6ffqx8 any d1rf8nx rur fg latexit latexit sha1 base64 ynhb3qad8a780gtho1upooefrac aaaigxiclvrtb9s2efybb w8t3b7uc cvm3j4aawcqwdigbfbwz72mglgsd0biqihmlus0gqjkfwv tn9c woyyklqweiwptx7rnnehfkrqvnus1mhx89php89vmt4rejl7 ptvnz77lpb5kqg9jznpxuwejeuso ekku4vckfxgnh6llr ye3vrqmqlm uducllo8yljccfagcp8dvucrxbfmy85w2a9m9atknrgkqy5cd8n1rr8yueibf9ekpyk np8gelwya5saivnlgta723pza06rg4t nthvgcdnsamwurgigmgmll7rbnggzplbca5zvek4xmxalpj5gyrwm4no02bysmfx2xyevuqsziaywjfysq2kclwfolkmvfw0o a 1kdbn m5tb7 odbduu2 0yveb8ac1uaus3a3ezbqbufrhho3vvl0l vzodrnphmgckfhfzdoxhok6xfkp1gasosfqd1nlrg9nawaz57s26x4c7wbhzoq mvdw9d2sw4i1xb2idupgwd 5owsq3rgfi9kj70q9ifskcoak1s tdagu6qau0uos3nezdxhod 9j2owqfj2ems txdwwuesdn8b fnf0bxtsquzopwloxcmxvqqbfqjhak kwkbszrvkiledocurnu1swx7s gid0kf dllftp9z00tqxcphegu6wuzddmlb02qvistilumy5klfy hcttlipmpd5funjx5a6dwm7mbcwkb0hardbixcwxwgciyla1wrckqu9ohdk6itl0gyqjmsanrorekkw03zi2hcbn2iz8jug4w3gqx56z6rfvkkj2hfiuywbxyqktfpufl2wour3etlxbwyg5hr agwdbavqoryshytxgcndik0avv8eoomvlxmpauguqzmidekq6owwngv9cxqol2x9uh1ezsmjztozpbmjznjrqzcuxqwno6i0jruchxwymnk0nto2lin0oqmr5bpvfu woprcj0ey67tfn1 viad71vgu5 mq4nwtb7m eyd7elo7ursq2a643spuupdgeb9tbympeqy8fa 70g fwd 1zqfe3 749u nfbg6pzg oseo57x0xjt ow dc4cmngyed34bvbwedu gs6ffqx8 any d1rf8nx rur fg latexit latexit sha1 base64 ynhb3qad8a780gtho1upooefrac aaaigxiclvrtb9s2efybb w8t3b7uc cvm3j4aawcqwdigbfbwz72mglgsd0biqihmlus0gqjkfwv tn9c woyyklqweiwptx7rnnehfkrqvnus1mhx89php89vmt4rejl7 ptvnz77lpb5kqg9jznpxuwejeuso ekku4vckfxgnh6llr ye3vrqmqlm uducllo8yljccfagcp8dvucrxbfmy85w2a9m9atknrgkqy5cd8n1rr8yueibf9ekpyk np8gelwya5saivnlgta723pza06rg4t nthvgcdnsamwurgigmgmll7rbnggzplbca5zvek4xmxalpj5gyrwm4no02bysmfx2xyevuqsziaywjfysq2kclwfolkmvfw0o a 1kdbn m5tb7 odbduu2 0yveb8ac1uaus3a3ezbqbufrhho3vvl0l vzodrnphmgckfhfzdoxhok6xfkp1gasosfqd1nlrg9nawaz57s26x4c7wbhzoq mvdw9d2sw4i1xb2idupgwd 5owsq3rgfi9kj70q9ifskcoak1s tdagu6qau0uos3nezdxhod 9j2owqfj2ems txdwwuesdn8b fnf0bxtsquzopwloxcmxvqqbfqjhak kwkbszrvkiledocurnu1swx7s gid0kf dllftp9z00tqxcphegu6wuzddmlb02qvistilumy5klfy hcttlipmpd5funjx5a6dwm7mbcwkb0hardbixcwxwgciyla1wrckqu9ohdk6itl0gyqjmsanrorekkw03zi2hcbn2iz8jug4w3gqx56z6rfvkkj2hfiuywbxyqktfpufl2wour3etlxbwyg5hr agwdbavqoryshytxgcndik0avv8eoomvlxmpauguqzmidekq6owwngv9cxqol2x9uh1ezsmjztozpbmjznjrqzcuxqwno6i0jruchxwymnk0nto2lin0oqmr5bpvfu woprcj0ey67tfn1 viad71vgu5 mq4nwtb7m eyd7elo7ursq2a643spuupdgeb9tbympeqy8fa 70g fwd 1zqfe3 749u nfbg6pzg oseo57x0xjt ow dc4cmngyed34bvbwedu gs6ffqx8 any d1rf8nx rur fg latexit latexit sha1 base64 ynhb3qad8a780gtho1upooefrac aaaigxiclvrtb9s2efybb w8t3b7uc cvm3j4aawcqwdigbfbwz72mglgsd0biqihmlus0gqjkfwv tn9c woyyklqweiwptx7rnnehfkrqvnus1mhx89php89vmt4rejl7 ptvnz77lpb5kqg9jznpxuwejeuso ekku4vckfxgnh6llr ye3vrqmqlm uducllo8yljccfagcp8dvucrxbfmy85w2a9m9atknrgkqy5cd8n1rr8yueibf9ekpyk np8gelwya5saivnlgta723pza06rg4t nthvgcdnsamwurgigmgmll7rbnggzplbca5zvek4xmxalpj5gyrwm4no02bysmfx2xyevuqsziaywjfysq2kclwfolkmvfw0o a 1kdbn m5tb7 odbduu2 0yveb8ac1uaus3a3ezbqbufrhho3vvl0l vzodrnphmgckfhfzdoxhok6xfkp1gasosfqd1nlrg9nawaz57s26x4c7wbhzoq mvdw9d2sw4i1xb2idupgwd 5owsq3rgfi9kj70q9ifskcoak1s tdagu6qau0uos3nezdxhod 9j2owqfj2ems txdwwuesdn8b fnf0bxtsquzopwloxcmxvqqbfqjhak kwkbszrvkiledocurnu1swx7s gid0kf dllftp9z00tqxcphegu6wuzddmlb02qvistilumy5klfy hcttlipmpd5funjx5a6dwm7mbcwkb0hardbixcwxwgciyla1wrckqu9ohdk6itl0gyqjmsanrorekkw03zi2hcbn2iz8jug4w3gqx56z6rfvkkj2hfiuywbxyqktfpufl2wour3etlxbwyg5hr agwdbavqoryshytxgcndik0avv8eoomvlxmpauguqzmidekq6owwngv9cxqol2x9uh1ezsmjztozpbmjznjrqzcuxqwno6i0jruchxwymnk0nto2lin0oqmr5bpvfu woprcj0ey67tfn1 viad71vgu5 mq4nwtb7m eyd7elo7ursq2a643spuupdgeb9tbympeqy8fa 70g fwd 1zqfe3 749u nfbg6pzg oseo57x0xjt ow dc4cmngyed34bvbwedu gs6ffqx8 any d1rf8nx rur fg latexit figure formal semantics of xmu core condition e u 1u2is a conditional statement which executes u1oru2according to the result of expression e i.e.
ujcondition e u 1u2k .
u1 u2executes u1andu2sequentially i.e.
uju1 u2k .
.
bidirectional statements a bidirectional statement bis interpreted as a bx x jbk which represents the bidirectional semantics of bunder environment .x jbk consists of a forward semantics f jbkand a backward semantics b jbk under the same environment .b1 b2merges b1andb2using .
we embed explicit checks of equations in the definitions of b jb1 b2kandf jb1 b2kto ensure their well behavedness.
the core function of x jb1 b2kis the merging of the core functions of x jb1kandx jb2k.
replace patspatvensures that a match of patsis paired with a match of patv.
forb jreplace patspatvk this statement instantiates a match of patsbased on a match of patvif the source match is absent.
in the forward semantics f jreplace patspatvk this statement instantiates a match of patvbased on a match of pats.
the putback based bidirectional model transformations esec fse november lake buena vista fl usa core function of x jreplace patspatvkextracts the unique match of patvout from the view model based on .
indexvsvvbmay append new indices to the result of b. the core function of x jindexvsvvbkis the core function of x jbk.
as mentioned in section we employ an index function index s v to compute object indices.
in b jindexvsvvbk the index function is written as index s s v which computes an updated source index based on sandv.
in the same backward transformation any two invocations of index s s1 v1 andindex s s2 v2 must satisfy the following runtime constraints v1 v2 s1 s2 s1 s2 index s s1 v1 index s s2 v2 index sshould not generate an index that is already used in the original source model.
inf jindexvsvvbk the index function is denoted as index v s which computes a view index based on s. in the same forward transformation any two invocations of index v s1 andindex v s2 must satisfy the following constraint s1 s2 index v s1 index v s2 .
these constraints ensure that the same view objects are always created based on the same source objects and that index functions do not cause index collision.
index functions may be implemented in many ways.
they can but not necessarily be bidirectional transformations.
as shown in section we can concatenate the actual parameters of an index function to compute the result index.
in our future work we plan to investigate other possible implementation of index functions.
ifthenelse f b1b2is a bidirectional statement that selects b1or b2according to condition f where fis a boolean function about the source and view model.
we adapt the semantics of the case statement in bigul i.e.
a two branch case statement for the semantics of this statement.
the core function of x jifthenelse f b 1b2k returns either the result of x jb1k s core function or the result of x jb2k s core function depending on condition f. matchs patsbfinds a match of patsand then evaluates bbased on this match i.e.
f jmatchs patsbkandb jmatchs patsbk .
especially in the backward semantics the match of patsmust also exist in the updated source model.
similarly matchv patvbfinds a match of patvand then evaluates bbased on this match i.e.
f jmatchv patsbkandb jmatchv patsbk .
in the backward semantics there may be multiple matches of patvfound but only one match is expected to be successfully used in the evaluation of b. if no or many matches of patvcan be used then the statement returns .
the core functions of x jmatchs patsbkandx jmatchv patvbkare the core function of x jbk where is the match of patsorpatvthat is found based on .
p e1 ... en denotes the rule call statement.
it prepares a new environment for the callee rule and executes the body statement supposing that bis the body of rule p .
the core function of this statement is the core function of b. finally consider the semantics of updatewithby .
before going on we define a conditional statement with adaption i.e.
ifthenadaption f b u which will be used to construct the semanticsupdatewithby .ifthenadaption is also adapted from bigul so it is a well behaved bx.
informally in the backward direction ifthenadaption executes bidirectional statement bif condition fholds otherwise this statement executes unidirectionalstatement uto change the given source model into a new source that can make fhold and then executes bwith the new source.
in the forward direction ifthenadaption ignores uand behaves like ifthenelse statement whose else branch is .
as for updatewithby patspatvb ucur informally in the backward direction it aligns the matches of patswith the matches of patv and executes the bidirectional statement b to synchronize the aligned source and view matches and unidirectional statements ur to destroy misaligned source matches and uc to create matches ofpatsfor misaligned view matches according to the alignment result.
in the forward direction this statement finds all matches of patsand executes bto construct the view model for each match.
we start from a simple case in which source and view models i.e.
sandv satisfy the following alignment condition each match ofpatscan be uniquely aligned with a match of patv and each match of patvcan be uniquely aligned with a match of pats we useisali ned l r defined in figure to determine whether a source match and a view match can be aligned .
in fact in this case a view match is uniquely determined by a source match and vice versa .
furthermore only bidirectional statement bwill be executed for each pair of source and view matches that are aligned.
we view each execution of bas a derived component bx.
because the view match is fully determined by the corresponding source match every component bx is actually derived from a single source match.
hence in the simple case the semantics of updatewithby can be viewed as a composition of a set x i jbk of derived component bxs where iis a match of pats.
we formulate this semantics as fjb k bjb k in figure .
in fjb kandbjb k we explicitly check equations and the alignment condition.
now we consider the complex case where some source view matches may be misaligned.
based on the informal semantics above ucand urwill be executed to destroy the unaligned source matches and to construct new source matches that can be paired with unaligned view matches respectively.
in short we execute ucand urto convert the original source model into a new one that will satisfy the alignment condition .
hence given a certain source model s we can specify the semantics ofupdatewithby as follows x jupdatewithby patspatvb ucurk x jifthenadaption f b uak where fis the alignment condition ua is derived from ucandur.
in backward transformation uacan be derived as follows for each misaligned match siofpats execute urto obtain ssi u si jurk s for each misaligned match viof patv execute ucto obtain svi u vi juck s merge all ssiandsvi.
in forward direction we simply ignore uasince it is useless.
.
round trip properties of xmu core the key to defining a bx language is to assure the well behavedness of this language.
all bidirectional statements defined in xmu core can be proven to be well behaved.
in this section we presents the proof sketch of the well behavedness of xmu core as the evidence of the correctness of our approach.
x jreplace patspatvk after executing b jreplace patspatvk we can ensure that there exists a unique match of patsin the updated source model which can be found in the forward execution to esec fse november lake buena vista fl usa xiao he and zhenjiang hu construct the view model i.e.
putget .b jreplace patspatvkalso states that if there is already a match of patsin the original source model this statement does nothing i.e.
puttwice .
after running f jreplace patspatvk for the unique match of pats a view instance is created which can be paired with the match of patsduring the backward execution i.e.
getput .
x jindexvsvvbk ifx jbkis well behaved then this statement is also well behaved because it does not change the output of x jbk though it appends new object indices .
x jifthenelse f b 1b2k this statement is well behaved because it is adapted from the case statement in bigul i.e.
a case statement with two branches and without adaption .
in bigul the case statement has been verified .
x jmatchs patsbk inb jmatchs patsbk a match of pats namely is found first and then b jbkis executed.
after executing b jbk b jmatchs patsbkalso checks that the match ofpatsstill exists in the updated source.
hence putget andputtwice hold when x jbkis well behaved.
in f jmatchs patsbk a match of pats namely is found first and then f jbkis executed.
hence getput holds when x jbkis well behaved.
x jmatchv patvbk the backward semantics i.e.
b jmatchv patvbk ensures puttwice .
as discussed previously b jmatchv patvbkfinds a match namely ofpatvto evaluate b. in this process it does not change the information related to source in the original environment .
hence executing f jbkresults in a view that is isomorphic to the result of f jbk.
hence putget must hold when bis well behaved.
regarding getput inf jmatchv patvbk the statement executes bto create a view vthat contains exactly one match of patv namely .
if we execute the backward transformation immediately we will find a unique match in vthat must be .
hence getput holds.
x jp e1 .
.
.
en k if the body statement of p namely b is well behaved then the rule call statement is well behaved.
it is because that a rule call statement simply constructs a new environment based on and then executes bwith the new environment.
x jb1 b2k this statement is well behaved because this statement is actually realized by using the model merging based bx combinator see theorem .
.
x jupdatewithby patspatvb ucurk this statement is interpreted asx jifthenadaption f b uak where ifthenadaption statement is also adapted from the case statement in bigul.
hence we only have to prove x jb kis well behaved.
according to the definition ofx jb k we learn that x jb kis a composition of x 1 jbk x 2 jbk ... x n jbk they are combined by where 1 ... n pats s .
the definition itself is well behaved.
however this definition of x jb k is actually related to the source matches 1 ... n. to ensure x jb kis well behaved we must ensure that 1 ... nare not destroyed during the backward transformation since in the forward transformation the source model is not changed .
in b jb k we append an explicit check at the end of the execution.
overall the round trip properties of x jupdatewithby patspatvb ucurkare satisfied.
tool support and examples we implemented a prototype tool of xmu on eclipse platform.
the tool employed eclipse modeling framework as the internal data representation.
the language facilities such as code editor interpreter and launcher were realized based on emftext and xtext .
in our tool implementation we also extend the syntax of xmu by providing some syntax sugars such as the otherwise branch for switch case .
at present we applied the dynamic check of equations to ensure the well behavedness of a bx.
to evaluate and demonstrate xmu we implemented several benchmark bx programs2using our tool support.
those bx programs include but not limited to the follow programs the classic transformation uml2rdbms between uml class diagrams and rdbms models which has been intensively studied in the model transformation community e.g.
zan et al.
presented a partial implementation based on biflux the conversion between a hierarchical state machine and a flatten state machine hsm2fsm which was studied in the book mark example which was studied in and the nested section example which was studied in the address book examples which were studied in .
due to space limitation we cannot present all details of these examples.
a full list of example bx programs including the source code and transformation results is available on our website.
to the best of our knowledge our implementation of uml2rdbms is the first fully implemented putback based version which is partially presented in section .
conclusion and future work in this paper we proposed a putback based language xmu for bidirectional model transformation and a model merging based bx combinator to address the ambiguity and the shared node issue.
xmu enables us to define a bx in the form of a backward transformation.
according to the semantics presented in figure we can derive a unique forward transformation from this backward transformation to eliminate ambiguities.
the model merging based bx combinator allows multiple conversions of the same node and preserves the result of each conversion if there is no conflict.
there are some open issues that must be investigated in the future to turn xmu into a more efficient user friendly and practical bx language.
first we believe that xmu core may be refined and enhanced to improve its semantics and expressiveness.
second xmu directly checks equations at runtime to ensure the successful application of .
however so may be very time consuming.
we plan to investigate how to efficiently check the validity of the bx combination.
third we will explore some useful implementation mechanisms of index functions and integrate them into our tool support.
fourth we will investigate how to support delta based incremental and symmetric bx and how to integrate xmu core with the existing transformation languages.
finally we will conduct more case studies to evaluate and apply our approach.
putback based bidirectional model transformations esec fse november lake buena vista fl usa