ui driven android application reduction jianjun huang1 y ousra aafer1 david perry1 xiangyu zhang1 c h e nt i a n2 .
department of computer science purdue university usa .
huawei r d usa huang427 yaafer perry74 purdue.edu xyzha ng cs.purdue.edu chen.tian huawei.com abstract while smartphones and mobile apps have been an integral part of our life modern mobile apps tend to contain a lot of rarely used functionalities.
for example applications containadvertisements and offer extra features such as recommendednews stories in weather apps.
while these functionalities are notessential to an app they nonetheless consume power cpu cyclesand bandwidth.
in this paper we design a ui driven approachthat allows customizing an android app by removing its un wanted functionalities.
in particular our technique displays theui and allows the user to select elements denoting functionalitiesthat she wants to remove.
using this information our techniqueautomatically removes all the code elements related to the selectedfunctionalities including all the relevant background tasks.
theunderlying analysis is a type system in which each code elementis tagged with a type indicating if it should be removed.
from theui hints our technique infers types for all other code elementsand reduces the app accordingly.
we implement a prototype andevaluate it on real world android apps.
the results showthat our approach can accurately discover the removable codeelements and lead to substantial resource savings in the reducedapps.
i. i ntroduction smartphone apps have become an integral part of our daily life .
however apps tend to contain a lot of rarely used functionalities.
for example advertisements are reportedto appear in more than of android apps .
as ad libraries are provided by third party service providers and integrated by developers into their apps this practice has raisedlots of privacy and security concerns .
in fact previous studies have identified sensitive information exposure in ad networks and others have found that upon a user s click advertisements may reach some destinations that play an important role in propagating attacks .
in addition toadvertisements apps may offer extra features that are usually not desired by the users.
for example a weather app mayrecommend news stories and a calendar app may includenews like sections as we will show in section iv b2 .
besides the non relevant features some apps may contain complex functionalities that are relevant to the apps purpose but considered redundant or distracting by the users.
for example a shopping app usually recommends products based on the user s profile and shopping history.
however uninterestedusers might find such recommendations quite distracting and would appreciate it if the app provides an option to turn this feature off.
besides visual distraction unwanted functionalities often incur additional consumption of battery power cpu cycles bandwidth and so on.
previous studies have shown thatmobile apps using ads consume significantly more network data and have increased energy consumption .therefore there is an increasing need of automatically customizing mobile apps to meet the various demands of different user groups.
for example enterprises and government agencies may want the apps installed on their employee s devices to not have potentially malicious third party components e.g.
ad components .
users that often operate their devices in rough environments such as outdoors and battle fields maywant to minimize battery and data consumption by turningoff unnecessary app features.
even normal users may have different personal preferences needs to customize apps.
for example parents may want to disable components that could deliver inappropriate content to their children.
unfortunately due to the potentially diverse needs app customization andpersonalization are prohibitively expensive in terms of human effort for the development team if no automatic tools are available.
in this paper we propose a ui driven app customization technique that removes unwanted features in android appsthat are associated with given ui elements.
in particular our technique requires the user to first specify the ui elements denoting functionalities that she wants to remove.
usingthis information our technique automatically identifies the program locations that load the s pecific ui elements into code and store them in variables.
with such program locations our technique can then track all correlated uses of the ui elements and the code elements for relevant background tasks e.g.
acquiring data from remote serve rs.
while the ui related code elements are directly removable as indicated by the user the background tasks require more analysis to determine if theyare removable.
specifically our technique examines whether the background tasks generate data that exclusively flows tothe specified ui elements.
if so these background tasks areconsidered removable.
otherwise i.e.
the generated data gets propagated to other components the background tasks cannotbe removed.
the underlying analysis is a type system in which each code element is tagged with a type indicating if it should be removed.
the type system infers types forall correlated code elements from the ui hints.
finally our technique reduces the app acco rding to the deduced types.
our technique can be potentially used in the last stage of app development to generate a la rge number of customizations to meet different needs.
in addition it is designed in such a way that it does not require source code.
as such legacy apps whose source code and original developers are no longer available can benefit from our technique as well.
we evaluate our prototype on popular android apps.
our evaluation shows a substantial reduction of various resources .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research286 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
real time weathercondition wea thernews banner ad fig.
.
screenshot of app weatherbug.
usage.
on average removing certain ui elements associated with typical unwanted functionalities results in saving .
of data usage.
.
of cpu time .
wi fi runningtime and .
of computed power use.
our achieved results clearly demonstrate the strength of our proposed ui driven application reduction.
our work makes the following contributions we propose a ui driven approach to remove unwanted functionalities in android apps associated with ui elements specified by the user.
our technique features a typesystem that tags all relevant code elements to indicate if they are removable.
we implement a prototype and evaluate it on a set of real world android apps.
the results show that our approach accurately discovers the remov able code elements and the reduction leads to substantial resource savings.
ii.
m otiv a tion we use weatherbug a real world android app to motivate our technique.
weatherbug is a popular app thatprovides weather alerts real time weather conditions hourly forecasts and much more.
while the status bar notification provided by weatherbug is enough to check live weather conditions the user can launch the app to receive more detailed information and access more advanced features.
intuitively once the app is launched the user expects to get a view of real time weather conditions.
however the main page offers much more additional information.
as shown in figure themain page of the app contains the real time weather condition some weather news and a banner ad.
if we further scroll down the page contains more unrelated information such as photosfrom other users the closest spark strike and so on.
besides overwhelming the user with unrelated information these components consume additional energy and networkdata.
thus there is a need to customize refactor the app to remove some features that are not essential to various clients.
for example to prevent visual distraction reduce potential privacy leaks and malicious behaviors in an enterprise environment and to reduce energy and network dataconsumption in rough environments such as outdoors .
the overarching idea of our work is to customize an app to meetdifferent user needs by specifying what features are not neededon the ui.
suppose the user wants to remove some unwanted ui components and any associated func tionalities in the weatherbug app.
specifically consider the case in which the user selectsweather news the highlighted component in figure for removal.
figure shows simplified code snippets representing the corresponding work flow where ndescribes the execution order of a method.
when the component is loaded the android os invokes 1oncreateview which inflates a static layout file at line to hold the content ofthe component.
additionally a storiesadapter is created and added to the component.
this provides a binding from thecomponent specific data set to views that are displayed e.g.
the images and the titles of all inner elements.
the android os then invokes 2onactivitycreated that eventually launches a background functiona lity for acquiring data from a remote server.
once this data is loaded the background taskinvokes its callback method 3onrequestcompleted .i n this callback method the data i s transmitted to a thread and the thread is queued for execution.
later the android os executes 4run in the thread.
in run the data is retrieved and saved to a shared data set at line .
next the thread notifies storiesadapter about the data set change at line .
finally this data set change notification triggers the execution of 5oncreateviewholder and 6onbindviewholder .
the method oncreateviewholder creates a view holder with an inflated view and the method onbindviewholder obtains data from the shared data set and displays it on the inflated view at line .
in order to remove the unwanted component i.e.
the ui elements and functionalities associated with weather news our approach first receives the in formation associated with the elements specified by the user.
next it uses this information to discover the program locations loading the ui elements into code.
then it takes four steps to remove the ui elements and associated functionalities forwardly discovers all code related to the specified ui elements starting from wherethe ui elements use data backwardly tracks the data to its generation points in background functionalities examines whether the data obtained from the discovered data generation points are exclusively used by the specific ui elements or not iteratively removes the code.
in our motivating example lines and are associated with the unwanted ui elements.
our technique forwardly tracks the uses of the correlated variables as depicted by in figure and identifies lines and that put data to the specific ui elements.
line 7binds storiesadapter to the ui component to respond to data changes and displaysthe content acting similarly to an action handler.
we omit the discussion of tracking the adapter for simplicity.
line displays a short description of the corresponding image asshown in figure using the given data.
starting from line we backwardly track the data along onrequestcompleted and then the data generation point in the background functionality omitted in the code .
we further find the location authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1class storieslistfragment ... 2storiesadapter adapter arraylist data 3public view oncreateview layoutinflater inflater viewgroup vg bundle b view view inflater.inflate r.layout .stories v g recyclerview rv view.findviewbyid ... adapter new storiesadapter this rv.setadapter adapter return view public void onactivitycreated bundle b loaddata omitted public void onrequestcompleted request req updatestories ud new updatestories this req handler.post ud 20class updatestories implements runnable storieslistfragment fragment request request public updatestories storieslistfragment f request r fragment f request r public void run list list request .getresponse fragment .data .clear fragment .data .addall list fragment .adapter .notifydatasetchanged 34class storiesadapter extends recyclerview.adapter storieslistfragment fragment public viewholder oncreateviewholder viewgroup vg int type view v view.inflate ... r.layout .storiespage vg newsviewholder vh new newsviewholder fragment v return vh public void onbindviewholder viewholder vh int pos textview tv newsviewholder vh .findviewbyidr.id.
stitle storyinfo info fragment .data .get pos tv.settext info.gettitle 6indirect call ui related forward slicing backward data tracking forward data tracking nn th executed method fig.
.
simplified code snippet for the wea th er news component and the corresponding flows.
in class storieslistfragment 2public view oncreateview ... 3textview tv new textview ... 4tv.settext weather news removed 5return tv fig.
.
removing wea ther news.
invoking the background functionality at line .
next we check whether the generated data is only used in the specific ui elements by forwardly tracking the data from the data generation point following in figure .
we do not find any other components using the data in the example and thus the data is specific to the ui elements.
however the background functionality is found to be a public component used at other locations in the app and thus the discovered code inside the functionality including the data generation point cannot be removed.
finally our technique removes theother code not occurring in the background functionality and iteratively removes methods and classes if applicable.
to show the effect of the code reduction our technique replaces the layout inflation in oncreateview with a dummy view and eliminates all the othe r removable code elements.
the modified code snippet and the runtime screenshot isshown in figure .
the dummy view is depicted in the highlighted area.
as shown in section iv removing theweather news component reduces of the data usage and of the power consumption.app userui element discovery0 ui element tracking1backward data tracking2forward data tracking3 code removal4 modified app fig.
.
approach overview.
iii.
d esign in this section we will discuss our ui driven approach to discovering removable code elements in android apps.
figure shows the work flow of our approach.
as discussed in section ii after receiving the user specified ui elements and discovering the program locations referring to them step our approach takes four steps to detect potentially removable code elements 1forwardly discovers all uses of the specified ui elements 2backwardly tracks the data used in the ui elements 3finds all uses of the data starting from the discovered data generation points 4iteratively removes the code elements based on the results of data tracking.
steps and 1are discussed in section iii c section iii d describes steps 2and and section iii e talks about step .
we use the code snippet in figure throughout the section to exemplify the approach details.
assume that id0 andid1 refer to unwanted ui elements but id2 doesn t. bgtask represents a background functionality that obtains input data from remote servers and stores the result to data .
line abstracts the operations of obtaining input data byfunction getinputdata .
a concrete example is httpclient.execute which is commonly used in android authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
class a declares field data 2class bextends a 3a t new bgtask this trigger t 4b textview0 findviewbyid id0 unwanted textview0.settext data b 6class cextends a 7c g new bgtask this trigger g 8d textview1 findviewbyid id1 unwanted textview1.settext data .split textview2 findviewbyid id2 not unwanted textview2.settext data .split c 12class bgtask a ck bgtask a a ck a void run ck.data getinputdata bgtask fig.
.
code example for discussion.
program p k class k m method m m x s statement s x lc constant x linflate i inflation x lfindviewbyid i get view x l circleminusy unary assignment x ly z binary assignment x l y z value merging in ssa x ly.z get field x .
y lz put field x lcheckcast y type cast x lnew k y new instance x ly.m z method call r e t u r nl x return in a method va r i a bl e x y z all variables id i ui related id v alue c non id constant label l l1 l2 l3 ... fig.
.
simplified language model.
apps to fetch remote data from web servers.
the data acquisition task is initiated at two locations line and line .
the data is displayed on ui elements at lines and .
a. language abstraction to simplify our discussion we introduce an abstract language as presented in figure .
a program is made up of classes a class contains a list of methods and each method contains a number of statements.
we model common types of statements and other operations are abstracted away or simplified.
we label statem ents with a superscript.
as we discussed in section ii we start our analysis from the layout inflations and aim to remove the inflated views.
thus we introduce the function inflate to represent all kinds of inflations in the code e.g.
lines and in figure .
additionally we introduce another function findviewbyid to represent the operation of an app looking for a ui element.
we abstract all types of assignment such as unary assignment binary assignment type cast assignment and assignment from to a field variable.
note that our language is a kind of single static assignment ssa language such that conditionals including loops are implicitly represented by the value merge statement y z .
since the predicate of the value merge statement is irrelevant in our analysis it is abstracted away and hence yandzdenote the values of the same variable in the two branches of a conditional.
statementsin m methodsin k x thisof k x paramof m s returnof m fig.
.
functions for class method and statement .
for object creation i.e.
new instance statement and method calls we assume there is only one parameter besides thereceiver object this of an instance method call.
a return statement returns a value fro m a callee method to a variable in the caller method.
we also define a number of auxiliary functions for statements methods and classes to acquire correlated informationduring analysis.
these functions are shown in figure .function statementsin returns all statements inside a method represented by .
similarly methodsin returns all declared methods in a class k. functions thisof and paramof behave similarly except that one looks for this reference in the callee method and the other searches the corresponding formalparameter.
the return statement of a method is given by returnof .
b. type system we formalize our approach in a type system.
code elements including variables statements methods and classes are associated with tags.
a tag is treated as the type tof the code elementl.w es a y lhas type t written as l t. the type of a code element may be a set of tags for example l t t prime .
in this case we use to union two sets of types together.
in this paper we define the type domain as type braceleftbiguirelated uidata inputuidata removable unremovable bracerightbig type uirelated is used to mark the variables or statements that depend on the specified ui elements.
we type the code elements with it and propagate it at step .f o r example we type an inflate method call where the inflated view is a user specified ui element and the resultantvariable with uirelated .
when we find any data uses on the specified ui elements we type the data variable with uidata and then backwardly propagate it at step .i fw e reach a data generation poi nt along above propagation we get the knowledge that the data is some input data from outside sources.
we type the data generation point and the data variable with inputuidata and propagate it forwardly step .
eventually we can mark which code elements are removable or definitely unremovable using the correspondingtypes step .
notice that type inputuidata can be parameterized with a data generation point.
it will help us distinguish the typesof code elements which are correlated with multiple data generation points.
in addition to the concrete types if any code element has not been visited or is not interesting to us we say it is not typed in the notation of nil.
consider that the same code element executed in different calling contexts may produce different results and in some contexts it may be related to the specified ui elements while authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ui inflatebelongtospecifiedui i 1 x linflate i epsilon1 1 ui findviewbelongtospecifiedui i 1 x lfindviewbyid i epsilon1 1 ui call thisnonapi m turnstilelefty epsilon1 uirelated epsilon1 prime epsilon1 lt thisof m 1 x ly.m z epsilon1 1 ui bassign 1 turnstilelefty epsilon1 uirelated 1 x epsilon1 ly epsilon1 z epsilon1 epsilon1 1 ui return 1 turnstileleftr epsilon1 prime uirelated epsilon1 prime epsilon1 lx ly.m z 1 returnl prime r epsilon1 prime x epsilon1 l prime epsilon1 prime l epsilon1 uirelated 1 fig.
.
rules for discovering code elements associated with the ui elements.
in other contexts it may not be.
we use epsilon1to represent the calling context which is a stack of labels referring to method calls or new instance sites.
each code element lis tagged with a context e.g.
l epsilon1 in order to conduct context sensitive analysis.
different contexts are depicted by the subscript of epsilon1 e.g.
epsilon1 1and epsilon12.w eu s e to concatenate a context with a label to form a new context for the statements in the callee method associated with l for example epsilon1 prime epsilon1 l. the mappings from the code elements to the types form the context of the type system which is iteratively updated during analysis until a fixed point is reached.
for example at the beginning is empty.
upon a removable statement l epsilon1 is updated to l epsilon1 removable .
at this point we have turnstileleftl epsilon1 removable which means under type context statement l epsilon1is typed with removable .i no t h e rw o r d s l epsilon1 removable w h e r e l epsilon1 evaluates statement l epsilon1in the context to obtain the corresponding type.
when a statement l epsilon1is evaluated the context may be updated.
we use l epsilon1 primeto indicate that under type context evaluating code l epsilon1updates the context from to prime.w eu s e to represent an update to the context.
specifically if no mapping is found for l epsilon1in t h e mapping is added to the context.
but if there exists a mappingforl epsilon1 the rule substitutes the existing type of l epsilon1with type t. multiple mappings can be updated simultaneously.
for instance l epsilon11 t l prime epsilon12 t prime update the context for two code elements l epsilon11andl epsilon12.w ea l s ou s e l epsilon11 l prime epsilon12 t to denote l epsilon11 t l prime epsilon12 t for brevity.
in the following analysis we define four type contexts 1 2 3and 4for the four steps respectively.
we also have a special context mr in which the discovered data generation points are mapped to true orfalse indicating whether the corresponding data generation points must be retained or not.
c. turning off ui element in this section we discuss how to identify the code elements related to the unwanted ui elements i.e.
steps 0and 1in figure .
starting from inflate and findviewbyid w ef o r w a r d l y track the uses of the specified ui elements and type all correlated statements and variables with uirelated .
we define the rules in figure .
we omit the rules for some statements e.g.
unary assignment assignment and field access due to the space limit.
in addition we do notpresent the rules for api method calls that require models.new instance operations behave similarly to method calls and thus we omit the corresponding rules too.
based on the language definition the user specified ui elements are introduced into the code through layout inflation inflate or view finding findviewbyid .
we apply rules uiinflate and ui findview to start the analysis.
if the given id is corresponding to a specified ui element we say the resultant variable and the statement are related to specific ui element.
if the receiver object yof a method call mis typed with uirelated the definition of ywill be potentially removed.
the removal results in a null r eference leading to run time exceptions.
therefore we apply rule ui call this in this case to type the resultant variable x the method call statement land the corresponding this reference in the callee method with uirelated .
if an actual argument zis typed the behavior is similar to ui call this and the corresponding rule is omitted.
rule ui bassign indicates that if a right hand side variable is typed the left hand side variable and the statement are typedtoo.
rule ui return is applied when a return variable in a callee method is typed with uirelated .
it propagates the type to the resultant variable at the corresponding call site andtypes the call site with uirelated .
example consider applying the rules to the code snippet in figure .
first we type textview0 andtextview1 lines and with uirelated by rule ui findview.
then through type propagation lines and are typed with uirelated .
we present the context updates as follows.
epsilon1 1is the calling context of method b.b and epsilon12is the calling context of method c.d .
ui findview line epsilon11 l i n e8 epsilon12 textview0 epsilon11 uirelated textview1 epsilon12 uirelated lines epsilon11 epsilon12 uirelated ui call this line epsilon11 l i n e9 epsilon12 bracketleftbiglines epsilon11 epsilon12 uirelated bracketrightbig 1 d. discovering associated background functionalities if we reach some api method calls that put data to the specified ui elements for display we track where the data is generated.
we backwardly track the generation of the data and type all the involved statements and associ ated variables with uidata step .
when we reach a data generation point that acquires data from outside sources e.g.
httpclient.execute we use inputuidata authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ui put data 1 turnstilelefty epsilon1 uirelated 1 turnstileleftl epsilon1 uirelated apiputdatatoui m 1 x ly.m z epsilon1 2 bwd assign 2 turnstileleftx epsilon1 uidata 2 x ly z epsilon1 2 bwd call return 2 turnstileleftx epsilon1 uidata nonapi m epsilon1 prime epsilon1 l returnl prime r returnof m 2 x ly.m z epsilon1 r epsilon1 prime l prime epsilon1 prime l epsilon1 uidata 2 bwd call paramnonconstructor m epsilon1 prime epsilon1 lp paramof m turnstileleftp epsilon1 prime uidata 2 x ly.m a epsilon1 2 fig.
.
rules for backwardly discovering data relevant code elements.
bwd call data gen 2 turnstileleftx epsilon1 uidata apigetinputdata m 2 x ly.m z epsilon1 x epsilon1 l epsilon1 3 l epsilon1 inputuidata l 3 fwd assigninputuidata ld 3 y epsilon1 3 x ly z epsilon1 x epsilon1 l epsilon1 3 x epsilon1 inputuidata ld 3 fwd call thisnonapi m inputuidata ld 3 y epsilon1 epsilon1 prime epsilon1 lt thisof m 3 x ly.m z epsilon1 x epsilon1 t epsilon1 prime l epsilon1 3 x epsilon1 inputuidata ld 3 fwd call returninputuidata ld 3 r epsilon1 prime epsilon1 prime epsilon1 lx ly.m z 3 returnl prime r epsilon1 prime epsilon1 prime x epsilon1 l epsilon1 l prime epsilon1 prime 3 x epsilon1 inputuidata ld 3 unexpected data useinputuidata ld 3 z epsilon1 uirelated 1 y epsilon1 apiputdatatoui m 1 3 x ly.m z epsilon1 mr ld true fig.
.
rules for discovering the uses of input data.
to type the data variable and the statement indicating their correlation with input data.
we then forwardly propagate inputuidata along data flows step .
along the forward propagation we parameterize inputuidata withld ad a t a generation point to distinguish data originating from different points.
if we encounter any cases in which the tracked data is used in some ui components other than the unwanted ones we need to remember that the corresponding data generation points from which the data propagations are unremovable.
we define the backward propagation rules in figure and theforward rules in figure .
step 2starts with the discovery of api calls putting data on specified ui elements.
rule ui put data initiates the context 2which stores mappings from variables or statements to type uidata by typing the data variable with uidata .b w d rules are then applied to propagate the type backwardly.
if a re sultant variable xis typed in a method call the corresponding return value rin the callee method should also be typed bwdcall return .
if a formal parameter pin a callee method is typed the corresponding actual argument at the caller is typed bwd call param .
if the typed variable is this reference in the callee method we type the c orresponding receiver object.
during the propagation if we meet a api method call that acquires outside data and stores the data to any variables under tracking we consider the method call as a data generation point and thus type the data variable and the data generation point with inputuidata in context bwdcall data gen .
given the fact that a code element may becorrelated with multiple data generations we associate eachtypeinputuidata with the location of data generation and we use a set to represent the type of a code element.
forexample statement a b cconcatenates two strings and bis generated by a method call at l 0while cis generated atl1.
therefore ahas a type of inputuidata l0 l1 .
if either one of the data generation points cannot be removed this statement is unremovable.
the forward propagation rules are straightforward similar to the ones for discovering ui related code elements except that type inputuidata is parameterized with a data generation point and the resultant type is a union of the incoming type and the original types.
if the input data is discovered to be used by some ui elements that are not correlated with the unwanted ui elements we apply rule unexpected data use and mark in context mr that the corresponding data generation point must be retained i.e.
unremovable.
example we apply the rules to the example in figure .
backward data tracking updates 2as bracketleftbigdata ... data ... line ... l i n e1 ... uidata bracketrightbig 2 we use ... n to denote the calling context of method run where ndenotes the line number of corresponding trigger site.
the background functionality is triggered in two contexts one at line and the other at line .
this results in different instances of variable data and the statement of getting input data.
therefore variable data at line is defined in two calling contexts represented by data ... and data ... .
starting from the data generation points we have data ... l i n e1 ... l i n e5 epsilon11 inputuidata line13 data ... l i n e1 ... inputuidata line13 line epsilon12 l i n e1 epsilon12 inputuidata line13 at line the data is sent to a unspecified ui element and the line is typed with inputuidata line13 .
with authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
rule unexpected data use we mark the corresponding data generation point as mr line13 true saying that the corresponding data generation point must be retained.
e. removing code elements after we type all data correlated statements with one or more inputuidata types we can finally determine which code elements are removable or unremovable step .
the rules are shown in figure .
we use lto aggregate the code element in allcalling contexts i.e.
l epsilon1jfor allj.
rule remove stmt says if a code element lis directly related to the specified ui elements in all possible calling contexts it is absolutely removable.
if lin a context epsilon1has a type of inputuidata which is associated with some data generation point ld and the data generation point needs to be retained when lis not a ui related code element rule unremove stmt declares las unremovable.
in contrast if the corresponding data generation point is not required to beretained and the target lhas not been typed with unremovable we use remove stmt to mark las removable.
rules remove method and remove class behave similarly.
if all call sites of a method or instantiation sites of a class areremoved the method or the class can be fully removed.
the last two rules iteratively remove included code elements when a method or a class is removable.
we are also able to find out the trigger sites of background functionalities like the start call of a thread object or execute call on an asynctask instance.
if the triggered operations in b ackground functionalities are all removable we can remove the corresponding trigger sites aswell.
furthermore we do not re move branch statements like ifandswitch even if they use variables whose definitions are removable.
instead we replace the definition statement ofeach such variable with a statement that assigns or null to that variable depending on the type of the variable.
example we can now apply the rules to remove code elements in figure .
we have bracketleftbigg line line line line removable line line unremovable bracketrightbigg 4 therefore we can remove lines and .
the background data generation point at line cannot be removedbecause its data flows to non specified ui elements at line .
however under the context of class bwhere the data is only used in the unwanted ui elements we can disable thecorresponding trigger of the b ackground functionality to avoid unnecessary network access after we remove the unwanted ui elements.
we discover the corresponding trigger site at line and we type it with removable while we retain the trigger site at line .
iv .
e va l uat i o n we implement a prototype t ofu t urning of fu ie l e m e n t s to discover the removable code elements for specified unwanted ui elements.
t ofu is built on top of soot supporting rewriting modified code to dex files.
we evaluate tofu on popular android apps table i .
t ofu runs ontable i benchmark apps and removed ui.
app removed ui description weatherbug wea ther news weather related news dictionary.com blog slideshow word related items on main page baidu iknow latest q a real time update on main page walmart recommendation recommended items based on macy s the other users choices china calendar news button a button to news page fox news sponsored stories ad in each news page cbs news banner ad banner ad associated with each news title and brief introduction ap mobile banner ad bottom banner ad in each page tattoo my photo banner ad an intel core i5 .5ghz machine with windows and 8gb memory.
in our experiments we specify the ui elements that represent the unwanted features based on our understanding of the expected app behavior.
the unwanted components include normal functionalities that certain users may not need e.g.
word related additional information on the main page in a dictionary app irrelevant buttons e.g.
a button leading to a news page in a calendar app and advertisements.
more details can be found in table i. we manually obtain the corresponding ids of the specified ui elements.
t ofu then automates the aforementioned a nalysis and the generation of the modified apk file.
specifically given an app we run it to the pages containing ui components correlated with theunwanted functionalities in a nexus 6p running android .
.
.
we then use the android sdk tool uiautomator viewer toobtain the dynamic ui hierarchy on which we select thecomponents to be removed corresponding to the unwanted features .
we feed the corresponding information ids of layouts and ui elements to t ofu .t ofu then statically analyzes the app code removes the code elements markedas removable and rewrites the modified code to dex files constructing a new apk file.
next we sign the apk file and run it in the same device in order to measure the savings resulting from our code reduction.
each pair of apps original and modified are kept running for minutes and then their power use is examined.
since the power consumption profiler rounds the result up to an integer it may not be able to tell the differences in somecases.
if the values are not distinguishable we continue to test the pair of apps for anot her minutes.
for each app at the beginning of first run we disable potential live contentupdate e.g.
push notifications that may largely influence the results.
for example the app ap mobile updates its displayed live news in the background.
if we allow all the categories e.g.
sports entertainment to update in a minute run we observed 73mb of data usage minutes of cpu time and mah of power use.
after unsubscribing all categories except the top news the data usage is reduced to less than 10mb.
a. experiment results our evaluation aims to measure the benefits of our code reduction with regards to two aspects data usage and battery usage.
to evaluate the data usage reduction we select authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
remove stmt 1 1 turnstileleftl uirelated 4 4 unremove stmtinputuidata ld 3 l epsilon1 mr ld l negationslash uirelated 4 4 remove stmt 2inputuidata ld 3 l epsilon1 mr ld l negationslash unremovable 4 4 remove methodnonapi m x ly.m z 4 turnstileleftl removable 4 4 remove classnonframeworkclass k x lnew k y 4 turnstileleftl removable 4 4 remove stmts 4 turnstileleftm removable l statementsin m 4 4 remove methods 4 turnstileleftk removable m methodsin k 4 4 fig.
.
rules for removing code elements.
table ii experiment results .
app data usage cpu total wi fi running computed power use original modified reduction original modified reduction original modified reduction original modified reduction weatherbug .84mb .33mb .
2m05s 1m59s .
8m02s 5m48s .
5mah 4mah .
dictionary.com .21mb .20mb .
4m22s 3m56s .
32s 21s .
8mah 7mah .
baidu iknow .86mb .42mb .
2m08s 1m18s .
1m07s 1m06s .
5mah 3mah .
walmart .67mb .02mb .
8m08s 7m58s .
1m50s 1m03s .
17mah 14mah .
macy s .09mb .32mb .
6m06s 4m35s .
22s 21s .
11mah 8mah .
china calendar .49mb .26mb .
9m35s 6m24s .
32s 24s .
16mah 11mah .
fox news .71mb .52mb .
6m56s 6m43s .
27s 19s .
21mah 18mah .
cbs news .55mb .21mb .
8m00s 2m40s .
38s 27s .
17mah 5mah .
ap mobile .63mb .09mb .
4m55s 1m44s .
21s 12s .
12mah 6mah .
tattoo my photo .79mb .04mb .
10m13s 1m00s .
41s 31s .
25mah 2mah .
average .
.
.
.
removable ui elements that are correlated to network access and measure the incurred data usage before and after their removal.
similarly to evaluate the battery usage we measure the app s total cpu time wi fi running time and computedpower use before and after the code reduction.
we obtain this detailed information through the setting app.
we present the experiment results in table ii.
from table ii we observe that removing some unwanted functionalities and associated ui elements has a minimum reduction of .
for data usage weatherbug .
for total cpu time walmart .
for wi fi running time baiduiknow and .
for the computed power use dictionary.com .
the maximum reductions for the four factors are .
.
.
and .
respectively.
eventually we obtain average reductions of .
.
.
and .
for the four factors which demonstrate the effectiveness ofour approach.
figure depicts the time required to analyze the apps alongside their dex code size.
as shown the analysis time increases as the code size increases.
we have also observed that apps with more complex removable functionalities take longer time to be analyzed.
for example the weatherbug app see section ii requires more than minutes to finish theanalysis while the china calendar app in which a button is disabled only needs one and a half minutes.
.
.
.
.
.
.
.
analysis time minute size mb fig.
.
app analysis time and the dex code size.
search box word of the day blog slideshow a app dictionary.com clickingmain page news page b app china calendar fig.
.
screenshots of dictionary.com and china calendar.
b. case studies in the following we use a few cases to illustrate the application of our approach.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
removing unwanted app components we use unwanted app components to refer to those ui elements that display information provided by the app providers not thirdparty advertisement but are probably unwanted by the users e.g.
the wea ther news in the weatherbug app figure .
here we study one more case from the dictionary.com app in this section.
as shown in figure 13a the main page of the app contains a search box a tag for the word of the day and a list of othertopics about language grammar etc.
usually a user launches the app to look for words and does not expect to be distractedby the other irrelevant contents which inevitably consume additional data and battery.
in our experiment we remove the irrelevant contents blog and slideshow features from theapp which are populated through some background services.
specifically t ofu first locates the program locations firing the background actions and then disables their invocations.
as a result the blog and slideshow tags are prevented from being displayed on the main page leading to .
data usage reduction and .
power usage reduction.
removing unwanted user actions the china calendar app com.veryapps.hl helps users explore the lunar calendar e.g.
current lunar day auspicious information etc.
.
however the app contains a button in the main page which once clicked launches a new page acting similar to a news app figure 13b .accidentally clicking the button will cause unexpected data usage and battery consumption.
the implementation is as follows in class mainactivity 2public void oncreate bundle b omitted operations 3btn findviewbyid r.id.btn news category 4btn.setonclicklistener this 6public void onclick view v 7intent i new intent this newscategoryactivity.
class 8startactivity i the button handler is simplified in method onclick at line in which a new activity presenting the news is started line .
the unwanted ui element is referred to at line .
t ofu forwardly tracks the uses of the ui element and types lines and .
it further tracks and types the button handlerand the launched activity.
after reduction e.g.
lines and the functionality of the button is disabled.
based on our experiment the removal saves .
of data usage .
of cpu time of wi fi running time and .
of power use when we click the button in original app once per minute for minutes.
removing advertisements advertisements are commonly used in android apps for monetization purposes.
how ever mobile advertisements have long been considered a source of distraction for users responsible for additional network data and power consumption not to mention the risks of privacy leaks and potentially malicious behaviors exhibited by advertisement libraries .
banner ad displayed usually at the bottom of the screen see figure is the most common type of mobile advertisement.as shown in table ii removing the banner ads in apps cbs 1class articlefragment ... 2loadercallbacks callback oadapter madapter 3arraylist contents 4articlefragment callback new loadera this madapter new oadapter ... 8void onactivitycreated bundle b loadermanager.initloader ... callback 12class loadera implements loadercallbacks articlefragment fragment loader oncreateloader int i bundle b return new oloader ... void onloadfinished loader l object d fragment .contents arraylist d fragment .madapter .updatecontent arraylist d 22class oadapter ... arraylist alist void updatecontent arraylist list alist .addall list this .notifydatasetchanged view getview int pos view v viewgroup vg vv inflater.inflate ... unwanted ui content alist .get pos vv.set content detail omitted uirelated uidata inputuidata fig.
.
code snippet for fox news.
news ap mobile and tattoo my photo has led to a significant reduction of data usage and battery consumption.
app fox news adopts another type of advertisement which displays several pieces of ad titles and images.
we noticed thatsuch advertisement is heavily integrated with the app code compared with the simple banner ad as shown in figure .
we also show in the same figure what the correlated statements are typed with.
for example in their own calling context line is typed with uirelated in 1and line is typed withuidata in 2andinputuidata in 3. the classes loadera andoadapter are only used as shown in the code snippet and thus all the typed statements are removable.our analysis further locates the trigger for the backgroundfunctionality at line to disable its invocation.
according to table ii removing the unwanted advertisement in this app results in .
of data usage reduction and .
of poweruse reduction.
c. discussion as mentioned in the introduction our technique is intended to help the development team automatically generate various customizations and personalizations of an app at the endof development cycle.
it is also desirable for retrofitting legacy apps whose source code or original developers are no longer available.
for instance instead of patching a securityvulnerability in a legacy app the maintenance team may choose to remove the corresponding feature.
while it is a valid concern that disabling some features such as advertisements may have negative impact on the income of the development team we anticipate that an alternative business model is for thedevelopment team to sell customized versions at a higher price to compensate for the loss.
a more aggressive business model authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
may be to sell the right of customization using a technique like ours that is certified by authorities to the end users e.g.
enterprises such that the customized versions will be signedby the original development team or some authorized party on their behalf to avoid possible legal issues.
as an initial effort of customizing apps by removing features our technique is limited to reducing features associ ated with given ui elements.
w e expect in the future more techniques can be developed to customize reduce other app features e.g.
background tasks not related to uis .
in addition our analysis inherits the limitations of android app analysis .
specifically our approach re quires a precise and complete call graph which is usually not satisfied in android app analysis.
context sensitive analysis as depicted in section iii is resource intensive which inevitably hinders arbitrary app code reduction.
besides theunderlying rewriting framework soot limits the capability of our prototype.
even though all the apps run well without errors after code reduction we found that some other apps e.g.
cnn don t work correctly after the transformation of dex code by soot even if we remove nothing in the code.in addition removing ui elements e.g.
advertisements that are embedded in html pages rendered by w ebview is notsupported.
while our technique has usability in consideration to begin with as it allows users to express their needs through the ui which is far more intuitive than some formal specificationlanguage the implementation is still a research prototype whose user interface has many places to improve.
v. r ela ted work techniques have been proposed for detecting arbitrary thirdparty libraries including ad libraries in android apps.
some rely on simple techniques such as white listing namespaces of popular ad libraries .
narayanan et al.
distinguished primary and non primary modules of apps through hierarchical clustering whereas liu et al.
developed a classifier for ads detection based on code features and package relationship .
libradar relies on api frequencies.
along the same line backes et al.
proposed an obfuscation resilient ad detection technique through extracting profiles resilient to commonobfuscation techniques and relying on class hierarchy rather than code .
in comparison our technique is more general.
it focuses on removing features indicated by users on the ui not just ads.
it does not rely on specific code patterns.
there are also techniques that detect redundancy in applications .
their purpose is to make the software systems more resilient to failures and to leverage duplicated code as test oracles.
they are complementary toour technique as redunda nt code can be removed replaced for better quality.
they discover redundant code starting fromfaulty components in programs while our approach starts fromuser specification of ui information.
in addition a lot of works aim at improving energy efficiency.
gottschalk et al.
detected and removed energywasting code in android apps with the knowledge of energy inefficiency patterns .
sahin et al.
studied energy consumption caused by code obfuscation in mobile apps .
gui et al.
measured energy consumption of mobile ads .
banerjee et al.
proposed a technique of refactoring android apps to enhance energy efficiency following a set of guidelines .
wu et al.
statically detected energy defects in app uis with predefined energy draining patterns .
our proposed approach doesn t rely on code patterns nor does it require domain knowledge to work properly.
energy savingoccurs because of the removal of selected unwanted features.
martins et al.
presented t amer to improve battery lifetime by instrumenting the android os and interposing events andsignals that cause background task wakeups .
linaresv seuez et al.
and li et al.
proposed approaches for reducing display energy through automatically changing the color schemes.
there are works using ui info rmation to detect attacks or privacy leaks.
asdroid uses ui information to confirm whether a program behavior is expected by the app user.
supor uipicker and bidtext utilize ui information to check data sensitiveness displayed or enteredon ui.
in particular bidtext features a type system for information disclosure detection by recognizing the text information as types and performs type propagation along data flows.
the type based taint analysis system developed by ernst et al.
predefines a few security types and checks if types reach a program point are compatible .
vi.
c onclusion w e propose a static technique to remove code elements in android apps.
the code elements are relevant to user specified unwanted ui elements.
the approach identifies the program locations directly refe rring to the specific ui elements and applies a type system to infe r removable code elements.
each reachable code element is tagged with a type that ispropagated.
the types are used to determine whether thecorresponding code elements are removable or not.
in addition to removing code elements that are related to the specified ui elements our technique is also able to discover the associated background functiona lities and type the c orresponding code elements in the background functionalities such that they canbe removed too.
w e implement a prototype and evaluate it on real world android apps.
the results show that our approach can accurately identif y removable code elements associated with the specified ui elements and removing those functionalities leads to substantial resource savings.
a cknowledgments w e thank the anonymous reviewers for their constructive comments.
this research was supported in part by darp a under contract fa8650 c nsf under awards and and onr under contracts n000141410468 and n000141712947.
any opinions findings and conclusions in this paper are those of the authors only and do not necessarily reflect the views of our sponsors.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.