launch mode aware context sensitive activity transition analysis yifei zhang unsw sydney australiayulei sui university of technology sydney australiajingling xue unsw sydney australia abstract existing static analyses model activity transitions in android apps context insensitively making it impossible to distinguish different activity launch modes reducing the pointer analysis precision for anactivity scallbacks andpotentiallyresultingininfeasibleactivitytransitionpaths.inthispaper weintroducechime alaunch modeaware context sensitive activity transition analysis that models differentinstancesofanactivityclassaccordingtoitslaunchmode and the transitions between activities context sensitively by working together with an object sensitive pointer analysis.
our evaluation shows that our context sensitive activity transitionanalysisismoreprecisethanitscontext insensitivecounterpartincapturingactivitytransitions facilitatingguitesting and improving the pointer analysis precision.
ccs concepts theory of computation program analysis software and its engineering object oriented languages keywords android pointer analysis activity transition analysis acm reference format yifeizhang yuleisui andjinglingxue.
.launch mode awarecontextsensitiveactivitytransitionanalysis.in icse icse 40th international conference on software engineering may june gothenburg sweden.acm newyork ny usa 11pages.
introduction activity as a majortype of android components lies at the heart of the android programming framework due to its event driven nature.
an activity acts as a container consisting of various gui elements e.g.
views and text boxes through which users interact with an app for activity navigations i.e.
transitions between differentactivities.conceptually anappexecutesalongtheactivity transition paths and other callbacks are sprawled out of them.
thankstoallthereviewersfortheirvaluablecomments.thisresearchissupportedby arcgrants dp170103956andde170101081.yifeizhangissupportedbyanaustralian government research training program scholarship.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
class search extends activity void onclick ... startactivity new intent this search .class void oncreate ... ... void onstart ... ... void onrestart ... ... android framework startactivity intent intent ... find target activity instance based on the launch mode a findactivity intent if a null a createnewactivity intent a.oncreate a.onstart ... else a.onrestart ... omain o3 o a application code c two activity transition sequences when search activity is configured under standard left and singletask right launch modes b library pseudo code1 class home extends activity void onclick ... startactivity new intent this search .class home search searchomainhome o3search figure three activity transitions represented by and via callbacks homelaunches searchand searchlaunchesitselfwith standard andsingletask modes.
afundamentalstaticanalysisforandroidappsistomodelactivity transitions for event driven callbacks.
this serves as a cornerstoneformanyclients suchasvulnerabilitydetection malware detection and mitigation gui model generation and gui testing .
thecore datastructureused foranapp isan activity transition graph atg which represents the activity transitions in theapp.inanatg anoderepresentsanactivityinstanceandan edge between two nodes denotes an activity transition.
in android a parent activity can start a child activity by invoking e.g.
startactivity as a form of an inter component communication icc call passing it an intent that describes the child activity to be launched.
in addition an activity instance ofa class say tcan be launched in one of the four launch modes standard singletask singletop andsingleinstance either configured in androidmanifest.xml or specified in the intent passed to startactivity .
the first one is the default while the otherthreeareknownasspeciallaunchmodes.theselaunchmodes affectwhichactivityinstancesarelaunchedandtheirtransitions.
for example standard always requests a new activity instance of tto be launched while singletask requires an existing activity instance of tto be reused if it exists by thus limiting only one instance of tin each activity transition path .
figure gives an example to demonstrate how we intend to use an atg to keep track of activity transitions in the presenceof icc calls under different launch modes with searchbeing configured once with standard and once with singletask .w e assumeanavigationscenariowheretheuserclicksabuttononthe acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yifei zhang yulei sui and jingling xue currenthomeactivitytolauncha searchactivityviatheicccall startactivity at line .
next the user clicks another button onthelaunched searchactivity causingeitheranew searchactivity with standard ortheexistingone with singletask tobe launched via the icc call startactivity at line .
letusunderstandtheinternalworkingoficccallbacksinthe abovenavigationscenarioforthethreetransitionsashighlightedin black redandbluearrows.therearethreestepsforeachtransition viatheandroidcallbackmechanismwhenanapp figure1 a interacts with the android framework figure b .
first the app code passesanewintentobject line3 totheframework line10 .second the framework finds the corresponding activity instance a line basedonthelaunchmodespecified.asshowninfigure1 b anew instanceiscreated line13 iftheactivityislaunchedforthefirst time i.e.
ohome mainosearch o ri nstandard mode with the transition osearch 3osearch6 whereosearch 3andosearch6are twodifferentinstancesof search.finally theframeworklaunches searchvia the callbacks lines to their corresponding lifecycle methods lines .
if a special mode singletask is used the android framework will retrieve the existing searchinstance to restart the activity line osearch .
building atgs statically to reason about activity transitions for android apps is challenging.
unlike a java program with a dedicated main method an android app can have multiple entry points with some activities implicitly launched by the android framework through nondeterministic user and system events.
this can significantly complicate static activity transition analysis in the presence of a large number of callbacks.
in addition activity transitionsthroughiccmakeuseofintentobjectstospecifytarget activities launched requiring a precise pointer analysis to discover thecontentsinsuchintents.finally theheapallocationsitesforac tivityinstancesareinvisibleintheappcode astheyaredistributed via deep call chains in the android framework.
thus performing a precise pointer analysis for an app over the entire android framework with millions of lines of code is unrealistic .
existingguitestingtechniques usecontext insensitive atgs to model activity transitions in android apps implying that allinstancesofanactivityclassareabstractedwithonesingleob ject.thus context insensitivitymakesitinherentlyimpossibleto distinguish different activity launch modes reduces the pointer analysis precision for an activity s callbacks and potentially introduces infeasibleactivity transition paths.to analyzethe callbacks ofanactivity existingstaticanalyses construct a fat harness main consistingofoneallocationsiteperactivity class for allocating one single abstract object for the class and the calls to all its callbacks e.g.
oncreate andonclick o nt h e abstractobject.infigure1 osearch willbecreatedregardless of thelaunch mode specifiedfor search.
thetransitions between activities are modeled context insensitively as discussed section .
toaddresstheabove mentionedchallengesinmodelingactivity transitionsandthelimitationsofthepriorwork wepresentchime a launch mode aware context sensitive activity transition analysis for android apps that builds context sensitive atgs together with an object sensitive pointer analysis .activity aware object sensitive pointer analysiscontextsensitive atgpreprocessing launch mode analysischime slim harness main intent filterslaunch modestargets of icc calls activity behaviors modeling figure an overview of the chime framework.
by maintaining context sensitivity in tracking activity transitions chime can model launched activities based on their launch modes andreducethenumberofinfeasibletransitionpaths thatwould otherwisebeintroducedcontext insensitively .bydistinguishing different instances of an activity class based on their activity transitionsequencesascontexts chimeavoidshavingtoanalyzethe androidframework e.g.
tolookfortheheapallocationsitesfor activities and improves the pointer analysis precision for the callbacks of an activity.
figure depicts our framework.
the activity aware objectsensitivepointeranalysisandlaunchmodeanalysisaremutually dependent.
its preprocessing phase extracts metadata including activity launch modes and intent filters for an android app.
unlike existingstaticanalyses whichuseafatharness main for allocatingall theactivities andcalling its callbacks as mentioned earlier chime builds an atg for an app by using a slimharness main consistingofinitiallythesameinformation but restricted to the entry activities i.e.
the ones registered via intent filters or exported to the system.
the other activities will be gradually introduced into the atg during the analysis.
this paper makes the following contributions weintroducealaunchmodeanalysisfordistinguishinglaunched instancesofanactivityclassbasedonthelaunchmodespecified.
we introduce chime a launch mode aware context sensitive activitytransitionanalysisthattracksactivitytransitionscontextsensitively together with an object sensitive pointer analysis.
wehaveimplementedchimeinthedroidsafeframework .
evaluated with a set of large real world android apps from googleplay chimeisshowntobemoreprecisethanitscontextinsensitive counterpart in modeling activity transitions guiding gui testing and improving the pointer analysis precision.
motivation insection1 wehaveusedanexampleinfigure1toexplainwhy modeling activity transitions context sensitively is essential in accounting for the effects of launch modes on launched activities.
in this section we use another example to demonstrate why such context sensitive modeling is also essential in modeling accurately activitytransitions improvingthepointeranalysisprecision and potentially reducing the number of infeasible activity transitions.
with this second example in figure we show how chime modelscontext sensitivelytheactivityinstanceslaunchedfor home newtrip tripview andeditfolder andtheirtransitions byconsideringtheirlaunch modes.
infigure3 a we see acodesnippet from tripview arealpublictransportationtripplantool.
homeis themainactivity.twolaunchmodes singletask andstandard will be considered.
the other three activities configured under standard launch mode are not exported to the system .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
launch mode aware context sensitive activity transition analysis icse may june gothenburg sweden class home extends activity the button registered with the following callback void onclick view view intent hmtont new intent this newtrip.
class startactivity hmtont a list registered with the following callback void onitemselected ... int pos long row if getitem pos instanceof tripfolder intent hmtotv new intent this tripview.
class startactivity hmtotv ... void onnewintent ... intent eftohm ... class newtrip extends activity the new folder button registered with the following callback void onclick view view intent nttoef new intent this editfolder.
class startactivityforresult nttoef ... void onactivityresult ... intent eftont ... class tripview extends activity a menu registered with the following callback void oncontextitemselected menuitem menuitem if menuitem .getitemid editfolder intent tvtoef new intent this editfolder.
class startactivityforresult tvtoef ... ... void onactivityresult ... intent eftotv ... class editfolder extends activity a menu registered with the following callback void oncontextitemselected menuitem menuitem if menuitem .getitemid save intent ret new intent ret.putextra folder name name setresult ... ret else if menuitem .getitemid home intent eftohm new intent this home.class startactivity eftohm ... a app code abstracted from tripview homenewtrip tripvieweditfolder b activity transitions including gui events ohm ont otv oef c context insensitive atg omain o10 o5 o16 o23 nt nttv tvhm hm hmhm hm ef ef d context sensitive atg singletask forhome omain o10 o5 o16 o23 o34 o34 hm hm hm hm hm hm hmnt nt nttv tv tvef efef ef hm hm e context sensitive atg standard forhome figure a motivating example.
ot is an instance of t wheret home hm newtrip nt tripview tv editfolder ef .
in d and e and denote two context sensitive activity transition paths identified by chime.
.
two navigations scenarios figure b shows twoactivity navigations highlightedin redand bluearrows respectively.
for the rednavigation homelaunches newtrip via the icc call at line once the button for newtrip is clicked.
then newtrip launches editfolder once the new folder buttonisclicked tocreateanewtripfolderviatheicccall startactivityforresult atline16 andsubsequently receives an intent object from the target activity as its result.
if save on themenuisclicked editfolder transitsbackto newtripsothat setresult which is invoked at line returns an intent object as the result to the previous newtripinstance that has launched editfolder through the android callback onactivityresult at line .
if home on the menu is clicked instead editfolder transits back to homevia the icc call at line .
for thebluenavigation homelaunches tripview to look up an existing trip at line once the list item existing trip folder is selected.
tripview launches editfolder to edit the name of an existing folder via the icc call at line once edit folder on the menu is clicked.
then editfolder transits back to tripview if save is clicked or returns to homeif home is clicked.
.
context insensitive transition analysis existing static analyses model activity transitions context insensitively.
for our example the contextinsensitive atg obtained is shown in figure c .
for each app a fat harness main is created responsible for allocating one abstract object for each activity class to represent all its instances andcallingallitscallbacks e.g.
oncreate ontheabstractobject.
thus each abstract activity is parameterized with an empty context .asthereareonlyfourcontext insensitiveactivityobjects angbracketleftohm angbracketright angbracketleftont angbracketright angbracketleftotv angbracketrightand angbracketleftoef angbracketright thetwoeditfolder instances that are actually created at run time along two different transition paths are indistinguishable.
in addition regardless of the launch mode specified for home the same atg is always built.
finally atgsareessentiallycallgraphsbutusedformodeling activity transitions.
when constructed context insensitively atgs will potentially exhibit infeasible transition paths.
.
context sensitive transition analysis for our example chime will eventually build the context sensitive atginfigure3 d if homeusessingletask asitslaunchmodeand the one in figure e if homeusesstandard as its launch mode.
initially its slim harness main allocates one instance ohm main o f themainactivity home andalsocallsallthecallbacksregistered .
as before ohm mainis parameterized with in the atg.
our activity aware pointer analysis is then performed on the harnessedapptoresolveitsactivity relatedicccalls.duringthe analysis the pointed to objects of theintent variables at the two icccallsatlines5and10arequeriedinordertofindtheirtargetactivities.oncetheirclasstypes newtrip line4 and tripview line are found chime creates two activity instances angbracketleftont ohm main angbracketright atline5and angbracketleftotv ohm main angbracketrightatline10 andthenaddsthetransition edgesfrom ohm maintoont 5andotv 10asshown.notethat ont 5andotv 10are parameterized with ohm main a context representing currently the onlyactivitytransitionsequencereaching ohmmain.foreditfolder however there are two reaching transition paths resulting in two differentinstances angbracketleftoef ont5 ohm main angbracketrightand angbracketleftoef otv ohm main angbracketright parameterized by two different transition sequences.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yifei zhang yulei sui and jingling xue finally angbracketleftoef ont ohm main angbracketrightatline34launchesa homeactivity.if homeis configured with singletask figure d chime retrieves its existing instance angbracketleftohm main angbracketrightalong the transition path reaching angbracketleftoef ont5 ohm main angbracketright and adds an edge from angbracketleftoef ont5 ohm main angbracketright to angbracketleftohm main angbracketright.
similarly the context sensitive transition from angbracketleftoef otv ohm main angbracketrightto angbracketleftohmmain angbracketrightis added.
if homeis configured withstandard instead figure e two new instances of home will be created angbracketleftohm oef ont5 ohm main angbracketrightand angbracketleftohm oef otv ohm main angbracketright one per each transition path resulting in the following two new edges added angbracketleftoef ont5 ohm main angbracketright angbracketleftohm oef ont5 ohm main angbracketrightand angbracketleftoef otv ohm main angbracketright angbracketleftohm oef otv ohm main angbracketright.
.
object sensitive pointer analysis considertheclass editfolder withoncreate showninfigure4.
at line its intentef is known to point to only one of the two intentobjectspassedfromlines15and22infigure3 a respectively.
class editfolder extends activity protected void oncreate ... ... intent intentef getintent ... figure context sensitive pointer analysis of callbacks with context insensitive and context sensitive atgs.
based on the context insensitive atg in figure c existing context sensitive pointer analyses for android apps will analyze all the callbacks of an activity context insensitively.
as there is only one instance of editfolder angbracketleftoef angbracketright in figure c oncreate will be analyzed only once on the receiver object angbracketleftoef angbracketright.
as a result intentef at line in figure will point to the two intent objects passed from lines and in figure a .
chime builds one of the two context sensitive atgs in figures d and e depending on whether homeis configured with singletask orstandard launch mode.
there are two instances ofeditfolder angbracketleftoef ont5 ohm main angbracketright representing the instance of editfolder startedatline16infigure3 a and angbracketleftoef otv ohm main angbracketright representing the instance of editfolder started at line in figure a .
our activity aware object sensitive pointer analysis is abletoanalyze oncreate separately.with angbracketleftoef ont5 ohm main angbracketrightas itsreceiverobject intentef willpointtotheintentobjectpointed to bynttoefat line in figure a .
with angbracketleftoef otv ohm main angbracketrightas its receiver object intentef will point to the intent object pointed to bytvtoefat line in in figure a .
approach first wereviewbrieflyandroid sintentsanditsiccmechanism section3.
andintroduceournotationsused section3.
.next we discuss how chime preprocesses an app to enable our subsequentanalyses section3.
.then weintroduceouractivity aware object sensitivepointeranalysis section3.
.finally westartwith a context insensitive approach section .
and then move to a context sensitiveone section3.
formodelingactivitytransitions.
.
android intents and icc calls theintentat an icc call e.g.
startactivity intent determinesthetargetactivitytobeopened where intentiseither explicitorimplicit.withanexplicitintent theclassnameofthetargetactivity is explicit e.g.
as in line in figure .
with an implicit intent an action together with some data withwhich to perform the action is provided.
the android framework will find a target class witharegisteredintentfilter initsapp s androidmanifest.xml that has advertised its ability for performing the action.
the android framework provides various apis to store the information regarding a target activity in the fields ofan intent object such as setclassname andsetaction whose parameters are target class name and action name respectively.
for an explicit intent the target class name isstored into the field intent.mcomponent.mclass where the type ofintent.mcomponent iscomponentname and the type of componentname.mclass isstring.
we will use the action field intent.maction toresolveanimplicitintent.therefore thetarget activityofanicccallcanbedeterminedbyqueryingthepointed to values in the fields of an intent object section .
.
.
notations figure5givesournotations.thefirstpartliststhedomainsused.
abstract objects are created at object allocation sites.
to achieve object sensitivity a context is a sequence of abstract objects.
variable intent cpnt a v class type t t abstract object oi ot ot i o context c c o o2 ... launch mode std top task inst lm pt v c p o c fpt o c f p o c newactobj t o heapctxselector o c c mtdctxselector o c c atgg v e atg node angbracketleftoi c angbracketright v o c atg edge angbracketleftoi c angbracketright arrowhookleft p angbracketleftoj c prime angbracketright e v v n figure notations.
the middle part lists several functions used in our inference rules.pt p c gives the points to set of a pointer punder context c. fpt oi c f givesthepoints tosetofthefield fofanobject oiunder contextc.newactobj t creates an instance of an activity class t inmain whilenew t appliestoeveryothertype t .following we use mtdctxselector heapselector to generate a method heap context required for analyzing identifying avirtual method call a non activity object to enable k object sensitive pointer analysis.
note that heapctxselector andmtdctxselector are recursively defined.
for heapctxselector the object oiat allocation site iis modeled context sensitively by a heap context oflength k where ijistheallocationsitefor thereceiverobject oijofthemethodthatcontains ij withi0 i .
formtdctxselector i fxpoints to an object oimodeled under a heap context then the k object sensitive method contextusedforanalyzingavirtualcall x.foo is .
the bottom part defines an atg as a directed multi edge graph for an app.
a node angbracketleftoi c angbracketrightrepresents a context sensitive instance of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
launch mode aware context sensitive activity transition analysis icse may june gothenburg sweden anactivity.anedge angbracketleftoi c angbracketright arrowhookleft p angbracketleftoj c prime angbracketrightfromaparentactivity angbracketleftoi c angbracketright toachildactivity angbracketleftoj c prime angbracketrightrepresentsanactivitytransition where angbracketleftoi c angbracketrightstarts angbracketleftoj c prime angbracketrightviaanicccall say startactivity atlinep.
in figures and the line numbers on their edges are elided.
wewillpresentourformalismforajava likelanguageconsisting offivetypesofstatements objectallocation x new t copy x y load x y.f store x .
f y and virtual call x y.g arg ... arg n .staticvariablesandstaticmethodcallsare excluded but handled context insensitively.
in addition we handle four types of icc related statements specially.
we resolve an explicit intent at intent.mcomponent cpntand an implicit intent at intent.maction action .
for activity related icc calls we consider startactivity intent for starting an activity and setresult intent for receiving a result from an activity .
note that startactivity represents all the apis that can start an activity including e.g.
also startactivityforresult andstartactivityifneeded .by handling startactivity onnewintent is also modeled.
by handling setresult onactivityresult is also modeled.
.
preprocessing during this preprocessing step an app is decompiled to extract its code and metadata such as the launch mode of and intent filters registeredbyeachactivityclassinits androidmanifest.xml file.
to analyze an app we must generate a slim harness main .
for the user defined android components of class types service broadcastreceiver andcontentprovider in an app w ep r o c e e da si n by including in the harness one heap allocation site for each component class for allocating one abstract object from this class and a call to each of its callbacks registered for the object.
these components can start an activity but do not otherwise contribute to activity transitions.
for the user defined android components of class type activity theharnessforanappwillincludethesameinformation pertainingonlytoitsentryactivities i.e.
theonesregisteredvia intent filters or exported to the system.
all the other activities that are started by these entry activities will be added later to the atg of the app context sensitively during the analysis.
.
activity aware object sensitive whole program pointer analysis given an app chime builds a context sensitive atg g v e while performing an object sensitive pointer analysis to the app starting from its harness main .
figure gives our rules.
let contexts m be the set of all the contexts reaching method mfrom main where contexts main .
initially g v e is empty.
letusconsiderthefirstsixrules.wehandleanobjectallocation site dependingon whetherit isfor anactivity classin main orotherwise .intheformercase the activityinstancecreatedisaddedtotheatg.noedgesareavailable at this stage yet.
in each case o iuniquely identifies the abstract object created as an instance of tat allocation site i. in and wehandleallthe other non icc related statements.
in the points to facts flow from rhs to the lhs of a copy statement.
in and thefieldsofanabstractobject oiaredistinguished.inm the containing method for each statement being analyzed i x newt m main ti sas u b t y p eof activity angbracketleftot main angbracketright pt x angbracketleftot main angbracketright v i x newt c contexts m m main ti sas u b t y p eof activity angbracketleftoi heapctxselector oi c angbracketright pt x c x yc contexts m pt y c pt x c x y.fc contexts m angbracketleftoi c prime angbracketright pt y c fpt oi c prime f pt x c x.f yc contexts m angbracketleftoi c prime angbracketright pt x c pt y c fpt oi c prime f x y. ar 1 ... ar n c contexts m angbracketleftoi c prime angbracketright pt y c prime dispatch oi c prime prime mtdctxselector oi c prime c prime prime contexts prime angbracketleftoi c prime angbracketright pt prime this c prime prime lessorequalslantk lessorequalslantn pt ar k c pt prime pk c prime prime pt prime ret c prime prime pt x c intent.mcomponent cpntc contexts m angbracketleftoi c prime angbracketright pt intent c angbracketleftoj c prime prime angbracketright pt cpnt c fpt oj c prime prime mclass fpt oi c prime tgtclassname intent.maction actionc contexts m angbracketleftoi c prime angbracketright pt intent c angbracketleftoj angbracketright pt action c actiontocpnt oj fpt oi c prime tgtclassname p this.startactivity intent c contexts m thisinstanceof activity angbracketleftoi c prime angbracketright pt this c angbracketleftoj c prime prime angbracketright pt intent c angbracketleftok angbracketright fpt oj c prime prime tgtclassname t ettype ok lm etlm t angbracketleftoi c prime angbracketright angbracketleftoj c prime prime angbracketright lm p leadstot this.setresult intent c contexts m thisinstanceof activity angbracketleftok c prime angbracketright pt this c angbracketleftoj c prime prime prime angbracketright pt intent c angbracketleftoi c prime prime angbracketright arrowhookleft angbracketleftok c prime angbracketright e modelsetresult angbracketleft oi c prime prime angbracketright angbracketleftoj c prime prime prime angbracketright figure rules for activity aware object sensitive pointer analysis tgtclassname isapseudofieldforanintentobject .
the function dispatch oi is used to resolve the virtual dispatch of method on the receiver object oito be prime.
we assume that primehas a formal parameter prime thisfor the receiver object and prime p1 ... prime pkfor the remaining parameters and a pseudo variable prime retis used to hold the return value of prime.
finally letusconsiderthelastfourrulesforhandlingicc related statements.
and resolveexplicitandimplicitintents respectively passed via icc calls .
to handle both uniformly a pseudo field of type string tgtclassname for an intent is used.
in we analyze intent.mcomponent cpnt by storing the name of each target activity class in cpnt.mclass directly intointent.tgtclassname .i n we do likewise in analyzing intent.maction action except that actiontocpnt oj gives risetothesetoftargetclasses identifiedagainbytheirnames that have registered an intent filter for performing action oj.
and handle the two icc apis a.startactivity anda.setresult respectively.
for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yifei zhang yulei sui and jingling xue simplicity we assume that a this wherethisis an instance ofactivity .thiscapturesthetwomostlycommonlyusedcases.
theothercasescanbehandledsimilarly involvingasimplesearch for anyparent activitythat maypossibly start achild activityand possibly receive a result from the child activity in the app.
in everycallto this.startactivity intent atlinep induces a fact angbracketleftoi c prime angbracketright angbracketleftoj c prime prime angbracketright lm p leadstot meaning that a parent activity angbracketleftoi c prime angbracketrightstarts an instance of activity class twith its launch modelmat linep with angbracketleftoj c prime prime angbracketrightpassed as the intent object.
here ettype ok maps the name of a class okto its corresponding class type and etlm t obtains the launch mode of an activity class t. in we analyze setresult intent where the intent is given by angbracketleftoj c prime prime prime angbracketright which is invoked on a child activity angbracketleftok c prime angbracketrightin order to find its matching callback onactivityresult ... intentres that is invoked on its parent activity angbracketleftoi c prime prime angbracketright thanks to the atg built on the fly .
now modelsetresult angbracketleftoi c prime prime angbracketright angbracketleftoj c prime prime prime angbracketright simply tells the pointer analysistoanalyze onactivityresult ... intentres invoked on angbracketleftoi c prime prime angbracketright whereintentres points to angbracketleftoj c prime prime prime angbracketright.
.
launch mode unaware context insensitive activity transition analysis figure 7givesthe rule for buildinga context insensitive atg g v e andalsoperformingthepointeranalysisforthe callbacks of every newly started activity at the same time.
angbracketleftoi angbracketright angbracketleftoj c angbracketright p leadstot ot newactobj t angbracketleftoj c angbracketright fpt ot mintent angbracketleftot angbracketright v angbracketleftoi angbracketright arrowhookleft p angbracketleftot angbracketright e modelcallbacks angbracketleft ot angbracketright modelnewintent angbracketleft ot angbracketright angbracketleftoj c angbracketright figure a rule for context insensitive activity transition analysis as assumed in the state of the art .
accordingtothepriorwork onlyone abstractobject angbracketleftot angbracketright withanemptycontext iscreatedforeach activity class t. in addition the launch mode for tis ignored.
given the new activity angbracketleftot angbracketrightstarted modelactivity angbracketleftot angbracketright tellsthepointeranalysistoanalyzethecallbacksof tinvokedon angbracketleftot angbracketright.inaddition fortheintentobject angbracketleftoj c angbracketright whichisnowadded toot.mintent undercontext andcanberetrievedlaterbycalling getintent on angbracketleftot angbracketright modelnewintent serves to inform the pointer analysis to analyze onnewintent with this intent on the receiver angbracketleftot angbracketrightconservatively as this may be reused .
.
launch mode aware context sensitive activity transition analysis figure is an analogue of figure except that our analysis now is launch mode aware and builds a context sensitive atg g v e .
theexecutionofanappismanagedbyoneormoretasks.every task has a back stack which is used to manage activity navigations adding a newly created activity to the stack and backtracking popping off the finished activity off the stack .
a launch mode specifies how a new instance of an activity class is associated with thecurrenttask .developersselectlaunch modestoprovidea smooth and consistent user experience or to achieve design requirements such as the singleton pattern.
in figure two different launch modes singletask andstandard forhomeare illustrated.
withthehelpofacontext sensitiveatg differentlaunchmodes can now be distinguished and effectively handled during the analy sis.theatgkeepstrackofactivitytransitionsforeverytransition path mimicking the back stack of a task.
let us examine the rules for handling four types of of launch modes standard and singletop and singletask and singleinstance .
angbracketleftoi c angbracketright angbracketleftoj c prime angbracketright std p leadstot hc heapctxselector oi c otp newactobj t angbracketleftotp hc angbracketright v angbracketleftoi c angbracketright arrowhookleft p angbracketleftotp hc angbracketright e angbracketleftoj c prime angbracketright fpt otp hc mintent modelcallbacks angbracketleft otp hc angbracketright angbracketleftoi c angbracketright angbracketleftoj c prime angbracketright top p leadstot e t t y p e oi t angbracketleftoi c angbracketright arrowhookleft p angbracketleftoi c angbracketright e modelnewintent angbracketleft oi c angbracketright angbracketleftoj c prime angbracketright angbracketleftoi c angbracketright angbracketleftoj c prime angbracketright top p leadstot e t t y p e oi negationslash t angbracketleftoi c angbracketright angbracketleftoj c prime angbracketright std p leadstot angbracketleftoi c angbracketright angbracketleftoj c prime angbracketright task p leadstot angbracketleftok c prime prime angbracketright arrowhookleft angbracketleftoi c angbracketright ettype ok t angbracketleftoi c angbracketright arrowhookleft p angbracketleftok c prime prime angbracketright e modelnewintent angbracketleft ok c prime prime angbracketright angbracketleftoj c prime angbracketright angbracketleftoi c angbracketright angbracketleftoj c prime angbracketright task p leadstot angbracketleftok c prime prime angbracketright negationslash arrowhookleft angbracketleftoi c angbracketright ettype ok t angbracketleftoi c angbracketright angbracketleftoj c prime angbracketright std p leadstot angbracketleftoi c angbracketright angbracketleftoj c prime angbracketright inst p leadstot angbracketleftoi c angbracketright angbracketleftoj c prime angbracketright task p leadstot figure rules for chime s launch mode aware context sensitive activity transition analysis.
standard.
for the default launch mode we always create a new instance of t identified by angbracketleftotp hc angbracketright wherepis the line number of its corresponding startactivity and then deliver its passed in intent to this new activity object.
while the atg grows modelcallbacks angbracketleftotp hc angbracketright serves again as in to request the callbacks on the new activity angbracketleftotp hc angbracketrightto be analyzed now.
singletop.
if the activity to be started has the same type as the top activity then the top activity is reused with its onnewintent reanalyzed modelnewintent .
otherwise we handle it identically as in the case of standard .
singletask.
this mode is similar to singletop except that the activity instance closest to the top of the back stack will be reused if it has the same type as the new activity to be started .
otherwise we fall back to the case where standard is handled .
here angbracketleftok c prime prime angbracketright arrowhookleft angbracketleftoi c angbracketrightrepresents thestandardgraphreachabilityonadirectedgraphexceptthatit disallowstheexistenceofanyintermediatenode angbracketleftos c prime prime prime angbracketrightsuchthat angbracketleftos c prime prime prime angbracketright arrowhookleft angbracketleftoi c angbracketrightalso holds where ettype ok ettype os .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
launch mode aware context sensitive activity transition analysis icse may june gothenburg sweden singleinstance.
this mode is similar to singletask except that only one instance of its activity class resides in its task.
therefore this mode is handled identically as singletask .
.
discussion inourevaluation wewillcomparechimewithcichime aversion of chime with used for building the atg for an app.
given the same object sensitive pointer analysis applied to a given app chime s atg is strictly non less precise than cichime s atg as the former is context sensitive but the latter is not.
thus the pointer analysis under chime will also be strictly nonless precise than the one under cichime.
with a context sensitive atg chime enables an activity s callbacks to be analyzed contextsensitively.
with a context insensitive atg however cichime allows such callbacks to be analyzed only context insensitively.
.
example letusgothroughsomeofourrulesfortheexampleinfigure3 with homeconfiguredfor singletask andtheothersfor standard to see how chime builds the context sensitive atg in figure d .
initially the atg contains angbracketleftomain hm angbracketright an instance of homeallocated when its harness main is analyzed .
leto4ano9 betheintentobjectsresolvedatlines4and9respectively sothat weobtain newtrip fpt o4 tgtclassname and tripview fpt o9 tgtclassname .
by applying to lines and the two icc call relations angbracketleftomainhm angbracketright angbracketlefto4 angbracketright std leadsto newtrip and angbracketleftomainhm angbracketright angbracketlefto9 angbracketright std leadstotripview are established.byfurtherapplying tothesetworelations where heapctxselector omain hm we obtain two new activity objectsont 5andotv .
in addition two atg edges angbracketleftohm main angbracketright arrowhookleft angbracketleftont ohm main angbracketrightand angbracketleftohmmain angbracketright arrowhookleft angbracketleftotv ohm main angbracketrightare discovered.
similarly we can resolve the icc calls at lines and .
let o15 ano22betheintentobjectsresolvedatlines15and22 respectively so that we obtain editfolder fpt o15 tgtclassname and editfolder fpt o22 tgtclassname .
at line we obtain angbracketleftont ohm main angbracketright angbracketlefto15 angbracketright std leadstoeditfolder .
by applying to this relation where heapctxselector ont ohm main ont ohm main we obtain angbracketleftont ohm main angbracketright arrowhookleft angbracketleftoef ont5 ohm main angbracketright.
at line we obtain angbracketleftotv ohm main angbracketright angbracketlefto22 angbracketright std leadstoeditfolder .
by applying to this relation where heapctxselector otv ohm main otv ohm main we obtain angbracketleftotv ohm main angbracketright arrowhookleft angbracketleftoef otv ohm main angbracketright.
finally we consider the startactivity at line .
let o33be the intent object resolved at line so that home fpt o33 tgtclassname .
two relations will be established at line angbracketleftoef ont5 ohm main angbracketright angbracketlefto33 angbracketright task leadstohome and angbracketleftoef otv ohm main angbracketright angbracketlefto33 angbracketright task leadstohome.a shomeuses singletask launch mode the final atg is shown in figure d .
evaluation the objective of our evaluation is to demonstrate that our contextsensitiveactivitytransitionanalysisismoreprecisethanitscontextinsensitive counterpart in modeling activity transitions guiding gui testing and improving the pointer analysis precision.
.
implementation chimeisbuiltontopofthesparkpointeranalysisframeworkin droidsafe .weleveragetheandroiddeviceimplementation adi provided by droidsafe a comprehensive modeling of the android framework and java library to improve the precision and soundness of our analysis.
droidsafe is used to decompile anapp generateaslimharness main andobtainappmatadata from its manifest file.
to resolve reflection we use ripple but may consider a hybrid analysis in future work.
.
experimental setup and methodology wehaveselected a total of 42androidapps in the top chart free apps from google play downloaded on november .
our k object sensitivepointeranalysisisconfiguredtobe2obj h with two elements for a method context and one for a heap context whichisawidelyusedconfigurationforachievingthebesttradeoff between precision and scalability .
ourexperiments areconductedon axeon e5 .2ghzmachinewith256gbramrunningubuntu16.04lts.theanalysis time of every app is the average of three runs.
chimemodelsactivitytransitionscontext sensitivelyanddistinguishes activity launch modes.
to demonstrate the benefits of our approach wecomparechimewithcichime asimplifiedversionof chime realized with which models activity transitions context insensitively andconsequently incapableofhandlingor distinguishing activity launch modes adequately.
our evaluation answers the following research questions rqs rq1.is chime able to distinguish an activity along different transition paths compared with cichime?
rq2.is chime capable of analyzing launch modes effectively?
rq3.is chime useful for facilitating gui testing?
rq4.is chime able in improving the pointer analysis precision?
.
results and analysis .
.
rq1.
activity transition .table1compareschimeand cichimeintermsoftheatgsconstructedforthe42appsevaluated.
for each app the context sensitive atg from chime is usually largerthanthecontext insensitiveatgfromcichime columns atgnode and atgedge .toseewhychimecandistinguish different activity transition sequences leading to an activity better thancichime werelyonthemaximal average minimalnumber oftheclasstypesofthepredecessoractivitiesofanactivityinan atg columns max avg min typ .
the max avg min typ for chime is always no larger than that for cichime showing that chime can distinguish different activities that would otherwise be merged under cichime.
figure plots the same data measured by thesethreemetrics.finally chimeismorecostlyinmaintaining context sensitivity.theaveragepointeranalysistimespentperapp is .
seconds under cichime but .
seconds under chime.
.
.
rq2.
launch modes .launchmodesforactivitiescan significantly affect how activities are created and their transitions.
we first examine the widespread use of special launch modes singletask singletop andsingleinstance other than just standard inreal worldandroidapps.wethenpresentanddiscuss authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yifei zhang yulei sui and jingling xue table1 comparingchimeandcichimeintermsofatgsconstructed.foreachapp column atgnode atgedge gives thenumberofnodes edges inanatg column max avg mintyp representsthemaximal average minimalnumberofthe class types of the predecessor activities of an activity and column pta time gives the pointer analysis time in seconds.
app idapp namecichime chime app idapp namecichime chime atg nodeatg edgemax typavg typmin typpta timeatg nodeatg edgemax typavg typmin typpta timeatg nodeatg edgemax typavg typmin typpta timeatg nodeatg edgemax typavg typmin typpta time 1instagram .
.
22opal .
2googlelite .
23rollingsky .
3raider .
24starwars .
.
.
4speed .
.
25clashofclan 5flashlight .
.
26tripview .
6booster 27firefox .
.
7seek 28powercleaner .
8anz 29talkingangela 9antivirus .
.
30speedtest .
10solitaire 31talkingtom 11clean .
.
32slots .
12phoneclean .
.
33healthengine .
13pool .
34tiles .
.
14paypal 35hillclimb .
15clashroyale 36hungryjacks .
.
.
16mobilestrike 37machinezone 17cleaner .
.
38deathworm .
18domino .
.
.
39wallet .
.
.
19mail .
.
40legends .
20vlc .
.
.
41catch .
.
21powerclean .
42k9 .
4142max avg min typ app idcichime chime figure comparing cichime andchimegraphically in terms of max avg min typ from table .
for each bar itstop edge represents max typ its bottom edge represents min typ and the dash in the bar represents avg typ .
in the case of a max typ avg typ min typ .
the results of our launch mode analysis.
finally we use a realworld android app to demonstrate the effectiveness of our activity transition analysis in handling special launch modes.
figure present our results on the activity classes analyzed by chime in all the apps with default and special launch modes.
note that for each activity class only one launch mode is counted statically .wecanseethat30 ofallactivityclassesareconfigured with special launch modes.
developers often use special launch modesforsomeactivitiesinreal worldandroidappsinordertoprovide a smooth and consistent user experience.
such special launch modes are also used to achieve certain design requirements such as the singleton pattern.
therefore it is important to develop a launch mode aware analysis to understand activity transitions.
let us examine why chime can but cichime cannot handle four types of activity launch modes the key difference between a speciallaunchmodeandthedefaultmode i.e.
standard isthat the former may cause an existing activity to be resumed but the latter will always cause a new activity to be created.
without context sensitivity cichime represents all instances of anactivityclasswithonesingleabstractobject.asaresult differentlaunchmodescannotbedistinguished.inacontext insensitiveatg constructed its edges are unaware of the launch modes used.
withcontext sensitivity chimecandistinguishdifferentlaunch modesasitcandistinguishdifferentinstancesofanactivityclass under different activity transition sequences.
in a context sensitive atgconstructed itsedgesareessentiallyannotatedwiththelaunch modes used.
to see this let us distinguish two types of edges in anatg stdedgecorrespondingto standard and spledge corresponding to singletask singletop o rsingleinstance.
table2givesourresultsforindividualapps.foreachapp while many activity classes are configured with the default launch mode manyothersusespeciallaunchmodes columns std and spl .
note that these two columns contain the raw data used for plot ting figure .
for each app its atg consists of not only edges markedby stdedge butalsomanyotheredgesmarkedby spledge columns stdedge and spledge .forsomeapps suchas seek an activity class configured with a special launch mode may not haveanyincomingedgeoftype spledge sinceonlyoneinstanceis ever created.
on the other hand for catch activity classes with special launch modes result in edges of type spledge.
for all the apps combined there are and activity classesconfiguredforthedefaultandspeciallaunchmodes respectively figure .
in the atgs constructed there are and edges marked with stdedgeandspledge respectively.
finally let us conduct a case study by considering the code snippet from catchin figure .
the launch mode for mainhome mh issingletask butthelaunchmodesfor searchactivity sa andshoppingcartview sc are irrelevant here.
mhlaunches saat 1andsalaunches sc a t2.
afterwards sclaunches mhagain at3.chimegeneratesalaunch mode awareatgtocapturethe activity transitions by considering singletask formhat3 insection3.
sothattheexisting mhisresumed.thus the activity transitions omh mainosa 9osc 14are precisely captured.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
launch mode aware context sensitive activity transition analysis icse may june gothenburg sweden default standard singletop singletask singleinstance special figure percentage of the analyzed activity classes with the default and special launch modes in the apps.
table classification of atg edges under the default and special modes.
for each app columns std and spl givethenumberofdifferentactivityclassesconfiguredwiththedefault and special launch modes respectively.
for each atg columns stdedge and spledge givethenumberof edges marked by stdedge and spledge respectively.
app idapp namelaunch modeatg edge app id app namelaunch modeatg edge stdsplstdedge spledge stdsplstdedge spledge 1instagram 22opal 2googlelite 23rollingsky 3raider 24starwars 4speed 25clashofclan 5flashlight 26tripview 6booster 27firefox 7seek 28powercleaner 8anz 29talkingangela 9antivirus 30speedtest 10solitaire 31talkingtom 11clean 32slots 12phoneclean 33healthengine 13pool 34tiles 14paypal 35hillclimb 15clashroyale 36hungryjacks 16mobilestrike 37machinezone 17cleaner 38deathworm 18domino 39wallet 19mail 40legends 20vlc 41catch 21powerclean 42k9 launch mode singletask class mainhome extends activity void onnewintent intent sctomh setintent sctomh ... boolean onquerytextsubmit string query intent mhtosa new intent this searchactivity.
class mhtosa.putextra search query query startactivity mhtosa launch mode standard class searchactivity extends activity void onclick view view intent satosc new intent this shoppingcartview.
class startactivity satosc launch mode singletask class shoppingcartview extends activity boolean onoptionsitemselected menuitem menuitem intent sctomh new intent this mainhome.
class startactivity sctomh newactedge newavtedgeprevactedge figure activity transitions tracked by chime in catch.
.
rq3.
gui testing existing static analyses trimdroid brahmastra and a3e rely on context insensitive atgs to guide gui testing.
for thisclient chimeisexpectedtobemoreeffectivethancichimeascontext sensitiveatgsaremorebeneficialthancontext insensitive atgs.
for example brahmastra et al.
instrument an app to track a transition path from one activity to another based on acontext insensitiveatgfortheappinordertofindsecurityvulnerabilitiesatruntime.duetocontext insensitivity theuserhas toworkoutthetransitionpathsbetweenthetwoactivitiestobe tested withpotentiallysomeinfeasibletransitionpathsbeinginstrumentedredundantly causingfalsepositives .thisproblemcan bealleviatedifacontext sensitiveatgisusedfortheapp sincethe transition paths between two activities are available context sensitively with the number of infeasible transitions also being reduced .
to demonstrate that chime can be more effective than cichime in guiding gui testing table compares both in terms of the averagenumberofactivityclasses nac reachinganactivityclass in an atg with each cycle in an atg counted only once .
ina context sensitive atg different nodes may represent different instancesofacommonclass.inthiscase thenacfortheclassistheaverageofthenacsonthetransitionpathsreachingallsuchnodes.foragivenapp thesmallernacis thelesseffortisexpectedtobe spent on gui testing.
in general chime s nac is always no larger than cichime s nac.
for out of the apps evaluated both are indistinguishable.
there are two different reasons behind .
in the case of booster cashroyale cleaner andclashofclan chime and cichime produce the same atg for each app.
in the caseoftheother6apps theatgsbuiltbychimeandcichimefor an app are different but their nacs happen to be the same.
let us take a look at some specific activity classes.
consider posttwitteractivity fromhungryjacks .
for cichime it is representedby oneabstractobjectin theatg for hungryjacks .the numberofactivityclassesreachingitis11.forchime thisabstract object is split into context sensitive instances.
the average number of activity classes reaching these instances remains to be .
consider signinactivity fromopal.for cichime it isalso representedbyoneabstractobjectintheatgfor opal.thenumber of activity classes reaching it is .
for chime this abstract object is now split into context sensitive instances.
the average number of activity classes reaching these instances is .
.
.
rq4.
pointer analysis givenanapp itsatgiscontext sensitiveunderchimebutcontextinsensitiveundercichime.thus chimeismoreprecisethancichime as the the callbacks of an activity are analyzed contextsensitively under chime but context insensitively under cichime.
table4compareschimeandcichimeintermsoftheaverage size of the points to sets of the intent variables accessed in the callstooncreate inalltheactivityclassesinanapp.forchime the size of the points to set of the intent variable accessed in a oncreate call is the average of the sizes of the points to sets underallitscontextsanalyzed.recallhow intentef ineditfolder in figure4isanalyzed section2.
where editfolder maybestarted fromtwo differentcontexts newtripandtripview figure3 a .
as cichime is context insensitive intentef inoncreate will pointtothetwointentobjectspassedbothcontextsindiscriminately.
however chimecandistinguishthetwointentsfor intentef as oncreate is analyzed separately under these two contexts.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden yifei zhang yulei sui and jingling xue table3 comparingchimeandcichimeintermsoftheaveragenumberofactivityclassesreachinganactivityclassin an atg measuring the effort spent in gui testing .
app idapp name cichime chimeapp idapp name cichime chime 1instagram .
.1222opal .
.
2googlelite .
.6723rollingsky .
.
3raider .
.7824starwars .
.
4speed .
.3625clashofclan .
.
5flashlight .
.3526tripview .
.
6booster .
.5027firefox .
.
7seek .
.0028powercleaner .
.
8anz .
.3229talkingangela .
.
9antivirus .
.2330speedtest .
.
10solitaire .
.5031talkingtom .
.
11clean .
.5032slots .
.
12phoneclean .
.5633healthengine .
.
13pool .
.5034tiles .
.
14paypal .
.1235hillclimb .
.
15clashroyale .
.5036hungryjacks .
.
16mobilestrike .
.7337machinezone .
.
17cleaner .
.5738deathworm .
.
18domino .
.9539wallet .
.
19mail .
.2140legends .
.
20vlc .
.7041catch .
.
21powerclean .
.4242k9 .
.
givenanapp theaveragesizeperpoints tosetunderchimeisalwaysnolargerthanthatundercichime.for booster cashroyale cleaner andclashofclan chime and cichime build the same atgineachcase .however chimeismoreprecisethan cichime as chime allows an activity s callbacks to be analyzed context sensitively.for seek pool opal speedtest hillclimb anddeathworm chime and cichime build different atgs but areequallyprecise.letus seewhybyconsidering seek withfouractivityclasses mainactivity authactivity hardupgradeactivity and com.adobe.mobile.ar where starts twiceusingacommonintent starts twiceusinga commonintent and start usingacommonintent.distinguishing calling contexts for each oncreate is not beneficial.
related work pointer analysis.
object sensitivepointeranalysisproposed by milanova et al.
is known to be the best contextsensitive pointer analysis for object oriented programming lan guages .
type sensitivity and hybrid context sensitivity aretwovariantsbasedonobject sensitivity.
the former approximates roughly the objects created at allocationsitesbytheirdynamictypes tradingprecisionforscalability and efficiency.
the latter applies call site sensitivity to static calls andobject sensitivitytovirtualcalls.recently tanetal.improve object sensitivity pointer analysis to achieve better precision by removing redundant context elements and better scalability in building call graphs by targeting type dependent clients .
however existingcontext sensitivepointeranalysesareinsufficient in analyzing the android specific apis such as icc calls which trigger a large number of callbacks interacting with the androidframework e.g.
activityobjectscreatedtherein .incontrast chime is aware of the activity related apis so that activity transitions are modeled context sensitively thereby improving the precision of the underlying object sensitive pointer analysis.table comparing chime and cichime in terms of the average size of the points to sets of the intent variables ac cessed in the calls to oncreate in all activity classes.
app idapp name cichime chimeapp idapp name cichime chime 1instagram .
.
22opal .
.
2googlelite .
.5823rollingsky .
.
3raider .
.8024starwars .
.
4speed .
.0025clashofclan .
.
5flashlight .
.0026tripview .
.
6booster .
.8327firefox .
.
7seek .
.7528powercleaner .
.
8anz .
.8629talkingangela .
.
9antivirus .
.7630speedtest .
.
10solitaire .
.2131talkingtom .
.
11clean .
.1332slots .
.
12phoneclean .
.1033healthengine .
.
13pool .
.0034tiles .
.
14paypal .
.5935hillclimb .
.
15clashroyale .
.6036hungryjacks .
.
16mobilestrike .
.6037machinezone .
.
17cleaner .
.8638deathworm .
.
18domino .
.7839wallet .
.
19mail .
.
40legends .
.
20vlc .
.0841catch .
.
21powerclean .
.1942k9 .
.
static android app analysis.
flowdroid is a popular open sourcestaticinformationflowanalysis whichconstructsa harnessmethodtomodelthebehaviorsoftheandroidcomponentsin an app.
then a context insensitive pointer analysis is performed to construct its call graph and inter procedural control flow graph againstwhichsomeintra componenttaintanalysisisperformed.
iccta representsastatictaintanalysisbuiltontopof flowdroid to detect inter component privacy leaks.
it queries the icc analysis ic3 to instrumentthe target activities startedat icc calls by using a flow and context insensitive pointer analysis.
droidsafe detects information leaks by applying an objectsensitive pointer analysis to resolve the intents associate with icc calls.amandroid isastaticinter componentdata flowanalysis framework for supporting security vetting tasks by using a call site sensitiveandflow sensitivepointeranalysistoconstruct the call graph for an app.
despite the fact that both frameworks use context sensitive pointeranalysis to constructcall graphs all the activities are still modeled context insensitively.
unliketheseearlierapproaches chimedistinguishesdifferent activities launched under different launch modes along different transitionsequencesbyusingcontext sensitiveatgs whichare constructed on the fly during the object sensitive pointer analysis fortheentireapp.suchcontext sensitiveatgscanhelpimprove the efficiency of gui testing tools .
conclusion we present chime a launch mode aware context sensitive activity transition analysis for android apps.
chime models the activitytransitions under different launch modes context sensitively to gether with an object sensitive pointer analysis.
our evaluation showsthatourcontext sensitiveactivitytransitionanalysisismore precise than its context insensitive counterpart in modeling activitytransitions facilitatingguitesting andimprovingthepointer analysis precision for real world android apps.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
launch mode aware context sensitive activity transition analysis icse may june gothenburg sweden