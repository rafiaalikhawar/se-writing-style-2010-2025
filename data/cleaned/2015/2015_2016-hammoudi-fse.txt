waterfall an incremental approach for repairing record replay tests of web applications mouna hammoudi gregg rothermel university of nebraska lincoln usa mouna grother cse.unl.eduandrea stocco universit di genova italy andrea.stocco dibris.unige.it abstract software engineers use record replay tools to capture use case scenarios that can serve as regression tests for web applications.
such tests however can be brittle in the face of code changes.
thus researchers have sought automated approaches for repairing broken record replay tests.
to date such approaches have operated by directly analyzing differences between the releases of web applications.
often however intermediate versions or commits exist between releases and these represent finer grained sequences of changes by which new releases evolve.
in this paper we present wat erfall an incremental test repair approach that applies test repair techniques iteratively across a sequence of fine grained versions of a web application.
the results of an empirical study on seven web applications show that our approach is substantially more effective than a coarse grained approach overall while maintaining an acceptable level of overhead.
ccs concepts software and its engineering software verification and validation keywords test case repair web applications record replay tests .
introduction record replay tools enable software engineers to automate the testing of web applications.
record replay tools capture a set of inputs and actions mouse clicks keyboard entries navigation commands etc.
that are applied to a web application by a software engineer.
during playback these tools re deliver the sequence of captured inputs and actions hereafter referred to as tests to the browser engine.
the number of record replay tools used in both research and commercial realms e.g.
coscripter jalangi sahi selenium sikuli and watir attest to their importance and popularity.
unfortunately tests created by record replay tools can easily stop functioning as applications evolve .
changes as simple as repositioning page elements or altering the selections in a drop downlist can cause such tests to break.
this can greatly limit engineers abilities to perform regression testing.
for this reason researchers have recently begun devising techniques for automatically repairing record replay tests .
while these techniques can be successful at performing repairs as we shall show in real case scenarios they often are not.
record replay tests may break for a variety of reasons but researchers have singled out locators as being particularly problematic .
locators are used by high level languages such as javascript and by record replay tools to identify and manipulate elements on web application guis.
as web applications evolve locators are likely to change and prior instances of locators become obsolete.
this causes tests relying on such locators to break.
while claims about the problem of locator fragility in the papers just cited are primarily anecdotal in a recent study we evaluated test breakages1that occurred in selenium ide tests across versions of eight web applications and used the results to create a taxonomy of the causes of test breakages.2we discovered individual instances of test breakages and found that .
of them were related to obsolete locators within tests.
for this reason in this work we focus on issues related to the repair of locators in record replay tests.
prior work on repairing record replay tests has focused on situations in which a test tfunctions on a release rof web application a but breaks on the subsequent release r ofa.
current techniques for repairing these tests analyze differences between randr in an attempt to select an appropriate repair.
code repositories however routinely make applications accessible in the form offiner grained intermediate increments e.g.
lower level versions or commits so versions of abetweenrandr are often available.
by applying test repair techniques iteratively across these finer grained intermediate versions we may be able to repair tests more effectively than when we apply the same techniques across coarser grained sets of changes.
the additional applications of repair techniques however will entail additional costs and thus both the effectiveness and the efficiency of fine grained approaches must be assessed relative to those of coarse grained approaches.
1we define a test breakage as the event that occurs when a test that used to function on a web application ceases to be applicable to a new release of that application due to changes that cause the test to halt prematurely.
test breakages differ from test failures these occur when tests continue to function on a new release up to a point at which an oracle signals that a program failure has occurred.
in current practice engineers who execute tests on a new release must distinguish test breakages from test failures in this work we focus only on tests that have been determined to have broken.
2while the results presented in motivate the need for automated test repair techniques the paper does not present or investigate any particular techniques.
this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication fse november seattle wa usa c acm.
... 751in this paper we present an approach wat erfall that incrementally repairs tests by considering code changes across finergrained increments of evolving web applications.
while any test repair technique could be plugged in to wat erfall in this paper we make use of the locator repair component of the non incremental capture replay test repair technique wat er presented in .
we empirically study our approach on seven open source web applications for which we had previously created record replay tests using selenium ide on which test breakages related to test locators had previously been discovered .
in our study applying a repair technique at finer granularities increased its effectiveness across all versions of all seven web applications by over coarser granularities.
our results also show that while wat erfall required more execution time than the coarse grained repair approach overall the overhead it imposed was not excessive.
in fact that overhead was more than compensated for by the reduction achieved in the number of times that humans must intervene to manually repair test cases that could not be automatically repaired.
the contributions of this work are as follows a novel algorithm wat erfall for applying test repairs incrementally across fine grained releases of web applications an implementation of our algorithm an empirical study that shows that wat erfall can be effective when applied to several non trivial open source web applications without imposing excessive overhead.
.
background .
record replay tools record replay tools allow test engineers to capture sequences of inputs and actions applied to a web application s gui.
the recording process creates a test script that can then be replayed in an unattended mode.
there are many record replay tools for web applications available in this work we utilize selenium one of the flagship open source test automation tools for web applications.
figure top depicts a typical sample web application allowing users to login.
figure bottom shows the associated html code consisting of a form two input fields for entering a username and password and a submit input field for submitting credentials.
table shows a test created by selenium ide via the application of a sequence of inputs and actions to the login web page.
each input or action causes a selenese command to be inserted into the test.
each selenese command is denoted by a tuple action locator value .
the action component indicates either an event that is performed on the user interface during recording or an action specific to selenium s control of the replay.
the locator component specifies the web element the user is interacting with during a step of the recording process.
the value component refers to any input entered by the user within the element specified by the locator.
.
the water test repair technique while any technique could be plugged in to our test repair approach for this work we chose the wat er web application test repair technique created by choudhary et al.
.
we chose water because it has a procedure geared specifically towards locator repair.
while there exists one other approach for improving locator robustness that approach specifically targets only xpath locators and applying it to the web applications used in our study would require us to convert all other types of locators in our recorded tests to xpath locators rendering our results less generalizable.
at a high level wat er is a differential testing technique used to compare the executions of a test tover two different releases r andr of a web application under test where truns properly on r form method post action index.php input type text class username name usernamefield value username val input type password class password name passwordfield value password val input type submit class submitbutton name submitbtn value submit form username password submitlocalhost web app login.php release r figure sample web application showing a login form top and the corresponding html code bottom table a selenium test for the web application of figure stmt action locator value open localhost web app login.php type name usernamefield jsmith type name passwordfield secret123!
click form input but breaks on r .
wat er executes tonrandr and gathers data about these executions.
wat er then examines the differences betweenrandr and based on these differences and execution data uses heuristics to find a set of potential repairs prfort.
for each potential repair pinpr wat er executes tusingp.
iftruns properly on r pis added to a list of suggested repairs .
this step is repeated until each potential repair in pr has been considered.
the list of suggested repairs is then output to developers for their consideration.
the list of suggestions is ordered according to a set of heuristics such that earlier suggestions have higher probabilities of yielding a correct repair.
choudhary et al.
also explain that if a broken test statement works correctly after a potential repair is applied but the test encounters a breakage again at a later statement wat er is rerun to attempt to repair the new breakage.
space limitations prevent us from providing a more detailed description of the algorithm but details are available in choudhary et al.
s paper .
wat er can suggest locator repairs that are not in fact appropriate.
thus choudhary et al.
state that their technique suggests test repairs to engineers rather than simply applying the repairs and assuming that one is correct if the test runs to completion.
it also seems clear that choudhary et al.
present suggested repairs for tto engineers only after thas run to completion not at an earlier point pintat which a repair has been suggested.
finally wat er is not guaranteed to find a test repair.
in a case study presented in their paper choudhary et al.
show instances in which wat er fails instances in which it suggests inappropriate repairs and instances in which it suggests appropriate repairs.
.
a test repair scenario letrandr be releases of web application a and lettbe a test that runs properly on rbut breaks on r .
acoarse grained approach to repairing tattempts to do so by applying a repair technique to r r t and if successful produces a repaired test tfix.
figure depicts this approach.
in the foregoing scenario let v1 v2 ...vkbe intermediate versions or intermediate commits created as revolved into r .
a fine grained approach to repairing tattempts to execute ton the sequence of intermediate versions or commits between randr .
if a breakage occurs in some intermediate version vk the repair technique is applied to vk vk t .
if successful the approach produces a test that no longer breaks on vk.
the approach then 752tfix release r t release r t figure repairing tusing a coarse grained approach release r release r v1 v2 v3 fix tfix fix tfix tfix t t t figure repairing tusing a fine grained approach iterates through subsequent intermediate versions or commits repairingtwhere necessary until it has produced a repaired version oftthat runs correctly and to completion on r .
figure shows a case in which the fine grained approach is applied where three intermediate releases are available between r andr .
in the figure tpasses on the initial release r. then tis transferred forward to the next version v1 where it passes and is transferred forward to v2.
whentis executed on v2a breakage occurs andtneeds to be corrected.
the repair technique is applied to v1 v2 t and outputs tfix which is transferred forward to the next version v3.
here tfixfails and must be repaired again.
the repair technique is applied to v2 v3 tfix and outputs tfix which is transferred forward to the last version r where it passes.
we believe that the coarse grained approach will be less effective at repairing tests than the fine grained approach.
the number of code changes between randr can be far larger than the number of changes between any pair of successive releases or commits.
the changes between randr may also be intertwined in manners that render repair heuristics less effective.
applying a repair technique iteratively to intermediate versions or commits should leave the technique with fewer less intertwined changes to consider per application increasing its chances of success.
on the other hand a fine grained approach may need to apply repairs many more times than a coarse grained approach increasing its overall cost.
this can occur for example if a specific locator breaks for different reasons across several intermediate versions.
consider figure and suppose that the test breakage in v2is caused by the fact that an attribute locator has been changed from name name to name newername and suppose that the test breakage in v3is caused by the fact that the same locator has been changed again to name newestname .
in this case the coarse grained approach would require only one application to change the locator used in r name name to one that works inr name newestname whereas the fine grained approach would be applied twice i.e.
iteratively on each problematic intermediate version.
in this case the extra cost associated with extra applications of the test repair technique across all versions may exceed the cost of applying the technique once on randr .
an additional cost factor concerns the manual effort within the test repair process itself.
wat er does not always succeed and when it fails engineers need to intervene and find repairs manually.
given that the fine grained approach may require more applications of a test repair technique than the coarse grained approach the finegrained approach may also require more manual repairs.
.
the waterfall approach .
a basic algorithm a fine grained test repair algorithm operates on releases rand r of web application a for which a sequence of intermediate ver sions between randr are available.
given test t the algorithm proceeds until either it reaches release r andtpasses and runs properly on it or tbreaks on some intermediate version vkprior tor .
in this case the algorithm attempts to repair tk the test that reaches vk such that it operates correctly on vk.
this process iterates until occurs or until the algorithm unable to repair a test at some point in the sequence.
algorithm presents wat erfall our fine grained test repair algorithm.
wat erfall accepts releases randr and a test t that ran properly on r. wat erfall initially obtains the list of versions versionlist between randr line including rand r at the beginning and end of the list respectively.
it then iterates through versionlist lines .
for each version vnext considered wat erfall attempts to run possibly previously repaired testton that version.
if tdoes not break wat erfall begins a new iteration on the next version retaining t. iftdoes break waterfall attempts to repair it procedure repairtest line .
ifrepairtest fails to repair t it returns null and wat erfall terminates.
if the repair succeeds wat erfall begins a new iteration on the next version promoting the repaired test tfixed tot.
if wat erfall reaches the end of the sequence of versions r and is able to run ton that version or repair tso that it runs on that version it returns t. algorithm fine grained test repair algorithm function wat erfall r r t tfixed versionlist getversions r r v r fori 0to versionlist.length do vnext versionlist.get i ifruntest vnext t .passes true then v vnext else tfixed repairtest v vnext t iftfixed null then returnnull else t tfixed v vnext end if end if end for returnt end function note thatrepairtest could be instantiated using any test case repair algorithm in this work we instantiate it using our implementation of wat er.
further if wat erfall is unable to repair a test i.e.
returns null line there are additional steps that could be taken.
a test engineer could intervene and repair the test manually and then reapply wat erfall from that point.
alternatively repairtest could be invoked again to retrieve a different suggested repair.
such an approach makes sense when utilizing wat er which actually suggests a list of repairs.
.
example we now illustrate wat erfall using an example.
let the web application in figure be r and suppose that it undergoes a three step evolution process.
figure shows the evolution of the html code for three versions beginning with an intermediate version v1 top then an intermediate version v2 middle and finally a releaser bottom .
specific changes are enclosed in ellipses.
inv1 the values of the class and value attributes have been modified for the username andpassword text fields.
further form method post action index.php div class login input type text class userclass name user value uservalue input type password class passwordclass name passwordfield value passwordvalue input type submit class submitclass name sub value submit val div div class developer info .
.
.
div form form method post action index.php input type text class userclass name user value uservalue input type password class passwordclass name passwordfield value passwordvalue input type submit class submitclass name sub value submit val form form method post action index.php input type text class userclass name usernamefield value uservalue input type password class passwordclass name passwordfield value passwordvalue input type submit class submitclass name submitbtn value submit form version v1 version v2 release r figure an example of web application evolution theclass attribute of the submit button has been modified.
for example in the username text field line the class attribute has been changed from class username toclass userclass and thevalue attribute has been changed from value username val to value uservalue .
despite these changes the test in table still passes on this version because in v1the locators for the username field password field and submit button remain stable.
inv2 the name attribute of the username text field has changed from name usernamefield toname user .
hence statement of the test in table breaks when executed on v2.
in this case wat erfall considers v1andv2and compares line of the html code in v1with line of the html code in v2.
since all of the attribute values are identical except for the name attribute value wat erfall is able to identify the equivalent username input field in v2and repair the locator breakage in line .
inr the developer has modified the page layout by introducing a div line that differentiates the login portion of the web page from the developer info portion.
this causes statement of the test in table to break because the xpath locator no longer reflects the hierarchical path identifying the submit button within the dom tree of the web page under test.
in this case wat erfall compares line of the html code for v2with line of the html code for r .
all the attribute values of the submit button remain unchanged in this case.
thus wat er is able to recognize the equivalent submit button in r .
table displays tas repaired by wat erfall.
the first repair updates the name locator in line from name usernamefield to name user .
the second repair updates the xpath locator in line of the test from form input to form div input .
wat erfallis capable of performing these repairs using a fine grained approach however neither of these breakages can be repaired by wat er using a coarse grained approach.
wat er compares the class name and value attributes of the username andsubmit button input fields.
to repair the breakage in statement of the test in table theusername locator breakage wat er compares line in r figure to line in r figure bottom .
because the values for theclass name andvalue attributes have changed wat er is not able to recognize the username text field in r .
thus wat er is not able to suggest any repairs for the username locator breakage.table the repaired selenium test stmt action locator value open localhost web app login.php type name user jsmith type name passwordfield secret123!
click form div input similarly to repair the breakage encountered in statement of the test in table the submit button locator wat er compares line in rto line in r .
because all the values for the class name andvalue attributes have changed wat er cannot recognize the equivalent submit button in r .
thus wat er is not able to suggest any repairs for the submit button locator breakage.
this example is in fact representative of many of the breakages that we encountered in our empirical study.
the superior performance of wat erfall on this example is due to the smaller number of changes made to the html code across successive versions of the web app.
by applying the repairs to smaller sets of changes wat erfall is able to identify equivalent html input fields across releases.
therefore wat erfall is able to suggest correct repairs more often than a coarse grained approach in which wat er is applied just to randr .
.
improvements to the basic algorithm given r r t wat er outputs a setofsuggested repairs.
each suggestion allows tto run to completion on r but this does not mean that tis operating as designed e.g.
it may now exercise a different use case scenario than the one it was intended to exercise.
thus test engineers may wish to inspect the list of suggestions and select a repair that allows tto run properly.
in our basic algorithm in contrast repairtest is applied iteratively across a sequence of versions.
this raises two issues which if addressed might yield improvements in wat erfall s effectiveness.
to understand these issues again consider the example presented in figure .
suppose that when repairtest is run on v1 v2 t it suggests three repairs s1 s2 ands3.
the fact thats1 s2 ands3are suggested means that each of them yields a test that passes on v2.
our basic algorithm selects the first suggested repair s1 and moves forward to the next version v3 transferringtfixto it.
in our example tfixbreaks on v3.
suppose repairtest is now unable to find a repair for tfixonv3.
in this case our basic algorithm terminates and returns null.
the first issue to consider for this scenario is the manner in which the algorithm treats suggestions.
if the algorithm were to select one of the other suggestions for repairs at v2 s2ors3 then on reachingv3itmight have found a repair there.
a potential improvement to the algorithm would allow it to backtrack to prior lists of suggestions when it cannot repair a test on a subsequent breakage.
in the scenario just presented a backtracking version of the algorithm having failed to find a repair at v3 would return to v2and select a new suggested repair and proceed forward with that.
while theoretically feasible backtracking versions of wat erfall could face scalability problems depending on the sizes of suggestion lists and the number of times that backtracking is called for when processing a sequence of versions.
heuristics might be needed to avoid an exponential explosion in the number of sequences of repairs to consider.
nevertheless with appropriate use of such heuristics a backtracking version of wat erfall might be more effective than our basic version.
the second issue to consider for this scenario is the point at which humans are asked to inspect lists of suggested repairs.
waterfall assumes that humans will be shown suggested repairs only when r is reached when a list of suggested repair sequences is output.
engineers could however become involved each time a 754breakage is located in a version vk and select from the list of repairs suggested at that version the repair they consider appropriate.
this may also improve the algorithm s effectiveness at the cost of additional engineer time.
.
empirical study we consider the following research questions rq1 how do coarse and fine grained test repair approaches compare in terms of effectiveness?
rq2 how do coarse and fine grained test repair approaches compare in terms of efficiency?
in our study the coarse grained approach is represented by water and the fine grained approach is represented by wat erfall.
in this study we utilize our basic algorithm on the view that it makes sense to first determine whether that algorithm has promise prior to implementing more complex algorithms.
we do provide insights into the use of backtracking however in section .
.
.
objects of analysis .
.
web applications as objects of analysis we chose several web applications utilized in our earlier study of test breakages in record replay tests .
the applications selected there were required to i have at least installable and executable versions commits ii have at least lines of code iii have been downloaded at least times and iv have experienced at least commits.
requirement i is crucial to application usability the other requirements lessen threats to external validity by ensuring that the selected applications are non trivial and widely used.
table provides data on the web applications we used including their names the number of releases versions and commits we used the number of lines of code they contained counted using cloc3and averaged across the versions the number of times they had been downloaded and the number of tests used for them.
phpaddressbook helps users manage and organize contacts.
phpagenda lets users manage calendars schedule appointments holidays todo lists and share them with other users.
phpfusion is a content management system that helps users create manage and administer a web site without knowledge about web programming.
joomla is a content management system that helps users with little experience in web programming publish content.
mycollaborationis a collaboration platform that helps users manage customer information and projects.
dolibarr is used for enterprise resource planning and customer relationship management.
yourcontacts is used by companies to manage their contacts.
while all applications use javascript html mysql and css mycollaboration is written in java and the other applications are written in php.
.
.
releases versions and commits for each web application considered we required a way to investigate test repair at both the coarse and fine grained levels.
the ways in which we were able to do this varied however across the applications because some provide case commits between versions while others provide case only various levels of versions.
in both of these cases there are scenarios in which coarse and fine grained test repair are viable.
in case coarse grained repair could be applied across pairs of successive versions whereas finegrained repair could be applied across pairs of intervening commits provided these commits result in executable instances of the web applications.
in case coarse grained repair could be applied 3cloc.sourceforge.nettable objects of analysis idweb app name releases versions loc downloads tests commits a1phpa ddress book a2phpa genda a3phpf usion a4joomla a5mycollaboration a6dolibarr a7yourcontacts across pairs of successive higher level releases while fine grained repair could be applied across pairs of intervening versions.
such an approach could make sense in practice if regression testing is restricted to higher level releases as might happen if the time available for testing lower level releases were constrained.
to provide a uniform way to describe the two cases we refer to the coarsergranularity versions as releases and we refer to the finer granularity versions whether commits or intermediate versions as versions or on occasions where clarity requires intermediate versions .
yourcontacts anddolibarr were available at the levels of releases and commits.
for yourcontacts we were able to utilize releases with commits between each pair.
for dolibarr we were able to utilize eight releases.
in this case however there were an enormous number of commits between each pair of releases many of which involved no code changes so we selected every 75th commit between each pair.
for the other five web applications phpaddressbook phpagenda phpfusion joomla and mycollaboration commits were not available but on each there were three levels of versions major minor patch this allowed us to choose several versions as releases with several finer grained versions as intermediate versions between them.
this choice is motivated by empirical evidence that a larger percentage of breakages occur at intermediate release levels than at higher levels.
for each of these web applications we chose as releases all major e.g .
or .
or minor e.g .
.
.
.
releases.
as intermediate versions we selected the patch versions between successive major or minor releases yielding sequences such as .
.
.
.
.
.
or .
.
.
.
.
.
.
.
respectively.
we disregarded cases in which only zero or one patch versions were available.
in either of the foregoing cases we obtain for each web application several of what we refer to as sequences of versions which begin with a release end with a subsequent release and contain two or more intermediate versions between these releases.
for example we obtain sequences of versions of the form r v1 ... vn vn r whererandr are releases and v1 ... vnare intermediate versions or commits .
table lists the number of releases and the number of intermediate versions or commits that we ultimately retained for each web application considered.
.
.
record replay test suites the record replay tests used in this study were initially created in the context of our earlier work .
we created these tests because no appropriate tests were available for the web applications utilized.5to create these tests we followed a systematic iterative procedure for each web application creating tests that achieved coverage of use cases and exceptional behaviors.
such use case based approaches to testing systems at the interface level are common in practice and well suited to the use of record replay tools.
4for a list of the actual releases versions and commits that we considered and pointers to the source code repositories for each object of study see 5joomla does include webdriver tests but no ide tests and only for its first version.
755given a test suite tcreated for a version vkthe first author followed a three step process a process that wat erfall needs to replicate with some differences in this current study as described in section .
.
in step she executed ton the next version of the web application vk and noted each case in which a test broke.
in step she manually repaired each of the tests that were repairable an iterative process because repairing one test breakage might allow that test to proceed further and break again later.
in step she added new tests covering new functionality to the test suite.
this resulted in a new test suite t that now functioned onvk .
she then repeated these three steps for each subsequent version of the web application until each had been tested and the causes of all test breakages had been noted.
the numbers of tests listed in table are the numbers available on the final version of each web application considered.
.
variables and measures .
.
independent variables our independent variable is the test repair approach used coarsegrained i.e.
wat er or fine grained i.e.
wat erfall .
.
.
dependent variables our goal is to assess the effectiveness and efficiency of the test repair approaches.
effectiveness.
to measure the effectiveness of the coarse grained repair approach we first count ctot the total number of repairs required when applying the approach to r r t this number equals the total number of locator breakages of tonr .
we then countcrep the total number of locator breakages of tthat wat er is able to correctly repair.
to compare the overall effectiveness of the coarse and finegrained repair approaches it is not appropriate to count breakages encountered by the fine grained approach at intermediate versions because such breakages may cancel each other out .
section provided an example of this in which an attribute locator is first changed in some version from name name to name newername and then changed in a subsequent version to name newestname .
in this case the fine grained repair approach encounters each of these changes separately and must repair tfor each of them independently.
as far as the coarse grained repair approach is concerned however the only visible breakage involves the fact that name used in r is changed to newestname inr and only one repair is needed to address the resultant breakage.
it is this repair and others that the coarse grained repair approach encounters that matters for the sake of overall comparisons of the techniques.
thus to compare the overall effectiveness of the coarse and fine grained test repair approaches we consider how well the finegrained approach does at repairing just those breakages that the coarse grained approach needs to repair at r .
more precisely we letftot the total number of breakages that need to ultimately be repaired by wat erfall inr be equal to ctot.
then we countfrep the total number of breakages out of ftotthat waterfall was ultimately able to correctly repair i.e.
breakages no longer present in r following the application of the algorithm.
the methods just described require a mechanism for determining whether wat er is able to correctly repair a breakage.
to perform this determination each time wat er produced a test t that executes without breaking on r we manually inspected t to ascertain whether it achieved the original goal for t and pronounced it correct only if it did.
when applying wat erfall each time it produced a test t that executes on all versions in a sequence without breaking we performed an analogous inspection.efficiency.
we utilize two measures of efficiency.
first we measure the efficiency of the approaches in terms of execution time .
since our algorithms and instrumentation code are implemented in java we used a java subroutine java.lang.system.currenttimemillis which returns the current time in milliseconds.
we invoked this subroutine before and after calls to the coarse and fine grained repair procedures this allowed us to avoid measuring other computational load such as cpu contention and memory saturation .
in this way we were able to derive the current time before and after the calls and compute run times by subtracting the second from the first.
note that there is a complicating factor in this process involving unrepaired intermediate breakages encountered when applying the fine grained repair approach that we must account for when measuring its execution time.
we discuss this in section .
.
a second efficiency metric as noted in section .
relates to the additional costs for checking repairs and finding and applying repairs in cases where automated repair techniques fail.
without conducting an empirical study of humans we cannot assess this cost in terms of time.
however studies involving humans are expensive.
before incurring that expense it makes sense to assess whether our approach has prospects for success using a dependent variable that serves as a proxy for the time spent by humans.
as such a proxy we measure the number of manual repairs required by each approach.
to do this for the coarse grained repair approach we simply count the number of unrepaired breakages that remain in r this is given byctot crep.
to do this for the fine grained repair approach there are two sets of breakages to count breakages that remain inr and breakages that occur in intermediate versions that cannot be repaired by wat erfall and must be repaired by engineers before the process can continue.
the former is given by ftot frep and the latter is given by fintdone fintneeded where fintdone is the sum of repairs made by wat erfall at each intermediate version between randr andfintneeded is the sum of repairs needed at each intermediate version between randr .
.
study operation for each web application a we considered each pair of successive releases ri rj ofaand performed the following activities.
first for each test tapplicable to rj we applied wat er to ri rj t which resulted in a list sof suggested repairs for t. note that the list of locator breakages in rjis already known having been determined in our earlier study and the size of that list isctot.
each time wat er selected a locator repair from s the first author inspected it and determined for each of the known locator breakages in rj whether the repair applied by wat er was correct.
the number of correct locator repairs selected from sand applied by wat er is equal to crep.
second for each test tapplicable to rj we applied wat erfall to the sequence of intermediate versions beginning with ri and ending at rj.
this process was more complex for two reasons i when the fine grained approach is applied to a sequence of versions wat erfall can encounter at some intermediate version a locator breakage that it is unable to repair and ii our tests do contain some breakages due to causes not involving locators that our current implementation of wat erfall cannot repair.
in practice in either of these cases an engineer would need to intervene address the cause of the breakage and repair the test manually.
in our study we simulate that practice.
we say simulate because we already know where all the breakages are and what repairs are needed to correct them given the data from our prior study and we make use of that knowledge to apply known repairs.
our simulation is similar to the three step process by which we evolved test suites for our web applications.
to describe the process 02004006008001000efficiency time seconds a1 cg timea1 fg timea2 cg timea2 fg timea3 cg timea3 fg timea4 cg timea4 fg timea5 cg timea5 fg timea6 cg timea6 fg timea7 cg timea7 fg time 050100150200efficiency manual repairs of repairs a1 cg man a1 fg man a2 cg man a2 fg man a3 cg man a3 fg man a4 cg man a4 fg man a5 cg man a5 fg man a6 cg man a6 fg man a7 cg man a7 fg man 050100150200effectiveness repairs of repairs a1 cg a1 fg a2 cg a2 fg a3 cg a3 fg a4 cg a4 fg a5 cg a5 fg a6 cg a6 fg a7 cg a7 fg figure effectiveness efficiency and manual repair results all applications all sequences of versions.
we refer to the scenario in figure .
we initialize ftotandfrepto zero.
suppose the breakage encountered on v2is a locator breakage wat erfall can repair and the breakage encountered in v3 is a breakage locator or other wat erfall cannot repair.
we first apply wat erfall to v1 v2 t wat erfall succeeds creating repaired test tfix and we increment both ftotandfrep by one.
we next apply wat erfall to v2 v3 tfix and waterfall is unable to repair the breakage.
whether the breakage involves a locator or not we manually apply the repair utilized in our first study creating repaired test tfix and increment ftot but notfrep by one.
next we apply wat erfall to v3 r t fix andt fixpasses in r and performs its intended behavior.
thus t has been successfully repaired by wat erfall for the sequence of versions r r .
in this example v3is the last intermediate version in the sequence r r so we do not need any further repairs.
if there were additional intermediate versions between v3andr we would apply wat erfall iteratively to each subsequent version that triggers a test breakage adjusting ftotandfrepappropriately until no additional test breakages in subsequent versions arise.
if multiple breakages arise when running ton an intermediate version the foregoing process becomes more complicated but continues to function.
we apply wat erfall to each locator breakage intand note the locator breakages in tthat it can and cannot repair incrementing ftotandfrepaccordingly.
we then manually correct any remaining unrepaired breakages.
in section .
when discussing our approach for measuring the run time of the fine grained approach we mentioned that there was a complicating factor in that process.
that complicating factor arises in cases such as those just described where a breakage is encountered that wat erfall cannot repair.
in these cases we keep track of the execution time spent by wat erfall on the sub sequence of versions up to the problematic breakage and then also measure execution times on following sub sequences.
the run time of the fine grained approach is given by the sum of the elapsed times across all sub sequences.
.
threats to validity external validity threats concern the generalization of our findings.
we considered only seven web applications and our results may not generalize to others.
the selection criteria that we had adopted in choosing these however did ensure that they were of non trivial size and had multiple versions and had experienced many downloads and commits.
as a second threat our results are gathered relative to tests repaired using wat er and wat erfall and generalization to other repair approaches is not possible.
internal validity threats concern uncontrolled factors that may have affected our results.
the first author created the tests.
thistask however requires reasoning that cannot be automated so it is difficult to envision less threat prone approaches.
moreover to reduce the subjectivity involved she followed a systematic and structured procedure.
finally all of these tasks were performed during our prior study and prior to our having envisioned the approach and the study presented in this paper.
this reduces potential sources of bias that could have occurred if the tasks had been performed specifically with this study in mind.
construct validity threats concern our metrics and measures.
we measure the numbers of breakages found and repaired but differences in these numbers across the two approaches do not necessarily correlate with differences in the amount of effort needed to manually repair breakages that remain.
similarly we measure the cost of the approaches in terms of the machine time required to run techniques and the number of manual repairs required but this may not directly correlate with the time that may be spent by engineers repairing breakages that are not automatically repaired.
we return to this latter point however in section where we are able to offer some additional insights.
.
results and analysis figure presents the data from our study graphically in the form of boxplots.
from left to right the three graphs present results for effectiveness efficiency in terms of technique execution time in seconds and efficiency in terms of numbers of manual repairs required respectively.
in each graph results are shown for each of the seven web applications as a pair of boxplots.
each pair of boxplots represents the datasets gathered for the coarse and fine grained approaches respectively across all of the sequences of versions considered for the given web application.
for space considerations web applications are identified by their ids as presented in table .
thus for example the first two boxes in the leftmost figure represent the distributions of the effectiveness values for web application a1 phpaddressbook for the coarse grained first box and fine grained second box test repair techniques across the nine sequences of versions available for that application.
the boxplots show that for every web application the finegrained repair approach is more effective than the coarse grained approach the fine grained approach requires more time than the coarse grained approach and the fine grained approach requires fewer manual repairs than the coarse grained approach.
.
.
rq1 effectiveness table presents effectiveness results for each web application for each sequence of versions or commits utilized.
in the column headers cg is an acronym for coarse grained and fg is an acronym for fine grained .
column lists the web applica757table effectiveness and efficiency results across all sequences of versions for all webapplications webapplications effectiveness efficiency cg fg total fg fg diff and repairs repairs repairs diff and int.
repairs int.
repairs cg fg overhead cg fg diff and name versions releases done done needed increase done needed time s time s man man decrease crep frep ctot ftot fintdone fintneeded cmfm phpaddressbookr1 r2 .
r2 r3 .
r3 r4 .
r4 r5 .
r5 r6 .
r6 r7 .
r7 r8 .
r8 r9 .
r9 r10 .
total for phpaddressbook .
phpagendar1 r2 .
r2 r3 .
r3 r4 .
r4 r5 .
r5 r6 .
total for phpagenda .
phpfusionr1 r2 .
r2 r3 .
r3 r4 .
r4 r5 .
r5 r6 .
total for phpfusion .
joomlar1 r2 .
r2 r3 .
r3 r4 .
r4 r5 .
r5 r6 .
r6 r7 .
r7 r8 .
total for joomla .
mycollaborationr1 r2 .
r2 r3 .
r3 r4 .
r4 r5 .
r5 r6 .
total for mycollaboration .
dolibarrr1 r2 .
r2 r3 .
r3 r4 .
r4 r5 .
r5 r6 .
r6 r7 .
r7 r8 .
total for dolibarr .
yourcontactsr1 r2 .
r2 r3 .
r3 r4 .
r4 r5 .
r5 r6 .
r6 r7 .
r7 r8 .
r8 r9 .
r9 r10 .
r10 r11 .
r11 r12 .
total for yourcontacts .
total across all web apps .
tions considered.
column lists the pairs of releases that serve as start end points for sequences of versions.
column lists the numbers of intermediate versions that occur within these sequences of versions.
columns and report the numbers of coarse grained and fine grained repairs performed respectively on each sequence of versions by wat er and wat erfall.
column reports thenumber of total repairs needed for each sequence of versions.
column reports the differences between the number of fine grained repairs performed and the number of coarse grained repairs performed along with the percentage increase in repairs performed.
column reports the number of repairs made by wat erfall for all sequences of intermediate versions lying between releases r 758andr .
column reports the number of repairs needed for all sequences of intermediate versions lying between releases randr .
we defer discussion of the other columns to sections .
.
and .
rows shaded in gray provide totals across all sequences of versions per individual web application and bottom all web applications.
across all web applications considering overall totals the finegrained repair approach was able to repair out of .
locator breakages while the coarse grained approach was able to repair only of .
locator breakages wat erfall was thus more effective than wat er overall.
improvements on individual web applications were all relatively large ranging from on yourcontacts to on dolibarr .
the results show the improved effectiveness of the fine grained repair approach applied across all of the sequences considered.
for example consider yourcontacts the application in which the widest variation in the numbers of coarse grained repairs across sequences of versions occurred.
here the overall improvement of fine grained repair over coarse grained repair was .
the lowest level of improvement occurred on the sequence of versions r11 r12 and the highest level occurred on the sequence of versions r5 r6 .
aside from these outliers however all other improvement percentages fell within a smaller range of to .
to assess whether the observed differences in effectiveness were statistically significant we applied mann whitney tests to the data on a per program basis testing the null hypothesis that the two approaches did not differ in effectiveness at a confidence level of .
in all cases the differences were statistically significant we omit the data due to space limitations .
.
.
rq2 efficiency columns and in table indicate for each web application how many seconds the coarse and fine grained approaches spent applying repair techniques.
column calculates the difference in time between the two approaches and the percentage overhead in time required by the coarse grained approach with respect to the fine grained approach.
the fine grained repair approach wat erfall required more time than the coarse grained approach wat er on all applications and sequences of versions.
differences ranged across sequences of versions from to seconds on phpaddressbook from to seconds on phpagenda from to seconds on phpfusion from to seconds on joomla from to seconds on mycollaboration from to seconds on dolibarr and from to seconds onyourcontacts .
on individual sequences of versions the smallest time difference was seconds .
minutes on sequence r4 r5ofmycollaboration and the largest was seconds .
minutes on sequence r8 r9ofphpaddressbook .
we applied mann whitney tests to the data on a per program basis testing the null hypothesis that the two approaches did not differ in efficiency at a confidence level of .
in all cases the differences were statistically significant we omit the data due to space limitations .
we now consider the second component of efficiency the number of test repairs that the coarse and fine grained approaches require engineers to accomplish manually.
we denote these two costs bycmandfm respectively.
they are displayed for each sequence of versions in columns and of the table.
column reports the differences between fmandcm along with the percentage increase in repairs required by cm.
as the data shows the fine grained repair approach required far fewer manual repairs overall than the coarse grained approach.
across all sequences of versions the differences range from seven onphpaddressbook sequence r8 r9 the coarse grained ap proach required manual repairs while the fine grained approach required only to on yourcontacts sequence r5 r6 the coarse grained approach required manual repairs while the fine grained approach required only .
we again applied mann whitney tests to the data on numbers of test repairs on a per program basis again in all cases the differences were statistically significant.
.
discussion .
cost effectiveness comparisons of the execution times of the coarse and fine grained approaches favor the former but considering these in conjunction with our other results suggests a different picture.
our own experience repairing tests which we were required to do for all tests of the web applications we considered attests to the costliness of the task.
for example for phpaddressbook the first author spent approximately hours manually repairing the breakages that occurred in the application s tests across its versions this amounts to an average cost of over minutes per breakages.
in one extreme case over two hours were required to repair a breakage.
keeping this in mind consider the efficiency and effectiveness results obtained on the sequence of versions r8 r9ofphpaddressbook .
here the difference in the number of manual repairs that must be performed by engineers using the two approaches is at its lowest with coarse grained repair manual repairs must still be performed by engineers whereas with fine grained repair must be performed two on r and on intermediate versions .
in this case coarse grained repair requires seconds and fine grained repair requires seconds just over minutes more.
thus the coarse grained approach is more cost effective than the fine grained approach only if manual repairs of the seven additional unrepaired breakages can be accomplished in less than minutes an average of seconds per breakage in our example .
given our experiences with manual breakage repair it seems unlikely that this would be the case in practice.
next consider the sequence of versions r5 r6onyourcontacts .
here the difference in the number of repairs that must be performed by engineers using the two approaches is at its highest with coarse grained repair repairs must be performed by engineers whereas with fine grained repair must be performed on r and on intermediate versions .
in this case coarse grained repair requires seconds and finegrained repair requires seconds almost seven minutes more.
in this case the coarse grained approach is more cost effective than the fine grained approach only if manual repair of the additional unrepaired breakages can be accomplished in less than seven minutes an average of .
seconds per breakage in our example .
this seems entirely impossible.
based on our own experiences manually repairing test breakages it also seems possible that it may be easier to repair breakages in intermediate versions than in the final release of a sequence.
this is because in intermediate versions web applications have undergone fewer smaller changes with respect to prior versions rendering breakages easier to analyze and repairs easier to conduct.
on the other hand there might be some startup costs associated with repairs that can be amortized when considering multiple breakages at once rendering human effort in the coarse grained approach less expensive.
empirical studies that measure human costs associated with repairs will be needed to investigate these scenarios.
.
repairing versions versus commits the first five web applications listed in our tables were considered at the level of releases and intermediate versions whereas the last two dolibarr andyourcontacts were considered at the level of releases and commits.
where intermediate repairs completed and needed are concerned dolibarr andyourcontacts have higher numbers than most of the other applications however these numbers are similar to those obtained on phpfusion .
investigating this further we found that this high number of manual repairs was needed on these applications because they contained a substantially higher number of non locator breakages than the other four web applications.
thus the differences in numbers of manual repairs was not due to the use of commits.
.
the potential for backtracking to obtain some initial insights into the use of an enhanced version of wat erfall incorporating backtracking section .
we simulated the use of such an algorithm by considering the sequence of versions for which wat erfall was the least effective at performing repairs r2 r3ofyourcontacts .
in this case the finegrained repair approach failed to repair of breakages.
the first author simulated the backtracking version of wat erfall by considering the subset of tests that wat erfall was not able to repair for sequence of versions r2 r3ofyourcontacts .yourcontacts has tests of which wat erfall repaired initially leaving unrepaired.
the simulation involved capturing all of the sequences of suggested repairs made by wat erfall for any breakage and then backtracking from r torand running the test with these suggested sequences of repairs.
we simulated the ongoing applications of wat erfall to all sequences of suggested repairs considering all possible combinations as the backtracking approach might do if applied exhaustively.
the process was halted whenever a test was repaired across one of these sequences.
a test was considered to be repaired if it was found to run properly through the last version of the sequence.
we repeated this process for all unrepaired tests in the sequence of versions.
using this simulated backtracking approach we were able to find repairs for of the breakages that were not addressed by our basic algorithm.
while this simulation does not take into account efficiency keep in mind that it did reduce the number of breakages that would need manual attention by .
of the repairs with respect to the basic algorithm and thus is worth a certain amount of overhead.
assessing whether the cost effectiveness tradeoff of a backtracking algorithm would be worthwhile in practice however requires further study.
.
related work there has been some research on automated repair of programs e.g.
.
our work focuses on tests.
there have been numerous papers on test repair.
several papers have addressed the problem of repairing unit tests such as junit tests or tests written in similar frameworks e.g.
.
many researchers have attempted to repair gui tests which track sequences of user actions applied to an interface.
memon and soffa memon and datchayani et al.
use event flow graphs and transformation techniques to repair broken gui tests.
huang et al.
use a genetic algorithm to repair gui tests.
grechanik et al.
analyze an initial and modified gui for differences and generate a report for engineers documenting ways in which test scripts may be broken by changes.
daniel et al.
use gui refactorings to track the changes engineers make to a gui suggesting that this information could be used to repair tests.
such approaches however do not address directly web tests produced by record replay tools although they might be adapted to do so.
zhang et al.
address the problem of repairing broken workflows in gui applications where a workflow is a sequence of activities to perform a given task.
this approach however does not attempt to repair actual tests.
alshawan and harman present an approach for repairing user session data that can be collected and used to regression test web applications.
user session data however differs from the data captured by record replay tools because it includes only requests received by a server from the web application.
other research attempts to simplify the debugging of faults in web applications.
hammoudi et al.
use delta debugging to reduce recordings that expose failures to smaller versions.
wang et al.
use dynamic slicing to discard events from an execution trace that are not required for failure reproduction.
these approaches might be used to facilitate test repair by reducing tests to a subset of actions that still result in breakages.
recent papers consider problems related to the robustness and maintainability of web test suites.
stocco et al.
investigate the automated generation of page objects that confine causes of test breakages to a single class a form of breakage prevention.
yandrapally et al.
address the problem of test script fragility in relation to locators proposing approaches for robustly identifying ui elements by using contextual clues which is also a form of prevention.
another approach for producing robust locators has been implemented in the tools robula and robula .
bajaj et al.
present led a tool that automatically synthesizes web element locators by solving a constraint satisfaction problem over the group of valid dom states in a web application.
to our knowledge there have been only two papers that have presented techniques for repairing locator breakages in web tests.
we have already discussed the technique proposed by choudhary et al.
.
in addition the multi locator extension of robula supports automated repair of broken locators by identifying and attempting to apply other potential locators generated by different tools at the breakage site.
waterfall in contrast is based on differential testing.
.
conclusions and future work we have presented wat erfall a fine grained approach for repairing record replay tests of web applications.
we have conducted an empirical study comparing our approach to a coarsegrained approach on seven non trivial open source web applications.
our results show that wat erfall is far more effective than the coarse grained approach at automatically repairing tests.
moreover while wat erfall requires more execution time than the coarse grained approach the extra overhead is overshadowed by the reduction in manual test repairs it requires.
as future work we intend to extend our implementation of waterfall to handle other classes of breakages that are not necessarily confined to locators e.g.
repairing assertions with the goal of repeating the study both at coarse and fine grained levels.
we also intend to develop the backtracking version of wat erfall in order to compare it with the multi locator repair approach suggested by leotta et al.
.
finally since our approach has demonstrated promise we intend to conduct an empirical study of humans to assess its cost effectiveness in practice.
.