the impact of continuous integration on other software development practices a large scale empirical study yangyang zhao nanjing university china njuzhyy gmail.comalexander serebrenik eindhoven u of technology the netherlands a.serebrenik tue.nlyuming zhou nanjing university china zhouyuming nju.edu.cnvladimir filkov uc davis usa filkov cs.ucdavis.edubogdan vasilescu carnegie mellon university usa vasilescu cmu.edu abstract continuous integration ci has become a disruptive innovation in software development with proper tool support and adoption positive effects have been demonstrated for pullrequest throughput and scaling up of project sizes.
as any otherinnovation adopting ci implies adapting existing practices inorder to take full advantage of its potential and best practices to that end have been proposed.
here we study the adaptationand evolution of code writing and submission issue and pullrequest closing and testing practices as t ra vis ciis adopted by hundreds of established projects on github.
to help essentialize the quantitative results we also survey a sample of github developers about their experiences with adopting tra vis ci.
our findings suggest a more nuanced picture of how githubteams are adapting to and benefiting from continuous integrationtechnology than suggested by prior work.
i. i ntroduction the d evopsmovement made popular in recent years is a paradigm shift .
it aims to get changes into production as quickly as possible without compromising software quality.while no standard definitions exist the term is often over loaded here we refer to d evopsas a culture that emphasizes automation of the processes of building testing and deployingsoftware.
in practice d evopsis supported by a multitude of tools for configuration management cloud based contin uous integration and automated deployment which enjoywidespread open source and industrial adoption .
in this study we focus on continuous integration ci the key enabler of d evops.
ci is a well known concept in extreme programming promulgated in martin fowler s 2000blog post .
as a practice ci is seeing broad adoptionwith the increasing popularity of the g ithubpull based development model and the plethora of open source github compatible cloud based ci tools such as t ra vis ci c loud bees and c ircle ci.
in a decentralized social coding context such as g ithub ci is particularly relevant.
by automatically building and testing a project s code base inisolation with each incoming code change i.e.
push commit pull request ci has the potential to i speed up development code change throughput ii help maintain these authors contributed equally to this workcode quality .
clearly ci promises to be a disruptivetechnology in distributed software development.
for it to be effective ci must allow for a seamless back and forth between development testing e.g.
unit integration code review and deployment.
however the road to efficiencyis riddled with choices and trade offs.
for example workingin large increments may lead to more meaningful changesets but it may also complicate synchronization between teammembers and if necessary reverting changes.
conversely more frequent changes facilitate merging but they also requiremore computing infrastructure for ci since by default thecode is built and all tests are executed with every change.
moreover while ci runs on smaller more frequent changeswould provide earlier feedback on potential problems theymay also lead to process noise where developers startto ignore the ci build status due to information overload irrespective of whether the build is clean or broken .
several ci best practices have been proposed e.g.
by fowler in his influential blog post such as everyone commits to the mainline every day fix broken builds immediately and keep the build fast.
however despite the large scale adoption of ci we know relatively little aboutthe state of the practice in using this technology and whetherdevelopers are aligning their practices with fowler s proposed best practices .
such knowledge can help developers tooptimize their practices project maintainers to make informeddecisions about adopting ci and researchers and tool buildersto identify areas in need of attention.
in this paper we report on a study of a large sample of g ithubopen source projects that adopted t ra vis ci by far the most popular ci infrastructure used on g ithub .
in particular we focus on the transition to using t ravis ci and investigate how development practices changed following thisshift.
to this end we introduce regression discontinuity design analyses to quantitatively evaluate the effect of an intervention in our case adoption of t ra vis ci on the transition toward expected behaviors in the above three practices measuredfrom trace data in a large sample of g ithubprojects appropriately selected .
qualitatively to help essentialize thequantitative results we survey a sample of g ithubdevelopers .
c ieeease urbana champaign il usa technical research60 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
about their experiences with adopting t ra vis ci.
applying this mixed methodology we find that the increasing number of merge commits aligns with the commit often guideline of fowler but is likely to befurther encouraged by the shift to a more distributedworkflow with multiple branches and pull requests the commit small guideline however is followed onlyto some extent with large differences between projectsin terms of adherence to this guideline the expected increasing trend in the number of closed pullrequests manifests itself after the introduction of t ra vis ci and even then only after the initial plateau period the pull request latency increases despite the codechanges becoming smaller while the number of issues closed increases this trend isunexpectedly slowed down by t ra vis ci after initial adjustments when adopting t ra vis ci test suite sizes seem to increase.
ii.
d evelopment of research questions transitioning to an integrated ci platform like t ra vis involves adaptation of established processes to the new environ ment.
during this transition some developers will experiencea more streamlined process evolution trajectory than others.studying those trajectories can provide lessons learned.
continuous integration encourages developers to break down their work into small chunks of a few hours each assmaller and more frequent commits helps them keep trackof their progress and reduces the debugging effort .miller has observed that on average microsoft developerscommitted once a day while off shore developers committedless frequently due to network latencies stolberg expectseveryone to commit every day and y uksel reports commits per day after introduction of ci .
on a relatednote the interviewees in the study of leppanen et al.
saw higher release frequency as an advantage and reportedthat the ci radically decreased time to market .
hence weask in rq are developers committing code more frequently?
frequent commits can be expected to be smaller in size indeed the quote from fowler s blog post refers to smallchunks .
hence we formulate rq are developers reducing the size of code changes in each commit post ciadoption?
do they continue to do so over time?
in the g ithub common pull based development model wherein project outsiders and sometimes insiders too sub mit changes in the form of pull requests prs evaluationthroughput is key.
indeed popular g ithubprojects receive increasingly many prs all of which need to be tested andreviewed pre merge.
one of the most commonly advocatedbenefits of t ra vis ci is the ability to scale up development by automating pr testing and delegating the workload tocloud based infrastructure in this sense vasilescu et al.
report that g ithubteams are able to process i.e.
close more prs per unit time after adopting t ra vis ci.
this high level of automation should also impact the speed not just the volume of pr evaluations.
hence we ask in rq are pull requests closed more quickly post ci adoption?
for ci and d evopsin general to have the stated benefits effective coordination between all project contributors isimportant a common mechanism for this are issue reports.similarly to the pull requests the number of closed issuesper time period may change after ci adoption in response toincreased project activity or efficiency.
hence we ask in rq are more issues being closed after adopting ci?
finally ci is closely related to the presence of automated tests .
duvall even claims that ci without such tests shouldnot be considered ci at all while cannizzo et al.
deem an extensive suite of unit and acceptance tests to be an essentialfirst step .
moreover ci is frequently introduced togetherwith test automation .
however developing tests suitedfor automation requires a change in developers mindset andpresence of a comprehensive set of tests incurs additionalmaintenance costs .
naturally more automated testing willexpose more errors and ci makes it possible to track andreact to different error types differently .
therefore weformulate rq how does the usage of automated testing change over time after ci adoption?
iii.
m ethods we collected and statistically analyzed data from a large sample of open source projects on g ithub that adopted tra vis ci at some point during their history.
we further surveyed a sample of those projects t ra vis ci adopters.
a. data gathering data collection involved mining multiple sources ght orrent the g ithubapi project version control git logs and the t ra vis ci api.
the goal was to select nontrivial projects that adopted t ra vis ci and had sufficient activity both before and after adoption in order to observepotential transition effects.
note that for the purpose of thisstudy we don t distinguish between project and repository the term project has also been used to refer to a collectionof interrelated repositories in the literature .
candidate projects we started by identifying g ithub projects that use t ra vis .
to our knowledge no such list exists t ra vis torrent is restricted to java and ruby projects so we wrote a script to iterate over non fork ght orrent projects oldest to newest and poke the t ra vis ci api cf.
to determine if the project used t ra vis we ran and stopped the script after identifying approximately half of all g ithubprojects that ever used t ra vis ci.
next we cloned the g ithubrepositories of all these projects locally and extracted their main branch commit his tories using p ercev al an open source repository mining tool part of the g rimoire labtool suite.
then we traversed each project s commit history to determine when maintainersintroduced t ra vis ci by identifying the earliest commit 1at the time of writing t ra vis self reports being used in over open source g ithubprojects see authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
timetravis ci adoption first .travis.yml commit days days ... ... days days days daysunstable period excluded fig.
.
overview of our time series assembly method.
to the .travis.yml configuration file and recorded its authored timestamp as the timestamp of the t ra vis adoption.
time series we proceeded to aggregate data about the different practices considered in day windows on each side around the t ra vis ci adoption event figure .
during initial exploration we saw several occasions of tra vis being adopted as part of a larger restructuring effort which lasted several days.
examples include changingthe build system from ant to gradle and consequently reorganizing project folders updated library dependencies and restructured tests.
based on this anecdotal evidence weconcluded that the activity immediately prior to and imme diately following the introduction of t ra vis ci might not be representative of the project s overall trends.
therefore tolimit the risk of bias due to extraordinary project activity inthe transition period we excluded one month of data centeredaround the adoption event in our quantitative analyses below.
measures we collected global and time window measures total number of commits in a project s history as a proxy for project size activity.
total number of commit authors as a proxy for the size of a project s community commit authors include bothcore developers who are also committers and externalcontributors without write access whose commits aremerged in by the core developers.
since it is commonfor open source developers to contribute under differentaliases name email tuples e.g.
as a result of using different machines and changes in git settings over time we first performed identity merging.
we used heuristics that match first and last names email prefixes and emaildomains cf.
prior work and found an averageof .
max aliases per person in our dataset.
project age at the time of adopting t ra vis ci in months computed since the earliest recorded commit.
main programming language automatically computedby g ithubbased on the contents of each repository and extensions of file names therein.
number of non merge commits number of merge commits per time window.
since git is a distributed version control system developers can work locally inincrements before pushing their changes to g ithubor opening a pull request.
e.g.
a developer can choose topartition a large change into many smaller ones andmake multiple local commits to better manage the work.this would have no effect on ci runs since ci is onlytriggered by g ithubpush events and events happening after and including when a pull request is opened.consequently to study commits to the mainline every day fowler s best practice as opposed to potentially local git commits we distinguish between non merge commits and merge commits as a proxy.
we recognize non merge commits as those having at most one parent and merge commits otherwise.
mean commit churn per time window.
churn is the total number of lines added plus the total number of linesremoved per commit in git modified lines appear as firstremoved then added extracted from git logs.
the meanis computed over all commits in that time window.
number of issues opened closed number of pull requests opened closed per time window extracted using the g ithubapi.
mean pull request latency per time window in hours computed as the difference between the timestamp whenthe pr was closed and that when it was opened.
themean is computed over all prs in that time window.
number of tests executed per build.
each t ra vis build runs at least one job corresponding to a particularbuild test environment e.g.
jdk version .
once the jobstarts a log is generated recording the detailed infor mation of the build lifecycle including installation stepsand output produced by the build managers.
on a sampleof java projects that used maven ant or gradle astheir build systems for which we could make reasonableassumptions about the structure of their build log files weparsed the t ra vis build logs and extracted information about the number of tests executed we take the maximumnumber of tests across jobs as the test count for a build and the reasons causing builds to break similar to .
filtering as a large fraction of projects on g ithubare small and not highly active we filtered out projects inconsistentlyactive during our month observation period to avoid bias ing our conclusions due to an inflation of zero values in ourdata.
depending on the research question this means eitherrequiring at least one merge and one non merge commit on themain branch closed pull request closed issue in each of the time windows of observation.
furthermore our multivariateregression analysis below requires enough variance along eachof the dimensions being modeled thus we additionally filterout programming languages not represented by many projectseach.
the resulting dataset spans seven popular programminglanguages c java ruby php javascript c and python.table i contains an overview.
b. time series analysis method we use data visualization and statistical modeling to discover longitudinal patterns indicative of ci adoption effects.
as one of our contributions we introduce the statisticalmodeling framework of regression discontinuity design to assess the existence and extent of a longitudinal effect associated with the t ra vis ci adoption.
to evaluate the effect of a treatment e.g.
a new drug on a disease progression randomized experimental trials are authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i projects per language for different filters .
active periods with language commits pull reqs issues all c java ruby 5php 14javascript 18c 13python total usually conducted the experimental cohort is randomly split into a treatment group i.e.
those given the treatment and a control group i.e.
those not given the treatment then the effect is evaluated based on the difference in disease progres sion between the two groups.
in the absence of randomizedtrials as is often the case with software engineering trace data weaker techniques such as quasi experiments are employed.
among quasi experimental designs to evaluate longitudinal effects of an intervention regression discontinuity designs rdds are the most powerful.
rdd is used to modelthe extent of a discontinuity of a function between its valuesat points just before after an intervention.
it is based onthe assumption that in the absence of the intervention thetrend of the function would be continuous in the same wayas prior to the intervention.
therefore one can statisticallyassess how much an intervention in our case the t ra vis adoption changed an outcome of interest immediately andover time and if implemented using multiple regression alsoevaluate whether the change could be attributed to other factorsthan the intervention.
figure illustrates a discontinuity therdd approach in a nutshell aims to uncover the differentregression lines before and after the discontinuity.
there are different formalizations of rdd most prominently sharp rdd and fuzzy rdd .
to model the effectof ci adoption on developer practices here we chose one im plementation of the simpler sharp rdd approach segmented regression analysis of interrupted time series data .
we summarize our approach next following the description bywagner et al.
and refer to figure .
let ybe the outcome variable in which we are looking for a discontinuity e.g.
commit churn per month.
we can specify the following linearregression model to estimate the level and trend in ybefore ci adoption and the changes in level and trend after ci adoption y i time i intervention i time after intervention i i where time indicates time in months at time ifrom the start of the observation period intervention is an indicator for time i occurring before intervention or after intervention ci adoption which was at month based on our encodingin figure and time after intervention counts the number of months at time iafter the intervention coded before ci adoption and time after ci adoption.
this model encapsulates two separate regressions.
for points before the treatment the resulting regression line has aslope of and after the treatment .
the size of the effect fig.
.
rdd the treatment effect is negative and there is an interaction effect which changes the slope of the regression after the treatment.
of the treatment is the difference between the two regression values of yiat the intervention time and is equal to .
our goal is to capture using the rdd model above changes in trends after ci adoption across our sample of projects whilecontrolling for confounding variables e.g.
project size age and programming language .
our data is centered at the timeof ci adoption and has an equal number of points oneach side.
since the data is inherently nested each projectcontributes multiple observations similarly for programminglanguage we implement the rdd model as a mixed effectslinear regression functions lmer andlmer.test in r with a random effects term for project and another random effects term for programming language this way we can capture project to project and language to language variability in theresponse.
all other variables were modeled as fixed effects.
solving the regression gives us the coefficients which if significant can help us reason about the treatment and itseffects if any.
we report on the models having significantcoefficients in the regressions p .
as well as their effect sizes obtained from anov a analyses.
model fit was evalu ated using a marginal r m and a conditional r2 c coefficient of determination for generalized mixed effects models r mdescribes the proportion of variance explained by the fixed effects alone r2 cdescribes the proportion of variance explained by the fixed and random effects together.
to improverobustness the top of the data was filtered out as outliers.finally we check for multicolinearity using vif below .
c. survey to obtain additional insights into the adoption of t ra vis ci we conducted a survey with a sample of the maintainers responsible for introducing t ra vis .
we randomly selected projects from our dataset stratified by how much of a discontinuity in commit activity we detected at t ra vis adoption time.
for each project we identified the developerresponsible for introducing t ra vis i.e.
committing the first version of .travis.yml and removed duplicates same developer in different projects .
in the invitation email deliveryof messages failed we received responses or .
response rate we explicitly stated the name of the project.
weasked three questions what made developers decide to startusing ci and t ra vis ci whether they had to change anything in their development process to accommodate ci t ra vis and how did their development process change with time if at all to use ci t ra vis ci efficiently.
no question was mandatory.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
month index w.r.t.
travis ci adoptionnum.
non merge commits month index w.r.t.
travis ci adoptionnum.
merge commits fig.
.
commit frequency before and after the t ra vis ci adoption.
iv.
r esults and discussion we discuss changes in development practices after ci adoption along four dimensions commit frequency code churn pull requests resolution efficiency issue tracking and testing.
a. rq trends in commit frequency the first practice we examine is commit frequency.
as we investigate the commits to the mainline every day practice it is important to distinguish non merge from merge commits.indeed local git commits in a developer s offline repository happen in isolation and can be seen as simply a mechanism topartition the work.
however what matters for t ra vis ci are pushes and pull requests to the blessed g ithubrepository i.e.
the main repository of the project as only then t ra vis would be triggered.
push events are not readily accessiblein our data hence we analyze merge commits on the maindevelopment branch as a proxy for work that would havebeen subjected to ci by t ra vis .
since not all our projects have recorded merge commits in all24 periods we restrict this analysis to only projects that had at least one mergecommit in each time window.
exploratory study figure shows the boxplots of per project number of non merge commits top and number of mergecommits bottom respectively for each of twelve consecutive30 day time intervals before and after the t ra vis ci adoption.
note the log scale.
recall that due to instability we omitthe day time interval centered around t when the earliest commit to the t ra vis configuration file which signals adoption was recorded figure .
the horizontal line in eachboxplot is the median value across all projects.
first we observe relative stability in the number of nonmerge commits prior to the t ra vis ci adoption figure top with the across projects medians around commits anda slight decreasing trend after the adoption with the across projects median dropping to commits in period .
second after an initial dip in periods to the merge commits figure bottom appear to display a slight increasing trendprior to the t ra vis ci adoption with the across projects median reaching commits immediately prior to the adoptionperiod followed by apparent stabilization after that.
we alsotable ii commit frequency model .the response is log number of merge commits per month .r2 m .
.r2 c .
.
coeffs errors sum sq.
intercept .
.
log totalcommits .
.
.
log numnonmergecommits .
.
.
ageattravis .
.
.
log numauthors .
.
.
time .
.
.
interventiontrue .
.
.
time after intervention .
.
.
p .
p .
p .
observe a discontinuity at t the across projects median is commits right after the adoption period.
note in bothplots the large variance in the data.
statistical modeling study we fitted a mixed effects rdd model as described before to model trends in the number of merge commits per project over time as a function of t ra vis ci adoption and while controlling for confounds most notably we control for the number of non merge commits as these may have not all been subjected to ci since they appearto display a decreasing trend with time.
we modeled a random intercept for programming language to allow for language to language variability in the response i.e.
code in some languages being naturally more verbosethan in others resulting in different ways to split the workacross commits or community level norms for committing we also modeled a random intervention slope and intercept forproject to allow for project to project variability in the response and the possibility that on average projects withlower initial activity may be less strongly affected by adopting t ra vis ci than high frequency projects.
recall also that the coefficient for time is the slope before adoption the coefficient forintervention is the size of the effect of ci introduction the coefficient for time after intervention is the divergence in the slopes before and after t ra vis ci adoption and the sum of the coefficients for time andtime after intervention is the slope of the linear trend after t ra vis ci adoption.
table ii summarizes the results.
in addition to the model coefficients and corresponding standard errors the table showsthe sum of squares a measure of variance explained for eachvariable.
the statistical significance is indicated by stars.
thefixed effects part of the model fits the data well r m .
.
there is also a considerable amount of variability explainedby the random effects i.e.
project to project and languageto language differences not explicitly modeled by our fixedeffects r c .
.
among the fixed effects we observe that thenumber of non merge commits our main control explains most of the variability in the response.
the coefficient ispositive i.e.
the direction of the correlation is expected other things constant the more non merge commits there are themore merge commits there will be as well.
neither project size total number of commits over the entire history nor project ageat adoption time have any statistically significant effects.
next we turn to our t ra vis related variables.
the model confirms a statistically significant positive baseline trend inthe response with time with a small effect as suggested by authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
month index w.r.t.
travis ci adoptionmean non merge churn loc month index w.r.t.
travis ci adoptionmean merge churn loc fig.
.
mean code churn per commit per project before and after t ra vis .
our exploratory study.
the model does not detect any discontinuity at adoption time since the coefficient for intervention is not statistically significant.
post adoption there is a decreasein the slope of the time trend but the overall trend remainsascending the sum of the coefficients for time andtime after intervention is positive more merge commits as time passes.
discussion the exploratory study suggests a slight decreasingtrend in the number of non merge commits with time.
sepa rately modeling the trend in number of non merge commits not shown using a similar approach as above confirmed thisoverall decreasing trend.
this is consistent with the commonobservation that as projects move past the initial developmenthurdle and age development generally slows down and thefocus shifts to bug fixing rather than adding new features noted e.g.
by brindescu et al.
.
in contrast the statistical modeling study above revealed a consistent increase in merge commits with time including post ci adoption albeit with a slowdown.
this overall trendaligns with the expected increase in commit frequency afterswitching to ci as expressed and encouraged by fowler.given the overall decreasing trend with time in the numberof non merge commits the increase in merge commits isnoteworthy.
one explanation is that projects are switching tomore distributed development workflows using branches andpull requests.
indeed in our survey r38 has indicated thattheir project shifted towards pull request merge develop ment strategy as it made the distributed development moremanageable.
the development process change reported byr38 is not exceptional.
indeed the idea of a shift towards morefocused development in separated branches has been voicedby r32 shorter lived and generally single contributor branches and r49 feature branches r6 and r47.
b. rq trends in code churn next we examine code churn.
as before we distinguish between merge and non merge commits.table iii commit churn model .
t he response is log mean non merge commit churn .r2 m .
.r2 c .
.
coeffs errors sum sq.
intercept .
.
log totalcommits .
.
.
ageattravis .
.
.
log numauthors .
.
.
time .
.
.
interventiontrue .
.
.
time after intervention .
.
.
p .
p .
p .
table iv commit churn model .
t he response is log mean merge commit churn .r2 m .
.r2 c .
.
coeffs errors sum sq.
intercept .
.
log totalcommits .
.
.
ageattravis .
.
.
log numauthors .
.
.
time .
.
.
interventiontrue .
.
.
time after intervention .
.
.
p .
p .
p .
exploratory study figure shows boxplots of per project percommit mean code churn medians behave similarly for eachof twelve consecutive day time intervals before and after the t ra vis ci adoption.
the horizontal line in each boxplot is the median value over all projects.
in the non merge commits the medians are quite stable across the entire interval from before to after the t ra vis ci adoption dancing around lines of code churn per commiton average with large variance.
in comparison in the merge commits we observe more than usual variance in the twomonths preceding the adoption as well as a slight downwardtrend in the medians following adoption which drop to about263 lines of code churn per commit on average in the lastperiod compared to about right after adoption period1 .
the variance around the medians is still large in all periods.
in conclusion non merge commits seem mostly unaffected by time passing and the t ra vis ci adoption while merge commits seem to be getting smaller with time.
statistical modeling study guided by our exploratory observations above we proceed to quantify the trends we observedusing two mixed effects rdd models for non merge andmerge commits respectively as described before.
table iii summarizes the rdd model for non merge commits.
first we observe that only the combined fixed and random effects model fits the data well r c .48compared tor2 m .
i.e.
most of the explained variability in the data is attributed to project to project and language to language variability rather than any of the fixed effects.
next we turn to the fixed effects.
from among the controls we note that overall bigger projects totalcommits tend tochurn more other things held constant and projects with alarger contributor base numauthors which typically indicatemany occasional contributors also tend to churn less.
noneof the t ra vis related predictors have statistically significant effects i.e.
the churn trend in non merge commits is stationary over time and remains unaffected by the t ra vis ci adoption.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv summarizes the rdd model for merge commits.
similarly as with the previous model of churn in non merge commits most of the explained variability in the data isattributed to project to project and language to language vari ability rather than any of the fixed effects variables.
thecontrols also behave similarly as before older projects tendto churn less perhaps as they have reached maturity and amore stationary stage in their evolution projects with a largercontributor base also tend to churn less which is in line withthe expectation that occasional contributors to open sourceprojects are generally less active than core developers smallpull request contributions would be reflected here.
after controlling for confounds we move on to the main time series predictors all of which now have statistically sig nificant effects.
the coefficient for time is negative suggesting a small decreasing baseline trend in commit churn before ciadoption the intervention coefficient signals a discontinuity in the time series at the time of the t ra vis ci adoption the negative coefficient time after intervention signals an acceleration in the baseline trend.
together this confirms a changein merge commit churn at the time of adoption followed byan accelerated decreasing trend after adoption.
discussion our modeling study revealed a statistically significant discontinuity in the merge commit churn time series whenadopting t ra vis ci and a statistically significant decreasing linear trend with time in merge commit churn after adopting tra vis ci.
however churn in non merge commits remains unaffected by either time or switching to t ra vis ci.
the discontinuity is not unexpected as one can reasonably expect more maintenance work in preparation for transitioningto t ra vis ci and some adjustment cleanup period right after.
the relative instability in code churn on both sides near theci adoption time is also indication of this as are the surveyresults.
indeed when asked about the introduction of t ra vis ci respondents frequently refer to test automation being introduced around the same time as t ra vis as contributors couldn t be trusted to run test suite on their own r25 .furthermore respondents indicate that t ra vis has been introduced as a part of automated package release effort r38 and to deploy artifacts to s3 on each commit as part of ourdeployment process using amazon codedeploy r34 .
the decreasing trend in code churn post t ra vis is visible only among merge commits which are more likely to beaffected by switching to a fast paced ci workflow than non merge commits which may live on local isolated developerbranches for some time before being merged to the remote.this finding is consistent with fowler s recommended goodpractices of ci of committing smaller changes to the code.the expected decrease in the size of the commits is alsoechoed by one of the survey respondents commits becamesmaller and more frequent to check the build pull requestsbecame easier to check r4 .
however the decreasing trendwe observed is not particularly steep.
survey responses providea possible explanation several developers referred to pullrequest integration as the reason for introducing t ra vis ci month index w.r.t.
travis ci adoptionnum closed prs fig.
.
closed pull requests before and after the t ra vis ci adoption.
table v pull request model .the response is log number of pull requests closed per month .r2 m .
.r2 c .
.
coeffs errors sum sq.
intercept .
.
log totalcommits .
.
.
ageattravis .
.
.
log numauthors .
.
.
time .
.
.
interventiontrue .
.
.
time after intervention .
.
.
p .
p .
p .
and while r31 and r50 state that t ra vis ci is used both for commits and for pull requests r11 r21 and r37 explicitly state that in their projects push commits are outside the scopeof t ra vis ci.
in other words if in a project not all commits are subjected to t ra vis ci then there may be less incentive to follow fowler s recommendations related to commit churn.
at the same time a different respondent indicated that tra vis ci discourages him her from making trivial commits r11 suggesting instead that the commits he she makes arelikely to be larger therefore our global decreasing trendmay be weakened by local trends in the opposite direction.our model found evidence for strong project specific effects project to project and language to language differences ascaptured by our random effects contribute substantially toexplaining the overall data variability.
this suggests that anyphenomena giving rise to pressures to increase or reduce codechurn are perhaps subordinate in magnitude to other morepressing phenomena of local i.e.
project specific character.
alternatively the decreasing trend in commit churn is also consistent with the observation that as projects age bug fixingcommits which on average are smaller become more commonthan new feature commits which on average are larger .
our results suggest that while fowler s good practice of small commits is followed to some extent the project to project and language to language differences are more impor tant and might overshadow the overall trend.
c. rq trends in pull request closing next we consider pull request closing which we analyze along two dimensions the number of pull requests closed and the average pull request latency i.e.
time to close per timewindow.
since t ra vis ci runs every time a pull request is submitted the developers are rapidly notified whether theirpull requests pass the t ra vis quality gate and can then rapidly react by correcting the pull request source code.
hence authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
month index w.r.t.
travis ci adoptionmean pr latency fig.
.
mean pull request latency before and after the t ra vis ci adoption.
table vi pull request latency model .the response is log mean pull request latency per month in hours .r2 m .
.r2 c .
.
coeffs errors sum sq.
intercept .
.
log totalcommits .
.
.
ageattravis .
.
.
log numauthors .
.
.
time .
.
.
interventiontrue .
.
.
time after intervention .
.
.
p .
p .
p .
we expect that t ra vis ci shortens the pull request latency and increases the number of closed pull requests.
exploratory study figure shows boxplots of per project number of closed pull requests.
we observe that the mediannumber of closed pull requests per months fluctuates between11 and before t ra vis introduction and between and after.
we note an apparent increasing trend pre t ra vis which also seems to continue post t ra vis .
both pre t ra vis and post t ra vis we see large variance around the medians.
figure provides a complementary perspective on the efficiency of pull request resolution namely the pull requestlatency.
the median latency seems to increase prior to intro duction of t ra vis ci and continues to do so afterwards.
statistical modeling study we apply rdd as above.
thestatistical models for the number of pull requests closed andthe mean pull request latency are summarized in tables v andvi.
as above the combined fixed and random effects modelsfit the data much better than the basic fixed effect models indicating that the project to project and language to languagevariability are responsible for most of the variability explained.
regarding closed pull requests table v we note an increasing time baseline trend pre adoption no statistically significant discontinuity at the adoption time and an apparentneutralization of the aforementioned time trend post adoption as time time after intervention .
turning to the pull request latency model table vi we note a statisticallysignificant increasing baseline time trend unaffected by the t ra vis ci adoption as neither coefficient for discontinuity and change in trend has statistically significant effects.
discussion the statistical modeling study generated two noteworthy findings.
first despite a visually apparent increasingtrend in the number of pull requests closed per time pe riod across the entire interval under observation our modelsuggests that after controlling for project size project age and size of developer community as well as local project to month index w.r.t.
travis ci adoptionnum closed issues fig.
.
number of closed issues before and after the t ra vis ci adoption.
table vii issues model .the response is log number of issues closed per month .r2 m .
.r2 c .
.
coeffs errors sum sq.
intercept .
.
log totalcommits .
.
.
ageattravis .
.
.
log numauthors .
.
.
time .
.
.
interventiontrue .
.
.
time after intervention .
.
.
p .
p .
p .
project and language to language differences the increasing trend manifests itself in aggregate only pre t ra vis .
moreover surprisingly we find that the initial trend is flattened posttra vis resulting in relatively stationary behavior on average.
this paints a more nuanced picture of how g ithubteams are adapting to and benefiting from continuous integrationtechnology than suggested by prior work and speaks tothe strength of time series based analysis methods such as therdd we use here at detecting fine resolution effects.
second our model finds that on average pull requests are taking longer to close over time and this trend is unaffected bythe switch to t ra vis ci.
this again is quite surprising as we have seen in rq 2above that the size of code changes becomes on average smaller over time in turn this would imply thatchanges are also easier quicker to evaluate.
one possibleexplanation for the increased latency is the t ra vis slowness reported by some survey participants r1 r27 r53 .
d. rq trends in issue closing next we examine issue closing trends.
exploratory study we follow the same approach as above and compare the medians in the number of issues per time period in the months before and after ci adoption.
fig.
shows theboxplots of the number of issues per unit time period for 12consecutive day time intervals before and after t ra vis ci adoption.
we note that the month immediately preceding andthe two following the adoption exhibit the highest number ofissues.
besides those before ci adoption the median numberof issues per period seems to vary between and withmost of them being in between.
following ci adoption wenote a slight increasing trend in the median of the number ofissues closed with the median between and .
statistical modeling study we apply rdd as above.
the statistical model for the number of issues closed is summarizedin table vii.
as above the combined fixed and random effectsmodels fit the data much better than the basic fixed effect authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time since ci adoption daysmedian no.
tests fig.
.
unit tests per build following ci adoption.
models indicating that the project to project and languageto language variability are responsible for most of the vari ability explained.
we note an increasing time baseline trend pre adoption no statistically significant discontinuity at theadoption time and a slight positive trend post adoption as time time after intervention .
discussion the statistical modeling study confirmed the visu ally apparent increasing trend in the number of issues closedper time period across the entire interval under observation although the trend slows down following t ra vis ci adoption and is smaller than expected from the visual study indicatingthe moderating influence of the control variables.
thus ourmodel finds that on average more issues are being closedover time but this trend slows with the switch to t ra vis ci.
survey participants experience t ra vis as beneficial for bug detection i think we produce less bugs r45 there was animmediately noticeable improvement in terms of the numberof serious bugs in production r51 .
an interesting insightinto this matter is provided by r16 while several surveyrespondents have indicated that t ra vis ci is not consistent in terms of performance and relatively slow those performanceaspects provided r16 with means to detect more flaky issues which where only visible on t ra vis .
e. rq trends in testing the last development practice we examine is testing.
here we only consider a sample of java projects for which we couldconfidently identify their build system and consequently parsetheir t ra vis log files.
the sample consists of projects each with at least builds of builds executing tests.
exploratory study as before we first look for general trends.
fig.
shows a boxplot of per project median number of testsper build for each of five consecutive day time intervalsbefore ci adoption.
we aggregated the data here in dayintervals to make it easier to visualize the trend since thedifferences are small.
the horizontal line in each boxplot isthe median value of all per project medians and the black dotis their average value.
we observe a monotonically increasingtrend in both the medians from to tests per build and the means from to i.e.
to increase.
to ascertain if the complexity of builds increases over time we also calculated the average number of jobs per build.
themedian is 1for all five time intervals.
these two findings suggest strongly that there is an increase in the number ofunit tests per build over time.
this coupled with our findingthat builds are not getting more complex over time indicatesthat developers are likely spending more time on automatedtesting since ci adoption.
this is consistent with fowler s good practices proposal.
error types study we also looked at the evolution of the error types in builds over time after ci adoption.
for all250 projects above we looked at the builds that resulted inerrors and deconvolved the errors into types after opencoding.
we did this over intervals days days and days i.e.
corresponding to the first third andfifth interval in figure .
we find an apparent upward trendover time in most error type categories most notably compileerrors execution errors failed tests and skipped test medianremained .
all these are consistent with an increase in theamount of code being built and tested per build as well as anincreasing management of errors by skipping tests likely toaid in debugging.
on the other hand we find a decreasing trendamong errors related to missing files dependencies and time outs both consistent with those errors being less of an issueover time as developers are acculturating to the ci mediatedprocesses.
thus overall we find an expected adjustment to theautomated testing and error handling with an indication thatdebugging complexity grows over time.
improving software quality through test automation has been repeatedly mentioned by the survey respondents as areason to switch to t ra vis ci.
by using t ra vis ci they became more aware of testing related aspects of their devel opment process r32 r52 spent more time and effort ondesigning testing strategies r5 r53 and encourage otherprojects to embrace t ra vis r26 .
the efficiency of t ra vis ci for long running tests is however a concern r10 .
v. r elated work impact of ci has attracted quite some attention from the research community.
the earlier studies interpretci as distributed development and obligation to integrate one s own contributions .
under this definition no commit size reduction has been observed in ohloh projects .
more recently the ease of use of the t ra vis ci system led to its popularity on g ithub and triggered a series of research studies .
this line ofresearch is closer to the current work as it performs empiricalanalysis of t ra vis ci data.
moreover similarly to vasilescu et al.
and hilton et al.
our work can be seen as related to adoption of t ra vis ci and similarly to beller et al.
we study build failures.
closest in spirit to ours is probablythe work of vasilescu et al.
who report using different methodology increases in a project team s ability to integrateoutside contributions following adoption of t ra vis ci.
in our work we adopt a similar evolutionary perspective focusing onchanges in development practices in the projects before andafter adoption of t ra vis ci most prior work has compared projects that adopt ci with others that do not.
gousious et al.
studied work practices and challenges in pull based development on g ithub .
they report that of the projects surveyed use ci tools to evaluate authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
code quality and that more than of the surveyed contributors employ automatic testing .
importance of toolingfacilitating the testing tasks has been already recognized bypham et al.
back in when the authors conducted the interviews t ra vis ci has only started to support mainstream languages such as java and lack of such tooling has beenreported as an important challenge.
these findings furtheremphasize importance of ci in modern software development.
a march survey of it professionals indicated that of the enterprises and small and midsizebusinesses implement d evops .
not surprisingly industrial adoption of ci has attracted substantial research attention and is a subject of recent literature surveyby eck et al.
.
however this line of work is based on interviews or surveys rather than on analysis of repository dataand as such is to a larger extent susceptible to perception bias e.g.
leppanen et al.
report that ci introduction is beneficial for productivity eck et al.
stress that productivity is likely to decrease before positive effects can be observed andst ahl and bosch validated this hypothesis only partially .
automated testing is an important factor that affects the cost effectiveness of ci and much effort has been devoted toimprove the quality and efficiency of automated testing in ci.campos et al.
enhanced ci with automated test genera tion.
elbaum et al.
and hu et al.
applied test case selection and test case prioritization to test suites.
d osinger et al.
proposed the continuous change impact analysis technique to improve the effectiveness of automated testing.long et al.
designed tools to support collaborative testing between testers.
nilsson et al.
developed a technique tovisualize end to end testing activities in ci processes.
all theseefforts aim at improving the cost effectiveness of ci.
vi.
t hreats to validity we focus on construct and internal validity as we do not claim generalizability.
construct validity one of our constructs is a project s ci adoption time operationalized as first commit to.travis.yml .
a more precise operationalization wouldhave involved reconciling two additional timestamps regis tration of the repository with t ra vis ci and first build the three timestamps may not coincide e.g.
because t ra vis ci can also start a build using some default environment settings ruby without .travis.yml being present.
hence validity of the ci adoption time construct might have been threatenedby our operationalization.
we reduce this threat by excludingthe period immediately before and after our t from all analyses.
another construct is size of a code change .
weoperationalize this as the number of churned lines customarilyinterpreted as the sum of the number of added and removedlines .
in this way moved lines are counted twice as beingadded and as being removed.
moreover we do not distinguishbetween lines of source code and other lines since it is non trivial when dealing with many languages.
internal validity to reduce these threats we have opted for rdd a sound approach to statistical modeling ofdiscontinuity in time series.
application of rdd to se datahas been recently advocated by wieringa .
multiple data filtering steps have been applied above.
we tested the robustness of our models by varying the data filteringcriteria e.g.
month windows instead of and observedsimilar phenomena.
we encourage independent replications tofurther assess the robustness of our results.
vii.
c onclusion this paper focused on the switch to continuous integration ci while several guidelines exist relatively little has beendone to evaluate the state of practice.
we empirically studiedthe impact of adopting t ra vis ci on development practices in a collection of g ithubprojects and surveyed the developers responsible for introducing t ra vis in those projects.
we find that the reality of adopting t ra vis ci is much more complex than suggested by previous work.
the increas ing number of merge commits aligns with the commit often guideline but is likely to be further encouraged by the shiftto a more distributed workflow with multiple branches andpull requests rq .
the commit small guideline however is followed only to some extent with large variation betweenprojects rq .
as expected we observe a general increasing trend in the number of issues closed over time however itwas surprising that this trend slows down after t ra vis ci is introduced rq .
in terms of testing we find that after some expected initial adjustments the amount and potentially thequality of automated tests seems to increase rq .
the most interesting observations relate to pull request pr evaluations while we also find that in aggregate moreprs are being closed after adopting t ra vis as did prior work our time series based analysis suggests that theexpected increasing trend in prs closed over time manifestsitself only before adopting t ra vis after the number of closed prs remains relatively stable rq .
at the same time pr latencies increase steadily over time despite the codechanges getting relatively smaller.
future work should employqualitative methods to understand potential causes for thiseffect.
we can only speculate here that even with the high levelof automation provided by ci the ability of teams to scale updistributed development is limited by the availability of humanresources for manual code review i.e.
the project integrators .this calls for a more profound investigation of how g ithub teams change their pr review practices in response to theintroduction of t ra vis ci as well as additional tool support e.g.
for automatic prioritization and automatic post mergedefect prediction which may help.
future work should alsoexplicitly consider the design decisions and trade offs betweenseemingly equivalent ci pipeline implementations.
projectspecific concerns may drive individual implementations us age and practices as the high amount of variance explainedby our project random effects suggest.