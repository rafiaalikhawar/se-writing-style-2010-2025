program splicing yanxin lu rice universty houston texas yanxin.lu rice.eduswarat chaudhuri rice university houston texas swarat rice.edu chris jermaine rice university houston texas cmj4 rice.edudavid melski grammatech inc. ithaca ny melski grammatech.com abstract weintroduce programsplicing aprogrammingmethodologythat aims to automate the workflow of copying pasting and modifying code available online.
here the programmer starts by writing a draft thatmixesunfinishedcode naturallanguagecomments and correctness requirements.
a program synthesizer that interacts with a large searchable database of program snippets is used to automatically complete the draft into a program that meets the requirements.thesynthesisprocesshappensintwostages.first the synthesizeridentifiesasmallnumberofprogramsinthedatabase that are relevant to the synthesis task.
next it uses an enumerative search to systematically fill the draft with expressions and statements from these relevant programs.
the resulting program isreturnedtotheprogrammer whocanmodifyitandpossiblyinvoke additional rounds of synthesis.
wepresentanimplementationofprogramsplicing calledsplicer for the java programming language.
splicer uses a corpus of over .
million procedures from an open source software repository.
ourevaluationusesthesysteminasuiteofeverydayprogramming tasks and includes a comparison with a state of the art competing approachaswellasauserstudy.theresultspointtothebroadscope and scalability of program splicing and indicate that the approach can significantly boost programmer productivity.
acm reference format yanxin lu swarat chaudhuri chris jermaine and david melski.
.
programsplicing.in proceedingsoficse 40thinternationalconference on software engineering gothenburg sweden may june icse pages.
introduction copyingandpastingfromexistingcodeisacodingpracticethat refuses to die out in spite of much expert disapproval .
the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
nature of the practice indicates that programmers often have to write codethat substantiallyoverlaps withexisting code and that they find it tedious to write this code from scratch.
inspiteofitspopularity copyingandpastingcodeisnotalways easy.
to copy and paste effectively the programmer has to identify a piece of code that is relevant to their work.
after pasting this code they have to modify it to fit the requirements of their taskand the code that they have already written.
many of the bugsintroduced during copying and pasting come from the low level manual nature of the task.
in this paper we present a programming methodology called programsplicing thataimstoofferthebenefitsofcopy and paste without some of its pitfalls.
here the programmer writes code with theassistance ofa programsynthesizer that is ableto queryalarge searchabledatabaseofprogramsnippetsextracted from online open source repositories.
operationally the inputs to synthesisincludea draft programthatisamixofunfinishedcodeandnaturallanguagecomments aswellacorrectnessrequirement for example a set of test cases or a constraint on the api callstheprogrammerwantstoinvoke.thesynthesizercompletesthe holes in the draft by instantiating them with code extracted from the database such that the resulting program meets its correctness requirement.thesynthesizer isinvokedinteractivelyaspartofa largerprogramdevelopmentprocess initially thedraftfedtothesynthesizer maybe closeto empty andthe programmeris freeto generate new drafts by adding code and holes to the result of a round of synthesis.
inmoredetail oursynthesisalgorithmoperatesasfollows.first it identifies and retrieves from the database a small number of programsnippetsthatarerelevanttothecodeinthedraft.these search results are viewed as pieces of knowledge relevant to the synthesistaskathand andareusedtoguidethesynthesisalgorithm.specifically fromeachresult thealgorithmextractsasetof codelets expressions and statements that are conceivably related to thesynthesis task.
next it systematically enumerates over possible instantiationsofholesinthedraftwithcodelets usingheuristics to prune the space of instantiations.
the primary distinction between our synthesis algorithm and existingapproachestosynthesisliesintheuseofpre existingcode.
a key benefit of our data driven approach is that it helps with the acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden y. lu et al.
1int csvmat st ring filename 2int mat new int comment read a matrix from a csv file req string filename matrix.
csv int m new int solution return test matrix m ?
?
a draft program1int csvmat st ring filename 2int mat new int 3file f newfile filename 4scanner scanner newscanner f 5for inti i r i 6string line scann er.nextline 7string fields line.split 8for intj j c j 9mat parseint fields b completed draft1int read csv int m intr intc string filename 2file f newfile filename 3scanner scanner newscanner f 4for inti i r i 5string line scann er.nextline 6string fields line.split 7for intj j c j 8m parseint fields 10return m c a database program figure reading from csv files problemof underspecification.becausesynthesisinvolvesthe discoveryof programs the requirements for a synthesis problem may beincomplete.thismeansthatevenifasynthesizerfindsasolution thatmeetstherequirements thissolutionmayinfactbenonsensical.thisproblemisespeciallycommonintraditionalsynthesis tools which explore a space of candidate programs without significant human guidance.
in contrast the codelets in our approach are sourcedfrompre existingcodethathumanswrotewhensolvingrelated programming tasks.
this means that our search for programs isbiasedtowardsprogramsthatarehuman readableandlikelyto follow common sense constraints that humans assume.
theuseofpre existingcodealsohasapositiveeffectonscalability.
without codelets the synthesizer would have to instantiate holesinthedraftwithexpressionsbuiltentirelyfromscratch.in contrast in program splicing the synthesizer searches the more limited space of ways in which codelets can be merged with a programmer written draft.
wepresentanimplementationofprogramsplicing calledsplicer that uses a corpus of approximately .
million methods extracted from the sourcerer source code repository to perform synthesisofjavaprograms.splicerusesaknownmethodforcodesearchtofindprogramsrelevanttoadraft.themethodformergingcodelets with a draft is also based on existing non data driven approaches to enumerative synthesis.
the key novelty of the system lies in combining these two components into an effective software engineering tool.
we evaluate our approach on a suite of java programming tasks includingtheimplementationofscriptsusefulineverydaycomput ing modificationsofwell knownalgorithms andinitialprototypes ofsoftwarecomponentssuchasguis htmlparsers andhttp servers.
our evaluation includes a comparison with scalpel a state of the art programming system that can transplant code acrossprograms aswellas auserstudywith18participants.the evaluation shows our system to outperform scalpel and indicates that it can significantly boost overall programmer productivity.
now we summarize the contributions of the paper we propose program splicing a methodology where programmers use a program synthesizer that can query a large databaseofexistingcode asamorerobustproxyforcopying and pasting code.
we present an implementation called splicer that repurposes existing approaches to code search and synthesis and is driven by a corpus of .
million java methods.
we present an extensive empirical evaluation of our system on a range of everyday programming tasks.
the evaluation which includes a user study shows that our method outperformsastate of the artcompetingapproachandincreases overall programmer productivity.
therestofthepaperisorganizedasfollows.insection2 wegive anoverviewofourmethod.section3statesoursynthesisproblem section describes the approach of program splicing section presents our evaluation.
related work is described in section .
we conclude with some discussion in section .
overview in this section we describe program splicing as embodied by splicer using a few motivating examples.
.
reading a matrix from a csv file consider a programmer who would like to read a matrix from a comma separated values csv file into a dimensional array and thentosquarethematrix.however theuserdoesnotrecallindetail what api to use and how matrix multiplication is implemented exactly.
incurrentpractice theprogrammerwouldsearchthewebfor a program that reads from a csv file and another one that does matrix multiplication copy code from the search results and modify the programs manually.
in contrast while using splicer he or shewritesa draftprograminanotationinspiredbythesketchsystem for program synthesis figure 1a .
this draft program declaresthe2d array matrix however inplaceofthecodetofill thisarray ithasa holerepresentedbyaspecialsymbol ?
?
.ahole in a program serves as a placeholder that splicer automaticallysubstitutes with code using an external snippet.
inthis example the external snippet is a piece of code that reads a matrix from a csv file.
theuserisrequiredtoprovideinformationaboutrelevantexternalsnippetsusingjavadocstylecommentscontaining comment sectionand req sectionabovetheholeorabovethefunction.if this information is provided above the hole as showed in figure 1a then the hole itself will be replaced with the external code snippet.
theuserdescribestheformsofexternalcodethatarerelevant to the task using natural language comments.
in this example the commentscontainwordssuchas read matrix and csv inthe comment section above the hole suggesting a program that reads authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
program splicing icse may june gothenburg sweden 1int csvmat st ring filename 2int mat new int ... 4int mat2 new int comment square a matrix using matrix multiplication req int m ... int result ... solution return tes t equality m result ?
?
11return mat2 figure reading csv draft for matrix multiplication 1int csvmat st ring filename 2int mat new int 3file f newfile filename 4scanner scanner newscanner f 5for inti i n i 6string line scan ner.nextline 7string fields line.split 8for intj j n j 9mat integer.parseint fields 10int mat2 new int 11for inti i n i for intj s j n j for intk k n k s mat mat mat2 s 15return mat2 figure reading csv complete program from csv files.
the system will use these words as a hint to search the code database.
this is similar to a web search using text but in this case it is done in a programming scenario.
finally to ensure thatthesynthesizedcodeiscompatiblewiththecodethathehas alreadywritten theprogrammerneedstoprovidesomecorrectness requirements.
therequirementsforourexampleareshowninthe req sectionabovethehole.arequirementissimplyapieceofcodethat executesandreturnstrueorfalseindicatingifthesolutioniscorrect.
to test the correctness of a synthesized code snippet solution solution will be replaced with a candidate solution and everything under req is run in an independent environment which has no access to the variables and names in the draft program.
for example in figure 1a m is defined for storing the matrix and filename is defined for storing the filename so that the solution willhaveaccesstothefilenameandbeabletocheckwhetherthe matrixisreadinto m .
test matrix weomitadetaileddefinition of this function is used to test the content of the matrix.
the advantage of separating the testing environment from the draft programisthatuserscanwritetestsinallpossiblewayswithout polluting the draft program and thatis also how typical unit tests are written.
given the draft splicer issues a query to a searchable database of code snippets.
the code database then returns a set of functions relevant to the current programming task including at least one program that reads from csv files such an implementation isshown in figure 1c .
the system now extracts a set of codelets expressions and statements from these functions and uses a figure api call sequence constraint for face detection composition of these codelets to fill in the hole in the draft.
the completed draft is showed in figure 1b.
aftergettingthecodethatreadsamatrixfromacsvfile theuser nowfocusesonthesecondpartofthetask whichismatrixsquaring using matrix multiplication.
the previous code is now extendedinto a new draft which has a hole for the matrix multiplicationcode some comments and requirements.
this draft is shown in figure .
splicer now searches the code database for snippets that performmatrixsquaringusingnormalmatrixmultiplicationand mergesthesesnippetsintotheexistingcode whileensuringthat allrequirementsaremet.thecompleteprogramresultingfromthis process is shown in figure .
asshownintheexample splicercanbeusedinaniterativeand interactive manner.
a programmer can start writing code as usual and then bring in external resources from the web into the existingcodebaseasneeded.inthisrespectourapproachissimilarto copyingandpastingcode.thedifferenceisthatsplicerautomatestheprocessoffindingandmodifyingrelevantcode andguarantees a certain level of reliability by ensuring that the output program meets all its requirements.
.
face detection using opencv in previous examples we relied on input output tests to verify the correctness of a solution.
now we consider the use of program splicing in the implementation of face detection a computer vision taskin whichinput output testsarehard tospecify requiringthe use of an alternative form for correctness requirement.
specifically therequirementsthat weuseareconstraintson sequencesofapi callsthataprogrammakes givenintheformofafiniteautomaton.
figure shows a draft program for this task.
in this example a user wants to use a cascadeclassifier object from opencv to detect faces from an input image called lena.jpg .
the output image named facedetection.png should have the same picture with a rectangle drawn above the faces.
the api call constraint for the task is shown in figure .
this requirementdescribesa sequenceofobjectcreation andapiinvocationactionsperformedduringfacedetection.tochecktheapi call requirement splicer runs the candidate solutions under an environment where necessary functions and variables are defined to keep track of the program state which is checked against therequirement.
for example in figure splicer loads the requirement line runs a candidate solution and checks internally line ifthesolutionhascreatedafacedetector has detector has loaded an image has image and etc.
and it ensures things are completed in order.
predicates like has detector are defined along with the api constraints.
in figure for example they are defined inside facedetectiontest.java.
while the requirement is more low level than unit tests we notethatitfreesusersfromspecifyingsmalldetailssuchaswhat configurationfiletobeused thecolorfordrawingrectangleson authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden y. lu et al.
comment facedetection using opencv req api cons facedet ectiontest.java solution run and test has detector has image has detection image written 6public void run 7string input img lena.jpg 8string output img facedetection.png 9cascadeclassi fier detector newcascadeclassifier ?
?
?
?
figure face detection draft program 1public void run 2string input image lena.png 3string filename facedetection.png 4cascadeclassi fier detector 5newcascadeclassifier getclass .getresource lbpcascade frontalface.xml .getpath 6mat image highgui.imread getclass .getresource input image .getpath 7matofrect facedetections newmatofrect 8detector.detectmultiscale image facedetections 9for rect rect facedetections.toarray core.rectangle image newpoint rect.x rect.y new point rect.x rect.width rect.y rect.height newscalar 12highgui.imwrite filename image figure face detection complete program faces and the order of specifying the four corners of rectangles.
splicerusesthisrequirementtofilteroutmanyofthecandidate programsthat itconsiders during synthesis.only afewsolutions satisfy therequirement andthe usercould easilypick thecorrect one shown in figure .
notethattheexternalcodeinformationinthisexampleisprovidedabovethefunction asshowninfigure5.inthiscase splicer willreplacealltheholesinsidethisfunctionwithpossiblydifferent external code snippets in a single run using a single set of relevant programs.
problem formulation in this section we define the problem of program splicing.
languagedefinition.
as mentioned earlier a draftprogram in oursettingconsistsofincompletecodeandasetofnaturallanguage comments.
we start by specifying the language of code permitted in our drafts.
our approach accepts code in a subset lof java abstractly represented by the following grammar.
in summary the grammar permits standard imperative expressions and statements over base and array types as well as a symbol ?
?representing holes.
angbracketleftexpr angbracketright id c angbracketleftexpr angbracketrightbinop angbracketleftexpr angbracketright unaryop angbracketleftexpr angbracketright f angbracketleftexpr angbracketright ... angbracketleftexpr angbracketright id angbracketleftexpr angbracketright ?
?
angbracketleftstmt angbracketright letid angbracketleftexpr angbracketright if angbracketleftexpr angbracketright angbracketleftstmt angbracketright angbracketleftstmt angbracketright while angbracketleftexpr angbracketright angbracketleftstmt angbracketright angbracketleftstmt angbracketright angbracketleftstmt angbracketright ?
?
angbracketleftprogram angbracketright id angbracketleftexpr angbracketright ... angbracketleftexpr angbracketright angbracketleftstmt angbracketright inthis grammar crepresentsa constant idrepresentsan identifier frepresents external functions api calls and binopand unaryoprespectively represent binary and unary operators.
we assumethatastandardtypesystemisusedtoassigntypestoexpressions and statements in this grammar.
the actual language handled by our implementation goes somewhat beyond this grammar permitting arrays objects data structure definitions a limited form of recursion and syntactic sugar such as for loops.
thespecialsymbol ?
?inthegrammarrepresentstwokindsof holes.expression holes is a placeholder for a missing expression.
a statement hole is a placeholder for a missing statement.
thesemanticsofaprogramwithholescanbedefinedasasetof complete hole free programs obtained by instantiating the holes with expressions and statements.
the semantics of a complete programisdefinedinthestandardway.weskiptheformaldefinitions of these semantics for brevity.
requirement.
aside from a draft an input to a program splicing problemincludesa requirement.thisrequirementisnotexpectedto be a full correctness specification.
specifically our implementation permits two classes of requirements input output tests and finite automata that constrain the sequences of api calls that a program canmake.weassumeaproceduretoconservativelycheckwhethera given complete program satisfies a given set of requirements.
for requirements that are input output tests this procedure simply evaluatestheprogramonthetests.theprocedureforautomaton constraints is based on a standard sound program analysis.
program splicing.
letps lbe a draft program with one or moreholes.let db lbeadatabasecontainingprogramswith noholes.
our objective is to use the programs from dbto complete holes in ps.
specifically we use the expressions similarly statements from dbto complete the expression holes similarly statementholes in ps.naturally suchaninstantiation oftheholes canbeperformedinmanyways.ourgoalistodothisinstantiation such that the resulting program passes the requirement.
moreprecisely considertheset cofallcodelets subexpressions andstatements thatappearinprogramsfrom db.letpbethe set of complete programs obtained by instantiating the holes of ps by appropriately typed codelets in c. let u l true false be a function that maps a complete program in lto a boolean valueindicatingwhethertheinputprogrampassestherequirement accompanying ps.thesplicingproblemistofindaprogram p c p such that u p c true.
method inthissection wepresentaspecificsolutiontothesplicingproblem implemented in the splicer system.
our synthesis problem has two key subproblems code search andhole substitution.
code search given a program ps l search a large corpus containingthousandsofprogramsforasetofrelevantprograms such that the retrieved programs contain the codelets that are neededtofillholes.thedesiredpropertyofthecodesearchtechnique should be that the retrieved programs should contain the exact codelet we need within a short period of time.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
program splicing icse may june gothenburg sweden hole substitution given multiple database programs sd w e wouldliketosearchforthecorrectcodeletstofillthehole.multiple programs combined consist of a large number of codelets.
the keychallengehereistoprunethesearchspacesuchthatwecan efficiently getthe exactcodelet we needand ensurethe necessary codelets will not be dropped.
.
searching for programs inthissection wedescribethecodesearchtechniquesfromkashyap et al.
with a modification employed to query a large database of programs effectively.
this is the first step in our workflow to findcandidatefunctionalityfromtheprogramdatabasetocomplete the draft program.
given the word hints below comment i nt h e javadoc and also the variable names in the draft program splicer does a code search and returns a set of relevant programs.
an important goal of the code search component is to have a quickresponsewhensearchinglargeamountsofcode.toaccomplishthis variouscodefeaturesareextractedfromalargecorpusofopen source code.
these code features along with the corresponding source code are stored in a program database.
the programdatabase is a scalable object store database that allows for fast similarity based queries.
aqueryissuedtotheprogramdatabaseincludescodefeatures extracted from the draft program along with associated weights indicatingtherelativeimportanceofthecodefeatures.theprogram databasecomputestheknearestneighboringcorpuselementsto thequery usingthecodefeaturesstored associatedweights and similaritymetricsdefinedoneachcodefeature.theresultofthe query is presented as a ranked list of source code corresponding to the k nearest neighbors.
below we describe the features extracted and the associated similarity metrics.
natural languageterms.
for this feature we extract the function name comments local variable names and parameter names of a function.
such extracted natural language nl terms are then subjected to a series of standard nl pre processing steps such assplittingwordswithunderscoresorcamel case removingstop words including typical english stop words and those specialized for java code stemming lemmatization and removing single character strings.
additionally we use a greedy algorithm for splitting terms into multiple words based on dictionary lookup.
this is to handle the case where programmers combine multiple words without separating the words with underscores or camelcase when naming functions and variables.
afternlpre processing wecomputeatf idf termfrequencyinversedocumentfrequency scoreforeachnlterm.eachfunction is considered as a document and the tf idf is computed per project.
we give the function name term an inflated score more than otherterms becauseitoftenprovidessignificantinformationabout a function s purpose.
the similarity between two functions is measured by taking the cosine similarity of their nl terms together withtheirtf idfvalues.belowisanexampleofnltermsfeatures for the draft showed in figure 1a.
read .
matrix .
csv .
...names.here we extract all the variable names the name of thefunction andperformsome basicnormalizationsuchassplitting camel case and underscores.the similarity metric used is the jaccard index on sets of names.
the code search method is described extensively in and the main difference is that our similarity search is primarily drivenby the natural language term features with variable names andfunction names providing additional context around the hole inthe query code.
we give more weights to natural language termfeatures and less weights to variable names and function names.
the reason is that the most important hint in the draft code is the comment becauseusersarerequiredtodescribethecodetheywant tosynthesize.however variablenamesandfunctionnamesmust not be treated as equally important because sometimes variable namesandfunctionnamesmightbetotallyirrelevanttothecode they want to synthesize.
for example users might leave comments sayingthatthey wantthecodethatreadsa matrixfromacsvfile but it is totally possible that the surrounding context is all about matrix calculation.
.
program completion afterwehaveretrievedasetofprogramsfromtheprogramdatabase ournextstepistocompletethedraftbysynthesizingcodelets.
a codelet here is a sequence of program statements or a set of expressions from the programs retrieved from the database duringcodesearch.notethatunlikeothertraditionalsynthesistechniques our synthesis method does not generatecodefromscratch butinsteaditusescodeletsfromalarge code corpus.
for each database program paired with the given partial program we spawn a thread to do the code completion task parallelizing the process.
a code completion task consists of the following steps .
.
hole substitution.
the first step is to use the codelets from the retrieved program to substitute the holes in the draft.procedure shows the algorithm.
we start by checking whetherthere is any hole in the draft at line .
if not we move on to the merging step.
otherwise we start injecting codelets into the draft.
for each hole we iterate all the codelets starting from the smallest oneandcheckwhethertheinjectionisvalidusingourheuristicsat line3.ifso wethensubstitutetheholewiththecodeletatline4and then continue injecting more codelets by recursively calling itself at line until we finish filling all the holes.
when no more holesexistinthedraftprogram wethenmergethecodeletsinto theexistingcodebase whichisexplainedindetailinlatersection.
if at some point injecting a codelet is not successful we backtrack andtryanothercodelet.next wediscussourheuristicsusedinthe step of hole substitution.
synthesizingexpressions ifwearesearchingforasubstitution nfor an expression hole h we ensure nandhare of the same type.
in addition we can also consider the rolesofhandn.
the intuition is that we only consider the codelet that serves as the same role by lookingattheparentof nandtheparentof hintheparsetree.if the parents of nandhare not of the same kind then we discard nandlookforanothercodelet.figure7illustratestheidea.ifwe are looking for a codelet to replace a hole representing the rval inside an assignment statement our target codelets are more likely authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden y. lu et al.
procedure fill input a draft program ps land a database program pd l output a complete program pc ifnot has hole ps then return merge ps end if forh next hole ps n next codelet pd do ifvalid ps h n then p primes substitute ps h n pc fill p primes pd ifpc nequalnullthen return pcend if end if end for return null figure matching for expression codelet procedure merge input acompleteddraftprogram ps landadatabaseprogram pd l output a correct completion pc ifno undefined refs ps then ifis correct ps then return psend if return null end if foru next undefined ref u r next ref pd do ifsame type ps u r then p primes substitute ps u r pc merge p primes pd ifpc nequalnullthen return pcend if end if end for return null to be the rvalof other assignment statements.
we can then just considerthosecodeletsassubstitutionsandignoreothercodelets.
the same can be applied if we want to synthesize the code for the guard of a condition for example.
synthesizing statements when we are searching for substitutionsforastatementhole h weneedtoconsiderasequenceof statementsfromthedatabaseprogram.wedefineaslidingwindow of various lengths and use that to scan the database program to identify the statement sequence we would like to use to substitute forh.wealso scanthesequencesunderloopsandconditions.we then use each codelet to fill the hole.
.
.
code merging.
one problem with using the codelets from thedatabaseprogramsisthatthenamingschemesaredifferentfrom the ones in the original draft program.
therefore after we have completed thedraftprogram wesearch forreference substitution suchthattheresultingprogramrefersbacktothedatadefinedin thedraftprogram whichisquitesimilartocodetransplantation .thealgorithmisshowninprocedure2.thetaskhereisessentiallysearchingforamappingbetweenthereferencesacrosstwo programs.
we first check whether we have undefined