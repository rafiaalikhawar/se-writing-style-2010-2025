comparing and combining test suite reduction and regression test selection august shi tifany yung alex gyori darko marinov department of computer science university of illinois at urbana champaign urbana il usa awshi2 yung4 gyori marinov illinois.edu abstract regression testingis widelyused tocheckthatchanges made to software do not break existing functionality but regres sion test suites grow and running them fully can become costly.
researchers have proposed test suite reduction an d regression test selection as two approaches to reduce this cost by not running some of the tests from the test suite.
however previous research has not empirically evaluated how the two approaches compare to each other and how well a combination of these approaches performs.
we present the first extensive study that compares testsuite reduction and regression test selection approaches i ndividually and also evaluates a combination of the two approaches.
we also propose a new criterion to measure the quality of tests with respect to software changes.
our exper iments on commits from open source projects show that regression test selection runs on average fewer tests by .15pp than test suite reduction.
however test suite r eduction can have a high loss in fault detection capability with respect to the changes whereas a safe regression tes t selection has noloss.
the experiments also show thata combination of the two approaches runs even fewer tests on average .34pp than regression test selection but these tes ts still have a loss in fault detection capability with respec t to the changes.
categories and subject descriptors d. .
software engineering testing and debugging general terms experimentation measurement keywords regression testing test suite reduction regression test selection .
introduction regression testing is important but time consuming.
regression testing is widely used to check that changes to a software system do not break existing functionality .
modern software evolves fast with changes pushed to a repository even several times per minute trigger ing regression test runs.
additionally regression test s uites grow and often become costly to run with previous research reporting test suites taking even weeks to run .
even google a corporation with a lot of computing resources reported that running all tests is prohibitive with a quadrat ic growth in the test execution over time .
previous research has proposed two approaches to speed upregression testing test suite reduction andregression test selection .
both approaches focus on runningonly some tests from the full test suite we call these tests chosen to run tests.
test suite reduction aims to permanently remove from the full test suite those tests that are redundant with respect to some testing requirements commonly with respect to statement or branch coverage.
the analysis is performed once on a single revision of software and the reduced test suite is used in subsequent revisions.
although running the reduced test suite can miss some faults that the full test suite detects it may still be tolerable in some con texts to get faster test results the full test suite could be run more rarely .
regression test selection aim s to select from the full test suite those tests that are releva nt to the changes made to the software.
the analysis is performed on every revision of software to determine how the changes between revisions affect the tests.
regression test selection is safeif it selects all tests that maybe affected by the changes guaranteeing that the outcome of the tests that are not selected will not be affected by the changes.
when test engineers wish to speed up regression testing it is unclear which approach is better to use testsuite reduction or regression test selection.
to the best of our knowledge there is no prior empirical comparison of test suite reduction and regression test selection.
eac h approach has some pros and cons.
regression test selection when safe selects all tests that could detect faults d ue to the changes while test suite reduction can remove some tests that could detect such faults because test suite red uction is not evolution aware i.e.
it removes tests that are deemed redundant for the current revision irrespective of future changes .
test suite reduction has a low amortized analysis cost because it is performed on one revision while regression test selection incurs an additional analy sis cost for every revision.
however test engineers care about the total testing time that includes not only the analysis time but also the time to execute the chosen to run tests it is unclear a priori which approach has lower total time.
to compare test suite reduction and regression test selection we would ideally measure how much time each approach takes and how many real faults it finds in the conthis is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication esec fse august september bergamo italy c acm.
... 237text of software evolution.
because measuring total time is challenging most research on regression testing measur es the number of chosen to run tests as a proxy for time .
we also measure the number of chosen to run tests to determine whethertest suite reductionor regression test selec tion yields a smaller number.
because using real faults is challenging mostresearch uses mutantsas aproxy .
we also use mutants but we have an additional challenge to measure the quality of the chosen to run tests with respect to the changes .
we introduce a new criterion to measure the loss of faultdetection capability of test suites with respect to changes .
we refer to the faults that are related to the changes as change related faults.
intuitively these faults can be directly in the code parts that changed between two revisions or latentfaults that are in the unchanged code parts but exposed by the changes.
simply reusing a criterion for evaluating a test suite on an entire given program revision i.e.
measuring the fault detection capability of the test suite on the code revision obtained after the changes could be misleading because it can find faults unrelated to the changes.
for example consider two test suites t1that broadly covers the entire code and t2that covers less code overall but focuses on one module m. if the faults are randomly seeded throughout the code t1can be better as it detects a higher percentage of faults than t2.
however if the change related faults affect the module mon which t2focuses then t2can be better than t1at detecting these change related faults.
we propose a new test criterion called change related requirements crr that approximates the change related faults a test suite needs to find.
we use this criterion to measure the quality of a test suite and to compare test suite reduction and regression test selection.
to further speed up testing we can combine the two approaches first perform test suite reduction on the full tes t suite to create a smaller reduced test suite and then perform regression test selection on this reduced test suite af ter the changes yielding an even smaller number of tests than selecting from the full test suite.
combining the two approaches provides the greatest reduction in the number of tests.
we call this combination selection of reduction .
we empirically evaluate how much it reduces the size of the test suite to run.
considering the quality of the tests selected b y regression test selection from the reduced test suite assu ming safe selection the change related fault detection ca pability of the tests selected from the reduced test suite is as good as the change related fault detection capability of t he reduced test suite.
we perform an empirical evaluation on open source java projects over a total of revisions to answer the following three questions rq1 does test suite reduction or regression test selection yield a smaller number of tests to run on average?
rq2 what is the change related loss in quality of the reduced test suite based on our crr criterion?
rq3 how does selection of reduction compare with the other two approaches in terms of number of tests to run?
.
background we review some background on test suite reduction and regression test selection and including how their effectiv eness is traditionally evaluated.
.
test suite reduction test suite reduction aims to remove redundant tests from a test suite creating a reduced test suite that is a subset of the full test suite ideally a developer could run fewer tests yet still detect almost the same faults as if running th e full test suite.
test suite reduction techniques find redun dant tests with respect to some testing requirements commonlydefinedbycodecoveragecriteria suchasstatementor branch coverage.
a test is redundant with respect to a test suite if the test satisfies only the requirements already sat isfied by some other tests in the test suite.
for a set of tests t we write req t for the set of requirements satisfied by t. given a full test suite o test suite reduction constructs a reduced test suite r osuch that req o req r .
after obtaining this reduced test suite r a developer would use it in lieu of the full test suite ofor testing the software as it evolves.
previous research on test suite reduction measured the effectiveness of a reduced test suite by two metrics the reduction of size and the loss in faultdetectioncapability bothincomparisontothefulltestsu ite.
for a reduced test suite rconstructed from the full test suiteo the size reduction is measured by r o a smaller value is better as it means fewer tests need to be run.
the loss in fault detection capability is measured using a proxy for the number of faults detected often the number of mutants killed but sometimes also the number of statements covered or other requirements satisfied .
withreq t denoting the set of requirements satisfied by the set of tests t the loss in fault detection capability is measured by req o req r req o a smaller value is better as the number of requirements satisfied by the full test suite but not satisfied by the reduced test suite is smaller relative to the set of all requirements satisfied.
note that different kinds of requirements should be used for thereductionandevaluation otherwise usingthesame kin d would trivially produce a loss of .
.
regression test selection unliketest suitereductiontechniquesthatoperateononl y onesoftware revision regression testselectiontechniqu esoperate on two or more software revisions.
the aim of regression test selection is to run only the tests that may be affected by the changes made between the two revisions.
regression test selection techniques are often designed to be safe with respect to the changes i.e.
a test is not selected to be run only if the software changes cannot affect the outcome of the test .
given a full test suite oiat revision i regression test selection selects torunasubset of thesetests si oi where represents all the other inputs that regression test selec tion takes including most importantly the changes between revision iand the previous revision typically revision i except for branching version histories but also the co verage matrix from the previous revision.
the effectiveness of regression test selection is measured by the ratio of number of tests selected to run over the total number of tests si oi a smaller value is better.
developersuseregression testselection tospeeduptestin g with a focus on detecting change related faults.
commonly a developer starts from a software revision where all tests in the test suite pass and after making some changes the developer wants regression test selection to select all t he 238tests that could fail because those tests find new faults.
in the general case however a developer can start from a software revision where some tests in the test suite fail and after making some changes the developer can use regression test selection in two scenarios select all previou sly failing tests even if they are not affected by the change reminding the developer that these failing tests are due to faults not fixed by the changes or select only the tests that are affected by the changes and if a previously passing test now fails it is due to a change related fault.
note that a change related fault is not necessarily introduced i n the changed code instead the change can be correct by itself but could lead the execution to some previously exist ing latent fault that was not executed before.
our crr criterion section .
captures the second scenario wher e a developer is only concerned with the new faults related to the developer s own changes and ignores other existing faults in the code possibly introduced by other developers that are unrelated to whatever change the developer made.
.
methodology this section describes our methodology for comparing the effectiveness of test suite reduction regression test sel ection and their combination.
we first describe how we evolve reduced test suites across multiple software revisions.
we th en define our crr criterion that evaluates the change related quality of a test suite for a change at a given revision.
we finally describe our proposed combination of the two approaches that applies regression test selection after havi ng performed test suite reductionon an earlier revision.
.
evolving reduced test suite test suite reduction constructs a reduced test suite on a singlerevision so evaluating the effectiveness of a reduced test suite as software evolves requires evolving the reduce d test suite into each subsequent revision.
ideally we would evaluate test suite reductionbyapplyingit on some softwa re revision and then consulting with developers on how the reduced test suite would actually evolve into the future.
however performing such an experiment with real developers is rather hard so we instead simulate from the actual project history how the reduced test suite could have evolved had test suite reduction been applied at some revision.
in general we need a procedure that takes a reduced test suite from one revision and outputs the evolved test suite at a later revision.
in our previous work we considered the evolution of the reduced test suite into a future revisio n by tracking tests based on name and only considering the tests that existed across all revisions which ignores t he tests added or removed after performing reduction.
this procedure captures how the tests from the reduced test suite behave in the future but it ignores new andremoved tests.
we modify our previous procedure to also consider the new and removed tests.
new tests are often introduced to cover new functionality if developers were to use test sui te reduction we assume they would augment the reduced test suite with these new tests as their software evolves with new functionality.
removed tests on the other hand may cover functionality that has been removed or may even be redundant tests manually identified so we assume developers would remove these tests from the reduced test suite as well if they still exist in the reduced test suite .
in other word s the reduced test suite used to replace the full test suite should go through similar changes as the full test suite went through while the software evolved.
we denote by rithe reduced test suite constructed at revision ifrom the full test suiteoi.
to evolve rito a later revision i we consider any new and removed tests between oian where the tests are identifiedbyname.
amore precise approach could track tests not only by name but by the semantics inferring likely renames .
definition .the reduced test suite computed at revisioniand evolved to subsequent revision i is the evolved reduced test suite ei i ri oi oi oi .
change related requirements crr our goal is to compare the quality of the subsets of tests chosen to run by test suite reduction and regression test selection which requires an appropriate metric.
because tes ts are run to detect faults the ideal measure would be by the faults that the tests detect.
in regression testing develo pers focus on code changes and care most about change related faults eithernewlyintroducedfaultsorlatentfaultsthatare exposed by tests only after the change .
the tests chosento run by test suite reduction and regression test selecti on should ideally detect all the change related faults that th e full test suite detects.
ideally wewouldliketomeasureonlychange relatedfault s and not all faults that a test suite detects.
given a set of testst o i from revision i that are chosen to run after a change let faults t represent the set of faults detected by t. intuitively change related faults are the faults fromfaults t that are not detected before the change is applied.
while the intuition can be clear it is challenging to give an automatic procedure to precisely determine change related faults because it is challenging to map each test failure to fault s and map faults across soft ware revisions e.g.
consider a case where a function with a fault is inlined in several callers and a test fails in one of those callers .
for this reason we approximate the set of change related faults with the set of faults detected onl y by the tests affected by the change as found using a safe regression test selection technique and not detected by tests not affected i.e.
the set of change related faults is faults si t faults t si where si is the set of tests selected from oi .
this formula can overapproximate change related faults when it includes faults that are only detected by the selected tests but unrelated to .
it is also challenging to build a dataset of real test suites that can detect real regression faults because we need not only one test written to detect each regression fault after i t had been already fixed but an entire test suite that could have detected the fault.
for this reason we measure for each test what test requirements statements covered and killed mutants it satisfies instead of measuring what real faults it detects.
we define a new criterion which we call change related requirements crr that specifies the change related requirements that a test suite satisfies definition .the set of change related requirements satisfied by tis crrsi t req si t req t si here req t is used in the broadest sense to denote any requirements e.g.
a set of statements covered or a set of seeded or real faults detected.
239r1r2r3r4r5 t1 t2 figure matrix for requirements r satisfied by tests t .
red color marks change related requirements and tests selected by regression test selection.
brackets mark tests in the evolved reduced test suite.
as a simple example to demonstrate crr consider the matrix in figure that shows what requirements each test satisfies.
inthisexample onlytherequirement r3ischangerelated si t1 t4 andei i t3 t4 .
for test suite reduction the loss in quality of a reduced test suite is typi cally measured by req o req r req o where req t denotesallrequirementsthatatestsuitesatisfies includingthose thatare notchange related.
inthisexample if we use all requirements that all four tests satisfy both si andei i would need to satisfy all five requirements and we see that both si andei i fail to satisfy some requirements.
however r3is the only change related requirement and crr should consider only such requirements.
if regression test selection is safe then the requirements satisfied by the tests chosen to run by regression test sele ction si satisfy all change related requirements and potentially some more requirements .
we see in our example thatsi does indeed satisfy r3.
we want to measure how many change related requirements a reduced test suite satisfies.
if we required it to satisfy all requirements satisfie d bysi those would include r2 r4andr5as well which are not change related hence including these extra requir ements could lead to inaccurate results.
indeed ei i does not satisfyr4despite satisfying the change related requirement r3 so using req si would inaccurately report a quality loss forei i .
however usingourproposedcriterion crr in this example filters out the requirements not change relat ed by removing the requirements satisfied by the non selected testst2andt3.
we see that crrsi oi does not include r2 r4 andr5 but only includes r3.
therefore in this example a set of tests only needs to satisfy r3to have no quality loss which is the exact change related requiremen t. .
quality of reduced test suites we usecrrsi ei i as the set of requirements that an evolved reduced test suite ei i initially reduced at revision iand evolved to revision i satisfies with respect to the changes .
we apply the traditional metric for measuring loss in quality by substituting crr in lieu of requirements definition .given the full test suite oi the selected testssi and the evolved reduced test suite ei i the changerelated loss in quality of ei i is crrloss i i crrsi oi crrsi ei i crrsi oi in the example from figure we determine the changerelated requirements for the full test suite to be just r3 i.e.
crrsi oi r3 .
because crrsi ei i r3 r5 has all the change related requirements crrloss i i is .
.
selection of reduction we compare the effectiveness of test suite reduction and regression test selection with each other because they both run a subset of tests from the full test suite.
however the two approaches are orthogonal test suite reduction remov es redundant tests from a single revision while regression te st selection considers changes between two revisions to selec t tests to run.
the two approaches can be combined.
after test suite reduction constructs rifor revision i rican be used as a replacement for oi and its evolved form ei i can be used for all future revisions i in lieu of oi .
regression test selection can then select tests affected by the changes between revision i and its predecessor from ei i instead of fromoi .
basically to get selection of reduction regression test selection would select tests from a reduced test suite.
for a revision i givensi andei i the tests selected from the evolved reduced test suite are si ei i .
.
ev aluation we next describe our evaluation of test suite reduction regression test selection and their combination on open source projects from github .
we first summarize the projects used in our study and then describe how we set up our experiments to answer the following three research questions rq1 does test suite reduction or regression test selection yield a smaller number of tests to run on average?
rq2 what is the change related loss in quality of the reduced test suite based on our crr criterion?
rq3 how does selection of reduction compare with the other two approaches in terms of number of tests to run?
.
projects figure 2lists the17projects thatwe use in ourevaluation.
we cloned from github java projects that use maven to build and junit to run tests.
we use projects from our prior study of test suite reduction we do not use three projects from the prior study one does not build any more one has issues with running tests on many commits and one does not work with the regression test selection tool ekstazi .
we also include two new projects square retrofitand apachepdfbox.
for each project we tabulate the number of commits used in our evaluation the starting sha the commit id in git the minimum median and maximum number of lines of code among the commits used in theevaluation measured usingsloccount theminimum median andmaximumnumberoftests inthefull test suite among the commits used in the evaluation and the time it takes to run the test suite using mvn test on the latest revision we evaluated on.
we conducted the experiments on a .33ghz intel core2 quad machine with 16gb of ram running ubuntu .
.
.
experimental setup for each project we perform regression test selection for the range of commits specified in figure .
we use the stateof the art regression test selection tool ekstazi t o find selected tests for the changes between each commit and its predecessor.
ekstazi selects the tests based on file level dependencies i.e.
if a file changed between two commits ekstazi selects every test that depends on that file.
moreover ekstazi selects at the level of test classes i.e.
if any one test 240loc tests idproject commits start sha min median max min median max time p1commons lang 5099ad1a4df .546s p2caelum stella 30939e50b7f .582s p3caelum v raptor 165443cf0ed .554s p4cloudfoundry uaa 20976cb4b8c .927s p5dropwizard 2706bf66144 .149s p6scribe java 2140222f08f .182s p7sql parser 251a1ddf59b .812s p8jodatime .106s p9assertj core 348df1adedd .259s p10messagepack 34039c7fa7f .009s p11jopt simple 153e4c251d6 .255s p12slf4j 335cfd6bdba .864s p13jasmine 1808d9121ab .401s p14square wire 1813cad6d0c .188s p15la4j 4377bd10910 .741s p16square retrofit 3354f3798e6 .206s p17apache pdfbox 3017ffff962 .464s figure statistics of projects used in our experiments from a test class depends on a changed file ekstazi selects the entire test class with all of its tests.
to measure test quality we use covered statements and killed mutants as the requirements that the tests must satisfy.
we use the mutation testing tool pit to map each test from the full test suite to the statements covered and killed mutants.
due to the high cost of mutation testing we donotmapthisfor everycommit butonlyevery30commits starting from the starting commit specified in figure .
at every commit where we record the satisfied requirements we also perform test suite reduction to generate a reduced tes t suite at that commit.
we constructed the reduced test suite by applying the greedy algorithm on the statements covered.
from each reduced test suite we then create an evolved reduced test suite in each subsequent commit to perform this evolution we use the procedure described in section .
.
.
rq1 comparing number of tests to run to answer rq1 and rq3 we measure how many tests would be chosen to run by test suite reduction and regression test selection and their combination across the rang e of commits for each project.
to visualize how the number of tests changes from commit to commit we show the number as a line plot.
figure shows these plots for three projects commons lang jodatime and la4j.
in each plot the lines show the numberof tests chosen to runby the different approaches at each commit.
the greentsline at the top represents the total number of tests for each commit the redtsline in the middle represents the number of tests in the evolved reduced test suite where test suite reduction is applied at the starting sha specified in the caption the bluetsline with bigger zig zags represents the number of tests selected by regression test selection and t he orangetsline with smaller zig zags represents the number of tests selected by regression test selection from the evolved reduced test suite.
we use these three projects because they show interesting varying behaviors.
for commons lang regression test selection is relatively small and for most commits the number of tests selected by regression test selection is smalle rthan the number of tests in the evolved reduced test suite.
however for jodatime we see many commits throughout the history where regression test selection would have selected many more tests than the evolved reduced test suite.
commons lang and jodatime are both rather mature and the growth of the test suite seems relatively small and stable i.e.
the number of tests in the full test suite does not change substantially across the commits.
in contrast for la4j the test suite changes greatly as the software evolves.
because of that we show two plots for la4j which also highlight how we apply test suite reduction at various points in our evaluation.
in figure 3c we apply test suite reduction on the starting sha and evolve the reduced test suite across the entire range of commits used in the evaluation.
in figure 3d we apply test suite reduction on a later sha and evolve it until the end of the range.
in both cases we see that regression test selection frequently selects more tests than the evolved reduced test suite.
we also see that reapplying test suite reduction on a later commit reduces the number of tests chosen to run by test suite reduction.
for example from the starting point showninfigure 3d the241st commit from thestartingsha we evaluate on the evolved reduced test suite in figure 3c had grown to tests whereas rerunning test suite reduction at that point creates a smaller reduced test suite that now has tests.
we do not show detailed plots for the other projects and starting points because they are similar in shape to the four plots shown and would take a lot of space we instead summarize their results.
for each project and each starting point we collect for each commit the ratio of the number of tests chosen to run by each approach over the number of tests in the full test suite in that commit.
figure 4a shows the distribution of these ratios as violin plots.
for each project we show three violin plots one for each approach the redts leftmost for the evolved reduced test suite the bluets middle for the tests selected by regression test selection andtheorangets rightmost for thetests selected by regression test selection on the evolved reduce d test suite.
each violin plot shows the minimum median horizontal line mean black dot and maximum values commits050010001500200025003000number of tests to run a commons lang reduced starting from 9ad1a4df0 commits050010001500200025003000350040004500number of tests to run b jodatime reduced starting from commits0100200300400500600700800900number of tests to runtotal tests regression test selection test suite reduction combined c la4j reduced starting from 7bd109100 commits0100200300400500600700800900number of tests to run d la4j reduced starting from c8e61571 figure tests chosen to run across multiple commits for s elect projects and the width of the plot depends on the number of points for each value.
we find that across the range of commits we evaluated for each project regression test selection would have on average run fewer tests than test suite reduction .
as expected the number of tests selected by combining the two approaches is even smaller than the number of tests chosento run by either approach.
in particular the median ratio of tests for evolved reduced test suite is higher than the median ratio of tests for regression test selection for all pro jects but three la4j messagepack and sql parser .
in other words the difference in the median ratio of tests for evolved reducedtestsuiteandthemedianratiooftestsfor regressi on test selection is positive for all projects but three.
the me an of these differences shows that the evolved reduced test suit e size is .15pp1higher than the number of tests selected by regression test selection.
however we note that the number of tests selected by regression test selection across th e commits has a much wider distribution than test suite reduction i.e.
one cannot easily predict the number of tests when using regression test selection.
we also note that regression test selection relatively often selects no tests because no relevant change was made 1the pp percentage point unit shows the difference between two percentages by subtracting one from the other.between commits that would affect any of the tests .
the average values for regression test selection could be skewe d by these zero cases and in theory a developer may realize that no relevant change is made and could manually choose to not run any tests even from a reduced test suite.
to explore this further we plot in figure 4b the number of tests selected by regression test selection only for the com mits when a non zero number of tests is selected.
we find that there are now four projects jopt simple in addition to la4j messagepack and sql parser where regression test selection on average selects more tests than the evolve d reduced test suite.
also the median evolved reduced test suite size is now on average only .61pp higher than the median number of tests selected by regression test selectio n across all projects.
finally utilizingthewilcoxonsignedranktesttocompare the distributions of the numbers of tests chosen to run by test suite reduction and regression test selection yields pvalues significant at an level of .
indicating that there is a high probability that the two distributions differ.
rq1 in sum for both scenarios with and without zero cases regression test selection selects to run on average fewer tests than the evolved reduced test suite.
242p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 project020406080100size reduction all selection allselection of reduction all a sizes for all commits including zeroes for selection p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 project020406080100size reduction all selection allselection of reduction all b sizes for commits where selection was not zero figure violin plots showing distribution of sizes for red uction selection and selection of reduction thisisasurprisingresult becauseregression testselect ion aims to be safe and selects all tests that could be affected by the changes and potentially selects many more tests given thecoarse imprecise level of files atwhich ekstazi operate s whereas test suite reduction is unsafe and could miss some test that is affected by the changes.
.
rq2 comparing quality of tests toevaluatehowmuchtest suitereductioncouldmiss and to answer rq2 we measure the quality of the chosen to run tests using two kinds of requirements statement coverage and killed mutants tocompute crr definition2 and the quality loss definition .
we evaluate the quality loss at each point where we collected the mapping from the tests to the satisfied requirements by default every commits.
for cases where regression test selection did not select any tes ts e.g.
betweencommits 29and30 wewentbackonecommit at atime to28 andsoon andaddedinall testsselected byregression testselection duetothechanges inearlier co mmits until the selected tests satisfy non zero requirement s. going back simulates havinghada bigger change i.e.
in the git terminology as if the developers squashed several commits because the tests selected by regression test select ion reflect the changes between a wider range of commits.
before we summarize the results for quality loss across all of the projects and various commit points we show more detailed results for one project.
figure shows for la4j how the change related statement coverage and killed mutants of evolved reduced test suites compare to the corresponding metrics for the test suites selected by regression test selection as measured using crr.
each column shows for the specified commit every commits from the beginning the percentage of change related statements covere d figure 5a or killed mutants figure 5b that are missed byv1v2v3v4v5v6v7v8 v01.
.
.
.
.
.
.
.
v1 .
.
.
.
.
.
.
v2 .
.
.
.
.
.
v3 .
.
.
.
.
v4 .
.
.
.
v5 .
.
.
v6 .
.
v7 .
a loss in change related statement coverage v1v2v3v4v5v6v7v8 v03.
.
.
.
.
.
.
.
v1 .
.
.
.
.
.
.
v2 .
.
.
.
.
.
v3 .
.
.
.
.
v4 .
.
.
.
v5 .
.
.
v6 .
.
v7 .
b loss in change related killed mutants figure change related loss in quality of evolved reduced test suite with reduced test suite constructed at vi iis row and evaluated at vj jis column for la4j distance between row column is about commits.
the evolved reduced test suite for that commit.
each row represents the evaluation of an evolved reduced test suite starting from a different commit the first row is for the evolved reduced test suite computed at the starting sha and each subsequent row starts from a later commit typically commits later .
we note that for la4j for the most part there is a very small loss in change related kille d mutants of the evolved reduced test suite although there are several points where the loss in killed mutants is higher going up to .
.
243p1 p2 p3p4p5 p6 p7p8 p9 p10 p11 p12 p13p14p15 p16 p17 project0246810statement coverage loss in changed loss in all a statement coverage p1 p2 p3p4p5 p6 p7p8 p9 p10 p11 p12 p13p14p15 p16 p17 project05101520killed mutants loss in changed loss in all b killed mutants figure violin plots showing distribution of loss in quality due to reduction for different projects we do not show detailed tables for the other projects and starting points but we instead summarize their results.
fi gures 6a and 6b show for each project a lavenderts leftmost violin plot representing the distribution of the loss in crr of both statement coverage and killed mutants respectively.
to contrast crr we also show for each project a magentats rightmost violin plot for the traditional metric of loss for the evolved reduced test suite where the loss is measured with respect to allrequirements satisfied by the full test suite req o req r req o .
we see that the change related loss in statement coverage typically has low absolute values with the median for a project being at most .
for jopt simple .
the values for the traditional metric are also fairly similar but reca ll that change related loss is the metric that matters for evol ving code.
in contrast the loss in killed mutants has higher absolute values across all projects with the median value o f loss being as high as .
for jopt simple these higher values mean that after applying test suite reduction the resulting evolved reduced test suite at each commit could miss detecting many change related faults.
this is the peri l of usingtest suitereduction.
comparedtothefull testsui te test suite reduction makes the test suite smaller but can miss some faults that the full test suite can find.
this was well understoodfrom previousstudies that considered all faults but we focus on change related faults and compare with regression test selection.
rq2 test suite reduction can miss on median up to .
change related statements and .
changerelated mutants that regression test selection finds while safe regression test selection cannot miss any changerelated fault that the full test suite can find.
.
rq3 evaluating selection of reduction despite the peril of test suite reduction test engineers may still use it to speed up regression testing one can then apply regression test selection on the reduced test suite to speed up regression testing even more.
to answer rq3 we evaluate how effective the combined selection of reduction i s compared to individual test suite reduction and regressio n test selection.
as a comparison metric we use the number of tests that selection of reduction selects to run at eachcommit for a project.
note that we do not need to empirically evaluate the loss in change related fault detec tion capability of selection of reduction because selection of reduction selects from the reduced test suite all the tests tha t are affected by the changes assuming a safe regression test selection the change related loss of selection of reducti on is the same as the change related loss of test suite reduction .
figure shows the violin plots for the number of tests selected by selection of reduction making it easy to compare the numbers for the combined approach to the two individual approaches.
the distribution across all projects shows that as expected selection of reduction always selects fe wer tests to run than any of the other two approaches.
however as selection of reduction performs selection on top of the reduced test suite it is not known a priori how the ratio of tests selected by regression test selection from the f ull test suite compares to the ratio of tests selected by selecti on of reduction from the reduced test suite.
figure 7a shows the distributions of these two ratios as violin plots for eac h project.
as regression test selection often selects no test s figure 7b plots only the non zero numbers of tests selected by both regression test selection and selection of reductio n. utilizing the wilcoxon signed rank test to compare the ratios of tests selected from the full test suite to the ratio of tests selected from the reduced test suite yields p value s significant at the level of .
for all projects except clou dfoundry uaa with a p value of .
and square retrofit with a p value of .
.
with the exception of square retrofit there is a high probability that the distributions of the ratio of tests selected by regression test selection fro m the full test suite and from the reduced test suite differ.
note however that the mean taken over all projects pairwise difference between the ratios of the two distributions is only .72pp.
therefore although the wilcoxon statistical test establishes a high probability that the distr ibutions of these ratios differ for each project except square retrofit their medians do not differ greatly.
rq3 selection of reduction selects fewer tests than either test suite reduction or regression test selection and the ratio of tests that selection of reduction selects from the evolved reduced test suite is about the same as the ratio of tests that regression test selection selects from the full test suite.
.
threats to validity external our conclusions may not generalize beyond the projects and revisions we evaluated.
to mitigate this issue we chose actively developed projects from github varying in size number of tests length of history and appl ication domain.
many of these projects were also previously used to study the effects of software evolution on test suite reduction .
internal we automated the process of recording what tests are selected by the ekstazi tool at each commit in each project used in our evaluation.
we also implemented the greedy algorithm to perform test suite reduction.
we increased the confidence in our code through many small experiments and peer code review.
construct we define a new metric crr to measure change related quality of a reduced test suite.
to determine the change related requirements to be satisfied we ef244p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 project020406080100size selection all selection of reduction reduction a ratios for all commits including zeroes for selection p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 project020406080100size selection all selection of reduction reduction b ratios for commits where selection was not zero figure violin plots showing selection all and selection of reduction reduction fectively assume thatregression test selection is notonly safe but also relatively precise.
we need regression test select ion to be safe to get all of the change related requirements and to be precise to help filter out the requirements not affected by change but accidentally satisfied by the tests selected by regression test selection.
if regression test selection se lects tests that are not affected by the changes in the extreme selecting all tests then we cannot filter out the accidenta lly satisfied requirements.
the regression test selection tool we use ekstazi tracks dependencies at the level of files including classes for cod e and is fairly safe with respect to code changes .
while ekstazi is not as precise as tools that track finer grained dependenciesthanfiles ekstazi is safer thanthosetoo ls and safety is more important to properly determine which requirements are change related.
also ekstazi is publicl y available .
ekstazi collects dependencies at the level o f test classes not test methods if a single test method is affected by a change its entire test class is selected to be run.
in contrast our test suite reduction is at the level of individual tests which allows removing each test based on the requirements it satisfies.
hence there is adiscrepancy in the level of the chosen to run tests for the two approaches.
using ekstazi our results for regression test selection ma y select more tests than actually necessary so our compariso n of test suite sizes for test suite reduction and regressio n test selection overestimates the sizes for regression test sele ction.
therefore one of our key findings that the size of selected test suites is on average smaller than the size of reduced test suite could be even stronger.
we evolved a reduced test suite across many commits using a particular procedure section .
to simulate how a test engineer who used a reduced test suite in lieu of the fulltest suite may have evolved the reduced test suite in future commits.
this simulation allows a comparison to regression test selection which directly considers changes inc luding those that modify the test suite adding or removing tests.
specifically our procedure for evolving the reduced test suite considers all changes made to the full test suite and adds all new tests.
however had the developer actually performed test suite reduction the reduced test suite cou ld have evolved differently than the way we simulated it.
furthermore we track tests between revisions by name only so if a test is renamed that test would be considered a newly added test.
not handling renames can affect the results if a test that was originally considered redundant and therefore excluded from the reduced test suite was renamed in a subsequent revision that test would be considered a new test and re added to the reduced test suite possibly intr oducing the same redundancy back in.
.
discussion change related requirements automatically evaluating the fault detection capability of test suites with respect to software changes is challenging.
we define crr definition by contrasting the requirements satisfied by tests selected byregression test selection totherequirem ents satisfied by tests not selected.
while this definition is not ideal it is better than some alternatives.
for example we could have considered only the requirements directly in the changed code e.g.
finding changed lines between two revisions and inserting mutants only on those lines.
however that would favor regression test selection over test suite reduction and miss some requirements that are affected by the changed code but not directly in the changed code.
if a fault is in some unchanged part of code it is possible that a change elsewhere in the code could trigger the detection of 245this fault.
for instance consider a fault that is control de pendent on some branch condition and a code change that affects the branch condition.
if we ignore whether a test suite can find this fault we could incorrectly label two test suites as equally good even when one finds this fault and the other does not find it.
future work should seek a better research methodology to evaluate quality of test suites wit h respect to changes.
reduction of selection for research evaluation purposes one could consider performing test suite reduction on test suites selected byregression test selection andthis combined approach called reduction of selection could yield different results than selection of reduction.
however reduction of selection is impractical for speeding up regress ion testing because performing precise reduction requires first runningall thetestsonthecurrentrevision toconstructar equirementsmatrixusedtodetermineredundanttests.
thus one could only determine which tests not to run after actually running those tests.
an alternative could be to use a stale requirements matrix computed on some previous revision to reduce the selected test suite but this requirement s matrixwouldbeimprecisefor thecurrentrevisionandwould become more imprecise as some tests would not be run due to the reduction.
moreover new requirements could have been introduced due to a change and reduction on a stale matrix being unaware of these new requirements cannot guarantee that the test suite reduced from the selected test suite would satisfy all the requirements which goes agains t the purpose of precise test suite reduction.
future work could evaluate such imprecise test suite reduction and com pare it with unsafe regression test selection.
.
related work there is a large body of work on test suite reduction and regression test selection but to the best of our knowledge there was no prior work on comparing and combining those two approaches for code.
korel et al.
propose a technique that combines test suite reduction and regressi on test selection which is similar to reduction of selecti on but differs from our selection of reduction and operates on models specifically extended finite state machines efsms unlike our combination that operates on real code and tests.
given two efsms their technique first computes a set of elementary changes then uses a static dependence analysis to find which test covers what changes and finally selects to run only tests that are non redundantwith respec t to the changes.
in contrast our evaluation does not assume any static analysis and measures the change related loss in quality for the reduced test suite.
there are also studies of the effects of software evolution on test information.
elbaum et al.
studied the effects on test coverage and found that coverage information changed greatly even for small software changes.
we recently studie d the effects of software evolution on test suite reduction .
we conducted experiments on open source projects and measured the quality of the constructed reduced test suite across multiple commits.
we found that the quality of the reduced test suite does not drop much as software evolves comparing the reduced test suite to the full test suite using requirements of the entire software.
the current study focuses on measuring the test quality using change related requirements and we find that the reduced test suite can suffer some greater loss in quality.there is prior work on combining various regression testing approaches.
for example zhang et al.
combined test suite prioritization and test suite reduction for mu tation testing.
we are the first to combine test suite reductio n and regression test selection.
there is also other work on speedingupregression testing e.g.
using history of test runs to perform unsafe test selec tion on large industrial codebases.
most recently herzig et al.
proposed a technique that selects tests based on historical data about test results.
their technique balanc es the cost of running a test many times in certain development branches versus running the test just once before release at the risk of it revealing a fault that requires much more time to debug.
their simulation of the technique on microsoft products found a reduction of of test executions.
elbaum et al.
combine unsafe test selection in the pre commit stage with test prioritization in the postcommit stage and evaluate their technique at google.
yoo et al.
propose a related technique using multi objecti ve sampling based on coverage cost and fault history an d also evaluate their techniqueat google.
we evaluate our approaches onsmall open sourceprojects butexpectthatsome of the key findings would carry over to large codebases.
.
conclusions this paper is thefirst toempirically compare and combine test suite reduction and regression test selection two ap proaches that can speed up regression testing but were evaluated only separately.
we propose a new criterion changerelated requirements to evaluate the quality of running a set of tests with respect to the changes made in software.
we also use test suite size to evaluate chosen to run tests .
our results on open source projects show three interesting conclusions.
first regression test selection on avera ge selectsfewertests than test suite reduction.
second testsuite reduction can lose change related fault detection c apability of up to .
for killed mutants while safe regression test selection has no loss.
third our proposed s electionofreductionapproachprovidesthegreatest speed up though with the same loss in change related fault detectio n capability as the reduced test suite and has about the same selection ratio from the reduced test suite as regression te st selection has from the full test suite.
in summary our results show that if only one approach must be chosen either test suite reduction or regression t est selection to speed up regression testing the test enginee r should choose regression test selection as it selects fewe r tests andpreserves change related fault detection capab ility where the faults are most likely to appear.
if there is a need to speed up testing even further then combining both testsuite reduction and regression test selection is a worthwhi le approach that provides even greater savings in the number of tests as long as one is willing to tolerate the possible los s in fault detection capability for some changes in software .
.