divide and conquer approach for multi phase statistical migration for source code anh tuan nguyen electrical and computer engineering dept.
iowa state university email anhnt iastate.edutung thanh nguyen computer science department utah state university email tung.nguyen usu.edutien n. nguyen electrical and computer engineering dept.
iowa state university email tien iastate.edu abstract prior research shows that directly applying phrasebased smt on lexical tokens to migrate java to c produces much semantically incorrect code.
a key limitation is the use of sequences in phrase based smt to model and translate sourcecode with well formed structures.
we propose mppsmt a divideand conquer technique to address that with novel training and mi gration algorithms using phrase based smt in three phases.
first mppsmt treats a program as a sequence of syntactic units andmaps translates such sequences in two languages to one another.second with a syntax directed fashion it deals with the tokens within syntactic units by encoding them with semantic symbols to represent their data and token types.
this encoding via semanticsymbols helps better migration of api usages.
third the lexicaltokens corresponding to each sememe are mapped or migrated.
the resulting sequences of tokens are merged together to form the final migrated code.
such divide and conquer and syntax direction strategies enable phrase based smt to adapt well tosyntactical structures in source code thus improving migrationaccuracy.
our empirical evaluation on several real world systemsshows that .
.
and of the migrated methods aresyntactically and semantically correct respectively.
.
.
of total migrated methods are exactly matched to the humanwritten c code in the oracle.
compared to java2csharp a rulebased migration tool it achieves higher semantic accuracy from6.
.
relatively.
importantly it does not require manuallabeling for training data or manual definition of rules.
i. i ntroduction software could be originally developed in a language and then migrated to another for different platform.
nowadays there is an increasing need for migrating source code from one programming language to another since the same software needs to exist in multiple platforms and environments.
aiming to reduce manual migration effort we have investigated the use of statistical approaches.
in a prior work we foundthat programming idioms can be captured by statistical language model .
that motivated us to explore statistical machine translation smt .
smt is a machine translation paradigm where translations are generated on the basis of statistical models whose parameters are derived from the analysis of acorpus in two respective languages .
smt is successful in automatic translation among several natural languages.
for example google translate and microsoft translator are smt based and support more than natural languages.
in our prior study we have directly applied the phrasebased smt model on the lexemes of source code to migrate java code to c .
a method is considered as a sentence and each code token produced by a java or c lexer is viewed asa word.
the result from that model is quite textually similar tothe correct code only .
.
of the total number of tokensin the resulting code are incorrect .
however a low percentage .
.
of all resulting methods is syntactically correct and that of semantically correct ones is even lower .
.
examining the results we found that one of the key reasons is a mismatch in which phrase based smt uses phrases to migrate source code with well defined syntactic structures.
sucha model defines a fixed size of phrases that are used in trainingand translation.
however there are often syntactic structures in aprogram containing longer sequences of lexical tokens.
in thosecases the model migrates the phrases that do not align well withsuch structures and often produces syntactically incorrect code because the migrated code tokens in one structure are placed in another structure.
that is it does not distinguish tokens of different syntactic units.
we experimented with increasing the size limit for the phrases used in the model.
the accuracy did not improve since it still did not capture the tokens withinsyntactic structures with larger sizes.
the training time cost becomes prohibitively high when the limit reaches tokens.
our research question is centered on whether we could still use phrase based smt on syntactic features of source code in addition to lexical tokens to adapt it to the structures in source code.
in this work we present multi phase phrase based smt mppsmt a divide and conquer technique to address the above challenge.
our idea is to take advantage of well formed syntactic units to divide and conquer in training migration in asyntax directed fashion.
it is similar in spirit to syntax directed editing to improve syntactic correctness in editors.
mppsmt operates on the sequences of syntactic units first and then on the tokens within those units.
to support that we develop multi phase training and migration algorithms each of which uses phrase based smt in three phases to accommodate the hierachical structures in source code as follows.
in the first phase instead of treating code as a sequence of lexical tokens mppsmt extracts from the source code the syntactic units and considers a program as a sequence of syntactic structures produced by a depth first traversal over the program s abstract syntax tree ast .
each syntactic structure is represented by a syntactic symbol called syntaxeme.f o r example for the code fragment if sc.hasnext c sc.next w e produce the syntaxeme sequence if op methcall cp expr eq methcall .
for training phrase based smt is used to learn the alignment between the sequences of syntaxemes in javaand c .
that is mppsmt statistically learns the migration rules for syntactic units in two languages.
for example a java 30th ieee acm international conference on automated software engineering .
ieee constructor declaration is modeled as a sequence of syntaxemes asmod method name paramlist supercall .
the respective syntaxeme sequence in c ismod method name paramlist basecall .
phrase based smt is used to align sub sequences to sub sequences.
in the above sequences the call to superclass inside the method s body in java will be mapped to the basecall in the method s declaration in c .
in the second phase the lexical tokens within each syntactic structure in java i.e.
corresponding to each syntaxeme and thetokens in their respective structure in c are processed.
instead of directly applying smt on those tokens we annotate each lexical token with its token type and data type.
for example in sc.hasnext the variable scis encoded by the sequence var since it is a variable of the type scanner .
those type annotations are called sememes.
for the method call hasnext we have call i.e.
its class name its name number of parameters list of parameters and the return type .
with explicit data types encoded in sememes smt is used to learn the alignments between the apis intwo languages e.g.
system.err.println in java is mapped to console.error.writeline in c .
the explicit encoding of token types helps in migrating from one token type to another e.g.
a method call in java to a field access in c .
finally in the third phase the lexical tokens within each of corresponding sememes in the source and target code are aligned by phrasebased smt.
moreover for the syntactic structures with deep hierarchical structures and many lexical tokens e.g.
an inner anonymous class mppsmt creates special syntaxemes called placeholders translates them independently and later merges the sub results into the final result.
for migration the same three phases are applied the sequences of syntaxemes are migrated first the sememes within each syntaxeme are handled next and finally the lexical tokens within each sememe are processed.
in mppsmt source code is modeled with three types of sequences lexeme sequences for lexical tokens syntaxeme sequences for syntactic units and sememe sequences for semantic units.
each of the training and migration processes has three phases in those three types of sequences.
with those three phases in training migration and the divide and conquer strategybased on syntactic units mppsmt uses phrase based smt three times to adapt to well formed structures in source code.
we conducted several experiments on nine real world opensource projects to evaluate its accuracy.
our result shows that mppsmt achieves much higher migration accuracy than phrase based smt syntactically .
.
higher and semantically .
.
higher .
for our current mppsmt .
.
and of the total translated methods are syntactically and semantically correct respectively .
.
.
of translated methods are exactly matched to the c code written by the developers of the subject projects in the oracle.
compared to java2csharp a rule based migration tool it achieves higher semantic accuracy from .
.
.
relatively higher .
we found that mppsmt can automatically learn many api usage mappings and java to c syntactic semantic migration rules.
importantly it does not require manually defining of those mappings rules as in java2csharp and manual labeling of respective methods.
moreover the training data of respective methods can be easily and automatically built from several open source projects with available corresponding versions.
in brief the key contributions in this paper includetokenizerdecoder translator source language texttarget language text t argmax p t s language model p t translation model p s t fig.
phrase based statistical machine translation smt .
a divide and conquer technique that makes phrase based smt work for source code with hierarchical structures .
an empirical evaluation to show that the new model is efficient and accurate in java to c code migration.
ii.
b ackground on phrase based smt phrase based statistical machine translation smt is an approach that uses statistical learning to derive the translation rules from a training data called a corpus and applies the trained model to translate a sequence from the source language ls to the target one l t .
figure displays the overview of phrase based smt.
the text in the source language lsis broken into words via the module t okenizer module .
the sequence s of those words is the input of the decoder module which plays the role of translation decoding module .
it searches for the most relevant sequence tin the target language for s. to do that it relies on two models the language model module which learns from the corpus the feasible sequences in the target language lt and the translation model module which learns from the training data the alignment between the words sequences in two languages.
both translation and language models need to be trained on the corpus and are then used by decoder for translation.
formally smt translates a sequence sin the source language lsinto a sequence tinltby searching for the sequence tthat has the maximum probability p t s p t .p s t p s since sis given p s is fixed for all potential sequences t. smt translates sby searching for the sequence tthat maximizes p t .p s t .
the language model of lt module is used to compute p t i.e.
how likely sequence toccurs in lt. the translation model module computes the likelihood p s t of the mapping pairs from ttos.
ibm model is a popular approach to compute the probability p s t for all the pairs of sequences s lsand t lt in the corpus.
it operates on the alignment of individual words.
given two sequences s s1s2...smand t t1t2...tl ibm model computes p s t .
unlike ibm model phrase based smt is a model operating on phrases i.e.
sequences of words.i t extends the word based smt model such as ibm model by expanding the surrounding words of the aligned words to get phrase based alignment.
the training process has the followingsteps the model adds the pairs of words that were aligned bythe word based alignment model into a phrase translation table which contains the mappings of the phrases with different sizes in two languages with their mapping translation probabilities it collects all phrase pairs that are consistent with the word alignment i.e.
the phrase alignment must contain all alignments java code public clientqueryresult t ransaction ta intinitialsize super ta initialsize correct c code public clientqueryresult t ransaction ta intinitialsize base ta initialsize incorrectly t ranslated by lpsmt public clientqueryresult t ransaction ta intinitialsize base ta initialsize fig.
call to constructor super ... of parent class for all covered words and include at least one word alignment pair and it iterates over all target phrases to find the ones closest to source phrases and then add those pairs and translation probabilities to the table.
details are in .
the decoder module uses the learned phrase translation table as well as the trained language model for the target language.
it processes the source sentence sfrom left to right.
it considers breaking sinto multiple phrases in all potential ways and searches them in the phrase translation table.
with multiple ways of phrase breaking and each phrase might have multiple aligned phrases in the table there are always multiple candidate sentences in the target language.
a probability is given to each candidate sentence tin the target language based on the probabilities of the aligned phrases in the sentence according to the phrase translation table the number of translated words ins as well as the probability p t of the sentence taccording to the language model.
the probability for a candidate sentenceis gradually computed in the translation decoding process.
the sentence with the highest probability is presented.
iii.
m otiv a ting examples in our prior model lpsmt we have applied directly the phrase based smt called phrasal to migrate java code to c .
many of the resulting methods are incorrect since the model treats source code as sequences of texts.
let us explain afew examples in our prior study to motivate our new approach.
example .
call to parent class constructor super ... .
figure shows an example in db4o as lpsmt translates a call to the constructor of a parent class via super line .
in java a call to super is made inside the method s body.
in contrast in c a call to the constructor is made via base and occurs in the method signature i.e.
prior to the method s body as in base ta initialsize line .
in the result this call was broken into two pieces one in the method signature base ta and one in the method s body initialsize line due to incorrect alignment.
thus the translation code is syntactically incorrect.
in this case lpsmt translates based on the lexeme sequence of the methodsignature and its body however does not consider and translate the call to the superclass super ta initialsize as a whole.
we can see that considering syntactical structures in the translation process would help.
syntactic structures could be translated as the entire units and play the roles of the placeholders for a later translation phase for the code within each placeholder.
example .
semantic error.
figure shows another example indb4o .
at line the parameter type was incorrectly translated by lpsmt to doublehandlerupdatet estcase.itemarrays instead of the correct type inthandlerupdatet estcase.itemarrays .
this is due to itemarrays being aligned by lpsmt with different sequences in different situations in the corpus e.g.
inthandlerupdatet estcase.itemarrays doublehandlerupdatet estcase.itemarrays .
java code private void createt ypedprimitivearray itemarrays item item.
typedprimitivearray new int system.arraycopy data item.
typedprimitivearray ... correct c code private void createt ypedprimitivearray inthandlerupdatet estcase.
itemarrays item item.
typedprimitivearray new int system.array.copy data item.
typedprimitivearray ... incorrectly t ranslated by lpsmt private void createt ypedprimitivearray doublehandlerupdatet estcase.
itemarrays item item.
typedprimitivearray new int system.array.copy data item.
typedprimitivearray ... fig.
semantic error incorrect type the type was incorrectly chosen by lpsmt.
however if type information was considered at the first statement it would know that item.
typedprimitivearray is an array of int t h u s inthandlerupdatet estcase.itemarrays should be used.
example .
long phrases.
in the dumpkeys method of bt reeassert class in db4o figure the second argument of the method call line is an instantiation of an anonymous class tree.traversekeys trans new visitor4 ... .
the phrase based smt with limited phrase sizes did not align correctly such a long sequence in the second argument because it breaks the sequence into sub sequences and places tokens in one syntactic structureinto a different one as in example .
that leads to the incorrect result.
increasing the maximum phrases sizes might degrade performance and alignment accuracy as well.
if the entire sequence new visitor4... is viewed as an instantiation the model could align translate an instantiation in java which is then broken further into smaller structures for alignment migration.
iv .
m apping of sequences of synt actic units we present multi phase phrase based smt mppsmt a divide and conquer technique to address the above challenges.
the idea is that we take advantage of the syntactic units to break source code into shorter sequences and run each of training and migration processes in multiple phases.
this section explains how we encode the syntactic structures in a program and how we use smt to learn the mappings of syntactic structures.
instead of treating source code as a sequence of lexical tokens we encode a source file with a sequence of special syntactic symbols called syntaxemes .
we adopt this concept from our prior work on language model.
syntaxemes are the basic units of syntax that represent the symbols on the right hand side of the grammar rules for a language.
that is syntaxemes represent syntactic units in a program.
for example for thecode while i if i j i i we produce the syntaxeme sequence while op expr cp if op expr cp expr eq expr sc.
the symbols expr s represent the expressions.
the other symbols are for the keywords while if parentheses the sign and the semicolon.
for each syntaxeme we will handle the lexical tokens corresponding with it in a later phase.
we parse the code into a parse tree traverse it to collect the syntaxemes for syntactic units and ensemble them to create the final syntaxeme sequence.
we choose to stop at the coarsegrained syntactic structures for efficiency thus we do notgo further to the content of an expression.
for example the expressions i i j etc.
are encoded only with expr s. 587t able i examples of java syntax and function encode to produce a sequence of syntaxemes for java code stmt decl java syntax building corresponding syntaxeme sequence methoddecl modifiers type name paramlist throwdecl block mod type id op encode paramlist cp throwdecl encode block constructordecl modifiers name paramlist throwdecl block mod id op encode paramlist cp throwdecl encode block paramlist param p aram comma p aram or statementlist statement encode statement block statementlist ob encode statementlist cb if if expression statement if op expr cp encode statement for for forinit expression forupdate statement for op init sc expr sc upda te cp encode statement while while expression statement while op expr cp encode statement switch switch expression casesection switch op expr cp ob encode casesection cb casesection case expression statementlist case expr c encode statementlist expression statementexpression expr sc v ariabledecl type identifier expression identifier expression type id eq expr comma id eq expr sc typedecl modifier class identifier body mod class id encode body thiscall this this op cp sc supercall super super op cp sc t able ii examples of c syntax and function encode to produce a sequence of syntaxemes for c code stmt decl c syntax building corresponding syntaxeme sequence methoddecl attributes modifiers type name params block a tt mod type id op p ara cp encode block contructordecl attributes modifiers name params thiscall basecall block a tt mod id op p ara cp encode thiscall encode basecall encode block paramlist param p aram comma p aram or statementlist statement encode statement block statementlist ob encode statementlist cb if if expression statement if op expr cp encode statement for for forinit expression forupdate statement for op init sc expr sc upda te cp encode statement while while expression statement while op expr cp encode statement switch switch expression casesection switch op expr cp ob encode casesection cb casesection case expression statementlist case expr c encode statementlist expression statementexpression expr sc v ariabledecl type ident expression ident expression type id eq expr comma id eq expr sc classdecl attrs modifiers class ident classbase body a ttrs mod class id classbase encode body thiscall this c this op cp basecall base c base op cp to produce syntaxeme sequences we follow the encoding rules for different java syntactic units.
the important encoding rules are shown in table i others are similar .
syntaxemes are listed as capital letters on the right hand side.
note that the code is compiled thus we can always produce the parse tree.
we traverse the parse tree to find the appropriate encoding rules and then create and ensemble the sequences of syntaxemes.
all the non terminal symbols will be expanded further and syntaxemes are ensembled until we encounter expressions or no more non terminal symbols are found.
the non terminal symbols in the right hand side of table i that will be expandedare called with the encode function which is represented by all the rules in the table.
the resulting syntaxemes at each step are concatenated to create the larger and then final sequences.
for example for the java code in figure we encode that method declaration using the rules in table i mod id op encode paramlist cp ob encode supercall sc cb where the capital letters are the terminal symbols for the separators in the grammar of java.
the modifier public and the method s name clientqueryresult are represented by two syntaxemes mod and id.paramlist and supercall are expanded further via other rules.
paramlist is for the parameter list and is expanded into p aram comma p aram for t ransaction ta int initialsize .
we do not explore further a parameter since we will use sememes to represent it.
supercall is encoded into super op expr comma expr cp .
those syntaxemes are not expanded further since stop at expressions.
similarly for the c code in figure we have mod id op encode paramlist cp c encode basecall ob cb fig.
alignments of syntactic symbols are learned from corpus where crefers to the colon and basecall refers to the call to the constructor of a base class in c .
the rules to syntaxemes for c are listed in table ii.
the non terminal symbols on the right panel are different from those for java even though we use the same notations.
all the words in capital letters in the right side of a table are collected into the syntaxeme vocabulary for each language.
in the first phase of the training process the syntaxeme sequence of each method in java is mapped to the syntaxeme sequence of the corresponding method in c .
the regular phrase based smt training is used on syntaxeme sequencesfor the first phase.
the alignment of syntactic symbols are automatically learned from the corpus of corresponding meth5881public static void dumpkeys t ransaction trans bt ree tree tree.traversekeys trans new visitor4 public void visit object obj system.out.println obj ... public void ... ... ... fig.
placeholder for an anonymous class ods.
this is the key difference between our statistical approach with the deterministic rule based approaches in which users must define the mappings among syntactic structures in two languages.
in our approach the mappings are learned from the alignments of syntactic symbols.
for example in figure for the corresponding methods in java and c mppsmt uses phrase based smt to align the corresponding syntaxeme sequences.
as seen the alignment of syntaxemes enables mppsmt to recognize the mapping of supercall tobasecall and the change to their locations from the method s body in java to the method s declaration in c .
divide and conquer with placeholders.
let us revisit the example figure .
at lines the second argument of a method call is an entire class declaration which is expanded into field and method declarations etc.
smt breaks the sequence into sub sequences and misplaces tokens in a syntactic structure into a different one leading to incorrect results.
to address that we create special syntaxemes called placeholders for long expressions such as anonymous class declarations cascading and nested expressions in method calls inner classes etc.
our implementation uses the same length limit for long sequences as the underlying smt tool phrasal symbols .
each placeholder represents a long expression.
the boundary of a placeholder is marked in the syntaxeme sequence.
a placeholder is associated with a sequence of syntaxemes for its contents.
syntaxemes in placeholders are used in training as normal however during decoding placeholders are translated independently and the results are merged into the final result section vi c .
with placeholders mppsmt not only makes the phrase based smt work for hierarchical structures of expressions in code but also achieves a divide and conquerstrategy in translation since it operates on shorter sequences.
the computational complexity of the translation of a sequence will be reduced since it is exponential to the sequence s length.
v. m appings of token types and data types in the second phase the lexical tokens within each syntactic structure corresponding to each syntaxeme in java and thetokens in their respective syntaxeme in c are processed.
instead of directly applying smt on lexical tokens we annotate each lexical token with its token type and data type.
eachcode token has a role in a program according to the writtenprogramming language e.g.
whether it is a type variable literal operator keyword method call method declaration field o rclass.
for example in list.empty the variable listis encoded by the sequence var since it is a variable of linkedlist .
such sequence of data token types is called a sememe sequence.
we adopted the concept of sememe from our prior work .
the sememe of a code token at a code location is a structured annotation representing its data token types .t able iii examples of sememes token token sememe data type arraylist type v ariable fwriter v ar literal ase lit methdecl substring func p ara string methcall exists call parameter endindex p ara fieldacc modcount field operator op .
op the type information in api method calls is captured as well.
this helps mppsmt to learn the api usage mappings from sememe alignments e.g.
system.err.println in java is mapped to console.error.writeline in c .
moreover different method calls with the same lexical value in different classes will not be mapped.
this helps mppsmt to overcome a key limitation in lpsmt which works on the lexical values of such method calls and cannot distinguish those cases.
table iii shows the examples of popular types of sememes.
for example in java file.exists is a function call and its sememe consists of the symbols call its class name file its name exists no parameter the return type boolean and .
let us take an example of different styles in java and c .
a pair of method calls becomes two field accesses and an assignment current.getedge .setmarked true current.edge.marked true .
the java sememe sequence varref call call edge setmarked boolean void becomes varref field field assign lit in c .
for the example in figure for the first syntaxeme p aram we have the sememe sequence p ara .
the lexeme of this sememe is ta.
the separators e.g.
semicolons and parentheses and keywords are not associated with semantic information thus are marked with special sememe types that are the same as their syntaxemes at the syntactic level.
if semantic information is not available the lexical token is kept and annotated with the special sememe lex .
the sememe for a variable and that for a literal do not include their lexemes since they are handled at the lexical level.
vi.
t raining and transla tion a.auto labeling of respective methods to build training data in code migration building training data is the process of collecting respective pieces of code with equivalent functionality in both languages.
in theory one can label pairs of respective pieces of code in java and c to train mppsmt.
however to automatically collect a large number of respective pieces of code in this work we focus on migrating each java method toan c method thus we need to build the collection of pairs of respective methods.
to do that we first used nine open source systems which were originally developed for java and then ported to c table iv .
they are well established systems with long developing histories and both java and c versions have been in use.
the projects db4o fpml lucene and neodatis have also been used in prior research in mining migration rules .
589t able iv subject systems project java c m.meth v er file meth v er file meth antlr .
.
.
.
db4o .
.
fpml .
.
itext .
.
.
.
jgit .
.
jts .
.
lucene lc .
.
.
.
neodatis nd .
.
.9b poi .
.
.
.
columns java.ver and c .ver show the corresponding versions in two languages.
columns file and meth show the numbers of files and methods in each revision.
to collect respective methods in each pair of corresponding versions we observe that in those manually migrated projects developers keep the same similar directory structures and the same similar names for classes and methods between java and c some have slightly different names regarding casesensitivity .
thus we built a tool to conservatively search for only the methods having the same signatures in the classes withthe same similar names in the same similar directory structures in both versions.
such pairs of methods likely implement the same functionality.
because in a project the corresponding versions also include different supporting libraries and utility methods in two languages and or contain extra or less functionality there are methods in both versions that do not have the respective ones.
thus we manually verified a small randomly selected sample set to have high confidence that the methodpairs are in fact the respective ones.
one to many mappings were discarded.
in total we found respective methods column m.meth .
we used them as a training data set.
b. multi phase training algorithm the training algorithm is shown in t rainingalgo figure .
it consists of phases at the three levels syntaxemes sememes and lexemes.
at each level it provides training for both language and translation models.
the input of the training step is a collection of method pairs m each of which contains a method in java and its respective migrated method in c .
from the aligned methods mppsmt learns the alignments between sub sequences of syntaxemes sememes and lexemes.
phase .
alignment for syntactic structures via syntaxeme sequences the goal of this phase is to use phrasebased smt on the syntaxeme sequences to learn the alignments between sub sequences of syntaxemes in two languages.
first for each method pair j c m mppsmt builds the syntaxeme sequences for both methods jand cin two languages and then collects those pairs into synpairs lines .
then it uses phrase based alignment section ii to map the syntaxemesequences for each pair in synpairs line .
next it uses smt to train the translation model line for syntaxeme sequences.
the result tsyn is the phrase translation table for syntaxeme sequences in two languages.
the syntaxeme sequences in c are used to train the n gram language model lsyn for syntaxemes line .
the functions on lines are from phrase based smt.
for example in figure two syntaxeme sequences in java1function t rainingalgo t rainingmethodpairs m t raining the model for syntaxeme sequences synpairs foreach pair j c m for each pair of methods j c synpairs.add encode j encode c collect pairs of syntaxeme seqs for j c mapsyn alignsmt synpairs align syntaxemes in each pair tsyn t ranslationt rainsmt mapsyn synpairs translation model lsyn langmodelt rainsmt synpairs.
cssequences language model t raining the model for sememe sequences sempairs foreach pair j c m sempairs.add sem j sem c foreach aligned pair syn j syn c mapsyn j c sempairs.add sem syn j sem syn c mapsem alignsmt sempairs tsem t ranslationt rainsmt mapsem sempairs lsem langmodelt rainsmt sempairs.
cssequences t raining the model for lexeme sequences lexpairs foreach pair j c m lexpairs .add lex j lex c foreach aligned pair sem j sem c mapsem j c lexpairs .add lex sem j lex sem c maplex alignsmt lexpairs tlex t ranslationt rainsmt maplex lexpairs llex langmodelt rainsmt lexpairs .cssequences return t syn lsyn tsem lsem tlex llex 31function t ranslationalgo javacode j out syn j encode j smttranslate syn j tsyn lsyn foreach sequence syn c syn j align syn c syntaxeme sequence syn j is aligned to syn c pmap syn j getplaceholders syn j checking for long exprs replace code with placeholders phexprs if any replace syn j.code pmap syn j .code phexprs sem c align sem c smttranslate sem syn j tsem lsem foreach sememe sequence sem c sem j align sem c sem j is aligned to sem c lex c smttranslate lex sem j tlex llex out.add lex c translate the code in placeholders pmap syn c .code t ranslationalgo pmap syn j .code replace out phexprs pmap syn c .code merge results back return out fig.
training and translation algorithms and c are mapped using phrase based alignment in smt.
the first result of this phase tsyn includes ... super op expr comma expr cp base op expr comma expr cp cp ... each syntaxeme sequence mapping has its score not shown .
phase .
alignment for sememes within each syntaxeme the goal of the second phase is to train the model to recognize the alignment of the sememes extracted from the code within each corresponding syntaxeme phrase syntactic structures that were aligned in the first phase.
the process is the same as in the first phase except that the phrase based smt is called on sememe sequences lines .
the result is p aram p aram p aram p aram clientobject call clientobject ... phase .
alignment for lexemes within each sememe in the last phase the lexical tokens for each sememe 590phrase aligned from the previous phase is mapped.
the procedure is the same as before.
for example we will have ... c. multi phase translation algorithm our multi phase translation algorithm first translates syntaxeme sequences then translates the sememes within thosesyntaxemes and finally merges the respective sequences of lexemes in those sememes to produce the final result.
details.
the translation algorithm for a java code fragment jis at line of figure .
it first builds for ja sequence of syntaxemes syn j. then smt with the trained language model lsyn for c and the trained translation model tsyn at the syntactic level are applied on syn jto produce the translated syntaxeme sequence with highest probability consisting of multiple non overlapping sub sequences syn c and the alignment align for those syntaxeme sub sequences line .
for each of those syntaxeme sequences syn cin c it uses align syn c to find the corresponding syntaxeme sequence in java syn j line .
it then checks if syn jand corresponding lexical code contains any long expressions via getplaceholders line .
if so it will replace the long expressions in the code with special syntaxemes placeholders phexpr s line .
pmap contains the mappings between placeholders and their code.
mppsmt then builds the sememes for the resulting syntaxeme sequence syn j and translates it with smt line into the c sememe sequence with highest probability consisting of multiple non overlapping sub sequences sem c with the alignment align sem c for those sememe sub sequences .
for each of those sememe sequences sem cin c it uses align sem c to find the corresponding sememe sequence sem jin java line .
it then uses smt to translate the lexeme sequences associated with sem j line to get the lexeme sequence lex cin c and add it into the output line .
finally the code for the placeholders phexprs is translated independently line and the results are merged back to form the final result line .
example.
let us revisit our example in figure .
given the java code mppsmt first builds the syntaxeme sequence as shown in figure mod id op p aram comma p aram cp ob super op expr comma expr cp sc cb .
using the phrase translation table for syntaxemes mppsmt then translates it into the syntaxeme sequence in c as shown in figure mod id op p aram comma p aram cp colon base op expr comma expr cp ob cb .
in the second phase the lexical tokens within each syntaxeme e.g.
p aram is processed.
for example the tokens in p aram i.e.
t ransaction ta are encoded into the sememe sequence p ara .
then mppsmt uses the phrase translation table for sememe sequences to translate itinto p ara in c .
a similar process is applied for other sememes in other syntaxemes.
in the third phase the tokens for the sememes are translated using the phrasetranslation table for lexemes.
for example taand t ransaction are migrated into taand t ransaction in c .
the lexical token super is migrated into base since super is mapped to base .
vii.
e mpirical ev alua tion in our evaluation we aim to answer the following questions rq1.
how accurate is mppsmt in comparison to the lexical smt and java2csharp a rule based migration tool?rq2.
how accurate is it with cross project training data?
rq3.
how time efficient is mppsmt?
rq4.
how accurate is it in migrating changes?
we used the dataset shown in table iv.
we applied ten fold cross validation by dividing all aligned methods into ten folds with equal numbers of methods.
to test for a fold we used the remaining folds for training.
the resulting methods were compared against the respective ones in the oracle.
we used four metrics the first two measure lexical translation accuracy while the last two measure syntactic and semantic accuracy.
.bleu bleu is a popular nlp metric from to measure the translation accuracy for the phrases with various lengths.
specifically bleu bp.e1 n log p1 ... log pn where bp is the brevity penalty value which equals if the total lengthof the resulting sentences is longer than that of the reference sentences i.e.
the correct ones .
otherwise it equals to the ratio between the two lengths.
piis the metric for the overlapping between the bag of i grams repeating items are allowed appearing in the resulting sentences and that of i grams appearing in the reference sentences.
specifically if si re fand si trans are the bags of i grams appearing in the reference code and in the translated code respectively pi si re f si trans si trans .
.token edit distance ratio edr .
this metric measures effort that a user must edit in term of the code tokensthat need to be deleted added in order to transform theresulting code into the correct one.
it is computed as edr methods editdistance s r st methods length s t where editdistance s r st is the editing distance between each pair of the reference method sr and the translated method st and the denominator is the total length of all translated methods.
.syntactic correctness ratio scr .
syntactic correctness is measured by the ratio between the number of translated methods that compile over the total translated methods.
.semantic correctness ratio secr .
semantic correctness is defined as the ratio between the number of semanticallycorrect translated methods over the total translated methods.
if secr is out of translated methods are semantically correct.
to check semantic correctness we compare the program dependence graph pdg for each translated method against the pdg of the respective reference method in the oracle.
to compare the pdgs we applied the technique from .
a. accuracy and comparison our first experiment aims to measure mppsmt s accuracy and compare it with lpsmt smt running on lexical tokens and java2csharp a rule based code migration tool.
as seen in table v mppsmt achieves good translation accuracy.
.
.
and of the total numbers of translated methods are syntactically and semantically correct respectively.
among all total translated methods there are .
.
that are exactly matched to the c code written by the developers of the subject projects in the oracle table vi .
we examined the migrated results that are syntactically and semantically correct but differ from the manual migrated code in the oracle.
we found that they involve code with different local variables names from a reference method but all variables are consistently renamed code with namespaces being 591t able v accuracy comparison max min values highlighted proj.
bleu scr syntax secr semantic mpp mpp mpp j2c lpsmt smt j2c lpsmt smt j2c lpsmt smt antlr .
.
.
.
.
.
.
.
db4o .
.
.
.
.
.
.
.
fpml .
.
.
.
.
.
.
.
itext .
.
.
.
.
.
.
.
jgit .
.
.
.
.
.
.
.
jts .
.
.
.
.
.
.
.
lc .
.
.
.
.
.
.
.
nd .
.
.
.
.
.
.
.
poi .
.
.
.
.
.
.
.
t able vi results exact matched to human written c project antlr db4o fpml itext jgit jts lc nd poi j2c .
.
.
.
.
.
.
.
.
lpsmt .
.
.
.
.
.
.
.
.
mppsmt .
.
.
.
.
.
.
.
.
added deleted to from a type e.g.
new p .a vsnew a and code with this being added deleted to from a field or method.
regarding edr only .
of the total number of tokens in the resulting code are incorrect not shown .
compared to the lexical model lpsmt mppsmt improves much in both syntactic .
.
and semantic correctness .
.
.
we found that all the syntactically and semantically correct methods translated by lpsmt are also included in the correct ones translated by mppsmt.
mppsmt migrates correctly many additional methods that lpsmt did not migrate correctly.
to further learn the impact of the divide and conquerapproach via syntactic structures we added only the syntaxeme and lexeme processing into lpsmt and left the sememesout.
we found that syntactic correctness is much improved with syntaxemes from relatively from .
.
.
investigating further we found that our divide and conquer approach with syntaxemes creates syntax directed translation which helps to align translate syntactic units as their entireties.
moreover mppsmt achieves better lexeme alignments for longer phrases since the alignments of syntaxemes place correct pivots on lexeme sequences for later aligning.
compared to java2csharp despite .
.
less in syntactic correctness mppsmt has .
higher semantic accuracy than java2csharp relatively .
.
thus is more accurate.
since java2csharp has the syntactic templates for migration the resulting code is syntactically correct.
however many methods migrated by java2csharp are not semantically correct due to incorrect concrete names since rules are just templates and the lack of rules for api mappings for libraries.moreover only of the migrated methods exactly match the reference code as opposed to .
.
for mppsmt .
table vii shows some examples of api mappings and migration rules that are mined and used in translation by mppsmt.
they are not in the latest version of the data file in java2csharp.
unlike in java2csharp which requires manual rule definition mppsmt can operate well with our training data 628methods in projects that was easily and automatically built viat able vii api mappings and other migration rules java c corresponding api usages interruptedexception operationcanceledexception assertequals nunit.framework.assert.areequal result.getupdatedfiles .size result.getupdatedfiles .count xmlutility.getdefaultschemaset xmlutility.defaultschemaset .getschema .xmlschemaset.compile htmltags.ul.equalsignorecase tag util.equalsignorecase htmltags.ul tag en1.getin1 .comparetoignorecase util.comparetoignorecase en2.getin1 en1.getin1 en2.getin1 asserttrue ... msg instanceof assert.istrue msg is grammargrammarunreachablealtsmessage unreachablealtsmessage ... double.parsedouble totoken n double.parse n.innertext.trim migration rules for styles current.getedge .setmarked true current.edge.marked true tokens.put tokenid utils.
tokens integer root.getnewtokentype root.getnewtokentype copy.setfirstlineindent getfirstlineindent copy.firstlineindent firstlineindent extent.get n extent.containskey n ?
extent null compareto other.todatetime compareto other as time node nodes.elementat index nodes as xmlnode bigdecimal fraction seconds.
decimal fraction remainder bigdecimal.one seconds 1m nodeindex.getdocument .
nodeindex.document.
getdocumentelement .
documentelement.
getnamespaceuri namespaceuri eot.set s.statenumber utils.
eot integer edge.target.statenumber edge.target.statenumber t able viii accuracy with cross project training mppsmt bleu edr scr syntax secr semantic within proj .
.
.
.
cross proj .
.
.
.
auto labeling of respective methods in two respective versions.
java2csharp requires pre defined rules while mppsmt needs data.
importantly with small effort to build such training data inmppsmt we achieve relatively better semantic accuracy from .
.
than java2csharp.
moreover we found that some correct java2csharp s results were not in those of mppsmt.
the reason is that mppsmt did not see them in training data.
this is the limitation of the data oriented approach in mppsmt.
this result suggests a direction to combine two approaches.
b. cross project training and translation we used jts project in another experiment to study mppsmt s accuracy as it was trained with data across projects.
to translate for one project we used for training all the data from the other projects.
table viii shows the result.
the rows within proj and cross proj show translation accuracy as mppsmt was trained with data within jts and with data across projects respectively.
as seen the accuracy in cross project setting is slightly better due to additional training data.
c. time complexity we measured training and translation time see tables ixx on a computer with amd phenom ii x4 .0ghz 8gb ram and linux mint.
as seen training time for mppsmt is comparable to that of lpsmt from minutes for a small project fpml to minutes for a larger one jgit .
generally lpsmt took longest translation time.
mppsmt saved much of that time cost due to its divide and conquer strategy.
java2csharp s translation time is comparable to that of mppsmt and is mostly for ast operations.
592t able ix training time in minutes per project project antlr db4o fpml itext jgit jts lc nd poi lpsmt mppsmt t able x translation time in seconds per method project antlr db4o fpml itext jgit jts lc nd poi lpsmt .
.
.
.
.
.
.
.
.
mppsmt .
.
.
.
.
.
.
.
.
j2c .
.
.
.
.
.
.
.
.
d.migrating changes and updating phrase translation table as software evolves in its java version the respective c version needs to be updated accordingly.
in practice developers migrate certain important versions to c .
for example in zxing project its developers manually migrated a total of versions between the revisions and in java .
since the number of changed methods is often much smaller than the total number of methods in a project it makes sense to help developers in the synchronization process by migrating only the changed methods rather than completely re migrating.
we conducted another experiment to study mppsmt s capability of updating its internal data with new mappings when training on the newly available respective java and c code.
we chose zxing a project that has been developed originally in java and ported to c inzxing.net over time in its history .
table xi shows the locs the number of methods at the ending revisions and the corresponding starting and ending revisions in our experiment.
to detect the corresponding revisions we searched on its c commit logs for the terms such as port and migrate and then manually verified them.
there are java revisions that were not ported to c .
the changes from those revisions are accumulated into the jichange from the latest java revision that was being ported to the next ported one.
sometimes the porting for one java version lasted a few revisions in c .
we chose the last revision among them as the mapped revision of the java one but we also accumulated the changed methods in those intermediate c revisions into cjchange from the latest ported c revision to the next ported one.
in total we have mapped revisions.
we used our dataset in table iv for training.
assume that the revision jiis mapped to ciand j i toc i .
the first pair j0and c0is used for training.
we used mppsmt to migrate the changed methods in j i .
we then compared the resulting methods against the changed methods in the actual one c i from citoc i .
we have two settings in our experiment.
in the first one after migrating j i the translation table learned from the prior mapped revision was kept without updating.
in the second setting we updated it using the actual changes in c i byzxing s developers.
as seen in table xii the accuracy for migration of changes is comparable to that in regular migration.
the result with updating is slightly better than that without updating.
we found that it updated the translation table with new apis that were used in a later version and were not in the previous version.
this suggests a practice of migration after the first migration onet able xi zxing and zxing.net zxing zxing.net locs meths revs locs meths revs syn.revs t able xii accuracy with updated phrase translation table mppsmt scr syntax secr semantic bleu edr without update .
.
.
.
with update .
.
.
.
just migrates the changed methods instead of re migrating the entire project.
then after developers fix the automatic migrated code one could use the new java version and the corrected c version to update mppsmt.
with the updated translation table mppsmt translates better for the later versions.
e. web based survey we also created a web based survey and asked human subjects who are isu software engineering students and have experience in both java and c for more than years to evaluate the resulting code.
we had a total of respondents.
for training each subject was shown an example of an original java method in one subject project.
we then preselected the correct answer based on the human translatedoracle for the method and explained why it is correct a good starting point or incorrect .
correct means that this translated code can be used as is.
good starting point means that it might need reasonable amount of modifications.
incorrect means that the code is totally incorrect and useless.
next they were shown a different original java method and the corresponding translated method in c from mppsmt.
we asked them to give a rating for the result on whether it is correct incorrect or is a good starting point.
they also have an option of not sure .
each participant graded methods.
we randomly choose the methods with different sizes in subject projects.
we also asked them to provide an overall rating on whether our translated code is useful for those methods.
in total we have the ratings for translated methods and overall ratings.
the following table summarizes the responses.
correct good starting point incorrect not sure total .
.
.
agree agree no opinion disagree disagree total .
.
.
.
overall the participants found that of the translated methods are correct and of them are not correct but are good starting points.
they rated mppsmt as useful for of the translated methods.
f .
examples .
a constructor call in method signature in c .
translating legacyactivationdepth.java indb4o mppsmt correctly puts the call to a constructor this ... to the method signature in c 593public legacyactivationdepth .. this .. act...mode.activa te public legacyactivationdepth .. this .. act...mode.activate we found that mppsmt is able to learn that via its alignment of the corresponding syntaxemes in two languages.
.
type and keyword.
insimplemapcache.java inlucene project mppsmt learned the mappings between respective types set and icollection and keywords synchronized and lock public set keyset synchronized mutex return ... java public icollection keyset lock mutex return ... c .
foreach .
inbuffersubgraph.java injts project mppsmt correctly translated a forloop with iterator into a foreach in c public void findresultedges for iterator it diredgelist.iterator it.hasnext directededge de directededge it.next ... java public void findresultedges foreach directededge de in diredgelist ... c threats to validity.
our collected dataset might not be representative.
to verify semantic correctness the approach in may cause inaccuracy in our result.
we used the latest rules and mappings in java2csharp.
different rule sets and project data could have different results.
however we only want to show that our training data by auto labeling helps us get better accuracy yet was easy to build.
we chose only java2csharp for comparison since it is open source and we can access its latest library mappings.
our experiment on change synchronization was on only one project.
viii.
r ela ted work language migration.
spice translates smalltalk to c by creating runtime replacement classes realizing the same functionality of smalltalk classes.
v an duersen and kuipers proposed a method to identify objects by semi automatically restructuring legacy data structures.
this can be used inmigrating from a structural language into an oo one.
other tools use wrappers or language independent representations and deterministic rules .
mam mines api mappings via transformation graphs.
our prior work staminer used statistical learning to mine api mappings.
the resulting mappings are used to enhance the rule based migration tool java2csharp .
sudoh et al.
proposed a method that separately translates clauses in the source sentence and reconstructs the target sentence using the clause translations with non terminals.
api migration.
as software is ported to use a new library developers have to migrate their code.
to mine api migration rules aura combines call dependency and text similarity analysis to identify change rules for one replaced by many and many replaced by one methods.
hima matches each revision pair of a framework and aggregates revision level rulesto obtain framework evolution rules.
twinning allows users to specify changes that migrate a program to use new apis.
there are approaches to support adaptation to client code as libraries evolve .
semdiff mines api usage changes from client code or the library itself.
diff catchup recognizes api changes and suggests api replacements based on framework examples.
generalized transformation rules are inferred from examples .
smpl is a domain specific transformation language for a semantic change description.
statistical language models.
hindle et al.
used ngram with lexical tokens to show that source code has high repetitiveness.
han et al.
used hidden markov model to infer the next token from user provided abbreviations.
n gram is also used to find code templates relevant to current task .
ix.
l imit a tions f uture work and conclusions limitations.
first mppsmt currently supports migrating one java method to a c method with only limited semantic information.
for example in c if a method allows an overriding one in a sub class it must be declared as virtual .i n training data mppsmt cannot learn when to add virtual since it does not consider dependencies across methods.
we will expand to migrate an entire project with all classes when considering semantic dependencies among methods classes.
mppsmt cannot handle the cases where the new implementation in c has quite different logic than the java version or when a method is splitted into two.
moreover if an api is mapped to multiple apis in subclasses of a class it sometimes used an incorrect one.
this weakness was also reported by a human subject incorrect cases were ones where an interface had multiple implementations and the tool used incorrect implementation e.g.
class a instead of class b or inconsistent use of classes e.g.
the variable would be declared of class a but initialized using class b .
post processing with type information stored in sememes could help.
another issue is out of vocabulary where it has not seen tokens in a training data.
to address that besides adding more training data we will explore the combination with pre defined rules e.g.
from java2csharp.
regarding the applicability of this approach to other programming languages there are several challenges that need to be investigated further.
first several issues arise when two languages have quite different programming paradigms.
for example smt s sequence based alignment technology would face great challenges to align code between java in oop style and javascript a dynamic language in event handling style.
this requires a fundamental advance in smt.
perhaps graphbased or tree based alignment algorithms are needed.
second issues arise when languages semantics have fundamentaldifferences.
for example migrating java to c with macros and pointer manipulation and to c with multiple inheritance would need a new approach of integrating semantics into smt.
third the dynamic languages used for web programming e.g.
php js pose challenges to smt due to dynamic typing.
as part of our future work we plan to conduct usability study and to measure effort saving with mppsmt as well asto study other factors in entire migration process e.g.
when to migrate and cost .
finally we need to investigate the role of developers and automated tools in code migration.
a process to guide developers in handling complex cases is desired.
acknowledgment this work was supported in part by the us nsf grants ccf1518897 cns ccf ccf ccf1349153 twc ccf and ccli .
594references j. andersen and j. l. lawall.
generic patch inference.
in proceedings of the 23rd ieee acm international conference on automated software engineering ase pages washington dc usa .
ieee computer society.
antlr.
t. bartolomei k. czarnecki and r. la lmmel.
swing to swt and back patterns for api migration by wrapping.
in software maintenance icsm ieee international conference on pages .
ieee sept .
p .
f. brown v .
j. d. pietra s. a. d. pietra and r. l. mercer.
the mathematics of statistical machine translation parameter estimation.
comput.
linguist.
june .
d. cer m. galley d. jurafsky and c. d. manning.
phrasal atoolkit for statistical machine translation with facilities for extractionand incorporation of arbitrary model features.
in proceedings of the naacl hlt demonstration session hl t demo pages stroudsburg p a usa .
association for computational linguistics.
k. chow and d. notkin.
semi automatic update of applications in response to library changes.
in proceedings of the international conference on software maintenance icsm pages washington dc usa .
ieee computer society.
b. dagenais and m. p .
robillard.
recommending adaptive changesfor framework evolution.
in proceedings of the 30th international conference on software engineering icse pages new y ork ny usa .
acm.
db4o.
dms.
fpml.
google translate.
s. han d. r. wallace and r. c. miller.
code completion from abbreviated input.
in proceedings of the ieee acm international conference on automated software engineering ase pages washington dc usa .
ieee computer society.
a. e. hassan and r. c. holt.
a lightweight approach for migrating web frameworks.
inf.
softw.
technol.
june .
j. henkel and a. diwan.
catchup!
capturing and replaying refactorings to support api evolution.
in proceedings of the 27th international conference on software engineering icse pages new y ork ny usa .
acm.
a. hindle e. t. barr z. su m. gabel and p .
devanbu.
on the naturalness of software.
in proceedings of the 34th international conference on software engineering icse pages piscataway nj usa .
ieee press.
c. h. hsiao m. cafarella and s. narayanasamy.
using web corpus statistics for program analysis.
in proceedings of the acm international conference on object oriented programming systems languages applications oopsla pages new y ork ny usa .
acm.
itext.
java to c converter.
details java to csharp converter.html.
f. jacob and r. tairas.
code template inference using language models.
inproceedings of the 48th annual southeast regional conference a c m se pages new y ork ny usa .
acm.
java2csharp.
jgit.
microsoft java language conversion assistant.
jts.
p .
koehn.
statistical machine translation.
cambridge university press new y ork ny usa 1st edition .
p .
koehn f. j. och and d. marcu.
statistical phrase based translation.
inproceedings of the conference of the north american chapter of the association for computational linguistics on human language technology v olume naacl pages stroudsburg pa usa .
association for computational linguistics.
lucene.
c. d. manning and h. sch tze.
foundations of statistical natural language processing.
mit press cambridge ma usa .
s. meng x. wang l. zhang and h. mei.
a history based matching approach to identification of framework evolution.
in proceedings of the 34th international conference on software engineering icse pages piscataway nj usa .
ieee press.
microsoft translator.
m. mossienko.
automated cobol to java recycling.
in proceedings of the seventh european conference on software maintenance and reengineering csmr pages washington dc usa .
ieee computer society.
neodatis.
a. t. nguyen h. a. nguyen t. t. nguyen and t. n. nguyen.
statistical learning approach for mining api usage mappings for code migration.
inproceedings of the 29th acm ieee international conference on automated software engineering ase pages new y ork ny usa .
acm.
a. t. nguyen t. t. nguyen and t. n. nguyen.
lexical statistical machine translation for language migration.
in proceedings of the 9th joint meeting on f oundations of software engineering esec fse pages new y ork ny usa .
acm.
t. t. nguyen a. t. nguyen h. a. nguyen and t. n. nguyen.
a statistical semantic language model for source code.
in proceedings of the 9th joint meeting on foundations of software engineering esec fse pages new y ork ny usa .
acm.
m. nita and d. notkin.
using twinning to adapt programs to alternative apis.
in proceedings of the 32nd acm ieee international conference on software engineering v olume icse pages new y ork ny usa .
acm.
octopus.net translator.
y .
padioleau j. l. lawall and g. muller.
smpl a domain specific language for specifying collateral evolutions in linux device drivers.
electron.
notes theor .
comput.
sci.
jan. .
k. papineni s. roukos t. ward and w. j. zhu.
bleu a method for automatic evaluation of machine translation.
in proceedings of the 40th annual meeting on association for computational linguistics acl pages stroudsburg p a usa .
association for computational linguistics.
poi.
sharpen.
k. sudoh k. duh h. tsukada t. hirao and m. nagata.
divide and translate improving long distance reordering in statistical machine translation.
in proceedings of the joint fifth workshop on statistical machine translation and metricsmatr wmt pages stroudsburg p a usa .
association for computational linguistics.
w .
tansey and e. tilevich.
annotation refactoring inferring upgrade transformations for legacy applications.
in proceedings of the 23rd acm sigplan conference on object oriented programming systems languages and applications oopsla pages new y ork ny usa .
acm.
a. van deursen and t. kuipers.
identifying objects using cluster and concept analysis.
in proceedings of the 21st international conference on software engineering icse pages new y ork ny usa .
acm.
r. c. waters.
program translation via abstraction and reimplementation.
ieee trans.
softw.
eng.
aug. .
w .
wu y .
g. gu h neuc g. antoniol and m. kim.
aura a hybrid approach to identify framework evolution.
in proceedings of the 32nd acm ieee international conference on software engineering v olume icse pages new y ork ny usa .
acm.
xes.
convert javatocsharp .
z. xing and e. stroulia.
api evolution support with diff catchup.
ieee trans.
softw.
eng.
dec. .
k. y asumatsu and n. spice a system for translating smalltalk programs into a c environment.
ieee trans.
softw.
eng.
nov. .
h. zhong s. thummalapenta t. xie l. zhang and q. wang.
mining api mapping for language migration.
in proceedings of the 32nd acm ieee international conference on software engineering v olume icse pages new y ork ny usa .
acm.
zxing.
zxing.net.