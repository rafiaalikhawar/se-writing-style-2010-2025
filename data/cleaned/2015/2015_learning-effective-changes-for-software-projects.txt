learning effective changes for software projects rahul krishna comptuer science north carolina state university usa i.m.ralk gmail.com abstract the primary motivation of much of software analytics is decision making.
how to make these decisions?
should one make decisions based on lessons that arise from within a particular project?
or should one generate these decisions from across multiple projects?
this work is an attempt to answer these questions.
our work was motivated by a realization that much of the current generation software analytics tools focus primarily on prediction.
indeed prediction is a useful task but it is usually followed by planning about what actions need to be taken.
this research seeks to address the planning task by seeking methods that support actionable analytics by offering clear guidance on what to do.
specifically we propose xtree and belltree algorithms for generating a set of actionable plans within and across projects.
each of these plans if followed will improve the quality of the software project.
index terms planning bellwethers defect prediction.
i. i ntroduction over the past decade advances in ai have enabled a widespread use of data analytics in software engineering.
for example we can now estimate how long it would take to integrate the new code where bugs are most likely to occur or amount of effort it will take to develop a software package etc.
despite these successes there are two primary operational shortcomings with many software analytic tools a conclusion instability as a result of constant influx of new data and b lack of insightful analytics.
in several applications where local data is scarce researchers use transfer learning.
they report that the use of data from other projects can yield comparable predictors to just using local data .
however new projects are constantly being created.
rahman et al.
caution that if quality predictors are always being updated based on the specifics of new data then those new predictors may suffer from over fitting.
such over fitted models are brittle in the sense that they can undergo constant changes whenever new data arrives and lead to unstable conclusions.
conclusion instability is unsettling for software project managers struggling to find general policies.
we require methods to support managers who seek stability in their conclusions while also allowing new projects to take full benefit from data arriving from all the other projects.
our research has offered strong evidence that organizations can declare some prior project as the bellwether 1that can then offer predictions that generalize across nother projects.
in addition to unstable conclusions business users also lament that most software analytics tools tell us what is.
but they don t tell us what to do .
a concern that was also raised by several researchers at a recent workshop on actionable 1according to the oxford english dictionary the bellwether is the leading sheep of a flock with a bell on its neck.analytics at ieee conference on automated software engineering .
for example most software analytics tools in the area of detecting software defects are mostly prediction algorithms such as support vector machines naive bayes logistic regression decision trees etc .
these prediction algorithms report what combinations of software project features predict for the number of defects.
but this is different task to planning which answers a more pressing question what to change in order to reduce these defects.
accordingly in this research we seek tools that offer clear guidance on what to do in a specific project.
the tool assessed in this paper is the xtree planning tool .
xtree employs a cluster contrast approach to planning where it a clusters different parts of the software project based on a quality measure e.g.
the number of defects b reports the contrast sets between neighboring clusters.
each of these contrast sets represent the difference between these clusters and they can be interpreted as plans if a current project falls into cluster c1 some neighboring cluster c2has better quality.
then the difference d c2 c1is aplan for changing a project such that it might have higher quality.
xtree uses data from within a software project to generate plans.
but in several cases local data may not be readily available.
to overcome this limitation we incorporate our findings from bellwethers to extend xtree to use the bellwether projects.
we call this tool belltree and we show that it can be used to generate stable plans for cross company planning.
ii.
c ontributions of this work .
new kinds of software analytics techniques this research introduces the notion of planning in software engineering.
in addition to showing that planning in effective in a withinproject setting we also show that with bellwethers plans can be generated for cross project problems with encouraging results.
this is a unique approach that combines our efforts to address the problems highlighted in xi.
.
compelling results of planning our results have established that planning is quite successful in producing actions that can reduce the number of defects.
in figure we show that planning can reduce defects by more than in out of the datasets studied here in the certain cases .
.
evidence of generality of bellwethers the more the bellwether effect is explored the more we learn about its broad applicability.
originally we explored this just in the context of defect prediction it has now been shown to work also in effort estimation predicting when issues will close and detecting code smells .
our preliminary results reported .
c ieeease urbana champaign il usa doctoral symposium1002 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in this work show that bellwethers can also be used for cross project planning with the use of belltree.
this is an important result of much significance since where bellwethers occur reasoning about multiple software projects becomes a simple matter of discovering bellwethers see .
.
replication package for readers this work who wish to replicate our findings we have made available a replication package at iii.
r elated work planning has been a subject of much research in artificial intelligence.
here planning usually refers to generating a sequence of actions that enables an agent to achieve a specific goal .
this can be achieved by classical searchbased problem solving approaches or logical planning agents.
such planning tasks now play a significant role in a variety of demanding applications ranging from controlling space vehicles and robots to playing the game of bridge .
some of the most common planning paradigms include a classical planning b probabilistic planning and c preference based planning .
existence of a model precludes the use of each of these planning approaches.
this is a limitation of all these planning approaches since not every domain has a reliable model.
in software engineering the planning problem translates to proposing changes to software artifacts.
solving this has been undertaken via the use of some search based software engineering techniques .
examples of algorithms include sway nsga ii etc.
.
these search based software engineering techniques require access to some trustworthy models that can be used to explore novel solutions.
in some software engineering domains there is ready access to such models which can offer assessment of newly generated plans.
examples of such domains within software engineering include automated program repair software product line management etc.
however not all domains come with ready to use models.
for example consider software defect prediction and all the intricate issues that may lead to defects in a product.
a model that includes allthose potential issues would be very large and complex.
further the empirical data required to validate any all parts of that model can be hard to find.
also even when there is an existing model they can require constant maintenance lest they become out dated.
in such domains we seek alternate methods for planning that can be automatically updated with new data without a need for comprehensive models.
for this we propose the use of data mining approaches to create a quasi model of the domain and make of use observable states from this data to generate an estimation of the model.
our preferred tools in this paper xtree and belltree take this approach by constructing decision trees on available data discussed in xiv b .
inxvii we show that these methodologies have encouraging results.
in summary for domains with readily accessible models we recommend the tools used by the search based software engineering community.
for domains where domain models are not available we recommend tools such as ours.
fig.
generating thresholds using xtree.
the recommended changes are shown in the bounded box above.
iv.
p lanning in software engineering a. what is planning?
we distinguish planning from prediction for software quality as follows quality prediction points to the likelihood of defects.
predictors take the form out f in where incontains many independent features and out contains some measure of how many defects are present.
for software analytics the function fis learned via data mining with static code attributes for instance .
contrary to this quality planning generates a concrete set of actions that can be taken as precautionary measures to significantly reduce the likelihood of defects occurring in the future.
for a formal definition of plans consider a test example z fz1 z2 zng planners proposes a plan8dj2dto adjust attribute zj2zas follows 8dj2d zj zj djifzjis numeric dj otherwise with this to say simplify a large bug prone method our planners might suggest to a developer to reduce its size i.e.
refactor that code by splitting it simpler functions .
b. xtree xtree builds a supervised decision tree and then generates plans by contrasting the differences between two branches branch where you are branch where you want to be.
the specifics of the algorithm used to divide the data and construct the decision tree were presented in greater detail in our previous work .
next xtree builds plans from the branches of the decision tree by asking the following three questions for each test case the last of which returns the plan which current branch does a test instance fall in?
which desired branch would we want to move to?
what are the deltas between current and desired?
as a motivating example consider figure with xtree constructed with training data consisting of oo code metrics and associated defect counts.
a defective test case with the same code metrics is passed into the tree and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
evaluated down the tree to a leaf node with a defect probability of .
see the orange line in figure .
xtree then looks for a nearby leaf node with a lower defect probability see the green line in figure .
xtree then evaluates the differences ofdeltas between green andorange.
these deltas can be translated as plans2.
in figure these plans are to change lcom lack of coupling among methods and cam cohesion among methods .
for a developer these may translated to a ensure a class contains more methods that interact with each other to address lcom and b ensure cohesion among methods improves to address cam.
c. belltree belltree is novel extension to xtree and is structurally similar to it.
it differs in the source of data used for analytics.
while xtree uses data from within the project belltree first starts by looking for the bellwether dataset.
to do this we employ the strategy discussed in our previous work .
this helps in identifying a bellwether dataset.
once the bellwethers are discovered we construct a supervised decision tree similar to xtree.
plans are generated by using the same procedure asxiv b. note that the use of bellwethers enables belltree to leverage data from across different projects.
v. r esearch questions rq1.
how prevalent are bellwethers?
it is important to establish the prevalence of bellwethers first as this determines if it is possible to learn plans from the bellwether data.
if bellwethers occur infrequently we cannot rely on them for planning.
we have initially shown that bellwethers are prevalent in defect prediction .
further evidence was seen in where we explored three additional sub domains within software engineering namely defect prediction effort estimation issue lifetime estimation and detection of code smells.
in a result consistent with bellwethers being very prevalent we found that all these domains have a bellwether dataset.
rq2.
does within project planning with xtree offer significant improvements in reducing defects?
this research question seeks to establish if our preferred planning tool xtree is effective in generating actionable plans in a within project setting.
our initial findings showed that xtree was indeed an effective planner that can generate plans that are also succinct and stable.
further these plans are not subject to conjunctive fallacy .
rq3.
does cross project planning with belltree offer significant improvements in reducing defects?
having established the prevalence of bellwether datasets and the efficacy of planning with xtree here we ask if it is possible for us to transfer plans across projects using the bellwether data and xtree referred to as belltree .
our preliminary results are very encouraging.
we show that belltree can be a very effective cross project planner.
rq4.
are cross project plans any better than within project plans?
this research question assesses the quality of plans obtained using xtree and belltree.
this is important 2represented as thresholds that are denoted by low high ranges for each oo metricbecause within project data is not always available especially if a project is in it s early stage of development and it may be useful to look to other similar projects for planning.
our preliminary results have suggested that the effectiveness of plans generated from within project data and xtree is statistically comparable to plans derived with cross project data and belltree.
thus when project specific data is not available one may use cross project data to derive plans.
vi.
e valuating plans to evaluate plans we propose the use of a verification oracle .
oracles have been commonly used by several se researchers such as o keefe et al.
and mkaouer et al.
.
they use an oracle that is learned separately from the planner.
the verification oracle assesses how defective the code is before and after some code changes.
for their oracle cheng o keefe moghadam and mkaouer et al.
use the qmood quality model .
a shortcoming of qmood is that quality models learned from other projects may perform poorly when applied to new projects .
hence for this study we eschew older quality models like qmood.
instead we use random forests to learn defect predictors from oo code metrics.
unlike qmood the predictors are specific to the project.
additionally classifiers such as random forest have shown to be very efficient in detecting bugs .
for planning and construction of a verification oracle we divide the project data into two parts the train set and the test test.
the train set could either be data that is available locally within a project or it could be data from the bellwether dataset.
we further partition the train set to build both a planner and averification oracle.
note that the verification oracle should be built with completely different data to the planner.
after constructing the planner and verification oracle we deploy the planner to recommend plans alter the test data according to these plans then apply the verification oracle to the altered data to estimate defects then compute the percent improvement denoted by the following equation r after before the value of the measure rhas the following properties if r this means no change from baseline ifr this indicates improvement if r this indicates optimization failure .
ideally an effective planner should have an improvement of r where larger values indicate better performance.
vii.
c urrent state and future work as mentioned earlier in the paper this work represents our efforts to address to key issues in modern software analytics a conclusion instability and b generating insightful analytics.
to this end we undertook two concurrent research efforts to address each of these issues.
while attempting to stabilize the pace of conclusion change we discovered the bellwether effect .
our results provided evidence that it is possible to slow the pace of conclusion change in software analytics for defect prediction models using bellwethers.
further exploration demonstrated that the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
observed improvements from equation antrank tr eatment median iqr xtree .
.
s bell tree .
.
s poirank tr eatment median iqr xtree .
.
s bell tree .
.
s ivyrank tr eatment median iqr bell tree .
.
s xtree .
.
s jeditrank tr eatment median iqr xtree .
.
s bell tree .
.
s fig.
results comparing xtree trained on local datasets and belltree.
results from repeats.
values come from eq.
.
values near imply no improvement larger median values are better.
so called bellwether effect is quite prevalent in several subdomains of software engineering such as code smell detection effort estimation and estimation of issue lifetimes .
in order to generate actionable analytics for software engineering we developed the xtree planner .
initial motivation for xtree was to address the varied opinions in literature on how best to undertake code reorganization so as to reduce bad smells.
we showed that by leveraging historical logs of data planners such as xtree can offer actionable recommendations on how to undertake code reorganization in order to reduce defects in code.
further we showed that in addition to generating effective plans xtree recommends of far fewer changes.
thus making it a better framework for critiquing and rejecting many of the code reorganizations.
the initial version of xtree was limited to using data from within a project to generate plans.
this paper represents our initial attempts to transfer plans from across other projects to a test project.
for this purpose we developed belltree.
it uses the same framework as xtree but uses bellwethers as the source of data for planning.
our results comparing belltree with xtree on a set of open source java projects is shown in figure .
in two of the four datasets we note that belltree performed just as well as xtree and two other cases xtree outperformed belltree but not by a significant amount .
our initial finding is that if within project data from previous releases are available we may use xtree.
if not using bellwethers would be a reasonable alternative.
our initial results of using belltree are encouraging and deserves much further exploration.
starting early this summer we have deployed an enhanced version of xtree on site in conjunction with our industrial partners with the following goals qualitatively validate the usefulness of the plans establish the receptiveness of developers actively using our tool and solicit developers feedback on usefulness of plans generated by xtree.