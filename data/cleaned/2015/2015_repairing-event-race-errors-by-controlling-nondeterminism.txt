repairing event race errors by controlling nondeterminism christoffer quist adamsen anders m ller aarhus university aarhus denmark cqa amoeller cs.au.dkrezwana karim manu sridharan samsung research america mountain view ca usa rezwana.k samsung.com manu sridharan.netfrank tip northeastern university boston ma usa f.tip northeastern.edukoushik sen eecs department uc berkeley ca usa ksen cs.berkeley.edu abstract modern web applications are written in an eventdriven style in which event handlers execute asynchronously in response to user or system events.
the nondeterminism arising from this programming style can lead to pernicious errors.
recent work focuses on detecting event races and classifying them as harmful or harmless.
however since modifying the source code to prevent harmful races can be a difficult and error prone task it may be preferable to steer away from the bad executions.
in this paper we present a technique for automated repair of event race errors in javascript web applications.
our approach relies on an event controller that restricts event handler scheduling in the browser according to a specified repair policy by intercepting and carefully postponing or discarding selected events.
we have implemented the technique in a tool called eventracecommander which relies entirely on source code instrumentation and evaluated it by repairing more than event race errors that occur in the web applications from the largest of the fortune companies.
our results show that applicationindependent repair policies usually suffice to repair event race errors without excessive negative impact on performance or user experience though application specific repair policies that target specific event races are sometimes desirable.
keywords javascript event driven programming automated repair i. i ntroduction modern application development has largely moved to platforms requiring event driven programming using web browsers and mobile platforms.
the event driven model is well suited to the needs of today s interactive programs which must perform high latency network requests to send and receive requested data while remaining responsive to user input.
however as studied in recent work this programming style can cause pernicious nondeterminism errors which can lead to crashes lost user data and malfunctioning user interfaces.
recent work has attacked this nondeterminism problem through tools for detecting event races where application behavior may differ depending on the order in which event handlers are executed.
for web applications event race detectors are capable of finding errors in real world deployed web the work of this author was carried out during an internship at samsung research america.
the author s current affiliation is uber.applications .
further tools such as r4 can filter away warnings about races that do not affect the external behavior of web applications.
despite these advances the output of state of the art event race detectors is often still not practical.
diagnosing the root cause of an event race in a real world web application can require a significant effort it often requires deciphering complex event sequences and it can be difficult to classify how harmful a reported race is especially for non expert users of the tools.
in addition preventing such races may require introducing complex synchronization into the code an arduous task since the web platform provides few mechanisms for synchronizing across event handlers.
manually devising such a fix is often not worth the effort particularly for minor errors when considering that fixes sometimes have unforeseen consequences .
better techniques are needed to reduce the cost of fixing event race errors.
in this work we explore automated repair of event race errors in web applications.
automated repair holds great promise for addressing the aforementioned drawbacks of event race detectors.
if event race errors can be automatically repaired without requiring developers to deeply understand root causes the errors may be avoided more often.
there is a wide body of work on repairing races in multi threaded programs but relatively little work on repair for event races.
wang et al.
have proposed a repair technique for event races in web applications but it has significant limitations in the types of races it can handle see section viii .
our approach builds on an event controller that restricts event handler scheduling in the browser according to a specified repair policy by intercepting and carefully postponing or discarding selected events.
restricting schedules dynamically to avoid bad orderings is a well known approach to automated repair of races in the context of shared memory concurrency races but to our knowledge it has not previously been applied to event driven applications.
an important property of our approach is that the event controller is built entirely by instrumenting the web application code.
most event race detection tools for javascript work using modified browsers which is reasonable for detecting races but not for automated repair ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
as the code must run on end user browsers.
in spite of relying solely on light weight instrumentation our approach is general enough to repair common types of event races although some event race errors cannot be repaired by merely restricting the nondeterminism see section v d .
given this event controller the question remains of what policies are required to repair races in practice.
a policy specifies which events to postpone or discard so choosing an appropriate policy requires knowledge about which event orders are good and which are bad.
we observe that many races in web applications can be prevented with a small collection of application independent policies.
for example application developers often expect ajax response handlers to execute in a first in first out fifo order and that the page completes loading before the user interacts with it many errors occur when these assumptions are violated.
our applicationindependent policies enforce these assumptions yielding a simple method for avoiding many races.
application independent policies are easy to apply but may impact performance or user experience negatively.
for example delaying all user events until after the page has loaded may make the page appear sluggish and in fact many user interactions during page load may be perfectly safe i.e.
they cannot lead to harmful races .
we show that these problems can be alleviated using application specific policies which can be designed for example by specializing an applicationindependent policy to a particular web application.
in summary the contributions of this paper are as follows.
we demonstrate that most errors involving event races in javascript web applications can be repaired automatically using light weight instrumentation to steer the nondeterminism according to a specified repair policy.
we propose the use of application independent policies which can be specialized as needed to avoid excessive delay in event processing or to target specific event races reported by existing race detection tools.
we evaluate our approach based on an implementation called eventracecommander by repairing event race errors in the websites of the largest companies from the fortune list.
our results show that of the errors can be repaired using application independent policies mostly without excessive negative impact and that application specific policies can alleviate the undesirable effects when this is not the case.
ii.
m otiv a ting example figure shows a small web application for browsing through galleries of images consisting of three files.
file index.html defines a top level page with two buttons labeled gallery and gallery .
clicking each button causes function loadthumbs lines to be invoked with the gallery name g1 o r g2 depending on the gallery being selected.
executing loadthumbs will send an ajax request to the server lines .
when the server responds the readystatechange callback function lines is invoked.
this callback parses the response to retrieve an array ofindex.html html ... div id container ... ... button id g1 gallery button button id g2 gallery button script src init.js script script src script.js script html init.js 10document.getelementbyid g1 .addeventlistener click function loadthumbs g1 false 12document.getelementbyid g2 .addeventlistener click function loadthumbs g2 false script.js 14varthumbs 15function loadthumbs name thumbs varxhr newxmlhttprequest xhr.onreadystatechange function if xhr.readystate xmlhttprequest.done thumbs json.parse xhr.responsetext showthumbs name xhr.open get gallery?name name true xhr.send null 27function showthumbs name container.innerhtml for varpos pos thumbs.length pos ... display thumbnail image varb document.createelement button b.textcontent delete function pos b.addeventlistener click function e deleteimg name pos false pos container.appendchild b 41function deleteimg name pos ... xhr.open post gallery?action delete name name img thumbs .id true ... fig.
.
motivating example inspired by zheng et al.
.
thumbnail images and stores them in variable thumbs line and then invokes showthumbs with the same gallery name as before.
function showthumbs lines iterates through thumbs and creates a delete button for each image that when clicked will invoke deleteimg with the gallery name and index of the image.
function deleteimg lines creates another ajax request requesting the selected image to be deleted from the server lines .
a. event races the example application exhibits three event races that may cause runtime exceptions or other unexpected behavior depending on the order in which event handlers execute.
the corresponding undesirable schedules are illustrated in figure and discussed in detail below.
a circlecopyrt if the user clicks the gallery buttons before init.js has executed then the user event is lost since the click event handlers are not yet registered.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
index.html init.js script.js lines index.html init.js script.js lines user clicks gallery buttononreadystatechange eventuser clicks gallery buttonuser clicks delete buttontypeerror no property id in undefined loadthumbs lines loadthumbs lines showthumbs lines showthumbs lines loadthumbs lines loadthumbs lines deleteimg lines deleteim g lines c c b ba a index.html lines index.html lines index.html lines index.html lines init.js lines init.js lines script.js lines script.js lines user clicks gallery button click event is lost init.js lines init.
js lines index.html lines index.html lines user clicks gallery button referenceerror loadthumbs not declared fig.
.
illustration of event races in the program of figure .
b circlecopyrt if the user clicks the gallery buttons after executing init.js but before script.js has executed then an event handler is associated with the click event but function loadthumbs is still undeclared.
hence executing either of theclick event handlers on lines and triggers an uncaught referenceerror .
c circlecopyrt assume the user clicks the gallery button after the entire page has been parsed.
this causes loadthumbs lines to execute with argument g1 generating an ajax request.
when the server responds the event handler on lines executes causing showthumbs to execute lines .
if the user then clicks the gallery button loadthumbs runs again now with argument g2 assigning an empty array to thumbs before making a second ajax request.
now say the user clicks the delete button for an image that is still on the screen before the response to the second ajax request is received.
then the click handler on lines invokes deleteimg lines causing the expression thumbs .id to be evaluated line .
but thumbs is still empty!
so thumbs evaluates to undefined and accessing the id property of undefined yields an uncaught typeerror .
we will refer to scenarios where user events interfere with initializations performed during page loading e.g.
scenarios a circlecopyrt and b circlecopyrt a s initialization races .
races such as the one in scenario c circlecopyrt will be referred to as post initialization races .
b. repairing event race errors the types of problems discussed above commonly occur when a schedule differs from developers expectations.
for example developers typically test their code in environments where the parsing and loading of a page is fast and where user actions do not occur until page loading is complete.
scenarios like a circlecopyrtand b circlecopyrtviolate this assumption causing various sorts of errors to arise when user events arrive at inopportune moments.
similarly developers commonly assume the network to be fast so that responses to ajax requests are received before the user performs additional actions.
scenario c circlecopyrt where the user clickson delete before the response for the click on gallery is received violates this assumption resulting in a runtime error.
our approach for preventing undesirable schedules relies on code instrumentation and takes as input a repair policy that specifies constraints on the scheduling of event handlers.
in particular the web application is instrumented so that all events are intercepted and monitored by a runtime controller.
at runtime when an event arrives that is not in accordance with the repair policy it is either discarded or postponed until the execution of the associated event handlers agrees with the policy.
for example scenarios a circlecopyrt and b circlecopyrt can be prevented in our approach by an application independent policy that postpones user events until all statically declared scripts are loaded by intercepting the events and regenerating them later.
in cases where this policy blocks harmless user events one can easily create a policy that only postpones clicks on the gallery buttons.
likewise scenario c circlecopyrt can be prevented by an application independent policy that discards user events after an ajax request until the response arrives.
in such cases eventracecommander shows a spinner on the screen to inform the end user that user events are temporarily blocked.
while the three scenarios discussed here can be repaired using application independent policies application specific policies may be preferable as we shall see in section vii.
iii.
b ackground on event races this section defines event races and related concepts using a simplified version of the formalism of raychev et al.
.
we instrument an event based program to generate a sequence of operations called a trace for a given execution.
an operation can be of the following kinds assuming each event is given a unique identifier u read u x and write u x denote that an event handler ofureads and writes respectively a shared variable x. fork u v denotes that an event handler of ucreates a new event vthat will be dispatched later.
begin u and end u denote the beginning and ending respectively of the execution of u s event handlers.
we denote the set of all operations by op and the event to which an operation belongs by evt .
the execution of a program generates a finite trace 0 n op .
in event based programs all event handlers of an event execute atomically without interleaving with the execution of any handler of another event.
therefore if an event ugets dispatched then all the operations from the event handlers ofuappear as a contiguous subsequence in the trace where the first and last operations of the subsequence are begin u and end u respectively.
if the trace contains an operation fork u v then begin u appears before begin v i.e.
an event must be created before it gets dispatched.
a trace defines a linear relation where primeif the operation appears before primein the trace .
as in traditional concurrent programs we can define a happens before relation precedesequalas the minimal partial order i.e.
a reflexive anti symmetric transitive relation over the events of a trace such that u precedesequalvif fork u v or ifuandvare user events where begin u authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
scheduler p extend p update p update p p q s a r pa s uniontext ri r q s t a r pa s extend p discard u if begin u action u p discard postpone u if begin u action u p postpone otherwise action u p m a x a q s t a r pa begin u s where disp a tch postpone discard fig.
.
the effect of a repair policy on the execution.
begin v .
two events uandvare unordered denoted by u bardblv if they are not related by the happens before relation.
we are now in a position to define the notion of an event race.
an event race prime is a pair of operations from a trace where prime evt bardblevt prime both and primeaccess i.e.
read or write the same shared variable and at least one of and primeis a write.
recent work has focused on classifying event races as either harmful or harmless .
in general such classification is a subjective matter.
in many cases lost user events or uncaught exceptions do not significantly affect the user experience and do not require remediation though for some web sites such errors are intolerable.
our approach side steps this ambiguity by relying on the user of eventracecommander to distinguish desirable schedules from undesirable ones and applying a repair policy that prevents undesirable schedules from taking place.
in other words our approach does not rely on a particular definition of harmfulness nor is it limited to races that are considered harmful.
iv .
a f ramework for specifying rep air policies this section presents a framework for constraining the order in which event handlers are executed using a specified repair policy.
a repair policy pconsists of a set of rules which upon their activation determined by the current trace and program states of the web application may discard or postpone events occurring in the execution.
to this end we add the following types of operations.
discard u denotes the discarding of event u i.e.
the event handlers for event uwill not be invoked and no begin u operation will ever appear in the trace .
postpone u denotes the postponement of event u i.e.
u will be re emitted later and at least one of the operations begin u discard u postpone u will appear in the trace onceuis re emitted .
a key contribution of our work is that we based on a study of many event races in real world web applications observe that harmful races mostly arise for similar reasons and can be repaired using application independent policies.
arule is a quintuple of the form q s t a r q where qis an operation predicate over the operations in op that specifies a necessary condition for the rule to be activated upon the current operation of a scheduler.
sis an expiration status which is a predicate over the pairs of traces and program states that determines if the rule is enabled or expired.
t is a scope .i ft then the rule expires the first time it is activated otherwise it remains enabled until the expiration status sbecomes true.
a disp a tch discard postpone is an action in response to the event that the rule was activated by.
r op 2qis an extension function that maps an operation to a policy which is used for dynamically adding new rules to the existing policy.
for the sake of presentation we will use q s t a r0 ... r nto denote the policy q s t a .
uniontext i nri and q s t a to denote the policy q s t a .
a rule q s t a r p isactivated by an operation in state s ifq and s s hold i.e.
the rule matches the operation and is not expired.
we denote by pa s the set of rules in pthat are activated by in s .
the definition of activated rules enables us to describe the effect of a repair policy on the execution by means of a function scheduler p figure that maps an operation a trace and a repair policy to an extended trace and updated policy.
the auxiliary function extend p figure determines whether events should be discarded or postponed by computing the action for as a maximum over the activated actions multiple rules may be activated simultaneously .
the ordering among actions is defined in figure .
if is not a begin operation then is simply extended with .
hence a policy cannot discard or postpone an event based on specific operations within an event handler.
rules can however match on specific operations and use them to modify the policy via the extension function.
in addition to extending the trace the current repair policy pis replaced by p prime update p figure which differs from pas follows.
all rules with scope 1that were activated by in s are removed from p. pis extended with the rules in r for every activated rule q s t a r .
we emphasize that postponing one event may require other events to be postponed as well due to the happens before relation of the original web application.
for example the load event of a script always follows the execution of the same script.
our framework automatically enforces such constraints and additionally preserves the order of user events.
v. r ep air policies we identify five classes of event races that cause many problems in practice.
section v a defines application independent policies in terms of the framework presented in section iv.
then section v b shows how such general policies can be specialized to particular web applications for improved performance and user experience.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
quser begin u type u keydown mousedown ... qcallback begin u type u timer type u load tagname target u iframe img qfork fork v type v script exec timer type v readystatechange readystate target v qbegin u begin u arrived u s begin u parsed s domc ontent loaded uniontext begin u type u a b wait for u quser arrived u discard wait rec u qfork arrived u disp a tch fork v w wait for w wait rec w order u v qbegin v arrived u postpone order next u qfork arrived u disp a tch fork v w order u w pinit user quser parsed postpone pinit system qcallback parsed postpone pasync user qfork latticetop disp a tch fork u v wait for v pasync fifo qfork latticetop disp a tch fork u v order next v p init user pinit user uniontext parenleftbig qfork parsed disp a tch fork u v wait for v wait rec v parenrightbig c d fig.
.
repair policies.
a operation predicates b expiration status utilities c utility functions d application independent repair policies.
a. application independent repair policies user events before domcontentloaded scenarios a circlecopyrt and b circlecopyrtfrom section ii a illustrate initialization races that lead to undesirable behavior when a user interacts with a web page before it has been fully parsed.
the errors induced by these races can be repaired by enforcing the policy pinit user from figure d where quser is an operation predicate that matches any user event.
due to the definition of the policy s expiration status p arsed figure b this policy postpones any user event until the event handlers of domcontentloaded have been executed.
it is easy to see how this policy prevents the errors in scenarios a circlecopyrt and b circlecopyrt from section ii a by preventing click events on the gallery buttons until the page has been parsed the click event handlers will be registered in time and theloadthumbs function will be defined before it is invoked thereby preventing the referenceerror .
in this policy d iscard could be used instead of postpone .
the d iscard action is intended for user events only since users can always simply repeat their inputs when the policy allows it which is not possible for system events.
system events before domcontentloaded harmful initialization races also arise when system events fire unexpectedly early.
in the following example which is based on code from exxon.com the load event listener attached by the script will never run if the iframe loads prior to the execution of the script.
iframe src ... id iframe iframe ... script iframe .load function e adjust iframe height script such errors can be repaired using the policy pinit system from figure d which postpones system events such as the load event of the iframe in line until the page has been parsed.
pinit system matches any iframe orimg load event and any timer event with the operation predicate qcallback .
user events while async event is pending scenario c circlecopyrt in section ii a represents a situation where the application logic implicitly assumes that asynchronously forked events are handled atomically without being interrupted by user events.such post initialization race errors can be prevented using policypasync user of figure d .
informally this policy adds the rule w ait for v figure c to the policy whenever an operation forks an asynchronous event v e.g.
ajax request asynchronous script request settimeout .
this rule discards user events until vis observed in the trace.
ajax fifo sometimes programmers implicitly assume that the responses to multiple ajax requests arrive in the same order as the requests were made.
consider the following example which captures the essence of a race from gazzetta.it 52ajax post url1 function a document.cookie f a 53ajax post url2 function b document.cookie g b the two callback functions are executed in response to the first and second ajax request respectively.
both functions assign some data from the server s response to the same document.cookie key.
therefore the value of this key depends on the order in which ajax responses arrive.
to prevent such races we use policy pasync fifo of figure d to postpone ajax response events that would break fifo order upon each ajax request operation fork v the policy starts listening for the next ajax request operation fork w by adding the rule o rder next v .
the use of scope in o rder next ensures that the rule will not be activated upon any ajax request operations following fork w .i f begin v appears in the trace before fork w then fifo is already maintained and o rder next v expires due to its expiration status a rrived v .
otherwise fifo is enforced by o rder v w added from o rder next v which postpones begin w until begin v appears in the trace.
furthermore o rder next w is added by the rule in pasync fifo t o order begin w with the response of the ajax request operation that follows fork w if any .
user events before async initialization sometimes initialization actions are being performed by asynchronously executed code.
consider the following snippet which was extracted from flysas.com .
input id from airport input id to airport script authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
56varlastfrom ... lastto ... inspect cookie .get service?code lastfrom function from .get service?code lastto function to from airport .val from.name to airport .val to.name script during loading the user s input may be overwritten since the fields in lines are not initialized until the responses of the two ajax requests in lines have been processed.
this may happen after the domc ontent loaded event and therefore the policy pinit user does not suffice to repair the race.
to accommodate for this we define an extension of this policy p init user that additionally discards user events until asynchronous initialization has been performed.
intuitively p init user continuously adds w ait for v which discards user events until begin v appears in the trace for every operation fork v that matches qfork as long an event that has been forked by some other operation matching qfork is pending.
for example if fork v and fork w denote the ajax requests in lines and respectively then wait for v is added upon fork v which discards user events until the callback in lines has executed.
in addition w ait rec v is added which itself adds w ait for w upon fork w .
the w ait for w rule discards user events until after the callback in lines .
the w ait rec rule recursively adds new rules to approximate when asynchronous initialization is over.
this may lead to user events being discarded indefinitely e.g.
in the presence of image sliders that keep changing automatically .
thus this policy should only be used for pages that always terminate i.e.
where the event queue eventually becomes empty if no more user events are made or qfork should be defined such that it excludes operations that are not part of initialization e.g.
by ignoring timer operations .
b. application specific policies the application independent policies can be applied without a deep understanding of the races and suffice for preventing the majority of the race errors see section vii .
however sometimes the policies negatively affect web page responsiveness e.g.
the user experience of a web page can be degraded when too many user events are interrupted .
this motivates application specific repair policies that reduce disruption.
it is straightforward to refine an application independent policy to specific user events.
the manual effort required to design an optimal application specific policy naturally requires understanding the cause of the race.
specializing an application independent policy to a concrete web application is straightforward.
as an example recall that the race errors exposed by scenarios a circlecopyrt and b circlecopyrt can be prevented by enforcing the policy pinit user .
however this may unnecessarily affect clicks to buttons other than gallery and gallery during page loading.
this problem can be alleviated by refining the operation predicate quser inpinit user to only match click events on those two buttons.the interruption of the user is still not minimal though since the function loadthumbs figure lines is declared strictly before the domcontentloaded event gets dispatched.
this can be remedied by for example exchanging the policy s expiration status from p arsed to one that unlike all of the application independent policies relies on the actual program state to return true when loadthumbs is declared in the global scope of s .
with this modification it not only becomes clear that the policy covers the event races in question it also minimizes the interruption of the user.
c. effectiveness of repair policies to understand if a repair policy pprevents the bad order of an event race recall that state of the art dynamic race detectors such as eventracer report event races as two operations and primein a trace where evt bardblevt prime .
simply checking that the race disappears when running a race detector on the instrumented program that enforces p is too naive since state of the art race detectors are currently unable to reason about ad hoc synchronization and will report prime as a false positive.
on the other hand checking that the race becomes covered gives false confidence.1indeed most races become covered in the instrumented program since the execution of event handlers is controlled by ad hoc synchronization in the instrumented program.
to see how a repair policy pprevents the bad order of prime consider that the instrumentation restricts the nondeterminism in the original program by enforcing an order among certain events in the execution.
assuming that the trace obtained by the race detector is valid according to p it is possible to model the effect of pby defining an augmented happens before relation precedesequalpas the minimal partial order such that u precedesequalpvif eitheru precedesequalvorpwould enforce u to execute before v. using this relation it is possible to tell ifpwould prevent the race prime by checking if precedesequalp prime or prime precedesequalp giving developers a way to automatically repair races that has been reported from dynamic race detectors for a fixed catalogue of policies .
the relation precedesequalpcan be built for multiple application independent policies by extending eventracer.
it remains open for future work to construct the relation for arbitrary policies.
d. discussion of limitations and liveness although it is not a problem for the repair policies we have presented so far there is a risk for postponing events indefinitely thereby breaking liveness when enforcing policies.
generally we want to prevent some bad ordering v u by discarding or postponing vuntiluhas been dispatched.
to avoid breaking liveness it must be known by the time vis about to fire that uwill inevitably occur later in the execution.
intuitively repair policies can only make decisions based on past events and not on future events.
let fbe a set of events that are known to happen in the future.
initially f contains events that always happen during page loading e.g.
1intuitively a race prime iscovered by another race prime if prime is no longer a race when prime is being treated as synchronization.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
domcontentloaded .
during execution as soon as some event is known to happen in the future e.g.
a timeout is registered or an ajax request is sent it is added to f. perhaps surprisingly fmay also contain some user events since a single user event is typically composed of a sequence of low level events e.g.
akeyup event always follows a keydown event .
we now define a necessary condition for being able to enforce an order u v ifvcomes before u andu negationslash f then there is no way to steer away from the bad execution without potentially breaking liveness since it is unknown if uwill ever arrive safety can be preserved though by postponing vuntilu or indefinitely ifunever arrives .
otherwise if we can define i an operation predicate that identifies begin v and ii a state predicate that becomes false at some point after uhas been dispatched then the desired ordering can be enforced.
we call a repair policy enforceable for a program if it does not break liveness in any execution .
conversely we call a race repairable if there exists an enforceable policy that prevents the bad order of that race.
the application independent policies pinit user pinit system pasync fifo andpasync user are enforceable for all programs and p init user is enforceable for all programs that terminate see section v a .
there are situations where it is not possible to prevent an ordering v uby only discarding or postponing events.
consider the following example script settimeout function d document script script console.log d.queryselectorall .length script here the callback in line is supposed to execute prior to the script in line .
if the latter executes first then the only possible repair is to postpone its execution.
however this will change program behavior since line counts the number of elements currently in the dom.
we have not seen any such examples in practice and hypothesize that this situation is rare.
in other cases although it is technically possible to repair an event race error the result would have such a negative impact on user experience that we do not consider it.
these races involve event handlers that are triggered when the user merely moves the cursor e.g.
mouseenter .
using a repair policy the user can be provided with feedback that the page is not ready.
however for this kind of indirect user event as opposed to mouse clicks and key events the event handler registration should rather be performed earlier by changing the code.
vi.
i mplement a tion our implementation named eventracecommander instruments html and javascript source files of a given web application on the fly using mitmproxy .
the instrumentation intercepts relevant operations and interacts with the event controller which is loaded before any application code such that instrumentation and application code do not race.
the implementation of eventracecommander is available at .
a. controlling the execution for non dom events e.g.
timers ajax responses eventracecommander replaces each registration of an eventhandlerhwith the registration of a new event handler h primethat addshto a queue maintained by the event controller.
this involves intercepting calls to a small set of global functions e.g.
settimeout and instrumenting all property assignments to intercept registrations to e.g.
the onreadystatechange property of xmlhttprequest objects.
for dom events e.g.
click load the situation is slightly more complicated due to capturing and bubbling .
these event delegation mechanisms propagate events from the document root to the target node and back .
eventracecommander handles dom events as follows.
when the page starts loading event handlers for all dom event types are registered for the capturing phase of the root element this ensures that these event handlers are triggered first since event handlers are triggered in registration order .
when one of these event handlers is invoked with an event ethat was not previously postponed the event controller is notified that ehas been emitted.
the controller then queries the repair policy for the action a primeassociated with e.i fa prime disp a tch then all event handlers associated with eare triggered and the controller is notified that ehas been dispatched.
otherwise a prime discard postpone and the execution of the application s event handlers and other possible side effects of the event e.g.
the insertion of a character into a text field are prevented by calling stopimmediatepropagation andpreventdefault on the event object of e. furthermore if a prime postpone then the process is repeated by re dispatching easynchronously.
b. intercepting relevant operations eventracecommander intercepts fork begin and end instructions.
operations of type fork are intercepted by replacing certain browser api functions and intercepting property assignments.
for example the send function on the prototype ofxmlhttprequest is replaced by a function that in addition to sending the request notifies the event controller that an ajax response event has been forked.
it is insufficient to monitor events for which the program has an event handler in order to enforce e.g.
pasync fifo all ajax response events must be intercepted even those that have no response event handler.
eventracecommander therefore adds a default event handler for such events.
vii.
e v alua tion we aim to answer the following research questions.
rq1 how effective is each of the application independent policies of section v at repairing event race errors?
rq2 what is the impact of each application independent repair policy on runtime performance and user experience?
rq3 is it possible to reduce runtime overhead and improve user experience using application specific policies?
a. experimental methodology selecting event race errors we use existing tools such as eventracer and r4 to identify candidate event races in the web applications of the largest companies from the fortune list.
since front pages of many websites authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
often contain little dynamic behavior we manually explore the selected sites to find interesting pages.
following mutlu et al.
we focus on observable races that result in errors such as uncaught exceptions or visual differences so that we can confirm the effectiveness of our repairs.
in order to keep the amount of work manageable we examine up to candidate races for each website to identify whether they are observable.
altogether this gives us errors that are caused by observable races.
selecting application independent repair policies we study each observable race in detail to identify which of the application independent repair policies that can repair the corresponding error.
measuring instrumentation overhead for each website we create an application independent policy that repairs all race errors possibly by combining multiple applicationindependent policies and measure the overhead of that policy.
we use the chrome debugging protocol to measure i parsing time i.e.
time to domcontentloaded showing the cost for loading eventracecommander and instrumenting the source and ii layout time i.e.
time to last layout event during initialization .
in this experiment we prevent layout events from triggering indefinitely e.g.
due to a slideshow by stopping recursive timer registrations and intervals so that every web application terminates.
we report the mean of repetitions in each case.
user experience parsing time and layout time indirectly reflect the user s experience most elements are ready for user interactions after a page has been parsed and layout time reflects perceived responsiveness.
in a few cases where application independent policies are inadequate because of undesirable impact on the user experience we attempt to design application specific versions of application independent policies that do no exhibit similar problems.
for each such case we attempt to evaluate the impact on user experience by comparing the delays in event processing for applicationindependent and application specific policies.
system details we run the experiments on ubuntu .
with an intel core i7 cpu and gb ram.
table i shows the sites and races used to evaluate eventracecommander .2the race errors column presents the total number of observable races found in each site.
the race classification columns classify these races.
most of the observable races that we found are initialization races and nearly all of these involve user events except a race onatt.com where two dependent scripts are loaded without any ordering and on exxon.com where an iframe load event handler is registered late.
late event handler registrations tend to be a recurring problem.
we also identify multiple postinitialization races.
these typically cause a web application to end up in an inconsistent state.
2we did not detect any observable races on berkshirehathaway.com valero.com unitedhealthgroup.com andkroger.com .
those sites are excluded from the table.b.
experimental results rq1 the repair policy columns of table i reflect the applicability of the application independent policies.
if for a given site an event race riappears in the column of repair policyp thenprepairs the error caused by ri.
otherwise no application independent policy prevents ri and the race appears in the none column.
in our experiments allobservable races that could not be repaired using application independent policies involve indirect user inputs section v d .
these races are relatively harmless e.g.
dropdowns that do not unfold when the user hovers a menu item with the cursor during loading .
note that races with the same classification tend to be prevented using the same policies.
this is to be expected sincepinit user p init user andpinit system target initialization races unlikepasync fifo andpasync user .
although we cannot guarantee that our applicationindependent policies always suffice our results suggest that the policies can prevent most event race errors in practice of the event race errors are repairable using our application independent policies .
this also suggests that although eventracecommander relies on a light weight instrumentation it provides sufficient control of the nondeterminism to prevent the races that occur in practice.
furthermore the results indicate that our assumption of what good schedules are section ii b agrees with developers expectations otherwise our policies would enforce erroneous schedules .
table i shows that many race errors can be repaired using more than one application independent policy.
not surprisingly many races can be repaired using both pinit user and p init user but we also find that pasync fifo andpasync user often repair the same race.
this happens when a user triggers an asynchronous event e.g.
an ajax request twice.
the policy pasync fifo avoids such races by enforcing an order among the unordered events whereas pasync user postpones user events while an asynchronous event is pending thereby ensuring that event handlers and their forked events execute atomically .
rq2 the last two columns of table i show parsing and layout time.
for most sites the instrumentation overhead is less than 200ms which we deem to be acceptable.
small websites exhibit larger relative overheads due the cost of including eventracecommander s kb of javascript.
the absolute overhead is barely noticeable by a user though.
regarding user experience it is important to interrupt only user events that are involved in races and only for as long as is necessary to prevent undesirable schedules.
generally we find that the policies pinit system andpasync fifo can be enforced obliviously to the user since they do not involve user events and in our experiments do not significantly postpone ui updates.
there is often room for improvements over pinit user pasync user andp init user since the operation predicates in these policies are overly general.
this is mostly a problem for p init user in sites that extensively load code asynchronously e.g.
walmart.com which uses requirejs .
in such cases the page appears to be ready significantly before user input is tolerated and an application specific policy should be used authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
race classification repair policy instrumentation overheadrace errors pinit user p init user pinit system pasync fifo pasync userinitialization racespost init.
races websitedeclare eventregister eventupdate eventsystem user none parsing ms layout ms walmart.com r1...r13 r14 r1...r10 r14r14r11...r13 .29x .08x exxon.com r1...r6 r7r1...r5r1...r5r6r7r7 .02x .01x chevron.com r1...r6 r7...r8 r7...r8r7...r8r1...r6 .12x .13x apple.com r1...r2 r3r1...r2r1...r2 r3r3 .11x .10x gm.com r1...r6r7r8r1...r6r1...r7 r8r8 .08x .08x phillips66.com 3r1...r2 r3 r1r1...r2 r3r3 .14x .04x ge.com r1...r7r8...r10r1r2...r7r8...r10r8...r10 .08x .13x ford.com r1 r1r1 .06x .06x cvshealth.com r1...r8 r9...r10r1...r7r1...r7r9...r10r9...r10r8 .98x .99x mckesson.com 2r1 r2 r1...r2r1...r2 .08x .00x att.com 12r1...r2r3...r12 r3...r12r3...r12r1...r2 .21x .20x verizonwireless.com 13r1...r13 r1...r13r1...r13 .15x .
amerisourcebergen.com r1...r4 r1...r4r1...r4 .04x .03x fanniemae.com r1...r5 r1...r5r1...r5 .26x .10x costco.com r1...r16 r1...r3r1...r3 r4...r16 .11x .03x hp.com r1 r1r1 .01x .01x total t able i observ able races applicability of applica tion independent rep air policies and instrument a tion overhead .
race classification declare event an entity may be used before it is declared triggering an error e.g.
scenario b circlecopyrt .register event an event handler may be registered late leading to lost events e.g.
scenario a circlecopyrt lines .
update event a form field may be updated asynchronously overwriting the user s input e.g.
lines .
system user a system and user event are unordered leading to an error or erroneous state e.g.
scenario c circlecopyrt .
to target the relevant user events and minimize the time in which the user is disrupted.
interestingly we find that some of the websites e.g.
apple.
com prevent races in ways similar to pasync user by showing a spinner that takes up most space on the screen when a user event leads to asynchronous dom updates.
rq3 we now briefly report on two event races where application independent repair policies yield suboptimal results and discuss how each situation can be remedied using an application specific policy.
onatt.com event race r1can cause a typeerror due to two scripts being unordered.3policypasync fifo ensures that asynchronous scripts are executed in fifo order and fixes the error but unnecessarily imposes an order on scripts.
on average of these scripts are postponed for 292ms.
this can be prevented using a specialized policy p prime async fifo which only postpones the execution of satellite567046aa64746d0712008241.js .
on average this policy postpones no scripts at all i.e.
in our experiments the two scripts always load in the desired order .
onwalmart.com aclick event handler of a button is registered by an asynchronous script.
until that happens click events on the button are lost and no dropdown is shown event race error r13 .
while this problem can be fixed using the application independent policy p init user this results in excessive delays for processing a click event.
we can avoid such undesirable impact on the user experience by designing an application specific policy pspec that postpones click events only until the handler is present.
in an experiment we issue 3the global variable s att is declared in s code contents65778bc202aa3fe01113e6b6ea6d103eda099fe5.js and used in satellite 567046aa64746d0712008241.js .
the latter may depending on the event order crash during an assignment to s att.events .a click immediately when the button is declared and measure the time until the corresponding event handlers execute.
on average the click event is dispatched 817ms faster when using the policy pspec instead of p init user .
the application specific repair policies discussed above are both optimal in the sense that they only postpone events that are involved in the races under consideration for the minimal amount of time required to prevent the undesired orders.
we argue that for these race errors enforcing repair policies using eventracecommander compares well to alternative solutions such as modifying the code to introduce ad hoc synchronization or explicitly load scripts synchronously.
c. discussion some aspects of our evaluation may affect the generality of the reported results.
most significantly the selection of websites and event race errors used in our evaluation could be subject to bias.
we have attempted to address this concern by evaluating eventracecommander on the websites of the largest companies from the fortune list similar to previous work on event race detection .
the code of the websites used in our evaluation may be subject to change which may affect reproducibility of our results.
therefore we spent significant effort using mitmproxy to record the server responses for an interaction with every site under consideration.
this enables reproducibility for all front pages.
regrettably some highly dynamic pages that we consider cannot be replayed since the urls of ajax requests depend on user input random numbers timestamps etc.
still this is a significant improvement over recent work where the importance of reproducibility has mostly been ignored.
the recordings from our study are available with the implementation of eventracecommander .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a related concern is that real websites may give rise to unpredictable network delays which may affect repair policies such as pasync fifo .
in principle these delays can become arbitrarily large so the data from our experiments may not truly reflect the impact on user experience.
in our experiments we avoid large fluctuations by relying on recordings of every website and by conducting experiments times and reporting average times.
to prevent situations where the user is being disrupted for too long it would be possible to monitor if eventracecommander postpones an event for more than a given threshold.
in such cases the event could simply be dispatched and the users of eventracecommander could be notified of the incident so that the policy can be adjusted.
viii.
r ela ted work race detection ide et al.
pointed out that javascript programs can have data races despite being single threaded and non preemptive.
such races often arise due to asynchronous ajax communication and html parsing.
the authors note regarding ajax races that the programmer prefers to think of the interaction with the server as a synchronous call which is also the foundation for our scheduling policies for such races.
zheng et al.
proposed a static analysis for automatically detecting javascript races.
due to the dynamic nature of javascript such static analyses are often prohibitively imprecise or unscalable.
inspired by successful techniques developed for multi threaded programs webracer and eventracer instead use dynamic analysis and a happensbefore relation .
this significantly improves precision however these tools cannot distinguish harmful from benign races which has motivated techniques that explore whether races cause observable differences .
still these techniques tend to report many false positives and also miss harmful races and it has been observed that the harmful races that are detected are often difficult to fix.
event race detection algorithms have also been developed for android using similar techniques as those targeting javascript but with more sophisticated happens before relations .
adapting our technique to android is an interesting opportunity for future work.
automated fixing of race errors the idea of automatically fixing race errors has been studied extensively in a multithreaded setting but not much for event driven applications in particular javascript.
some techniques patch the program code by inserting e.g.
locks and wait signal operations based on reports from race detectors and static analysis .
the javascript platform provides no explicit synchronization primitives but our repair policy mechanism can simulate the effect of having wait signal primitives or atomic groups of event handlers.
other techniques steer away from nondeterministic errors by postponing selected actions much like our approach but for multi threaded programs.
the ai technique attempts to stall threads where manifestation of a concurrency bug is about to become deterministic.
kivati uses static analysis and hardware watchpoints to detect atomicity violations andthen dynamically reorders the relevant instructions.
the aviso system learns schedule constraints from successful and failing executions and then uses these constraints to guide scheduling much like our policy mechanism and controller.
the loom system uses a notion of execution filters which resembles our use of application specific repair policies.
these techniques share the limitation of eventracecommander that they cannot fix all race errors while entirely avoiding situations where actions are postponed excessively.
other approaches include rollback recovery replicated execution with different schedules replication of shared state in critical sections or require special hardware which would not be realistic for javascript.
eventhealer unlike most of the work mentioned above considers event driven programs but with a different execution model than the one in javascript execution takes place in a main thread which has lower priority than event handlers and preemption is possible but can be selectively disabled to protect critical sections.
the system uses static analysis to locate event handlers shared variables and fragments of code that should be treated as critical sections which is very different from our setting.
none of the work on automated fixing discussed above targets javascript.
a position paper by mutlu et al.
proposes a notion of schedule shepherding for javascript but does not present any mechanism for how to actually do it.
the recent arrow tool by wang et al.
is the first to automatically repair races in javascript applications.
the key difference to eventracecommander is that arrow is based on static analysis which is notoriously difficult for realworld javascript code.
moreover the main idea in arrow is to identify inconsistencies between the happens before and def use relations which may miss many race errors even if more powerful static analysis were developed.
arrow cannot repair any of the errors in the example application in section ii.
ix.
c onclusion we have presented a general framework for controlling nondeterminism in event driven applications using specified repair policies and proposed application independent policies to prevent nondeterminism that commonly triggers event race errors.
the framework is sufficiently general to repair a wide variety of real world event race errors.
our experimental results show that of event race errors are repairable by our application independent policies and that application specific policies are useful to target specific races when needed.
for future work it will be interesting to automate the process of inferring application specific policies for a given event race to avoid negative impacts from overly general policies.
such candidate policies should restrict the nondeterminism only as needed to repair a given race but still be reasonably general so that they do not only apply to the concrete execution explored by the dynamic race detector.