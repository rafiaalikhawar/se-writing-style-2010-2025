mutation analysis for coq ahmet celik karl palmskog marinela parovic emilio jes us gallego arias and milos gligoric the university of texas at austin mines paristech ahmetcelik utexas.edu palmskog acm.org marinelaparo vic gmail.com e x80.org gligoric utexas.edu abstract mutation analysis which introduces artificial defects into software systems is the basis of mutation testing a technique widely applied to evaluate and enhance the quality of test suites.
however despite the deep analogy between tests andformal proofs mutation analysis has seldom been consideredin the context of deductive verification.
we propose mutationproving a technique for analyzing verification projects thatuse proof assistants.
we implemented our technique for the coq proof assistant in a tool dubbed mcoq.mcoq applies a set of mutation operators to coq definitions of functions and datatypes inspired by operators previously proposed for functional programming languages.
mcoq then checks proofs of lemmas affected by operator application.
to make our technique feasible in practice we implemented several optimizations in mcoq such as parallel proof checking.
we applied mcoq to several medium and large scale coq projects and recorded whether proofs passed or failed when applying different mutation operators.
we then qualitatively analyzed the mutants findingmany instances of incomplete specifications.
for our evaluation we made several improvements to serialization of coq files andeven discovered a notable bug in coq itself all acknowledgedby developers.
we believe mcoq can be useful both to proof engineers for improving the quality of their verification projects and to researchers for evaluating proof engineering techniques.
i. i ntroduction mutation analysis introdu ces small scale modifications to a software system with each modified system version called amutant .
mutation analysis is widely applied to software systems to perform mutation testing where test suites are evaluated on mutants of a system that represent faults introduced by programmers or are designed to give rise to fault like behavior.
if a sp ecific mutant induces test failures the mutant is said to be killed otherwise it is said to be live.
however if a mutant survives all tests this may indicate an inadequate test suite or present avenues to improve tests.
mutants of a system can be produced in a variety of ways a common approach implemented for many programming languages including functional languages such as haskell is to apply mutation operators at a level near the source code syntax e.g.
changing to .
an operator may intuitively represent a particular flaw that programmers are prone tomake such as getting the sign of an integer variable wrong.
formal verification can offer guarantees about program behavior and other properties beyond those of testing.
in particular deductive verification using proof assistants is increasingly used for development of trustworthy large scale software systems .
nevertheless just as test suites may be inadequate formal specifications can fail to account for unwanted program behavior potentially compromising the ability of formal verification to r ule out bugs and leading to lower trust in verified code.although it is regularly applied to unverified software and during lightweight verification mutation analysis has only rarely been considered for proof assistants and to our knowledge never with formal proofs in place of tests.
we propose mutation proving a technique for mutation analysis of verification projects u sing proof assistants suitable for evaluating the adequacy of collections of formally proven properties of programs.
our technique adapts and extends mutation operators previously used to mutate haskell pro grams .
we implemented our technique for the coq proof assistant in a tool dubbed mcoq.
given a mutation operator and a coq project mcoqapplies an instance of the operator to a definition in coq s gallina language and then checks all proofs that could be affected by the change.
a serious obstacle to operator based mutation analysis in proof assistants is the extensibility and flexibility of the syntax used to express functions datatypes and properties.
in particular coq supports defining powerful custom notations over existing specifications and coq s parser can be extended with large grammars at any point in a source file by loading plugins .
these facilities are convenient for expressing mathematical concepts but pose a great challengefor processing of coq files.
moreover definitions of functions and datatypes analogous to classes and methods in java like languages tend to be highly interspersed with proofs whichare analogous to tests .
this precludes simple mutation based on text replacement in source files .
we overcome these challenges by leveraging the ocamlbased s erapi serialization library which is integrated with coq s parser and inte rnal data structures.
we extended coq and s erapi to support full serialization of all coq files used in large scale projects to s expressions sexps .
we apply our mutation operators to the sexps we obtain and then deserialize and proof check the results.
to make mutation proving feasible in practice for large scale coq projects we optimized mcoqin several ways e.g.
to leverage multicore hardware for fast parallel checking of proofs affected by changes after applying a mutation operator.
to evaluate our technique we applied mcoqto several open source coq projects from medium to large scale.
we recorded whether a mu tant was live or killed based on proofs passing or failing and then qualitatively analyzed a subset of mutants unveiling several incomplete specifications.
for our evaluation we enhanced s erapi and fixed several serialization issues significantly increasing its robustness in processing large coq projects.
we also found a notable bug in coq related to proof processing when applying mcoq acknowledged and subsequently fixed by the developers .
ui .
oufsobujpobm pogfsfodf po vupnbufe 4pguxb sf ohjoffsjoh authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
our technique and tool can be useful both to proof engineers for directly analyzing their verification projects and to researchers for evaluating p roof engineering techniques analogously to how mutation testing is used to evaluate testing techniques for functional programs .
we believe mutation proving is largely orthogonal to and complements many other analysis techniques for proof assistants such as bounded testing dependency analysis counter example generation property basedtesting and theory exploration .
specifically these techniques do not consider alternative worlds where definitions are different from the present ones .
we make the following contributions technique we propose mutation proving for verification projects using proof assistants.
we define a set of mutationoperators on definitions of functi ons and datatypes inspired by operators defined previously for functional and imperative programming languages.
t ool we implemented mutation proving in a tool dubbed mcoq which supports coq projects.
our tool brings significant extensions to coq and the s erapi library for serialization and deserialization of coq syntax these extensionspave the way for other transformations of coq code.
optimizations to make mutation proving of large projects feasible in practice we optimized mcoqto make it run faster.
in particular we implemented several novel forms ofselective and parallel checking of proofs for mutants.
evaluation we performed an empirical study using mcoq on large and medium sized open source coq projects.
for each project we recorded the number of generated and killed mutants and the execution time.
we qualitatively analyzed a subset of the mutants and found several incomplete specifications manifested as live mutants.
impact our work resulted in many improvements and bugfixes to s erapi enhancing its robustness when applied to large scale projects and showing that complex extensible coq files can be manipulated in a lightweight way.
we made several modifications to coq itself and these changes have been accepted by coq developers.
we provide supplementary mater ial and artifacts related to mcoqat ii.
b ackground this section provides some brief background on the coq proof assistant the s erapi library and mutation testing.
a. the coq proof assistant coq is a proof assistant based on type theory implemented in the ocaml programming language.
the specification language of coq gallina is a small and purely functional programming language.
proofs about gallina specifications are typically performed using sequences of expressions tacticcalls in coq s proof tactic language ltac .
source files processed by coq are sequences of vernacular commands 1require import arith.
3definition update a st nat a h v a 4fun n ifnat.eq dec n h then velse st n. 6lemma update nop a st nat a y v 7st y v update st y v y st y.
8proof .
9intros unfold update case nat.eq dec auto .
10qed.
12lemma update diff a st nat a x v y 13x negationslash y update st x v y st y.
14proof .
15intros unfold update.
16case nat.eq dec congruence .
17qed.
update.v fig.
example coq source file.
each of which can contain both gallina and ltac expressions.
figure shows an example coq source file which contains a function update and two lemmas about the function.
the intended meaning of update defined on lines is that it returns a new version of a given function stfrom natural numbers to some type a and this returned function maps h tovbut otherwise behaves as st. vernacular syntax is extensible by the user in almost arbitrary ways by defining notations inside coq e.g.
or for the empty list constructor nil and loading plugins in coq that extend syntax.
in particular the ltac language and basic decision procedures for proof automation are implemented as a collectio n of plugins.
since plugins can generally be loaded at any time when interacting with coq the permitted syntax can grow dynamically as a vernacular file is processed.
hence writing a robust stand alone parser for vernacular is difficult and will break easily as coq evolves.
even though coq provides a logic of total terminating functions ltac allows nontermination e.g.
of proof search.
hence modifying a gallina datatype or function may result in infinite loops in analogy with the frequent infinite loops that arise in tests during mutation testing .
the mitigating practice in mutation testing is to assign execution time thresholds for test execution.
similarly we set thresholds to the proof checking time for each mutant.
thecoqc tool compiles source .vfiles to binary .vo files and checks all proofs.
such binary files are then loaded by coq when processing require commands in .vfiles.
b.s erapi and serialization to s expressions serapi is an ocaml library and toolchain for machine interaction with coq .
s erapi has two principal components an interface for serialization and deserialization of coq syntax and internal data structures to and from sexpressions sexps built on ocaml s ppx metaprogramming facilities and a protocol for building and querying coq files that abstracts over vernacular commands.
in effect s erapi overcomes the problem of robustly parsing vernacular by directly integrating with coq s parsing toolchain authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
cif capp cref capp qualid path vcref qualid path nat eq deccref cref qualid path nqualid path hcref qualid n pathcref qualid path st fig.
sexp of if subexpression on line in figure .
and internal datatypes.
since the serialization routines are automatically generated from coq s own definitions usingmetaprogramming s erapi is expected to require only modest maintenance as coq evolves.
before our work the principal application of s erapi was for user interfaces for coq e.g.
web based interfaces .
when mutating coq projects we use the s erapi sexpbased serialization facilities avoiding heavyweight ocamllibrary development.
intuitively a s erapi sexp is either an atom representing a constant or variable name or a list delimited by parentheses.
for example the sexp for the command on the first line in figure is as follows vernacexpr vernacrequire false qualid path arith a more readable but less compact representation of sexps is graphically as trees.
for example the tree in figure provides a simplified illustration of the s erapi sexp for the if subexpression on line in figure .
c. mutation testing and proving we follow papadakis et al.
in using mutation analysis for the process of generating code variants and mutation testing for the application of this process to support software testing and test suite improvement.
in analogy with the latter we refer to the application of mutation analysis to support proof development using proof assistants and improving collections of formally proven properties as mutation proving .
mutation analysis was propos ed by lipton then formalized by demillo et al.
and first applied in practice in the context of software testing by budd et al.
.
in mutation testing test suites that distinguish between a mutant and the original program e.g.
by reporting an assertion violation leaving the mutant killed are judged to meet objectives.
in contrast test suites that do not report assertion violations or other errors for a mutant leaving the mutant live could be judged not to meet objectives and may require revision.
a test suite s mutation score is defined as the percentage of killed mutants out of all mutants that are distinct under functional equivalence .
intuitively mutants may be viewed as containing buggy code and the mutation score as a measure of how well the test suite rules out the presence of buggy code .
how to interpret killed and live mutants in mutation proving is less clear than for mutation testing.
while there may be definitions of functions and datatypes that are nonsensical for mostpurposes a failing proof of a lemma using such definitions does not unambiguously indicate an error or mistake bug in the definitions.
coq proof scripts are often brittle and fail to produce proofs when associated definitions are changed in trivial ways that preserve all their properties.
in addition the goal of a proof assistant verification project may be to prove some lemma unrelated to any specific program.
nevertheless live mutants may still indicate the inadequacy of the verification harness to fully meet reasonable objectives.
in particular live mutants can go far beyond flagging up completely unused definitions as in dependency analysis they can pinpoint that certain fragments of key definitions vacuously satisfy behavioral specifications e.g.
that an ostensibly strong and complete lemma about a function can be proven regardless of what the returned value is for a certain range of inputs to that function.
many live mutants could indicate the presence of such underspecification in a coqproject which may eventually manifest as bugs in executable systems and lead to lower trust in formally verified code.
iii.
t echnique in this section we describe our mutation approach mutation operators and optimizations to mutation proving.
a. mutation approach our approach to mutation proving follows the classical approach of defining a set of mutation operators operator for short which describe cl asses of changes to a project.
intuitively an operator captures a common mistake made by a proof engineer.
when an operator is successfully applied to a project it generates a mutant.
when the mutant has been successfully checked i.e.
all related proofs have passed it isdeclared live.
otherwise if proof checking fails or times out the mutant is considered killed .
since the notion of functional equivalence is not applicable to many verification projects we use a broader definition of mutation score as the percentage of killed mutants out of all mutants that are distinct undersyntactical equivalence .
we define operators for mutation proving as transformations on coq vernacular sexps.
for any transformation and sexp it must be unambiguous and easily checkable whether the transformation can be successfully applied or not to the sexp.
for example if the transformation pertains to particular coq constants it is applicable preci sely when those constants occur in a specific way in the sexp.
note that checking syntactical equivalence of a target and result sexp modulo non essentialauxiliary data such as file line numbers is simple and fast.
the initial step for applying any operator to a coq verification project is to convert all .vsource files to lists of sexps.
for a specific operator opand sexp list the steps are then to apply opsequentially to all list elements until a nonequivalent mutant is generated check the mutated list of sexps check all proofs in files that transitively depend on the source file that was indirectly mutated.
the latter threesteps are repeated for all lists of sexps until no additional mutants can be generated using op.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i list of mutation operators.
category name description generalgib reorder branches in if else expression gic reverse the order of the constructors in the definition of an inductive type gme replace expression in the second match case with the expression from the first match case listslrh replace list with head singleton list lrt replace list with its tail lre replace list with empty list lar reorder arguments to the list append operator laf replace list append expression with first argument las replace list append expression with second argument numbersnpm replace plus with minus nzo replace zero with one nsz replace successor constructor with zeronsa replace successor constructor with its argument booleansbft replace false withtrue btf replace true withfalse 1require import list.
import listnotations.
3fixpoint ftmap a b f a option b l list b 4match lwith a xs 6match fa with none ftmap f xs some b b ftmap f xs 9end 10end.
12lemma ftmap app a b f a option b xs ys 13ftmap f xs ys ftmap f xs ftmap f ys.
14proof .
15induction xs intros simpl in auto .
16case f a eqn ?
simpl auto using f equal.
17qed.
19lemma ftmap in ab f a option b a b xs 20f a some b in a xs in b ftmap f xs .
21proof .
22induction xs simpl auto .
23case f a0 eqn ?
simpl intuition congruence .
24qed.
ftmap.v fig.
example coq source file using lists.
b. mutation operators our inspiration for coq mutation operators came from two sources.
primarily we were inspired by the operators defined by le et al.
for haskell .
secondarily we took inspiration from the operators in mutation frameworks for java such as pit and the major framework .
we considered these operators through the lens of our experience from usingcoq for over years cumulative .
table i lists our operators.
for each operator we give a category a short name which we will use in the rest of text and a short description.
the g eneral category includes operators which are applicable regardles s of whether a project uses a specific datatype from the coq standard library.
the listscategory includes operators which pertain to the ubiquitous list datatype in the standard library.
the numbers categoryincludes operators which appl y to natural numbers in their standard linear size peano encoding e.g.
2is defined as the successor constructor applied two times to the zero constructor .
similarly the booleans category applies to booleans as defined in the standard library.
in contrast to imperative languages such as java where numeric datatypes are typically built in gallina has only a fewnative constructs which is reflected in the limited number of operators in the general category .
other operators require a project to use the corresponding notations and constants fromthe standard library the associated categories therefore pertain to the most elementary and widely used parts of the library.
to illustrate how our operators work we give a few examples using the coq code in figure and figure .
for amore intuitive presentation we describe the effect of operators mostly in terms of the source code rather than sexps.
general mutation example .
applying the operator gib to the file in figure results in one mutant where update has the expressions vandst n swapped on line .
the proof of update nop goes through for the mutant indicating that the lemma does not express any fundamental property of update .
however the proof of update diff fails specifically congruence on line fails killing the mutant.
note that the mutation can be performed at the sexp level by swapping the two rightmost subtrees below cif in figure .
lists mutation examples .
the source file in figure contains a recursive function ftmap lines that applies a given partial function fto a list.
the two accompanying lemmas express some basic properties about the function in particular ftmap app establishes that ftmap distributes over list append.
applying the operator lrh results in a mutant wherethe singleton list has replaced b ftmap f xs on line .
this mutant is killed by ftmap app since this property no longer holds.
applying the operator lrt resultsin a mutant where the tail list expression ftmap f xs has replaced b ftmap f xs on line .
this mutant survives ftmap app but is killed by ftmap in .
c. mutation optimizations mutation analysis is generally acknowledged to be a costly process and this also holds true for mutation proving.
in this section we describe several optimizations to our basic mutation proving approach.
in mutation testing optimizations are generally about generating faster smarter or fewer mutants .
we focus on accomplishing faster mutation and the insight we build on is that proof checking for mutation proving can be viewed as a particular instance of regression proving i.e.
to check an existing coq project after a change has been made similar insights are found in regression testing .
proof selection .
a proof selection technique uses knowledge ofmodi fiedfiles or proofs in a project to only check impacted files or proofs .
since a successful application of a mutation operator means that a sexp file was modified we canuse change impact analysis to perform selective proof checking during mutation proving.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
qmutatorsexp parser transformer.vfile sexp filecoq serapisercomp compser fig.
mcoqimplementation architecture.
proof checking parallelization .
unlike test execution in javalike languages proof checking in proof assistants is determin istic which increases the potential for parallelization on multicore hardware.
in particular coq proof checking is routinely parallelized at the file level where the main restriction on the degree of parallelism is the file dependency graph .
mutation operator parallelization .
since we only perform first order mutation app lication of one mutation operator to a project can be performed completely independently of the application of another operator.
hence when the goal is to apply several operators to the same project the outcomes can be computed in parallel as in mutatio n testing of software .
mutant parallelization .
application of one mutant can be performed completely independently of application of another mutant.
we thus also introduce a parallel mode where each mutant is checked as a separate task.
iv .
i mplementation in this section we describe the components of our mutation proving implementation define and discuss our mutation modes and procedure which use the components and outline the impact of our tool development on other projects.
a. t ool architecture and components our tool for mutation proving dubbed mcoq i si m p l e mented in ocaml java and bash.
figure shows an overview of the architecture of mcoq and highlights how the main components interact.
during mutation proving coq source files to be mutated are first given as input to our sercomp program integrated with s erapi which produces corresponding files with lists of sexps .
the sexps are then handed to our qmutator program which performs parsing and applies the transformations corresponding to a specified mutation operator.
ultimately qmutator outputs mutated sexps 4which become input to our compser program integrated with s erapi .
we next describe each main component of mcoqin detail.
sercomp we implemented a command line program called sercomp on top of s erapi which takes a regular coq .v source file as input and outputs the corresponding lists of sexps.
the program is now included as part of s erapi .
compser we implemented a command line program called compser on top of s erapi meant to be the inverse ofsercomp .compser takes a file with a list of sexps as input and either produces a .vo file or simply checks every sexp.
the program is now included as part of s erapi .
coq fork we forked the v8.
branch of the coq github repository corresponding to coq version .
and modified it to expose internal data structures relevant for mutation proving to s erapi.
we submitted our proposed changes to the coq repository and the developers eventually merged them.
serapi we extended s erapi to provide serialization and deserialization of all coq internal data structures required to support large projects.
in particular we added support for serialization of ltac syntax extensions added by the ssreflect proof language used in many projects.
all of our changes have been added to the s erapi codebase.
qmutator we implemented a library for transformation of sexps produced by sercomp and mutation operators that use this library in java.
we used an existing library jsexp to parse and encode sexps.
based on our experience implementing new operators on top of our library is quick and straightforward.
on top of our library we implemented a program dubbed qmutator that takes sexps and an operator name as input and produces mutated sexps.
runner we implemented a program in java and bash that uses the above components to perform mutation proving on a given coq project and then computes its mutation score.
b. mutation modes and procedure based on the approach and optimizations in section iii we define four basic mutation proving execution modes default a simple mode which checks every file in a project after a mutant is gene rated by compiling .vfiles to .vo files in topological order according to the file dependency graph.
rdeps an advanced mode which checks only .vfiles affected by a mutation and caches and reverts to unmodified .vo files to avoid the cost of generating them more than once.
skip an advanced mode which checks only .vfiles affected by a mutation and additionally avoids reverting .vo files.
noleaves a variant of default which checks proofs in leaf nodes in the file dependency graph but does not generate .vo files for those files.
we added this mode to explore if there were any notable speedups gained by avoiding to write .vo files with compser .
to realize these modes we implemented the parameterized mutation procedure check opshown in figure in our runner program.
in the subprocedures called by check op there are several auxiliary proce dures that behave differently depending on the mode revertfile for the default and skip modes the file vf is always reverted.
for rdeps vfis never reverted.
for noleaves vfis reverted only if it is not a leaf node in rg.
getotherfiles for the default and noleaves modes this procedure returns rg.topologicalsort sv f s v whereas for the rdeps and skip modes the procedure instead returns rg.topologicalsort rg.closure vf v .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm pseudocode of check op.
require op mutation operator require p coq project procedure check op op p vfs p.vfiles g p.dependencygraph rg g.reverse svfs rg.topologicalsort vfs v for vf sv f s do v.add vf check opvfile g r g o p s vfs v v f end for end procedure algorithm pseudocode of check opvfile.
require g dependency graph require rg reverse dependency graph require op mutation operator require svfs topologically sorted .vfiles require v set of visited .vfiles require vf .vfile procedure check opvfile g rg op svfs v vf sf sercomp vf mc countmutationlocations sf op mi while mi mc do msf mutate sf op mi check opsexpfile g rg sv fs v vf msf mi mi end while revertfile vf end procedure algorithm pseudocode of check opsexpfile.
require g dependency graph require rg reverse dependency graph require svfs topologically sorted .vfiles require v set of visited .vfiles require vf .vfile require msf mutated sexp file procedure check opsexpfile g rg svfs v vf msf ifcompser msf negationslash then global.killed global.killed return end if ovfs getotherfiles g rg sv fs v vf revertotherfilesbefore vf ov fs forof ov f s do ifcoqc of negationslash then global.killed global.killed break end if end for revertotherfilesafter vf ov fs end procedure fig.
mutation procedure pseudocode.
revertotherfilesbefore for all modes except skip this procedure does nothing.
for the skip mode it reverts all files ing.closure ov f s ov f s vf with ov f s defined on line in check opsexpfile.
revertotherfilesafter for all modes except rdeps it does nothing.
for rdeps it reverts all files in ov f s .on top of the basic modes we define four parallel modes which we believed could lead to significant speedups parfile this mode builds on skip and parallelizes the for loop in the check opsexpfileprocedure lines to .
parallelization is at the coarse grained file level.
parquick like parfile this mode builds on skip and parallelizes the for loop in the check opsexpfileprocedure lines to .
however parallelization is at the fine grained level of proofs .
parmutant this mode builds on rdeps and checks each mutant in parallel i.e.
we parallelize the while loop in the check opvfileprocedure lines to .
rdeps in this mode we organize the operators into groups of six or less and run groups in parallel using the rdeps mode.
we limit to six groups to match the number of cores available in our evaluation machine.
c. impact of t ool development work on our tool implementation resulted in more than merged code contributions to s erapi.
specifically we found over failing test cases that were all fixed.
our enhancements to coq itself have been merged and are set to be included in the upcoming coq version .
.
release.
when applying mutation provi ng to a project structtact during our evaluation we generated a mutant which we checked with both coqc andcompser the mutant was killed according to the former but not the latter.
the discrepancy was due to a serious bug in coq related to proof processing acknowledged and subsequently fixed by the developers .this shows that mutation proving development has significantly improved general coq tooling.
v. e va l uat i o n we evaluate mcoqby answering four research questions rq1 what is the number of mutants created for large and medium sized projects and what are their mutation scores?
rq2 what is the cost of mutation proving in terms of the execution time and what are the benefits of our optimizations?
rq3 why are some mutants not killed?
rq4 how does mutation proving compare to dependency analysis for finding incomplete and missing specifications?
we run all experiments on a core intel core i7 cpu .20ghz machine with 64gb of ram running ubuntu .
.
lts.
we limit the number of parallel processes to be at or below the number of physical cpu cores.
we next describe the studied projects our independent and dependent variables and our results.
a. v erification projects under study table ii lists the coq projects used in our evaluation all are publicly available.
for each project we show the project name the latest sha at the time of our experiments number of.vfiles total lines of code loc specification loc and proof script loc.
all locs are computed using the coqwc authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii projects used in the evaluation.
project sha files loc spec.
loc pr .
loc atbr 366ac237 fcsl pcm b34fce32 2851flocq 7ec13200 18044huffman mathcomp 91fa7b57 prettyparsing 189a2625 705bin.
rat.
numbers 7b9cc06d 29541quicksort compl.
0a6eed8b stalmarck 6932ed8a coq std 005887ee structtact 82a85b7e tlc 4babc16c avg.
n a .
.
.
.
total n a tool which is bundled with coq.
the last two rows of the table show the average and total values across all projects.
we selected the projects based on compatibility with coq version .
their size and popularity in terms of e.g.
github stars and usage in other coq projects and their inclusion of functions and da tatypes that can be mutated.
b. v ariables independent variables .
we manipulate two independent variables in our experiments operator and execution mode.
for the former we use the operators defined in table i. for the latter we use the execution modes described in section iv b. dependent variables .
we compute three dependent variables mutation score execution cost and cost reduction.
mutation score provides an estimate of the adequacy of formal specifications this metric is computed as the percentage of killed mutants out of the total number of mutants minus the numberof syntactically equivalent mutants.
mutation score is either computed per mutation operator or for all mutants at once.
execution cost is the time needed to pe rform mutation proving this metric can also be reported per mutation operator or for all mutants at once.
cost reduction is the percentage of time saved using various execution modes compared to the time needed to perform mutation proving using the default mode.
c. results rq1 number of mutants and mutation score table iii shows the total number of generated mutants for each pair of project row and mutation operator column .
additionally the last column shows the tota l number of mutants per project and the last two rows show the average and total number ofmutants per mutation operator.
we can observe that gme generates the most mutants followed by nzo and npm.
on the other hand nsz generates the smallest number of mutants followed by nsa.
this indicates that explicit uses of the natural number successor construct or were few for the projects we used in our evaluation.
table iv shows the number of killed mutants for each pair of project and mutation operator.
table v shows the mutation score for all pairs of projects and mutation operators n a indi cates mutation score value thatcannot be computed because the number of generated mutants is zero.
the last column shows the mutation score for all mutants in a given project which is the metric traditionally reported in mutation testing research these mutation scores vary from .
for tlc to .
for huffman .
recall that mutation scores exclude syntactically equivalent mutants.
however including equivalent mutants would affect mutation scores only marginally all but three projects atbr flocq and bin.
rat.
numbers had two equivalentmutants or less.
the gme operator accounted for all equivalent mutants which were due to pattern matching cases returning the same expression.
it is important to note that mutation scores are much higher than traditionally seen in mutation testing research.
we expected such high scores for several reasons.
first as mentioned in section ii c many coq proof scripts are brittle and fail after only trivial changes are made to specifications.second even robust proofs tend to be tightly coupled to functions and datatypes in effect exploring them symbolically rather than relying only on externally observable properties such as outputs.
this is what enables proofs to e.g.
establish properties about all members of infinite sets of datatypeinstances which is impossible for traditional unit tests.
two projects are outliers in terms o f mutation score prettyparsing and tlc and we come back to this below.
finally we analyzed the logs of our runs which record the reason for each mutant being killed and found that only mutants were killed due to timeout.
these two mutants were generated by gme and lrt.
rq2 performance table vi shows the proof checking and mutation proving time in seconds for various execution modes.
specifically the second column shows time to check the project by running the default build commands coqc viamake for each project.
the third column shows time to process all files in a project with sercomp .
recall that we mutate a file by first obtaining the corresponding sexps via sercomp produce a mutant and then use compser to write a.vo file back to disk.
clearly it would be costly to use both sercomp andcompser to proof check all the files in any given project so we use this combination only on the file being mutated.
the fourth column sh ows time to perform mutation proving using the default mode.
the remaining columns show execution time for mutation proving for optimized modes.
due to performing unnecessary proof processing the default and noleaves modes are consistently the slowest typically by a wide margin.
reasonably rdeps and skip give consistent speedups sometimes substantial over the basic modes on average over default .
nevertheless some projects such as huffman show only marginal improvement.
we expected parallel modes to perform better than the advanced sequential modes.
however parfile and parquick were only substantially faster than skip for some large projects such as mathcomp.
this may be due to many mutants being killed quickly before realizing the benefits of parallel checking.
fornearly all projects parmutant is a clear winner over rdeps and others its average speedup over default is .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii total number of mutants for each mutation operator per project.
project gib gic gme lrh lrt lre lar laf las npm nzo nsz nsa bft btf total atbr fcsl pcm f l o c q h u f f m a n mathcomp prettyparsing bin.
rat.
numbers quicksort compl.
stalmarck coq std s t r u c t t a c t t l c avg.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total table iv total number of killed mutant s for each mutation operator per project.
project gib gic gme lrh lrt lre lar laf las npm nzo nsz nsa bft btf total atbr fcsl pcm flocq h u f f m a n mathcomp prettyparsing bin.
rat.
numbers quicksort compl.
stalmarck coq std s t r u c t t a c t tlc avg.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total rq3 qualitative analysis to qualitatively analyze why mutants are killed or live we sampled live mutants to inspect manually.
to ensure diversity among inspected mutants we set a requirement of inspecting or more of all livemutants for each operator and of all live mutants for each project.
due to our familiarity with the project we also decided to inspect alllive mutants in mathcomp.
initially we randomly chose mutants to inspect from the set of all live mutants.
when we had inspected of total we finished the remaining mathcomp mutants and used the distribution among operators and projects for inspected mutants to sample from underrepresented subsets.
in total we inspected live mutants which we labeled with precisely one of the following labels underspecifieddef the live mutant pinpoints a definitionwhich lacks lemmas for certain cases mutants .
danglingdef the live mutant pinpoints a definition thathas no associated lemma mutants .
semanticallyeq the live mutant is semantically equivalent to the original project mutants .
a detailed description of each live mutant with links to their locations in the original source code repositories can be found in the supplementary material at the mcoqwebsite.
here we first highlight some notable live mutants labeled withunderspecifieddef and then discuss our general experience from the analysis.
gib mutant in flocq a mutant swapped the branches in the if else expression of the following function for addition ofbinary ieee floating point numbers definition bplus op nan m x y match x y with b754 infinity sx b754 infinity sy ifbool.eqb sx sy then x else build nan plus nan x y the mutant reveals that a particular case of binary addition namely for numbers represen ting infinities is not considered by any lemma.
another live gib mutant showed the same problem for the analogous definition for subtraction bminus .
bft mutant in structt act a mutant which changed false totrue in a function named before func on lists highlighted that the function was weakly specified in the library fixpoint before func a f a bool g l match lwith a l f a true g a false before func f g l end.
further investigation revealed five general lemmas about before func in verdi raft four of these lemmas kill the mutant.
our changes to factor out all five lemmas to structtact have been merged in both projects.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table v mutation score for each mutation operator per project.
project gib gic gme lrh lrt lre lar laf las npm nzo nsz nsa bft btf total atbr .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
fcsl pcm n a .
.
.
.
.
n a n a n a .
.
n a n a .
.
.
flocq .
.
.
n a n a n a n a n a n a .
.
.
.
.
.
.
huffman n a .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
mathcomp n a .
.
.
.
.
.
.
.
.
.
n a n a .
.
.
prettyparsing .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bin.
rat.
numbers .
.
.
n a n a n a n a n a n a .
.
.
.
.
.
.
quicksort compl.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
stalmarck n a .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
coq std .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
structtact .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
tlc .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table vi proof checking and mutation time in seconds for various modes.
project checking sercomp default rdeps skip n oleaves parfile parquick parmutant rdeps atbr .
.
.
.
.
.
.
.
.
.
fcsl pcm .
.
.
.
.
.
.
.
.
.51flocq .
.
.
.
.
.
.
.
.
.02huffman .
.
.
.
.
.
.
.
.
.
mathcomp .
.
.
.
.
.
.
.
.
.
prettyparsing .
.
.
.
.
.
.
.
.
.21bin.
rat.
numbers .
.
.
.
.
.
.
.
.
.94quicksort compl.
.
.
.
.
.
.
.
.
.
.
stalmarck .
.
.
.
.
.
.
.
.
.
coq std .
.
.
.
.
.
.
.
.
.
structtact .
.
.
.
.
.
.
.
.
.
tlc .
.
.
.
.
.
.
.
.
.
avg.
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
.
lrt mutant in mathcomp in this mutant the last empty list is removed from an auxiliary function used by an implementation of the merge sort algorithm fixpoint merge sort push s1 ss match sswith ss asss s1 ss s s s merge sort push merge s1 s2 ss end.
in essence mutation preserves the functional correctness of sorting.
however the complexity of the sort function changes from o nlogn too n2 .
according to the author of the function in personal communication georges gonthier the key but unstated invariant of ssis that its ith item has size 2i if it is not empty so that merge sort push only performs perfectly balanced merges.
he concluded that without the placeholder the mathcomp sort becomes two elementwise insertion sort.
bft in flocq in this mutant false is changed to true in the following function definition shr 1 mrs let build shr record m r s mrs in let s orb r s in match mwith zneg xo p build shr record zneg p false salthough there are several lemmas about shr 1 below the definition none of them touch this particular match case.
infact there are no lemmas at all about zneg negative integer cases of shr 1 .
this indicates that zneg cases in shr 1 are unused elsewhere and we found that they are actually assumed away implicitly by guards in lemmas.
discussion .
in addition to the live mutants we also analyzed two killed mutants from every pr oject by sampling uniformly at random all were killed by a nearby proof same file .prettyparsing and tlc have the lowest mutation scores of all projects .
and .
respectively.
we expected the utility libraries coq std tlc and structtact to have relatively low scores due to the greater number of functions and datatypes than in more focused projects.
the relatively high score of coq std despite its size in terms of loc may indicate that most definitions are extensively specified.
to corroborate this the main author of coq std emphasized in personal communication that he consistently proves several lemmas about each new definition added to the library.
the main author of tlc explained in personal communication that in contrast to coq std key lemmas about tlc definitions are sometimes placed in other projects for reasons of convenience.
the relatively low score of prettyparsing likely stems from that its main theorem that deserializing serialized prettified data gives correct results authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table vii number of definitions found by dependency tools with various parameters.
project grep defusage total atbr fcsl pcm flocq huffman mathcomp prettyparsing bin.
rat.
numbers quicksort compl.
stalmarck coq std structtact tlc does not take into account most details on how prettification is done through functions modified by live mutants .
rq4 comparison to dependency analysis as mentioned in section ii c dependency analysis is used by proof engineers to analyze their verification projects and may highlight some unused definitions similar to those we labeled danglingdef.
to enable comparing mutation proving with dependency analysis we used the coq dpdgraph plugin to obtain for each project a dependency graph of all definitions and lemmas and a list of the names of all definitions.
we also extended dpdgraph to produce a tool dubbed defusage that counts edges todefinitions in graphs.
as a simple baseline we used grep to record the number of matches for each definition in each project s .vfiles.
the first three columns in table vii show the project name and number of definitions that had exactly one and more than one match respectively with grep .
these can be compared to those in the last column which show the total number of definitions.
as a more robust alternative we used defusage on the dependency graph of each project with three thresholds in terms of number of incoming edges unused and .
columns four to six in table vii show the number of definitions at or below each threshold for all projects.
the large discrepancies between the second and fourth columns of table vii indicate that the grep baseline is both unsound and incomplete for some projects such as atbr it finds only a fraction of all unused definitions while for e.g.
mathcomp it finds too many unused definitions.
more importantly none of the definitions changed by the live mutants we manually analyzed were included among the definitions in the second column grep .
we conclude that the grep baseline is unusable for finding incompletely specified functions and datatypes.
while defusage produces sound and complete lists of unused definitions the lists are typically long and contain a large percentage of all definitions even with threshold e.g.
for mathcomp making it hard to apply in practice.
among definitions changed by the l ive mutants we labeled with underspecifieddef and danglingdef only out of all labeled danglingdef are found among those in columnfour .
we conclude that mutation proving finds many more fundamental flaws in coq verification projects than dependency analysis and does so in a more informative systematic and less noisy way.
vi.
t hreats to validity external .
our results may not generalize to all coq projects.
to mitigate this threat we chose popular projects that differ in size number of proofs and proof checking time.
as our infrastructure builds on coq .
we could only use projects that work with this coq version.
we report results for a single hardware platform and results may differ if experiments are run elsewhere.
we ran all our experiments on two platforms but we reported results only for one of them more modern due to space limitations.
although absolute numbers differ across platforms our conclusions remain unchanged.
we only analyzed a subset of killed and live mutants in our qualitative study.
our findings could differ if we had inspected a different set or more mutants.
we mitigate this threat by systematically sampling mutants for inspection.
internal .
our implementation of the tool and or scripts may have bugs.
to mitigate this th reat we performed extensive unit testing of our code.
we also checked that results were thesame across modes and that execution time differences were negligible across several runs.
finally during our qualitative analysis we validated the outcome of each mutant we studied.
construct .
our work targets only coq.
nevertheless many mutation operators described in section iii b e.g.
all operators in the lists category are applicable to projects using otherproof assistants such as lean and isabelle hol .
however more research is needed to develop an extensive set of mutation operators and evaluate mutation proving for other proof assistants and deductive verification tools.
vii.
l imitations and future work mutation operator design .
we implemented and experimented with a mutation operator for changing the order of cases in a pattern matching expression inspired by le et al.
.
however mutants generated by this operator were nearly always killed immediately stillborn since coq pattern matching branches tend to be completely unambiguous and the strong type system does not permit leaving out matching cases.
this illustrates the problem of defining general operators for gallina as opposed to operators using the standard library e.g.
additio n for peano arithmetic.
a highly idiomatic coq project may benefit from using specialized operators for the libraries it depends on.
scope of mutation .
we do not consider mutation of lemma statements or of ltac proof scripts.
the main reason is that we then would largely lose the analogy between mutation proving and mutation testing since mutation of test code is not performed in the latter.
inductive predicates which are a special form of inductive datatypes are arguably borderline cases but we included them for mutation based on their established interpretation as cut free higher order prolog programs .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
equivalence and mutation scores .
mutation testing traditionally uses functional equivalence of programs in its definition of mutation score which makes score calculation undecidable in general and usually necessitates using heuristics to filter out equivalent mutants .
in contrast this equivalence is only one of many that may be considered when defining mutation score for coq projects.
we implemented checking of syntactical equality at the vernacular level which preserves proofs but is highly discriminating.
it is also possible todefine and compute scores using coq s least discriminating decidable notion of equivalence that always preserves proofs convertibility or using a project specific equivalence.
however checking convertibility is costly and only two of the live mutants we labeled semanticallyeq were convertible.
alternative mutation approaches .
while our operators are defined and applied at the level of vernacular syntax s erapi also supports serialization of data added during the elaboration phase of type checking in coq.
additional operators can potentially use this information to perform sophisticated type preserving changes to coq definitions.
however such operators may intuitively no longer capture mistakes that are made by proof engineers which our operators aim at viii.
r elated work since to our knowledge ours is the first evaluation of mutation analysis for proof assistants we contrast with mutationanalysis in similar settings and other analysis techniques.
mutation testing of functional programs .l ee ta l .
implemented a mutation t esting framework for haskell called mucheck which applies mutation operators nondeterministically at the level of abstract syntax trees.
cheng et al.
used mucheck to evaluate different types of test coverage for haskell programs.
dureg ard proposed a black box approach to mutation testing of haskell code on top of the quickcheck framework.
the function under test must be an instance of a specific type class that allows it to be mutated without modifying it in place .
braquehais and runciman presented a haskell framework fitspec that uses mutation testing to measure adequacy of sets of properties specified in property testing frameworks such as quickcheck.
fitspec takes a black box view of mutations and uses instanceenumeration to produce mutants.
on one hand black box mutation can be applied in a wider context than operator bas ed mutation e.g.
to functions associated with native code.
on the other hand black box mutation sometimes requires defining explicit functions that return mutants.
while black box mutation can be implemented in coq we believe the purity of gallina makes its advantages modest compared to operator based mutation.
mutation of specifications .
we took inspiration from groce et al.
who use mutation analysis to improve the process of verification based on model checking.
ball and kupferman consider the concept of vacuity in verification and testing which can be established through mutation of systems and their specifications.
mutation proving is intuitively similar to but more general than their notion of vacuity in softwarechecking.
efremidis et al.
p resented a mutation framework for prolog with operators reminiscent of ours.
analysis and testing in proof assistants .
berghofer and nipkow first considered random testing to assist users ofisabelle hol to specify and verify programs.
bulwahn subsequently improved the isabelle testing facilities.
a testing framework for coq dubbed quickchick was proposed by paraskevopoulou et al.
and lampropoulos and pierce describe mutation testing in that framework.
blanchette and nipkow presented a count erexample generator for isabelle hol.
cruanes and blanch ette later presented a general tool nunchaku for counterexample generation and showed how to adapt it to dependent type theories like coq s. johansson proposed a tool for theory exploration in isabelle hol called hipster which attempts to prove interesting facts from a given set of definitions.
testing and generation as in quickchick and nunchaku can analyze specific functions and datatypes to find problematic inputs but lack the connection to proofs that mcoqhas.
moreover the above techniques do not consider alternative worlds with different definitions and are thus largely complementary to mutation proving.
for example hipster could be appliedto mutants to reveal facts that are consequences of alternative definitions generated by mcoq.
ix.
c onclusion we proposed mutation proving a technique for analyzing verification projects that use proof assistants.
we implemented our technique for the coq proof assistant in a tool dubbed mcoq.mcoqapplies a set of mutation operators to coq definitions of functions and datat ypes inspired by our experience and operators previously defined for functional programming languages.
mcoqthen checks proofs of lemmas affected by operator application.
to mak e our technique feasible in practice we implemented several optimizations in mcoqsuch as parallel proof checking.
we applied mcoqto medium and large scale coq projects and recorded whether proofs passed or failed when applying different mutation operators.
we then qualitatively analyzed the failed proofs finding several examples of incomplete specifications.
moreover our work has already had significant impact on coq tooling and our tool helped to uncover a bug in coq itself.
we believe that mcoqcan be extended in a number of ways and already be useful for many practical tasks.
we are looking forward to see mcoqused by proof engineers for improving the quality of their verification projects and by researchers for evaluating new proof engineering techniques.