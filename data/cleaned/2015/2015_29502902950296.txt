on demand strong update analysis via value flow refinement yulei sui jingling xue school of computer science and engineering unsw australia abstract we present a new strong update analysis for c programs called supa that enables computing points to information on demand via valueow re nement in environments with small time and memory budgets such as ides.
we formulate supa by solving a graph reachability problem on a valueow graph representation of the program so that strong updates are performed where needed as long as the total analysis budget is not exhausted.
supa facilitates e ciency and precision tradeo s by allowing di erent pointer analyses to be applied in a hybrid multi stage analysis framework.
we have implemented supa in llvm and evaluated supa by choosing uninitialized pointer detection as a major client on open source c programs.
as the analysis budget increases supa achieves improved precision with its single stage ow sensitive analysis reaching of that achieved by whole program ow sensitive analysis by consuming about .
seconds and 36kb of memory per query on average with a budget of at most valueow edges per query .
ccs concepts software and its engineering software veri cation and validation software defect analysis theory of computation program analysis keywords strong updates value ow pointer analysis ow sensitivity .
introduction strong updates where stores overwrite i.e.
kill the previous contents of their abstract destination locations with new values is an important factor in the precision of pointer analysis .
in the case of weak updates these locations are assumed conservatively to also retain their old contents.
a pointer analysis is ow sensitive if it respects control ow and ow insensitive otherwise and contextsensitive if it distinguishes di erent calling contexts and context insensitive otherwise.
a ow sensitive analysis canstrongly update an abstract location written at a store if and only if that location refers to exactly one concrete memory address.
by applying strong updates where needed an analysis can improve precision thereby providing signi cant bene ts to many clients such as change impact analysis bug detection security analysis type state veri cation compiler optimization and symbolic execution .
in this paper we investigate how to perform strong updates e ectively in analyzing large c programs for which ow sensitivity is important in achieving the precision required by the afore mentioned client applications.
for object oriented languages like java context sensitivity is essential in achieving useful precision .
ideally strong updates at stores should be performed by analyzing all paths independently by solving a meet over allpaths mop problem.
however even with branch conditions ignored this problem is intractable due to potentially unbounded number of paths that must be analyzed .
instead traditional ow sensitive pointer analysis fs for c computes the maximal xed point solution mfp as an over approximation of mop by solving an iterative dataow problem.
thus the dataow facts that reach a con uence point along di erent paths are merged.
recently sparse ow sensitive pointer analysis sfs boosts the performance of fs in analyzing large c programs while maintaining the same strong updates done by fs.
the basic idea is to rst conduct a pre analysis on the program to over approximate its def use chains and then perform fs by propagating the dataow facts i.e.
points to information sparsely along only the pre computed def use chains aka valueows instead of all program points in the program s controlow graph.
recently an approach for performing strong updates in c programs is introduced.
it sacri ces the precision of fs to gain e ciency by applying strong updates at stores where ow sensitive singleton points to sets are available but falls back to the ow insensitive points to information otherwise.
by nature the challenge of pointer analysis is to make judicious tradeo s between e ciency and precision.
virtually all of the prior analyses that consider some degree of owsensitivity are whole program analyses.
precise ones are unscalable since they must typically consider both ow and context sensitivity fscs in order to maximize the number of strong updates performed.
in contrast faster ones like are less precise due to both missing strong updates and propagating the points to information ow insensitively along all the weakly updated abstract locations.
in practice a client application may require only parts of the program to be analyzed.
in addition some queries may demand precise answers while others can be answered as permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
artifact evaluated by fse program pre analysis value flows stage on demand reachability solverqueries out of budget ?
stagesstage stage efficiencyprecision....budgetsnoyesselect ii refinefigure overview of supa precisely as possible with small time and memory budgets.
in all these cases performing strong updates blindly across the entire program is cost ine ective in achieving precision.
for c programs how do we develop precise and e cient pointer analyses that are focused and partial paying closer attention to the parts of the programs relevant to on demand queries?
existing demand driven analyses for c and java are ow insensitive and thus cannot perform strong updates to produce the precision needed by some clients.
in addition recent advances in whole program ow sensitive analysis for c have exploited some form of sparsity to improve performance .
however how to replicate this success for demanddriven ow sensitive analysis is unclear.
finally it remains open as to whether sparse strong update analysis can be performed both ow and context sensitively on demand to avoid under or over analyzing.
in this paper we introduce supa the rst valueow based demand driven strong updateanalysis for c designed to support exible yet e ective tradeo s between e ciency and precision in answering client queries in environments with small time and memory budgets such as ides.
as shown in figure its novelty lies in performing strong update analysis precisely by re ning imprecisely precomputed valueows away in a hybrid multi stage analysis framework.
given a points to query strong updates are performed by solving a graph reachability problem on an interprocedural valueow graph that captures the def use chains of the program obtained conservatively by a pre analysis.
such over approximated valueows can be obtained by applying andersen s analysis ow insensitively .
supa conducts its reachability analysis on demand sparsely along only the pre computed valueows rather than controlows.
in addition supa lters out imprecise valueows by performing strong updates where needed with no loss of precision as long as the total analysis budget is su cient.
the precision of supa depends on the degree of valueow re nement performed under a budget.
the more spurious valueows supa removes the more precise the nal results are.
supa handles large programs by staging analyses in increasing e ciency but decreasing precision in a hybrid manner.
presently supa proceeds in two stages by applying fscs andfsin that order with a con gurable budget for each analysis.
when failing to answer a query in a stage within its alloted budget supa downgrades itself to a more scalable but less precise analysis in the next stage and will eventually fall back to the pre computed ow insensitive information.
at each stage supa will re answer the query by reusing the points to information found from processing the current and earlier queries.
by increasing the budgets used in the earlier stages e.g.
fscs supa will obtain improved precision via improved valueow re nement.
p a q c a b c d t1 p p q q t1 p a q c x b y d p x q y t1 p t2 q p t2 q t1 a c code b partial ssa pqacbdpqacbd c before swap d after swapswapswapfigure a swap example and its partial ssa with the points to relations for pandqat run time this paper makes the following contributions we present the rst strong update analysis for c that enables computing precise points to information ondemand with strong updates applied where needed by re ning away imprecisely precomputed valueows subject to analysis budgets.
we introduce a hybrid multi stage analysis framework that facilitates e ciency and precision tradeo s by staging di erent analyses in answering client queries.
we have produced an implementation of supa in llvm with its artifact available at .
we choose uninitialized pointer detection as a practical client using open source c programs.
as the analysis budget increases supa achieves improved precision with its single stage ow sensitive analysis reaching of that achieved by whole program ow sensitive analysis by consuming about .
seconds and 36kb of memory per query on average with a per query budget of at most valueow edges traversed .
.
background we describe the partial ssa form used for representing a c program and the sparse valueow graph used for representing conservatively its valueows i.e.
def use chains.
.
partial ssa form we represent a program by putting it into llvm s partial ssa form following .
the set of all variablesvare separated into two subsets acontaining all possible targets i.e.
address taken variables of a pointer andtcontaining all top level variables wherev tya.
after the ssa conversion a program is represented by ve types of statements p a addrof p q copy p q load p q store andp pq rq phi .
toplevel variables are put directly in ssa form while addresstaken variables are accessed indirectly via load orstore .
passing arguments into and returning results from functions are modeled by copies.
for an addrof statementp a known as an allocation site ais a stack or global variable or a dynamically created abstract heap object.
figure shows a swap program in c and its corresponding partial ssa form where p q x y t t2ptanda b c dpa.
here x y t andt2 are new temporaries introduced.
.
sparse value flow graph given a program in partial ssa form a sparse valueow graph svfg g pn eqis a multi edged directed graph z t3 a a program and its svfg withonly indirect value flows shown d the supa analysis for resolving pt l16 z i bytraversing from l16 z backwards against the value flows l16 q y p a t2 q t3 p z t3 y d v i p t2 t3 v t3 w q c su for d su for a su for cl1 l2 l4 l6 l8 l9 l12 l13 l14 l15 l16 paqcbdiut3z b flow sensitive points to relations found to hold at the end of the program with some for top level pointers omitted direct value flow indirect value flow points tospurious points topaqcbdiut3zswap t3 v t3 w t3 p v i w u q t1 p t2 t2 q t1 p q y p x y d x b q c p a l1 l2 l3 l5 l6 l7 l8 l4 l10 l9 l14 l15 l13 l11 l12 c flow insensitive points to relations with some for top level pointers omitted spurious value flowsxxx p x xl5 .querypt l16 z ?figure a motivating example for illustrating the supa analysis with su standing for strong update that captures its def use chains conservatively.
nis the set of nodes representing all statements and eis the set of edges representing all potential def use chains.
in particular an edge 1v wherevpv from statement 1to statement 2signi es a potential def use chain for vwith its def at 1and use at .
this representation is sparse since the intermediate program points between 1and 2are omitted.
as top level variables are in ssa form their uses have unique de nitions with functions inserted at con uence points as is standard .
a def use chain 1t wheretpt represents a direct valueow oft.
such def use chains can be found easily without requiring pointer analysis.
as address taken variables are not yet in ssa form their indirect uses at loads may be de ned indirectly at multiple stores.
we can build their def use chains in several steps by following with an illustrating example given in section .
first the points to information in the program is computed by a pre analysis.
second a load p qis annotated with a function paqfor each variable apathat may be pointed to by qto represent a potential use of aat the load.
similarly a store p qis annotated with a function a paqfor each variable apathat may be pointed to by pto represent a potential def and use of aat the store.
if a can be strongly updated then areceives whatever qpoints to and the old contents in aare killed.
otherwise amust also incorporate its old contents resulting in a weak update toa.
third we convert all the address taken variables into ssa form with each paqtreated as a use of aand each a paqas both a def and use of a. finally we obtain the indirect def use chains for an address taken variable apa as follows.
for a use of aidenti ed as an with its versionidenti ed by n at a load or store its unique de nition in ssa form is anat a store .
then an indirect def use chain 1a is added to represent potentially the indirect valueow ofafrom 1to .
note that the functions introduced for address taken variables will now be ignored as the value athat appears in 1a is not versioned.
.
a motivating example our example program shown in figure a is simple even with lines .
the program consists of a straightline sequence of code with 10taken directly from figure b and the six new statements 16added to enable us to highlight some key properties of supa .
we assume thatuat 11is uninitialized but iat 12is initialized.
the svfg embedded in figure a will be discussed later.
we describe how supa can be used to prove that zat 16points only to the initialized object i by computing on demand the points to query ptpx zyq i.e.
the points to set of zat the program point after which is de ned in in section .
figure b depicts the points to relations for the six address taken variables and some top level ones found at the endof the code sequence by a whole program ow sensitive analysis with strong updates like sfs .
due to owsensitivity multiple solutions for a pointer are maintained.
in this example these are the true relations observed at the end of program execution.
note that sfs gives rise to figure c by analyzing figure d by analyzing also and nally figure b by analyzing 16further.
aszpoints toibut notu no warning is issued for z. figure c shows how the points to relations in figure b are over approximated ow insensitively by apply462ing andersen s analysis .
in this case a single solution is computed conservatively for the entire program.
due to the lack of strong updates in analyzing the two stores performed byswap the points to relations in figures c and d are merged causing aand cto become spurious aliases.
when 16are analyzed the seven spurious points to relations shown in dashed arrows in figure c are introduced.
since zpoints toi correctly and u spuriously a false positive for zwill be issued.
failing to consider owsensitivity andersen s analysis is not precise for this client.
let us now explain how supa shown in figure works.
supa will rst perform a pre analysis to the example program to build the svfg given in figure a .
for its toplevel variables their direct valueows i.e.
def use chains are explicit and thus omitted to avoid cluttering.
for example qhas three def use chains 2q 2q 8and 2q .
for its address taken variables we rst apply andersen s analysis to nd ow insensitively their points to relations which are given in figure c .
we then obtain the nine indirect valueows i.e.
def use chains depicted in figure a as described in section .
let us see how the two def use chains for bare created.
as t3 points to b 15and 16will be annotated with b pbq b pbqand pbq respectively.
by putting bin ssa form these three functions become b2 pb1q b3 pb2qand pb3q.
hence we have 14b 15and 15b indicating bat 16has two potential de nitions with the one at 15overwriting the one at .
the def use chains for dandaare built similarly.
let us consider a single stage analysis with stage stage fsin figure .
figure d shows how supa computes ptpx zyqon demand starting from by performing a backward reachability analysis on the svfg with the visiting order of def use chains marked as .
formally this is done in figure .
the def use chains for only the relevant top level variables are shown.
by ltering out the four spurious valueows marked by supa nds that onlyiat 12is backward reachable from zat .
thus ptpx zyq tiu.
so no warning for zwill be issued.
supa di ers from prior work in three major aspects on demand strong updates a whole program ow sensitive analysis like sfs can answer ptpx zyqprecisely but must accomplish this task by analyzing all the statements resulting in six strong updates at the six stores with some done unnecessarily for this query.
unfortunately existing whole program fscs or even just fs algorithms do not scale well for large c programs .
in contrast supa computes ptpx zyqprecisely by performing only three strong updates at 9and .
the earlier supa performs a strong update during its reachability analysis the fewer the number of statements traversed.
after supa nds thatt3 points todonly.
with a strong update done at t3 v supa concludes that ptpx zyq tiu.
value flow re nement existing demand driven analyses are ow insensitive and thus su er from the same imprecision as their ow insensitive whole program counterparts.
in the absence of strong updates many spurious aliases such as aand c result causing ztopoint to both iandu.
as a result a false positive for zis issued as discussed earlier.
however supa performs strong updates owsensitively by ltering out the four spurious precomputed valueows marked by .
ast3 points to donly 15b 16is spurious and not traversed.
in addition a strong update is enabled at t3 v rendering 14b 15and 14d 15spurious.
finally 5a 9is re ned away due to another strong update done at .
thus supa has avoided many spurious aliases e.g.
aand c introduced ow insensitively by pre analysis resulting in ptpx zyq tiuprecisely.
thus no warning for zis issued.
query based precision control to balance e ciency and precision supa operates in a hybrid multi stage analysis framework.
when asked to answer the query ptpx zyqin say three steps supa will stop its traversal from 9to at4 in figure d and falls back to the pre computed results by returning ptpx zyq tu iu.
in this case a false positive for zwill end up being reported.
.
demand driven strong updates we introduce our on demand strong update analysis figure .
we rst describe our inference rules in a owsensitive setting section .
.
we then discuss our contextsensitive extension section .
.
finally we examine our hybrid multi stage analysis framework section .
.
all our analyses are eld sensitive as discussed in section .
.
.
formalism flow sensitivity we present a formalization of a single stage supa consisting of only a ow sensitive fs analysis.
given a program supa will operate on its svfg representation gvfgconstructed by applying andersen s analysis as a pre analysis as discussed in section .
and illustrated in section .
letv l vbe the set of labeled variables lv where lis the set of statement labels and v tya.supa conducts a backward reachability analysis ow sensitively ongvfgby computing a reachability relation v v. in our formalism x vy x v1ysigni es a valueow from a def ofv1at 1to a use ofvat through one or multiple valueow paths in gvfg.
for an object ocreated at an addrof statement i.e.
an allocation site at identi ed as x oy we must distinguish it from x oyaccessed elsewhere at in our inference rules.
our abbreviation for x oyispo.
givenx vy supa computes ptpx vyq i.e.
the points to set ofx vyby nding all reachable target objects po ptpx vyq to x vy pou despite ow sensitivity our formalization in figure makes no explicit