oa uth lint an empirical study on oauth bugs in android applications tamjid al rahat dept.
of computer science university of virginia u.s.a tr9wr virginia.eduy u feng dept.
of computer science university of california santa barbara u.s.a yufeng cs.ucsb.eduy uan tian dept.
of computer science university of virginia u.s.a yuant virginia.edu abstract mobile developers use oauth apis to implement single sign on services.
however the oauth protocol was originally designed for the authorization for third party websites not to authenticate users in third party mobile apps.
as a result it is challenging for developers to correctly implement mobile oauth securely.
these vulnerabilities due to the misunderstanding of oauth and inexperience of developers could lead to data leakage and account breach.
in this paper we perform an empirical study on the usage of oauth apis in android applications and their security implications.
in particular we develop oa uth lint that incorporates a query driven static analysis to automatically check programs on the google play marketplace.
oa uth lint takes as input an anti protocol that encodes a vulnerable pattern extracted from the oauth specifications and a program p. our tool then generates a counter example if the anti protocol can match a trace of ps possible executions.
to evaluate the effectiveness of our approach we perform a systematic study on popular apps which have more than millions of downloads.
the evaluation shows that out of applications that use oauth apis make at least one security mistake.
index terms security oauth android static analysis bug finding i. i ntroduction the oauth protocol has been widely used for mobile developers to implement single sign on services.
for example many mobile game developers use oauth to implement authentication with user s major accounts in google twitter or facebook.
however the oauth protocol was originally designed for the authorization for third party websites in not to authenticate users in third party mobile apps.
since the security implications for authentication and authorization are fundamentally different and mobile platforms have different security schemes comparing to the browsers it is challenging for developers to implement the oauth protocols in mobile platforms securely.
recent years many widespread attacks for the oauth implementation in popular mobile applications have been reported causing users to lose their accounts or information.
for example facebook has a bug for the insecure storage of oauth tokens which exposes a large number of user accounts to attackers .
studying such a critical and popular multiparty protocol will also provide insight for building other multi party protocols securely.due to the complexity of the oauth protocol it is challenging to implement it in a secure way.
in particular there are three parties in oauth the user who owns protected resources the service provider that hosts the user s services and the relying party that uses the service provider to get access to the user s resources or authenticate the user.
during authorization the three parties need to verify each other s identity and synchronize their secure states.
however despite wide deployment the oauth protocol is still too complicated for most developers to follow.
for example as we mentioned earlier oauth was first designed for authorization but not for authentication .
therefore the use case for authentication is not clearly defined in the original specification.
as a result developers may misunderstand the threat model and security implications in oauth which leads to vulnerabilities that compromise user privacy.
in the meantime the original oauth .
protocol was first proposed for websites and then got widely used in mobile applications.
however many security schemes cannot be directly mapped from the web to mobile platforms.
therefore mobile application developers make many mistakes for using the oauth protocol.
although an oauth protocol typically involves multi parties i.e.
user relying party and service provider in this paper we mainly focus on studying bugs in the relying parties and developing techniques for automatically finding those bugs.
the ultimate goal is to provide a tool for helping developers to write secure authentication using the oauth protocol.
we focus on the relying parties for several reasons.
first comparing to the very few identity providers such as google or facebook there are tens of thousands of relying parties in android platforms and the developers of the relying parties contribute a majority of the common mistakes in using the oauth protocol .
as a result it is important to develop tools for helping numerous relying parties to check the security of their oauth implementations.
second mobile applications of most of the relying parties are publicly available through google play store.
in contrast the implementations of most of the identity providers are not available to us and we can only approximate their behaviors through black box testing .
previous studies have identified many security issues of the mobile oauth implementations by manual or semi automatic analyses.
however the entire process is very 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
time consuming and error prone as it requires security experts with domain knowledge in oauth to inspect the implementations manually.
on the other hand there are several challenges for automatically finding oauth vulnerabilities in android platforms.
first verifying oauth implementation requires precisely modeling the data and control properties of mobile applications which are highly asynchronous and interactive.
second to precisely reason about the oauth vulnerabilities in mobile applications our system has to consider the interactions among multiple parties i.e.
service provider relying party sdk etc and the majority of their implementations are not available.
finally a system would need a specification for finding the oauth vulnerabilities however the specification of the latest oauth .
protocol has over pages which are extremely difficult to digest by developers.
to understand the oauth vulnerabilities in relying parties and help mobile developers to write secure code using oauth we perform the first empirical and systematic study on popular android applications from google play.
in particular we propose oa uth lint the first static analyzer for checking anti protocols i.e.
vulnerabilities in oauth implementation.
first we present a simple but effective query language for describing common anti protocols in oauth implementations.
here each anti protocol is a class of vulnerabilities in oauth implementation.
second we perform a thorough study on specifications of the existing oauth protocols and summarize five common anti protocols .
third given an anti protocol expressed in our query language we leverage a fully automatic and demand driven static analysis to identify the anti protocols that appear in the android applications from the relying parties.
formally speaking an anti protocol for program pis true iff matches a trace of p primes possible executions.
our system will return a counter example if the specified antiprotocol configuration is feasible in the application.
most of the anti protocols that we check are logical flaws due to the misunderstanding of the oauth protocol.
because of the misunderstanding of the security implications of the oauth protocol the developers can make logical errors that compromise user privacy.
for example in the oauth .
implicit flow the bearer token represents that a user grants a set of permissions to an application.
by its design the bearer token is bound to the user and the set of permissions but not to the application.
therefore if developers just verify the bearer token it s not secure to authenticate the user because a malicious application might get the bearer token and reuse it in the oauth process of another application to gain access to the user s account.
to evaluate the effectiveness of our approach we perform a systematic study on popular applications which have more than millions of downloads.
our evaluation shows that for those popular apps that use oauth api more than of them contain at least one anti protocol.
for those anti protocols identified by oa uth lint we also reported them to the developers of corresponding mobile applications and get acknowledged by companies such as wordpress and gofundme.user .
req token .
req token .
user grants permission .
req token .
.
access token .
.
protected resourceverifies signature verifies signature verifies signature1.
service provider relying party the secret is only known between the relying party and service providerrelying party s web server fig.
overview of oauth .
.
contributions.
in summary this paper makes the following key contributions we devise a simple but effective query language for expressing common anti protocols that violate the oauth specification.
we propose five anti protocols that widely appear in the implementations of relying parties.
given an anti protocol expressed in our query language we design a demand and query driven static analysis for checking violations in the mobile applications from the relying parties.
we implement our proposed ideas in oa uth lint and evaluate it on over popular applications from google play.
our result shows that more than of the applications contain at least one anti protocol.
ii.
b ackground the concept of oauth protocol was proposed in and was designed as an authorization protocol which contains two major oauth versions that are currently deployed oauth .
and .
.
the first version of the oauth protocol oauth .
was published in april .
since then the protocol has gone through a few revisions.
the most notable changes to the protocol were released as the oauth .
framework in october .
a. oauth .
oauth .
was released for around years however some service providers such as twitter are still using oauth .
.
we illustrate the oauth .
protocol flow in fig.
.
the dashed lines in our figures for oauth represent redirection and solid lines represent direct server to server api calls e.g.
a rest api call .
also parameters inside square brackets are signed using shared secrets.
we summarize the oauth .
flow in the following initialization relying party developers will need to register with the service provider and obtain shared secrets consumer secret and consumer key .
the shared secrets will be used in the following steps to sign packets and verify the signatures.
unauthorized request token step first the relying party gets a request token from the service provider using a direct server to server call.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
authorized request token step then the relying party redirects the user to the service provider in mobile devices it is done by inter process communication such as intent in android with the request token as a uri parameter.
then the user grants the relying party access to their protected resource and is redirected back to the relying party.
access token step with the request token authorized the relying party can exchange the request token for an access token using another direct server to server call with the service provider.
note that these two steps are very critical for the security of oauth .
.
the relying party needs to sign the packet with the shared secret consumer secret key and the service provider needs to verify the signature to check the identity of the relying party.
protected resource step finally the relying party can use the access token to obtain the users protected resource.
b. oauth .
instead of building on top of the existing oauth .
protocol the working group changed the specification completely to create a different protocol known as oauth .
.
compared to oauth .
oauth .
removed obtaining the shared secrets and providing signature as mandatory processes.
instead oauth .
introduced the concept of bearer token .
for the bearer token a users access token was no longer bound to a relying party any party with this token could access the users protected resource.
in addition oauth .
also offers four different flows these methods are referred to as grants and they can be viewed as different versions of oauth .
.
out of the four oauth grants the most popular one is the implicit grant.
in the following we will use fig to explain the most popular implicit grant of oauth .
.
the implicit grant is the shortest of all oauth .
flows.
it consists of two steps.
first the user is redirected to the service provider to grant the relying party access to his her protected resource.
after the user grants the permission the service provider redirects the user back to the relying party along with an access token as a parameter in the uri.
the relying party can then use this access token to exchange for the users resource.
besides the implicit grant we find that the authorization code grant is also used in mobile applications we studied.
comparing to the implicit grant the authorization code grant has additional steps for the relying party to obtain an authorization code and then use the authorization code to exchange for the token.
there are two important differences in the implicit grant comparing to other oauth flows.
first with exception to the final protected resource request every message in the protocol is exchanged through the user agent e.g.
using browser redirection or android intent .
second the implicit grant does not require the relying party to present a shared secret to theuser service provider relying party .
user grants permission .
access token .
access token .
protected resource1.
app id resource type redirect uri verifies redirect uri the receiver of the access token must be the same as the registered redirect uribrowser redirection http fig.
overview of oauth .
.
secret tokens android apktaint analysis points to analysisprogram facts oauthlint secret callgraph callgraph taint ow anti protocols in oauth andddroid fig.
overview of oa uth lint.
service provider.
this is ideal for the mobile environment where the relying party resides on an untrusted device.
c. using oauth for authentication although oauth is originally designed for authorization developers re purposed it for authentication.
therefore the way to do authentication using oauth is never documented in the oauth standard protocol and developers have to figure out their own ways to run the authentication using oauth.
typically they just changed the last step of the oauth protocol using the user s resources to identify the user.
some service providers such as google and facebook recognized the limitation of using oauth for authentication and propose additional steps of verification to improve the security such as the appsecret proof .
iii.
o verview in this section we give an overview of our approach with the aid of a motivating example and then summarize the threat model in our system.
a. system overview fig.
gives a high level overview of oa uth lint s architecture.
in particular oa uth lint incorporates standard pointer and taint analyses to explicitly track sensitive information e.g.
secret keys access tokens etc.
in oauth protocols.
a pointer analysis given the source code or bytecode of an android application oa uth lint leverages f low droid to perform field and object sensitive pointer analysis to build a precise call graph and identify all variables that may be an alias to each other.
the call graph and alias authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
information are further used by the subsequent taint analysis for generating additional program facts that are relevant to answering the anti protocols in oauth.
b taint analysis the taint analyzer leverages the annotations in oa uth lint s configuration file to determine taint sources i.e.
secret keys and access tokens and propagates them using a field and object sensitive analysis.
intuitively a taint flow encodes that a sensitive field e.g.
secret keys may flow to an untrusted resource e.g.
local storage webview etc.
.
c anti protocols for oauth to find logical flaws due to the misunderstanding of the oauth protocol oa uth lint first proposes a query language that enables developers to specifyanti protocols .
these anti protocols represent the oauthimplementation mistakes by developers that may result in severe vulnerabilities such as impersonation attack and users privacy violation.
here each anti protocol is expressed as a logical formula which encodes a class of vulnerabilities that compromise user s security and privacy.
section v includes detailed explanation and security impacts of five anti protocols that widely appear in existing android apps in google play store.
while we propose five anti protocols using the query language in oa uth lint a security expert can come up with more anti protocols based on her insight on the standard oauth specifications.
after that using the program facts generated by our previous analyses oa uth lint leverages a fully automatic and demand driven static analysis for checking whether there exists an execution trace such that the antiprotocol holds.
if so a violation will be reported to the developer.
for instance tiktok a very popular app for creating and sharing short videos has over million installs by the time of our submission.
to integrate the user accounts from service providers such as facebook instagram and google tiktok implements the standard authentication flow using the oauth .
protocol .
however after running oa uth lint ontiktok we found the application contains multiple logical flaws in their implementation for the oauth protocol.
firstly tiktok bundles its consumer key and secret within the application code.
the following code snippet from tiktok represents one of the most common ways that developers use to bundle their secrets 1final string consumer key yywjet ... 3final string consumer serect w981h5bed ... ... according to the specification in oauth .
the consumer secrets or keys should never be bundled in the clients.
the reasons are as follows first the consumer secrets are highly sensitive information shared between service providers and relying parties and service providers will use consumer keys to verify identities of the relying parties.
second all mobiles devices are technically untrusted which means that an attacker could extract the consumer secrets through reverseengineering and impersonate a benign replying parties to get access to users information.
moreover tiktok embeds a webview to retrieve the access token attached with the redirect url from twitter and instagram.
1string url provider.com ..?
client id .. redirect url .. response token ... 6webview.loadurl url 8void onpagestarted string url string token parsetoken url when an application hosts service provider s website inside a webview it gets full access to the information such as users cookies.
therefore using webview for oauth enables a malicious relying party app to log into a victim user s account with the service provider.
this is due to the fundamental design of isolation in webview and there is no way for the service provider to protect herself when it was loaded in webview.
often service providers use long term cookies which makes such vulnerability persistent.
furthermore oa uth lint also detects that tiktok exchanges its access token with service providers to fetch the corresponding userid for login purpose.
1string user id fetchuserinfo token consumer secret 3storeinsharedpreferences user id token ... 6authorizeuserlogin user id login this approach is also vulnerable because any requests made from a client could be potentially tampered by an attacker.
hence for authentication using oauth client devices should not be trusted.
according to oauth .
and .
a secure authentication should be made through server to server calls.
finally after obtaining the userid tiktok stores both userid and access token as plain text in the sharedpreferences.
here there are multiple security issues.
first information stored in sharedpreferences is insecure since they can easily be accessed by another malicious application in a rooted device or emulator.
hence any sensitive information should not be stored in sharedpreferences.
second storing sensitive information such as access token as plain text is insecure.
according to the suggestion from oauth .
and .
the access tokens should be encrypted and stored on the server side of the relying party.
we have reported all the above mentioned flaws to tiktok s security team and they are still working on those issues by the time of this submission.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. threat model in this paper we focus on the vulnerabilities in the design and implementation of the relying parties for using oauth protocols.
we assume the service providers are trusted and correctly implement the security schemes for oauth.
for the attacks to authentication we consider the case where an attacker has the capability of accessing the mobile apps on behalf of the victims.
for the attacks to authorization we consider the case where malicious relying parties seek to access user s data without consensus.
iv .
a nalysis this section describes oa uth lint s static analyses for computing an over approximation of some built in predicates that encode the data and control dependency of a program.
in what follows we first give some background on datalog and then describe the syntax and semantics of oa uth lint s built in predicates.
a. datalog preliminaries a datalog program consists of a set of rules and a set of facts .
facts simply declare predicates that evaluate to true.
for example parent bill mary states that bill is a parent of mary.
each datalog rule is a horn clause defining a predicate as a conjunction of other predicates.
for example the rule ancestor x y parent x z ancestor z y .
says that ancestor x y is true if both parent x z andancestor z y are true.
in addition to variables predicates can also contain constants which are surrounded by double quotes or don t cares denoted by underscores.
datalog predicates naturally represent relations.
specifically if tuple x y z is in relation a this means the predicate a x y z is true.
in what follows we write the type of a relationr x y ... as s1 x s y ... wheres1 s2 ...are descriptive texts for the corresponding domains.
base facts.
the base facts of our inference engine describe the instructions in the application s control flow graph cfg .
the base facts take the form of a y x ... x n where ais the instruction name yis the variable storing the instruction result if any and x1 ... x nare variables given to the instruction as arguments if any .
for example the instruction r1 is encoded to assign r1 .
further the special local store instruction lstore d v denotes that the value of vis stored in location d. flow to predicates .
the flowto predicate is defined over pairs of variables and is inferred from the application s cfg.
the intuitive meaning also summarized in fig.
is flowto x1 x2 holds for x1andx2if the value of variable x2 depends on the value of x1.
oauth specific predicates .
in addition to base facts from programs oa uth lint also defines a list of predicates that are specific to the oauth domain.
as shown in fig.
istoken x denotes that xmay be an access token.flowto x y alloc y x flowto x y assign y x flowto x z assign y x flowto y z flowto x z alias y z flowto x y fig.
rules for computing the flow to predicate.
here the alias predicate alias is directly obtained from f low droid .
since it is difficult to precisely pinpoint strings that corresponds to access tokens we use both pattern matching i.e.
regular expressions and domain specific knowledge i.e.
api that may return an access token to over approximate the domain of access tokens.
similarly client secret is encoded as issecret x .
furthermore statement y new secretkeyspec x which is used to construct a client secret is represented as secretkeyspec y x .
finally islocalstore x represents a location for local store which can be android sharepreferences or file systems.
istoken x xmay be an access token issecret x xmay be a secret webview x xis the url of a webview secretkey y x secretkeyspec y x http y x yis an http object of which arguments contain x lstore x z islocalstore x flowto z x login x y login with user x and password y fig.
rules for computing the oauth related predicates.
v. a nti protocols in oa uth this section describes oa uth lint s anti protocol language which is a datalog program augmented with builtin predicates.
we propose five anti protocols that widely appear in existing mobile apps and formalize them using our language.
to identify the pattern of these anti protocols we manually reverse engineered android apps from google play store.
the anti protocols are designed with android and java apis and therefore are not biased with any particular application.
for each anti protocol the user defines a unique predicate that serves as the signature for this anti protocol.
in what follows we first describe the syntax of oa uth lint s built in predicates and then discuss five common antiprotocols in oauth.
a. an anti protocol language for oauth we first introduce our anti protocol language for oauth shown in fig.
.
here arg reg and mem are variables from function arguments registers and memory respectively.
the predicate flowto determines the data dependency between two variables as specified in section iv.
finally we can express more complex queries by composing simple expressions with logical operators i.e.
etc.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
vi arg reg mem ... flowto v1 v2 istoken v1 issecret v1 secretkey v1 v2 http v1 v2 v3 lstore v1 v2 webview v1 login v1 v2 fig.
the anti protocol language in oa uth lint.
user .
req token .
req token .
user grants permission .
req token .
.
access token .
.
protected resourceverifies signature verifies signature verifies signature1.
service provider relying party the relying party bundle this secret into their mobile apps which enables attackers to impersonate them and get user data.relying party s mobile application fig.
vulnerability of locally bundled client secret oauth .
flow.
parameters inside the square brackets are typically signed by client secret.
b. common anti protocols in oauth locally bundled client secrets relying party secret which is often referred to as the client secret by oauth .
and consumer secret by oauth .
is used by service providers to authenticate the relying party.
developers can obtain the relying party secret from the developer s console of the service providers when they register their application.
many developers misunderstand the purpose of the relying party secrets and store them locally on client side applications.
if a developer bundles the relying party secret with her mobile application an attacker can easily retrieve it through reverse engineering and use this secret to get her own application to be authenticated by the service providers as a benign application.
fig.
use oauth .
as an example to illustrate the vulnerability of locally bundled client secret.
relying party gets the client secret from the service provider when it registers for the oauth service and the client secret is then used to generate the signature from the token in step .
since the service provider verifies the signature to check the identity of the relying party if the relying party bundles the secret in their mobile app the attacker can do simple reverse engineering to extract the client secret and impersonate the relying party i.e.
victim to access the user s protected resources.
in practice oa uth lint identifies that many developers bundle their relying party secrets as field variables resource files or constants in their application code.
for instance here is an example from the gofundme application which hard codes its secret for communicating with twitter 1string consumer secret qfmu9 ... 3mac mac.getinstance hmacsha1 4key encodeparam consumer secret 5mac.init new secretkeyspec key.getbytes hmacsha1 7httpurlconnection c 8new url url .openconnection 9params new arraylist 10params.add signature getsignature mac token .. ... 13r c.getinputstream the locally store client secrets can be encoded as the following anti protocol in oa uth lint issecret x secretkey y z flowto x z http u flowto y u in addition to the above scenario developers also store relying party secrets in android sharedpreferences which is also insecure 1string appsecret getappsecret 2sharedpreferences sf getactivity .getpreferences mode 4sharedpreferences.editor editor sf.edit 6editor.putstring app secret appsecret 8editor.commit since the data in sharedpreferences are stored in the file system an attacker can access the secret by other malicious applications if the device is rooted.
oa uth lint uses the following anti protocol for checking this variant issecret x lstore z flowto x z where lstore represents all untrusted locations.
using webview for oauth transactions using webview for oauth transactions is insecure because webview breaks the isolation between the service provider and the relying party.
when a malicious relying party hosts the service provider s website in the webview of their mobile applications the malicious relying party can get the user s cookies to log in on behalf of the user.
fig.
illustrates an example of using webview for facebook login.
webview enables the hosting app malicious relying party to access the cookies of the service provider such as facebook.
with the cookies the malicious relying party can log in on behalf of the user.
this attack can be persistent if the service providers such as google and facebook use long term cookie for better user experiences which is quite common.
in practice we found many developers use embedded webview or mobile browsers for user redirection in oauth which endangers user privacy.
for example here is a code snippet from the waplog application 1webview webview 2string url provider.com ..?
client id .. redirect url .. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
webview provides the feature that app can get the cookies from the webview it embeds facebook uses long term cookie even inside webview and attacker can reuse the cookie to log in as the user.
fig.
vulnerability of using webview for oauth transactions.
response code ... 7public void oncreate webview.loadurl url using webview for oauth transactions can be encoded as the following anti protocol issecret x istoken y webview z flowto x z flowto y z client side api call client devices should not be trusted during api calls that are involved in the flows for oauth authentication.
in other words relying parties should always assume that any requests made from client devices could be tampered by the attackers.
unfortunately in reality developers often misunderstand the security implication and assume that the access token granted by the service providers are only bounded to the relying party.
as a result an attacker could leverage the access token granted for some malicious applications and login as a user for other benign applications to access other sensitive information.
for example the topface application exchanges access token for user id by api call from the application to authenticate users.
1string url api.provider.com .. 2httpurlconnection c 3new url url .openconnection 4c.setrequestmethod post ... 6params new arraylist 7params.add oauth consumer key client id 8params.add oauth token access token 9params.add oauth signature getsignature client secret ... 11c.setrequestproperty authorization createheaders params 12string user id 13parsejson c.getinputstream id 14newuserlogin user id we express the client side api call vulnerability using the following anti protocol istoken x issecret y http r u login v flowto x u flowto y u flowto r v storing access tokens on client devices by the end of a typical oauth transaction the relying party receives an access token which is a raw string that can be used to make api calls to retrieve protected resources from the service provider.
stealing access token provides an ideal vector through which an attacker can compromise user accounts and harvest confidential data such as email and contacts.
some service providers e.g.
google also allow access to user s files stored in the cloud via access tokens .
more importantly an access token does not require user s password and is capable of bypassing any two factor authentication.
to make things worse the only way to revoke an attacker s access is to explicitly revoke access to the malicious application that uses the access token to launch attacks.
thus having access token obtained by attackers could have an adverse impact on users.
during u.s. presidential election in one of the tactics attackers used was collecting oauth access tokens as reported by security experts from fireeye.
our analysis finds that many developers often do not encrypt their raw access tokens before storing them to client devices using sharepreferences or files in the external storage.
this is insecure as data in sharedpreferences or filesystem and can easily be accessed from any rooted device or an emulator.
for example the chatous application stores the access token received from instagram as follows 1string atoken getaccesstoken 2sharedpreferences sf getactivity .getpreferences mode 4sharedpreferences.editor editor sf.edit 6editor.putstring access token atoken 8editor.commit storing access token on client devices can be encoded as the following anti protocol istoken x lstore u flowto x u sending raw access token to server to make serverto server api calls during oauth transactions developers send the access token to the relying party server.
however if a raw i.e.
unsigned access token is sent to the backend server a modified client application can send arbitrary access token and initiate an impersonation attack.
a client device is assumed to be untrusted when oauth is used for authentication.
thus instead of making api call directly a mobile application should communicate with its own backend server and pass the access token to the server.
the server would then use the access token to make api calls to communicate with the resource server of the corresponding service provider.
however it is important for developers to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
understand that access tokens are portable.
once an access token is received it can be used from both applications and server to fetch users resources.
thus sending an unsigned access token to the server can lead to token hijacking .a n example from the wish application that sends the raw access token to the backend server is given below 1string atoken getaccesstoken 2httpclient httpclient new defaulthttpclient 4httppost httppost new httppost backend.com tokensignin 6params new arraylist 7params.add new basicnamevaluepair access token atoken 9httppost.setentity new urlencodedformentity params 12httpclient.execute httppost sending raw access token to server can be encoded as the following anti protocol istoken x http u flowto y u google recently added a security notice to address this vulnerability in their official documentation .
to authenticate users on google s backend servers they recommend developers to send id token returned by googlesigninaccount.getidtoken which is signed by google s public keys.
if backend server receives sensitive information such as access token in plain text a modified application can send an arbitrary token to the server and thereby initiate an impersonation attack.
vi.
e xperimental ev alua tion to evaluate the effectiveness of oa uth lint we conduct a series of experiments to answer the following questions how effective is oa uth lint at identifying real world vulnerabilities in oauth implementations?
how prevalent are those anti protocols discussed in section v?
how do the real world oauth vulnerabilities look like?
a. data collection to find the current scenario of vulnerable implementation of oauth we have analyzed latest android applications shown in table i collected from google play store.
our unbiased selection of applications includes top free applications from all categories top free social applications and top free communication applications.
the reason why we include more applications in the social and communication category is that these applications are usually more likely to use oauth.
most applications use oauth sdks from service providers such as google and twitter.
table iii shows the detail of the statistics.
all applications were collected in april .our analysis found that out of the applications use oauth with at least one service provider.
we built a sootbased sanitizer that automatically analyzes the dalvik bytecodes to filter out applications not using any relevant classes or apis provided by the service providers.
we included most popular service providers for this sanitization step.
category apps apps oauth apps vulnerable top free social communication total table i top android applications using oauth b. results oa uth lint successfully analyzed in total applications that use at least one oauth service provider.
among the remaining applications applications did not use any oauth implementation and applications ran out of memory during the analysis.
in average total runtime for each application was .6seconds and maximum memory consumption was .06mb during the analysis.
all results mentioned here are in reference to the successfully analyzed applications.
table ii lists the number of vulnerable applications for different oauth vulnerabilities.
total vulnerable applications with distinct number of vulnerabilities are illustrated in fig.
.
we discuss the results for each vulnerability below locally bundled client secrets.
oa uth lint successfully identified applications that bundle the consumer key secret of at least one service provider within the application code.
we found applications bundled twitter consumer key and secret applications bundled the client id and client secret from instagram applications bundled the facebook app secret and applications bundled the consumer keys secrets from other service providers in the source code.
using webview for oauth transactions.
this vulnerability is a common scenario for the application that implements oauth in an embedded webview for the web based service providers.
by hosting the service provider s website in the webview of the relying party s mobile applications the relying party can interact with the service provider easily.
in addition a malicious relying party can access the user s cookies in the service provider website to log into the user s account.
oa uth lint successfully identified 24applications who use webview for the authorization and authentication transactions of oauth.
9applications choose to implement the web based oauth version instead of app based version even though corresponding service providers provide official sdk particularly for app based oauth implementation.
client side api call.
when using oauth for authentication developers should pass the encrypted access token received from the relying party application to the backend server of the same relying party and then should verify the access token with the service provider by server to server api call.
oa uth lint identified 69applications that violated this authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
secure approach and performed the authentication by making client to server api call.
for authentication client device should not be trusted as an api call made from the client side could be tampered by a malicious user.
storing access token on client device.
oa uth lint identified 21applications that stores plain i.e.
unencrypted access token in android sharedpreferences .
access tokens are portable which means an access token obtained from a relying party application can also be used from any client server or otherwise.
hence if malicious attackers retrieve the access token from a client device they can use it from a different machine to launch an impersonation attack.
storing sensitive access token in insecure sharedpreferences gives partial security as data stored in sharedpreferences can be easily accessed by any applications or user from a rooted device or emulator.
android provides a keystore system to enhance the security for storing such sensitive information such as access token.
sending raw access token to server.
right after obtaining the access token at the authorization endpoint relying party application should send the access token to their backend server in order to exchange it for user s resources i.e.
user id .
however to this end relying party server should not trust data received from the application.
a malicious attacker could modify the application to tamper the access token and hence initiate an impersonation attack to the relying party server.
oa uth lint identified applications that send the plain access token to the relying party server.
finally we note that the analysis in oa uth lint is precise.
as shown in table ii the average false positive rate is .
we manually inspected the false alarms and confirmed that most of them are caused by the imprecision of the pointer analysis and call graph construction.
vulnerability apps fp locally bundled client secrets using webview for oauth transactions client side api call storing access token on client device sending raw access token to server table ii oauth vulnerabilities in top android applications oauth api total apps vulnerable apps oauth1.
or .
facebook .
google .
twitter .0a .
table iii statistic of top oauth apis in our evaluation c. case studies cbs sports.
to estimate the impact of vulnerable implementations of oauth we manually inspected the applications that were reported as vulnerable by oa uth lint.
cbs sports is one of the most popular applications in u.s. for top sports news scores and videos.
according to google play this application was installed more than millions times.
this application got flagged by oa uth lintfig.
number of applications with ... vulnerabilities.
for three reasons.
first it bundles the twitter consumer key and consumer secret within the application code which makes it vulnerable for impersonation attack with the authorization transactions of oauth.
secondly it uses an embedded webview for oauth transactions between relying party application and service provider.
currently there exists no secure way for the web based service provider to deliver the sensitive oauth data to the honest relying party application.
hence using webview for oauth transactions makes it very difficult for the service provider to determine the identity of the cbs sports application.
thirdly the application uses client side api calls to authenticate new users.
client device must not be trusted during the oauth transactions for authentication since corresponding api calls could be tampered by malicious users.
topface.
we also performed a thorough inspection with topface one of the most popular social application in google play.
this application allows users to meet new people online and was installed more than million times.
however topface provides authentication using oauth for various service providers including google facebook instagram and vkontakte.
the application was flagged by oa uth lint for several reasons.
even though it provides secure intent based oauth transactions for google and facebook it uses webview for both authorization and authentication transactions for instagram and vkontakte.
more importantly it performs all api call for oauth transactions from client to server instead of server to server call which allows a malicious user to tamper sensitive information such as access token and user id .
the application also stores plain access token user id and email address in the sharedpreferences without any encryption.
storing these sensitive information in sharedpreferences gives partial security since any data stored in sharedpreferences can be easily accessed from any rooted devices and emulators.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
vii.
r ela ted work since oauth is a critical protocol for authentication and authorization many researchers have studied the implementation of oauth and discovered many prominent attacks for web applications .
in recent years mobile developers also use oauth to build authentication or authorization schemes and they have many misunderstandings of the security implications of oauth.
researchers also did field studies to identify the vulnerabilities due to the implementation errors of oauth in mobile apps.
chen et al.
present a comprehensive study on implementation errors and misunderstandings regarding oauth protocols in mobile applications.
their study also shows that over of mobile oauth implementations have at least one vulnerability.
also shehab et al.
analyze source codes of android applications and demonstrate possible attacks in oauth implementation.
however these studies depend on dedicated manual analysis by security experts such as inspecting the network traffic and inferring the protocol flows and cannot be scaled to large scale studies.
furthermore researchers also studied user s privacy risks during oauth transactions comparing to these works our system is designed to automatically identify the vulnerabilities of mobile oauth implementations efficiently and effectively.
realizing that oauth is a critical problem researchers also propose solutions to improve the security of oauth.
for example yang et al.
s work is the most relevant one they build an automatic testing tool using symbolic execution to check the correctness of popular oauth sdks and identified vulnerabilities.
in comparison our study focuses on the implementation errors of the relying party because the developers of the relying parties are more easily to misunderstand oauth and make mistakes comparing to the developers of popular sdks.
researchers also propose to run automatic traffic analysis to identify oauth implementation errors however this kind of approach will fail to point out the details of the implementation errors.
compared to their work oa uth lint can identify the details of the implementation errors which is very helpful for the developers to fix the security issues.
wang et al.
propose a tool that combines static analysis and network analysis to identify oauth bugs however their tool is semi automatic and requires manual work to identify the vulnerabilities .
applying formal analysis to the oauth protocols is also another way to improve the security of the protocols .
however though these papers elegantly model the oauth protocol the level of abstraction in these papers make it difficult to detect implementation errors.
detecting implementation mistakes in recent years researchers have been studying the problem of implementation errors in many security applications such as ssl and crypto libraries.
for example cryptolint did a systemic analysis of the incorrect usage of crypto api and ssllint did program analysis to identify the errors of implementing ssl.
moreover researchers also utilized demand driven static analysis for other domains.
arzt et al.
present flowdroid a static taint analysis tool designed to identify data leaksin android applications.
feng et al.
implement a tool to answer a class of interprocedural control flow queries about java programs.
martin et al.
present a query language pql that uses context sensitive pointer alias analysis to mine information e.g.
bugs from a program.
sridharan et al.
introduce a demand driven points to analysis algorithm that outperforms the previous techniques.
feng et al.
s work implements a semantic based approach that identifies an android malware that leaks the user s private information.
compared to these papers oa uth lint needs to overcome more challenges because oauth is a multi party protocol and we don t have access to the data from all parties.
viii.
b est security practice for oa uth relying party according to our analysis of the oauth relying party implementation suffers from at least one vulnerability.
we hope this study can help to provide more guidelines for the mobile oauth developers especially for the relying party developers.
for securing the oauth protocol there are two general major points be aware that the security of oauth partially lies in its access token delivery methodology never trust the mobile client because it might belong to a malicious user who can access the secret data and temper the verification results or data.
for example if developers are developing oauth .
in android instead of using the default intent scheme to deliver the access token they should use the developer key hash in order to check the identity of the party that receives the token.
if developers are developing oauth .
they also need to make sure they can verify the token receiver s identity correctly.
the relying party should never bundle the developer s consumer secret and consumer key into its mobile app because a malicious user can just extract the secret and key from the app and pretend to be the relying party to access user data.
for using oauth to do authentication the relying party needs to be more careful about dealing with the users.
first the relying party must not bundle any security related protocol logic e.g.
security checks or any sensitive information e.g.
the token into its own mobile application.
second the relying party must assume that the attacker could tamper with any data sent from the users device.
because of this the relying party must check that the relying party receiving the users id in the last step of the protocol is the same relying party that the user intends to authenticate to.
for example instead of using the default implicit flow of oauth .
for authentication the relying party should do an additional verification step such as described in the appsecret proof flow of facebook oauth guidelines .
ix.
d iscussion like any other program analysis tool oa uth lint has a number of limitations oa uth lint proposes a query language that helps developers to define oauth based anti protocols.
in this paper we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
explore five anti protocols each of which represents a class of vulnerabilities in oauth implementation that widely appears in android apps.
however defining a new anti protocol that covers a wide range of vulnerable implementation scenarios may seem tedious for a security expert.
also applications having complex logical implementation flaws may still be undetected by oa uth lint.
in addition to that service providers typically allow developers to make certain changes in security settings of the developer s panel.
cross checking between program facts in relying party apps and security settings in developers panel is beyond the limit of oa uth lint.
x. c onclusions and future work in this paper we propose oa uth lint the first static analyzer for checking anti protocols i.e.
vulnerabilities in mobile oauth implementation.
we propose five anti protocols that widely appear in mobile apps and formalize them using our query language.
furthermore we leverage a fullyautomatic and demand driven static analysis to identify antiprotocols that appear in the android apps from the relying parties.
to evaluate the effectiveness of our approach we perform a systematic study on popular apps which have millions of downloads.
our evaluation shows that for those popular apps that use oauth api more than of them contain at least one anti protocol.
for those anti protocols identified by oa uth lint we also reported them to the developers of corresponding mobile apps.
there are several future directions that we plan to explore.
first we will develop techniques to automatically repair android apps that have vulnerabilities in their oauth implementations.
second we are also very interested in applying program synthesis to perform a correct by construction paradigm for oauth implementations.
in that case developers only need to specify the oauth specifications using a highlevel domain specific language and let the synthesizer generate the implementations.