test migration between mobile apps with similar functionality farnaz behrang and alessandro orso georgia institute of technology atlanta usa behrang gatech.edu orso cc.gatech.edu abstract the use of mobile apps is increasingly widespread and much effort is put into testing these apps to make sure they behave as intended.
to reduce this effort and thus the overall cost of mobile app testing we propose a pptest migrator a technique for migrating test cases between apps in the same category e.g.
banking apps .
the intuition behind a pptest migrator is that many apps share similarities in their functionality and these similarities often result in conceptually similar user interfaces through which that functionality is accessed .
a pptest migra tor leverages these commonalities between user interfaces to migrate existing tests written for an app to another similar app.
specifically given a test case for an app source app and a second app target app a pptest migrator attempts to automatically transform the sequence of events and oracles in the test for the source app to events and oracles for the target app.
we implemented a pptest migrator for android mobile apps and evaluated it on a set of randomly selected apps from the google play store in four different categories.
our initial results are promising support our intuition that test migration is possible and motivate further research in this direction.
index t erms test migration gui testing mobile apps i. i ntroduction mobile apps are used on a daily basis to perform a number of tasks such as reading the news accessing social media and shopping.
it is therefore important to thoroughly test these apps to gain confidence that they behave as intended when used in the field.
manually developing test cases for an app tends to be extremely expensive as it involves human effort to define test cases and check test results.
we believe that the cost of testing mobile apps can be reduced by considering similarities between apps and migrating test cases across similar apps.
more precisely this work is motivated by the intuition that although guis for different apps can differ dramatically there are many cases in which apps share similarities that result in conceptually similar guis .
typical examples of this situation are apps that belong to the same category such as banking applications which share much of their functionality and may provide guis that are inherently similar.
it is worth noting that migrating test cases is different in nature from and mostly orthogonal to input generation.
whereas input generation aims to produce inputs based on some criteria e.g.
coverage goals test migration has the potential to generate test cases that exercise specific scenarios that developers considered to be of interest for the functionality under test .based on our intuition we defined a pptestmigrator app test migrator a technique for migrating test cases i.e.
test inputs and oracles between apps that share part of their functionality.
a pptestmigrator takes as input a source app a test case for the source app source test and a target app and produces as output the source test migrated to the target app target test .
to do so it records both the sequence of gui events generated and the assertions checked by the source test migrates events and assertions to the target app using a similarity metric based on a combination of techniques and generates a target test case based on the migrated events and assertions.
there is a good amount of recent work including our own that shares a similar intuition and proposes approaches for exploiting commonalities in the functionality of different apps and improve gui test generation e.g.
.
in fact this paper builds on the vision and ideas that we proposed in earlier work and extends guit estmigrator our approach for migrating test cases between student apps developed based on identical specifications .
specifically apptestmigrator extends our earlier work in a number of ways and addresses several limitations that hinder the effectiveness of guit estmigrator when migrating tests between apps that do not have identical specifications but simply share part of their functionality.
first while evaluating guit estmigrator for use in this context we realized that its success rate was inversely correlated to the number of events in the tests i.e.
the higher the number of events the higher the chances of getting lost during dynamic exploration or crawling .
to address this issue a pptestmigrator migrates each event independently from other events while crawling a target app.
second a pptestmigrator incorporates the use of static analysis to prune the search space by taking into account the possible future states of the app which can further improve the effectiveness of the approach.
third apptestmigrator improves the way in which guit estmigrator computes the similarity between app entities and between events across apps.
for the former a pptestmigrator builds an app ontology that captures the semantic similarity between words using word embeddings produced by word2vec and leverages all available textual information e.g.
labels content descriptions hints .
for the latter a pptestmigrator uses a new approach that is not based on the similarity of actions 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
or types associated with events but rather on the targets of the event actions.
f ourth unlike guit estmigrator apptestmigrator can migrate oracles in addition to test inputs.
migrating oracles for app tests involves understanding how developers write such oracles in practice and defining a technique that can map them across apps accordingly.
this is particularly challenging as there are typically multiple ways to find a counterpart for an oracle in a target app but it can make the approach considerably more useful in practice tests that are successfully migrated together with their oracles can in fact also detect failures that do not result in crashes.
to evaluate a pptestmigrator while also assessing its improvements over previous work we implemented it in a tool that supports android apps and test cases written using the espresso testing framework .
we then used our tool to migrate test cases for apps in four categories shopping list note taking expense tracking and weather .
more precisely we evaluated a pptestmigrator on apps per category apps overall randomly selected from the google play store and and test cases for the categories.
we used both the test cases provided with the apps when available and additional test cases written by cs graduate students not involved in this research.
for each category we then considered each app as a source app and the remaining apps as target apps which resulted in a pptestmigrator attempting to migrate over test cases.
overall a pptestmigrator fully migrated and partially migrated of the tests considered.
for of the fully migrated tests it also fully migrated their oracles.
we also summarize these results in terms of individual events and oracles migrated.
on average a pptestmigrator was accurate for of the events considered that is for of the events it either successfully migrated them or did not migrate them when they had no counterpart in the target app .
for the remaining events a pptestmigrator either matched them to the wrong event or did not match them when a matching was possible .
as for oracle migration a pptestmigrator was accurate for of the oracles considered that is for of the oracles it either successfully migrated them or did not migrate them when they had no counterpart in the target app .
for the remaining oracles a pptestmigrator either matched them incorrectly or did not match them when a matching was possible .
note that we considered measuring a pptestmigrator s effectiveness also in terms of coverage and fault detection ability of the migrated tests.
we decided against it because we believe that a meaningful and fair computation of these metrics would be extremely difficult as we discuss in section v. in addition to assessing a pptestmigrator s performance in isolation we compared its effectiveness with that of guit estmigrator so as to assess whether our extensions resulted in actual improvements in practice.
in addition to not supporting oracle migration at all guit estmigrator was outperformed by a pptestmigrator in terms of both full test migration percentage points improvement and accu racy in individual event migration percentage points improvement .
we also manually inspected all the cases in which apptestmigrator outperformed guit estmigrator to understand which of our extensions to guit estmigrator played a role in improving the effectiveness of the approach.
as a result of this analysis we found that considering events independently while crawling a target app using static analysis to prune the search space and using a new approach to compute similarity between entities and events across app accounted for a pptestmigrator s improvements in and of the cases respectively.
we believe that these results are promising as they show that a considerable number of test cases can be successfully migrated between apps that share only partial functionality and were developed in a totally independent way.
the results support our intuition that test migration is possible and motivate further research in this direction.
in particular our technique should generally be applicable to any gui based software including web apps.
in addition if the effectiveness of test migration were confirmed by further studies this could support the compelling idea of a test store that operates in parallel with a traditional app store when developers submit an app the test store could analyze the app look for similar ones migrate tests from these apps and return all the tests that were successfully migrated.
we believe that this is a realistic scenario as many developers already provide test cases in public repositories including for apps also available in app stores e.g.
wordpress .
the benefit of getting additional tests in return may further motivate developers to create and share tests.
in general migrated tests could be provided as a service or used as an extra check before an app is published.
this paper makes the following contributions a new technique for migrating test cases including oracles between apps that share part of their functionality.
an implementation of the technique for the android platform that is publicly available together with our experimental data and infrastructure .
an empirical evaluation that provides initial yet strong evidence of the effectiveness and potential usefulness of our technique and that shows its improvements over the state of the art.
ii.
b ackground and terminology mobile apps are largely tested through their guis guibased testing aims to bring the app into a particular state through a sequence of gui events such as clicking on a button or submitting text to a form and uses oracles to check the outcome of the test e.g.
the existence or the specific value of a property for a given gui element .
since oracles in this context are assertion based in the paper we use terms oracle and assertion interchangeably.
a gui element or simply element is a graphical widget on a screen of the app.
a gui state sis a set of triples w p v where wis a gui element pis a property of w and vis the value of p.a gui event or simply event eis a triple a t i where ais the action authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
sequence of events of a test case that sorts items in a list in the source app.
fig.
sequence of events migrated by a pptestmigrator from the source app to the target app.
that corresponds to the event e.g.
click tis the target of the action e.g.
button and iis the optional input value e.g.
data for a text input box .
an assertion as is a function f e c tru e fa ls e where eis a gui element and cis a condition to be checked for that element.
the function returns true ifesatisfies condition c and false otherwise.
iii.
m otiv ating example in this section we present a motivating example that consists of two shopping list apps a source app and a target app and a test case for the source app source test .
the goal of apptestmigrator is to migrate the source test from the source app to the target app.
fig.
shows the sequence of events and assertions that the test case triggers to check the sorting items in list functionality in the source app.
the sequence of events to add items to the list are not shown due to space limitations.
the test clicks on more options a b then sort... b c and finally a z c d .
it then checks whether the items are displayed in the sorted order by using six assertions.
items that are checked by assertions are highlighted with rectangles on screen d. fig.
shows the sequence of events and assertions generated by a pptestmigrator for the target app after migration.
the test clicks on more options a b then settings b c and finally on default style ordering of items c d .
next it selects ascending alphabetical order d e .
it then clicks the navigate up button e f and checks whether the itemsare displayed in the sorted order through six assertions.
also here items that are checked by assertions are highlighted with rectangles on screen f. as the example shows although the apps belong to the same category and provide similar functionality their guis are quite different which makes it difficult to migrate test cases from the source to the target app.
iv .
a pproach fig.
shows an overview of our approach a pptestmigrator .
as the figure shows a pptestmigrator takes as input the source app the source tests a set of tests for the source app and the target app and produces as output the target tests the source tests migrated to the target app .
apptestmigrator consists of five main modules instrumenter test runner and recorder event migrator assertion migrator and test encoder .
first instrumenter instruments the source tests so that test runner and recorder can record both the sequence of events generated and the assertions i.e.
oracles checked by the tests.
event migrator and subsequently assertion migrator then migrate the events and assertions from the source app to the target app.
finally given the migrated events and assertions test encoder generates actual test cases for the target app.
in the rest of this section we discuss each step in detail.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
instrumentert est runner and recorder... instrumented source tests ...n sequence of gui events and assertionsevent migrator assertion migrator migrated gui events1 k... ... k... source tests ... target testsmigrated gui events and assertions1 ... ...source app target app t est encoder fig.
overview of a pptestmigrator .
a. instrumenter testing frameworks provide apis that let users write test cases by generating events and assertions.
the instrumenter module instruments these apis to collect information about gui interactions.
b. test runner and recorder the test runner and recorder module runs the instrumented source tests to record the sequence of events they generate and the assertions they check.
for each event it logs the performed action the element that is the target of the action and the input value used by the action if any.
c. event migrator the event migrator is one of the key modules of our technique.
given a sequence of source events extracted from a source test and the target app this module tries to migrate the source events to the target app.
algorithm migrate events describes how this module operates.
the algorithm first computes a window transition graph wtg for the target app line a statically computed graph where nodes represent windows i.e.
activities menus and dialogs and edges represent transitions between windows triggered by callbacks executed in the ui thread .
the algorithm then launches the target app line .
for each source event the algorithm tries to find a match in the target app target event within a predefined time limit lines .
to do so it gets the gui state and finds all the elements in the gui state with which users can interact it first traverses the gui state and checks the value of the attributes of the elements and of their ancestors it then identifies actionable elements that is elements that are clickable long clickable or checkable lines .
after identifying the actionable elements the algorithm computes a similarity score between the source event and these elements call to method computesimilarityscore on line discussed later in this section.
the actionable element with the highest similarity score is considered a match for the source event if the score is above a given threshold.
if the algorithm finds multiple matches it selects one of them randomly and records the others as alternative matches lines .
wediscuss how the algorithm might use these alternative matches later in this section.
if the algorithm can find at least a match it adds to the target events the actionable element matched lines .
it then triggers the matched actionable element and continues by trying to find a match for the next source event lines .
conversely if the algorithm does not find any matches in the current gui state it leverages the wtg it statically computed for the target app to find a matching element elsewhere in the app.
specifically it finds all the actionable elements in the wtg and tries to match them against the current source event.
also in this case the actionable element with the highest similarity score above a given threshold is considered a match for the source event lines .
if one such match is found the algorithm tries to find the shortest path sp ath in the wtg from the current gui state to the gui state where the matched actionable element exists lines .
if sp ath exists the algorithm considers the first actionable element of the path as the next event to trigger lines .
note that the algorithm only triggers the first actionable element of the path rather than triggering them all because the wtg is computed statically and may contain infeasible paths roughly speaking triggering the first event is likely to point the search in the right direction even when the whole path sp ath is not feasible.
after triggering this element a pptestmigrator again tries to find the next match dynamically.
if the algorithm does not find any match either dynamically or statically it semi randomly1selects one of the actionable elements that was not been previously selected lines .
if the number of consecutive random events triggered reaches a predefined limit the algorithm backtracks to the gui state where the first random event was triggered lines .
if the algorithm times out without finding a match for the current source event currsrcev it checks whether an alternative match exists for the last matched source event lastmatchedev .
if so it backtracks by invalidating the last target event and replacing it with one of the alternative matches lines relaunches the target app line 1intuitively and similar to guit estmigrator a pptestmigrator would select a random event while prioritizing promising events e.g.
a dialog button if the previous event resulted in opening a dialog window .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
triggers all the previously migrated events including the selected alternative match line and tries to find a match for currsrcev in this new gui state.
relaunching the target app and replaying events is necessary because an app execution cannot be easily backtracked.
conversely if there are no possible alternative matches for lastmatchedev the algorithm skips currsrcev and tries to match the source event that follows currsrcev .
also in this case the algorithm relaunches the app and replays the previously matched events up to and including the one s matching lastmatchedev .
it does so to undo the possible triggering of target events that were statically or randomly identified while looking for a match for currsrcev .
after processing all source events the algorithm returns the sequence of successfully migrated target events line .
computing the similarity score between two events to match a source event evsto a target event evt apptestmigrator computes their similarity score by comparing the gui elements targeted by the events e.g.
the button in the case of a button click .
we refer to these elements as els source element and elt target element .
our technique does so instead of assessing the similarity of the actual events because it is possible to provide the same functionality by performing different actions on a target element.
for instance it is possible to select an element by clicking long clicking or checking such element.
similarly a pptestmigrator does not require matching elements to be of the same type unless the element is of a type that accepts inputs as different elements might provide the same functionality e.g.
button imagebutton and textview in android .
given evsandevt our technique extracts all the textual information associated with elsandelt.
first if an element has a label or any label exists within a predefined distance from the element the technique extracts it.
second it checks whether the developer defined any content description or hint for the element and if so it retrieves the values of these attributes as well.
third it considers the id of the element as developers tend to assign meaningful ids to elements.
finally if the element is an image the technique retrieves the image filename which is also often meaningful.
after extracting these pieces of textual information associated with elsandelt the technique first preprocesses them.
in particular it tokenizes each piece of textual information and applies lemmatization to the resulting tokens.
the results of this preprocessing are two sets of tokens one for els sets and one for elt sett .
the technique then considers all possible pairs of tokens toks t o k t such that toks sets andtokt sett and computes two distance scores for each such pair based on edit distance and semantic similarity.
to compute this latter we created an ontology for mobile apps based on word embeddings that we generated using the word2vec methodology.
specifically to build the ontology we generated a word2vec model using randomly selected user manuals for mobile apps in different categories.
the user manuals contain sets of instructions that correspond to different user scenarios for a given app.
foralgorithm algorithm for migrating events.
input srcevents targetapp output targetevents procedure migrate events mr max consecutive random events mt match threshold targetevents list tevent wtg computewtg targetapp launchtargetapp targetapp forindex 1tosrcevents .size do currsrcev srcevents .get index matched false numrandevents eventstriggered list tevent while !timeout do nextevent null state getguistate actionables findactionables state mscore foreachactionable inactionables do score computesimilarityscore currsrcev actionable ifscore mt score mscore then ifnextevent !
null then nextevent actionable else nextevent .setalternatives actionable end if mscore score end if end for ifnextevent !
null then matched true eventstriggered .add nextevent targetevents .addall eventstriggered triggerevent nextevent break else sactionables findstaticactionables wtg mscore for each sa insactionables do score compute similarity score currsrcev sa ifscore mt score mscore then staticnextevent sa mscore score end if end for ifstaticnextevent !
null then staticeventstate getstate staticnextevent spath findshortestpath state staticeventstate ifspath !
null then nextevent spath .getfirstevent end if end if ifnextevent null then ifnumrandevents !
mr then nextevent picknexteventsemirandomly numrandevents numrandevents else nextevent back numrandevents end if end if triggerevent nextevent eventstriggered .add nextevent end if end while if!matched then lastmatchedev getlastmatchedsourceevent targetevents ifalternativeeventexists lastmatchedev then alternativeevent getalternative lastmatchedev targetevents .replacelastevent alternativeevent index index end if launchtargetapp targetapp triggerpreviouslymigratedevents targetevents end if end for return targetevents end procedure authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
each word the model produces a feature vector and the semantic distance between two words is determined by the cosine similarity between their vectors.
building this ontology allows us to improve over our previous work where we used general purpose lexical databases such as wordnet .
after computing the scores based on edit and semantic distance between two tokens our technique considers the maximum of these two values as the similarity score for these tokens.
it then matches each source token with the target token that has the highest similarity score above a given threshold and computes the overall similarity score by averaging the scores of all the matched tokens in setsandsett.
d. applying algorithm to the example we now show how algorithm can migrate the source test to the target app in our motivating example.
apptestmigrator first matches the clicks on the dots more options menus in the source and target apps screen ain both figures .
the next event in the source test is a click on the element with label sort... screen bin fig.
.
since a corresponding element does not exist in the target app apptestmigrator does not find any matches.
therefore it uses the wtg of the target app to find a match in another gui state of the app and compute the shortest path from the current gui state to the gui state where the match exists.
due to space limits we do not show the wtg and the statically matched element here.
for the sake of the example it suffices to say that the first actionable element of the computed shortest path is menu entry settings .
therefore our technique would trigger that menu entry screen bin fig.
.
apptestmigrator then looks for a match for the next source event click on menu entry sort... by comparing it against the actionable elements of the current gui state screen cin fig.
and finds two possible matches default style ordering of checked items and default alphabetical style ordering of items .
the technique finds these matches by considering the semantic relation between the words sort and order when computing the similarity scores between the tokens associated with the source and target elements.
since the similarity scores for these two possible matches are the same the technique triggers one of the two actionable elements e.g.
default style ordering of checked items randomly and records the other as an alternative match.
apptestmigrator then tries to find a match for the next source event click on menu entry a z but it does not find any match either statically or dynamically within the time limit.
since the previous source event click on sort... has an alternative match a pptestmigrator invalidates the previous match default style ordering of checked items and triggers the alternative match default alphabetical style ordering of items screen cin fig.
.
it then tries again to find a match for a z is able to match it to the checkedtextview element with label ascending alphabetical order due to the semantic similarity of the terms ascending and a z and triggers the corresponding actionable element screen d in fig.
.
note that our specialized ontology for mobile appstable i assertions statistics.
category property if applicable total percentage ui based displayed .
text .
clickable .
effectivevisibility .
hint .
spinnert ext .
check ed .
completelydisplayed .
enabled .
contentdescription .
.
hier archy based child .
isdescendantofa .
parent .
hasdescendant .
.
doesnotexist .
intent based other s .
described above is what allows our technique to identify this semantic similarity which would have not been possible using a general purpose lexical database.
e. assertion migrator assertions are essential parts of test cases.
to better understand how assertions are written for gui based test cases we manually inspected a large number of test cases for android apps on github.
we specifically focused on test cases written using the espresso testing framework which provides various apis for writing assertions.
as we also explain in section v a we chose espresso because it is one of the major test automation frameworks.
we randomly selected test cases which contained assertions and classified these assertions.
table i shows the categories of assertions that we identified together with the total number and the percentage of assertions for each category.
in total we identified five main categories where the most common category is ui based which accounts for .
of the considered assertions.
assertions in this category check for properties of elements at a specific point of the execution.
the list of such properties is also shown in table i. the second most common category is hierarchy based .
of the assertions .
assertions in this category check the relationships between two elements.
we show different examples such as child parent child and parent child parent relationships in table i. the third and fourth most common categories are doesnotexist and intent based .doesnotexist assertions check that a specific element does not exist in a given gui state whereas intent based assertions check specific properties of intents message objects used within android to request an action from another component either within the same app or in another app.
the rest of the assertions .
are specific to their corresponding apps and cannot be easily generalized.
in the rest of this section we discuss how the assertion migrator module migrates assertions that belong to categories ui based hierarchy based and doesnotexist which account authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
for more than of the assertions we observed.
note that the properties shown in table i for each category are only a subset of the properties supported by our technique.
other examples include f ocus and sibling for the ui based and hierarchybased categories respectively.
we decided not to consider the intent based category for now as these assertions are used to test the control flow of different components of the apps rather than their guis and such control flow might be quite different even among similar apps.
algorithm describes our technique for migrating assertions.
an assertion consists of a condition cond and an element elon which cond is checked.
therefore to migrate an assertion the algorithm must migrate both elandcond .f o r each source assertion ass consisting of a source element els and a source condition cond s the algorithm operates as follow.
first it launches the target app and triggers the migrated events therein lines so that it reaches the gui state in which it can start migrating the assertion.
to migrate els the algorithm compares all the elements of the current gui state with elsand identifies the target element eltwith the highest similarity score line .
to do so function findmatch uses an approach analogous to the one we discussed in section iv c. if a suitable element cannot be found the algorithm selects an event randomly triggers it and tries to find a match in the new gui state lines .
the algorithm keeps exploring randomly until it either finds a match line or reaches a given time limit line .
if it is unable to find a match either directly or through random exploration the algorithm skips the current assertion lines .
otherwise it continues and tries to migrate cond s lines based on its category ui based ifcond schecks a ui based property prop the algorithm gets the expected value valforprop from elt line .
given elt prop and val the algorithm then generates an assertion for the target app line .
hierarchy based ifcond schecks a hierarchy based property the algorithm first tries to match the element associated with cond swith an element in the current gui state using again function findmatch lines .
for condition parent parentel for instance parentel would be the element in the source app that must be matched in the target app.
if findmatch is able to find a match the algorithm generates an assertion for the target app using the matched element the property that needs to be checked and elt lines .
doesnotexist ifcond sbelongs to category doesnotexist the algorithm must identify and migrate in the source app an element srcel that has the properties specified in the assertion e.g.
a specific label does not exist in the last gui state reached by the source test where the assertion is checked and exists in a previous gui state.
note that the last condition is included because in most if not all cases this kind of tests are used to check that a previously existing element has been successfully removed.
to identify srcel function findelement line examines the gui states reached by the source test from the beginning of the execution to the point where the assertion is checked.algorithm algorithm for migrating assertions.
input targetevents srcassertions targetapp output targetassertions procedure migrate assertions foreachassinsrcassertions do launchtargetapp targetapp triggermigratedevents targetevents massertion null melement null els ass.getelement while !timeout do state getguistate elt findmatch state els ifelt null then nextevent picknexteventrandomly triggernextevent nextevent continue else break end if end while ifelt null then continue else cond s ass.getcondition prop ass.getconditionproperty ifcond sis ui based then val elt.getpropertyvalue prop massertion assertion elt prop val else if cond sis hierarchy based then celement assertion .getconditionelement cmelement findmatch getguistate celement ifcmelement !
null then massertion assertion elt prop cmelement end if else if cond sis doesnotexist then srcel srcev findelement ass trgel srcev .gettargetelement trgst targetevents .get trgel .getstate lasttrgst targetevents .getlast .getstate ne finddoesnotexist el trgst lasttrgst ifne!
null then massertion assertion cond s ne end if end if end if ifmassertion !
null then targetassertions .add massertion end if end for return targetassertions end procedure while so function findelement also identifies the last gui state in which srcel existed and the source event srcev that led to that state.
the algorithm then identifies the target event that was mapped to srcev when migrated trgel and the gui state trgst resulting from triggering trgel lines .
the algorithm also identifies the gui state lasttrgst resulting from triggering the last target element that is the state in the target app in which the migrated element should not exist line .
to generate the actual assertion method finddoesnotexist line checks whether there is an element neintrgst that does not exist in lasttrgst and matches srcel if so the algorithm generates a corresponding assertion lines .
finally the algorithm adds all the assertions that it is able to migrate to the list of migrated assertions lines and return them line .
f .
applying algorithm to the example in this section we illustrate how algorithm can migrate the assertions in the source test to the target app authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
in our motivating example.
apptestmigrator first triggers the migrated source events in the target app thus reaching screen ein fig.
.
the technique must then identify in this screen the elements checked by the assertions shown on screen din fig.
.
because it is unable to do so the technique randomly selects an actionable element in the target app.
assume that at some point it selects the navigate up button e f which takes the target app to screen fin fig.
.
the technique again tries to find matches for the elements in the new gui state and this time it is successful.
it then checks the property of the conditions in the assertions which are all displayed i.e.
allui based .
therefore a pptestmigrator generates the assertions using the matched elements and using displayed as the condition to check.
g. test encoder once a pptestmigrator has processed all source events and assertions the test encoder generates actual test cases for the target app based on the migrated events and assertions.
v. e mpirical ev aluation to evaluate our approach we implemented a pptestmigrator and investigated the following research questions rq1 how accurate is a pptestmigrator in migrating events from source to target apps?
rq2 is a pptestmigrator more effective than guitestmigrator in migrating test events?
rq3 how accurate is a pptestmigrator in migrating oracles from source to target apps?
a. implementation our implementation supports android apps as android is one of the major platforms in the mobile app market.
apptestmigrator requires as input tests for the source app and our current implementation supports tests written using the espresso testing framework .
we chose espresso for several reasons including the fact that it is widely used and is actively maintained by google provides easy access to a more complete gui state is integrated with android studio s espresso test recorder and supports asynchronous tasks.
we modified espresso to collect relevant dynamic information during test execution.
note however that our general approach is not specific to android and espresso and could be ported to other mobile platforms and testing frameworks.
for our static analysis we leverage gator a static analysis tool that creates a model of the gui related behavior of an android app.
we used neo4j a graph database management system to interact with the static model.
to generate our word2vec model we used genism an open source vector space and topic modeling toolkit implemented in python.
b. evaluation setup to evaluate a pptestmigrator we first identified app categories in the google play store containing at least fourtable ii description of our benchmark apps and tests.
id name loc installs test cases events oracles coverage s1 shopping list .7k s2 shopping list .2k s3 shopping list .2k s4 oishopping list .9k n1 note now .7k n2 swiftnotes .7k n3 writeily pro .3k n4 pock et note .4k e1 easybudget .1k e2 expenses .2k e3 daily budget .1k e4 open money tracker .5k w1 forecastie .6k w2 good weather .6k w3 world weather .5k w4 geometric weather .5k apps with over installs and source code available.
this resulted in many categories including address book diet tracking expense tracking food ordering mail clients music news note taking online shopping shopping list to dos management and weather apps.
we then excluded those categories that are too broad to provide a standard set of features e.g.
games and fitness .
among the resulting categories we randomly selected four shopping list note taking expense tracking and weather apps.
finally for each of these four categories we selected the four apps either with the most test cases or randomly in case there were not enough apps with test cases in a category.
in total we found two apps with gui test cases one in the shopping list category six test cases and one in the note taking category four test cases .
we then asked eight cs students not involved in this research but familiar with when not expert in testing to write more test cases for all the apps using b arista a test record and replay tool that allows users to generate tests in a visual and intuitive way.
we first introduced the participants to the b arista tool and gave them some time to become familiar with it and ask us questions about it.
we then asked each participant to write test cases for two randomly selected apps.
table ii shows the list of the apps and tests we used.
for each app the table shows its id name size loc number of installations and number of test cases in addition to the total number of events the total number of oracles and the statement coverage for the test cases considered.
note that although we considered only open source apps these apps are available in the google play store and have been installed at least times as mentioned above which should provide some confidence in their quality and popularity.
we applied a pptestmigrator to these apps and test cases by considering each app in a category as the source app and the remaining apps as target apps.
we also compared apptestmigrator with its most closely related technique guit estmigrator gtm for brevity in the rest of this section .
to do so while reducing the cost of the manual check of the results we randomly selected half of the possible combinations of source and target apps and ran gtm on them.
2because the current implementation of a pptestmigrator supports test cases written in espresso the app source code is required to build and run test cases.
however our technique could be directly applied to binary apps by targeting a different testing framework.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii results of migrating test cases using a pptestmigrator atm both events and oracles and gtm events only .
source apptarget appcompletely migrated partially migrated correctly matched unmatched !exist unmatched exist incorrectly matched atm gtm atm gtm atm gtm atm atm gtm atm gtm events oracles events events oracles events events oracles events events oracles events s1 s2 s1 s3 s1 s4 s2 s1 s2 s3 s2 s4 s3 s1 s3 s2 s3 s4 s4 s1 s4 s2 s4 s3 avg.
n1 n2 n1 n3 n1 n4 n2 n1 n2 n3 n2 n4 n3 n1 n3 n2 n3 n4 n4 n1 n4 n2 n4 n3 avg.
e1 e2 e1 e3 e1 e4 e2 e1 e2 e3 e2 e4 e3 e1 e3 e2 e3 e4 e4 e1 e4 e2 e4 e3 avg.
w1 w2 w1 w3 w1 w4 w2 w1 w2 w3 w2 w4 w3 w1 w3 w2 w3 w4 w4 w1 w4 w2 w4 w3 avg.
we then compared the accuracy of migrating events by gtm with that of a pptestmigrator .
because gtm does not support the migration of oracles we could not compare that part of our approach.
c. results table iii shows the results obtained through manual inspection of the migrated test cases by a pptestmigrator both events and oracles and gtm events only .
the results for the combinations of source and target apps not considered see section v b are indicated with a dash .
the first and second columns of the table show the id of the source and target apps respectively.
columns completely migrated and partially migrated show the percentage of test cases for which the technique generated complete and partial target test cases respectively.
completely migrated tests are those for which all events are successfully migrated.
partially migratedtests are those that are not completely migrated but for which at least one event is successfully migrated.
the fifth column correctly matched indicates the percentage of individual events in the source tests that were correctly matched to events in the target app.
to get a better understanding of the performance of the techniques we manually inspected the events or oracles that were not successfully matched and classified them in one of three categories unmatched !exist events oracles are events oracles in the source test that could not be matched to a corresponding event oracle in the target app because they actually do not have a counterpart in that app i.e.
true negatives unmatched exist events oracles conversely represent events oracles in the source test that have a counterpart in the target app but were nevertheless not migrated i.e.
false negatives finally incorrectly matched events oracles are events oracles that authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv benchmarks assertions statistics.
category property if applicable total percentage ui based text displayed enabled completelydisplayed check ed focus hier archy based child doesnotexist other s were mapped to the wrong events oracles in the target app i.e.
false positives .
table iii shows the results with respect to this further classification in columns to .
note that initially we considered measuring a pptestmigrator s effectiveness also in terms of coverage and faultdetection ability of the migrated tests.
we ultimately decided against it because we believe that these metrics make little sense in the context of test migration the degree of coverage and fault revealing ability of the migrated tests not only depends on the number and variety of the source tests but also on the specifics of the code on which they run which makes a meaningful computation of these metrics extremely difficult.
a migrated test that exercises an important feature that only represents of the source code for instance can be very useful but is not going to affect much the overall coverage or fault revealing ability of the migrated test suite.
in other words we believe that these metrics provide little to no information on the effectiveness of the technique itself which is what we are interested in assessing.
d. rq1 accuracy in migrating events as table iii shows on average a pptestmigrator completely migrated and of the tests considered and partially migrated and of the tests considered for the shopping list note taking expense tracking and weather categories respectively.
this corresponds to correctly matching and of the events in the four categories.
among the unmatched events and were true negatives and were false negatives and and were false positives.
in summary on average a pptestmigrator completely migrated and partially migrated of the tests considered while correctly matching of the events.
of the unmatched events were true negatives were false negatives and were false positives.
e. rq2 comparison with gtm as table iii shows on average gtm completely migrated and of the tests considered and partially migrated and of the tests considered for the shopping list note taking expense tracking and weather categories respectively.
this corresponds to correctly matching and of the events in the four categories.
among the unmatched events and31 were true negatives and were false negatives and and were false positives.
in summary on average gtm completely migrated fewer tests than a pptestmigrator versus and partially migrated more tests than a pptestmigrator versus .
also on average gtm correctly matched less event than a pptestmigrator versus .
finally the percentages of true negatives false negatives and false positives for gtm are and which are less more and less than the corresponding results for a pptestmigrator .
to better understand which aspects of a pptestmigrator allowed it to outperform gtm in most cases we manually inspected the cases labeled as correctly matched for a pptestmigrator but not for gtm.
we found that the new approach for computing similarity scores the use of static analysis and the new crawling algorithm helped a pptestmigrator to successfully migrate the events for which gtm failed in and of the cases respectively.
f .
rq3 accuracy in migrating oracles table iv shows the properties that are checked by the assertions in the tests we considered in our evaluation.
as the table shows the most checked property is text followed by displayed enabled completelydisplayed checked f ocus child and doesnotexist .
the assertions in category others check whether the elements in an adapterview have specific names using custom apis that are not currently supported by our implementation.
as the results in table iii show a pptestmigrator correctly matched and of the assertions in the shopping list note taking expense tracking and weather categories respectively.
among the unmatched assertions and were true negatives and were false negatives and and were false positives.
in summary on average a pptestmigrator correctly matched of the assertions in the test cases.
of the remaining were true negatives assertions that apptestmigrator could not match and that in fact had no counterpart in the target app were false negatives assertions that a pptestmigrator could not match but had a counterpart in the target app and were false positives assertions without a counterpart in the target app that a pptestmigrator matched incorrectly .
whereas fault negatives simply make a migrated test potentially less useful as developers would have to manually check its results false positives may result in erroneous assertions and ultimately in erroneous test outcomes.
this issue could be addressed by using the technique as a recommender system as it is typical for this kind of automated approaches a pptestmigrator would propose to the developers the migrated test cases so that they would have a chance to check them before use.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
vi.
t hreats tovalidity the primary threat to the external validity of our results concerns whether they will generalize to other apps tests and categories.
to mitigate this issue we used randomly selected real world apps from four different categories.
a first threat to internal validity is that the students who wrote some of the tests used in our evaluation were not familiar with the apps under test.
however it is not uncommon for testers to test software they did not develop themselves.
a second threat to internal validity consists of possible mistakes in the manual inspection of the test migration results.
despite the many differences in the gui design of apps within the same category however the checks were time consuming but ultimately straightforward due to the similarity in the functionality behind the guis.
vii.
r elated work a. gui test migration apptestmigrator builds on the idea and vision we proposed in earlier work and extends guit estmigra tor our technique for migrating test cases between student apps developed based on identical specifications.
as we discussed in the introduction a pptestmigrator addresses several limitations of guit estmigrator that limit its effectiveness when migrating tests between apps that share only part of their functionality.
it does so by using a new crawling algorithm a more powerful approach for computing similarity scores and static analysis for better exploring the search space.
furthermore unlike guit estmigrator apptestmigrator can also migrate test oracles.
concurrently to our development of a pptestmigrator lin jabbarvand and malek developed c raft droid which also aims to migrate tests including oracles across mobile apps that share part of their functionality.
since apptestmigrator and c raft droid have similar goals both build on and extend some of the ideas and vision proposed in our and others earlier work and rely on similar techniques e.g.
word2vec models to match gui elements combination of static and dynamic analysis we plan to perform an empirical comparison between the two approaches in future work.
rau hotzkow and zeller propose a technique for generating more effective gui tests by transferring tests across web applications .
besides targeting mobile instead of web apps our technique is different from theirs in several ways.
first their matching approach exploits only textual labels while our technique takes into account additional features and can also handle icons without any associated text.
second their dynamic crawling algorithm is different from ours and does not use any static analysis information.
finally unlike apptestmigrator their approach does not migrate oracles.
testmig migrates gui tests between ios and android apps.
the goal of their work is different as a pptestmigra tor migrates gui test cases between similar apps whereas testmig migrates gui test cases for apps meant to have the same functionality across different platforms ios to android .b.
gui test repair there has been much research on gui test repair.
these techniques focus on repairing gui test scripts on different versions of the same software .
apptestmigrator differs from these techniques as our goal is to migrate test cases between apps rather than repairing tests during software evolution.
in fact these techniques could not be readily applied in our context whereas our approach could be used for gui test repair as well.
c. gui test generation recently several researchers have defined techniques that exploit commonalities among apps to generate more effective gui tests.
polariz generates test scripts from crowdbased tests by extracting cross app reusable event sequences.
augusto generates semantic ui tests that target popular functionality.
appflow leverages machine learning to automatically recognize common screens and widgets and synthesize reusable gui tests.
ermuth and pradel propose a ui level test generation approach that exploits execution traces of human users to automatically create complex sequences of events.
none of the above approaches exploits commonalities in functionality to migrate test cases between apps.
viii.
c onclusion and future work we presented a pptestmigrator a technique for migrating test cases between mobile apps that share part of their functionality.
we implemented a prototype of a pptestmigrator for android apps and test cases written using the espresso framework and used it to migrate tests between randomly selected apps in four different app categories.
overall a pptestmigrator fully migrated of the tests considered and partially migrated of them.
for of the fully migrated tests it also fully migrated their oracles.
in addition a pptestmigrator improves on the state of the art in terms of both effectiveness higher migration success and functionality ability to migrate oracles .
in future work we will evaluate a pptestmigrator on additional benchmarks to confirm our initial results.
we will also investigate ways to generalize the approach to other guibased software such as web apps.
as we discussed in the introduction we will also explore the idea of creating a test store that when developers submit an app analyzes the app looks for similar ones in the store tries to migrate tests from these apps and returns all the tests that were successfully migrated.
such a test store could operate in parallel with a traditional app store and automatically provide test cases that developers could run on their apps before submitting them to the app store.