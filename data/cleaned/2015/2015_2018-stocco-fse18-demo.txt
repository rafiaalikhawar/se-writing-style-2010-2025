vista web test repair using computer vision andrea stocco university of british columbia vancouver bc canada astocco ece.ubc.carahulkrishna yandrapally university of british columbia vancouver bc canada rahulky ece.ubc.caali mesbah university of british columbia vancouver bc canada amesbah ece.ubc.ca abstract repairing broken web element locators represents the major maintenance cost of web test cases.
to detect possible repairs testers typically inspect the tests interactions with the application under test through the gui.
existing automated test repair techniques focus instead on the code and ignore visual aspects of the application.
in this demo paper we give an overview of vista a novel test repair technique that leverages computer vision and local crawling to automatically suggest and apply repairs to broken web tests.
url ccs concepts software and its engineering software testing and debugging keywords web testing test repair computer vision image analysis acm reference format andrea stocco rahulkrishna yandrapally and ali mesbah.
.
vista web test repair using computer vision.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
https introduction and motivation automated web tests created with tools such as selenium are renown for being fragile as the the web application under test evolves .
researchers have singled out web element locators as the main cause of fragility .
locators are commands used by test automation tools to identify elements on a web page hanging on specific properties found in the document object model dom such as the element s identifier xpath or text.
test breakage problem.
unfortunately the dom tends to be a quite volatile structure which is massively updated both for evolution and cosmetic purposes.
even simple modifications such as elements repositioning can negatively impact the mapping between locators and web elements making tests inapplicable.
in literature instances of these problems are referred to as test breakages .
a broken test is different from a failing test because the natural permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
evolution is the cause of the test s malfunction rather than the presence of bugs in the production code.
thus the repair activity must be triggered on the test code rather than on the application s. how testers repair.
while repairing locators might seem a fairly mundane task it instead accounts for a number of different scenarios that makes it quite challenging and time consuming .
when a test tthat was used to function on a version v1breaks on a successive version v2 a tester needs to understand the root cause behind the breakage and a possible fixfor it.
this process involves at least four steps.
the tester inspects the error stack trace or the console which may contain information about the origin of breakage e.g.
nosuchelementexception occurred.
unable to locate element with name password .
the tester inspects t looking for the statement strelated to the error message.
the tester browses the gui of v2 trying to identify the portion of gui related to st. the tester inspects either the dom or the gui or both the dom and the gui of v2to find potential fixes.
while so the tester may possibly need to manually exercise the same broken scenario of t i.e.
all the actions in the statements preceding st in order to replicate the breakage occurred at stand gather insights on possible repairs.
challenges of manual repair.
afirst challenge in repairing web tests derives from the fact that testers often need to inspect and link the test code behaviour with the modifications perpetrated to the gui and the dom of the evolved application.
in other words breakages are often repaired by finding candidate solutions through the inspection of the dom and the gui at the same time .
for this reason it is arguably more challenging and time consuming to repair selenium tests than standard junit tests for desktop applications for which the error messages are typically more informative and ide features make debugging activities easier.
asecond challenge is related to the time needed to correct such breakages which can be significant .
one of the main reasons is due to the low tooling support by existing test automation frameworks in understanding the root causes behind test breakages and how they do relate with the changes made in the web applications.
the idea.
our insight is using the gui and visual technologies to support the detection of breakages by checking the gui actions performed by the tests and validating them at runtime in a similar way as testers do timely detecting deviations from the correct behaviour.
in this way we can anticipate the occurrence of breakages and trigger repair procedures that suggest potential fixes to the testers.
existing locator repair techniques are limited when the web application undergoes drastic structural changes because they only consider the dom as a source where to find repairs.
the tool.
our tool vista uses the visual information obtained by the tests execution and along with image processing and crawling techniques supports the automated repair of locator breakages.
876esec fse november lake buena vista fl usa andrea stocco rahulkrishna yandrapally ali mesbah driver.findelement by.name user .sendkeys user driver.findelement by.name password .sendkeys pass driver.findelement by.xpath input .click driver.findelement by.linktext add new .click driver.findelement by.xpath input .sendkeys name driver.findelement by.xpath input .sendkeys lastname driver.findelement by.xpath input .sendkeys company a a version .
.
driver.findelement by.name user .sendkeys user driver.findelement by.name password .sendkeys pass driver.findelement by.xpath button .click driver.findelement by.linktext add new .click driver.findelement by.name next .click driver.findelement by.name input .sendkeys name driver.findelement by.xpath input .sendkeys lastname driver.findelement by.xpath input .sendkeys company b b version .
.
figure addressbook web application evolution v. .
.
v. .
.
along with selenium webdriver test cases.
running example we consider a real test regression scenario and explain the limitations of water an existing dom based web test repair solution which motivate the need for a novel visual based approach.
figure shows two versions of the addressbook web application one of the experimental subjects used in our empirical study .
we consider a test scenario in which a new entry is added to the address book.
in the first version .
.
figure 1a the test alogs into the application lines clicks on the add new link line and fills in the form with the new user information lines .
when the new version of addressbook is released a tester may wish to run this test to check whether regressions have occurred into the application during development.
however when executed on version .
.
figure 1b the test awill cease to function because multiple breakages are present.
non selections.
first the execution will stop at line when attempting to locate the login button because the attribute value has been removed from the html.
at a visual inspection of the two guis however a tester would expect the test to work because her perception is immaterial where changes at dom level are concerned.
indeed it is evident that the target element i.e.
the login button is visually still present on the page and its position on the gui has not changed.
this is a simple instance of direct breakage because the test scenario is unaltered and no bugs are eventually present in the application.
however the test is inapplicable because the synchronization with the application is lost and a fix needs to be found.
to this aim a tester may wish to use water to automatically fix the broken statement at line .
specifically another locator for the login button needs to be generated rather the relying on the broken attribute value .water will attempt to gather information about the broken element such as the xpath and the various attributes by analysing the dom of the previous version .
.
and match such information on the evolved dom of version .
.
.
unfortunately water s technique is ineffective in this case because i the attribute value has been deleted from the dom and ii both the xpath and the tag of the target element have changed from input tobutton which render impossible for water s heuristic to identify it on the evolved dom and apply its automatic repair.
broken workflows.
a second non trivial breakage happens at line .
when attempting to locate the first name text field the test will raise an exception of kind nosuchelementexception .
indeed a new intermediate confirmation page has been added figure 1b and the navigational workflow of the test must be corrected to reflect that of the new modified web application.
from a testing perspective the first name text field can no longer be found on the web page test state following the execution of the statement at line .
however conceptually the repair action that needs to be triggered in order to correct the test has nothing to do with the locator at line .
in fact by only looking at the exception raised by junit it is challenging for the tester to detect this problem unless the visual execution of the test is taken into consideration.
even the use of water is unsuccessful because the tool would attempt to repair the broken statement at line the technique only handles addition of statements within forms and does not apply to general broken workflow scenarios .
mis selections.
lastly the statements at lines will execute correctly whereas the statement at line will fill the field nickname instead of the field company .
in literature this is known as a mis selection problem .
mis selection of web elements can lead to unpredictable test executions that diverge from the test s intended behaviour.
depending on the kind of actions being performed the test s execution might continue until it reaches a point in which an action cannot be performed or an element cannot be found but the actual repair has to be triggered in a previous test statement propagated breakage .water is not designed to detect mis selections however those scenarios are very challenging to detect for a tester because only at a manual visual inspection of the test s execution one can recognize such breakage patterns.
repaired test.
figure 1b bshows the test as repaired by vista repairs are highlighted that works correctly on addressbook version .
.
.
specifically i the non selection and mis selection are corrected by updating the locator component of the test statements lines and and ii the broken workflow is corrected by adding a new test statement to reach the new page hence creating the missing transition .
in the following of this demo paper we illustrate our tool design and implementation.
3vista tool our intuition behind the development of vista is that an algorithm taking into consideration the visual execution of the tests might be able to validate the feasibility of dom based locators through their visual appearance potentially anticipating the occurrence of breakages.
additionally the visual locators can be also used to match the target element in the new evolved gui.
an assumption 877vista web test repair using computer vision esec fse november lake buena vista fl usa correct test suite execution visual execution tracervisual augmented test execution repair2image processing pipeline feature extraction feature detection template matching filtering local crawlingeclipse ide junitweb app v1 eclipse ide junitweb app v2selenium testselenium test dynamic visual execution trace dom query test statement 1test statement 2test statement 3test statement test case tc repairs r1 r2 r3 figure high level architecture of vista of this work is that the gui of a web application is less prone to be drastically changed between two consecutive releases whereas the dom gets updated more frequently.
however matching web elements between two guis is challenging and several issues needs to be solved.
among all finding an accurate visual matching technique that can handle multiple visual matches visual false positives and in the case a good visual match is found retrieving the corresponding element in the dom.
lastly in the case of broken workflows it would be desirable to automate the local exploration of the application s state space looking whether the target element has repositioned to another test state.
.
tool architecture figure shows the high level architecture of vista which is logically composed by two main modules the visual execution tracer and the visual augmented test runner .vista is written in java and executes selenium test cases within the eclipse ide analysing their visual execution trace to detect the occurrence of locator breakages and finding potential fixes at runtime to report to the users for inspection.
in the following we explain the two modules on the running example described in section .
.
visual execution tracer in the first phase our tool records the visual interactions of each test statement with a correct version of the application web app v1 .
keeping the association between statements dom locators and their visual appearance is important because it is close to the mental model that testers create when they manually validate the execution of the tests through for instance eye balling.
such a mapping can be captured only at runtime while tests execute because the visual appearance of the rendered elements may change during the application s execution and some elements may be not visible until specific events occur.
to this aim the visual execution tracer integrates the tool pesto that uses aspectoriented programming to intercept selenium webdriver method calls e.g.
click and automatically creates visual locators for each web element composing the test cases.
a visual locator is theportion of the rendered web page that uniquely identifies that web element on the screen .
for instance for the test breakage at line in figure 1a the login submit button in the html input value login is identified through the xpath locator input .
the tool i saves the entire screenshot of the web page ii retrieves the web element coordinates and sizes through webdriver and finally iii crops a rectangle image centred on the web element.
note that a visual locator is not always the precise crop of the web element s bounding box.
pesto can also manage cases in which a larger crop taking into account the web element s visual context is necessary in order to visually differentiate it from other visually similar web elements appearing on the page e.g.
multiple text fields in a form .
when the test execution terminates all this information test statements corresponding screenshots and visual locators is made persistent as a json file and used by the second main component of the tool.
.
visual augmented test runner in the second phase vista runs the tests on the new evolved version of the application web app v2 .
the visual augmented test runner executes each test statement in a controlled loop environment in which the result of the action performed by the statement on the web application is validated by a series of steps.
first the tool pools the dom of the application with the original locator input to observe if an instance of awebelement object is returned by webdriver.
in case of nonselections e.g.
no web elements are associated with the locator in the new dom vista attempts at verifying if the web element is still visually present on the web page by means of the visual locator saved before and if so it generates a new locator see section .
.
conversely if an element is retrieved by the original dom locator a further sanity check is performed still relying on the visual search of the web element.
vista checks the equivalence of the twowebelement objects retrieved by the two locators if they do target the same web element the approach has visually validated the test statement which is executed.
then the approach proceeds to validating the next statement.
878esec fse november lake buena vista fl usa andrea stocco rahulkrishna yandrapally ali mesbah in case of disagreement between the visual and dom locators a possible case of mis selection might have occurred and vista outputs the result to the tester who needs to resolve the dispute by selecting the correct locator if any .
a third breakage scenario occurs when neither the dom nor the visual locator is able to select any web element in the current dom test state .
this is the case of line of figure 1a in which the target web element has repositioned to a new web page.
in this case vista triggers a local crawling of the state space of the web application looking for matches which are one level distant from the current page.
if a match is found in any of the web pages the workflow is repaired by adding a transition to that page generating a new statement i.e.
a locator for the matched element.
if all these validation checks are not successful vista assumes the web element as being removed from the application and suggests the deletion of the statement to the user.
.
key components of vista for the development of the visual component of vista we have pipelined different algorithms available from the open source computer vision library opencv version .
.
into a custom detector.
the detector aims at assessing the presence of the visual locator in the new dom and if so at searching for the best visual match in the gui and its correspondent dom element.
in the following we briefly illustrate each step.
.
.
image processing pipeline.
the image detector combines two feature detection algorithms sift and fast.
the detector extracts the key points from the template image using sift descriptors and then adopts a flann based descriptor matcher with a distance threshold ratio of .
.
if at least of the key points are matched the fast normalized cross correlation template matching algorithm with a similarity threshold .99is executed.
in case of multiple or false visual matches our procedure discards the matches that do not fall in the region where the key points have been found through a non maxima suppression nms operation.
in this way only the closest match is returned see the green thick rectangle over the login button in figure .
.
.
from gui to dom.
once the best visual match has been found we still need to retrieve the correspondent dom element whose bounding box centre has coordinates x y .
this operation can be done in different ways such as parsing the dom into a spatial structure e.g.
a r tree for easier querying.
willing to provide a runtime validation technique this solution failed to provide acceptable performance results in our exploratory experiments because the parsing operation is costly and its complexity scales up with the number of elements in the dom tree.
thus vista simply queries the browser through the javascript command elementfrompoint x y that returns the dom element whose bounding box contains xandy.
those parameters need to specify the centre of the bounding box otherwise a dom ancestor of the searched web element as a form ordivcontainer will be erroneously returned.
.
.
locator generator.
the xpath of the retrieved web element can already be considered a valid repair for locator breakage.
however vista can synthesize different dom locators based onthe attributes of the element itself such as id orname discarding attributes considered fragile and prioritizing the final list based on the alleged robustness .
.
.
local crawling for workflow repair.
for the local crawling exploration vista features a crawljax plugin that incorporates the image processing pipeline.
in this way the crawler can search the desired web element visually thus looking for repairs in the neighbourhood of the breakage site.
for an empirical evaluation of vista in repairing the breakages of different breakage classes we refer the reader to our full paper .
vista was able to provide correct repairs for of breakages with a increment over water .
conclusions and future work in this paper we described vista a novel web test repair technique based on a fast image processing pipeline.
while vista has shown promising results we are considering several improvements.
for future work we plan to investigate alternative visual techniques such as ocr and evaluating the effect of varying the template sizes on the tool s accuracy.
perhaps more interesting is the potential for hybridization i.e.
joining dom and visual heuristics in a single solution.
indeed the visual search function can be improved by bringing in additional information that can help filter the multiple visual matches more intelligently.
as an example one can collect both dom information and the method s call stack of the elements in order to verify the semantic equivalence of the elements between different versions.
for the interested reader the source code and a demo video can be found on the tool s repository