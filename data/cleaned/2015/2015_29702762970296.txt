an extensible framework for variable precision data flow analyses in mps tam s szab itemis germany delft university of technology netherlands tamas.szabo itemis.desimon alperovich jetbrains czechia alpsm yandex.ru markus voelter independent itemis germany voelter acm.orgsebastian erdweg delft university of technology netherlands s.t.erdweg tudelft.nl abstract dataow analyses are used as part of many software engineering tasks they are the foundations of program understanding refactorings and optimized code generation.
similar to general purpose languages gpls state of the art domain speci c languages dsls also require sophisticated dataow analyses.
however as a consequence of the different economies of dsl development and their typically relatively fast evolution the e ort for developing and evolving such analyses must be lowered compared to gpls.
this tension can be resolved with dedicated support for dataow analyses in language workbenches.
in this tool paper we present mps df which is the component in the mps language workbench that supports the de nition of dataow analyses for dsls.
language developers can de ne dataow graph builders declaratively as part of a language de nition and compute analysis results e ciently based on these dataow graphs.
mps df is extensible such that it does not compromise the support for language composition in mps.
additionally clients of mpsdf analyses can run the analyses with variable precision thus trading o precision for performance.
this allows clients to tailor an analysis to a particular use case.
demo video of mps df ccs concepts software and its engineering !automated static analysis data ow languages integrated and visual development environments keywords dataow analysis domain speci c language language workbench inter procedural analysis1.
introduction dataow analysis is essential for program analysis optimizations in compilers integrated development environments ides and debuggers.
fast and precise analyzers are typically designed speci cally for a particular programming language and require signi cant research and implementation e ort .
this e ort is justi able for gpls which change rather slowly and where the implementation e ort for an analysis and other compiler and ide features is justi ed by a large user base.
historically most dsls have been simple languages requiring only simple analyses e.g.
enforcement of name uniqueness detecting simple bug patterns or basic type checking .
however for state of the art dsls such as mbeddr webdsl or polar this is no longer true sophisticated analyses similar to those in gpls are required.
however the economies of dsl development are di erent dsls evolve more rapidly and their user base is smaller making it hard to justify high development e ort for languages and tools in general and for analyses in particular.
to lower this e ort we propose that language workbenches directly support the development of dataow analyses.
this allows for the analyses to be an integral part of language development and to evolve together with the language as it grows in complexity.
in this tool paper we present mps df the dataow support of the meta programming system mps .1mps is a language workbench for the de nition of domain speci c languages plus their accompanying ides.
mps df is a component of mps and it supports the de nition and e cient execution of dataow analyses.
users of mps df rst de ne dataow builders for the analyzed language.
these builders contribute subgraphs to the dataow graph dfg an intermediate program representation encoding the dataow of the analyzed program.
mps df then supports de ning dataow analyses on the dfg which compute some dataow speci c knowledge e.g.
which variables are initialized about the program.
these dataow analyses are static program analyses which derive the knowledge without actually running the analyzed program.
finally existing mps components such as program validators transformations or refactorings make use of this knowledge.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
contributions mps df has two important characteristics extensibility and variable precision.
extensibility is motivated by the fact that mps based languages are extensible themselves wrt.
syntax semantics ide support .
it comes in two avours rst builders enable extensibility of the dfg in the face of language extensions of the analyzed language.
this means that an existing analysis immediately works on an extended program if the concepts in the language extension also de ne builders and thus contribute subgraphs to the dfg.
the second avour of extensibility supports augmenting the dfg for a particular analysis with custom nodes that encode speci c knowledge about the analyzed program and potentially override an analysis result based on that knowledge.
variable precision considers performance trade o s realtime checks in the ide must run fast possibly compromising on precision whereas a more precise but slower analysis is needed during compilation.
we achieve the variable precision by switching between intra procedural analysis within a single function de nition and inter procedural analysis across function de nitions .
switching is achieved by constructing two di erent dfgs but running the same analyses.
we used mps df in mps itself and in projects built with mps to implement several dataow analyses for c java and dsls.2for example we built analyses to aid developers by marking reads from uninitialized variables and unused assignments in mbeddr c programs while a commercial project for insurance dsls uses mps df to empower program understanding.
.
data flow analysis by example in this section we illustrate the ingredients of an analysis by developing an example uninitialized read analysis also called de nite assignment analysis .
it marks a variable read as erroneous if the variable can not be guaranteed to have been initialized beforehand.
our target language is mbeddr c and its extensions .
mbeddr is a set of languages and an ide for embedded software development built with mps.
the code in figure a reads sensor data if the environment is active otherwise it logs an error message.
the call tocalibrateenv reads the value of temp however the read is marked as erroneous because temp is initialized only in the then branch of the preceding ifstatement readsensor dereferences the address of temp and assigns a value to it.
instruction i intrajflowjinter intra p. intra read ejwrite e ejretj nopjcode for e ow s. ow label idjjump pjifjump p trye nally eendj inter p. inter map e ejunmap ej entry point ejcall e position p before ejafter ej after label id id id identi er expression e java expression figure abstract syntax of the dfg builder dsl.
.
the data flow graph and its builders mps is a projectional language workbench where programs are represented as abstract syntax trees asts .
each ast node is an instance of a language concept meta class .
the is an intermediate program representation that represents dataow information in the program as nodes for example read andwrite nodes and encodes the control ow between the nodes as directed edges.
the dfg is derived from the ast by dataow builders.
a builder is associated with each language concept and contributes a concept speci c subgraph to the dfg.
builders are expressed using a dsl using dsls to express a language aspect is idiomatic in mps.
for example there are other dsls for de ning a concept s concrete syntax type checking or transformations.
the dsl for builders shown in figure relies on three groups of dataow instructions intra procedural ow sensitive and inter procedural.
intra procedural instructions encode the basic dataow of a program.
read and write indicate a read from and a write to a variable retmarks returns from functions and nopis an empty operation.
code for recursively calls the builder of another ast node e.g.
the then branch of an if statement and inserts it s subgraph into the dfg at the place of the code for instruction.
each dfg node carries trace information i.e.
it has a pointer to the ast node from which it was created.
the trace is automatically set up by the builders.
for language concepts that do not a ect data ow builders use the nop instruction to support tracing.
flow sensitive instructions improve the precision of the dfg by encoding control ow.
the unconditional jump creates an edge to a dfg node.
for example c s continue statement jumps to the start of a loop.
the conditional ifjump instruction encodes branching in the dfg.
for example c s ifstatement can jump either to the then orelse branch.
in the dfg label s are used to mark jump targets.
finally the tryinstruction encodes the dataow associated with exception handling.
inter procedural instructions help to model the dataow e ects of function calls.
an inter procedural dfg is a hierarchical structure which contains nested dfgs for called functions where nesting resembles the call stack.
mappasses information from the caller to the callee by assigning an actual argument to a formal parameter.
mapcan be imagined as a shortcut for a read from the argument and a write to the parameter.
unmap is its counterpart which indicates that a parameter becomes invalid because the called function returns.
builders can contribute entry points which mark nodes as potential targets of calls.
finally call is similar to code for with one di erence if the entry point of its called function is present in an ancestor dfg it creates an edge to the entry point instead of recursively calling the builder of the called function.
this is crucial to support modeling recursive function calls because instead of in nite nesting only a single edge is inserted.
example figure b shows the builder of the functioncall language concept.
the code rst iterates over the arguments and parameters in parallel and maps the arguments to the parameters thus passing information from the caller to the callee.
next it uses the call instruction to nest the dfg of the called function or to insert a single edge if the call is recursive.
finally the code inserts unmap instructions for the parameters.
the mode property is used for variable precision and it is explained in section .
.
871a call error call calibrateenv ...nested dfg nested dfgnested dfgcallread sensor dbc figure ingredients of an analysis a a simple c program which we statically analyze for uninitialized reads b dataow builder of the functioncall concept c dfg for the code snippet and d the skeleton of the analysis.
figure c shows the dfg for the code in a as it is visualized in mps df.
the dfg is hierarchical because the function calls contribute nested dfgs.
the call to readsensor contributes instructions .
for better readability we collapsed the calls to error and calibrateenv into a single arti cial instruction but in fact they also contribute a nested dfg similar to readsensor .
the branching at instruction is contributed by the builder of the ifstatement.
.
analysis implementation mps df implements the classical monotone framework for dataow analysis based on the work list algorithm.
in this framework every analysis is characterized by a lattice.
a lattice is a partially ordered structure in which every two elements have a unique least upper bound and a unique greatest lower bound.
the work list algorithm builds on two analysis speci c functions funassigns a lattice element to every instruction in the dfg while merge is used to merge lattice elements when control ow edges merge in the dfg.
the algorithm uses these two functions and traverses the dfg to assign a lattice element to every node until it reaches a x point.
the x point computation is required because some control structures e.g.
loops jumps recursion contribute cycles into the dfg and multiple traversals of these cycles may be required until an assigned lattice element converges.
it is the analysis developer s responsibility to de ne funand merge in a way that a x point can be reached.
certain analysis e.g.
interval analysis may require a widening operator a form of convergence accelerator on the lattice to ful ll this requirement.
the funand merge functions de ne how to derive the dataow knowledge on the dfg of the analyzed program.
this knowledge is the analysis result and technically it is a mapping from a dfg node to an element in the analysisspeci c lattice.
other mps components then make use of this result for example validation rules create error markers while a transformation uses it for optimizations.
approximation recall that we develop static analyses in mps df.
as these analyses do not execute the analyzed programs they use approximations to derive the analysis result.
a may analysis is one that derives information that may possibly be true and thus computes an upper approximation of the information that would be true during the execution of the analyzed program.
in contrast a must anal ysis computes information that is de nitely true and derives a lower approximation.
in mps df the implementation of the funand merge functions de ne whether an analysis is a must or a may analysis.
nevertheless the must may property must be coordinated with the client which uses the analysis result.
we discuss the relevance of the must may property on our example analysis next.
example similar to builders the dataow analysis is also expressed with a dsl.
figure d shows the skeleton of theinitializedvariables analysis.
we de ne its lattice as set node var and it encodes the set of de nitely initialized variables at a program point.
the forward direction speci es that the work list algorithm starts the traversal at the rst instruction.
a backward analysis such as liveness would start at the last instruction.
the uses part is used for extensibility and is explained in section .
.
the funfunction builds the aforementioned set of variables for every node in the dfg.
when funencounters a write instruction in the dfg it adds the written variable to the set because that variable is now initialized.
the merge function uses intersection to merge lattice elements because we develop a must analysis.
the name of the analysis is initializedvariables indicating that it derives information about initialized variables.
the analysis is sound because it claims that a variable is initialized at a dfg node only if it is initialized on all executions paths that lead to that node.
the actual error marker in figure a comes from a validation rule of the function concept.
the rule uses the must analysis result iterates over all reads in the function and checks whether the read variable is initialized at the dfg node where the read happens.
this is not the case for temp so an error marker is placed.
in contrast a may analysis would use union yielding an unsound result and in turn the dependent validation rule would only mark a read variable as uninitialized if it is not initialized on any of the execution paths that lead to the dfg node representing the read.
the bene t of the latter setup would be that it produces less false positives.
.
architecture of mps df in this section we present the complete architecture of mpsdf.
we focus on the components that enable variable precision and extensibility.
872analyzed programanalyzed languageextbuildersdfganalysis 1validationrefactoringgeneratorclientsvar precext 2ext 1legendanalysis 2analysis nresult 1result 2result nab a is input to bab a produces bab a is instance of bab a uses bset modefigure the architecture of the dataow support in mps.
annotations mark the components which are responsible for extensibility ext1and ext2 and for variable precision var prec .
.
overview figure shows the complete architecture of mps df.
components on the left produce data that serves as input to components on the right.
a dataow analysis always targets a particular language and potentially its language extensions.
given a concrete program of the analyzed language the dataow builders construct the dfg.
this dfg serves as the input to all dataow analyses.
mps df evaluates the analyses on the dfg and produces the analysis results using the work list algorithm section .
.
certain analyses may require the results of other analyses.
this happens in our example as well because the uninitialized read analysis uses the results of a prior points to analysis to know the possible targets of pointer typed variables.
without this information it can not know that readsensor indirectly initializes temp.
there are several examples for clients of an analysis a code generator can use the result to apply optimizations analysis results can enable or prevent refactorings and validation rules can create error markers in the ide on program elements.
.
support for variable precision variable precision analyses are inspired by the observation that di erent use cases of analyses require a di erent tradeo between precision and performance.
while the user edits code in the ide she expects the analyses to be fast in order to not break the coding ow a compromise in precision may be acceptable.
however when the same analysis is used in the compiler a somewhat longer execution time may be acceptable in order to get better precision through an exhaustive analysis.
various precision properties ow sensitivity inter procedurality can be sacri ced in order to make analyses run faster.
for example the lack of inter procedurality means that analyses do not know what happens in called functions and thus must approximate the analysis results.
the method of approximation is speci c to each analysis implementation and must be in coordination with the dependent clients similar to the must may property section .
.
reducing precision has an immediate e ect on the size of the dfg which in turn a ects how fast the analyses can be evaluated.
in fact the inter procedurality yields the largest dfg because it introduces nested dfgs for all called functions.
based on this observation we introduced two modes for analyses intra and inter which are used by the builders.
we mark the builders with var prec in figure to indicate that they are the sources of variable precision.
when a builder uses the intra mode it contributes to the less precise intra procedural dfg and when it uses the inter mode it contributes to the more precise inter procedural dfg.
the two kinds of builders are de ned separately for a language concept.
flow sensitivity can be activated in both modes because it has only a small e ect on the dfg size.analyses consume the dfg constructed by the builders.
an analysis itself requires only minimal changes to handle the inter mode because only the mapandunmap inter procedural instructions appear explicitly in the inter procedural dfg.
nevertheless builders do not contribute nested dfgs into the dfg in the intra mode thus an analysis does not know what happens in the called functions.
in order to mitigate this problem builders should introduce nopinstructions for called functions in the intra mode.
analyses can then use these instructions to trace back to the originating node for the call in the ast and perform an analysis speci c approximation.
using the dfg as an intermediate representation has the bene t that we can reuse an intra procedural analysis and only change its input from an intra dfg to an inter dfg to derive inter procedural results.
having both intra and inter builders and adapting the analysis with a slight change let the clients switch between the two modes and tailor the precision of the analysis to their needs.
the exact mode is speci ed at the client side when the client calls mps df to obtain the results of a dataow analysis.
example the fuctioncall builder in figure b is dened for the inter mode which means that it contributes to the inter procedural dfg of the program.
for the intra mode we de ne a builder that does not use any inter procedural builder instruction but contributes a nopinstruction to make tracing possible.
the initializedvariables figure d analysis requires only a slight change in the funfunction to support theinter mode.
whenever it sees a map it adds the written variable to the set of initialized ones.
if it encounters an unmap it simply removes the given parameter from the set to forget about it.
in the intra mode in accordance to the must property the initializedvariables analysis handles anopinstruction which traces back to a function call by assuming that no variable is initialized in the called function.
this preserves soundness because we do not add any variable to the set of initialized ones for which we can not guarantee the initialized property.
.
support for extensibility mps provides extensive support for composing languages .
in order to not limit this support dataow analyses must be extensible as well.
we address this requirement with two avours of extensibility.
builders enable one form of extensibility ext1 in figure the dfg becomes extensible in the face of language extensions.
when mps df constructs the dfg of a program it executes all builders of the involved language concepts.
as long as a language extension contains builders for their extension concepts these are automatically taken into account resulting in a dfg for the program written in the composed language.
typically an existing analysis will also work for programs of an extended language.
this is because 873custom instructionsdfginjection ruleaugmented dfganalysis cbafigure components supporting extensibility of analyses in the face of language extensions.
sub gure a unfolds the ext2 annotation in figure and uses the same legend as figure .
sub gure b shows our example custom instruction and c shows the example injection rule for the statemachinevarref concept.
the analyses are evaluated on dfgs only and it does not matter how that dfg was built.
there is another avour of extensibility the analyses may require extensibility in the face of language extensions.
in other words sometimes it is necessary to augment the dfg with custom nodes to support a particular analysis by encoding domain speci c knowledge.
this form of extensibility is achieved through the combination of two components custom instruction and injection rule .
figure a shows their connection.
first an analysis developer de nes a set of custom dataow instructions for a particular analysis.
then an analysis developer de nes injection rules for the analysis.
a rule is similar to a builder as it also contributes nodes and edges to the dfg for a language concept but it can only inject the custom instructions of its analysis.
if an analysis has injection rules then its input is not the common dfg anymore which is shared by all rule less analyses but the one which is augmented by its rules.
example mbeddr c comes with a language extension for inline de nitions of state machines.
it is possible to create global variables of type state machine and like any other global variable they can be referenced from c code.
however the code generator of the state machine extension makes sure that a state machine variable is always initialized.
to avoid false positive uninitialized read errors we use custom instructions in the dfg to override the analysis result.
we de ne one custom instruction definit figure b and organize it into a container defoverride .
the instruction points to a variable and its presence in the dfg means that the pointed to variable is de nitely initialized.
there are two components in the architecture which use definit .
a rule which augments the dfg and the analysis which handles the custom instruction in the augmented dfg.
figure c shows an injection rule for the statemachinevarref concept and for the initializedvariables analysis.
the rule injects a definit instruction for the referenced variable of astatemachinevarref .
the before ref means that the definit is inserted just before the subgraph contributed by the builder of the reference.
it is the responsibility of the analysis to handle the custom instruction and indirectly let the rule override its result.
figure d shows that the analysis uses the defoverride container to access the contained custom instructions.
it handles a definit instruction in the funfunction similar to a write as it adds the pointed to variable to the set of de nitely initialized variables.
as there is a definit before every read from a state machine variable the validation rule will not mark any of these reads as erroneous.
.
discussion validation mps df is in heavy use in both mps itself and in the mbeddr ide to develop dataow analyses.
for example we developed points to uninitialized read livenessanalyses for mbeddr c and null analysis for java.
the analyses implementations are available in our online material.
additionally language engineers and not the developers of mps df at the company itemis have used mps df to implement dataow analyses in several customer projects in the domains of embedded systems insurance and high performance computing.
based on their experience and feedback the dataow analyses indeed evolve together with the developed languages.
adding new language extensions requires dataow related extension as well.
if the new language constructs do not provide builders then they do not contribute to the dfg which will be immediately visible in the form of false positive analysis results on the extended program.
on the other hand due to the support for extensibility the mitigation usually ends with implementing new builders and or rules.
performance we evaluated the performance3of mpsdf on the toyota itc benchmark 4a collection of c code snippets with intentional bugs to test the precision of static analysis tools.
the code base comprises about lines of c code which we imported into mbeddr.
we ran the uninitialized read analysis together with a points to analysis on the complete code base in both intra and inter modes.
the intra analysis requires .
seconds on the complete code base and the inter analysis needs .
seconds which is a11x slowdown.
this shows that a more precise inter analysis requires considerably more time.
the source of this slowdown is the inlining of nested dfgs in the inter mode which could be mitigated by the application of summaries as in soot .
portability to other ides we designed a generic architecture for dataow analysis that can be used in other language workbenches as well.
however the explicit construction of the dfg may have an e ect on the performance in other workbenches.
mps df builds the dfg from the ast of the analyzed program thus the ast must be available rst.
as dataow analyses may run frequently even after every code change an up to date ast must be always available for the analyses.
this kind of incremental maintenance is not an issue in projectional workbenches e.g.
mps or eco where the ast is always available and users directly modify it with tree transformations.
however parser based systems may be able to cope with this challenge only with an incremental parser in the background cf.
the survey by ramalingam and reps for example incremental parsers .
nevertheless the requirement for the ast is not speci c to mps df analyses because program analyses are usually carried out on the ast.
3we ran the measurements on a bit osx .
.
machine with an intel core i7 .
ghz processor and gb of ram using java .
.
.
.
related work there are several tools which rely on relations and relational algebra to carry out program analyses defacto crocopat and grok .
similar to mps df these tools also decouple the creation of an intermediate program representation and the analysis.
the program representation is tuples of relations and these tools all come with a language for the de nition of relational operators which derive the analysis result.
all these tools are independent of the analyzed language similar to mps df.
nevertheless they were not designed with extensibility in mind and target only one particular language without considering language extensions.
dcflow is a dsl and rascal library for constructing control ow graphs of programs.
the dsl is similar to the ow sensitive part of our builder dsl.
however in dcflow only the control ow graph is extracted as an intermediate representation and not the primitive dataow instructions e.g.
read write which prevents extensibility of analyses.
handling a new kind of language concept requires invasive changes in the analysis implementation.
in contrast mps df only requires a new builder implementation and no modi cations to the analyses.
bodden et al.
extend the soot framework to support inter procedural dataow analyses .
compared to our solution of nesting the dfg of a called function they use summaries instead of reanalyzing a function for all call sites a summary is computed once to capture the e ects of a function and it is applied and reused for all callers.
this could lead to great performance improvements for large programs.
from the user perspective the tool is programmable through java apis and it can analyze only java programs.
in contrast mps df supports variable precision dataow analyses and it is independent of the analyzed language.
.
conclusions we presented mps df which is the dataow support in mps.
it de nes a builder dsl for the construction of variableprecision dfgs and an analysis dsl for the de nition of dataow analyses.
additionally mps df analyses are extensible in the face of language extensions of the analyzed language.
we found mps df useful in several open source and commercial projects centered around dsls for embedded systems insurance and high performance computing.
mps df constitutes an integral part of the mps language workbench and it is available open source.
.