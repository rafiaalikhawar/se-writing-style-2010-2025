semantic crash bucketing rijnard van tonder school of computer science carnegie mellon university usa rvt cs.cmu.edujohn kotheimer heinz college carnegie mellon university usa john.kotheimer alumni.cmu.educlaire le goues school of computer science carnegie mellon university usa clegoues cs.cmu.edu abstract precise crash triage is important for automated dynamic testing tools like fuzzers.
at scale fuzzers produce millions of crashing inputs.
fuzzers use heuristics like stack hashes to cut down on duplicatebugreports.theseheuristicsarefast butoftenimprecise even after deduplication hundreds of uniquely reported crashes canstillcorrespondtothesamebug.remainingcrashesmustbe inspected manually incurring considerable effort.
in this paper we present semantic crash bucketing a generic method for precisecrash bucketing using program transformation.
semantic crashbucketing maps crashing inputs to unique bugs as a function of changinga program i.e.
asemantic delta .weobserve thata real bug fix precisely identifies crashes belonging to the same bug.
our insightisto approximate realbugfixeswithlightweightprogram transformation to obtain the same level of precision.
our approach uses a patch templates and b semantic feedback from the pro gram to automatically generate and apply approximate fixes for generalbugclasses.ourevaluationshowsthatapproximatefixes arecompetitivewithusingtruefixesforcrashbucketing andsignificantlyoutperformsbuilt indeduplicationtechniquesforthree state of the art fuzzers.
ccs concepts software and its engineering error handling and recovery maintaining software software defect analysis security and privacy software security engineering keywords crash bucketing fuzzing bug triage program transformation automated bug fixing acm reference format rijnardvantonder johnkotheimer andclairelegoues.
.semantic crash bucketing.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.
acm newyork ny usa 11pages.
org .
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
introduction the advent of large scale fuzzing services such as google s ossfuzz and microsoft s fuzzing service attest to the effectivenessofautomaticbugfindingtools.whenoperatingatscale accurately identifying unique bugs is critical for a reducing timeconsuming manual debugging efforts b characterizing theeffectivenessofautomatedbug findingtools and c rankinginteresting crashingtestcases .however one outstanding challenge in effectively deploying automated fuzzing techniquesisaccuratelyidentifyinguniquebugsduringcrashtriage.
fuzzersoftengeneratethousandsofcrashinginputsthatultimatelycorrespondtothesamebug andthesheernumberofcrashing inputs preclude manual inspection.
this is a hard problem and an area of active research .
automatedcrashtriagetechniquesseektoapproximately bucket multiplecrashing butultimatelyequivalent inputs toreducethenumberofredundantbugreportsanengineermust inspectbyhand.atahighlevel automatedtestingtoolslikefuzzers andsymbolicexecutorstypicallyusetool specific heuristicbucketingstrategies.bothresearchandindustrystandardtriagetechniques have known limitations .
techniques may assume best effort hardcoded values e.g.
the number of calls to consider in a call stack or require tool specific instrumentation for feedback drivenapproaches .thevariedsensitivityofsuchad hoctechniquesresultinimprecisebugidentificationthatcanfail in two ways.
overapproximation occurs when multiple crashing tests caused by a single bug incorrectly bucket to more than one uniquebug i.e.
duplicatebugreports .
underapproximation occurs whencrashingtestsduetomultipleuniquebugsareputinthesame bucket i.e.
missed unique bugs .
stack hash and branch sequence techniques used in state of the practicefuzzers cansufferfrombothover and underapproximation .suchtechniquesseektodetermine bug uniqueness as a function of e.g.
crashing input program traces programcrashstate oracombinationofthese .
recent andmoresophisticated researchadvancesproposetomorepreciselyclassifyuniquebugsusingsymbolicanalysis machine learningoncrashinginputs andbackwardtaintanalysison programtraces .whilesuchapproachespromisemoreaccurate bucketing by considering semantic program behavior e.g.
their accuracy depends on sensitivity to a general semantic trait e.g.
symbolic branch uniqueness and can still misbucket bugs.built inorhardcodedtechniquesfurtherstruggletointegrate specialist knowledge that can produce more accurate output for classes of bugs.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france rijnard van tonder john kotheimer and claire le goues we present a radically new approach to identifying unique bugs in the context of fuzzing by modifying the program itself.
our insight is that bugs can be characterized by a semantic transfor mation on the program under test.
for example patching one of two buffer overflows in a single execution can distinguish crashes unique onlyto thesecond.
further a fixcan stopthe samelogical bug from manifesting on multiple unique execution paths.
our insight draws on the fact that fixing the program offers a precisewaytoassociatecrashinginputswithauniquebug since correct fixes should neutralize all crash inducing inputs associated with the bug in question.
we introduce semantic crash bucketing which maps crashing inputstobugsasafunctionofchange delta inprogramsemantics wherethedeltaapproximatesfixingtherootcauseofthebug.in general root cause analysis is hard and automatically fixing bugs is an open problem .
however e xisting work in automated program repair apr does demonstrate that programs canprofitablybetransformedtoautomaticallyimprovequality .
the motivation behind our approach is that changing a program with approximate fixes can accurately and automatically constrain crashing behavior in a way that mimics real program fixes to detect unique bugs in fuzzer output.
semantic crash bucketing contrasts with the usual sense of seeking program fixes with respect to a correctness oracle suchas tests .
however although the objective of semantic crash bucketing is different from apr it can similarly suffer from programtransformationsthatoverfittothesuccesscriterion.for example supposeaprogramcontainsmorethanoneuniquebug each with independent fixes.
inserting exit at the beginning of a program will satisfy the criterion of neutralizing all crashes butwillassociate andunderapproximate alluniquebugswitha single fix.
to be effective program transformations must therefore haveconstrainedsemanticeffectstopreciselyidentifyuniquebugs under semantic crash bucketing.
we propose a rule based approach using fix templates to constrain the semantic transformations for crash bucketing.
our observationisthatcommonbugstypicallydetectedbyfuzzers e.g.
buffer and integer overflows null dereferences etc.
have semantic properties that are amenable to a rule based application of generalfixtemplates asfoundinanalogaprwork e.g.
.
at a high level rule based application of fix templates can integrate specialist knowledge of bug semantics into the triage process toproducemorepreciseoutput.wedemonstratesemanticcrash bucketing for buffer overflows and null dereferences on real world bugs in the cve database .
buffer overflows and null dereferencevulnerabilitiesaccountforsomeofthemostcommonsoftware security weaknesses and are frequently discovered through fuzzing .
our contributions are as follows semantic crash bucketing a novel technique to automatically identify unique bugs as a function of changinga program s semantics.
semantic crash bucketing groups crashinginputsbyapplyingprogramtransformationstothe program under test.
we use semantic crash bucketing to identifyimprecisecrashreportinginfuzzers andtocomparetheeffectivenessofdeveloper writtenfixesandapproximate fixes.
approximate fixes.
we present an automated procedure using bug fixing patch templates and rule based application of patches to approximate correct fixes.
in general correctly and automatically fixing a program is hard.
the key insight is that the effectiveness of approximate fixes is competitive withusingcorrectfixesforidentifyinguniquebugs.weinstantiatesemantic crashbucketing withapproximate fixes forreal worldbugscommonlyfoundbyfuzzers bufferoverflows and null dereferences and demonstrate effectiveness.
empirical evaluation .
we comparatively evaluate semantic crash bucketing using developer written fixes and approximatefixeswithdeduplicationtechniquesofthreestateof the artfuzzers afl fuzz certbff andhonggfuzz .
we show with semantic crash bucketing that approximate fixes associate crashing inputs precisely i.e.
no under or overapproximation for out of bugs in6 projects compared to ground truth fixes.
we also show that bucketing with approximate fixes is more precise than built in deduplication of all three fuzzers.
our results are available online.
motivating example afl fuzzisknowntofindnulldereferenceandmemorycorruption bugsinevenwell testedsoftware .consideronesuchbugfound insqlite anulldereferencethatwaslaterfixedbythepatchinlisting1a.the sqlite3walkselect function line7 walkstheexpression treeofasqlselectstatement.thereturnvalueof sqlite3walkselect canindicatean errorina select ... from ... statement butthe return value is not checked.
this missing check can lead to a nulldereference downstream during execution due to an invalid from clause.
the fixing commit message says make sure errors from the from clause of a select cause analysis to abort and unwind the stack before those errors have a chance to mischief in the column name wildcard expander.
thedeveloperthuschecksthereturnvalueof sqlite3walkselect and aborts avoiding any null dereferences downstream line figure1a .
current fuzzers and symbolic executors can find many different crashing inputs that trigger bugs like these.
for example slight modificationsinacrash inducing select...from... inputcouldfollow a different sequence of calls or branches but still trigger thesame bug.
existing techniques use generic heuristics to identifyunique crashes from a set of many generated inputs.
call stackhashes are predominant instrumentation based fuzzers may use program execution paths sensitive to branch sequences .
these heuristics are fast and moderately effective but remain imprecise because they are sensitive to inputs that vary program execution in a way that is unrelated to the actual bug.
depending on the heuristic and inputs fuzzers report many duplicate crashes as unique.
ourapproachdefinesbuguniquenessintermsof programtransformation.
the motivation is that fixing a bug as the developer didinfigure 1a ideally catches allcrashinginputsrelatedtothebug authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
semantic crash bucketing ase september montpellier france a src select.c b src select.c static int selectexpander walker pwalker select p a sub query in the from clause of a select assert psel!
assert pfrom ptab sqlite3walkselect pwalker psel if sqlite3walkselect pwalker psel return wrc abort pfrom ptab ptab sqlite3dbmalloczero db sizeof table if ptab return wrc abort a sqlite a developer fix that avoids a null dereference.
a src resolve.c b src resolve.c int sqlite3matchspanname const char zspan const char zcol const char ztab const char zdb 4int n if zspan null exit 9for n always zspan zspan !
.
n if zdb sqlite3strnicmp zspan zdb n !
zdb n !
return b sqlite autogeneratedapproximatefixforthenulldereference.
figure two fixes for a null dereference in sqlite3.
.
.
the actual fix is shown on the left commit 10c478e .
our approach automatically generates the patch on the right.
irrespective of call stacks or other program execution paths.3the challengeisthatfindingtruefixesishard.automatedrootcause analysis is difficult and expensive especially for bugs like this one that requires deep reasoning.
our primary insightis thatsimpler approximate fixes cansubstitute for real fixes to precisely bucket crashing inputs.
for example figure1bpresents an autogenerated approximate fix for the same sqlitenulldereferencebug.semantically itsafelyabortstheprogram if zspanarenull.
it turns out that the sqlitebug leads directly tozspanbeingnullat this later program point i.e.
when the input statement contains a expander described in the commit message .
the approximate patch precisely catches similar crashing inputs like the actual patch.
ourapproachusessyntactictemplatesandconfigurable semantic cues to generate such patches.
semantic cues act as predicates forapplyingpatchtemplates.aconcreteexampleis checkwhether any dereferenced variables atprogram point pisnull.
if so return the variable name .
a patch template can then be instantiated with the specific variable.
in general templates and rules for patch generationandapplicationarespecifiedjustonceperbugclass e.g.
null dereferences and overflows.
.
we describe the procedure fully in section but provide a brief summary here for null dereferences.thepatchtemplatefornulldereferencescheckswhethera variableis null andsafelyabortstheprogramifso.thistemplate containsa hole forthevariabletocheck andmustbeinstantiated withaconcretevariable.weconfiguretheproceduretocheckfor a semantic cue whether variables are null at the point of crash using a debugger environment.
in this case our procedure finds thatzspan could bea problematic dereference and dynamically checks whether zspanis null when the program crashes.
variable zspanisfoundtoindeedbe null generatingthepatchin figure 1b.
the patch is validated to confirm that the modified program no longercrashesfortheinput.thatis theautogeneratedpatchapproximatestherealfixeffectivelybecauseitdiscoversandfixesthe related null dereference triggered downstream during execution even though it does not deeply address the root cause.
3and under correctness assumption of the fix any other crashing input is associated with a different unique bug.in essence applying lightweight program transformation reduces noise compared to typical deduplication heuristics by focusing on the semantic properties of the bug.
at the expense of slight upfrontcostperbugclass ourapproachprovidesaconfigurable mechanism that is sensitive to the semantic property of the bug to more precisely identify uniqueness.
a configurable approach is important bugs exhibit different semantictraits towhichprogramtransformation mustbesensitive.
for example null dereferences cause an immediate program crash which allows us to identify possible causes at the point of crash.
on the other hand buffer overflows typically only cause a crash oncecorruptedmemoryisaccessed andnotwhentheoverwrite actuallyoccurs.handlingoverflowsthereforerequiresadifferent strategy see section .
fuzzers can also underreport unique bugs.
for example under a na ve call stack approach two unique null dereferences in a single function will be reported as just one unique bug.
our technique can identify each bug uniquely via independent program transformations.
semantic crash bucketing this section introduces semantic crash bucketing scb .
semantic crashbucketingisageneralmethodforbucketingcrashes interms ofprogramtransformation i.e.
asemanticdelta .semanticcrash bucketing can be performed with arbitrary program transformations.
our goal in this sectionis to develop a way for determining howwellapproximatefixesidentifyuniquebugscomparedto a ground truth fixes and b existing methods in fuzzers.
we now introducetheproblemdefinitionandapplicationofscbfordetecting inaccurate error reports.
.
problem formulation abuginourcontextisasoftwareflawthatleadstoanerror i.e.
undesirable program behavior an error is a deviation from expectedbehaviordefinedbyatestoracle.weaddressonthetypesof bugs typically found by fuzzers namely those that induce runtime crashes.
for such bugs the error oracle is signaled by a runtime failure a crash results in segfault.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france rijnard van tonder john kotheimer and claire le goues semantic crash bucketing groups crashing inputs according to a programchange that nullifiesthose inputs i.e.
causethe inputs tono longercrashthe program .thus a truefixfor auniquebug maps all crashing inputs for that bug to a unique bucket.
grouping crashes as a function of known fixing patches is a de facto method for establishing ground truth classification of fuzzer crash reports .
we use this idea to develop a general method of identifying misbucketing e.g.
duplicate crash reports arising from approximate fixes and fuzzers.
idealbucketing.
webeginbydefininganidealbucketing where the correct fixing patches for unique bugs in a program are known orpresumed.thisdefinitionrepresentsgroundtruthtomeasurethe effectiveness of ourapproach section .
the intuitionis straightforward someknownorpresumedprogramtransformation tifixes all crashing input associated with a bug i and only those inputs.
tiisbyconstructionthetheoreticallyidealoracletransformation that correctly fixes the bug iand thus all of the crashing behavior it can cause.
in practice we may think of such a transformation as a correct developer written patch for a single bug.
weexpressidealbucketingintermsofuniquebugs thecrashes they induce and their fixes.
let i nbe the identifier for a unique bugiofnuniquebugsinaprogram p.auniquebug iisassociated with a set of one or more crashing inputs which we denote by a bucket bi.
let ti p pbe a function that applies a correct fix to the program p for unique bug i. a correct fix tifixes all crash inducing inputs bidue to i but none of the crashes due to a different bug jwith crashing inputs bj.
weexpressallbucketscontainingcrashinginputsuniquelyfixed byknown ti i nasdisjointpartitions b b1 unionmulti unionmulti bnunderthe correctness assumption of ti.
for a particular ti ideal bucketing implies bi b bj b bis.t.
ci bi angbracketleftti p ci angbracketright negationslash squigglerightcrash cj bj angbracketleftti p cj angbracketright squigglerightcrash where angbracketleftti p c angbracketright negationslash squiggleright crashexpresses that the program punder transformation of fix tiand executed on crashing input cdoes not induce a runtime crash.
ideal bucketing for a bug iexpresses that the fix tiassociates non crashing behavior with all previously crashinginputs c bi butnotanycrashesforotherbuckets bj b bi.
one subtlety of ideal bucketing is the special case where a single input may trigger multiple bugs.
for example two separate buffer overflow copies i.e.
two bugs b1andb2 along the same executionpathmayoverwritethestack twice inasingleexecution.fromourdefinition neithercorresponding fix t1nort2will bucketthecrashinginput.however wecanextendthedefinitionto account for composition of transformations t1andt2to place such a crashing input into a separate bucketthat represents a composite fault.
although conceptually useful we focus on logically discrete fixes based on developer patches to associate crashing inputs with bugs so that it is tenable to experimentally compare real and approximate fixes.
in practice fuzzer generated inputs typically 4note if b bi then the constraint on bjholds vacuously.trigger single bugs and our results corroborate this observation.
classifying composite faults is an open problem and we leave the consideration of usingprogram transformation for classifying such faults to future work.
.
detecting duplicates one goal in fuzz triaging is to approximate the ground truth ideal bucketing strategy minimizing overhead and confusion for the engineer using a fuzzer to identify defects.
approximations are done by e.g.
unique call stack hashes or unique branch sequences.
such approximations can fail however leading to misbucketing of crashing inputs.
misbucketing can be classified into two categories duplicate bug reporting and suppressed unique bugs unreported unique bugs that are missed by crash bucketing or over condensing .
inthispaper wedealwiththefirstcaseofduplicatebugreports.
wenowdescribehowwedetectduplicatebugreportsintermsof fixingtransformations ti whereidealbucketingdoesnothold.
considertwoexamplebugreportsproducedbyafuzzer bug1with a crash bucket b1 c1 containing crashing input c1 and bug with b2 c2 .wesaythat b2isaduplicatebugreport ifc2actually crashes the program due to bug .
that is the correct bucketingimplies b1 c1 c2 and no bug should be reported.
duplicate misbucketingwronglyimpliesbuguniqueness increasingthetriage burden of engineers processing fuzzer output.
inanimprecise bucketing b duplicationoccurswhenthefollowing is true for a particular ti bi b bj b bis.t.
c bi angbracketleftti p c angbracketright negationslash squigglerightcrash cdup bj angbracketleftti p cdup angbracketright negationslash squigglerightcrash thatis somecrash cdup bjactuallyfixed bytiisconsidereda crashforadifferentuniquebug j belongingto bj.byourcorrectness assumption of ti any crash fixed by timust belong to bifor idealbucketingtohold.notethatif cistheonlycrashin bjthen a unique bucketis implied resulting in aduplicate report of bug i as some other bug jthat should not exist.
in summary given correct ti s wecan determine groundtruth ideal bucketing and detect duplicate bug reports as deviations from ideal bucketing.
.
semantic crash bucketing procedure our formulation leads to a straightforward procedure for identi fying misbucketing in fuzzers.
figure 2illustrates the process.
a fuzzertakes a program pand input to generate a set of crashes c c1 ... cn1.
the fuzzer reports a set of crashing input accordingtoitsbuilt inmethodforidentifyinguniquebugs.werepresent the fuzzer output as a disjoint set of unique bugs indexed by i bfuzzer unionmultitext i ibi2.
asamatterofpracticality afuzzerdoesnot bydefault preserve allgeneratedcrashinginputs.instead afuzzerdiscardsanycrashing input it believes triggers a bug it has already seen and typically outputsonerepresentativecrashfor eachbug bucketitconsiders authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
semantic crash bucketing ase september montpellier france unique.
this is expressed as bfuzzer b1 c1 unionmulti b2 c2 unionmulti unionmulti bn cn .
figure the semantic crash bucketing procedure.
thefunction scbtakesasinputthesetofcrashes candaground truth fix tj3.
for a single fix tj scbpartitions the set of crashes cinto a disjoint set bj unionmultibrestby running each crash c con the modified program tj p .
the set bjcontains all inputs fixed by tj asintheidealbucketingcase while brestcontainsallinputsthat still cause tj p to crash.
the final step 4tests if the crashes in a nonempty bucket bjdistinguished by tjis contained in bfuzzer.
because bfuzzercontainsapartitionofuniquebugswithjustone representative crash in any bi there are only two outcomes for the test bj bfuzzer bj andis equalto some biinbfuzzer implyingthat bfuzzerpreciselybucketsthecrashinginputforabug j or bj implying that the crashes in c bjare partitioned acrossmultiplebucketsin bfuzzer implyingthatthefuzzerreported duplicate bugs.
for simplicity figure 2illustrates the procedure forasinglefix tjthatfixesatleastonecrashinginputin c.ideal bucketingchecksthateverycrashinginputin ccanbefixed and bucketed uniquely by one or more fixes t. generating approximate fixes this section explains how we instantiate our approach to perform scbusing approximatefixes.inpractice adeveloperfixprovidesthe bestassuranceofcorrectlyfixingaknownbug whichweaccept as ground truth tfor scb.
however our goal is to reduce the burden on developers to triage fuzzing output when the crash s fix is not immediately known.
in general fixing arbitrary bugs automatically is hard .
our core insight is that an approximate fix hatwidetis competitive with using tto identify unique bugs under scb.inourapproach hatwidetisanautomatic productionencodingthe semanticpropertiesnecessarytofixpossiblecrash inducingbugs.
to demonstrate we instantiate scb with approximate fixes on null dereferences and buffer overflows in c programs.
.
hatwidetproduction.
atahighlevel hatwidetisaproductionofafunction g p t thattakes two inputs the source program pand a crash trace t. a crash trace is produced by executing pon a single crashing input c.g generatespatchesfromfixingtemplates andappliesthemtothe source.patchapplicationispredicatedoncertaininformationintheprogramsource dynamictrace orboth.werefertothesepredicates assemanticcues thatare sensitiveto semanticpropertiesof abug class.ifthepredicatesarenotsatisfied theprogramisnotmodified.
we concretely represent hatwidetas a source level patch.
this has two advantages.
first patches can be used as better bug reports supportinghumantriageanddebugging.second patchescanapply withoutactuallyrunningtheprogram meaningstaticanalyses e.g.
static symbolic execution can also benefit from scb.
weuse gdbandltracetoobtaindynamiccrashtraces.inprinciple anydynamictechniqueoranalysiscanenrichthespaceofsemanticcues to trigger program modification.
we now describe in concrete terms how we obtain hatwidetfor null dereferences and buffer overflows.
.
null dereferences null dereferences are typically fixed in one of two ways correctly initializing a variable or checking whether a variable is null before dereferencingit .atasemanticlevel afixmustenforcea nonnull property for a variable that results in a null dereference crash.
we use the template in figure 3to approximate fixing a null dereference.
pvar is a hole substituted with the offending program variable.
1if pvar null 2exit figure a template for null dereferences the patch approximates error handling by exiting the program on condition of pvarbeingnull similar to the common c idiom ofreturn .whilesimplyexitingappearssimplistic itisinfact appropriateforourobjectivetoaccuratelybucketcrashinginput.
consider if we chose a different strategy by returning a value or initializing pvar .
besides the difficulty of correctly inferring appropriate values we risk the possibility that the modified program may continue executing and cascade errors or crash in other unexpected ways.
without complete information of the root cause to actually fix the bug exiting is a conservative strategy it acts as anassertionensuringthedesirednonnullsemanticproperty.the correct fix in our motivating example supports this strategy sqlite conservatively aborts for error cases but does some extra work propagating theerror up the callstack .
since thetemplate can be changed ourmethoddoesnotprecludeotherpossibilities however our experiments show that the template in figure 3approximates true fixes well enough for precise crash bucketing.
templatedefinitionisonlypartofthelargerproblem generating thefinalpatch hatwidetalsoreliesonidentifyingtheappropriateprogram variable and location to insert the patch.
semantic cues from a gdbtrace inform patch application whether a variable dereference at the point of crash is null.
for example our approximate patch in figure 1bchecks the variable zspan.
the general procedure for finding such crash inducing variables works as follows attach gdbto the program run it on the crashing input.
extract the source line and code reported at the crash.
parse the code for pointer dereference syntax e.g.
p q .
workingbackwards extractprogramvariablesthataredereferenced e.g.
extract pfromp q .
test using gdb whether the variable is nullin the debugger environment.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france rijnard van tonder john kotheimer and claire le goues if the variable is null return the variable and associated line number.
if not move backwards a basic block and continue from .
iftheproceduresucceeds wesubstitutethetemplateprogram variableandinsertthecandidatepatchjustbeforethenulldereference.
the null check could possibly be placed earlier and a true fix may indirectly prohibit a particular variable from being null cf.
thecorrect sqlitefixinfigure 1a .ourdecisionisaninexpensive compromise that we show works well in practice.
before we use the patch for scb we first validate that the modifiedprogramnolongercrashesforinput c.thepatchgeneration procedure can produce more than one candidate patch but our implementation takes the first crash fixing patch for bucketing.
.
buffer overflows buffer overflows are a class of memory corruption bugs commonly discoveredbyfuzzers .bufferoverflowsaretypicallyfixed by performing array bounds checking on memory accesses.
our approximation to fixing buffer overflows thus focuses on arraylength as the underlying semantic property to change.
inferring arrayboundscandirectlyassistsuggestingapproximatefixesfor arbitrary overflow bugs but generally requires additional anal ysis techniques and remains an open problem .
our approachistotruncatememorywritesthatmaycauseinvalidaccesses.applicationsinfailure obliviouscomputing andexploit mitigation use a similar mechanism.
unsafeclibraryfunctionscommonlytriggerbufferoverflows andpersistinmodernsoftware.5ourapproachapplies templates for common c library functions such as memcpy strcpy sprintf gets strcat etc.
wegiveanexampletemplatefor memcpyinfigure thetemplates forotheroverflowsareconceptuallysimilar.werewriteexisting callsandrestrictthelengthofdatacopiedtoadefaultconcretevalue of .
restricting data to only one byte approximates a conservative angelic value that is likely to lead to non crashing program termination.notethatotherpossibilitiesexist wemay forexample instrument the code to obtain actual angelic values observed atruntime and use these to construct fixes.
our experiments show that our current choice works well for precise bucketing.
modify a possible overflowing memcpy call 2size t angelic length 3memcpy dst src angelic length figure a template for memcpy.
dst binds to the destination argument for the original memcpycall and src is binds to the source argument.
compared to approximating null fixes overflow fixes do not attempt to stop execution placing a condition on the length of a potentialbufferprovesproblematicifwedonotknowitsbounds.
conversely simplyexitingbeforecallinganunsafefunctionwill overfittouniquecrashinginputsthatwouldcrashafterthefunction.
inaddition whilememorycorruptionoccurs duringexecutionof theclibraryfunctions theprogramonly crashesatalaterpoint once an invalid memory access occurs in the heap or when a 5astrcpyvulnerabilityhasbeenfoundinthelinuxdistributionasrecentas2017 .corruptedreturnaddressisaccessedonthestack.6thesebehaviors motivate different semantic cues compared to null dereferences and emphasize the importance of a configurable approach.
for bufferoverflows weimplementaproceduretodiscoverpossibly problematiclibrarycallsandresolvetheirlocation.apatchtemplate like figure 4then replaces the call.
the steps are as follows useltracetoobtainatraceoflibrarycallsfromthecrashing program run.
workingbackwards resolvethesourcelocationoflibrary calls in the trace for which we have fixing templates.
apply the template at the location and rerun the program on the original crashing input.
iftheprogramnolongercrashes emittheapproximatefixing patch hatwidet.
else continue from step .
similar to null dereferences we validate that the program no longer crashes for any change done in step and use the first crash fixing patch for bucketing.
extendingsemanticcrashbucketing.
thepatchtemplatesand rulesfor patchingareembeddedin pythonscriptsand areeasyto change.users candefinetheirown patchtemplatesandsemantic cues for patch application depending on the semantic properties of the bug types or application specific apis.
the gdbinterface and ltraceoutput is available in the scripting framework for customization.
additional analysis tools can be integrated e.g.
valgrind though naturally this requires some extra effort.
experimental design ultimately we want to know how well approximate fixes hatwidetdistinguish unique crashes compared to a ground truth bucketing byt developer fixes and b built in fuzzer deduplication the previousstateoftheart .weconductacontrolledexperimentwith real bugs for which we know the ground truth fix section .
.
unfortunately for the purposes of our experiments state of the art fuzzers do not all neatly decouple fuzzing campaigns from crashdeduplication e.g.
deduplication is invoked during fuzzing iter ations .
instead we first generate for each bug an upper boundof inputs that trigger the same bug i.e.
a crash corpus which aimtoexercisedifferentexecutionpathstriggeringthesamebug section5.
.
we then provide this crash corpus as input to each fuzzer and run a campaign for a fixed length hours forcing the fuzzertoperformdeduplicationonthecrashcorpusduringfuzzing iterations section .
.
we use the developer fix and apply scb to obtain the ground truth number of duplicate bug reports after the campaign which includes each fuzzer s deduplication efforton the corpus .
we then apply scb with approximate fixes and measure a thedifferencefromgroundtruth and b deduplication improvement over existing fuzzers.
hardware.
weranourexperimentsonanubuntu16.04ltsserver with2xeone5 2699cpusand20gbofram.crashcorpusgeneration and fuzzing campaigns all ran on a single cpu core.
we used fourcorestorecompilewhenvalidatingwhetheranapproximate fix stops a crash.
6memory fence posts can detect overwrites immediately and don t require a program tosegfault .thisrequirescodeinstrumentationandextrashadowmemorythathurts fuzzing performance.
approximate fixes can be adapted accordingly but we currently do not assume such instrumentation.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
semantic crash bucketing ase september montpellier france .
bugs with ground truth weevaluateonasampleof18nulldereferenceand3bufferoverflow bugsin6real worldprojects.foreachbugwe a extractedaground truthdeveloperfixfromtheprojectand b sourcedacrashinginput that triggers the bug e.g.
from online bug reports .
projects with multiple bugs.
sqliteiswell tested populardatabasesoftware w3misatext basedwebbrowser.fortheseprojects we curated datasets of multiple bugs in a single revision.
to be useful adeduplicationstrategyshouldcorrectlybucketcrashinginputs associated with a bug but onlythat bug and not those for other bugs .thatis hatwidetshouldbeasclosetoidealbucketingaspossible giving strong assurance that hatwidetdoes not overfit the input crashes.
thus we curated a dataset of fixes for null dereference bugs inasinglesqliterevision.thisisanoneroustaskbecausedeveloper fixesareofteninterspersedoverlongperiodsoftime7andfixing patchescannotalwaysbeautomaticallyappliedtopreviousrevisions due to intermediate code changes.
in addition a single patch maycontainmultiplefixes whichwemustseparateforeachrespectivebug.wethereforemanuallyminimizedandbackportedpatches to support a large controlled ground truth study on multiple bugs insqlite.
weselected w3moutofalistofprojectswithreportedcves and found that it also has multiple null dereferences for which we could find developer fixes and crashing inputs that work on the samerevision.8wedemonstratescbonfour nulldereference bugs on a single revision of w3m.
other projects.
we identify two null dereference bugs in different versions of php a large popular project with well documented bugsandgroundtruthpatches.wedemonstratescbonreal worldoverflowbugsin r alargeandpopularsoftwaresuiteforstatistical computing conntrackd a networking utility and libmad an mpeg audiodecoder.weapplyscbtoa strcpyvulnerabilityin r.todemonstratereal worldutility wedemonstratescbontwoofourown days found in previous fuzzing campaigns a strcpyvulnerability inconntrackd and amemcpyvulnerability in libmad.
.
crash corpus generation foreachbug wegeneratealargebaselinecorpusofcrashingin puts from the initial crashing input aiming to exercise different executionpathstriggeringthesamebug.weusethiscorpustotest howwelleachfuzzer sdeduplicationmethodcopeswithvarying behavior that trigger the same bug.
although a typical fuzzing campaignbeginswithoneormorenon crashingseedfilesasinput it is hard to trigger a specific bug starting with arbitrary seed files the inputsearch spaceis huge and fuzzingnondeterminism means itisdifficulttargetspecificareas ofcode.isolatingfeaturesintest cases is one strategy for producing crashing test cases that maycorrespondtothesamebug butcantakeseveraldaysto produce a large test set.
instead we pursue a conceptually similar approach mutating an initially crashing input to explore different execution paths that trigger a particular bug.
we then use this corpus as input to the other state of the art fuzzers.
7thesqlitebugs were fixed over a period of four months.
9vulnerability disclosure is in progress with cert under vrf ymmkt and vrf xkjzj .todothis weusetheexisting crashmode procedureimplemented in afl fuzz .
the crash exploration procedure tracks branches executed by the input and mutates input to try and force execution along different branches where the objective function is topreservecrashingbehavior.inputsthatfailtoexploreinterestingpathsorcrashtheprogramarediscarded.weruncrashexploration for two hours per bug producing crash corpora of related inputs for each bug s crashing seed file.
.
evaluating fuzzers wecomparetothreestateoftheartfuzzers afl fuzz cert bff andhonggfuzz .thesefuzzersarefrequentlyusedin industrialandresearchsettings andimplementdifferentdeduplicationtechniques.ingeneral fuzzersdonotdecouple fuzzingcampaignswithcrashdeduplication crashesarededuplicatedduringfuzzeriterations.totriggercrashdeduplication we seed fuzzing campaigns for each fuzzer with the crash corpus.
industrial strengthfuzzersarehighlyconfigurable.wesoughtto evaluate on default options across varying parameters in coveragebased fuzzing call stack depth branch sequences and point offailure information.
we evaluate on five configurations across the three fuzzers afl fuzz.
we use afl fuzz in its default configuration.
afl is instrumentation driven and keeps track of branches taken duringfuzzing.roughly thismeansthataflissensitivetouniquely executed paths.
afl s default method for fuzzing uses the same mechanismas crashmode startingfromanon crashingseedand withanobjectiveofdiscoveringarbitrarycrashes.onekeydifference however isthat crashmode doesnotdeduplicatethecrash corpus bydefault.
therefore toapproximateafl s deduplication in a real campaign while avoiding a redundant fuzzing campaign we use afl s own minimization procedure directly on the crash corpus then remove equivalent duplicates.
certbff.
weruncertbffinitsdefaultconfiguration which usesacallstackhashbasedon bydefault the fivelastcalls frames leadingtoacrash.thisnumberisconfigurable.thus forthesecond configuration we set bff to use a call stack of just oneframe to determine bug uniqueness.
bff also invokes a built in input minimizer while fuzzing on the fly.
honggfuzz.
werunhonggfuzzinitsdefaultconfiguration which usesacallstackhashofsevencalls.bydefault honggfuzzconsiders informationatthepointoffailurewhenacrashoccurs e.g.
thelast knownpcinstructionandfaultingaddress toreportuniqueness.
honggfuzzcanenableafeedback drivenfuzzingmode provided aprogramiscompiledwiththecoverageinstrumentation.inthe firstconfiguration wedisablecoverage inthesecond weenable coverage.
notethatduetoinputmutationduringthecampaign afuzzer may trigger a bug that we do not have a fix for.
as a final post processing step we use the ground truth fix tto filter out only the crashes fixed by t. experimental results ourmainresultisthatscbwithapproximatefixesis justaspreciseas using the ground truth fix for out of bugs across all configurations.
approximate fixes suffer only small imprecision authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france rijnard van tonder john kotheimer and claire le goues table semantic crash bucketing results.
for each fuzzer configuration we show the ground truth number of duplicate crashes reported by thefuzzer gt compared to the numberof duplicate crashes reported using approximatefixes with scb scb hatwidet .
crash corpus is the number of crashing inputs that initially seed fuzzing campaigns for each configuration.
for example bug firstrow inthehfuzz gtcolumnshowsthathfuzzreports10duplicates determinedbythegroundtruth fix whiletheapproximatefix scb hatwidet reports0duplicates.whenscb hatwidetreports0duplicates itisaspreciseasgroundtruth.
crash afl bff bff hfuzz hfuzz cov project type idcorpus gt scb hatwidetgt scb hatwidetgt scb hatwidetgt scb hatwidetgt scb hatwidet sqlite null deref119125 subtotal w3m null deref13 subtotal php null deref17 r overflow conntrackd overflow libmad overflow total andperformsignificantlybetterdeduplicationcomparedtostateof the art fuzzer deduplication in our experiments.
speedandpr oject size.
automaticpatchgenerationforapproximate fixes is fast.
generating a patch from crashing input and validatingthatitfixesthecrash includingprojectrecompilation takesjust18secondsonaverageacrossallbugs.theminimumtime for patch generation and validation is seconds the maximum seconds.oursampleuseslargereal worldprojects rangingfrom kloc to mloc.
.
overall results table1shows results.
each row corresponds to a unique bug with assigned id .
crash corpus is the number of crashing inputs that initially seed the fuzzing campaigns.
we deduplicate crashing inputs for each bug using five fuzz campaign configurations section5 afl bff 5andhfuzzaredefaultconfigurationsfor thethreefuzzers.
bff 1configuresbfftousejustonecallinits callstackhash hfuzz cov turnsoncoverageinstrumentationfor feedback fuzzing in honggfuzz.
gt is the ground truth number of duplicate reports for each respective configuration which we obtain using the actualdeveloper fix tfor each bug.
column scb hatwidet isthe numberof duplicatebugs fora campaignreported using approximate fixes with scb.
exceptforbugs 1and11in sqlite discussedsubsequently approximate fixes are as precise as the ground truth fix across all configurations.
that is approximate fixes detect and remove allduplicates across all fuzzing configurations for out of bugs.for projects sqliteandw3mcontaining multiple bugs none of our approximate patches suppress any other unique bug.
in aggregate scbwithapproximatefixessignificantlyreducesthenumberofduplicate crash reports compared to the default configurations from and to just two duplicates for aflandhfuzz respectively andareductionof41duplicatestooneduplicatefor bff .in practice crash reports produced by fuzzers must be further triaged manually.
our results show that applying approximate fixes canautomatically cut down on the time that an engineer spends on further triage.
ground truth fixes expose different semantic sensitivities of errorreportingacrossconfigurationsandbugtypes.afl fuzzon average reports more duplicate bugs this is expected due to itssensitivity to unique execution paths especially for null dereferences.ontheotherhand aflandbffreportmoderatenumbers authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
semantic crash bucketing ase september montpellier france ofduplicatesforoverflowbugs whereashonggfuzzreportshundreds of crashes for two stack based overflows bugs and .
honggfuzz s default sometimes considers portions of overflowing stackdatatosignaluniquebugs.bug21isaheap basedoverflow and does not adversely affect honggfuzz compared to stack based bugs.bff 1uses just one call to calculate a unique stack hash per bug and reports the least amount of duplicate bugs.
although bff 1appearstoperformwell theconfigurationisnonstandard in practice because it has the caveat that unique bugs triggered in the same function are easily missed.
none of the bugs in our sample exposes this weakness in the bff 1configuration but it is uncommoninrealfuzzingcampaigns.weincludeitasoneextreme example where coarse aggressive deduplication can be performed at the cost of potentially missing unique bugs.
notethatevenforcaseswhereafuzzingconfigurationreports noduplicates fora particularbug approximatefixesdo aswellas fuzzer deduplication and strictly better for the majority of cases whereduplicatesarereported.thisemphasizesanimportantpoint approximatefixesuniformlybucketcrashesviaconfigurablesensitivitytobug classsemantics.ourresultsshowthatlightweight programtransformationcaneffectivelyavoidimprecisiondueto varying yet broadly applied choices made by built in fuzzer deduplication methods.
.
project specific results sqlite.approximatefixesfor sqliteperformidenticallytoground truth except for bugs and .
patches for bugs and failto fix crashing inputs out of a larger duplicate crash set of crashesreportedbyfuzzers.weanalyzedtheseinputsandfound thattheygenerallytriggerdifferentcrashingbehaviordownstream in execution that our approximate patches do not catch but which correct patches handle earlier upstream .
the implication is not severe scb hatwidetonly reports duplicates over all configurations which is comparatively low compared to duplicate fuzzer reports.
w3m.scb hatwidetperfectly simulates ground truth bucketing for w3m.
our approximate fixes are semantically close to developer fixes each approximate patch checks the same program variable for null as the corresponding developer patch.
interestingly bug produces far more duplicate crashes compared to the other three bugs across all configurations.
this demonstrates a latent benefit of our approach scbcanrevealpropertiesaboutbuggybehavior e.g.
we speculatethatbug13canbetriggeredalongmanyexecutionpaths and different call chains compared to the other bugs .
weconfirmedthatcrashbucketingwith tand hatwidetresultindisjoint buckets for multiple bugs in sqliteandw3m and corresponds to the assumptions of ideal bucketing i.e.
zero overlap of crashing inputs of distinct bug fixes .
php.weappliedscbtoonebugeachin phpv5 cve and v7 cve .
scb improves over afl s reports the other configurations do not report duplicates.r andconntrackd bothcontain strcpyoverflowbugs.the rbug is assigned cve .
we discovered a day strcpybug in conntrackd in our own fuzzing efforts.
since no developer fix exists fora0 day wemanuallydebuggedtodevelopagroundtruthpatch.
we have disclosed the bug and recommended the patch to the maintainers.
as mentioned honggfuzz is particularly sensitive tochangesinthestack especiallyoverflowvulnerabilitiesaffecting thestack.honggfuzzprovidesawayofblacklistingstackhashes to compensate 10but this option is disabled by default.
libmad.wealsodiscovereda0 day memcpybuginlibmadwithour ownfuzzing.
wedevelopedour ownpatchtoperform thecorrect boundscheckingonthelengthofbytestocopy.interestingly developers added a c assertstatement before the memcpycall that checks thecorrectbounds.however assertstatementsarenotcompiled in release versions and the bug results in a segfault.
we used the assertstatementtoinformagroundtruthfixforcheckingthebuffer bound.ourdeduplicationgainsissmallerfor libmad butremains precise.our libmadexampleshowsthatapproximatefixesextend to varieties of api calls in real world bugs with little effort.
.
discussion meritsofscbandapproximatefixes.
ourapproachcanbelayeredontopofexistingfuzzerdeduplicationmethodsorasadrop in replacement.ingeneral scbopenstheopportunitytoparameterize bucketingusingtargetedprogramtransformation.oneadvantage ofautomatedpatchgenerationisresiliencetochangesinunrelated code across revisions.
concretely we can generate an approximate fixforanyrevisioncontainingthebug.thisisnottrueforstatic developerwritten patches.
as explained we hadto takecarefuleffort to isolate and backport existing patches for a ground truth study.
approximate fixes can also improve fuzzing performance and coverage .
fuzzers are known to get stuck on shallow bugs that restrict execution past a memory corruption bug.11our approachprovidesalightweight parameterizablesolutiontoaugment fuzzing behavior and overcome such obstacles.
we are currently investigating these extensions and additional bug classes.
limitations.
our approach requires some up front manual cost to parameterize automated behavior for generating approximate fixes.complexityofthetargetedbugclassalsobearsonthedifficulty of specifying appropriate semantic cues and patch templates andvariousapproximationswillaffectaccuracyofsemanticbug containment.
we demonstrated however that conceptually simple patch templates and semantic cues work well for common bugs found by fuzzers in real world programs.
we speculate that the approachgeneralizesfurtherto e.g.
division by zero arithmetic overflows and use after free bugs.
in general we offer that one off specifications per bug class is competitive with per fuzzer configuration that preclude fine grained semantic control.
our time spent selecting projects to evaluate was dominated bywhetherwecouldfindgroundtruthfixesandcrashinginputs.
thoughthesampleissmall everyprojectthatsatisfiedthesecriteria has worked with our approach so far i.e.
we do not fail to find an approximate fix modulo the need for incremental refinements in our approach e.g.
we added a preprocessing step that expands macrosin phptodiscovernulldereferencesyntaxwhentheprogram crashes .
inourexperimentsweobservethatbothapproximateanddeveloperfixesaddressuniquebugswithasinglecheck.conceptually we can imagine a case where some buggy behavior e.g .
a null pointer may be checked once before branching on multiple paths authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france rijnard van tonder john kotheimer and claire le goues or alternatively along two different paths.
depending on the transformation crashing inputs may thus map to one or two buckets.
our approach for null dereferences currently follows the second strategy forbucketing sincewe addthe checkclose towhere the dereference occurs .
in our experiments this matched the behavior of developer fixes.
note that we can extend our approach to usefirst strategy i.e.
by searching for branch points and inserting checks upstream and even compare different strategies exploring and comparing such transformation strategies holds interesting potential for future work.
duetothedifficultyofperformingorganicfuzzingcampaigns forknownbugs wepurposelygenerateacrashcorpusbymutatingexisting crashing inputs.
the generated crash corpus likely inflates the number crashes that an organic campaign would encounter.
nevertheless thecrashcorpusservesasausefulupperboundto quantifyprecisionofdefaultdeduplicationtechniquesinfuzzers versus scb.
we evaluate our approach on existing state of the art fuzzers under default options and with small modifications to bff and honggfuzz.werecognizethatdeduplicationcanbetweakedand improved with additional parameters and post processing e.g.
stack hash blacklists but we generally believe that fuzzers like other tools should run with sensible defaults.
related work our approach relates generally to existing work in identifying bug uniquenessandbucketingcrashinginputs .ofparticular interest chen et al.
propose a machine learning approach thatranksinterestingtestcasesforcompilerfuzzeroutput anduse fixing patches as ground truth to map crashing inputs to unique bugs.semanticcrashbucketingdrawsontheideaofusingground truth fixes to precisely identify unique bugs obtaining similar precision to ground truth by automatically approximating fixes.
recent work by pham et al.
uses a clustering algorithm thatreliesonasemanticcharacterizationofinputsasconstraints overpaths withparticularapplicabilitytosymbolicexecutors.our approach also promotes a semantic characterization of bugs butfocuses on being sensitive to semantic properties of bugs themselves ratherthansummarizingcrashinginputsintermsofpath constraints.
broadly current techniques manipulate and analyze program input orotherwise instrument programs to obtain readonly behaviorofprograms suchasinputcoverage constraints on input or crash callstack to group crashes.
to the best ofourknowledge scbisthefirsttechniquethatappealsto program modification forpreciselygroupingcrashinginputintheabsence of ground truth fixes.
angelicdebugging seekstomodifyprogramsbyreplacing expressionswithvalues whichbearsconceptualsimilaritytoour approximating fixes for c library functions.
our problem focus differs however we seek accurate crash bucketing in the presence ofduplicatedorunreportedbugs whileangelicdebuggingseeks to fix failing test cases while preserving existing passing test cases.
in terms of program modification our work relates to failureoblivious computing .
for instance our rule based application of fix templates share similarities with the idea proposedby long et al.
who modify a program so that a null dereferencedoesnotcauseittocrash.theobjectiveoffailure oblivious computing however is to make program execution resilient to crash inducingeffectsofbugssuchasnulldereferencesordivideby zero errors.
in contrast scb seeks to isolateunique bugs by selectivelyapplyingprogramtransformation ratherthanprovidinganautomatic catch alltechnique forkeeping aprogram runningin the interest of resilience.
syntactic patches promote the benefit of patchesasbetterbugreports sothatengineerscananalyze semantic effects that influence crash bucketing.
peng et al.
show that applying program transformation while fuzzing can increaseprogramcoverageandrevealmore bugs whileourapproach focusesonaccuratecrashbucketing ourtechniquecomplements this recent idea.
fault localization and automatic program repair sharesimilar highlevelgoalsforidentifying bugs andautomaticallyfixingthem.thisworkisbroadlycomplementarytoours providingtechniquesthatcanassistwithaccurately identifying fault locations for patch placement and appropriate program transformations for different bug classes.
conclusion we introduced semantic crash bucketing a way to perform crash bucketing using lightweight program transformation.
we then developed an automatic approach that applies patch templates to approximate real developer fixes to perform crash bucketing.
our approachusesconfigurablerules specifiedonceperbugclass that instantiateandapplypatchtemplatesbasedoncrashingbehavior.
unlikecoarse deduplicationmethods rulesandtemplates aresensitive to bug specific semantic properties and crashing behavior.
we developed approximate fixes for null dereferences and buffer overflows.weperformedagroundtruthstudycomparingscband approximate fixes to a true developer fixes and b crash deduplicationofthreestateoftheartfuzzers afl bff andhonggfuzz .
ourresultsshowthatapproximatefixesarecompetitivewithcrash bucketingprecisionoftruedeveloperfixes andperformsstrictly better deduplication than all tested fuzzer configurations.