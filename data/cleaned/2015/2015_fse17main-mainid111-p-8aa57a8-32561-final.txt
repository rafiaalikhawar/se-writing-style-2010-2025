see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation toward full elasticity in distributed static analysis the case of callgraph analysis conf erence paper august .
.
citations 29reads author s diego garber vetsky univ ersity of buenos air es publica tions citations see profile edg ardo z oppi univ ersity of buenos air es publica tions citations see profile ben livshits micr osoft publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y diego garber vetsky on oct ober .
the user has r equest ed enhanc ement of the do wnlo aded file.towardfullelasticityin distributed static analysis thecaseofcallgraph analysis diego garbervetsky edgardo zoppi universidadde buenos aires fceyn dc icc conicet argentinabenjaminlivshits imperialcollegelondon unitedkingdom abstract in this paper we present the design and implementation of a distributed whole programstaticanalysisframeworkthatisdesigned to scale with the size of the input.
our approach is based on the actor programming model and is deployed in the cloud.
our reliance on a cloud cluster provides a degree of elasticity for cpu memory and storage resources.
to demonstrate the potential of our technique we show how a typical call graph analysis can be implementedinadistributedsetting.thevisionthatmotivatesthis work isthateverylarge scale softwarerepositorysuch asgithub bitbucket or visual studio online will be able to perform static analysisonalarge scale.
we experimentally validate our implementation of the distributed call graph analysis using a combination of both synthetic and real benchmarks.
to show scalability we demonstrate how the analysis presented in this paper is able to handle inputs that are almost10 millionlines of code loc insize without running out of memory.
our results show that the analysis scales well in termsofmemorypressureindependentlyoftheinputsize aswe addmorevirtualmachines vms .asthenumberofworkervms increases we observe that the analysis time generally improves as well.
lastly we demonstrate that querying the results can be performedwithamedian latency of15 ms. ccs concepts theory of computation distributed algorithms software and its engineering automated static analysis integratedandvisualdevelopmentenvironments computer systemsorganization cloud computing keywords development environments and tools parallel distributed and concurrentsystems performanceandscalability programanalysis program comprehensionandvisualization partof thisworkwas donewhen the authorswerevisitingmicrosoft.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forproitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the irst page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspeciicpermissionand ora fee.
request permissions from permissions acm.org.
esec fse september paderborn germany associationfor computing machinery.
acm isbn ... .
format diegogarbervetsky edgardozoppi andbenjaminlivshits.
.toward fullelasticityindistributedstaticanalysis thecaseofcallgraphanalysis.
inproceedings of 11th joint meeting of the european software engineeringconferenceandtheacmsigsoftsymposiumonthefoundations of software engineering paderborn germany september esec fse 12pages.
introduction in the last decade we have seen a number of attempts to build increasinglymorescalablewholeprogramanalysistools.advances inscalabilityhaveoftencomefromimprovementsinunderlying solvers such as sat and datalog solvers as well as sometimes improvements tothedatarepresentationintheanalysis itself we have seen much of this progress in the space of pointer analysis .
limits of scalability a typical whole program analysis is designed to run on a single machine primarily storingits data structures in memory.
despite the intentions of the analysis designer this approach ultimately leads to scalability issues as the input program size increases with even the most lightweight of analyses.
indeed if the analysis is stateful i.e.
it needs to store data about the programas it progresses typically in memory eventually this approachceasestoscaletoverylargeinputs.memoryisfrequently a bottleneck even if the processing time is tolerable despite various memory compression techinques such as bdds.
we believe thatthe needtodevelopscalable program analyses is nowgreater thanever.thisisbecauseweseeashifttowarddevelopinglarge projectsincentralizedsourcerepositoriessuchasgithub which opens up opportunities for creating powerful and scalable analysis backends that go beyond what any developer s machine may be ableto accomplish.
distributed analysis inthispaperweexploreanalternativeapproachtobuilddistributedstaticanalysistools designedtoscale with the input size with the goal of achieving full elasticity.
in otherwords nomatterhowbigtheinputprogramis givenenough computingresources i.e.machinestoexecuteon theanalysiswill completeinareasonabletime.ouranalysisarchitectureassumes thatthestaticanalysisrunsinthecloud whichgivesuselasticity for cpu and memory resources as well as storage.
more specifically in the context of large scale code repositories even code understandingandcodebrowsingtasksaremadechallengingby thesizeofthecodebase.wehaveseentheemergenceofscalable online code browsers such as mozilla s lxr .
these tools oftenoperateinbatchmode andthushaveahardtimekeepingup 442esec fse september04 paderborn germany diegogarbervetsky edgardozoppi andbenjamin livshits with a rapidly changing code repository in real time especially for repositorieswithmanysimultaneouscontributors.weaimtoshow howanimblersystemcanbedesigned whereanalysisresultsare largely stored in memory spread across multiple machines.
this design results in more responsive queries to obtain analysis results.
.
motivation static analysis backend imaginealargeprojecthostedwithinacentralizedsourcerepository such as github bitbucket or visual studio online1.
we see anemergingopportunitytoperformserver sideanalysisinsuch asetting.indeed the backendsofmanysuchrepositoriesconsists of a large collection of machines not all of which are fully utilized at any given time.
during the downtime some of the available cycles could be used to do static analysis of the code base.
this can helpdeveloperswithbothprogramunderstandingtasks suchas code browsing as well as other static analysis applications such as indingbugs.
the ever changing code base as is typical for large projects multiple developers constantly update the code base so it is imperative that the server side analysis be both responsive to read only user queries and propagate code updates fast.
at the same time within a large code base many parts of the code often entire directories remain unchanged for days or months at a time.
often there is no reason to access these for analysis purposes.
therefore to ensure that we do not run out of memory it is important to have a system that is able to bring analysis nodes into memory on demandandpersistthemtodisk putthemtosleep whentheyare nolonger needed.
.
callgraphcomputation inthispaperweadvocatetheuseofthe actormodel asabuilding blockoftypicalworklist basedanalysisapproaches.morespeciically weusethisapproachtoimplementatypicalcallgraphconstruction algorithm.
while the algorithm itself is quite well known andisnotacontributionofthispaper thewayitisimplemented in a distributed setting is.
also note that call graph information is used for interactive tasks such as autocomplete or intellisense as shown in figure .
for tasks like this both accuracy and responsivenessareimportant.callgraphconstructionisafundamental stepofmostwhole programanalysistechniques.however mostof thetime call graph analysis computationis a batchprocess startingwithoneormoreentrypointssuchas main thecallgraphis iterativelyupdateduntil nomore methodsare discovered.
interactiveanalysis our setting in this paper is a little diferent.
our goal is to answer interactive user queries quickly.
our queries arethekind thataremostfrequentlyposed inthecontextofcode browsing and debugging and are already supported on a syntactic levelbymanyides.speciically ouranalysisinthispaperhasbeen developed to provide semantic analysis backed answers for the followingide basedtasks gotodeinition givenasymbolin theprogram inditspossibledeinitions2 whocallsme given 1visual studio online .
2note that this process is challenging due to the presence of polymorphism common inobject orientedlanguages.givenacallsite itisnotalwayspossibletodetermine whichistheactualmethodimplementationbeinginvoked.thisproblemknownas call site devirtualization is well studied in the literature.
therefore a static analysis canonly approximate the targetmethod deinitions for avirtual method invocation.amethoddeinition indallofitscallers auto complete autocompletion invokedwhenthedeveloperpressesadotisoneofthe most common and well studied tasks within an ide 29 .ifthevariableorexpressionsontheleft handsideofthedotisof agenericinterfacetype completionsuggestionsarenotparticularly usefulortoogeneral.itisthereforehelpfultoknowwhichconcrete type lowto agiven abstract location.
wehavearchitectedouranalysisbackendtorespondtorest calls thatcorrespondtothequeriesabove.thesequeriesconstituteanimportantpartofwhatiscollectivelyknownas language servicesand canbe issued bybothonline ides sophisticated code editorssuchassublimetext andfull ledgedidessuchaseclipse andvisualstudio.figure 6showsexamples of an ide inaction.
soundness given the nature of such tasks that focus on program understanding thegoalisnottoalwaysbeabsolutelyprecise but to be both useful to the end user and responsive.
our analysis judiciouslycutscornersinthespiritofsoundiness .astheanalysis resultsareusedinanadvisoryroleinthecontextofprogramunderstandinginaninteractivesetting completesoundnessisnotthe goal.forinstance wedonotattempttomodelrelectiveconstructs.
whilewefocusonc astheinputlanguage ourworkshouldapply equallywelltoanalyzinglargeprojectsinjavaandothersimilar object oriented languages.
it is not however our goal to faithfully handleallthetrickylanguagefeaturessuchasrelection runtime code generation and pinvoke basednative calls.
.
contributions this paper makesthe following contributions weproposeadistributedstaticanalysisapproach basedonthe monotone framework and show how to apply it to call graph construction for answering program understanding and code browsing queries.
we describe how the analysis is implemented on top of the orleansdistributedprogramming platformand isdeployed on legacy hardware inthe cloud using microsoftazure.
we experimentally demonstrate the scalability of our distributed call graph implementation using a range of synthetic and real benchmarks.
the results show that our analysis scales well in terms of memory pressure independently of the input size as we add more machines.
despite using stock hardware and incurringanon trivialcommunicationoverhead wescaletoinputs containing10millionloc forinputsof1mloc theanalysisrequires at least machines for 10m loc machines.
while the communicationoverheadcanbecomeabottleneck weshowthat asthenumberofmachinesincreases upto64 theanalysistime generally drops.
depending on the setting partial results can be queried before theanalysis has inished.lastly we demonstrate that querying the results can be performed with an acceptable median latency of15 ms. overview ourgoalistohavetheanalysisbackendrespondtoqueriesquickly independentlyoftheinputsize.ofcourse wealsoneedtomake sure that the backend does not run out of memory or timeout in someunpredictableway.ourrequirementsforceustorethinksome ofthe typicalassumptions of whole program analysis.
443towardfullelasticity in distributedstaticanalysis the caseof callgraphanalysis esec fse september04 paderborn germany while mq 0do a m mq.choose v unpack m value ifv value then continue endif v tf v ifv v then u delta v v for eachuinudo mq mq pack a u endfor value v endif endwhile figure distributed worklistalgorithm.
.
analysis design principles weusea distributedactormodel asthebasisofourdistributed static analysis engine.
for a program written in an object oriented language such as java or c a natural it is to have an actor per methodwithin the program.
we could choose to have an actor per classinaprogram oranyotherwell deinedprogramentity.these actors are responsible for receiving messages from other actors processingthemusinglocalstate arepresentationofthemethod body for instance and sending information to other methods that dependonit.forexample foracallgraphconstructionanalysis actorsrepresentingindividualmethodsmaysendmessagestoactors for their callers and callees.
our analysis design adhere to the following distilledprinciples.
minimalin memorystateperactor wewantto pack asmany actors per machine as possible without creating undue memory pressure leadingto swapping etc.
design for lightweight serialization we have designed our analysis so that the updates sent from one actor to another are generally small and easily serialized.
there is minimal sharing amongactors asactorholdsontoitslocalstateandoccasionally sends small updates to others.
the same principle applies to persistent per actor state as well.
we only serialize the bare minimum to disk before the actor is put to sleep.
this can happen when the actorruntimedecidestopageanactoroutduetomemorypressure orlackofrecent use.
state can be recomputed on demand in a distributed setting we have to face the reality that processes may die due to hardware and orsoftwarefaults.itisthereforeimperativetobeabletorecover in case of state loss.
while it is possible to commit local state to persistent store we eschew the overhead of such an approach and instead choose to recompute per node state ondemand.
locality optimizations to minimize communication we attempt to place related actors together on the same machine.
in the caseofacallgraphanalysis this oftenmeans that entirestrongly connectedcomponentsco existonthesamephysicalbox which minimizesthenumberofmessagesthatweactuallyneedtodispatch acrossthe network.
.
distributedworklist algorithm wenowpresentahigh levelviewofadistributedanalysisproblem as apair a l where aisasetofactors distributedinanetwork.
l isacomplete semi lattice ofiniteheight3.
eachactor a ahas the following associatedfunctions value v listhe local state ofactor a 3the initeheightrequirementcanbeavoided with the useof awidening operator.
tf l maps o lis thetransfer functionfor thelocal computation performedwithin actor a.we assumeall tfare monotone thefollowinghelperfunctionsareforcommunicatingstatechanges among actors delta v v computesaset uof global updatesrequiredwhen switchingfrom local state vtov l pack a u is a function that given an update at actor a a producesoneorseveralmessagestocommunicatetootheractors.
unpack m is a function that unpacks a message and returns a valuev l. figure1showsthepseudocodeforadistributedworklistalgorithm.
the algorithm makes use of a global message queue denoted as mq4.thequeueisinitializedwithasetofstartingmessagesthat willdepend onthe actual analysisinstance.
.
terminationandnon determinism we would like to show that the presented distributed worklist algorithm terminates.
lethdenotethe inite5 heightofsemi lattice landletn a .
consideriterationsthroughthelooponline1.let sconsidertwo sets of sequences of iterations i1are iterations that lead to a value increaseonline7and i2are thosethat do not.
we can have at most h niterations in i1given the inite size of the lattice.
for iterations in i2 the size of mqdecreases because at least one message is consumed but it does not generate other messages.
we considertwopossibilities startingfromsomeiteration i weonlyhaveiterationsin i2.this however meansthatoneveryiterationthesizeof mqdecreases until iteventually becomes empty.
theotherpossibilityisthatwewillhaveanininitenumberof iterationsin i1.thisisclearlyimpossiblebecausethesizeof i1 isboundedby h n. itisimportanttoemphasizethediferencebetweenthisdistributed algorithmandasingle nodeworklistapproach.ifamessageisin light we do not wish the program analysis to terminate.
however detectingtheemptinessof mqisnottrivial soinpracticewemust have an efective means for detecting termination.
we make use of anorchestrator mechanism for termination detection as described insection .
.
whilethealgorithminfigure1reachesaixpointindependently of the arrival order of messages it is natural to ask whether that is the only ixpoint that can be reached.
given that tf is monotone and lis of a inite height the uniqueness of least ixpoint is guaranteed .
call graph analysis inthissectionwepresentaninstantiationofthegeneralframework described in the previous section for computing call graphs.
our analysisisadistributedinterproceduralinclusion basedstaticanalysisinspiredbythevariabletypeanalysis vta presentedin .
thislow insensitiveanalysiscomputesthesetofpotentialtypes 4note thatmqis amathematical abstraction we do not actually use a global message queue in our implementation.
conceptually we can think of a local worklist maintainedonaper actorbasis.terminationisachievedwhenalltheworklistsare empty.
5note that our approach can also terminate for an ininite hight lattice with the use of awidening operator.
444esec fse september04 paderborn germany diegogarbervetsky edgardozoppi andbenjamin livshits for eachobject reference variable ield etc.
by solving a system of inclusion constraints.
because it propagates type constraints from object allocation sites to their uses this kind of analysis is sometimes referredto as concretetype analysis.
.
programrepresentation propagation graphs at the method level the inclusion based analysisisimplementedusingadatastructurewecalla propagationgraph pg .apgisa directedgraphusedto push type information to follow data low in the program as described by analysis rules.
our analysis naturally lands itself to incrementality although we do not evaluate this experimentally in this paper.
a typical change in the program would require often minimal recomputation within the modiied code fragment as well as propagation of that information to its neighbors .
propagation graphs support incrementalupdatessincethepropagationofinformationistriggeredwhen anewtype reaches anode.
terminology more formally let pg r e whererdenotes a set of nodes representing abstract locations in the method such as variables and ields and erefers to a set of edges between them.
an edgee v1 v2 econnects nodes in the pg to model the potentiallowoftypeinformationfrom v1tov2.essentially anedge representsarulestatingthat types v2 types v1 e.g v2 v1 .
tomodelinterproceduralinteraction thepgalsoincludesnodes representing method invocations invloc and return values rv .
finally i rdenotes the set of invocations.
let tbe the set of all possible types dtypecontains declared types compile time types for abstract locations and typesdenotes concrete types inferred byour analysis.
.
analysis phases intheactormodel thechoiceofgranularityiskeyforperformance.
wedecidedtouseoneactorpermethod althoughotherdesigndecisionssuchasoneactorperclassarealsopossible.eachmethod level actor contains a pg that captures type information that propagates through the method.
the analysis starts by analyzing an initial set ofrootmethods m0.wedescribebothintra andinterprocedural processing below.
.
.
intraproceduralanalysis.
this phaseis the responsible of computing the local state of an actor representing amethod.
instantiatingtheproblem thelattice lforouranalysisconsists ofamappingfromabstractlocationstosetsofpossibletypesand isdeinedas l types r maps o 2t type type with typedeinedas l1 typel2ifl1.types r l2.types r r r and typedeinedas l1 typel2 l3where l3.types r l1.types r l2.types r r r. analysis rules that compute tf are summarized in figure and cover the typical statement types such as loads stores allocations etc.
object dereferences i.e.
v.f are represented by using thev1 v2 types v1 types v2 v1 v2.f types v1 types dtype v2 .f v1.f v2 types dtype v1 .f types v2 v newc c types v returnv types rv types v loc v v0.m v1.
..vn types invloc uniondisplay j ..ntypes vj figure vtaanalysis rules.
name of the class deining the ield.
that is the analysis is ieldsensitivebutnotobject sensitive.inthecaseofinvocationsthere is an inclusion relation to model the low of all the arguments to theinvocationabstractlocation invloc i r.notethatthelefthand side vof the invocation is not updated by the rule since it depends on the result of the invoked method.
this will be handled byinterproceduralanalysis.
noticethat tf ismonotonicbecausethepropagationoftypes never removes a type and lsatisies the inite height condition because itisainitelattice.
.
.
interprocedural analysis.
once the intraprocedural phase inishes relevantupdatesmustbecommunicatedtothecorrespondingmethods calleesandcallers .asmentioned theanalysisconsidersinvocationsusingtheset i r.tohandlecallers updates we need to extend the lattice to include the caller s information for the current method.
this has the form m lhs wherem a denotes the caller s name and lhs rrepresents the left hand side of the invocation made by the caller.
the extended lattice is shown below.
l types r maps o 2t callers 2a r l1 l2ifl1 typel2 l1.callers l2.callers l1 l2 ts cs where ts l1 typel2 cs l1.callers l2.callers a message mhas the form kind d data where kind callmsg retmsg is the kind of message d ais the destinationactor and dataisatuple.
instantiating delta infigure3aweshowthedeinitionofthe deltaoperation described in section .
it computes the set of invocationsthatwereafectedbythepropagation.aninvocation is afected if the set of types lowing to any of its parameters grew.
additionally wealsomustconsiderchangesintypesthatthereturn valuemaycorrespondto sincetheyneedtobecommunicatedto the callers.
instantiating pack figure3bshowsadeinitionof pack.this function is in charge of converting local updates to messages that can be serialized and sent to other actors.
for each invocation the analysis uses the computed type information of the receiver argument to resolve potentialcallees.
then it builds a caller message including the potential types for each argument.
those types will be added to the set of types of the parameters on the caller actor.
in case of an update in return value itbuildsamessagetoinformthecalleraboutchangestothereturn value stypes.thismessageincludesthe original caller sleft hand side sothat the caller can updateits types.
445towardfullelasticity in distributedstaticanalysis the caseof callgraphanalysis esec fse september04 paderborn germany letdif v v r v .types r v.types r letinv v v inv inv i dif v v inv nequal letrv v v braceleftbigg rv ifdif v v rv nequal otherwise delta v v def inv v v rv v v a deinition of delta v v letcallees inv c.m c l.types ar s inv letcallmsg a inv a lhs inv l.types ar s inv letcallmsgs a inv callmsg d callmsg a inv d callees inv letreturnmsg a c a lhs c l.types rv letretmsgs a retmsg method c returnmsg a c c l.callers pack a u def braceleftbigg callmsgs a u ifu i retmsgs a ifu rv b deinitionof pack a u .l.types ar s istheliftingof l.typesto the list of arguments it returns a lists of set of types.
given inv v v0.m v1...vn ar s inv lhs inv v. for a caller c m lhs l.callers method c m the caller s nameand lhs c lhs theleft handsideoftheoriginalinvocation made by thecaller.
letl1.types r braceleftbigg ar types m iifr pi otherwise letl1.callers sender m lhs m letl2.types r braceleftbigg rettypes m ifr lhs m otherwise unpack m def braceleftbigg l1ifkind m callmsg l2ifkind m retmsg c deinition of unpack m .
for a message m callmsg d a lhs ar types m i tsi the set of potential types for the ithargument pi.lhs m lhs sender m a. for a return message m retmsg d a lhs ts rettypes m tsis the set of potential types of the method s returnvalue.
figure deining delta unpack andpack.
instantiating unpack function unpack infigure3cisresponsibleforprocessingmessagesreceivedbyanactor.thisfunction convertsamessageintoavalueinthelatticeofthelocalanalysis thatwillbethenjoinedintothelocalstate.amessagecanbeeither acall message i.e.
an invocation made by a caller or a return message i.e.
toinformachangeinthecallee sreturnvalue .forcall messages we produce an element that incorporates the types for eachcallargumentintothemethodparameters.wealsoupdatethe set of callers.
for return messages we need to update the left hand sideofthe invocation withthe potentialtypes ofthe return value.
example thisexampleillustratestheadvantageofusingconcretetypes asopposedto declaredtypes to obtain more precision.
consider the small program in figure 4a.
in figure 4b we show the propagation graphsfor both methods.
as theanalysisstarts only the left handsidesofallocations lines2and11 contain types.
duringpropagation type blowsfromvariable xintoaninvocation of mas an argument.
this triggers a message to the actor for methodb.m.
the low through parameter pandwmakes the return1public static void main 2a x newb allocation 3a y x.m x 4a z y 6public class a 7public abstract a m a p 9public class b a public override a m a p a w newb allocation return p !
null ?
p w a codeexamplefor interproceduralpropagation.
a actual argument of call m x a y a z a x b a p a returnvalue a w b a actual argument of call m x b a y b a z b a x b a p b a returnvalue b a w b call messagereturn message b pgs for methods mainandb.mbefore left and after right the propagationfor thecodeinfigure4a.
figure codeandpropagation graphforexample .
valueofb.mtocontaintype b.thisinturntriggersareturnmessage thatadds btothetypesof y.thispropagatesto z.concretetype analysis produces resultsthat are more accurate for y z etc.
than what we can obtain from their declaredtypes.
typeapproximation intheinterproceduralstage ouranalysis sends information about concrete parameter types to its callees.
however whenitcomestocomplex nestedobjects thisinformationispotentiallyinsuicient asitonlyconcernsonelevelofthe objecthierarchy.considerthe following example voidmain voidm a p a x newb a z p.f x.f newb return z y m x function packwill create a message that propagates the type of x intomandunpack will discover the type of pto beb.
however noinformationisgivenforthetypeof p.f potentiallyleadingto unsoundness.insteadofsendinginformationaboutnestedields whichleadstoincreasedmessagesizes weoptedtousethetypeof p.fgivenbyadistributedversionoftherapidtypeanalysis thatrunssimultaneouslyoneachmethod actor whenrtaprovides nousefulinformation wefallbackondeclaredtypes.wedidnot observe imprecision causedbythis over approximation.
.
otheruses oftheanalysis framework thedistributed algorithm in figure 1can be instantiated forother program analyses that follow the same design principle.
for instance consideraninclusion basedanalysislikeandersen spointsto .
a possible instantiation may be as follows each actor representsamethod thetransfer functionimplementsandersen s inclusion rules locally and in case there is a change in an 446esec fse september04 paderborn germany diegogarbervetsky edgardozoppi andbenjamin livshits argumentofamethodinvocation producesanupdatemessageto be sentto the potentialcallees.
similarly byjustreplacingtheinclusionruleswithuniication rulesinthetransferfunction wecanturnitintoauniicationbased points toanalysislikesteensgaard s .context sensitivitycanbe achieved by representing diferent context methodcombinations withdiferentactors.
it is worth noticing that our analysis has similar characteristics asstandarddatalowanalyses butanorderingonhowinformation lowsbetweentheactorscannotbeassumed.weenvisionfuture work where our distributed back end would be combined with a natural front end for this kind of analysis that uses datalog as previously proposed for single machine analysis .
however aswedescribeinsection1.
ourevaluationinsection5focuses on quickly answering interactive questions related to call graph resolutioninthe contextofaide.
implementation we implemented a prototype of our distributed approach6to analyze large scale projects written in c .
this prototype relies on roslyn acompilerframeworkforanalyzingc codeandthe orleansframework animplementationofadistributedactor model thatcan bedeployedinthecloud.
althoughotherdeployment options such aws are possible for this paper we used azure as aplatform for running our experiments.
.
orleans andtheactormodel orleans isaframeworkdesignedtosimplifythedevelopment of distributed applications.
it is based on the abstraction of virtual actors.
in orleans terminology these actors are called grains.
orleanssolvesanumberofthecomplexdistributedsystemsproblems such as deciding where on which machine to allocate a given actor sending messages across machines etc.
largely liberating developers from dealing with those concerns.
at the same time the orleans runtime is designed to enable applications that have high degrees of responsiveness and scalability.
grains are the basic building blocks of orleans applications and are the units of isolation and distribution.
every grain has a unique global identity that allows the underlying runtime to dispatch messages between actors.anactorencapsulatesbothbehaviorandmutablelocalstate.
stateupdatesacrossgrains can be initiatedusing messages.
the runtime decides which physical machine siloin orleans terminology a given grain should execute on given concerns such asmemorypressure amountofcommunicationbetweenindividual grains etc.
thismechanism isdesignedtooptimizeforcommunication locality because even within the same cluster the amount of cross machine messages are considerably smaller than the amount oflocal messages within the same machine.
we follow a speciic strategy in organizing grains at runtime.
this strategy is driven by the input structure.
the input consists of anmsbuild solution a.slnilethatcanbeopenedinvisualstudio.
each solution consists of a set of project iles .csproj which may depend on each other.
roslyn allows us to enumerate all project iles within a solution source iles withina project classes within 6source codeand benchmarks available ongithubat .a ile methods within a class etc.
furthermore roslyn can use its built inc compilertocompilesourcesonthely.
wedeinegrains for solutions projects and methods.
we did not ind it necessary toprovidegrainsforclassesandotherhigher levelcodeartifacts such asnamespace s. asolutiongrainisasingletonresponsibleformaintainingthe listofprojectsandproviding functionality to ind methodswithin projects a project grain contains the source code of all iles for that project and provides functionality to compute the information requiredbymethodgrains e.g.
tobuildpropagationgraphsbyparsingthemethodcode aswellastyperesolution e.g.
methodlockup subtypingqueries etc .finally amethodgrainisresponsiblefor computingthelocaltypepropagationandresolvingcaller callees queries it stores type information for abstract locations within the method.
thesolutiongrainreadsthe .slnilefromcloudstorage inour implementation we used azure files but other forms of input that support ile like apis such as github or dropbox are also possible.
projectgrains read .csprojilesandalsoproceedtocompilethe sourcescontainedintheprojecttogetaroslyn compilation object.
thisinformationisonlycontainedintheprojectgraintominimize duplication.
to obtain information about the rest of the project method grains can consult the project grain.
we use caching to reducethenumberofmessagesbetweenmethodandprojectgrains.
example2 toillustratepersistentstateforatypicalmethodgrain consider the example in figure 4a.
the state of both methods is as follows.
methodmain callers types x b y b z b b methodb.m callers a.main y types p b w b returnvalue b this minimal state iseasily serialized to disk if thegrainsare ever deactivated by the orleans runtime.
orleans deactivates grains whentheyaren tusedforalongtime however thisneverhappened inour experiments.
.
distributed analysis challenges implementing a distributed system like ours is fraught withsome fundamental challenges.
reentrancy sincethecallgraphcanhavecycles agraincanstarta propagationwhichwillinturneventuallypropagatetotheoriginal method.
however since orleans uses turn based concurrency this willcreateadeadlock.evenwithoutrecursionitispossiblefora methodgrain thatis currentlybeing processedtoreceive another message i.e.areturn message .
termination in a distributed setting detecting when we achieve termination is not so easy.
this is in part because even if all the local worklists are empty we may have messages in light or those that have been delayed.
a na ve implementation is not going to work well because of reentrancyissues wecanblockwaitingforamessagethatwaits for our response.
in our implementation we use orchestrators to 447towardfullelasticity in distributedstaticanalysis the caseof callgraphanalysis esec fse september04 paderborn germany orleans client dispatcher grain dispatcher grain dispatcher grain m manalyze enqueue effectm enqueue effectsubscribe notify m m enqueue effectdequeuesubscribe notify notifysubscribe enqueue effectanalyze analyze analyze enqueue effectanalyze queuequeuequeuequeue queuequeueenqueue effectdequeue dequeue enqueue effectanalyzeanalyzesilo silo silo figure the multi queue approach illustrated.
method grains are circles shown in light blue.
solid and dashed arrows represent standard invocations and callbacks respectively.each silo haseachowndispatchergrain.
establish somedegree ofcentralized controlover thepropagation process.grains communicatewith an orchestrator exclusively instead of communicating with each other peer to peer.
this avoids theissueofreentrancybyconstruction onlytheorchestratorcan send messages to grains via a single message queue .
the orchestratorkeepstrackoftheoutstandingtasksandcanthereforedetect both terminationandpreventreentrant calls from taking place.
thekeydisadvantageofthisdesignisthatitispossibletohavea great deal of contention for access to the orchestrator.
we observed thisinpractice suggestingadiferentvariantofthisidea.weuse a collection of queues distributed across the distributed system.
each methodgrainisapotentialproducerof efectstobeprocessedby othermethodgrains.toavoidreentrancy thisinformationisnot sentdirectlytothetargetmethodgrainbutitisenqueuedinone of the queues in a round robin fashion.
the information is then consumed by dispatchers grains that pullthe data from the queues anddeliverittothecorrespondingmethodgrains thisisillustrated infigure .
usingthismechanismweavoidbothreentrancy bottlenecksand single points of failure.
the drawback is that detecting termination is more complex.
for that we use timers to determine when a dispatcher becomes idle i.e.
inactive longer than a predetermined threshold atwhichpointwenotifytheclient.theanalysisinishes when the client is sure that all dispatchersare idle7.
in practice we set the number of queues to be four times higher than the number ofworkervms forexample 128queuesfor32workervms and setthe terminationthreshold to seconds.
.
deploymentdetails our analysis is deployed in azure as illustrated in figure .
on the left there is the analysis client such as an ide or a code editor like sublimetext.
the cluster we used consists on one front end vm and a number of worker vms.
the client used rest requests to communicatetothefront endvm.thejobofthefront endvmisto acceptandprocessexternalanalysisclientrequests dispatch jobstotheworkervmsandprocesstheresults and providea webuiwithanalysisresults andstatistics.
interactive deployment within an ide in figure we show twoscreen shotsofanexperimentalideprototypethatusesthe 7wehavea mechanism to detect when anidledispatcherbecomes activeagain.
a visualizing callees callsite on line invokes function dotest.
b visualizing callers method baris calledon line .
figure anexperimental online ide that usesanalysis for resolving