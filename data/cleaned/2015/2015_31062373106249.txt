failure directed program trimming kostas ferles the university of texas at austin usa kferles cs.utexas.eduvalentin w stholz the university of texas at austin usa valentin cs.utexas.edu maria christakis university of kent uk m.christakis kent.ac.ukisil dillig the university of texas at austin usa isil cs.utexas.edu abstract this paper describes a new program simplification technique called program trimming that aims to improve the scalability and precision of safety checking tools.
given a program p program trimming generates a new program p such thatpandp areequi safe i.e.
p has a bug if and only if phas a bug butp has fewer execution paths thanp.
since many program analyzers are sensitive to the number of execution paths program trimming has the potential to improve the effectiveness of safety checking tools.
in addition to introducing the concept of program trimming this paper also presents a lightweight static analysis that can be used as a pre processing step to remove program paths while retaining equi safety.
we have implemented the proposed technique in a tool called trimmer and evaluate it in the context of two program analysis techniques namely abstract interpretation and dynamic symbolic execution.
our experiments show that program trimming significantly improves the effectiveness of both techniques.
ccs concepts software and its engineering formal methods keywords condition inference abstract interpretation dynamic symbolic execution acm reference format kostas ferles valentin w stholz maria christakis and isil dillig.
.
failure directed program trimming.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction due to its potential to dramatically simplify programs with respect to a certain criterion e.g.
the value of a program variable at a given location program slicing has been the focus of decades permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
research in the program analysis community .
in addition to being useful for program understanding slicing also has the potential to improve the scalability of bug finding and verification tools by removing irrelevant code snippets with respect to some property of interest.
yet despite this potential relatively few bugfinding and verification tools use slicing as a pre processing step.
in this paper we argue that existing notions of a program slice do not adequately capture the kinds of program simplification that are beneficial to safety checking tools.
instead we propose a new semantic program simplification technique called program trimming which removes program paths that are irrelevant to the safety property of interest.
given a program p program trimming generates a simplified program p such thatp violates a safety property if and only if the original program pdoes i.e.
pandp areequi safe .
however p has the advantage of containing fewer execution paths thanp.
since the scalability and precision of many program analyzers depend on the number of program paths program trimming can have a positive impact on many kinds of program analyses particularly those that are notproperty directed.
to illustrate the difference between the standard notion of program slicing and our proposed notion of program trimming consider the following very simple program where indicates a nondeterministic value e.g.
user input 1x y 2if y while x x x y 3else x x 4assert x suppose that our goal is to prove the assertion so we are interested in the value of xat line .
now every single statement in this program is relevant to determining the value of x hence there is nothing that can be removed using program slicing.
however observe that the then branch of the ifstatement is actually irrelevant to the assertion.
since this part of the program can never result in a program state where the value of xis less than lines and can be simplified without affecting whether or not the assertion can fail.
hence for the purposes of safety checking the above program is equivalent to the following much simpler trimmed program p 1x y 2assume y 3x x 4assert x observe thatp contains far fewer paths compared to the original programp.
in fact whilepcontains infinitely many execution paths the trimmed program p contains only two one through the successful and one through the failing branch of the assertion.
esec fse september paderborn germany kostas ferles valentin w stholz maria christakis and isil dillig consequently program analyzers that eagerly explore all program paths such as bounded model checkers and symbolic execution engines can greatly benefit from program trimming in terms of scalability.
furthermore since many static analyzers e.g.
abstract interpreters typically lose precision at join points of the control flow graph program trimming can improve their precision by removing paths that are irrelevant to a safety property.
motivated by these observations this paper introduces the notion of failure directed program trimming and presents a lightweight algorithm to remove execution paths in a way that guarantees equisafety.
the key idea underlying our approach is to statically infer safety conditions which are sufficient conditions for correctness and can be computed in a lightweight way.
our technique then negates these safety conditions to obtain trimming conditions which are necessary conditions for the program to fail.
the trimming conditions are used to instrument the program with assumptions such that program paths that violate an assumption are pruned.
program trimming is meant as a lightweight but effective preprocessing step for program analyzers that check safety.
we have implemented our proposed trimming algorithm in a tool called trimmer and used it to pre process hundreds of programs most of which are taken from the software verification competition svcomp .
we have also evaluated the impact of trimming in the context of two widely used program analysis techniques namely abstract interpretation and dynamic symbolic execution .
our experiments with crab an abstract interpreter show that program trimming can considerably improve the precision of static analyzers.
furthermore our experiments with klee a dynamic symbolic execution tool show that program trimming allows the dynamic symbolic execution engine to find more bugs and verify more programs within a given resource limit.
to summarize this paper makes the following key contributions we introduce the notion of program trimming as a new kind of program simplification technique.
we propose an effective and lightweight inference engine for computing safety conditions.
we describe a modular technique for instrumenting the program with trimming conditions.
we demonstrate empirically that program trimming has a significant positive impact on the effectiveness of program analyzers.
guided tour the running example shown in figure is written in c extended with assume andassert statements.
note that the example is intentionally quite artificial to illustrate the main ideas behind our technique.
procedure main assigns a non deterministic integer value to variable mand computes its factorial using the recursive fact procedure.
the light and dark gray boxes are discussed below andshould be ignored for now .
we examine two variations of this example one for dynamic symbolic execution dse engines and another for abstract interpreters ai .
motivation scalability.
first let us ignore the assertion on line and only consider the one on line .
clearly this assertion cannot fail unless mis equal to .
observe that procedure main contains infinitely many execution paths because the number of1int fact int n assume n assume n !
ai int r if n !
r n fact n assert n !
r ai return r 11void main int m assume m dse int f fact m assert m !
f dse figure running example illustrating program trimming.
recursive calls to fact depends on the value of m which is unconstrained.
consequently a dynamic symbolic execution engine like klee would have to explore a number of these paths until it finds the bug or exceeds its resource limit.
however there is only one buggy execution path in this program meaning that the dynamic symbolic execution engine is wasting its resources exploring paths that cannot possibly fail.
our approach.
now let us see how program trimming can help a symbolic execution tool in the context of this example.
as mentioned in section our program trimming technique first computes safety conditions which are sufficient conditions for the rest of the program to be correct.
in this sense standard weakest preconditions are instances of safety conditions.
however automatically computing safety conditions precisely for instance via weakest precondition calculi abstract interpretation or predicate abstraction can become very expensive especially in the presence of loops or recursion making such an approach unsuitable as a pre processing step for program analyzers that already check safety.
instead we use lightweight techniques to infer safety conditions that describe a subset of the safe executions in the program.
that is the safety conditions inferred by our approach can be stronger than necessary but they are still useful for ruling out many program paths that obviously cannot violate a safety property.
in contrast to a safety condition a trimming condition at a given program point reflects a necessary condition for the rest of the program execution to fail.
since a necessary condition for a property qcan be obtained using the negation of a sufficient condition for q we can compute a valid trimming condition for a program point as the negation of the safety condition at .
thus our approach trims the program by instrumenting it with assumptions of the form assume where is the negation of the safety condition for that program point.
since condition is by construction necessary for the program to fail the trimmed program preserves the safety of the original program.
moreover since execution terminates as soon as we encounter an assumption violation instrumenting the program with trimming conditions prunes program paths in a semantic way.
program trimming on this example.
revisiting our running example from figure the safety condition right after line is m !
f .
since procedure fact called at line neither 175failure directed program trimming esec fse september paderborn germany contains any assertions nor modifies the value of m a valid safety condition right before line is m !
.
indeed in executions that reach line and satisfy this safety condition the assertion does not fail.
we can now obtain a sound trimming condition by negating the safety condition.
this allows us to instrument the program with the assume statement shown in the dark gray box of line .
any execution that does not satisfy this condition is correct and is effectively removed by the assume statement in a way that preserves safety.
as a result a dynamic symbolic execution tool running on the instrumented program will only explore the single execution path containing the bug and will not waste any resources on provably correct paths.
observe that a bounded model checker would similarly benefit from this kind of instrumentation.
motivation precision.
to see how our approach might improve the precision of program analysis let us ignore the assertion on line and only consider the one on line .
since n implies r on line this assertion can clearly never fail.
however an abstract interpreter like crab using intervals cannot prove this assertion due to the inherent imprecision of the underlying abstract domain.
in particular the abstract interpreter knows that n is non negative at the point of the assertion but has no information about r i.e.
its abstract state is .
hence it does not have sufficient information to discharge the assertion at line .
suppose however that our technique can infer the safety conditionn on line .
using this condition we can now instrument this line with the trimming condition n !
which corresponds to the assumption in the light gray box.
if we run the same abstract interpreter on the instrumented program it now knows that nis strictly greater than and can therefore prove the assertion even though it is using the same interval abstract domain.
hence as this example illustrates program trimming can also be useful for improving the precision of static analyzers in verification tasks.
program trimming in this section we formally present the key insight behind failuredirected program trimming using a simple imperative language in the style of imp augmented with assert andassume statements.
this lays the foundation for understanding the safety condition inference which is described in the next section and is defined for a more expressive language.
here we present the semantics of the imp language using big step operational semantics specifically using judgments of the form s where sis a program statement arevaluations mapping program variables to values indicates whether an assertion violation occurred an assumption was violated or neither assertion nor assumption violations were encountered denoted .
we assume that the program terminates as soon as an assertion or assumption violation is encountered.
we also ignore non determinism to simplify the presentation.
definition .
.
failing execution we say that an execution of sunder isfailing iff s and successful otherwise.
in other words a failing execution exhibits an assertion violation.
executions with assumption violations also terminate immediately but are not considered failing.definition .
.
equi safety we say that two programs s s are equi safe iff for all valuations we have s s in other words two programs are equi safe if they exhibit the same set of failing executions starting from the same state .
thus program s has a bug if and only if shas a bug.
as mentioned in section the goal of program trimming is to obtain a program s that a is equi safe to sand b can terminate early in successful executions of s definition .
.
trimmed program a program s is atrimmed version ofsiffs s are equi safe and s s s s s here the first condition says that the trimmed program s either exhibits the same successful execution as the original program or terminates early with an assumption violation.
the second condition says that if the original program terminates with an assumption violation then the trimmed program also violates an assumption but can terminate in a different state .
in the latter case we allow the trimmed program to end in a different state than the original program because the assumption violation could occur earlier in the trimmed program.
intuitively from a program analysis perspective we can think of trimming as a program simplification technique that prunes execution paths that are guaranteed not to result in an assertion violation.
observe that program trimming preserves all terminating executions of program s. in other words if sterminates under valuation then the trimmed version s is also guaranteed to terminate.
however program trimming does not give any guarantees about non terminating executions.
hence even though this technique is suitable as a pre processing technique for safety checking it does not necessarily need to preserve liveness properties.
for example non terminating executions of scan become terminating in s .
the definition of program trimming presented above does not impose any syntactic restrictions on the trimmed program.
for instance it allows program trimming to add and remove arbitrary statements as long as the resulting program satisfies the properties of definition .
.
however in practice it is desirable to make some syntactic restrictions on how trimming can be performed.
in this paper we perform program trimming by adding assumptions to the original program rather than removing statements.
even though this transformation does not simplify the program from a program understanding point of view it is very useful to subsequent program analyzers because the introduction of assume statements prunes program paths in a semantic way.
static analysis for trimming as mentioned in section our trimming algorithm consists of two phases where we infer safety conditions using a lightweight static analysis in the first phase and instrument the program with trimming conditions in the next phase.
in this section we describe the safety condition inference.
176esec fse september paderborn germany kostas ferles valentin w stholz maria christakis and isil dillig programp prc procedure prc proc prc vin vout s statement s s1 s2 v e v1 v2 v e v malloc e v call prc v assert p assume p if s1 else s2 expression e v c e1 e2 predicate p e1 e2 p1 p2 p1 p2 p figure programming language used for formalization.
the notation sdenotes a sequence s1 .
.
.
sn.
.
programming language in order to precisely describe our trimming algorithm we first introduce a small but realistic call by value imperative language with pointers and procedure calls.
as shown in figure a program in this language consists of one or more procedure definitions.
statements include sequencing assignments heap reads and writes memory allocation procedure calls assertions assumptions and conditionals.
since loops can be expressed as tail recursive procedures we do not introduce an additional loop construct.
also observe that we only allow conditionals with non deterministic predicates denoted .
however a conditional of the form if p s1 else s2 can be expressed as follows in this language if assume p s1 else assume p s2 since the language is quite standard we do not present its operational semantics in detail.
however as explained in section we assume that the execution of a program terminates as soon as we encounter an assertion or assumption violation i.e.
the predicate evaluates to false .
as in section we use the term failing execution to indicate a program run with an assertion violation.
.
safety condition inference recall from section that a safety condition at a given program point is a sufficient condition for any execution starting at to be error free.
more precisely a safety condition for a terminating statement sis a formula such that wp s true where wp s denotes the weakest precondition ofswith respect to postcondition .
while the most precise safety condition is wp s true our analysis intentionally infers stronger safety conditions so that trimming can be used as a pre processing technique for safety checkers.
our safety condition inference engine is formalized using the rules shown in figure .
our formalization makes use of an oracle for resolving queries about pointer aliasing and procedure side effects.
for instance this oracle can be implemented using a scalable pointer analysis such as the data structure analysis dsa method of lattner et al.
.
in the rest of this section we assume that the oracle for resolving aliasing queries is flow insensitive .
figure includes two types of inference rules one for statements and one for procedures.
both forms of judgments utilize a summary environment that maps each procedure prcto its corresponding safety condition or summary .
since our language contains recursive procedures we would in general need to perform a fixed point s2 2 2 s1 1 s1 s2 1 v e v1 v2 store drf v e v e v. v malloc e modlocs prc s v.havoc s summary prc vact v call prc vact p assert p p assume p s1 1 s2 2 1 2 if s1 else s2 true s proc prc vin vout s figure inference rules for computing safety conditions.
computation to obtain sound and precise summaries.
however because our analysis initializes summaries conservatively the analysis can terminate at any point to produce sound results.
with the exception of rule all rules in figure derive judgments of the form s .
the meaning of this judgment is that using environments and it is provable that s is a valid hoare triple i.e.
wp s ifsterminates .
similarly to the computation of standard weakest preconditions our analysis propagates safety conditions backward but sacrifices precision to improve scalability.
next we only focus on those rules where our inference engine differs from standard precondition computation.
heap reads and writes.
an innovation underlying our safety condition inference is the handling of the heap.
given a store operation v e this statement can modify the value of all expressions x where xis an alias of v. hence a sound way to model the heap is to rewrite v eas v e if v v1 v1 e .
.
.
if v vk vk e wherev1 .
.
.
vkare potential aliases of v. effectively this strategy accounts for the side effects of statement v eto other heap 177failure directed program trimming esec fse september paderborn germany locations by explicitly introducing additional statements.
these statements are of the form if v vi vi e i.e.
ifvandviare indeed aliases then change the value of expression vitoe.
while the strategy outlined above is sound it unfortunately conflicts with our goal of computing safety conditions using lightweight analysis.
in particular since we use a coarse but scalable alias analysis most pointers have a large number of possible aliases in practice.
hence introducing a linear number of conditionals causes a huge blow up in the size of the safety conditions computed by our technique.
to prevent this blow up our inference engine computes a safety precondition that is stronger than necessary by using the following conservative store operation.
definition .
.
memory location we represent memory locations using terms that belong to the following grammar memory location v drf here vrepresents any program variable and drfis an uninterpreted function representing the dereference of a memory location.
to define our conservative store operation we make use of a function aliases v that uses oracle to retrieve all memory locations that may alias v. definition .
.
store operation letderefs denote all for which a sub term drf occurs in formula .
then store drf e i a i where a aliases derefs in other words we compute the precondition for statement v eas though the store operation was a regular assignment but we also assert that vis distinct from every memory location ithat can potentially alias v. to see why this is correct observe that gives the weakest precondition of v ewhenv does not have any aliases.
if vdoes have aliases that are relevant to the safety condition then the conjunctv i a v i vevaluates tofalse meaning that we can never guarantee the safety of the program.
thus store drf v e logically implies wp v e .
example .
.
consider the following code snippet if assume x y a else assume x y y x a t y assert t right before the heap write x a our analysis infers the safety condition drf y x y. before the heap write y the safety condition is x y which causes the condition before the assumption assume x yto be true.
this means that executions through the else branch are verified and may be trimmed because xandyare not aliases for these executions.
interprocedural analysis.
we now turn our attention to the handling of procedure calls.
as mentioned earlier we perform interprocedural analysis in a modular way computing summaries for each procedure.
specifically a summary f for procedure f is a sufficient condition for any execution of fto be error free.
with this intuition in mind let us consider rule for analyzing procedure calls of the form v call prc e .
suppose that is theset of memory locations modified by the callee prcbut expressed in terms of the memory locations in the caller .
then similarly to other modular interprocedural analyses we conservatively model the effect of the statement v call prc vact as follows assert summary prc havocv havoc here havoc denotes a statement that assigns an unknown value to memory location .
hence our treatment of procedure calls asserts that the safety condition for prcholds before the call and that the values of all memory locations modified in prcare destroyed .
while our general approach is similar to prior techniques on modular analysis there are some subtleties in our context to which we would like to draw the reader s attention.
first since our procedure summaries i.e.
safety conditions are not provided by the user but instead inferred by our algorithm see rule we must be conservative about how summaries are initialized .
in particular because our analysis aims to be lightweight we do not want to perform an expensive fixed point computation in the presence of recursive procedures.
therefore we use the following summary function to yield a conservative summary for each procedure.
definition .
.
procedure summary lethasasrts f be a predicate that yields trueiff procedure for any of its transitive callees contain an assertion.
then summary f v f iff dom false ifhasasrts f true otherwise in other words if procedure fis in the domain of meaning that it has previously been analyzed we use the safety condition given by f substituting formals by the actuals.
however if f has not yet been analyzed we then use the conservative summary false iffor any of its callees have assertions and trueotherwise.
observe that if fis not part of a strongly connected component scc in the call graph we can always obtain the precise summary forfby analyzing the program bottom up.
however if fis part of an scc we can still soundly analyze the caller by using the conservative summaries given by summary f v .
the other subtlety about our interprocedural analysis is the particular way in which havocking is performed.
since the callee may modify heap locations accessible in the caller we define a havoc operation that uses the store function from earlier to conservatively deal with memory locations.
definition .
.
havoc operation havoc drf vnew.store drf vnew wherevnew freevars havoc havoc tail havoc head observe that the above definition differs from the standard way this operation is typically defined .
in particular given a scalar variablev the assignment v and its postcondition the standard way to compute a conservative precondition for the assignment is v. i.e.
must hold for anyvalue ofv .
note that an alternative way of computing the precondition is x. where xis not a free variable in .
in the context of scalars these two definitions are essentially identical but the latter view allows 178esec fse september paderborn germany kostas ferles valentin w stholz maria christakis and isil dillig us to naturally extend our definition to heap locations by using the previously defined store function.
specifically given a heap location drf modified by the callee we model the effect of this modification as vnew.store drf vnew .
theorem .
.
suppose that s and assume that provides sound information about aliasing and procedure side effects.
then under the condition that sterminates and that the summaries provided by are sound we have wp s .
program instrumentation in the previous section we discussed how to infer safety conditions for each program point.
recall that program trimming annotates the code with trimming conditions which are necessary conditions for failure.
here we describe how we instrument the program with suitable assumptions that preserve safety of the original program.
intraprocedural instrumentation.
first let us ignore procedure calls and consider instrumenting a single procedure in isolation.
specifically consider a procedure with body s1 .
.
.
snand let true si .
.
.
sn we instrument the program with the statement assume right before statement siifsicomplies with the instrumentation strategy specified by the user see section .
note that we do not instrument at every single instruction because subsequent safety checkers must also analyze the assumptions which adds overhead to their analysis.
theorem .
.
suppose that our technique adds a statement assume before si .
.
.
sn.
then is a necessary condition for si .
.
.
snto have an assertion violation.
interprocedural instrumentation.
one of the key challenges in performing program instrumentation is how to handle procedure calls.
in particular we cannot simply annotate a procedure f using the safety conditions computed for f. the following example illustrates why such a strategy would be unsound.
example .
.
consider procedures foo bar and baz proc foo x x proc bar a x malloc a foo x assert a proc baz b x malloc b foo x assert b here the safety condition for procedure foois just truesince foo does not contain assertions or have callees with assertions.
however observe that we cannot simply instrument foowith assume false because there are assertions after the call to fooinbarandbaz.
one possible solution to this challenge is to only instrument the main method which would be very ineffective.
another possible strategy might be to propagate safety conditions top down from callers to callees in a separate pass.
however this latter strategy also has some drawbacks.
for instance in this example variables aand bare not in scope in foo hence there is no meaningful instrumentation we could add to fooshort of assume true which is the same as having no instrumentation at all.
we solve this challenge by performing a program transformation inspired by previous work .
the key idea underlying this transformation is to create for each procedure prc a new procedure 1this paper s extended version includes proofs or proof sketches for all theorems.prc that can never fail.
in particular we create prc by a changing all assertions assert inprctoassume and b replacing all calls tof including recursive ones with f .
now given a call site of prc v call prc e we replace it with the following conditional if v call prc e else v call prc e assume false this transformation is semantics preserving since it is merely a case analysis either prcsucceeds in which case it is safe to replace the call to prcwith prc or it fails in which case we can call original prcbut add assume false afterward since prchas failed.
the following example illustrates this transformation.
example .
.
consider the following procedures proc foo x y assert x bar y proc bar z assert z proc main x y foo x y our transformation yields the following new program proc foo x y assume x bar y proc foo x y assert x if bar y else bar y assume false proc bar z assume z proc bar z assert z proc main x y if foo x y else foo x y assume false the main advantage of this transformation is that it allows us to perform program instrumentation in a modular and conceptually simple way.
in particular we do not need to instrument the safe version prc of a procedure prcsince prc never fails.
on the other hand it is safe to instrument prcwith the negation of the local safety conditions since every call site of prcis followed by the statement assume false i.e.
execution terminates immediately after the call .
example .
.
consider the following procedures fooandbar proc foo x assert x proc bar a x foo x assert a our instrumentation yields the following new program proc foo x assume x proc foo x assume x assert x proc bar a x assume a x if foo x else foo x assume false assert a discussion.
the reader may notice that our program transformation introduces additional branches that did not exist in the original program.
since the goal of program trimming is to reduce the number of execution paths while retaining equi safety this transformation may seem counter intuitive.
however because one 179failure directed program trimming esec fse september paderborn germany of the branches is always followed by assume false our transformation does not lead to a blow up in the number of paths and allows us to perform the instrumentation modularly.
implementation we have implemented our program trimming algorithm as a tool called trimmer meant as a lightweight pre processor for program analyzers that check safety.
our implementation is based on the llvm infrastructure and performs instrumentation at the llvm bit code level.
hence trimmer can be conveniently integrated into any safety checking tool that is built on top of the llvm infrastructure and is capable of analyzing assume statements.
recall from section that trimmer s safety inference engine requires alias and side effect information to soundly analyze heap stores and procedure calls.
for this purpose trimmer leverages llvm s dsa pointer analysis a highly scalable summarybased flow insensitive analysis.
since trimmer can be useful to a variety of program analysis tools including both static and dynamic analyzers trimmer can be customized in different ways depending on the assumptions made by subsequent safety checkers.
in what follows we describe the different configurations that trimmer provides.
reasoning about integer arithmetic.
trimmer provides the option of treating integral type expressions either as mathematical unbounded or fixed width integers.
since some safety checkers ignore integer over and under flows but others do not trimmer supports both encodings.2analyzers treating values as mathematical integers can therefore use the configuration of trimmer that also makes this same unsound assumption.
eliminating quantifiers.
recall from section that the safety conditions generated by our inference engine contain universal quantifiers.
hence when negating the safety conditions the resulting trimming conditions contain existentially quantified variables.
trimmer provides two alternatives for eliminating quantifiers.
first trimmer can remove quantifiers using z3 s quantifier elimination qe capabilities after simplifying and pre processing the formula.
second trimmer also allows replacing quantified variables by calls to non deterministic functions.
since quantified variables at the formula level correspond to program variables with unknown values this strategy has the same effect as quantifier elimination.
bounding the instrumentation.
after trimmer instruments the program with trimming conditions subsequent safety checkers need to analyze the assumptions.
hence the number of additional assume statements as well as the sizeof the predicates can affect the running time of program analyzers.
for this reason trimmer allows users to customize where to add assumptions in the code.
for example sensible strategies include adding instrumentation right before loops and procedure calls or before every conditional.
in a similar vein trimmer also provides different options for bounding the size of the formulas used in assume statements.
for example the user can bound the number of conjuncts in the formula to be at most k where kis a value chosen by the user.
this strategy 2for the fixed width integer encoding trimmer strengthens safety conditions by requiring that there are no integer over or under flows.
specifically trimmer utilizes arithmetic operations in the llvm instruction set that return both the result of the operation and a flag indicating whether an over flow occurred.
note that trimmer does not use bit vectors for encoding fixed width integers.is sound because trimmer guarantees that the simplified formulas are weaker than the original trimming conditions.
experiments to evaluate the effectiveness of program trimming we have used trimmer to pre process hundreds of programs by instrumenting them with assume statements.
since these assumptions are not useful on their own we evaluate the effect of program trimming in the context of two different llvm based program analyzers for safety checking.
in particular we use crab an abstract interpreter that supports several abstract domains and klee a widely used dynamic symbolic execution engine.
we ran our experiments on programs3 most of which are taken from the software verification competition sv comp benchmarks which have clearly defined outcomes and are handled by numerous tools.
since the errors in many of the buggy programs in this benchmark set are very shallow4 we also augment these benchmarks with additional buggy programs either taken from other sources or obtained by injecting deeper bugs into safe svcomp benchmarks.
the benchmarks taken from sv comp span a broad range of categories including controlflow loops recursive and arrayreach but exclude categories that are not handled byklee orcrab e.g.
bitvectorsreach concurrency .
in what follows we describe the effects of program trimming on the results of crab andklee .
we ran all of our experiments on an intel xeon cpu e5 v3 .60ghz machine with gb of memory running the ubuntu .
.
operating system.
we used the latest available version of crab and the latest version of klee that was compatible with llvm .
which crab requires.
.
impact of program trimming on crab to demonstrate that program trimming increases precision across a range of abstract domains we compare the performance of crab with and without trimming on three different domains with varying levels of precision intdenotes the non relational interval domain which infers invariants of the form c1 x c2 zones is the relational zones abstract domain which infers difference constraints of the form x y c rtz iscrab s most precise native abstract domain and corresponds to the reduced product of disjunctive intervals i.e.
disjunctions of constraints of the form c1 x c2 and the zones abstract domains.
as mentioned in section trimmer can be customized using a variety of different configurations.
to understand the precision vs. performance trade off we evaluate crab using the configurations of trimmer shown in table .
here the column labeled mc indicates the maximum number of conjuncts used in an assume statement.
the third column labeled qeindicates whether we use quantifier elimination or whether we model quantified variables using calls to non deterministic functions recall section .
finally the columns labeled l pandcdenote the instrumentation strategy.
in configurations where there is a checkmark under l p we add 3available at 4for example in the existing sv comp benchmarks klee can find the bug with a very low resource limit for of the buggy programs.
180esec fse september paderborn germany kostas ferles valentin w stholz maria christakis and isil dillig table overview of trimming configurations incl.
total number of added assume statements and time for preprocessing all benchmarks in the two right most columns .
configuration mc qe l p c atime s trim l b .
trim b .
trim nd b .
trim l .
trim .
trim nd .
assume statements right before loops l and before procedure p calls.
in configurations where there is a checkmark under c we also add instrumentation before every conditional.
the two right most columns show the total number of added assume statements not trivially true and the pre processing time for all benchmarks.
since average trimming time is milliseconds per benchmark we see that program trimming is indeed very lightweight.
the results of our evaluation are summarized in table .
as we can see from this table all configurations of program trimming improve the precision of crab and these improvements range from to .
for instance for the interval domain the most precise configuration of trimmer allows the verification of benchmarks instead of only when using crab without trimming.
another observation based on table is the precision vs. performance trade offs between different configurations of trimmer .
versions of crab that use trimmer with qe seem to be faster and more precise than those configurations of trimmer without qe.
in particular the version of trimmer with qe performs better because there are fewer variables for the abstract domain to track.
we also conjecture that trimmer using qe is more precise because the abstract domain can introduce imprecision when reasoning about logical connectives.
for instance consider the formula x. x x which is logically equivalent to false sotrimmer with qe would instrument the code with assume false.
however if we do not use qe we would instrument the code as follows x nondet assume x x when reasoning about the assume statement an abstract interpreter using the interval domain takes the meet of the intervals and which yields .
hence using trimmer without qe crab cannot prove that the subsequent code is unreachable.
summary.
table shows that trimming significantly improves the precision of an abstract interpreter with reasonable overhead.
our cheapest trimming configuration trim l b int proves more programs safe than the most expensive configuration of crab without trimming rtz inless than of the time .
.
impact of program trimming on klee in our second experiment we evaluate the impact of program trimming on klee a state of the art dynamic symbolic execution tool.
we use a subset5of the variants of trimmer see table and evaluate trimming on klee with three search strategies breadth first search bfs depth first search dfs and random search r .
5in particular since klee s analysis is already path sensitive we do not consider variants that instrument before conditionals here.table increased precision of an abstract interpreter due to trimming.
since crab treats integers as unbounded our instrumentation also makes this assumption.
configuration safe time s int trim l b int trim b int trim nd b int trim l int trim int trim nd int zones trim l b zones trim b zones trim nd b zones trim l zones trim zones trim nd zones rtz trim l b rtz trim b rtz trim nd b rtz trim l rtz trim rtz trim nd rtz since programs usually have infinitely many execution paths it is necessary to enforce some resource bounds when running klee .
in particular we run klee with a timeout of seconds and a limit of on the number of forks i.e.
symbolic branches .
the results of our evaluation are presented in table .
here the column labeled safe shows the number of programs for which klee explores all execution paths without reporting any errors or warnings.6hence these programs can be considered verified.
the second column labeled unsafe shows the number of programs reported as buggy by each variant of klee .
in this context a bug corresponds to an explicit assertion violation in the program.
next the third column labeled paths shows the number of program paths that klee explored for each variant.
note that fewer paths is better this means that klee needs to explore fewer executions before it finds the bug or proves the absence of an assertion violation.
the next two columns measure the number of programs for which each klee variant reaches a resource limit.
in particular the column labeled timeout shows the number of programs for which klee fails to terminate within the minute time limit.
similarly the column max forks indicates the number of programs for which each klee variant reaches the limit that we impose on the number of forks.
finally the last column labeled time shows the total running time of each klee variant on all benchmarks.
as shown in table program trimming increases the number of programs that can be proved safe by .
furthermore program trimming allows klee to find up to more bugs within the given resource limit.
in addition klee with program trimming needs to explore significantly fewer paths up to and reaches the resource bound on significantly fewer programs.
finally observe that the overall running time of klee decreases by up to .
6by warning we mean any internal klee warning that designates an incompleteness inklee s execution e.g.
solver timeouts and concretizing symbolic values .
181failure directed program trimming esec fse september paderborn germany table summary of comparison with klee.
since klee treats integers in a sound way we also use the variant of trimmer that reasons about integer over and under flows.
configuration safe unsafe paths timeout max forks time s klee bfs trim l b klee bfs trim l klee bfs klee dfs trim l b klee dfs trim l klee dfs klee r trim l b klee r trim l klee r figure compares the number of benchmarks solved by the original version of klee using bfs with its variants using program trimming.
specifically the x axis shows how many benchmarks were solved i.e.
identified as safe or unsafe by each variant sorted by running time and the y axis shows the corresponding running time per benchmark.
for instance we can see that trim l klee bfs solves benchmarks within less than one second each whereas the original version of klee only solves benchmarks.
summary.
overall the results shown in table and figure demonstrate that program trimming significantly improves the effectiveness and performance of a mature state of the art symbolic execution tool.
in particular program trimming allows klee to find more bugs and prove more programs correct within a given resource limit independently of its search strategy.
.
threats to validity we identified these threats to the validity of our experiments sample size we used programs most of which however are taken from the sv comp benchmarks a widely used and established set of verification tasks.
safety checkers we evaluate our technique using two safety checkers which however are mature and representative of two program analysis techniques.
trimming configurations we only presented experiments using a selection of the different configurations that trimmer provides see section .
however all of these configurations are orthogonal to each other and we evaluated a large variety of them to demonstrate the benefits of our technique.
.
.
of solved benchmarkstime s klee bfs trim l b klee bfs trim l klee bfs figure quantile plot of time and solved benchmarks for selected klee variants.
related work the ideas in this paper are related to a long line of previous work on program transformations and safety precondition inference.
program slicing.
one of the most well known program simplification techniques is program slicing which removes program statements that are not relevant to some criterion of interest e.g.
value of a variable at some program point .
a program slice can be computed either statically or dynamically and includes both forward and backward variants.
program trimming differs from traditional program slicing in two ways first trimming focuses on removing execution paths as opposed to statements second it is meant as a pre processing technique for safety checkers rather than a transformation to aid program understanding.
in particular a typical slicing tool may not produce compilable and runnable code that could be consumed by subsequent safety checkers.
more semantic variants of program slicing have also been considered in later work .
for instance jhala and majumdar propose path slicing to improve the scalability of software model checkers .
in particular path slicing eliminates all operations that are irrelevant toward the reachability of the target location in a given program path.
unlike program trimming path slicing is not used as a pre processing step and works on a single program path that corresponds to a counterexample trace.
prior work has also considered how to slice the program with respect to a predicate .
such techniques can be useful for program understanding for example when the user only wants to see statements that affect a given condition e.g.
the predicate of a conditional .
in contrast program trimming is not meant as a program understanding technique and removes program paths that are irrelevant for a given safety property.
furthermore the trimmed program is not meant for human consumption as it semantically prunes program paths through the insertion of assume statements.
slicing has been used before invoking a program analyzer .
a key difference with these approaches is that the result of trimming is valid code which compiles and runs instead of an abstract representation such as a control flow graph or model.
pre processing for program analyzers.
in the same spirit as this paper prior work has also used program transformations to improve the precision or scalability of program analyzers .
for instance a transformation for faster goal directed search moves all assertions to a single main procedure with the goal of speeding up analysis.
another program transformation 182esec fse september paderborn germany kostas ferles valentin w stholz maria christakis and isil dillig called loop splitting aims to improve the precision of program analyzers by turning multi phase loops into a sequence of single phase loops .
however neither of these techniques instrument the program with assumptions to guide safety checking tools.
recent techniques rely on the verification results of a full fledged analyzer such as an abstract interpreter or a model checker to guide automatic test case generation tools or other static analyzers some even using slicing as an intermediate step .
in contrast program trimming is more lightweight by not relying on previous analyzers and thus can be used as a preprocessing step for any safety checker.
precondition inference.
the use of precondition inference dates back to the dawn of program verification .
most verification techniques infer a sufficient condition for program safety and prove the correctness of the program by showing the validity of this condition .
in this work we do not aim to infer the weakest possible safety precondition instead we use lightweight modular static analysis to infer asufficient condition for safety.
furthermore we use safety conditions to prune program paths rather than to verify the program.
program trimming hinges on the observation that the negation of a sufficient condition for property pyields a necessary condition for the negation of p. prior program analysis techniques also exploit the same observation .
for instance this duality has been used to perform modular path sensitive analysis and strong updates on elements of unbounded data structures .
while most program analysis techniques focus on the inference of sufficient preconditions to guarantee safety some techniques also infer necessary preconditions .
for example verification modulo versions vmv infers both necessary and sufficient conditions and utilizes previous versions of the program to reduce the number of warnings reported by verifiers .
similarly necessary conditions are inferred to repair the program in such a way that the repair does not remove any good traces .
finally the techniques described by cousot et al.
infer necessary preconditions which are used to improve the effectiveness of the code contracts abstract interpreter .
abductive reasoning.
there has been significant work on program analysis using abductive reasoning which looks for a sufficient condition that implies a desired goal .
our analysis for computing safety conditions can be viewed as a form of abductive reasoning in that we generate sufficient conditions that are stronger than necessary for ensuring safety.
however we perform this kind of reasoning in a very lightweight way without calling an smt solver or invoking a logical decision procedure.
modular interprocedural analysis.
the safety condition inference we have proposed in this paper is modular in the sense that it analyzes each procedure independently of its callers.
there are many previous techniques for performing modular summary based analysis .
our technique differs from these approaches in several ways first our procedure summaries only contain safety preconditions but not post conditions as we handle procedure side effects in a very conservative way.
second we do not perform fixed point computations and achieve soundness by initializing summaries to false.
finally we use summary based analysis for program transformation rather than verification.property directed program analysis.
there is a significant body of work that aims to make program analyzers property directed.
many of these techniques such as blast slam and yogi rely on counterexample guided abstraction refinement cegar to iteratively refine an analysis based on counterexample traces.
another example of a property directed analysis is the ic3 pdr algorithm which iteratively performs forward and backward analysis for bounded program executions to decide reachability queries.
although abstract interpretation is traditionally not property directed there is recent work on adapting and rephrasing ic3 pdr in the framework of abstract interpretation.
in contrast we propose a general pre processing technique to make any eager program analysis property directed.
path exploration strategies.
most symbolic execution and testing techniques utilize different strategies to explore the possible execution paths of a program.
for example there are strategies that prioritize deeper paths in depth first search less traveled paths number of new instructions covered in breadth first search distance from a target line or paths specified by the programmer .
in the context of symbolic execution program trimming can be viewed as a search strategy that prunes safe paths and steers exploration toward paths that are more likely to contain bugs.
however as shown in our experiments our technique is beneficial independently of a particular search strategy.
conclusion in this paper we have proposed program trimming a program simplification technique that aims to reduce the number of execution paths while preserving safety.
program trimming can allow any safety checker to be goal directed by pruning execution paths that cannot possibly result in an assertion violation.
furthermore because our proposed trimming algorithm is very lightweight it can be used as an effective pre processing tool for many program analyzers.
as shown by our evaluation program trimming allows an abstract interpreter namely crab to verify more programs while cutting running time by .
trimming also allows klee a dynamic symbolic execution engine to find more bugs and verify more programs within a given resource limit.
in future work we plan to investigate the impact of program trimming on other kinds of program analyzers such as bounded model checkers.
we also plan to investigate alternative program trimming algorithms and strategies.