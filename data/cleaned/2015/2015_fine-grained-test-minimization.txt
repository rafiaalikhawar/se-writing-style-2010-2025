fine grained test minimization arash vahabzadeh university of british columbia vancouver bc canada arashvhb ece.ubc.caandrea stocco university of british columbia vancouver bc canada astocco ece.ubc.caali mesbah university of british columbia vancouver bc canada amesbah ece.ubc.ca abstract as asoftware systemevolves its testsuite canaccumulate redundancies over time.test minimization aimsat removing redundant test cases.
however current techniques remove whole test cases fromthetestsuiteusingtestadequacycriteria suchascodecoverage.
this has two limitations namely by removing a whole test case the corresponding test assertions are also lost which can inhibit test suite effectiveness the issue of partly redundant test cases i.e.
tests with redundant test statements is ignored.
we proposeanovelapproachforfine grainedtestcaseminimization.
our analysis is based on the inference of a test suite model that enables automated test reorganization within test cases.
it enables removingredundanciesattheteststatementlevel whilepreserving the coverage and test assertions of the test suite.
we evaluated our approach implementedinatoolcalledtestler onthetestsuitesof 15opensourceprojects.ouranalysisshowsthatover4 of the tests in these test suites are partly redundant with over redundantteststatementsintotal.ourresultsshowthattestler removes43 oftheredundantteststatements reducingthenumber ofpartlyredundanttestsby52 .asaresult testsuiteexecution timeis reducedby upto on average while maintaining theoriginalstatementcoverage branchcoverage testassertions and fault detection capability.
ccs concepts software and its engineering software testing and debugging keywords test minimization test reduction test redundancy test model acm reference format arashvahabzadeh andreastocco andalimesbah.
.fine grainedtest minimization.in proceedingsof40thinternationalconferenceonsoftware engineering icse .
acm new york ny usa pages.
.
.
introduction testinghasbecomeawidespreadpracticetoensurethequalityand correctnessofsoftwaresystems.astheproductioncodeevolves permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
a test suite can accumulate redundant test cases without benefiting the overall test suite coverage or effectiveness.
test suite minimization also known as reduction techniques aimateliminatingredundanttestcasesfromtestsuitestoreduce their maintenance and regression testing costs .
existing reductiontechniques however useadequacycriteria suchascode coverage as a guideline to remove wholetest cases with redundant coverage .
a potential drawback of such techniques is the deletion of a test case having similar code coverage as other test cases but different test statements and assertions.
this can severelymodifytheintendedtestsuitebehaviour becausehow aproductionmethodiscalledandassertedinfluencestheoverall test suite effectiveness and fault finding capability .
toovercomethisissue anapproachtargetingmorefine grained redundancies within test statements is needed.
however reorganizing or refactoring test casesisa challengingtask.developersusethe testsuite tocheck thatthe behaviour ofthe systemis preserved when production code is changed.
in contrast such a safety net does not exist when a test suite needs to go through internal changes.moreover itisnotstraightforwardtomanuallyre order complex test cases in a way that retains the semantics.
inthis paper we proposeanovel approachto fine grained test minimization whilepreservingtheoriginalbehaviourofthetest suite.ourapproachanalysestestcasesatthe statementlevel and infers a test model that captures the relationships between test statements and test states.
the test model allows fine grained test re organizationaltaskssuchasidentifyingandremovingredundant teststatements.asopposedtoexistingtestreductiontechniques our fine grained test minimization technique models the actualbehaviourofthetestsuitebycapturingtheproductionmethodcalls togetherwiththeirinputs insteadofsimplyrelyingoncodecoverage removes redundant test statements instead of removing whole test cases and preserves all test assertions in a test suite inadditiontomaintainingthecoverageandfaultfindingcapability.
our work makes the following main contributions a novel test minimization technique for eliminating finegrained redundancies in testcases that is safe and accurate.
a test model capturing test statements and test states along with their relationships.
an algorithm for identifying behaviour preserving refactorings in a test suite.
it uses the test model to reorganize tests in a way to minize redundant test statements.
animplementationofourapproachinatoolcalledtestler which supports java code and junit4 and is available .
anempiricalevaluationof testlerperformedontestsuites of open source projects.
our results show on average a decrease in the number of redundant statements a decreaseinthenumberofpartlyredundanttests and acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. vahabzadeh et al.
test public void testadd complex x new complex .
.
complex y new complex .
.
complex z x.add y assertequals .
z.getreal .0e test public void testsubtract complex x new complex .
.
complex y new complex .
.
complex z x.subtract y assertequals .
z.getreal .0e test public void testmultiply complex x new complex .
.
complex y new complex .
.
complex z x.multiply y assertequals .
z.getreal .0e test public void testdivide complex dividend new complex .
.
complex divisor new complex .
.
complex q dividend.divide divisor assertequals .
.
q.getreal .0e figure four tests from apache commons math.
finegrained redundancies are highlighted.
atestsuiteexecutiontimereductionbyupto37 on average .
a model for analyzing tests ourtest suite model that enables our fine grained test analysis is defined as follows.
definition test suite model .a test suite model is a directedgraphdenotedbyatriple angbracketleftr v e angbracketrightwherevisasetofvertices representingteststates eisasetofdirectededgesrepresentingtest statements and assertions and rdenotes the root of the graph which is the initial empty state.
to explain our model we use the complextest class from the apachecommonsmathproject oneoftheexperimentalsubjects used in our evaluation.
the test class shown in figure consistsoffourtestcaseswithredundantstatements i.e.
theinitializationoftheobjects xand yoftheclass complex atlines3 and24 .figure2showshowtheseredundantstatements are removed by our approach.
figure illustrates the test suite model obtained for the class complextest .
rectanglesdenote test states nodes whereas round boxes theannotatededges depictteststatements anddashedlinesrepresentthecompatibilitybetweenateststateandateststatement explained in section .
.
next we define the properties of our model the notions of test statement and test state as well as their relationships in the model.
.
model properties thereareanumberofpropertiesthatourmodelneedstoexhibit.
first the model should capture how the production code meth ods are called by the test suite.
this is important to preserve thebehaviour of the test suite after any refactoring activity.
second the model should capture dependencies at the test statement level1 test public void testadd subtract multiply divide complex x new complex .
.
complex y new complex .
.
complex z x.add y assertequals .
z.getreal .0e complex z subtract x.subtract y assertequals .
z subtract.getreal .0e complex z multiply x.multiply y assertequals .
z multiply.getreal .0e complex q x.divide y assertequals .
.
q.getreal .0e figure reorganized tests of figure .
the redundant teststatements are removed and four test cases are merged intoone.
tosupporttestreorganization.sinceateststatementmighthave dependencies on previous statements it is important to know how tosafelymoveteststatementswithinoramongtests.finally the model should facilitate the discovery and removal of redundancies in test cases.
.
test statements we use test statements as the smallest unit of computation for the test model.
using a more fine grained unit such as bytecode operation wouldincreasethemodelsizeandtheanalysiscomplexity.
on the other hand using a larger unit such as blocks of statements would invalidate our ability to detect and reorganize partly redundant testcases with common test statements.
therefore we considereachtestcaseasasequenceof teststatements hereafter referredtoas st .forexample eachlineofthetestcasesinfigure1 is ast.
assertions are also a particular type of st. a unittest casetypically creates aset ofvariables e.g.
objects and assigns values to their member variables then it calls the production method under test using those variables as inputs and finally it asserts the value returned by the method.
our test model needs to capture all these three entities namely variables and their values production method calls and test assertions.
definition variable value .the value of a variable x val x is defined as val x primitive value type x p xi val xi xi fields x type x nelementp type x denotesthetypeofthevariable x pisthesetofallprimitivetypes and fields x denotesthesetofallmembervariablesof theobject x.ifthevariable xisaprimitivetype val x istheprimitive value.
otherwise if the variable xis an object its value is a set of xi val xi pairswhere xiisthenameof ithmembervariablein x injavathisincludes private protected and publicmembervariables of the object.
for example in figure the value of the object xat line is val x complex .r .
complex .i .
given that the complexclass has two member variables of type double named rand i. in order to preserve the test suite semantics we analyze it to captureitsexternallyobservablebehaviour.werefertomethods in the production code that are under test as production methods.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fine grained test minimization icse may june gothenburg sweden complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
complex complex.r .
complex.i .
s0 s3s4s5st 3st 10st st 4st 11st 25st st st st 27st 12st 19st st 20st 13st 6s6s1 s2 figure3 extractedpartialmodelfortherunningexample.nodes rectangles representteststatesanddirectededgesaretest statements.
each edge is labelled with all the information about the test statement here we use line numbers to simplify the graph.
dashed lines represent state compatibility relations between test states and test statements.
the external behaviour of a test suite can be hence modelled by capturingalltheproductionmethodscalledalongwiththeirinputs.
definition production method calls pmc .the production method calls of a test statement st pmc st is a set of methodname i inputset i pairs in which methodname iisthe qualified name of the called production method and inputset iis the ordered setof type xj val xj pairsfor eachinput variable xjof themethodstartingwith thisobjectfornon staticmemberfunctions.
forexample infigure1 the pmcfortheteststatementatline5 is complex .add since as part of the test statement execution the method complex.add is called with the two inputs xand y. thepmcof a test statement that does not call any production methods is the empty set.
further our model needs to accommodate the ability of moving test statements from a source position in one test case to a destination position in another test case.
in order to preserve the test s behaviourandavoidundesirablesideeffects weneedtokeeptrack of the data and definition dependencies of the test statements .
indeed ifweknowwhichvariableshavebeenusedaspartofthe executionof atest statement we candetermine whetherit canbe safely moved to another destination position in the test suite.
concerning datadependency wesavethevariablesthatareused by the test statements and by the assertions defined as follows.
definition4 usedvariablesofteststatements uvs .
the used variables of a test statement stj uvs stj is a set of type xi val xi pairs where each variable xiis used in the execution ofstj.
for example the uvs of the statement at line of figure contains type x value x type y value y .
for assertions we also need to keep track of the method calls that create the value of the variables.
since assertions check theoutputofparticularproductionmethodcalls weneedtocapture thisinformationaspartofourtestmodel.forexample atline6 of figure the assertion checks the output of the method add with specific inputs.
it is possible to retrieve the whole chain of methodcallsthattheassertionevaluatesasfollowing theassertion checks the output of the addmethod which uses the output of two constructor calls of the complexclass.
definition5 usedvariablesofassertions uva .the usedvariables ofanassertion asrt uv a asrt isasetof type xi val xi meth xi tupleswhereaspartoftheassertionexecutionthe variablexiis used and meth xi is thepmcof the test statement that assigns the value of xi.
forexample infigure1 theuvaatline6is type z value z meth z wheremeth z complex .add type x val x type y val y sincevariable zisbeingusedaspartoftheexecutionoftheassertionanditsvalueiscreatedbythe addproduction method call pmcof the test statement at line .
in addition to data dependencies a test statement can have definition dependencies on previous test statements.
for example at line26offigure1 theteststatementdoesnotdependonthevalue of the variable q. thus given that the datadependency of the test statement is satisfied it is possible to replace the variable qwith any other variable of type complex.
in order to be executed the test statement needs three variables of the type complexdefined in thepreviousteststatements inadditiontoitsdatadependencies.
the defined variables dv set of a test statement captures this definition dependency.
definition defined variables dv .
the defined variables of a test statement st dv st is the set of the variable types thatarereferencedin st whichneedtobedefinedbeforetheexecution ofst.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. vahabzadeh et al.
note that for the defined variables we abstract away the actual values by focusing on the types.consider figure again.
thedv set at line is complex complex complex since the variables dividend divisorand qneedtobepreviouslydefinedtosatisfythe definition dependency of the statement.
.
test states toperform dataanddefinition dependency analysis wemaintain atest stateat each test statement.
definition teststate .a test state encompasses information pertaining to the defined variables their values and the pmc thatcreatedthemataspecificteststatementinthetestcase.formally the test state sj is a set of type xi val xi meth xi tuples for each variable xireferable from jth test statement in the test case.
in the java programming language and junit testing framework the test state includes information about local variables static field of loaded classes and member variables of the test class.
for example in figure the test state before the executionofline5is type x value x meth x type y value y meth y sincethetwovariables xandyarereferableatline5.followingourmodel meth x complex double .
double .
since xis created by the pmc complex i.e.
the constructor with two input values .
and .
of type double.
.
test state compatibility it is possible to move a test statement stto a destination position d only if the test state at discompatible withst.
definition compatible state .a test state is compatible with a test statement if it satisfies the test statement data anddefinition dependencies.
in this case the test statement can be executed on the test state while preserving its behaviour.
formally a test state si iscompatiblewithateststatement stj iffitsusedvariables uvs stj anddefinedvariables dv stj aresubsetsoftheteststate uvs stj si dv stj def si .def si denotesthesetof defined variables in the test state si.
the compatibility relation for assertions is defined similarly.
in figure dashed lines represent state compatibility relations betweenteststatesandteststatements.forexample thestatement of line st12 is compatible with the states s2 s3 s4 s5 ands6 sincethe readvariable setat line12 complex complex .r .
complex .i .
complex complex .r .
complex .i .
is a subset of these test states.
note that we have illustrated only a subset of all compatibility relations to avoid a tangled graph.
with the notion of compatible states we can determine possible valid reorganizations of test statements in test cases.
for example wecanrelocatetheteststatementofline12 st12 infigure3to any location after the states s3 s4 s5 o rs6.
.
equivalent and redundant test statements to detect redundancies in the test suite we look at the external behaviourofeachteststatementtoidentifythosethathaveidentical behaviour.these equivalentteststatements areidenticalasfaras testing the production code is concerned.test code production code run instrumented test casesproduction method calls test statesidentify defined used variables defined used variablesidentify compatible statescompatible statesidentify equivalent test statements equivalent test statements create test suite model test suite model reorganize test casesreorganized test pathscompose minimized test caseminimized test suitecode instrumentation test suite minimizationinstrumentmodel generation traces test code production code identif y defined used variables defined used variablescode instrumentatio n instrumentrun instrumented test casesproduction method calls test statesidentify compatible statescompatible statesidentify equivalent test statement s equivalent test statement s create test suite model test suite modelmodel generatio n tracest figure overview of our approach.
definition9 eqivalent test statements .equivalent test statements are the sets of test statements that have the same set of production method calls pmc .
to preserve the coverage of the production code we need to execute atleast oneoftheteststatementsineachsetofequivalentteststatements.allremainingequivalentteststatementsare redundant test statements and hence can be removed.
forexample concerningfigure1 thesetofequivalentteststatementsis st3 st10 st17 st24 st4 st11 st18 st25 st5 st6 st12 st13 st19 st20 st26 st27 .
in this case in order to maintain the coverage of the test we only need to execute one of the teststatementsfromtheset st3 st10 st17 st24 onefromtheset st4 st11 st18 st25 as well as the sets with only one member.
definition10 partly redundant tests .testcasesthat haveoneormoreredundantteststatementsarecalledpartlyredundant tests.
approach wenowdescribeourapproachforcreatingthemodelofatestsuite andreducingtheredundanciesgiventhemodel.figure4depicts our overall approach.
.
code instrumentation tocapturetheteststateateachteststatementlevel westorethe type and value of all referable variables through code instrumentation.weprobelocalvariables membervariablesofthetestclass andstaticfieldsofloadedclasses.tocaptureproductionmethod calls pmcs weinstrumenttheproductioncodetologtheentry point inputvalues includingthe thisobjectfornon staticmethods andexitpointsofeachmethod.tokeeptrackofproduction methods that are called by each test statement we produce a separate call stack log for each test statement of every test case.
these call stacks allow us to obtain the pmc sets directly called from test statements.
used and defined variables.
for each method invocation we assume that all the input variables and all of their properties are usedas partof thetest statementexecution.
thisalso includes all referablevariables suchasstaticvariablesandmembervariables authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fine grained test minimization icse may june gothenburg sweden of an object that are part of a method invocation on the object.
for example at line of figure we assume that all of the properties of the variable z i.e.
z.rand z.i will be used as part of the test statement execution even if z.iis not actually used .
this is a conservative assumption that prioritizes the precision of detecting compatible states for test statements.
in this case our recall might be adversely influenced since we might miss some compatibility relations but the precision is enforced because the relations we detect are correct.
to compute the definedvariables set see definition6 wecheckforthetypeofthevariablesthatarereferenced in the test statement.
.
model generation equivalent test statements.
after the instrumentation phase weexecutetheinstrumentedtestcasesagainsttheinstrumented productioncode andusethetracestocomputesetsofequivalent test statements i.e.
having the same pmc .
compatible states.
to compute compatible states for a test statements wecheckthestatesinwhichthevariablesusedin shave thesamevalues.we also makesurethattheteststatessatisfythe definitiondependency seesection2.
.forassertions additionally we look for the pmcthat defined the most recent value for the used variables.
we require that the direct method calls and theirinputs that an assertion checks remain the same to preserve test assertion coverage .
with the information about equivalent test statements and compatiblestates wecreatea graphrepresentingour testsuitemodel.
.
test suite minimization weusetheinferredmodeltoidentifyandremoveredundanttest statements.
for example by reorganizing the four test cases offigure we create the minimized test case shown in figure which has the same coverage and assertions but with six less statements.
to maintain the test suite coverage we basically need to call each production method once.
each test case in our test modelis a path starting from the initial state.
for example in figure the test testaddis the path angbracketleftst3 st4 st5 st6 angbracketrightin which stiisith test statement i.e.
edge .
thus to maintain the test suite coverage we need to find a set of paths starting from the initial state that visits at least one test statement from each set of equivalent test statements.
to find such paths we propose a greedy algorithm.
test reorganization algorithm.
algorithm shows our test reorganization algorithm.
the intuition is to extend a path among thecompatiblestatesofateststatementtocoverasmanyunique teststatementsandassertionsaspossible.todoso wemaintain asetofequivalentteststatementsandassertionsthatweneedto cover uncoveredeqstmts .
starting from the initial state we find the shortest path to the nearest test statement that is still uncovered line .
we repeat thisprocedurefromthatnodeuntilpathextensioncoveringnew equivalentteststatementsorassertionsisnolongerpossible inner looplines12 .thiseventoccurswhenalltheequivalenttest statementsandalltheassertionsinthemodelhavebeencovered.
otherwise if there exist equivalent test statements or assertions which are still uncovered we start from the initial state and repeatalgorithm test suite reorganization input uncoveredeqstmts set of uncovered equivalent test statements input g the test suite model output paths set of paths that visits at least one test statement in each set of equivalentteststatements andallassertionswhileminimizingnumberoftest statements visited 1reorganize uncoveredeqstmts g begin 3paths 4d o first g.get init runningstate first path pathtonearestuncovered g first uncoveredeqstmts runningstate foreach sti pathdo runningstate apply sti runningstate end frontier first whilefrontier nequalnulldo frontier newpath pathtonearestuncovered g frontier uncoveredeqstmts runningstate foreach sti newpathdo runningstate apply sti runningstate end updategraph g frontier runningstate markascovered frontier uncoveredeqstmts path.add newpath end paths.add path while first nequalnull end the procedure again outer loop lines .
to find the shortest path we use a variant of the best fit search algorithm that alsomaintains the running state .
we track the test state at each pointinthegraphbymaintainingarunningstate runningstate .
thisisessentiallytheteststatethatiscomputeddynamicallyateach pointinthegraph.weupdatetherunningstateateachiteration of the algorithm line and line .
eachteststatementoperatesonacompatibleteststateandtransformstherunningstatetoanotherteststate.let siandsi 1bethe teststatesbeforeandaftertheexecutionoftheteststatement sti.
the function apply sti si si 1applies the effect of executing the test statement stion the test state siand gives us the changed test state si .
thus we know the test state beforeandafterthe executionofeachteststatementintheoriginaltestexecution.this enables us to compute the effects of running the test statement on eachofitscompatiblestates.basically weneedtoupdatethevalue of the used variables of the compatible test state to the values of variablesin si .ifthestate sjiscompatiblewiththeteststatement sti thenapply sti sj updatevalues usv sti si sj .w ea s sume that the test statement could potentially change all of itsusedvariables.weupdatethegraph toincludeanynewcompat ibility edge based on the computed running state line .
to this aim we compare the uvsanddvof test statements with the computed running state to identify the compatible test statements.
the algorithm returns a set of paths each corresponding to a reorganized mergedtestcase thatcovereachsetofequivalenttest statements and all the assertions.
for example for the test suite modeloffigure3 ouralgorithmreturnsthepath angbracketleftst3 st4 st5 st6 st12 st13 st19 st20 st26 st27 angbracketright whichcorrespondstothemergedtest case of figure .
composingminimizedtestcases.
algorithm1givesusasetof pathsthatminimizesthenumberofteststatementsexecuted while authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. vahabzadeh et al.
algorithm test case composition input statementspath ordered list of statements in the composed test case output statementspath renamed list of statements in the composed test case 1renamestatements statementspath begin 3statebimap angbracketleftvalue set angbracketleftname type angbracketright angbracketright foreach stmt statementspath do mappreq angbracketleftname value angbracketright getnamevaluepreqvarsinstatement stmt renamemap angbracketleftoldname newname angbracketright castmap angbracketleftvarname oldtype newtype angbracketright foreach varname varvalue mappreq do varnamesinstate statebimap ifvarname nequalvarnamesinstate then renamemap generatename varnamesinstate end castmap checkfortypes statebimap stmt end lefthandsidevars angbracketleftname angbracketright getvarsinlefthandside stmt foreachvarname mappreq do varnameinstate statebimap ifvarnameinstate nequalnullthen renamemap generatename varname end end stmt renamestatement stmt renamemap castmap updatestatemap statebimap stmt end end preservingthetest suitecoverage.despitethestate compatibility however problemsmayarisewhenmovingteststatements because ofvariablenamingandcastissues.forexample in testdivide of figure variables xand yhave names dividend and divisor r e spectively.
therefore to generate a compilable reorganized test case weneedtorenamethesevariables.teststatementscanalso definevariablesthathavepreviouslybeendefinedwiththesame name.
for example in the reorganized test case the variable zwas already defined in three out of four test cases.
thus we need to rename such variable definitions to avoid name clashes.
further teststatementscanusemembervariablesandmemberfunctionsof thesourcetestclass thuswealsoneedtoincludethoseinthedestination test class note that this is not needed when test statements relocate within a test class .
at last due to the polymorphism in object oriented programs we might need to cast a variable to itssub or super class if the static type of two variables having the same value differ in the source and the destination state.
algorithm shows the pseudocode of the algorithm for composing reorganized test paths.
to maintain the state we use a bidirectional map from variable values to variable names and their types.
as we go through the test statements in the reorganized test casepath wecheck foreachteststatement ifwehavethevalue for each variable in the test statement.
if such a value exists buthas a different name in the state we rename the variable in the test statement to the name of the variable in the state lines .
if the type of the variable is different we cast the variable to thedestination type.
if there are name duplicates we rename them lines16 .finally weupdatethebidirectionalstatemapwith the changed values from test statement execution line .
.
preserving test suite behaviour assumethatwereorganizeasetoftestcases xintothereorganized set of test cases y we show that ypreserves the fault revealing behaviourof x.pmc x denotesthesetofproductionmethodcallsthatthesetoftestcases xcallwiththeirinputs.since pmc x pmc y each production method mithat is called as part of the executionof x willbecalledwiththesameinputsin y.hence both the coverage and the implicitoracles ofxare preserved.
we also retainthe explicitoracles ofx becauseourapproachkeepsallthe correspondingtestassertionsinthereorganizedtestcases.assume that inx assertion asichecks the return value of the production methodmiwith the input ini.
letasjbe the same assertion asi thatisincludedin y.sinceuva asi uva asj assertion asjwill checkthereturnvalueof miwiththesameinput ini.ifafault fin miaffects the return value of mi ini and is detectable by asi i ti s also detectable by asj.
square .
implementation we implemented our approach in a tool called testler which is publicly available .
the tool is written in java.
it supports analyzing java programs with junit4 tests.
however our overall approachisgeneralandapplicabletootherprogramminglanguages and testing frameworks.
testler takes as input the path to a java project.itinstrumentsthetestandproductioncode andrunsthe instrumentedtestcodeagainsttheinstrumentedproductioncodeto obtain traces.
then testler uses the traces to create a test model detects and reorganizes partly redundant test cases and generates a new minimized test suite.
evaluation toassessthereal worldrelevanceandefficacyofourapproach we address the following research questions rq1 prevalence how prevalent are partly redundant tests in practice?
rq2 reduction what is the redundancy reduction in terms of tests and test statements achievable with testler?
rq3 execution time what is the reduction in the execution time of the test suites reorganized by testler?
rq4 code coverage and fault detection doestestlerpreserve the code coverage and fault detection of the test suite?
rq5 performance what is the runtime of testler?
.
subject systems weinclude15subjectsystemsinourstudy.ourselectioncriteria forthesubjectsystemswasthattheyshouldusethemavenbuild system and to have executable junit4 test cases as required by our tool s implementation to be of various sizes in terms of lines of code andtospandifferentdomains.werantestlertoinferthe testmodelsonthetestsuitesofthesubjectsystems.forprojects thatcomewithdifferentmodules werepeatedtheanalysisonapermodulebasis.table1providescharacteristicsofthesubjectsystems including their names lines of java production code counted using cloc linesoftestcode numberoftestcases aswellasnumber and percentage of partly redundant tests.
.
procedure and results prevalence rq .toassesstheprevalenceoffine grainedredundancies wemeasuredthenumberoftestcasesthathaveatleastonecommonequivalentteststatementwithanothertestcase whichwe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fine grained test minimization icse may june gothenburg sweden table subject systems and their characteristics lines of code k test cases prod.
test par.
redundant collections .
.
math .
.
lang .
.
email .
.
assertj .
.
checkstyle .
.
pmd .
.
lambdaj .
.
java library .
.
jfreechart .
.
accumulo .
.
xmlsecurity .
.
crunch .
.
tika .
.
log4j .
.
total average .
.
callpartlyredundanttests .todoso weinferredthetestmodels byrunningtestleronthetestsuitesofthesubjectsystems.for each subject we analyzed the inferred test suite model to identify classes of equivalent test statements see section .
.
the fifth and sixth columns of table show the number and percentage of partly redundant tests in the subject systems.
our results show that out of the total number of test cases in the test suites of our subject systems are partly redundant.redundanciesonindividualsubjectsystemsrangefrom9 checkstyle to jfreechart .
figure5showsboxplotsaboutthedistributionofredundanttest statementsineachsubjectsystem.weobservethatmostofthetests of the studied subjects share between common test statements.
this empirical data motivates further the need for an approach capable of detecting fine grained redundancies in tests.
reduction rq .to assess the efficacy of our approach in reducing test statement redundancies we ran testler on the subject systems.testlerreorganizesredundanttestcasestoavoidrepeated productionmethodcalls thusreducingthenumberofredundant teststatements.thefirstmacro columnoftable2 redundancy presentsthenumberofpartlyredundant testcases beforerunning testler the subset reducedby testler and the reduction percentage.further thetableshowsthenumberofpartlyredundant test statements beforerunning testler the subset reducedby testler and the achieved reduction percentage.
onaverage testlerwasabletoremove43 oftheredundant test statements which also resulted in a reduction of in the number of test cases.
across all test suites partly redundant testcaseswerereorganizedinto2 tests performed byremoving5 041redundantteststatements.xmlsecurityisour best case with test reduction obtained by discarding redundant test statements.
the lowest reduction was obtained for assertj by removing redundant test statements.
all test cases that werereorganized passed successfully withno errors or failures.
our results confirm the design choice of our algorithm collections math lang email assertj checkstyle pmd lambdaj javalibrary jfreechart accumulo xmlsec crunch tika log4j2468101214 figure distribution of redundant test statements per test case in each subject system.
see section .
which prioritizes the precision of redundancy detectionoverthedetrimentoftherecall.wediscusswhytestler cannot eliminate all the partial redundancies in section .
execution time rq .to assess the effects of reducing redundancy on test suite execution time we measure the execution time of the test suites beforeandafterthe reorganization by testler.
to mitigate the variability effect of non deterministic tests we performed the measurements times and we report the averages.
thesecondmacro columnoftable2 executiontime showsthe executiontimeof theoriginaltestsuite theexecutiontimeofthe reorganizedtestsuite andthepercentageofreduction.percentagewise testler was able to reduce test execution time across all test suites by about with the lowest being collections and pmd andthehighestlambdaj .forninesubjects collections lang email assertj checkstyle pmd lambdaj java library jfreechart thetestsuitesraninlessthanoneminute.theabsolute executiontimereductionsforthose fast testsuitesrangebetween .211sofjfreechart and5.326sofcheckstyle .the other six test suites math accumulo xmlsecurity crunch tika log4j haveexecutionsthatrangebetween1.4and4.4minutes.for those slower testsuites theabsoluteexecutiontimereductions range between .
s of math and .
s of log4j .
code coverage and fault detection rq .we measured the statement and branch coverage for each test suite before and after reorganization using eclemma .
the third macro column of table code coverage shows these coverage numbers.
tomeasurefaultdetectionrate wemutatedeachsubjectsystem using pit againstthetestsuitebeforeandafterourrefactoring.
thefourthmacro columnoftable2 faultdetection showsthe mutation scores obtained.
we also counted the number of testassertions in the original and the reorganized test suites which remained the same in all subject systems.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. vahabzadeh et al.
table results redundancy execution time code coverage fault detection analysis time par.
red.
tests red.
test stmts seconds stmt branch mut.
score ci mg tr tot before reduced reduction before reduced reduction original reorganized reduction before reduced before reduced before reduced time seconds collections .
.
.
.
.
.
.
.
math .
.
.
.
.
.
.
.
lang .
.
.
.
.
.
.
.
email .
.
.
.
.
.
.
.
assertj .
.
.
.
.
.
.
.
checkstyle .
.
.
.
.
.
.
.
pmd .
.
.
.
.
.
.
.
lambdaj .
.
.
.
.
.
.
.
java library .
.
.
.
.
.
.
.
jfreechart .
.
.
.
.
.
.
.
accumulo .
.
.
.
.
.
.
.
xmlsecurity .
.
.
.
.
.
.
.
crunch .
.
.
.
.
.
.
.
tika .
.
.
.
.
.
.
.
log4j .
.
.
.
.
.
.
.
total average4 .
.
.
.
.
.
.
.
overall ourresultsshowthat testassertionsremainintact the statement and branch coverage are preserved and the fault detection rate is unchanged for all the subject systems.
performance rq .toassesstheperformanceofrunningtestler we measured the execution time on a macos machine equipped witha .3ghz intelcore i7and 16gb ofmemory.
table analysis time shows the execution time in seconds pertaining to the three phases of our algorithm code instrumentation ci model generation mg andthetestsuitereorganization tr andtotal tot .
in total testler took seconds .
hours to analyze all the subjects test suites seconds .
minutes on average.
email and math were the extreme cases with and seconds respectively.
this is not surprising as testler found the least and the most number of redundant test cases in email and math respectively.
on average code instrumentation ci required approximately1.5minutes themodelgeneration mg .6minutes and the reorganization tr .
minutes.
considering the analy sis time in relation with the size of the test suites testler was fastestonlambdaj .12s testcase andslowestontika .94s test case .onaverage acrossallsystems theruntimeis0.42seconds for each test case to be analyzed reorganized and recomposed.
discussion in this section we discuss some of our evaluation findings tooldesign decisions and limitations as well as threats to validity of our study.automation.
ourresultsconfirmthatovertime testsuitestend toaccumulateaconsiderablenumberofpartlyredundanttests and fine grainedredundanciesmaypertaintoteststatementsintests acrossthewholetestsuite and ourtechniquecansafelyremove nearlyhalfofthese redundanciesautomatically.manuallyfinding and reorganizing redundant tests to create a reduced test suite that still preserves the coverage could be in fact quite challenging.
our ownexperienceinreorganizingtests whichwewererequiredto dowhiledevisingtestler corroboratesthedifficultyofthetask.
forexample forthe complextest classofmath whichiscomposed of tests the authors spent approximately one hour to manuallydetecttheredundantstatementswithinthat singleclass and reorganize the tests in a way to retain the coverage analyzing and reorganizing the remaining test classes would be practically infeasible to perform manually.
test suite evolution.
as long as the sut stays deterministic testler preserves all the test states and assertions also during softwareevolution becausethemodeliscreatedandupdatedbased ontheactualbehaviourofthetestsuite.animportantfeatureof testleristhatthereducedtestsuitedoesnotneedtobeupdatedif therearenochangesmadetothetests aspartofacommit.testler savestheinferredtestmodelsothatthewholeanalysisdoesnot needtoberepeatedeverytimeanewtestisaddedoranexistingoneischanged.thismeansthatthetestmodelisonlypartiallyupdated when the software evolves.
asdiscussed in our evaluations rq thetestanalysisprocesstooklessthanhalfasecondtocomplete for each test case.
readability.
weareawarethatmergingtestsmightaffecttheoverall readability of the test suite.
in our experiments rq testler authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fine grained test minimization icse may june gothenburg sweden mergedtestcaseshavingatleastonecommonequivalentteststatementwithanothertestcase becausewewereinterestedinassessing the maximal capability of our technique at finding and eliminating fine grained redundancies at the cost of producing larger merged testclasses .asfarasreadabilityisconcerned inpracticethetester cancustomizethegranularityoftheanalysistooptimizethebalance between readability and redundancy reduction.
that said the purposeofourworkisnottoreplacetheexistingtestsuite.testler keeps both the original and minimized versions of the test suite andmaintainslinksbetweenthem.thisenablestheusertotrace back anyminimized testcase or itsfailure tothe test casein the original test suite for better comprehension.
testexecutionreductionandoverhead.
industrialprojectsoftengothroughnumerouschangesdaily andthewholetestsuite is executed after each change.
for instance at google on a typical workday around 000changesarecommitted .ourresults showthatbyremovingfine grainedredundancies thetestexecutiontimecanbeminimizedby20 onaverage whichwasachieved by removing around of the initial test cases in our evaluation.a20 reductionintestexecutiontimewouldadduptoa substantialtestruntimereductionquickly.inourevaluation the20 reduction corresponds to about seconds.
hypothetically speaking ifaminimizedtestsuiteisexecuted40 000timesaday this would save hours per day.
thus we believe the startupoverhead associated with our analysis can be amortized quickly when considering high commit rates in practice.
accuracyandefficacy.
ourevaluationresultsshowthattestler removed around half of redundant test statements automatically and safely.
all the test suites that were reorganized passed successfullyandthecoverageandfaultdetectionratesweremaintained.
therefore we believe testler is accurate in its minimization task.
regardingtheefficacyof testler weinvestigatedwhy allredundant test statements were not reduced.
we enumerate some of themainreasonsnext whichpertaintoboththeinherentnatureof junittestsandsomeofourdesigndecisionsindevelopingtestler.
our analysis does not have a fully sound handling of the following features.
first testlercannotreorganizetestcasesthatterminateabruptly as forinstance thosethat checkthatanexceptionisthrown e.g.
usingthejunitannotation test expected someexception.class .
in our experiments a similar behaviour was also simulated by meansofthe returnand failstatements.second althoughtheuse ofinheritanceintestcodeisdebatable mostofoursubjectsystems use inheritance in their test code.
we chose not to reorganize testcasesintestclassesthataresubclassedbyanothertestclass sinceinthiscasethesubclassmightoverridesomeofthetestcases and render the reorganized test cases useless.
third testler does not reorganize parameterized test cases since in this case the test case will be run with different inputs and can only be merged with another test case that has exactly the same inputs.
fourth some testsusecustomtestrunnerstoruntheirtestcases.forexample inonecase testcaseswouldberetriedseveraltimeswithacustom runner until they would pass.
in this scenario we can only reorganize test classes that have the same custom runner.
fifth we chose not to reorganize test statements inside conditionals such as ifs for loops and try catch s. sixth since we do not store the variableidentityaspartofourteststate definition7 wedonotsupport reorganizingtestcaseswith assertsame assertions.finally wedo not reorganize flaky non deterministic tests multithreaded tests orteststhathaveread writedependenciesonexternalresources such as files or databases.
sideeffectsortestdependencies.
inourevaluation wedidnot witness any issues with side effects of running tests or test dependencies.
by creating our test model from the dynamic execution ofthetestcases weconsiderpotentialsideeffectsanddependencies of test statements and test states using the state compatibility notion when reorganizing tests.
applications.
testlercanbeusedbydeveloperstofindandminimize redundant test statements.
our test suite model can also be utilized for other test analysis activities for instance for testbug or test smell detection.
one of the tasks performed duringtestrefactoringistoreorganizetestcasestoremoveeager and lazy test smells in this case our model can help with the refactoring task since it is not straightforward to manually reorganizetestcasesinawaythatpreservesthebehaviourofthe testsuite.forinstance ourtestmodelcanbeusedtoidentifysmall test cases that have common test statements and merge them toremove lazy test smells.
our test model also facilitates going theother direction it can be used to reorganize large test cases intosmaller ones to remove the eager test smell while keeping the incurred redundancy at a minimum.
although we evaluated testler on desktop unit tests we believe our technique can be even more effective in other domainsof testing such as ui mobile or web where the test execution timemaybelonger.forexample testsdevelopedforthewebdomainusingframeworkssuchasseleniumhavegenerallyamuch higherrunningcostthanunitteststhattestlow leveljavamethods.
this is due to the overhead imposed by the interaction with the gui thebrowserandthenetworklatency.inthiscontext weexpect testler to be especially beneficial because a minimized test suitewouldcontainlesscallstothebrowser sapisandserver side requests resulting in a substantial decrease in test execution time.
relation to test reduction techniques.
traditional test suite minimization seeks to eliminate redundant test cases in order toreduce the number of tests to run .
our technique seeks to eliminate redundant statements in the whole test suite in order toreducethenumberofteststatementstoexecute asourresults show thisalsoresultsinareductionofthenumberoftestcases .
more importantly a distinguishing characteristic of our work is that we retain all the test assertions which are known to be highly correlated with test suite effectiveness .
relationtotestprioritization selectiontechniques.
testprioritizationseekstoordertestcasesinsuchawaythatearlyfault detection is maximized whereas test selection seeks to identify the test cases that are relevant to the most recent changes .
our approachisorthogonaltothosetechniques andcanbecombined withthem.minimizedtestcasescanstillbeprioritized.ontheother hand test selection is change driven.
although we do not target software evolution in this paper our technique can also be used to applychange relatedfine grainedminimization.also asthetest cases that we merge together have common test statements it is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. vahabzadeh et al.
likelythat theytestthe samecomponent andthuscan beselected together as part of a selection strategy.
parallel virtualized test execution.
a number of techniques address the problem of long running test suites by running tests in virtualized or cloud based parallel environments.
any of these techniques require complete test independency a requirement hard to meet in many real world test suites including those of our subject systems which we ran sequentially.
however such techniques can still be applied to test suites that testler minimizes.
threatstovalidity.
usingalimitednumberofsubjectsystemsin our evaluation poses an external validity in terms of generalizability of our results.
we tried to mitigate this threat by choosing 15subject systems with various sizes domains and tests although weneedmoresubjectsystemstofullyaddressthegeneralization threat.
as reported in a recent empirical study of large java systems it isoftennotnecessary toresettheapplication prior to test execution.
our results confirm this finding as we did not witnessedanysideeffects.however insometypesofapplicationsit mightbenecessarytoresettheapplicationaftereachtestexecution session.withrespecttoreproducibilityofourresults thesource codeof testlerandallsubjectsystemsareavailableonline making the evaluation repeatable and our results reproducible.
related work thereisalargebodyofworkontestsuitereduction minimization andtestselectiontechniques which have been proposed for removing redundant test cases.
these techniques use different coverage criteria such as statement or branch coverage to detect redundancies at the whole testcaselevel.althoughitispossibletousecoveragecriteriainour approach we chose to preserve the test suite behaviour and find redundantpartsoftestcasesthatcallthesameproductionmethods withexactlythesameinput.asopposedtothesetechniquesthat remove whole test cases in this paper we tackle the problem of partlyredundanttests andwereorganizetestcasesbyremoving only redundant test statements.
this allows us to preserve the original test suite s coverage and retain all test assertions without affecting the fault finding capability.
many techniques are proposed for regression test selection and use different levels of granularity for tracking dependencies suchasfiledependency andclassdependency todetect affected test cases as part of a change to production code.
more recently techniqueshavebeenproposedthatcombinetestreduction test selection and test prioritization techniques .
however none operates at the fine grained test statement level.
ourteststaterepresentationiscloselyrelatedtotheheaprepresentation used by gyori et al.
.
they store the portions of the concrete heap accessible from static fields of test classes.
onthe other hand in order to support test reorganization we need toincludelocalvariablesaswellasmembervariablesusedinthe testclass.ourstatealsoincludesinformationabouttheproduction method calls that were responsible for the creation of a specific value in the test state.
some approaches entirely focus on reducing the test suite execution time .
for instance a recent work by bell andkaiser usesunit testvirtualization toreduce the timerequired for the execution of a test suite while leaving all the redundant statements.
our work on the contrary focuses on identifying and removing redundant test statements which also results in test execution time reduction of the merged test suites.
moreover in most of our subjects there are test dependencies and it is not always possible to reset the system state prior to execution of tests.
alipouretal.
presentanapproachthatreducesatestsuiteby compromising a certain amount of coverage while preserving the overallfault findingability.ourtechniquereducesthetestsuiteby eliminatingredundantteststatementswhilepreservingboththe original coverage and fault finding ability.
fangetal.
useassertionfingerprintstodetectsimilartest casesthatcanberefactoredintoonesingletestcase.theyperform staticanalysisontestcodeand byanalyzingthecontrolflowgraph theycomputebranchcount mergecount andexceptionalsuccessor count for each assertion.
based on these attributes they detect refactoringcandidates.
ourapproach findsrefactoringcandidates based on common redundant statements in test cases.
guerraetal.
visuallyrepresenttestcaseswithagraphical notationtohelpdeveloperswiththerefactoringactivity.ourapproach makes sure that reorganizing test statements in the test suite preserves its behaviour by closely examining the production methods called from test cases.
xuanetal.
splittestcasesintosmallerfragmentstoenhance dynamic analysis while xuan and monperrus perform test purification to improve fault localization.
in these papers the goal istoimprovedynamicanalysisbysplittingtestcasesintosmaller units whereas we aim at reducing redundancies in the test code through test case reorganization.
fraserandwotawa mergetestcasesgeneratedbyamodel checkerbycomparingthestateoftheapplicationfordifferenttests and merging only those for which a common prefix exists.
devaki et al.
merge web applications gui test cases to reduce test execution time.
they define the state of the program as a combination ofbrowser sdomanddatabasestate.theseapproachescanonly interleavechunksofteststepsthatresultinthesamestate whereas ourapproachiscapableofreorganizingandinterleavingallvalid refactorings among and across unit test cases.
conclusions in this paper we proposed a test suite model that facilitates testcode analysis at the test statement level.
we used the proposed model to present an automated technique and tool called testler forminimizingfine grainedstatement redundanciesintestcases while preserving the behaviour coverage test assertions and fault detection of the test suite.
we empirically evaluated our technique on subject systems and overall testler was able to reduce the numberofpartlyredundanttestcasesupto52 andtestexecutiontimebyupto37 whilepreservingtheoriginaltestsuitecoverage and production method call behaviour.
forfuturework weplantoinvestigatetheapplicationoffinegrainedtestanalysisontestselectiontechniques.wealsointend to run testler on more subject systems and extend the tool to support web and mobile test suites.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fine grained test minimization icse may june gothenburg sweden