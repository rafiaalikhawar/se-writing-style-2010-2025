extracting instruction semantics via symbolic execution of code generators niranjan hasabnis intel ca usa niranjan.hasabnis intel.comr.
sekar stony brook university ny usa sekar cs.stonybrook.edu abstract binary analysis and instrumentation form the basis of many tools and frameworks for software debugging security hardening and monitoring.
accurate modeling of instruction semantics is paramount in this regard as errors can lead to program crashes or worse bypassing of security checks.
semantic modeling is a daunting task for modern processors such as x86 and arm that support over a thousand instructions many of them with complex semantics.
this paper describes a new approach to automate this semantic modeling task.
our approach leverages instruction semantics knowledge that is already encoded into today s production compilers such as gcc and llvm.
such an approach can greatly reduce manual effort and more importantly avoid errors introduced by manual modeling.
furthermore it is applicable to any of the numerous architectures already supported by the compiler.
in this paper we develop a new symbolic execution technique to extract instruction semanti cs from a compiler s source code.
unlike previous applications of symbolic execution that were focused on identifying a single program path that violates a property our approach addresses the all paths problem extracting the entire input output behavior of the code generator.
we have applied it successfully to the 120k lines of c code used in gcc s code generator to extract x86 instruction semantics.
to demonstrate architecture neutrality we have also applied it to avr a processor used in the popular arduino platform.
ccs concepts theory of computation program analysis preand post conditions abstraction software and its engineering source code generation automatic programming retargetable compilers software reverse engineering this work was supported in part by grants from nsf cns1319137 and onr n00014 .
this work was completed while the first author was a phd studen t at stony brook university.keywords instruction set semantics extraction code generators symbolic execution .
introduction binary analysis and instrumentation play a central role in software monitoring and debugging as well as hardening of commercial off the shelf cots software.
many popular tools and techniques including those for software emulation andvirtualization e.g.
qemu valgrind dynamorio and pin malware analysis exploit de fense e.g.
taint tracking control flow integrit y and sandboxing rely on these techniques .
one of the major challenges in binary instrumentation is the complexity of modern instruction sets.
the intel manual describing the x86 instruction set runs to over pages describing over instructions.
modern arm instruction sets are even larger.
moreover this semantic modeling task is not a one time effort since there are many processors to be considered e.g.
processors used in embedded systems.
even for mature processors the instruction sets are frequently expanded.
as a result even mature platforms such as valgrind support only a small number of processors and omit subsets of instructions such as avx fma4 and sse4.
on x86.
binaryanalysisandinstrumentationpresentanunforgiving environment for modeling errors not only are such errors hard to debug they also cause the instrumented application to fail or worse they allow security checks to be bypassed.
in this paper we present a new approach called eissec extracting instruction semantics by symbolic execution of code generators that overcomes these challenges by automatically synthesizing instruction semantics from information already contained in existing compilers.
specifically modern compilers such as gcc and llvm incorporate a code generator that translates code from a low level intermediate representation e.g.
rtl in the case of gcc to assembly.
we develop a novel symbolic execution based technique to extract the semantics encoded in the source of such a code generator.
the extracted semantics maps assembly instructions into the compiler s architecture independent internal representation ir .
not only does this approach avoid manual labor but it also benefits from years of testing and debugging already performed on the code generator.
more importantly the approach is architecture neutral i.e.
it can support any of the numerous architectures already supported by a compiler such as gcc.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
fse november seattle wa usa acm.
... .
artifact evaluated by fse below we summarize the structure of code generators in modern compilers and provide the rationale for the approach developed in this paper.
we then identify the key challenges faced in this approach and summarize our contributions.
.
approach motivation architecture independent code generation has long been a focus in compiler research.
these code generators translate code from an architecture independent intermediate representation ir to assembly.
target independence is achieved by driving a generic code generator with machine descriptions mds that model the specifics of the target instruction set.
the bulk of the md consists of rules that specify how to translate a snippet of ir into an assembly instruction.
these rules are matched up against the ir produced by the compiler front end and the matching snippets are then replaced by the corresponding assembly instruction.
a purely rule based approach can generate inefficient code since it fails to take into account the context in which translation takes place e.g.
it may generate many redundant loads and stores.
davidson and fraser showed that these inefficiencies can be mitigated by performing several optimizing transformations on the generated code.
moreover they showed that the mds can be used to make these optimizations target independent.
this approach thus moves the complexity of code generation to ir optimization passes that are shared across different architectures while simplifying architecture specific mds.
code generators in contemporary compilers such as gcc and llvm follow this general outline.
we based our implementation on gcc s code generator due to its maturity and support for many instruction sets.
to provide a better understanding of the rules used in mds consider the following rule set match operand register operand a div match operand register operand match operand nonimmediate operand qm clobber reg flags reg div the first part of the rule specifies the semantics of the divinstruction in rtl the ir used by gcc.
it indicates that operand contains the result of dividing operand by operand .
at the assembly level the first two operands are implicitly the a register a fact captured by match constraints and a in the rtl.
the applicability of the pattern is constrained by several other architecture specific constraints including register operand and qm.
often compilers don t need the exact flag values after every arithmetic or logical instruction.
hence this rule indicates that flags are modified without specifying exactly how1.
it might seem that we can simply use these rules in the reverse direction to translate assembly to ir.
however several major difficulties arise in so.
we found that key details such as the meanings of the constraints and the printing of assembly level operands i.e.
how 2is substituted in the above example are hard coded into architecture specific c functions.
even the output assembly may not be specified for some rules instead the right hand side of the rule may consist of c code that when compiled and executed will return a string representing the output assembly instruction!
1the impact of this abstraction is discussed at the end of sect ion .one possible avenue is to rely on human experts to specify the behavior of all this c code in a declarative form that is amenable to automated analysis and use in the reverse direction.
this was the approach used by disirer .
unfortunately the amount of code that needs to be manually analyzed is substantial.
for instance the x86 md in gcc consists of rules but the amount of x86 specific c code is about 17k lines!
in addition to the scale of effort involved manual approaches negate two of the key benefits of a compiler based approach the manual effort will need to be repeated for each architecture.
thus the approach is unable to benefit much from a compiler s support for many different architectures.
manual efforts will invariably introduce errors there by necessitating extensive testing thus negating another major benefit of relying on a well tested code generator.
the above drawbacks of manually reversing a code generator are avoided by the learning based approach called lisc we developed earlier.
in this approach a variety of binaries were compiled to produce training data in the form of angbracketleftassembly ir angbracketrightpairs for an algorithm that learns generalized assembly to ir mapping rules.
an important drawback of lisc is that its design does not ensure either soundness or completeness.
instead these properties have to be evaluated experimentally.
we therefore present an alternative approach called eissec that is based on symbolic execution of the code generator.
instead of blindly generalizing from observed results eissec extracts the actual mappings contained in the code generator.
thus the ir to assembly mappings extracted are sound by design.
moreover by developing an all paths exploration technique we ensure the extraction of the complete behavior of the code generator.
.
key challenges and contributions while we want to translate assembly to ir code generators perform the inverse task they map ir to assembly.
hence we need to develop techniques for inverting the translation function of a code generator.
if the code generator was driven by a declarative specification of the mapping the inversion problem may not be so hard.
indeed many modern code generatorsaredrivenbyso calledmachinedescriptions mds that aim to specify such mappings.
however in practice the size of target architecture specific c or c code used in these code generators is rather large.
for instance gcc s x86 machine description consists of pattern matching based rules together with 17k lines of c code2.
thus to realize eissec we must solve the following problems extracting functions specified in code.
we develop a novel symbolic execution based approach for extracting ir toassembly mapping from a code generator.
symbolic execution has been used successfully in the context of software testing vulnerability analysis malware analysis and exploit generation .
however these applications are generally concerned with the discovery of one program path or equivalently the problem of identifying one angbracketleftinput output angbracketrightpair.
sat and smt solvers excel in discovering such counter examples.
in contrast ours is an all paths problem one that requires all 2this excludes all architecture independent code e.g.
rt l optimization passes and the generic rule based translation fra mework.
302possible angbracketleftinput output angbracketrightpairs.while code generators are large they are constrained in some ways for instance loops are rare and pointer uses are relatively simple.
by exploiting these features and by carefully engineering a symbolic execution engine over a constraint logic programming system3 we have overcome the challenges of all paths symbolic execution in this domain.
soundness.
mds are meant to translate a compiler s ir to assembly so a natural question is whether they can be used backwards to lift assembly to ir.
section provides justification for this inversion.
completeness.
the mapping derived by our approach may be incomplete for two reasons.
first a code generator may not use all of the instructions in the target architecture.
our evaluation shows that this isn t a significant source of incompleteness in practice.
secondly the semantics may abstractoutsomedetails e.g.
theexactvalueofcpuflags after an instruction.
our evaluation measures the scope of such incompleteness.
we also discuss how binary analysis and instrumentation techniques can generally work with this imprecision.
see section .
efficient implementation.
our symbolic execution system is efficient and and is able to achieve all paths execution for the 120k lines of c code used by gcc in its x86 code generator.
in contrast with previous techniques that often limited their focus to a subset of instructions we handle the entire x86 instruction set including extensions such as sse4.
avx and fma4.
architecture neutrality.
it took us just about personhours to extract instruction semantics for avr an embedded systems processor used in the popular arduino platform as well as many automotive applications.
paper organization.
in section we describe eissec our symbolic execution system for extracting ir to assembly mapping.
section and section discuss the inversion of these rules and the soundness of so.
experimental evaluation of the completeness soundness and performance of our approach is described in section .
related work is discussed in section followed by concluding remarks in section and artifact description in section .
.
extracting ir to assembly map a conceptually simple approach for extracting ir to assembly mapping is to generate every possible ir snippet that can be given as input and observing the output.
however the number of possible snippets is far too large even a simple instruction set consisting of one opcode and one bit operand will require considering billion possibilitie s. instead of eagerly instantiating all possible ir snippets w e develop a concolic execution4technique that relies on lazy instantiation of ir specifically rtl patterns .
we outline this technique below and illustrate it with a small example.
3logic programming systems are generally designed to produc e most general solutions to constraints and to generate all solutions when needed the reasons we have relied on a clp fd constrai nt solver rather than a more conventional sat smt solver in o ur implementation.
4concolic execution stands for mixed concrete and symbolic e valuation where some of the variables assume symbolic values while the remaining ones assume concrete values.more details about the approach can be found in the first author s dissertation .
.
approach overview symbolic concolic execution systems such as klee dart exe and cute have proven effective in the context of automatic input generation for software testing and bug finding.
the nature of these applications however is qualitatively different from that targeted by eissec.
in particular although these systems try to exercise many paths in the code they don t ensure the exploration of all paths in nontrivial programs.
more importantly they don t attempt to generate every possible input that can drive a program down a specific path.
for this reason they are underpinned by sat smt solvers that are optimized to find a single solution to a formula.
in contrast eissec needs to extract thecomplete input output mapping i.e.
it needs to consider every possible input and compute the corresponding output.
thus eissec needs to traverse all possible paths in the code generator and compute all solutions to formulas i.e.
solve the all sat problem.
for these reasons we have developed a concolic execution system that is targeted at the function extraction problem.
extracting the complete input output behavior of arbitrary programs is infeasible in general.
however code generators are constrained in many ways.
for instance loops are relatively rare and even when they occur they can be easily unrolled.
moreover pointer uses are relatively simple.
by exploiting these features we have developed an effective all paths all solutions concolic execution system that s cales to relatively large programs such as the 120kloc x86 code generator used by gcc.
for simplicity we describe our approach using a hypothetical code generator for the following toy instruction set.
instruction movs d adds d s rn int int d rn int n .. assume that the processor imposes the following restrictions on the operands of these instructions .
stores moves to memory must be from registers .
loads can only target registers through .
.addinstructionacceptsonlyregistersarguments moreover the source register number should be the square root of the destination register.
this odd restriction is introduced as an example of a constraint that won t be supported by a constraint solver.
it will need to be handled by enumerating possible values of a symbolic variable.
figure shows a code generator for this instruction set implemented by a function recog.
it takes a single argument iwhich is an rtl snippet represented using a datatype rtx.
it prints an assembly instruction and returns when there is a valid translation for i and returns otherwise.
it is written in c except that we have a used indentation rather than braces to capture block nesting and b omitted the local variable declarations.
each of the above three cases is handled by the blocks of code beginning respectively on lines and in this figure.
.intrecog rtx i .if getcode i set .
s xexp i d xexp i .if getcode s reg .
getcode d mem getcode d reg .
print mov .
printop s .
print .
printop d .
return .else if getcode d reg .
n getreg d .
if getcode s reg getcode s imm .
getcode s mem n .
print mov .
printop s .
print .
printop d .
return .
else if getcode s add .
r1 xexp s .
r2 xexp s .
if getcode r1 getcode r2 reg .
n1 getreg r1 n2 getreg r2 .
if n2 n n1 sqrt n2 .
print add .
printop r1 .
print .
printop d .
return .return intrecogtr rtx i rtx meta imeta rtx meta ret meta if try getcode cons i set constraint i set x y xexp cons i s effective constraint s x xexp cons i d d y getcode cons s c1 getcode cons d c2 if try c1 reg c2 mem c2 reg printtr o mov printop tr s printtr o printop tr d recordmapping i o addreturncons ret meta backtrack else if try c2 reg d reg getreg cons d n d reg n if try c1 reg c1 imm c1 mem n printtr o mov printop tr s printtr o printop tr d recordmapping i o addreturncons ret meta backtrack else if try c1 add s add xexp cons s r1 xexp cons s r2 s add r1 r2 getcode cons r1 c5 getcode cons r2 c6 if try c5 reg c6 reg r1 reg r2 reg getreg cons r1 n1 getreg cons r2 n2 if try n2 n n1 sqrt n2 n2 n while getnext n2 n3 n1 sqrt n3 printtr o add printop tr r1 print tr o printop tr d record mapping i o addreturncons ret meta backtrack addreturncons ret meta backtrack figure a code generator for the toy instruction set left and its t ranformation for concolic execution right .
.
.
code transformation for concolic execution our concolic execution engine is implemented as a sourceto source transformation on c code implemented using cil1.
.
.
gcc s code generator5also contains the recog function shown in the toy example.
concolic execution will begin with a call to recogwith a symbolic argument.
other than this argument all remaining objects in memory will be concrete at this point.
as recogexecutes it will begin to assign symbolic values to more variables.
we use a simple static analysis to identify functions that could be called by recogwith symbolic arguments and the transformation is recursively applied to those functions.
for performance and scalability the number of symbolic variables should be kept as small as possible.
to accomplish this the transformed code incorporates runtime checks on whethervariablesflaggedbyourstaticanalysistobesymboli c are indeed symbolic at runtime and if not switch to using concrete computations on them.
to ensure consistency between symbolic and concrete state we limit pointers from being flagged as symbolic except in cases where the pointer can be treated as a opaque handle to an abstract data type.
in addition global variables are treated as concrete unless otherwise indicated using annotation.
in our case we had to annotate of gcc s global data structures that store rtxpointers.
array elements and structure fields accessed using constant offsets are permitted to hold symbolic values.
after marking variables as symbolic or concrete code transformation as illustrated in figure is carried out.
first we modelrtxobjects as first order terms and transform calls 5we used gcc .
.
which was the most recent version of gcc at the time we began our project.to its accessor functions into term constraints.
for the toy example the structure of this term is given by rtx set x y add x y reg n mem n imm n int n our constraint solver is a logic programming system so we use the prolog convention that variables start with uppercase while constants begin with lower case letters.
the code generator written in c uses the opposite convention variables are lower case while constants are upper case.
calls to accessor functions such as getcodeget replaced by a call to a symbolic version getcode cons .
these symbolic versions are developed manually but their number is small and moreover they are very simple and architecture independent.
if the value returned by an accessor function is used in a comparison for instance getcode i set the transformed version generates a corresponding constraint namely i set x y .
here xandyare new symbolic variables.
this constraint cis handed to a runtime function trythat forwardsittotheconstraintsolver.
ifthesolverindicatesthat ccan either be true or false then trycauses the symbolic execution engine to fork6 and explore both branches.
this is done in concert with the constraint solver s backtracking mechanism.
however if the solver indicates the only of the branches is feasible trywon t fork.
in the case of assignments we ensure that the variable being assigned is a fresh variable so there is no possibility of the constraint failing.
so the constraint is simply added on the current path without forking.
thus the statement s xexp i which is transformed to xexp cons i s ends up generating the constraint i set s where we use the prolog convention of to denote a dont care variable.
6we use a light weight version of fork as described later.
304arithmetic logic and comparison operations on symbolic variables will result in the generation of a constraint that is handed over to a constraint solver.
in addition output generation is also handled using constraints.
the output is treated as a term specifically a list whose elements get defined as the print operations are executed but the tail remains a symbolic variable until recogreturns.
at this point if the return code is negative we generate the falseconstraint that causes the currently explored path to fail.
otherwise we terminate the output list and record the mapping between input and output.
the constraint solver is queried to extract the contents of input and output at this point based on all the constraints processed by it so far.
.
.
constraint solver even though smt solvers are commonly used by symbolic execution systems they are typically engi neered to produce single solutions very quickly but not so much for the all solutions problem .
logic programming systems on the other hand have been optimized for systematic and efficient enumeration of all solutions.
specifi cally weusealogic programmingsystemwithafinite domain constraint solver clp fd in eissec.
unlike term structure constraints supported in plain logic programming clp fd systems support a wide range of constraints.
unfortunately as a result it is not possible to keep the constraints in the most simplified form i.e.
the equivalent of most general unifiers either don t exist or cannot be efficiently computed incrementally as constraints are added.
nevertheless these systems incorporate a primitive to systematically instantiate variables over a finite domain and to return those values that are consistent with the current set of constraints.
we rely on this primitive especially to handle complex constraints such as the square root constraint in the toy instruction set.
.
.
mapping extracted for figure the first case in the code generator lines to corresponds to two execution paths one where the destination operand of memory and the other with a destination register.
these two paths yield the following rules set mem x reg y mov ry x set reg x reg y mov ry rx the next block lines to contains three disjuncts thus yielding the following three rules.
set reg x reg y mov ry rx set reg x mem y mov y rx x set reg x imm y mov y rx finally thelastblock lines20to30 containsnodisjuncti ons but the constraint solver needs to enumerate the possible register numbers to generate suitable values.
since there are possible register values three combinations are possible thus yielding rules.
set reg add reg reg add r1 r1 set reg add reg reg add r2 r4 set reg add reg reg add r3 r9 it is important to note that our approach generates parameterized rules.
this is achieved by permitting the output to be a list where some elements could be variables.
by associating these variables names between the input and output we are generating parameterized rules.
.
implementation .
.
source to source transformation source to source transformation is implemented as a plugin to cil a popular open source transformation system.
the implementation of the plug in consists of around lines of ocaml code.
the plugin utilizes some of the cil features such as a simplification pass to generate address code from c code to simplify the transformation.
it also handles other challenges such as avoiding the transformations of system code included from header files.
this is done by getting a list of directories which are included in the compiler s include search path.
we treat files included from any of those directories as a header files and avoid their transformation.
.
.
concolic execution engine the transformer needs support code written in c to implement various functions such as addopcons etc.
this support code is approximately lines.
it also includes approximately lines of c code for rtl accessor functions.
note that this code does not have architecture dependencies.
although we limit the propagation of symbolic values for various pragmatic reasons these limitations do not pose hard constraints in terms of code constructs that can be handled.
for instance consider the case of a symbolic value xpassed to an external function that hasn t been transformed and hence can accept only concrete input values .
at this point our concolic execution engine invokes the constraint solver to enumerate all possible concrete values of xthat are consistent with the current set of constraints accumulated onx.
then it forks itself once for each such value and then calls the external function with that value.
our undo record approach is implemented in around lines of c code.
the space complexity of our approach is proportional to the length of the program path in terms of branch points .
thus eissec can scale to millions of paths.
.
.
constraint solver the implementation of our constraint solver uses swiprolog a popular prolog engine with its support for clpfd .
gcc s code generator only generates finitedomain constraints so clpfd is enough for our purpose.
the solver is implemented in around lines of prolog and is supported by lines of c code.
it uses the well known prolog concept of backtracking using fail.
and other supported features of swi prolog such as association lists enumerating all solutions to a query using labeling .
we execute the constraint solver as a stand alone process separate from the process executing the transformed c code.
the support library provides functions used by the transformed code to interact with the solver.
although we could map most of our requirements from the constraint solver into the predicates of clpfd or swiprolog one problem demanded special treatment.
specifically we found that neither clpfd nor swi prolog provides predicate s to access the set of constraints imposed on the variables.
to solve this problem we access the constraints usingclpfd attr and access its propagators via fd props7 7these are predicates internal to swi prolog.
305as swi prolog stores the constraints using attributed variables .
in order to capture a complete set of constraints on all the input and output variables of a mapping rule we traverse the dependence graph of the variables starting from the output variables and reaching all the input variables.
the dependence graph is a graph where the nodes are variables and the edges are constraints between the variables.
the goal of the traversal is to print constraints appearing on all the paths between the output and the input variables.
.
.
optimizations symbolic to concrete conversion enumeration as we described earlier leads to a large number of program paths so we have implemented several optimizations to limit it using range and set constraints.
this optimization relies on set and range constraints supported by swi prolog engine.
instead of generating a concrete process for every concrete enumerated value it uses set or range constraint to generate only one concrete process.
in symbolic execution context this optimization achieves the same effect as that of merging paths.
we implement this optimization in array accessor functions and in case of gcc some of the arrays contain hundreds of elements.
by using range constraints such elements could be represented using a few ranges.
exploiting hardware level parallelism.
as mentioned earlier parallel exploration of paths could be pursued with significant benefits at the higher levels of the search tree while at the lower levels benefits are less significant.
we have implemented a simple parallelization strategy that reverts to the use of efficient but serial undo mechanism at lower levels while relying on forks at the higher levels.
.
lifting binaries to ir as described earlier our concolic execution generates parameterized rules of the form ir asm.
the example rules for the toy instruction set was shown in section .
.
.
the key idea is to use these rules in reverse in order to lift binaries to ir.
while conceptually simple several additional problems need to be addressed in order to apply this approach to whole binaries disassembly for stripped binaries disassembly can be a nontrivial task.
however recent works e.g.
have developed solutions that are robust enough to scale to large binaries and we simply build over these solutions.
efficient lookup for large instruction sets the technique described in the last section can generate millions of rules.
to use this rule set efficiently we construct a matching automaton from these rules.
specifically we parse assembly instructions to construct asts and the matching automaton operates on this ast.
efficient tree automata construction techniques have been well studied and their use in assembly to ir lifting is also known .
handling one to many mapping multiple irs may be translated into the same assembly instruction.
as a result whenthemappingisinverted asingleassemblyinstruction may map to multiple irs.
as we discuss later these mappings are all sound but some may be more precise than others e.g.
contain fewer clobber declarations.
eissec chooses more precise translations when available.
handling many to one mapping there are instances when the code generator maps an ir snippet into a sequence of assembly instructions.
as a result a simple approach that lifts a single assembly instruction at a time won t always work.
a naive approach for handling such manyto one translations can lead to exponential complexity.
in previous work we developed a linear time dynamic programming technique to handle many to one mappings.
soundness of reversing ir to assembly mapping.
this is perhaps the most important consideration and is the topic of the next section.
.
soundness as described earlier mds are used to translate rtl to assembly so a natural question is whether it is sound to use them backwards.
there is an important practical reason to believe this from a developer s perspective an md is developed by enumerating instructions in the target architecture and specifying the equivalent rtl.
the second and more important reason for soundness stems from how these rules are used in code generators.
as discussed before these md pattern matching rules are applied against ir generated from the compiler front end.
any time there is a match a rule can be used.
this essentially means that in every system state the behavior of ir and assembly code components of any rule must have close correspondence.
otherwise the assembly instruction will either fail to achieve a required effect e.g.
fail to set a result register to a specified value or have spurious additional effects e.g.
modify a register that was indicated as being preserved in the ir .
intuitively this means that the semantics of ir and assembly should be in close correspondence.
we begin with a definition of this correspondence taken from .
the state sasmat the assembly level is given by an assignment of values to a set of variables vasmrepresenting the processor s internal registers memory etc.
the state srtlat the rtl level is given by an assignment of values to a set of variables vrtlrepresenting the processor s state as viewed by the code generator.
we assume that vrtl vasm.
the set of permitted values for a variable vat the rtl level will include all of the values permissible at the assembly level plus a special value called that captures the idea that the value is unknown or undefined.
srtlis said to be validfor an rtl snippet rif for every variable vread byr excluding those variables that are first updated and then read by r srtl v negationslash .
definition processor state correspondence .
statessasmandsrtlare said to correspond if v vasm srtl v sasm v srtl v this definition says that srtlis a conservative approximation of sasm either they agree on the value of a state variable or srtlleaves it unspecified.
the latter choice is made when a developer specifies that an instruction clobbers something without specifying an exact value.
this is mostly done for cpu flags.
while the state correspondence notion seems very reasonable note that it does imply that ir state should be mapped to concrete processor state.
for instance virtual registers need to be mapped to concrete registers.
this holds in the case of gcc the compiler used in our implementation.
306based on the correspondence between the statesat the ir and assembly levels we can define a notion of correspondence between instruction behaviors at the assembly and ir levels.
weusethenotation r s s todenotethattheexecution ofrin statesleads to a new state s .
definition recogsoundness .
letrbe such that recog r yields the assembly instruction a. letsrtlbe any state that is valid for r andsasmbe any corresponding state.
letr srtl s rtlanda sasm s asm.
the ruler aproduced by recogis sound if s rtlands asm correspond to each other.
note that this definition captures the intuition that an assembly instruction amust do every thing that is done by the corresponding rtl instruction r but it may also do more.
in particular from the definition of state correspondence s asmmay differ from s rtlin terms of a state variables that are not captured at the rtl level and b state variables that have been assigned ins rtl.
theorem code generator soundness .
any violation ofrecogsoundness will cause the code generator to produce incorrect code.
proof ifrecogsoundness is violated then there must exist anrtlrandcorrespondingstates srtlandsasmsuchthat recog r a r srtl s rtlanda sasm s asm buts rtlands asmdon t correspond.
from the definition of state correspondence this means that there is a state variable v vrtlsuch that s rtl negationslash s asm where s rtl negationslash .
now consider an rtl snippet r that depends on v. let recog r a .
thus the code generator will generate a a from rtl snippet r r .
note that the behavior of r r and a a cannot be identical because r starts with a different value of the variable vas compared to a .
note that there are two implicit assumptions in the proof that anr that depends on vcan be found and that there will be some source program whose translation can result in the sequence r r .
it is conceivable that the code generator is based on some deep knowledge that such a combination is impossible but it does not seem likely moreover building in such unspecified assumptions is not a reasonable practice.
theorem soundness of asm to rtl mapping .
letrbe an rtl snippet such that recog r a. ifrecog is sound then ris a sound i.e.
conservative approximation of the behavior of a. formally let a sasm s asm andsrtlbe obtained by restricting sasmtovrtl and r srtl s rtl.
thens rtlis a conservative approximation of s asm.
proof follows directly from the definition of recogsoundness.
note that sasm s asm srtlands rtlsatisfy definition and hence states s asmands rtlare in correspondence.
thuss rtlis a conservative approximation of s asm.
if multiple rtl snippets r1 ... r nare mapped to the same instruction a then this theorem implies that each ri must be a conservative approximation of the semantics of a. discussion.
note that a sound translation can be imprecise.
in particular there may be cases where some details of instruction semantics are not captured in the rtl translation.
in practice this mainly occurs in the case of cpu flags.
many arithmetic instructions modify these flags but the rtl specification of these instructions may only carry the informa tion that flags are clobbered by these instructions.
this does not normally pose a problem since compiler generated code uses cpu flags only after certain specific instructions such as comparison.
flags resulting from arithmetic operations are not used.
as long as the binary code being translated satisfies this condition use of approximate semantics will pose no problem.
even otherwise static analysis techniques are generally based on lossy approximations so should be able to cope with this kind of precision loss.
in an instrumentation context there can be a problem since the lifted rtl may include snippets that access valued variables.
this problem can also be handled we keep track of the assembly instructions athat lose precision during the lift up to their irr and moreover are followed by other instructions that depend on variables vuleft unspecified by r. when the binary is regenerated after instrumentation we ensure that ris replaced by a thus ensuring that the values of variables invuwill remain the same as in the original program.
thus any precision loss introduced by eissec does not pose a problem for binary instrumentation as well as most binary analysis techniques.
but for other applications e.g.
binary retargeting this precision loss may not be acceptable.
to support such applications the semantics derived by eissec needs to be manually augmented.
even so eissec can greatly reduce manual effort as it leaves only a small fraction of state variable values unspecified.
.
ev aluation in this section we evaluate eissec in terms of its performance on the x86 instruction set section .
the completeness of this model section .
and eissec s ability to support other architectures section .
.
where appropriate we compare the performance of eissec with the learning based lisc approach .
all evaluations were performed on a .90ghz intel core i7 3517u processor with 4gb of ram running linux .
.
.
.
performance on x86 code generator when gcc is compiled for an architecture it uses the machine description for that architecture together with architecture specific c code to generate a decision tree.
the decision tree is the analog of the recogfunction in fig.
i.e.
it translates rtl snippets to assembly.
our implementation is based on gcc .
.
the same version used in lisc .
in the case of x86 the machine description contained templates rules each for translating a snippet of rtl to assembly.
these templates cover all of the advanced x86 extensions such as sse and avx.
the templates themselves may contain c code.
in addition there is about 17kloc of architecture specific c code in the x86 code generator.
from all this code gcc generated a decision tree consisting of approximately 120k lines of c code.
eissec transforms and performs concolic execution on this 120kloc.
unoptimized performance.
fig.
shows the progress of concolicexecutionovertime.
thefirstcolumnshowsthetime while the second and third columns refer to the number of successfulandfailurepathsexploredbytheconcolicexecution engine.
the fourth column shows the coverage obtained expressed in terms of the fraction of the leaves in the decision tree that have been visited.
the fifth column shows the virtual memory use.
307total success failure coverage virtual time paths paths memory days m m use mb .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
figure unoptimized performance on x86.
although days may seem like a significant length of time what is more remarkable is that ultimately coverage is obtained.
in particular all possible paths in the 120kloc of decision tree code have been traversed and all possible angbracketleftrtl assembly angbracketrightpairs corresponding to each of these paths have been generated.
note that each positive path represents a successful translation of some rtl snippet to assembly.
although the machine description itself contains only thousands of translation tem plates the number of success paths traversed by the concolic execution engine numbers in tens of millions.
this is because the engine needs to consider all possible input output mappings that might result from each such template.
at one extreme a naive enumeration of all possible operand values can easily lead to the generation of 1010to 1030input output combinations for a single template depending on the number of operands involved.
clearly our constraint solver is performing much better which indicates that it is able to avoid enumeration in most cases.
some case where it can t avoid enumeration are as follows.
an instruction template may work with many different operand combinations but in the assembly representation these combinations differ significantly in their syntax causing distinct mappings to be computed.
secondly registers are identified using numbers in rtl while they have names such as eax.
moreover these names differ depending on the width of data involved.
each of these factors has a multiplicative effect thus contributing very quickly to thousands of mappings for each template.
note that the number of failure paths is far larger than success paths.
this is because each successful path performs a series of checks on rtl.
under normal operation almost all these checks would succeed but the concolic execution engi ne does not know this and hence needs to generate inputs that fail each of those checks.
thus the number of failure paths would be of the order of summationtext pi where pi denotes the length of theith successful path.
note that memory use is small which means that the exploration can be parallelized easily.
performance with optimizations.
early on in thebase range naive constraints parallelization cpu time days .
.
.
success paths m .
.
.
failure paths m .
.
.
total paths m .
.
.
figure effect of optimizations for x86.
project a lot of effort went into building a highly efficient concolic execution engine.
this included the development o f very light weight engine level fork operations that avoided an os level fork but instead relied on application level maintenance of undo records.
before these efforts the engine could handle instruction sets that were orders of magnitude smaller than x86.
only a limited effort has been put into other aspects of optimization such as range constraint optimization and parallelization discussed in section .
.
.
figure shows performance improvements obtained using the optimizations from section .
.
.
range constraint optimization is quite effective yielding over performance improvement.
thenatureofconcolicexecutionprovidesalmostunbounded opportunities for parallelization.
however to fully exploit it significant engineering effort needs to be expended on the concolic execution engine.
in particular we need a seamless way to switch between our application level forks and oslevel forks.
since we have not spent this effort we opted for a simpler approach that simply divides the decision tree at the top level into several pieces with each subtree explored serially.
although there were subtrees at the top level they were not balanced in size and hence we were able to gain only a improvement.
with additional effort it should be possible to reduce the execution time linearly with the number of available processors.
performance comparison with lisc.
lisc was trained with just over 3m angbracketleftrtl assembly angbracketrightpairs from about a dozen carefully chosen software packages.
since the number of pairs considered is about two orders of magnitude smaller than the total paths considered by eissec it is no surprise that lisc is much faster than eissec.
however note that semantics extraction is a one time effort so performance is not critical.
factors such as soundness and completeness are far more important and we discuss these in the next section.
.
code generator completeness symbolic execution by design should extract the complete behavior of the code generator as long as the coverage achieved is complete specifically if we ensure that all possible inputs have been considered.
as indicated by our experiments eissec does achieve complete coverage for the x86 code generator.
thus what is left to evaluate is the completeness of the code generator.
no additional incompleteness is introduced by our approach.
to evaluate the completeness of gcc s code generator we used the semantic model extracted by eissec to lift the instructions in all of the binaries that ship by default with ubuntu .
desktop version .
we were able to translate .
of the assembly instructions without any manual effort.
the remaining .
corresponded to of the 308instructions supported by x868.
many of these missing instructions are either inserted by the assembler e.g.
enter and various versions of nop or are low level instructions e.g.
cpuid invpcid andrdtsc that may be found in hand coded assembly.
also missing are some rarely used arithmetic instructions such as those operating on binary coded decimals and those for directly setting clearing cpu flags.
we did not undertake a formal comparison with valgrind but do point out that eissec supports all of the advanced x86 instructions such as fma4 that are missing in valgrind and similar systems.
in comparison with eissec lisc achieved .
coverage on the ubuntu test.
it should be noted that lisc achieved this coverage using a carefully selected training set that was optimized for this specific dataset.
despite this the number of instructions lisc can t translate is higher than eissec.
these misses covered two instructions rcland rcr as well as operand modes and combinations for other instructions that weren t present in the training set.
more importantly soundness of the extracted semantics has been established for eissec but in the case of lisc soundness is not ensured.
while testing techniques have been developed to compensate for this shortcoming only a small subset of x86 instructions have been tested in .
.
architecture independence we then followed the same evaluation steps to extract instruction semantics for the avr processor used in the popular arduino embedded system platform.
avr is also widely used in automotive applications.
we used avr gccv4.
.2code generator in our evaluation.
the avr architecture has mnemonics and the code generator used for the symbolic execution contained rtlto assembly mapping pairs.
the decision tree used by the code generator takes approximately 12k lines of c code.
our source to source transformer places some restrictions on the code.
some manual effort is required to modify the code generator to ensure conformance with these restrictions.
this manual effort required approximately hours.
in comparison lisc took roughly half this time .
hours .
being a black box approach lisc requires less manual effort than eissec.
runtime performance of eissec on the avr decision tree is shown in fig.
.
all of the optimizations discussed in section .
.
were used including way parallelization at t he top level of the decision tree.
note that the number of paths explored is about three orders of magnitude smaller than that of x86.
consequently model extraction is much faster as well.
four of the avr instructions break nop wdr andsleep were not supported by gcc.
eissec was able to extract the semantics for the remaining instructions.
.
related work .
binary analysis and instrumentation most previous binary analysis instrumentation systems including dynamorio pin qemu valgrind secondwrite codesurfer uqbt and many 8this count excludes privileged instructions that cannot be used at the user level.
more details about this dataset and how w e counted the instructions can be found in .total success failure coverage virtual time paths paths memory mins k k mb .
.
.
.
.
.
.
.
.
.
.
.
.
figure performance on avr.
other systems require a hand written target instruction specification to drive the translator.
approaches have been developed for assembly to ir translation by relying on qemu s support for multiple architectures.
specifically they have written a backend for qemu to translate qemu s ir to llvm s ir.
bap on the other hand directly uses valgrind s assembly to ir translator.
these methods thus inherit any completeness issues from qemu and valgrind which manifest as a support for only the most commonly used platforms and b missing support for new and advanced instruction sets.
disirer anddagger aretwoeffortsthatusecompiler infrastructures to lift binaries to an ir.
dagger relies on the llvm infrastructure but their approach is a manual one it requires a good understanding of llvm internals and considerable amount of additional code development.
disirer s goals are similar to ours using mds in reverse to lift binaries.
however as discussed earlier there are many parts of mds that are not specifications and the only way to invert them is if we understand the c code involved and manually write functions to invert them.
lisc relies on generating abstract mapping rules by learning the assembly to ir translations from concrete mapping rules obtained from code generator logs.
to generate the logs we compile a number of source code packages and record the angbracketleftir assembly angbracketrightpairs produced.
being a blackbox approach it requires less effort than eissec to support each addition architecture.
lisc is also faster.
however lisc does not guarantee the completeness of the extracted map.
eissec on the other hand explores all of the code generator paths and guarantees the completeness of the extracted map.
more importantly we prove the soundness of eissec but the soundness of lisc mappings need to be evaluated experimentally specifically using test cases .
both lisc and eissec were the results of the first author s phd research and a fuller discussion and comparison of the two approaches can be found in his dissertation .
.
constraint solvers smtsolvers suchasstp andz3 areusedinmany popular symbolic execution systems .
smt solvers with support for various theories such as arrays match closely with the semantics of c language.
so it is no surprise that they form the decision procedure backend for symbolic execution systems.
sat smt solvers are engineered to efficiently find one solution to a given formula.
fortunately in the context of bug finding or software testing the domains where these solvers are mostly used producing one solution is typically enough.
in other words existing solvers are not targeting 309all sat problem i.e.
finding allsolutions to a sat problem.
eissec however requires the extractions of the complete input output behavior of a code generator.
this requires the identification of every angbracketleftinput output angbracketrightpair that can be produced by the code generator.
in other words eissec needs to solve an all sat problem.
unlike sat solvers that are optimized for finding one solution logic programing systems are designed so that they can produce all solutions if needed.
this is why we based eissec on an clp fd system.
.
function extraction symbolicexecutionhasbeenusedinthecontextofprogram verification.
for instance work presented in uses symbolic execution in order to extract and verify cryptographic protocol models from their c implementations.
although the high level idea of using symbolic execution to extract a function from c code is similar to eissec there are number of differences.
specifically the complexity of cryptographic code handled in this work is several orders of magnitude less 100x than gcc s code generator.
moreover their system confines symbolic execution to main path in the code and can only handle the protocol implementations with no significant branching.
in order to reduce the complexity of symbolic execution they manually build semantic models for commonly used cryptographic function.
eissec on other hand would use concrete execution in such cases.
approach described in uses model extraction of gui programs from hand held devices and compares extracted models with the expected models obtained from specifications .
their work is mainly concerned with extracting models to capture how system responds to user inputs.
consequently their model is a state machine which captures system transitions on various event inputs.
definition of model for eissec on the other hand is simply a mapping between input rtl and output assembly instructions .
synthesizing functions using input output samples could be considered as an alternative to function extraction using symbolic execution.
given the complexity of symbolic execution engines encoding the instruction semantics in sy mbolic formulas is an interesting challenge.
there are existing approaches that use program synthesis or templatebased approach to generate bit vector formulas representing instruction semantics.
rather than searching the functions representing instruction semantics in a large search space they confine the search space by manually specifying semantics of basic instructions called base set in .
seman tics of remaining instructions is then searched starting from the semantics of basic instructions.
for instance using manually provided templates approach described in is able to synthesize formulas for bit x86 arithmetic instructions.
similarly using instructions in base set th e approach proposed in is able to synthesize smt formulas for around of x86 instructions.
both the approaches have the advantages of not relying on the correctness of a code generator and that they can address the precision issue semantics of eflags faced by eissec.
we address the correctness problem by developing a systematic proof of soundness.
although both the approaches are effective in synthesizing the semantics of parts of bit and bit x86 instruction sets they suffer from several limitations.
first of all the task of specifying the semantics of basic instruction s demands reasonable understanding of the target architec ture.
consequently it is unclear the level of effort required in supporting new architectures.
as compared to these approaches eissec requires minimal if not none architecture knowledge not the understanding of instruction semantics .
second both the approaches could not extract some of the user level instructions especially floating points and vec tor instructions in because of the difficulty or complexity modeling those instructions.
in our experiments eissec was able to extract semantics of advanced x86 instructions also.
moreover the approach used in eissec is not limited by the size of instruction s input space bit or bit an d can easily scale to complex instruction sets.
.
conclusion in this paper we described an automated approach using symbolic execution for extracting the instruction semantics model encoded in the code generators of modern compilers.
we formulate the model extraction problem as the all paths problem and employ carefully engineered symbolic execution system for extracting the complete input output behavior of the code generators.
unlike existing symbolic execution systems that are mostly applied in the context of testing or bug finding the model extraction problem demands different considerations in the design of a symbolic execution system.
our experimental evaluation validates our hypothesis that the knowledge encoded in the code generators of modern compilers can be used for semantic extraction with relative ease.
we apply eissec to gcc s x86 code generator of size kloc and extract semantics of all the instructions supported by the code generator.
importantly we demonstrate that by exploiting the strength of symbolic execution in reaching all of the rarely visited corners of the program code our approach is able to extract the semantics of all the instructions supported by the code generator.
furthermore it reduces manual modeling efforts even further than existing learning based approaches.
we also address a common concern of the soundness of the extracted model by developing a systematic proof.
lastly we demonstrate architectureneutrality of our approach by extracting semantic model of avr architecture.
in the spirit of open source community and to share our research prototype with other researchers working on similar problems we provide artifact description of our approach in this paper.
additionally the artifact is also available from our laboratory web site .
.
artifact description eissec artifact is packaged as a docker image that can be installed on linux windows macos and many other oses.
instructions for using the artifact are as follows docker installation.
please refer to steps at https docs.docker.com engine installation to install docker on your machine.
eissec docker image has been tested on ubuntu .
x86 .
using eissec docker image.
execute commands below to pull eissec docker image create a container from the image and get a shell access to the container.
docker pull seclab eissec docker create it name eissec seclab eissec docker start eissec docker exec it eissec bash 310 g2101 in .. g653 in .. g653 g588 g184 g653 g462 in .. g462 g494 g494 in .. g494 g543 g588 g462 g494 g494 g543 g543 in .. g494 g543 g588 g494 g543 g588 in .. g653 g588 g588 g184 g494 g543 g588 g184 in .. g184 g653 g588 g184 map cmpb g2101 insn g9 rtl g27 union u rtl g184 g191 g198 g205 rtl g462 g469 g470 g471 rtl g653 g660 g667 g668 g393 g39 g46 g53 g54 g73 figure mapping rule for cmpb reg instruction after executing these commands we get shell access to the eissec container.
inside the container in eissec directory the layout of eissec source package can be seen.
areadmefile under eissecdirectory explains the layout.
now execute commands below inside the container to build the eissec executable and extract the model from x86 code generator.
cd eissec source env setup.sh make cd test x86 .
testmodel dummy.c .
fullmodel dummy.c output of testmodel.
.
testmodel dummy.c this command will dump assembly to rtl mapping for a sample code generator.
one of the dumped rules is shown in fig.
.
in the figure gare prolog variables.
the figure shows the mapping rule for cmpbx86 instruction.
the operand ofcmpbis represented by a variable g2101.
it is a register operand as signified by the prefix before g2101.
rtl corresponding to the assembly specifies how it maps g2101into rtl variables.
for variables in assembly instruction rtl variables are obtained by solving constraints involving rtl variables.
mapping rules are of the form asm x y z rtl where x y andzare variables in assembly and rtlis an rtl snippet.
the rtl snippet contains many variables that are derived from the operands of the assembly instruction.
relations between x y zandrtlare captured by the set of constraints for every rule.
there can be more than one possible instantiation that satisfies the constraints for a single rule.
these instantiations correspond to different operands that a rule will support.
steps involved in extracting instruction semantics are transform gcc s code generator code for symbolic execution.
eissec uses cil based source to source transformation.
transformed code when executed performs symbolic execution of the code generator.
our sourceto source transformer is named pkgs cil .
.
bin cilly.
it transforms insn recog.c fromtest x86 while compiling test x86 .
transformed version of insn recog.c canbefoundin tmp insn recog.cil.c .
constraints sent to constraint solver.
whentestmodel orfullmodel is executed constraints sent tocons solve are dumped into tmp logcs file.
if you would like to change the location please modify driver.c intest x86 and recompile.
maturity.
artifact describes eissec symbolic execution system used to extract assembly to ir model from compiler scodegenerator.
extractingassembly to irsemantic model is the one of the complex tasks in the process of assembly to ir translation.
typical approach to this problem is to manually extract assembly to ir semantic model.
eissec automates this task and the artifact demonstrates how eissec automatically extracts the model .
note that this artifact does not describe how to apply extracted semantic model for assembly to ir translation process.
source code.
eissec s source code is fully contained insideeissecdirectory inside the docker container.
the src directory inside eisseccontains the source code of sourceto source transformer transformer for symbolic execution helper functions for symbolic execution symhelper and the interface to the constraint solver csolve .
additionally eissec source code can also be downloaded from .