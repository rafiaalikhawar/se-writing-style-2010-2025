search based energy testing of android reyhaneh jabbarvand jun wei lin and sam malek school of information and computer sciences university of california irvine usa fjabbarvr junwel1 malek g uci.edu abstract the utility of a smartphone is limited by its battery capacity and the ability of its hardware and software to efficiently use the device s battery.
to properly characterize the energy consumption of an app and identify energy defects it is critical that apps are properly tested i.e.
analyzed dynamically to assess the app s energy properties.
however currently there is a lack of testing tools for evaluating the energy properties of apps.
we present c obweb a search based energy testing technique for android.
by leveraging a set of novel models representing both the functional behavior of an app as well as the contextual conditions affecting the app s energy behavior c obweb generates a test suite that can effectively find energy defects.
our experimental results using real world apps demonstrate not only its ability to effectively and efficiently test energy behavior of apps but also its superiority over prior techniques by finding a wider and more diverse set of energy defects.
index terms software testing energy testing android i. i ntroduction improper usage of energy consuming hardware elements such as gps wifi radio bluetooth and display can drastically discharge the battery of a mobile device.
recent studies have shown energy to be a major concern for both users and developers .
in spite of that many mobile apps are abound with energy defects.
this can be attributed to the lack of tools and methodologies for energy testing .
recent advancements in mobile app testing have mostly focused on testing functional correctness of programs which may not be suitable for revealing energy defects .
there is thus an increasing demand for solutions to assist developers in testing energy behavior of apps prior to their release.
the first step toward energy testing is to understand the properties of tests that are effective in revealing energy defects in order to automatically generate such tests.
recently jabbarvand et al.
proposed a technique based on mutation testing to identify the properties of proper tests for energy testing.
they showed that to kill the energy mutants tests need to be executed under a variety of contextual settings.
based on the results of their study we have identified three contextual factors that are correlated to energy defects and should be considered in energy driven testing lifecycle context a subset of energy defects e.g.
wakelocks and resource leaks manifest themselves under specific sequences of lifecycle callbacks hardware state context some energy defects happen under peculiar hardware states e.g.
poor network signal no network connection or low battery and interacting environment context certain energy defects manifest themselves under specific interactions with the environment consisting of user backend server other apps and connected devices such as smartwatches.none of the prior automated android testing techniques properly consider these contextual factors in test generation thereby are not able to effectively test the energy behavior of apps.
that is majority of the state ofthe art android testing tools are aimed for gui testing which only considers the inputs directly generated by user e.g.
clicking on a button.
even among the techniques that go beyond gui testing there is no systematic approach for altering the lifecycle of components and state of hardware elements to properly evaluate the energy behavior of apps.
in this paper we present c obweb an energy testing technique for android apps.
c obweb uses an evolutionary search strategy with an energy aware genetic makeup for test generation.
by leveraging a set of novel models representing lifecycle of components and states of hardware elements on the phone c obweb is able to generate tests that execute the energy greedy parts of the code under a variety of contextual conditions.
extensive evaluation of c obweb using real world android apps with confirmed energy defects demonstrates not only its ability to effectively and efficiently test energy behavior of apps but also its superiority over prior techniques by finding a wider and more diverse set of energy defects.
the remainder of this paper is organized as follows.
section ii introduces an illustrative example that is used to describe our research.
section iii provides an overview of our approach while sections iv v describe the details.
section vi presents the evaluation results.
the paper concludes with a discussion of the related research and avenues of future work.
ii.
i llustrative example as an illustrative example we use an android app called mytracker .
in this section we describe two main functionalities of mytracker two tests to exercise these functionalities and two energy defects in this app that cannot be caught by tests that do not take execution context into account.
app as shown in figure mytracker allows users to search for the map of different locations using either the internet or gps download them and navigate through each specific downloaded map.
this app consists of seven components i.e.
four activities and three services .
mytracker provides two functionalities tracking navigation and search download map.
when a user clicks on the download maps button the app navigates to mapsearchactivity where the user can search for maps using the internet or gps.
if the user decides to search using the internet she needs to provide the name of the city e.g.
ottawa and then click on the find by internet button.
otherwise she can just click on the find by gps button.
depending on the selected search option the app starts ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
mytracker android application internetservice orgpsservice in the background which searches for the map on a specific server.
upon finding a match with the name provided by user or location coordinates downloadservice downloads the map resulting in the list of maps displayed on mainactivity to be updated.
for tracking once the user clicks on one of the downloaded maps in mainactivity e.g.
the map of montreal shown in figure the app navigates to locationactivity .
in this activity the user can see the map of montreal and provide a source and destination address to start the navigation.
by clicking on the start button the app starts trackingactivity and registers a location listener which updates the gui of trackingactivity upon movement.
tests android tests can be represented as a sequence of events where each event is an input to the app and can be triggered by the user or system.
we formally define each test tin test suite t ashc1he1 e p1i c mhe1 e pmii where ciindicates the ithcomponent covered during the execution of t. the execution of each component ci which could be activity service or broadcast receiver by test tis represented as an event sequence where each event is denoted ase.
we consider two types of events input events that take inputs using specific apis e.g.
filling a text box and callback events that are invocation of android callbacks e.g.
click on a button or transition to a lifecycle state.
figure shows representation of two tests according to this formalism that target the two functionalities of mytracker app.
we use these tests throughout the paper for illustrating our approach.
energy defects mytracker suffers from two energy defects fail to check connectivity energy defect occurs when an app fails to check for connectivity before performing a network operation.
mytracker unnecessarily searches for a network signal when there is no network connection available which is a power draining operation.
to find this energy defect mytracker should be tested both when there is a network connection available and not.
the test corresponding fig.
event sequences for testing the tracking navigation and search download functionalities of mytracker fig.
cobweb framework to sequence in figure does not enable or disable network connectivity therefore cannot detect this defect.
mytracker starts listening to location updates in trackingactivity by registering a location listener for gps.
as long as trackingactivity is visible to the user and gui is rendered based on location updates mytracker can keep the gps active.
however when user puts the app in the paused state i.e.
mytracker is sent to background it does not unregister the location listener thereby unnecessarily updates a gui that is not visible to the user .
to find this energy defect a test needs to put trackingactivity into paused state for some time to assess utilization of gps hardware in this state.
clearly the test corresponding to sequence in figure does not have this property.
iii.
a pproach overview since the domain of events and inputs for android apps is quite large c obweb follows a search based testing technique for input generation.
every search based testing technique has three facets search space which is a set of possible solutions meta heuristics to guide the search through the search space and evaluation metrics to measure the quality of potential solutions.
cobweb identifies the search space as a set of event sequences i.e.
system tests.
to guide the search through the search space our approach utilizes an evolutionary algorithm to globally search for an optimal solution.
similar to other search based techniques c obweb relies on the abstract representation of the program i.e.
models to generate event sequences and compute the fitness function as an evaluation metric.
however a key novelty of c obweb is that unlike prior search based testing techniques it also utilizes several other contextual models representing the state of hardware and environment in the search process.
figure provides an overview of c obweb consisting of two major components model extractor component that derives the required models for test generation and test generator component that utilizes an evolutionary searchbased technique to create system tests.
c obweb s fitness function rewards the tests based on two criteria how close they are to covering energy greedy apis in the application logic and how well they contribute to exercising different contextual factors.
iv.
m odel extractor cobweb uses four types of models component transition graph ctg call graph cg lifecycle state machine lsm and hardware state machine hsm .
figure shows authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a subset of these models for mytracker app.
at the highestlevel is the ctg model which represents the components comprising the app as nodes and the intents as transitions among the nodes.
intents are android events messages that result in the execution flow to move from one component to a different component.
each node of the ctg in turn contains one cg representing the internal behavior of the corresponding software component one lsm representing the possible lifecycle states of the corresponding software component and zero or more hsm each of which represents the states of an energy greedy hardware element utilized during the execution of the corresponding software component.
lsm and hsm models are generic and app device independent constructed manually by the authors while ctg and cg models are appspecific and automatically extracted through static analysis of an app s bytecode.
we describe each model and how it is obtained in the remainder of this section.
a. component transition graph ctg cobweb utilizes ctg to ensure generation of valid and useful event sequences.
events can be categorized into input events that take inputs to the app using specific apis e.g.
edittext.gettext that reads a string provided by user for a text box and callback events that invoke android callbacks e.g.
onlocationchanged which is invoked when the physical location of the device changes.
cobweb uses ctg model of the app under test to generate the proper order of event calls.
finding the proper order of event call invocations is particularly a challenge in android due to usage of callbacks each considered a possible entry point for an application.
for example onlocationchanged callback is an entry point for mytracker app.
the call graph obtained from running the state of the art static analysis tools such as soot does not model any particular order for the execution of entry points.
that is using such call graphs to generate event sequences onlocationchanged can appear before the oncreate oftrackingactivity or even oncreate ofmainactivity .
however proper invocation of onlocationchanged is after the execution of oncreate oftrackingactivity as shown in sequence of figure .
furthermore to properly test the energy behavior of mytracker with respect to its tracking functionality c obweb needs to mock the location such that android platform invokes onlocationchanged callback.
the tricky part of generating such tests is that onlocationchanged callback should only be invoked if the app has already registered a location listener to receive location updates which happens in the oncreate method of trackingactivity component.
in other words mocking the location should be performed after trackingactivity starts.
otherwise mocking has no effect and will not result in the invocation ofonlocationchanged callback.
generating valid and useful events entails not only an inter procedural analysis to find the proper component for callback invocation but also requires considering the specific types of dependencies among events.
to overcome these challenges ctg considers fivetypes of transitions fig.
ctg model for mytracker.
gray boxes show the detailed cg lsm and hsm of downloadservice and trackingactivity components.
components marked with an asterisk contain energygreedy api invocations call transition these intra component transitions are inferred from the basic call graph generated for the app under test using soot .
intent transition these transitions are inter component which result in transferring the control from one component to another component.
a method or callback inside one component that starts another component is connected to the lifecycle entry point of that component using this kind of transition.
c obweb uses ic3 to infer intent transitions.
gui transition these intra component transitions indicate the order of execution between gui widgets.
for example the start button in the locationactivity of mytracker should be clicked after user provides source and destination addresses in the from and totext boxes.
c obweb builds on top of trimdroid to infer such transitions.
registration transition this type of transition consists of two sub categories broadcast receiver registration and event listener registration .
a broadcast receiver receives an intent for which it has registered for via the onreceive callback method.
while static broadcast receivers those identified in the manifest file are registered when the app launches dynamic broadcast receivers are registered using registerreceiver api.
broadcast registration transition which could be inter or intra component connects a cg node that registers a broadcast receiver to its corresponding onreceive callback which is also a cg node.
an event listener is an interface that contains one or more callbacks.
listener callbacks are called by the android framework when the event that the listener has been registered authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
for is triggered either by user or environment.
for example onlocationchanged is called upon any change in the location of the device if the app has previously registered a location listener.
listener registration transition which could also be inter or intra component connects a cg node that registers a listener to its corresponding callbacks which is also a cg node.
the listener callbacks have no order among themselves.
cobweb s approach for identifying registration transition works as follows.
for a given registered callback c obweb performs an inter procedural flow sensitive static program analysis to find the registrar the entity that registers the broadcast receiver or listener of that callback.
it then assigns a transition from the registrar to the registered callback node in cg.
for broadcast registration the registered callback is onreceive either defined inside an inner class broadcast receiver or a broadcast receiver component and registrar is callback or method that invokes the registerreceiver api.
for listener transition c obweb takes a list of listener callbacks available in android api1to identify registered callbacks.
the listener registrar is a callback or method that registers a listener with the given callback implemented.
flowsensitivity is required for this analysis as a broadcast receiver may subscribe to receive multiple intents and multiple listeners of the same kind might be registered for an app.
for example an app may register two location listeners one listening to gps location updates and another one tracking location updates via network.
lifecycle transition these intra component transitions are between starting lifecycle callback nodes of a component e.g.
oncreate for activities or onstartcommand for services and every non lifecycle node with no incoming edge inside the component.
that is every callback or method inside a component with no incoming edge can be called after the component is started.
c obweb resolves lifecycle transitions after all other transitions are identified.
it ignores all other lifecycle callbacks that do not instantiate start a component e.g.
onpause orondestroy since these other lifecycle callbacks are considered using the lsm model discussed next.
b. lifecycle state machine lsm wakelocks and other resources such as gps are commonly acquired and released in lifecycle event handlers .
thereby proper implementation of lifecycle callbacks is important as developers need to ensure apps are not unnecessarily consuming power due to changes in the lifecycle state.
to that end we represent possible transitions among lifecycle states of an android component type as a finite state machine called lifecycle state machine lsm .
since the lifecycle callbacks are handled by the android framework itself we can define an lsm for each android component type regardless of which callbacks are actually implemented by instances of that component.
such a representation also ensures thorough testing of an app as developers may have failed to implement important lifecycle callbacks where resources should be managed properly.
1derivation of this list is discussed in section iv cwe derived three types of lsm models one for each of the android components types activities services and broadcast receivers based on the lifecycle callbacks identified for them in the android documentation.
figure shows lsms of the activity and service components for trackingactivity and internetservice respectively.
for example the activity lsm demonstrates four different lifecycle states for an activity component.
the activity lsm indicates how the execution of lifecycle callbacks results in transitions to different states.
c. hardware state machine hsm developers should adjust the functionality of apps according to the states of hardware elements.
for instance per android developer guidelines a location listener should be unregistered when user is stationary or the frequency of location update should be lowered when user is walking rather than driving.
to take such factors into account we need to look for changes in the hardware states from the inputs generated by the environment e.g.
change in the strength of network signal or the user directly or indirectly e.g.
user can turn on off location directly from setting or she can trigger changes in the state of gps by changing her location .
identifying different states of hardware elements for energy testing is crucial since apps consume different amounts of energy in different states .
we followed a systematic approach to derive generic and reusable models for each hardware element on a mobile device called hardware state machine hsm .
android provides libraries to access and utilize hardware elements.
these libraries provide apis and constant values i.e.
fields which can be used to inquire about possible states of hardware elements.
developers can use the apis implemented by such libraries to monitor the state of hardware elements e.g.
using locationmanager to track user location changes and connectivitymanager to query about the state of network connections or manipulate the states e.g.
hold a lock on the cpu using powermanager.wakelock apis to prevent the phone from going to sleep .
documentation of these apis is a rich source for identifying different hardware states.
similarly constant values introduced in such libraries can be used to identify hardware states as they usually are either representative of different states of hardware elements or the action field of broadcast intents that show a change in the state of hardware.
for example wifi mode full wifi mode full high perf andwifi mode scan only are constants associated with wifimanager library indicating that wifi hardware can operate in different modes each consuming battery of the device differently.
to find a thorough list of such libraries we started by automatically crawling android api reference using crawler4j to search for classes where description of their public methods or fields contained at least two of the following keywords location lock gps network connect radio cellular bluetooth display sensor cpu battery power consume drain charge discharge monitor hardware state and telephone.
we crawled 279pages in total and collected libraries after keyword filtering.
we further processed authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
genetic representation of tests the documentation of those libraries to find all the possible states of hardware elements as follows .
apis to automatically collect a set of apis that monitor state of the hardware elements we searched for event listeners and callbacks in the public methods of the collected libraries as they monitor the changes in the state of hardware elements.
from a total of apis in these classes we searched for apis that have the keyword listener in their signature for event listener apis and apis that start with on for callbacks.
this yielded 441listeners and callbacks.
to collect apis that manipulate state of hardware we searched for methods that have derivation of the following keywords in their description scan access acquire release state register disable enable connect and disconnect.
in the end we collected a total of apis correlated to different states of various hardware elements.
.
fields we automatically searched for the constant values identified for the collected libraries whose description contained one of the keywords we used for initial filtering.
this search left us with 225constant values.
once the states of each hardware element were identified using the aforementioned approach we constructed seven hsms for major hardware elements on mobile phones.
these hsms correspond to battery bluetooth cpu display gps radio and sensors e.g.
accelerometer and gyroscope.
hsm is a finite state machine that represents different states of a hardware element.
figure shows hsm models derived for network and location hardware elements in the details of internetservice andtrackingactivity components .
for network hsm for example from 46apis and12fields of two libraries connectivitymanager and wifimanager along with their nested classes we identified 9states for network namely disconnected connected with poor or full signal strength utilized under poor or full signal strength scanning and locked full multi cast and high performance .2edges between different states of the hardware can be traversed by calling one of the android apis inside the app or triggering events outside of it.3hence it is crucial to have a generic hsm for each hardware without considering just the source code of the app.
for example an application can start scanning for available wifi networks using startscan api or the state of hardware can be changed to scanning by manipulating the platform.
we have made the hsm models of other hardware elements publicly available .
2for a better illustration different locked states are merged in the hsm 3labels of edges are not shown here for sake of simplicityalgorithm evolutionary energy test generation input appapp set of lsm s set of hsm s list of energy greedy apis hw threshold breedsize output test suite te 1ctg cg staticanalysis app 2model mergemodels ctg cg hsm lsm 3p randompopulation app 4while improvement in fitness tr model threshold do poffspring select p breedsize poffspring converge model p offspring poffspring diverge model hw p offspring trtmp generate poffspring fitness trtmp model p merge p poffspring tr tr trtmp 12te minimize tr v. t estgenerator our objective is to generate tests that cover energygreedy apis and execute them under different contextual conditions.
in this section we describe the evolutionary search based test generation algorithm utilized in c obweb that aims to satisfy this objective.
a. genetic algorithm cobweb identifies the search space for energy testing problem as a set of system tests.
figure illustrates the genetic representation of a test suite generated by c obweb .
overall cobweb generates a set of system tests that corresponds to a population of chromosomes in the evolutionary algorithm.
at a finer granularity each chromosome consists of genes which are the main android components of an app and each gene contains multiple sub genes which are either input events or callback events recall section ii .
algorithm presents the evolutionary approach of c obweb for test generation.
it takes the app along with lsm and hsm models as inputs and generates a set of espresso tests te.
the algorithm starts by constructing the ctg and cg models through static analysis of the app line and integrating those with lsm and hsm models to arrive at the finalmodel of the app under test line .
next it randomly generates the initial population p which is later evolved using evolutionary search operators through multiple iterations lines .
once the new generation is available c obweb generates robolectric tests for each chromosome line executes them on jvm and calculates their corresponding fitness line .
at the end of iteration c obweb adds newly generated tests to the test suite and starts a new iteration.
this process continues until the termination condition is met if the improvement in the average fitness of generated tests in two consecutive iterations is less than a configurable threshold the algorithm terminates line .
afterwards algorithm minimizes the generated robolectric test suite and transforms them to espresso tests for execution on a mobile device line such that energy measurements can be collected.
for input fields c obweb follows an approach similar to sapienz and extracts statically defined values from the source code and layout files.
additionally developers can provide a list of inputs e.g.
list of cities for mytracker.
alternatively the input values can be provided to c obweb authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
intuition behind convergence and divergence operators through symbolic execution of the app using one of the many tools available for this purpose e.g.
.
b. genetic operators we now provide a more detailed explanation of the three genetic operators in algorithm .
selection operator cobweb implements a fitness proportionate selection strategy a.k.a.
roulette wheel selection for breeding the next generation.
that is the likelihood of selecting a chromosome is proportional to its fitness value.
the intuition behind this selection strategy is that tests that are closer to covering energy greedy apis or exercise them under previously unexplored contexts thus having a higher fitness value should have a higher chance of selection.
c obweb sorts chromosomes based on their fitness value and selects a subset of them denoted as poffspring for inclusion in the next generation.
the size of selected chromosomes is determined bybreedsize variable that is an input to the algorithm.
if f i is the fitness value for a chromosome iin the current population with size n the probability of this chromosome to be selected for breeding is computed as follows p i f i np j 1f j convergence operator the goal of convergence operator is to pull the population towards local optima i.e.
generate new chromosomes that largely inherit the genetic makeup of their parents.
the convergence operator only changes the execution context of tests.
that is from the parents identified by the selection operator poffspring it chooses those that have reached energy greedy apis then uses lsm and hsm models or mocking to create a new context for those tests.
the intuition behind this operator is shown in figure .
lsm and hsm models have finite states thereby their search space identified by dashed circle in figure is relatively small compared to the typical search space associated with the functional behavior of a program represented by ctg and cg models.
convergence operator denoted by the orange arrow in figure promotes exploration of the search space within close proximity of parent chromosomes thereby aids the algorithm to converge to local optima.
for each chromosome in poffspring cobweb randomly selects a gene to modify its context by inserting proper events in the chromosome event sequence.
to avoid bloated populations c obweb applies convergence operator if the gene has events associated with lifecycle callbacks or hardware related apis.
c obweb uses two types of convergence operator lifecycle context operator andhardware context operator .
lifecycle context operator to show the necessity of lifecycle context and usage of lsm for test generation consider the second energy defect for mytracker app described in fig.
evolved event sequences from illustrative example section ii.
recall that to effectively detect this bug a test needs to put the trackingactivity into the paused state to assess utilization of gps hardware in this state.
to generate such test lifecycle context operator determines current lifecycle state of the chromosome that utilizes gps in one of its genes and inserts the proper lifecycle callback event based on the next possible state determined from lsm.
consider sequence of figure to see how lifecycle context operator works.
the onlocationchanged event in trackingactivity gene indicates access to gps hardware.
cobweb realizes the lifecycle state of trackingactivity isrunning based on the last lifecycle callback in the event sequence.
the next eligible state for trackingactivity is paused based on lsm which can be reached by executingonpause lifecycle callback.
additionally since proper execution of a test requires the component to be in the running state c obweb needs to include a callback to restore the component to the running state to avoid generation of invalid tests.
thereby c obweb generates a new chromosome corresponding to sequence of figure .
the input argument ofonpause indicates that during the execution of this test trackingactivity remains in the paused state for 10seconds.
hardware context operator many energy defects manifest themselves under specific hardware settings making it important to test an app under different hardware states.
recall fail to check for connectivity energy defect in mytracker described in section ii.
to find this energy defect mytracker should be tested both when there is a network connection available and not.
for each chromosome in poffspring hardware context operator finds a gene that utilizes hardware if any determines the next hardware state based on the last explored state in hsm and inserts a specific hardware state sub gene right before the sub gene that is a callback or contains apis that utilize a hardware element.
for example consider a chromosome represented by sequence in figure .
the startdownload sub gene inside thedownloadservice gene makes an app connect to a server and download the map of ottawa.
if no prior hardware context operator is applied on downloadservice the state of network would be disconnected based on the network hsm presented in figure .
hence c obweb randomly chooses to transfer the state to either scanning utilized poor or utilized full .
supposing the next state is chosen to be utilized full cobweb changes this event sequence to sequence in figure .
unlike lifecycle context operator there is no need to restore the state of hardware.
that is if a test crashes by changing the hardware state developer has failed to properly handle that situation.
divergence operator in contrast to convergence operator the goal of divergence operator is to bring the population authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
out of local optima to discover potentially better solutions i.e.
find solutions that cover new energy greedy apis not previously covered by tests in the current population.
the intuition behind this operator is shown in figure .
unlike convergence operators that perform a neighborhood search divergence operator denoted by the dashed green arrow causes exploration of the whole new areas of the search space.
the goal of this operator is to explore new paths specifically paths that cover energy greedy apis.
to that end it combines two operations namely breakup andreconcile to breed a new chromosome.
for each chromosome in poffspring breakup operation breaks it into two set of genes passes the first set to reconcile operation and discards the seconds set.
note that the breakup point is selected randomly and could also be the end of the chromosome i.e.
the first set is the entire chromosome and the second set is empty.
at the next step reconcile operation creates a new individual from the broken chromosome.
starting from the last gene of the broken chromosome reconcile operation uses the ctg and cg models to generate a sequence of events that cover a path toward their leaf nodes.
the operator selects a path based on a priority value.
given the following path hcihe1 e pii c mhe1 e pmii its priority value is calculated as follows pri m mx j iapi j api j lx k 0wk where api jis a weighted sum of the number of energygreedy apis l that might be invoked during the execution of event sequences in component cj.
cobweb takes a list of38 energy greedy apis from our empirical study described in section iv c and counts the number of their invocations for each component using a conventional usedef static analysis.
since energy greediness of apis vary cobweb employs a weighted sum.
to obtain the weight of each energy greedy api c obweb relies on a prior study that has ranked energy greedy apis based on their energygreediness to compute wkin equation .
reconcile operation may need to change the sub genes of the last gene in the broken chromosome to reduce the likelihood of generating invalid tests.
for example consider sequence in figure where breakup operation divides it into hmainactivity mapsearchactivity i and hinternetservice downloadservice i sequences of components.
referring to the ctg of mytracker shown in figure reconcile chooses hgpsservice downloadservice ito create a new chromosomehmainactivity mapsearchactivity gpsservice downloadservice i. without changing the event sequences of mapsearchactivity the test corresponding to this new chromosome would fail as clicking on the find by internet button does not instantiate gpsservice .
thereby c obweb changes the genetic makeup ofmapsearchactivity and generates a new chromosome corresponding to sequence shown in figure .
c. fitness evaluation the fitness function rewards tests based on two criteria c1 how close they are to covering energy greedy apis and c2 how well they contribute to exercising different contextual factors.
the first criterion is measured using ctg and cg while the second criterion is measured using lsm and hsm.
cobweb calculates the fitness value in two steps.
first it computes the fitness of tiwith respect to each energy greedy apij.
then it averages those values to compute a single fitness value for test.
for each test ti cobweb computes the fitness value as follows f i n nx j 1fi j where nis the number of energy greedy apis on the path of tito a leaf in ctg and fi j is the fitness value of tiwith respect to energy greedy api j calculated as follows fi j apijis on the path to a leaf otherwise here c1i j determines the fitness of tiwith respect to fitness criteria c1.
it computes how close test tiis to cover energy greedy api j. it is calculated asx y where xis the number of edges in cg to the node that contains api j starting from the last node covered by ti and yis the total number of edges from root to the node that contains api j. the intuition behind this formulation is that a test may not cover energy greedy apis in the early iterations.
however if it comes close to covering energy greedy apis it is likely to be able to eventually cover those apis in future iterations.
thereby tests that exercise paths that contain more energygreedy apis or get close to covering such apis should have a higher priority to evolve.
if a test covers api j c1i j attains a value of .
c2i j corresponds to fitness criterion c2and determines how well tiexercises lifecycle and hardware state contexts c2i j bc1i j c here li j andhi j are indicators of how well tiexercises the lifecycles of a software component and different states of a hardware element that implements api j respectively.
cobweb computes li j andhi j values as follows if the test achieve prime path coverage z qotherwise where zis the length of path covered in lsm hsm and qis the length of the longest prime path for lsm hsm.
this formulation enables tests that exercise more states in lsm hsm models to have a higher fitness value.
since execution context matters only if an api is covered by a test equation has a coefficient bc1i j c such that it is when ti has not reached api j and otherwise.
unless c1i j equals to1 the value ofbc1i j c hence c2i j is0and the execution context does not matter in calculation of fitness.
finally note that coefficient1 3in formula is to ensure that the fitness value is between 0and1.
d. test suite minimization to minimize the size of test suite c obweb removes tests that are subset of others as they are unlikely to find new defects.
c obweb uses lowest common ancestor lca algorithm to find tests corresponding to overlapping paths in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the graph and removes the shortest tests from tr.
for two testst1 hc1 cmiandt2 hc1 cni if the lca between cmandcnis either of these nodes these tests are likely to be overlapping.
the algorithm then checks the events inside overlapping components and if they are the same it removes the shorter test and keeps the longer one.
in addition cobweb removes tests that fail to cover any energy greedy apis as such tests are unlikely to have a significant impact on energy.
finally the reduced test suite is transformed to espresso tests which can be executed on a mobile device.
vi.
e valuation we investigate the following five research questions in the evaluation of c obweb rq1.
api and execution context coverage how well do the generated tests cover energy greedy apis and exercise different lifecycle and hardware state contexts?
rq2.
effectiveness how effective are the generated tests in revealing energy defects in real world android apps?
rq3.
necessity of the models to what extent does using the lsm and hms models and considering the execution context aid c obweb to find energy defects?
rq4.
energy defects coverage what types of energy defects can be detected by c obweb and not other energy analysis tools?
rq5.
performance how long does it take to generate tests using c obweb ?
a. experimental setup alternative approaches for a thorough evaluation of cobweb we compare it with other testing tools as well as a variety of other energy analysis approaches targeting android.
we compare c obweb against monkey since it is arguably the most widely used automated testing tool for android and in practice it has shown to outperform other academic test generation tools .
we also compare against the most recent publicly available android testing tool stoat shown to be superior to prior testing tools.
stoat uses a combination of model based stochastic exploration of a gui model of an app and randomly injected system level events to maximize code coverage.
subject apps to evaluate effectiveness of c obweb we needed android apps with real energy defects.
to eliminate any bias toward selection of subject apps in favor of c obweb we looked at the dataset of 8related approaches presented in table ii and used two criteria in selecting apps.
first the energy defects identified by the approach should be confirmed by the developers of studied subject apps through a commit in the repository.
second information about the faulty version of an app or pointers to a commit fixing the issue should be publicly available.
these criteria are required to ensure the defects reported by those tools are in fact reproducible in our experimental setup and do not impose a threat to the validity of our results.
from the total of 035apps studied in related approaches only 25matched our inclusion criteria.
from those apps we were able to reproduce the faults in 18of them mostly because a subset of faults in those apps related to older versions of android and could not be reproduced in android .
that we used in our evaluation.
out of these 18apps we removed since soot was not able to generate complete call graphs for them.
table i shows information about our subjects with real energy defects.
fault reproduction to ensure the energy issues are reproducible we executed each defective subject app under the documented use case known to exhibit the defect.
we profiled the state of hardware elements during and after execution of the app using trepn .
trepn is a profiling tool developed byqualcomm that collects the exact power consumption data from sensors embedded in the chipset.
if the profiled data indicated over utilization of a hardware element during the execution of use case we marked the energy defect to be reproducible.
for example if the energy defect to reproduce is categorized as a location defect we monitored the state of gps to see if the gps hardware is released after the execution.
b. rq1 api and execution context coverage the objective of c obweb is to maximize the coverage of energy greedy apis under various execution contexts.
to evaluate the extent to which c obweb achieves this goal we measured api lsm and hsm coverage of test suites produced for our subjects.
similarly we calculated these metrics for monkey and stoat as an alternative testing approach.
we collected coverage information of the subjects using emma during test execution.
we ran stoat for 3hours similar to the configuration used by its authors .
monkey is shown to converge very close to its highest coverage at around 10minutes .
however we ran it for 1hour to ensure sufficient testing budget.
during 1hour it generates over100 000events per subject which is significantly higher than the events generated on average by c obweb in our experiments.
table i illustrates the result of this experiment under coverage column.
we observe that cobweb achieves a higher api coverage compared to alternative approaches.
cobweb achieves api coverage on average ranging from to96 with the median of89 .
in contrast monkey and stoat are able to cover on average and46 of energy greedy apis.
cobweb is more effective in exercising different execution contexts compared to monkey.
while c obweb achieves an average of in covering prime paths of lsms ranging from to100 with the median of monkey and stoat are able to cover only and40 lsm prime paths on average.
alternative approaches perform worse in terms of hsm coverage failing to cover even a single hsm prime path.
this is due to the fact that neither monkey nor stoat are capable of effectively manipulating hardware and systematically create system events during testing.
c. rq2 effectiveness we investigated the ability of c obweb monkey and stoat for finding the energy defects in the subject apps.
to that end we executed the generated tests on a google nexus device running android version .
.
during the execution of each test trepn was running in the background to profile the states of hardware elements during and after execution of each test.
we used the results of fault reproduction recall section vi a as our oracle.
similar to prior work if the energy traces obtained during the fault reproduction and test authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i subject apps and coverage information for c obweb and alternative approaches.
apps versioncoverage tests energy greedy apis lsm hsm detection o events l h o m s o m s o m s o l h m s a2dp.v ol8624c4f y y y n n b9a5768 n n n n n 8231d4d y y y n y 4767d64 y y n n n gtalkdce8b85 y y n n n c0f8fa2 y y y n y 5ce2d94 y n n n n openbmap56c3a67 y y n n n 14d166f y n y n n f72421f y y n n n opencamera .
y y y y y senoriume153fdf y n y n n 94c9a8d y n y n n 94c9a8d y n y n n ushahidi 4f20612 y y y y y o original c obweb l c obweb without lsm h c obweb without hsm m monkey s stoat execution matched we determined that the test suite was able to detect the corresponding fault.
column detection in table i demonstrates the result of this study.
these results show that random gui exploration and random system event injection proves to be highly ineffective.
monkey and stoat were able to detect only 2and4energy defects respectively.
the root cause of this weakness comes from their inability to cover energy greedy apis under different execution contexts.
in fact monkey and stoat were able to cover the code related to4and5energy defects respectively those marked with asterisk under detection column.
even when covered by these tools manifestation of those defects requires the apps to be executed under specific component lifecycle or hardware states.
cobweb is effective for detecting energy defects.
from the total of 15verified energy defects c obweb was able to detect where 10of them could be detected by exercising different component lifecycle states and 4of them could be revealed under specific hardware states.
c obweb was not able to find 1energy defect in a2dp.vol .
further investigation showed that manifestation of this energy defect requires complex interactions with the app.
in fact a2dp.vol requires a user to connect a bluetooth device to her phone change her location save her location in a database and disconnect the bluetooth device from her phone.
c obweb generated a test for each of these use cases but not a single test to reproduce the whole scenario as they cover different branches of ctg.
d. rq3 necessity of the models to evaluate necessity and usefulness of lsm and hsm models we first compared the size of test suites originally generated by c obweb that considers these models with that generated by a modified version of algorithm that exhaustively injects lifecycle or hardware related events into event sequences i.e.
changed the convergence operator.
in addition we compared the ability of test suites originally generated by c obweb in finding energy defects with that generated without using the models i.e.
we removed the consideration of execution context from the test generation process.
from the results presented in table i we can observe that contextual models make energy testing scalable.
without a model each component of app should be exhaustively tested under all possible lifecycle hardware states.
columns land hunder tests show the size of test suites generate by exhaustively injecting lifecycle hardware related events to explore all possible states.
we can see that by using lsm and hsm models c obweb is able to generate test suites that are 27and28times smaller respectively.
execution context is crucial for detecting energy defects.
columns land hunder detection illustrate the number of faults that can be detected by test suites not using either lsm or hsm models.
test suites generated without using lsm and hsm models can only detect 9energy defects thereby are inferior to those generated by c obweb in terms of their ability to find energy defects.
these results confirm our intuition about the importance of considering contextual conditions for energy testing.
e. rq4 energy defects coverage we evaluated c obweb s ability to find different types of energy defect by comparing it with the state of the art energy analysis approaches.
to that end we used a recently published energy defect model for android consisting of 28energy defect types categorized into seven groups namely bluetooth display location network recurring callback sensor and wakelock.
for approaches that are either not publicly available or do not work on newer versions of android we rely on the corresponding paper i.e.
description of the approach and limitations stated in the paper to determine if it is able to detect each type of defect.
table ii shows how these approaches differ in terms of their ability to find various types of energy defect.
we can see that cobweb is able to detect a wider range of energy defects compared to prior techniques .
furthermore it appears that dynamic analysis solutions such as c obweb and are able to detect a wider variety of energy defects compared to static analysis solutions.
f .
rq5 performance to answer this research question we evaluated the time required for c obweb to extract models as well as the time required for test generation and test minimization.
to evaluate test generation time we measured time from when the algorithm starts generating initial population to when it terminates the loop in algorithm at line .
we ran the experiments on a laptop with .
ghz intel core i7 processor and gb authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii comparing ability of energy analysis tools to find different types of energy defects.
defect model c obweb analysis type hybrid static hybrid static static static dynamic dynamic static lifecycle context y n n y n y y n n hardware context y n n n n n n n n bluetooth display location network recurring callback sensor wakelock total fig.
performance characteristics of c obweb ddr3 ram.
figure shows the performance characteristics of c obweb for each subject app results are averaged over various faulty versions of apps presented in table i .
from this data we can see that c obweb takes 23seconds on average to extract models 8minutes for test generation and execution including calculation of fitness value and 57seconds for test suite minimization.
these results corroborate scalability of cobweb for test generation making it a reasonably efficient testing tool for detecting energy issues.
vii.
r elated work we provide an overview of the related research on mobile testing and green software engineering.
mobile testing test input generation techniques for android apps mainly focus on either fuzzing to generate intents or exercising an android app through its gui .
several approaches generate intents with null payloads or by randomly generating payloads for intents .
dynodroid and monkey generate test inputs using random input values.
several techniques rely on a model of the gui usually constructed dynamically and non systematically leading to unexplored program states.
polariz uses information from crowd based testing to enhance mobile test generation.
another set of techniques employ systematic exploration of an app in the construction of test cases evodroid and sapienz employ an evolutionary algorithm acteve jpf android collider and sig droid utilize symbolic execution.
another group of techniques focus on testing for specific defects .
none of the aforementioned solutions can be used to properly test the energy behavior of android apps as they lack the ability to generate tests meant to exercise contextual factors.
green software engineering in recent years several automated approaches for analysis testing re factoring and repair of mobile apps have been proposed to help developers produce more energy efficient apps.
the closest approaches to c obweb are that of banerjee et al.
greendroid and energypatch .
banerjee etal.
present a search based profiling strategy with the goal of identifying energy defects in an app.
they construct a graph representing an app s gui events extract the event traces using the incomplete generated graph and explore event traces that may possibly reach energy hotspots while profiling energy consumption of the device.
the profiling process always starts from the root activity of an app making it infeasible to test particular sequences of the app s lifecycle.
finally the usage of a power measurement hardware makes their approach device dependent and impractical.
energypatch fixes the scalability issue of the prior work by using abstract interpretation based program analysis to detect resource leaks instead of power trace oracle.
similar to the prior work they rely on a dynamically constructed model for gui events to guide the search for finding paths leading to a resource leak.
greendroid uses only bounded symbolic execution for finding event sequences that lead to resource leaks.
none of these techniques consider system inputs that are independent of gui nor do they incorporate lifecycle and hardware contextual factors in the generation of tests.
they also do not generate reproducible tests.
more importantly they generate tests specifically targeted for resource leaks failing to detect wide range of other energy defects shown in table ii.
viii.
c onclusion and future work energy efficiency is an important quality attribute for mobile apps.
naturally prior to releasing apps developers need to test them for energy defects.
yet there is a lack of practical tools and techniques for energy testing.
in this paper we presented cobweb a search based energy testing framework for android.
the approach employs a set of novel models to take execution context into account i.e.
lifecycle and hardware state context in the generation of tests that can effectively find energy defects.
additionally c obweb implements novel genetic operators tailored to the generation of energy tests.
our experience with c obweb on android apps with real energy defects corroborate its ability to effectively generate useful tests to find energy defects in a scalable fashion.
currently we are considering several directions for future work.
first test generation is not complete without accounting for the test oracle.
we are planning to explore automated methods of generating energy test oracles in future.
we also plan to extend the approach for multi objective test generation making c obweb a more general android testing tool.
cobweb and research artifacts are available publicly .
ix.
a cknowledgment this work was supported in part by awards ccf cns ccf cns from the national science foundation and a google phd fellowship.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.