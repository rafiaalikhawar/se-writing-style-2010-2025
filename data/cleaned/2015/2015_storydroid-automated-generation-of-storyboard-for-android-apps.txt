storydroid automated generation of storyboard for android apps sen chen lingling fan chunyang chen ting su wenhe li yang liu lihua xu east china normal university china monash university australia nanyang technological university singapore new y ork university shanghai china ecnuchensen gmail.com abstract mobile apps are now ubiquitous.
before developing a new app the development team usually endeavors painstaking efforts to review many existing apps with similar purposes.
the review process is crucial in the sense that it reduces market risks and provides inspiration for app development.
however manual exploration of hundreds of existing apps by different roles e.g.
product manager ui ux designer developer in a development team can be ineffective.
for example it is difficult to completely explore all the functionalities of the app in a short period of time.
inspired by the conception of storyboard in movie production we propose a system storydroid to automatically generate the storyboard for android apps and assist different roles to review apps efficiently.
specifically storydroid extracts the activity transition graph and leverages static analysis techniques to render ui pages to visualize the storyboard with the rendered pages.
the mapping relations between ui pages and the corresponding implementation code e.g.
layout code activity code and method hierarchy are also provided to users.
our comprehensive experiments unveil that storydroid is effective and indeed useful to assist app development.
the outputs of storydroid enable several potential applications such as the recommendation of ui design and layout code.
index t erms android app storyboard competitive analysis app review i. i ntroduction mobile apps now have become the most popular way of accessing the internet as well as performing daily tasks e.g.
reading shopping banking and chatting .
different from traditional desktop applications mobile apps are typically developed under the time to market pressure and facing fierce competitions over .
million android apps and million iphone apps are striving to gain users on google play and apple app store the two primary mobile app markets .
therefore for app developers and companies it is crucial to perform extensive competitive analysis over existing apps with similar purposes .
this analysis helps understand the competitors strengths and weaknesses and reduces market risks before development.
specifically it identifies common app features design choices and potential customers.
moreover researching similar apps also helps developers gain more insight on the actual implementation given that delivering commercial apps can be time consuming and expensive .
typically to achieve the aforementioned analysis a freelance developer or a product manager pm in a tech company has to download the apps from markets install them on mobile devices and use them back and forth to identifyatg with ui pages login password recovery registration help main profilefriend view connection method hierarchyactivity codelayout code fig.
the storyboard diagram of an android app what she is interested in .
however such manual exploration can be painstaking and ineffective.
for example if a tech company plans to develop a social media app similar apps on google play will be under review.
it is overwhelming to manually analyze them register accounts feed specific inputs if required and record necessary information e.g.
what are the main features how are the app pages connected .
additionally commercial apps can be too complex to manually uncover all functionalities in a reasonable time .
for ui ux designers the same exploration problem still remains when they want to get inspiration from similar apps design.
in addition the large number of user interface ui screens within the app also makes it difficult for designers to understand the relation and navigation between pages.
for developers who want to get inspiration from similar apps it is difficult to link the ui screens with the corresponding implementation code the code can be separated in static layout files as well as a large piece of functional code.
inspired by the conception of storyboard1in movie industry we intend to generate the storyboard of an app to visualize its key app behaviors.
specifically we use activities i.e.
ui screens to characterize the scenes in the storyboard since activities represent the intuitive impression of the apps in a full screen window and are the most frequently used components for user interactions .
fig.
shows the storyboard diagram of facebook one of most popular social media apps storyboard was developed at walt disney productions including a sequence of drawings typically with some directions and dialogues representing the shots planned for a movie or television production.
ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
which includes the activity transition graph a tg with ui pages the detailed layout code e.g.
static and dynamic the functional code of each activity activity code and method call relations within each activity method hierarchy .
based on this storyboard pms can review a number of apps in a short period of time and propose more competitive features in their own app.2ui designers can obtain the most related ui pages for reference.
and developers can directly refer to the related code to improve development efficiency.
however generating the storyboard is challenging.
first a tgs are usually incomplete due to the limitation of static analysis tools .
second to identify all ui pages a pure static approach may miss parts of uis that are dynamically rendered see section iii whereas a pure dynamic approach may not be able to reach all pages in the app especially those requiring login.
third the obfuscated activity names lack the semantics of corresponding functionalities making the storyboard hard to understand.
to overcome these challenges we propose a system storydroid to automatically generate the storyboard of apps in three main phases activity transition extraction which extracts a tg from the apks especially the transitions in fragments components of activities and inner classes making a tg more complete.
ui page rendering which first extracts the dynamic components if any for each ui page and embeds them into the corresponding static layout.
it then renders each ui page statically based on the static layout files.
semantic name inferring which infers the semantic names for the obfuscated activity names by comparing the layout hierarchy with the ones in our database which is constructed from open source apps.
through these analyses story droid provides a systematic solution for exploring and understanding an app from different points of view.
we evaluate story droid on apps open source and closed source apps from the following two aspects effectiveness evaluation of each phase usefulness evaluation of the visualization outputs.
the experimental results show the effectiveness of story droid in extracting activity transitions especially in fragments and inner classes.
story droid extracts nearly times more activity transitions than the stateof the art a tg extraction tool i.e.
ic3 on both opensource apps and closed source apps.
besides story droid significantly outperforms the state of the art dynamic testing tool i.e.
stoat on activity coverage for both opensource apps on average and closed source apps on average .
on average our rendered images achieve similarity compared with the ones that are dynamically obtained by stoat .
and story droid can infer the semantic names at a high accuracy .
in addition the user study shows that with the help of story droid the activity coverage has a significant improvement compared with exploration without story droid and users can find the layout code for the given ui pages more accurately and efficiently.
apart from 2the main target is to help pms developers designers understand and get inspiration from existing apps instead of directly distributing any part of the code for developing apps for commercial purpose.the fundamental usefulness we also discuss several additional practical applications based on the outputs of story droid such as the recommendation of ui design and layout code and guiding app regression testing.
in summary we make the following contributions this is the first research work to automatically generate the storyboard of android apps.
it assists app development teams including pms designers and developers to quickly have a clear overview of other similar apps.
we propose a novel algorithm to extract relatively complete a tg render ui pages statically and infer activity names for obfuscated apps.
these technical contributions are general for both open source and close source android apps.
our experiments demonstrate not only the accuracy of the generated storyboard but also the usefulness of our storyboard for assisting app development.
this is a fundamental work to enable the construction of a large scale database of app storyboards as the overall approach is based on static program analysis.
such a database can expand the horizon of current mobile app research by enabling lots of future work such as extracting commonalities across apps recommending ui code design and guiding app testing.
ii.
m otiv a ting scenario we detail the typical app review process with our story droid for android apps in term of different roles in the development team.
eve is a pm of an it company.
her team plans to develop an android social app.
in order to improve the competitiveness of the designed app she searches hundreds of similar apps e.g.
facebook instagram twitter based on the input keywords e.g.
social chat from google play store.
she then inputs all of the urls of these apps into story droid which automatically download all of these apps with google play api .
story droid further generates the storyboard e.g.
fig of all these apps and displays them to eve for an overview.
by observing these storyboards together she easily understands the storyline of these apps and spots the common features among these apps such as registering searching setting user profile posting etc.
based on these common features eve comes up with some unique features which can distinguish their own app from existing ones.
alice as a ui ux designer needs to design the ui pages according to eve s requirements.
with our story droid she can easily get not only a clear overview of the ui design style of related apps but also interaction relations among different screens within the app.
then alice can develop the ui and user interaction of her app inspired by others apps .
bob is an android developer who needs to develop the corresponding app based on alice s ui design.
based on alice s referred ui design in the existing app he can also refer to that app with the help of our story droid .
by clicking the ui screen of each activity in the storyboard story droid returns the corresponding ui implementation code no matter it is implemented with pure static code dynamic code or hybrid ones.
to implement their own ui design he can refer to the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
.
!
!
fig.
three types of gui layout implemented code and customize it based on their requirement.
that development process is much faster than starting from scratch.
in addition bob may also be interested in certain functionality within a certain app.
by using story droid h e easily locates the logic code.
iii.
p reliminaries in this section we briefly introduce the concepts of android ui layout types of ui and special views for populating data.
a. android activity and fragment there are four types of components in android apps i.e.
activity service broadcast receiver .
specifically activity and fragment render the user interface and are the visible parts of android apps.
activity is a fundamental component for drawing the screens which users can interact with.
fragment represents a portion of uis in the activities which contributes their own ui to certain activities.
fragment always depends on an activity and cannot exist independently.
a fragment can also be reused in multiple activities and an activity may contain multiple fragments based on the screen size with which we can create multi panel uis to adapt to mobile devices with different screen sizes.
b. ui layout a user interface rendered by activity andfragment requires a ui layout to draw a window for users.
we take a high level look at three layout types in android apps.
fig.
shows the login ui page of a famous social app twitter where the component e.g.
textview can be implemented in three different layout types.
static layout which relies on the static layout files i.e.
xml in the apk.
the ui pages of the app are rendered by these xml files.
viewgroup andview are the basic elements of user interfaces in ui layout files.
viewgroup is a container which holds other viewgroups andviews .
the gui code must contain a root node with viewgroup e.g.
relativelayout andlinearlayout .
when the viewgroup is defined developers can add additional view s e.g.
edittext textview as children elements to gradually build a hierarchy that defines the page layout.
gui components contain multiply attributes e.g.
id text width as shown in fig.
lines .
dynamic layout which allows developers to instantiate layout components at runtime using android api i.e.
addview .
public class partlist extends activity listview lv listview findviewbyid r. id .
l i s t arrayadapter adapter new arrayadapter this r. layout .
list view data lv .
setadapter adapter ... fig.
simplified code snippet of adapter start activity start fragment start activitymain prefeditor prefeditor fragmentadvanced prefeditorsearchpanel searchby partname partliststart activit yuse inner class a transitions with fragme n t b transitions with inner cla ss fig.
transitions between activities and fragment inner class developers can create components and manipulate their attributes in java code e.g.
t extview.sett ext password in java code is equivalent to android text password in layout file as shown in fig.
lines .
hybrid layout which defines some default components in static layout files.
these layout can be reused dynamically by invoking layoutinflater.inflate as shown in figure lines .
developers can also manipulate the attributes of the defined components.
for example they can modify the content of textview in java code.
to investigate the proportion of dynamic and hybrid layout used in android apps we randomly select apps from the top google play apps with the most number of downloads.
we use the specific android apis i.e.
addview and inflate to distinguish if the app contains dynamic hybrid layout types to draw the ui pages.
the result of our study unveils that .
apps use dynamic hybrid layout.
the reason for such frequent usage of dynamic hybrid layout is that with the help of them the views are separated from the view model in the xml file developers can change the layout without recompiling to adapt to the app s runtime state.
c. data population adapter is a bridge between the adapterview and the underlying data for the view.
it also provides the layout e.g.
listview gridview viewpager with the data which is usually loaded from a local database or remote server.
adapter enables these ui components e.g.
listview t o provide a list of scrollable items for the selection purpose.
fig.
shows an example of adapter .
it instantiates an adapter with a layout listview and associates it with data .
the data is then displayed in a listview via adapter.
the adapterview is part of the user interface layout and should be extracted from the source code for static rendering.
iv .
o urapproach story droid takes an apk as input and outputs the visualized storyboard s for the app.
fig.
shows the three main phases of story droid transition extraction which enhances the a tg extraction ability of ic3 especially for fragments and inner classes.
story droid leverages control598 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
transition extraction layout type checkinglayout type translatingui page rendering atg semantic name inferringatg with ui pages login password recovery registration help main profilefriend view connection method hierarchyactivity codelayout code g fig.
architecture of story droid public class prefeditor ... using replace add prefeditorfragment pref new prefeditorfragment fragmenttransaction .
replace r. id .
content pref fragmenttransaction .
c ommit public class prefeditor ... using setadapter viewpager .
setadapter getsupfragmentmanager new prefeditorfragment fig.
simplified code snippet of fragment public class searchpanel ... private class searchbypartname extends asynctack ... intent inte nt new intent mainactivity .
this partlist .class startactivity intent fig.
simplified code snippet of inner class and data flow analysis to obtain relatively complete a tg.
ui page rendering which translates dynamic and hybrid layout to static layout if needed to render ui pages that users interact with.
semantic name inferring which infers the semantic name for the obfuscated activity names by layout comparison.
a. transition extraction before extracting activity transitions in inner classes and fragments we illustrate the transitions in them.
fig.
a is the sub a tg of vespucci a map editor.
firstly activity main starts prefeditor in which prefeditorfragment is started.
and prefeditorfragment further starts advancedprefeditor .
specifically as shown in fig.
fragments can be added to an activity in two ways by invoking fragment modification api calls e.g.
replace add and further leveraging fragmenttransation.commit lines to start the fragment by using setadapter line to display the fragment in a certain view e.g.
viewpager .
the started prefeditorfragment then starts a new activity i.e.
advancedprefeditor .
fig.
b shows the sub a tg of adsdroid where searchpanel uses an inner class searchbypartname to handle time consuming operations as shown in fig.
.
after finishing the task it starts an activity partlist by invoking startactivity line .
in this example our goal is to extract activity transitions main preeditor preeditor advancedpreeditor and searchpanel partlist .
algorithm details the extraction of a tg and resources for rendering including the layout type i.e.
static dynamic or hybrid and the adapter mapping relations.
specifically it takes as input an apk and outputs the activity transition graph atg adapter mappings adapters and layout type layout type .
we first initialize atg as an empty set line which stores the activity transitions gradually.
we then generate the call graph cg of the given apk obtain the layout type by analyzing the existence of dynamic layout loadingalgorithm a tg and rendering source extraction input apk output atg activity transition graph adapters adapter mappings layout type i.e.
static dynamic or hybrid 1atg adapters 2cg getcallgraph apk 3layout type getlayouttype apk 4allclasses getallclasses apk 5foreach c allclasses do methods getclassmethods c foreach m methods do ifhasactivitytransition m then callee act gettargetact m ifisinnerclass c then caller act outerclass c atg.addpair caller act callee act else if isinfragment m then atg.addpair caller frag callee act else caller acts getcalleract m cg foreach act caller act do atg.addpair act callee act get rendering sources and optimize atg ifstartfragment m then caller acts getcalleract caller frag foreach act caller acts do atg.addpair act callee frag updatea tgifneeded atg get rendering sources ifhasadapter m then e.g.
listview recyclerview viewpager view type getviewtype m layout file backwardanalysis m adapters .add c view type layout file 28return atg adapters layout type apis lines .
for each method m in each class c if there exists an activity transition we first get the target activity callee act by analyzing the data in intent lines .
if the method m is in an inner class we regard the outer class as the activity that starts the target activity and add the transition to atg lines .
take fig.
b as an example we add an edge searchpanel partlist toatg.
ifmis in a fragment we construct the relation between the fragment caller frag and the target activity lines .
note that this relation does not represent the actual activity transition we optimize it by identifying the activities that start the fragment in lines .
this relation is used for both a tg construction and ui page rendering.
after that we update atg by merging fragment relations to construct the actual activity transitions line .
for example in fig.
a we first obtain the relations prefeditorfragment advancedpreeditor authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
prefeditor prefeditorfragment then we merge it to prefeditor advancedpreeditor to represent the actual activity transition.
for method mthat is neither in an inner class nor a fragment we backward traverse cgstarting from mto obtain all the activities that start the target activity callee act then add them to atg lines .
in addition to complement the ui layout that need to load data from data providers e.g.
contentprovider preference using different types of views e.g.
listview recyclerview viewpager we first identify the method that uses adapter and obtain the correponding view type view type lines .
we then utilize backward dataflow analysis on the adapters to track the corresponding layout files which pinpoints the layout activity that will be embedded with data displayed in view type .
we define each mapping relation as a tuple angbracketleftactivity view type layout angbracketrightand save them inadatpers for ui rendering.
take fig.
as an example we denote the relation as angbracketleftpartlist listview list view angbracketright.
b. ui page rendering we propose to statically render the ui pages due to the limitation of data dependence between different activities when using dynamic tools for ui page rendering e.g.
require login or special input to reach another activity .
the activities we rendered are the initial state of each activity.
as for apps that only use static layout to display ui pages we can directly extract the corresponding layout file for rendering.
however as for dynamic hybrid layout we need to resolve two challenges converting dynamic hybrid layout to static layout since we cannot render the corresponding ui pages accurately with incomplete layout filling the dynamic data loading area with dummy data i.e text image since we cannot render the corresponding components that load dynamic data from remote server which involves backend code.
to tackle these problems we first statically analyze the activity source code and identify the logic that is relevant to layout population including adding new views and modifying the parameters of views.
we then convert the dynamic layouts in the target app to static layouts.
moreover as our approach is based on static analysis we cannot obtain the real image which is loaded dynamically such as listview andgridview .
instead of keeping that position plain we fill in that position with dummy images so that users can directly discriminate it from the plain background.
otherwise the image position may be preempted by other components of the same page.
we associate the dummy data with the identified adapters in algorithm to display data in different styles.
with the translated static layouts and dummy dynamic data we compile them into an apk to render ui pages.
algorithm details the ui page rendering process.
it takes as input the activity transition graph atg adapter mapping relations adapter layout type layout type and outputs the rendered ui pages.
we first extract all the activities and fragments from atg since we need to render both activity uis and fragment uis to make it closer to the real uis.
for each activity fragment act ifact uses the static layout we directlyalgorithm ui page rendering input atg the transitions that contain activities and fragments adapters layout type output pages ui pages 1act frag getactivityandfragment atg 2foreach act act frag do layout copy act.xml iflayout type negationslash static then par layout getparentlayout act methods getallmethods act foreach m methods do ifm negationslash oncreate then continue compt attr dataflowanalysis m par layout .add compt add corresponding attributes ifismethod attr then compt .add dataflowanalysis attr else element getelementbyname attr compt .add element break act layout .add par layout savelayout act layout 20foreach adapter adapters do activity match activity adapter modify layoutf ile activity adapter.type 23apk bulidapk act frag 24pages getscreenshot apk 25return pages make a copy of the corresponding layout file for further rendering or modification line .
however if the app uses dynamic hybrid layout we aim to add the dynamic components together with their attributions to the corresponding parent layout.
specifically we first extract and pinpoint the parent layout e.g.
linearlayout line .
we then traverse each method m to identify the dynamic component compt e.g.
edittext textview and the corresponding attributes attr e.g.
text height width by keywords matching i.e.
inflate andaddview and forward analyzing the data flow of viewrelated variables in oncreate .
we then add compt to the corresponding parent layout lines .
as for the attribute if it is obtained by invoking another method we leverage dataflow analysis to reach the definition of the attribution and attach it to the corresponding component lines .
otherwise we identify the corresponding element in the resource files by the attribute name via getelementbyname and also attach it to compt lines .
after the modification to the parent layout of the dynamic components we attach the new par layout toactlayout and save it as layout format for further rendering lines .
take fig.
as an example our method is able to translate the dynamic hybrid layouts to static layouts i.e.
xml format .
in addition as for data display using adapters we match each adapter to the activity and modify the corresponding layout by embedding the view types e.g.
listview recyclerview lines as well as dummy data.
we finally get a view tree and ensure the corresponding attributes are added from the source code.
at last we build an apk to render all the activities and fragments and take screenshots authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
layout tree db ranking matchingsemantic act.
namexml namedb construction xml filelayout treelarge scale xml files a semantic name inferringlayout tree scrollview textview linearlayout buttontextview linearlayout editviewtextview b an example of layout tree fig.
workflow of semantic name inferring for each ui lines in a real app.
c. semantic name inferring in android app development activity names of apps are recommended to contain semantic meanings and end with activity thus we assume that the defined activity names by developers have basic semantic meanings of the corresponding functionality.
to verify this assumption we randomly download apps from f droid extract all the activity names from each app and finally get activity names.
we manually investigate the activity names and observe that most of activity names have semantic meanings.
however android obfuscation techniques are often used in google play apps to protect their security .
the activity names will be translated to simple words like a b and c totally losing their practical semantic meanings.
those obfuscated names significantly hinder users understanding of our storyboard.
to tackle this problem we propose to automatically infer the semantic names for obfuscated activities by comparing the layout hierarchy i.e.
viewgroup andview with those of the existing activities since activity layout files are not obfuscated in apps.
in this paper we consider the activity names whose length is less than three letters as obfuscated ones.
to infer the semantic names for obfuscated activities we aim to learn from the activity names of open source apps.
to achieve this as shown in fig.
a we crawl all the apps on f droid in total and build a large database based on the layout hierarchies of the apps for similarity comparing.
a layout hierarchy is a layout tree i.e.
fig.
b based on the xml layout code.
the root node of the tree is a type of viewgroup and the other viewgroup s and types of view s are the child nodes added to the root node.
we finally get activities with their layout hierarchies.
given the xml file layout file and xml name of the obfuscated activity we infer its semantic name by the following three steps layout hierarchy extraction which extracts the layout tree t from the xml file similarity comparison which computes the similarity between tand the trees in our database by leveraging the tree edit distance ted algorithm which is defined as the minimum cost sequence of node edit operations that transform one tree into another.
according to a pilot study of randomly selected tree pairs we define a threshold in ted as and filter the activity names whose ted are less than as candidates.
ranking and matching which infers the activity name from the candidates based on the frequency of each activity name and the corresponding layout names xml file names .
specifically we rank the activity names based on their frequency split the camel case layout nameinto multiple single words with the regular expression filter out the general words such as activity layout and compare it with those in the database by keyword matching.
the most matched activity name will be used to rename the obfuscated activity name.
however if the layout name is not matched with any names of the candidates we rename it with the top frequent name.
note that although the layout names are not obfuscated it is ineffective if we only use them to infer the semantic names since activities using dynamic layouts have no static layouts thus have no layout names.
v. i mplementa tion we implement story droid as an automated tool which is written in 3k lines of java code and 2k lines of python code.
story droid is built on top of several off the shelf tools ic3 jadx and soot .
we use soot to extract inputs of ui page rendering and get the call graphs from apks.
activity transition extraction is built on ic3 to obtain a comparatively complete a tg.
jadx is used to decompile the apk to the source code for android apps.
we also use jadx to extract xml layout code from each apk which will not be affected by obfuscation thus will not affect the semantic name inferring method.
we use data driven document d3 to visualize story droid s results which provides a visualized technique based on data in html javascript and css .
the visualization contains parts a tg with activity names and corresponding ui pages the layout code of each ui page the functional code of each activity and the method call relations within each activity.
vi.
e ffectiveness ev alua tion in this section we evaluate the effectiveness of story droid based on the following three research questions rq1 can story droid extract a more complete a tg for an app and achieve better activity coverage than the dynamic testing tool i.e.
s toat ?
rq2 can story droid render ui pages with high similarity compared with the real screenshots?
rq3 can story droid infer accurate semantic names for obfuscated activities?
a. experimental setup to investigate the capability of handling fragments and inner classes we self developed apps3as our groundtruth benchmark which cover different features i.e.
activity fragment and inner class we claim to resolve.
this is the only way to exactly know all the transitions even in fragments or inner classes and this way is widely used in the literature .
we follow the features below to generate the apps apps with transitions only in activities apps with transitions only in inner classes apps with transitions only in fragments apps with transitions in both activities and inner classes apps with transitions in both activities and fragments we developed apps with activities under each rule.
we apply both ic3 and story droid on the apps and extract 3the apps are available on .google .com view storydroid authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i capability of handling fragments and inner classes.
ic3 cannot handle app id feature transition pairs identified by ic3 identified by story 1activity14 3inner class13 5fragment13 activity inner class13 activity fragment10 the transition pairs respectively.
moreover since the stakeholders are more concerned about popular competitive apps which have already dominated the market.
to mimic the real scenario we randomly download apps from googleplay store with 10m installations to demonstrate the effectiveness ofstory droid on real world apps.
we compare the number of transition pairs identified by ic3 and story droid .w e also use these apps to evaluate the activity coverage ofstory droid and the state of the art dynamic testing tool stoat which has been demonstrated to be more effective on app exploration than other tools such as monkey and sapienz .
specifically we collect all the activities defined in each app from androidmanifest.xml and compare the number of the rendered activities by story droid and the explored activities by s toat .
for rq2 we evaluate the similarity of our statically rendered ui pages with the real ui which are dynamically rendered ui by stoat based on the apps .
stoat is configured with default settings and given minutes to test each app in order to collect the explored activities.
we further apply stoat on each app to collect the screenshots of each activity.
since stoat may only explore part of the activities of an app within the given time we only compare the similarity of the explored activities with the corresponding rendered activities by story droid for a fair comparison.
for rq3 to demonstrate the accuracy of inferring semantic names we randomly select activity names with semantic meanings from the extracted activity names in section iv c as the ground truth.
we collect the corresponding layout files from source files and further utilize our method based on ted to obtain the semantic names for the activities based on our collection of layout trees i.e.
layout files .
we then compare the results with the original activity names to evaluate the accuracy of our approach i.e.
the proportion of semantic names that are correctly inferred.
b. experimental results rq1 table i shows the results of the capability evaluation of handling fragments and inner classes on the ground truth benchmark apps.
we can see that ic3 is able to extract transitions in activities however is weak in fragments and inner classes.
in contrast storydroid can extract transitions with respect to all these features.
since we extract transitions by using particular apis i.e.
startactivity startactivityforreulst a comparison with ic3f droid f droid f droid f droid f droid f droid f droid b comparison with s toat fig.
comparison of transitions pairs and activity coverage strartactivityifneeded that start new activities with data flow analysis the extracted transitions are more accurate.
the results demonstrate the effectiveness of story droid on extracting activity transitions especially in fragments and inner classes.
moreover we also evaluate the effectiveness of story droid on real apps compared with ic3 in fig a .
it shows that story droid extracts nearly times more activity transitions and is more effective than ic3 for both open source apps and closed source apps.
besides the limitations of inner classes and fragments transitions in android system event callbacks are lost in ic3 according to our observation.
for example podlisten is a podcast player and there exists an activity transition in the callback method downloadreceiver.onreceive which is called when the broadcastreceiver is receiving an intent broadcast.
however ic3 fails to extract the activity transition.
csipsimple is an online voice communication app in which the system callback method sipservice.adjustvolume starts a new activity but ic3 fails to identify the transition.
fig.
b depicts the activity coverage results.
on average story droid outperforms stoat in terms of activity coverage achieving and coverage on open source apps and closed source apps respectively.
in addition story droid costs much less time i.e.
within minutes on average to extract and render the activities than stoat i.e.
minutes .
story droid does not cover all the activities for some apps due to the following reasons the limitation of reverse engineering techniques some classes and methods cannot be decompiled from the apks causing failure in the extraction of activity transition and coverage.
that situation is more severe in closed source apps due to packing and obfuscation.
in our evaluated apps podlisten is the only project in which activity coverage of story droid is lower than that of stoat due to decompiling failure of subscribedialog fragment.
another reason is the dead activities no transitions such as unused legacy code and testing code in apps.
we further investigate the reasons why stoat achieves low activity coverage login requirement.
for example stoat fails to explore santander which is a banking app requiring login using password or fingerprint.
lack of specific events.
for example open training is a fitness training app which can create fitness plans by swiping across the screen.
however stoat does not support such events resulting low coverage.
rq2 as for the similarity of the rendered images compared with the ones obtained by stoat we use two widely used image similarity metrics i.e.
mean absolute authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a real page b our rendered c real page d our rendered fig.
comparison of real pages and rendered pages table ii partial results of inferring semantic name for obfuscated activities groundtruth act.
namerank in candidatescorresponding xml nameinferred by storydroid aboutact.
about aboutact.
helpact.
activity help helpact.
personalinfoact.
content extended title wizardact.
loginact.
login loginact.
contactlistact.
contact list contactlistact.
searchact.
grid base searcher settingact.
setting container settingact.
shareact.
activity share shareact.
splashact.
activity splash splashact.
tracklistact.
list view tracklistact.
error mae and mean squared error mse to measure the similarity pixel by pixel.
mae measures the average magnitude of differences between the prediction and the actual value and mse measures the average squared differences between them.
on average our rendered images achieve and similarity in terms of mae and mse respectively.
the reasons for the inconsistencies are explained as follows.
some data in components are dynamically loaded from web servers or local storage e.g.
preference and sd card such as the list data of listview the text data of textview and the image background of imageview .
the differences are depicted in fig.
a b .
some components e.g.
button will change their color or visibility after users type some data.
for example as shown in fig.
c the color of the button changes when users input the nickname .
story droid renders the initial state of the activity thus reducing the similarity of the two ui pages which however does not affect the understanding of the app functionality.
rq3 out of activity names are inferred correctly based on our approach and the accuracy is .
to demonstrate and explain the inferring results we randomly select cases listed in table ii.
the first column refers to the groundtruth activity names.
according to the results of comparison with layout trees in our database we list the ranks of correct activity names based on the frequency of each name in the second column.
the third column is the corresponding xml layout names.
story droid accurately infers out of the semantic names which are consistent with the ground truth.
fortracklistact.
personalinfoact.
andsearchact.
highlighted in gray color in table ii the layout names cannot be matched with any name of the candidates so we choose the name at rank one as the semantic name.
two of them do not match the ground truth.
but note that the performance of our approach is highly underestimated as although some ofthe recommended names from our story droid differ from the ground truth they actually have similar meanings such as searchact.
andsearcher .
in addition with the expansion of our database the accuracy will be also boosted.
overall the results show that story droid can help infer the semantic names of obfuscated activities effectively.
remark story droid outperforms ic3 on a tg extraction and covers times more activities than stoat with less time.
story droid can render ui pages with high similarity to the real ones and accurately infer the semantic names for obfuscated activity names.
vii.
u sefulness ev alua tion apart from effectiveness evaluations we further conduct a user study to demonstrate the usefulness of story droid .
our goals are to check whether story droid can help explore and understand the functionalities of apps effectively?
whether story droid can help identify the layout code of the given ui page accurately and effectively?
dataset of user study.
we randomly select apps i.e.
bitcoin bankdroid connectbot vespucci with different number of activities activities from categories i.e.
finance tool which are hosted on google play store.
each category contains two apps and we ask participants to explore each app to finish the assigned tasks.
participant recruitment.
we recruit people including postdoc ph.d and master from our university to participate in the experiment via word of mouth.
all of the recruited participants have used android devices for more than one year and participated in android related research topics.
they never use these apps before.
all of them have android app development experience and come from different countries such as usa china european countries e.g.
spain and singapore.
the participants receive a shopping coupon as a compensation of their time.
experiment procedures.
we installed the apps on an android device nexus with android .
.
the experiment started with a brief introduction to the tasks.
we explained and went through all the features we want them to use within the apps and asked each participant to explore the apps separately to finish the tasks below.
note that for each category each participant explored one app with story droid and the other without story droid .
to avoid potential bias the order of app category and the order of using story droid or not using are rotated based on the latin square .
this setup ensures that each app is explored by multiple participants with different development experience.
we told each participant to complete two tasks with the given apps manually explore as many functionalities of the apps as possible in minutes which is far longer than the typical average app session .
seconds and understand the app functionalities with story droid identify the corresponding layout code for the given ui pages in minutes.
the ui pages are implemented by static and dynamic layout types respectively.
after the exploration participants were asked to rate their satisfactoriness in exploration and confidence in mapping ui authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii user study results of app exploration.
the figure represents the activity coverage of the apps with manual exploration.
denotes p .
and denotes p .
.
metricsmanual explorationstory droid time min .
.
coverage .
.
satisfactoriness .
.
page and code on the point likert scale with being least satisfied or confident and being most satisfied or confident .
all participants carried out experiments independently without any discussions with each other.
after performing all tasks they were required to write some comments about our tool.
experiment results.
as displayed in table iii the average activity coverage of manual exploration is quite low i.e.
.
showing the difficulty in exploring app functionalities thoroughly by manual exploration.
however the participants satisfactoriness of completeness of exploration is high i.e.
.
on average .
it indicates that the development teams sometimes are not aware that they miss many features when exploring others apps.
such blind confidence and neglection may further negatively influence their strategy or decision in developing their own apps.
compared with manual exploration storydroid achieves times more activity coverage with less time cost .
minutes on average to help understand the app functionalities.
according to the participates feedback the average satisfactoriness of story droid is .
which represents the usefulness of helping participants explore and understand app functionalities.
table iv shows the time cost and confidence of mapping ui page to layout code with and without story droid .
all the participants spend over minutes to map the ui pages to the corresponding layout code among which pages are not mapped successfully within minutes.
in contrast with the help of story droid participants only spent seconds to confirm the mapping relations between ui pages and layout code.
to understand the significance of the differences between without story droid and with story droid we carry out the mann whitney u test which is designed for small samples.
the results in table iii and table iv are both significant with p value .
or p value .
.
we analyze the comments from the participants and find that they mainly focus on two aspects it is better to add activity transition methods events on the edges such as clicking login if the transition graph is too complex story droid needs to provide a better strategy to visualize it.
viii.
d iscussion a. future applications based on story droid apart from the above fundamental usefulness i.e.
exploration of app functionalities we discuss additional follow up applications based on the outputs of story droid .
recommendation of ui design and code.
developing the gui of a mobile application involves two steps i.e.
ui designtable iv user study results of ui page and layout code mapping.
denotes p .
and denotes p .
.
metrics without s tory droid with s tory droid time cost min .
.
confidence .
.
and implementation.
designing a ui focuses on proper user interaction and visual effects while implementing a ui focuses on making the ui work as designed with proper layouts and widgets of a gui framework.
our story droid can assist both ui designers and developers by building a large scale database of app storyboard.
such a database bridges the gap across the abstract activities text ui pages image and detailed layout code i.e.
activity ui page layout code so that they can be searched as a whole.
due to that mapping ui ux designers can directly use keywords e.g.
login and search to search the ui images by matching the activity name of the ui in our database.
the searched images can be used for inspiring their own ui design.
the ui developers can also benefit from searching our database for ui implementation.
given the ui design image from designers developers can search the similar ui in our database by computing image similarity e.g.
mse in section vi b3 .
as each ui page in our database is also associated with corresponding run time ui code developers can select the most related ui page in the candidate list and then customize the ui code for their own need to implement the given ui design.
guiding regression testing of apps.
reusing test cases is useful to improve the efficiency of regression testing for android apps .
story droid can help guide app regression testing by identifying the ui components that have been modified.
different versions of a single app have many common functionalities which means most of ui pages in the newer version are the same as the previous version.
story droid stores the mapping relation between ui page and the corresponding layout code therefore analyzers can obtain the modified components by analyzing the differences of layout code and a tg and further update the corresponding test cases.
in this scenario most of the test cases can be reused and the modified components can be identified effectively to guide test case update for regression testing.
b. limitations transition extraction.
the inputs of ui page rendering are extracted from static analysis based on soot but some files failed to be transformed and the call graphs can still be incomplete.
as for the closed source apps jadx is used to decompile apk to java code.
however some java files failed to be decompiled which affects the analysis results of ui page rendering.
but according to our observation these cases rarely appear in the real apps.
besides as the activities spawned by other components e.g.
broadcast receiver can only be dynamically loaded our static analysis based approach cannot deal with them.
ui page rendering.
some ui pages use self defined components by overwriting the method ondraw .
for example authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
kiwix lets users read wikipedia without internet connections.
it draws the canvas for the ui page dynamically.
some components are dynamically created from a user defined function.
for example bankdroid is a banking client for the swedish banks.
it invokes createfrom function to create a component where the parameter is the return value of another self defined method.
as we cannot get a clue of what these values are unless we analyze them at runtime we use some empty placeholder to take the position so that the overall layout is the same as the real ui page.
ix.
r ela ted work studies for helping android development.
gui provides a visual bridge between apps and users through which they can interact with each other.
developing the gui of a mobile app involves two separate but related activities design the ui and implement the ui.
to assist ui implementation nguyen and csallner reverse engineer the ui screenshots by image processing techniques.
more powerful deep learning based algorithms are further proposed to leverage the existing big data of android apps.
retrieval based methods are also used to develop the user interfaces.
reiss parses the sketch into structured queries to search related uis of java based desktop software in the database.
different from the ui implementation studies our study focuses more on the generation of app storyboard which not only contains the ui code but also the transitions among the uis.
in addition the ui code generated in prior work is all static layout which conflicts with our observation in section iii that developers often write java code to dynamically render the ui.
in our work we provide developers with the original ui code no matter static code dynamic code or hybrid for each screen.
such real code makes developers more easy to customize the uis for their own needs.
apart from the ui implementation some studies also explore issues between ui design and its implementation.
moran et al check whether the ui implementation violates the original ui design by comparing the image similarity with computer vision techniques.
they further detect and summarize gui changes in evolving mobile apps.
they rely on the dynamically running apps for collecting ui screenshots and that is timeconsuming and leads to low coverage of the app.
in contrast our method can extract most ui pages of the app statically so it can complement with these studies for related tasks.
gui fectch customizes reiss s method into android app ui search by considering the transitions between uis.
it can also extract ui screenshots with corresponding transitions but our work is different from theirs in two aspects.
first their model can only deal with open source apps while ours can also reverse engineer the closed source apps hence leading to more generality and flexibility.
on the other hand gui fectch is much more heavy weight than our staticanalysis based approach as it relies on both static analysis for ui code extraction and dynamic analysis for transition extraction.
in addition dynamically running the app usually cannot cover all screens leading to the loss of information.studies for helping app understanding.
the process of reverse engineering of android apps is that researchers rely on the state of the art tools e.g.
apktool andro guard dex 2jar soot for decompiling an apk to intermediate language e.g.
smali jimple or java code.
android reverse engineering is usually used to understand and analyze apps .
it also can be used to extract features for android malware detection .
however reverse engineering only has the basic functionality for code review.
different from reverse engineering our work provides a storyboard of each app to show the basic functionalities and other useful mappings between the ui page and the corresponding layout code which helps different parties e.g.
pm ui ux designer developer improve their work efficiency in the real world.
studies for analyzing android apps.
many static analysis techniques have been proposed for android apps.
a3e provides two strategies targeted and depth first exploration for systematic testing of android apps .
it also extracts static activity transition graphs for automatically generated test cases.
apart from the target of android testing we extract activity transition graphs to identify and systematically explore the storyboard of android apps.
epicc is the first work to extract component communication and it determines most intent attributes to component matching.
icc significantly outperforms epicc on the extraction ability of inter component communication by utilizing the solver for mvc problems based on the proposed coal lauguage.
f low droid and i ccta extract call graphs based on soot for data flow analysis for detecting data leakage and malicious behaviors .
x. c onclusion and future work in this paper we propose story droid a system to return visualized storyboard of android apps by extracting relatively complete a tg rendering the ui pages statically and inferring semantic name for obfuscated activities.
such a storyboard benefits different roles i.e.
pms ui designers and developers in the app development process.
the extensive experiment and user study demonstrate the effectiveness and usefulness ofstory droid .
based on the outputs of story droid w e are able to construct a large scale database of storyboard to bridge the gap across app activities text ui pages image and implementation code.
such a comprehensive database can enable many potential applications such as recommending ui pages to designers and implementation code for developers.
in the future we will explore these potential applications and also extend our approach into other platforms such as ios apps and desktop software for more general usage.
acknowledgement we appreciate the constructive comments from prof. zhenchang xing and li li.
this work is partially supported by nsfc grant the science and technology commission of shanghai municipality grants and ntu research grant ngf and nrf grant crdcg2017 s04.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.