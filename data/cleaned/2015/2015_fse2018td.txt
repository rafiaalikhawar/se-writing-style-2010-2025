zurich open repository and archive university of zurich university library strickhofstrasse ch zurich year pydriller python framework for mining software repositories spadini davide aniche maur cio bacchelli alberto posted at the zurich open repository and archive university of zurich zora url conference or workshop item accepted version originally published at spadini davide aniche maur cio bacchelli alberto .
pydriller python framework for mining software repositories.
in 26th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering lake buena vista fl usa december december .
acm press .
python framework formining softwarerepositories davide spadini delft universityof technology softwareimprovement group delft the netherlands d.spadini sig.eumaur cio aniche delft universityof technology delft the netherlands m.f.aniche tudelft.nlalbertobacchelli universityof zurich zurich switzerland bacchelli ifi.uzh.ch abstract softwarerepositoriescontainhistoricalandvaluableinformation abouttheoveralldevelopmentofsoftwaresystems.miningsoftware repositories msr isnowadaysconsideredoneofthemostinteresting growing fields within software engineering.
msr focuses on extracting and analyzing data available in software repositories to uncover interesting useful and actionable information about the system.
even though msr plays an important role in software engineering research few tools have been created and made public to support developers in extracting information from git repository.inthispaper wepresent pydriller apythonframeworkthat easestheprocessofmininggit.wecompareourtoolagainstthe state of the art python framework gitpython demonstrating that pydriller canachieve the same results with on average less locandsignificantly lower complexity.
url materials pre print ccs concepts software andits engineering keywords miningsoftware repositories gitpython git python acmreference format davide spadini maur cio aniche and alberto bacchelli.
.
pydriller python framework for mining software repositories.
in proceedings of proceedingsofthe26thacmjointeuropeansoftwareengineeringconference and symposium on the foundations of software engineering lake buena vista fl usa november 4 9 esec fse 4pages.
introduction mining software repository msr techniques allow researchers to analyze the information generated throughout the software developmentprocess suchassourcecode versioncontrolsystemsmetadata andissuereports .withsuchanalysis researches permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse november 4 9 lake buenavista fl usa copyright held by the owner author s .
publication rights licensed to associationfor computing machinery.
acm isbn ... .
empirically investigate understand and uncover useful and actionableinsightsforsoftwareengineering suchasunderstanding the impact of code smells exploring how developers are andwhichtestingpracticesthey follow predicting classes that are more prone to change defects andidentifyingthecoredevelopersofasoftware team to transfer knowledge .
among the different sources of information researchers can use versioncontrolsystems suchasgit areamongthemostusedones.
indeed versioncontrolsystemsprovideresearcherswithprecise information about the source code its evolution the developers of the software and the commit messages which explain the reasons for changing .
nevertheless extracting information from git repositories is not trivial.indeed manyframeworks can beusedto interactwith git dependingonthepreferredprogramminglanguage suchas gitpython for python or jgit for java .
however these tools areoftendifficulttouse.oneofthemainreasonsforsuchdifficulty isthattheyencapsulateallthefeaturesfromgit hence developers areforcedtowritelongandcompleximplementationstoextract even simpledata from agit repository.
inthispaper wepresent pydriller apythonframeworkthat helpsdeveloperstominesoftwarerepositories.
pydriller provides developers with simple apis to extract information from a git repository suchascommits developers modifications diffs and source code.
moreover as pydriller is a framework developers canfurthermanipulatetheextracteddataandquicklyexportthe results to theirpreferredformats e.g.
csvfilesanddatabases .
toevaluatetheusefulnessofourtool wecompareitwiththe state of the art python framework gitpython in terms of implementation complexity performance and memory consumption.
our results show that pydriller requires significantly fewer lines of code to perform the same task when compared to gitpython with only a small drop in performance.
also we asked six developerstoperformtaskswithbothtoolsandfoundthatalldevelopers spend less time in learning and implementing tasks in pydriller .
pydriller pydriller isawrapperaroundgitpythonthateasestheextraction of information from git repositories.
the most significant difference between the two tools is that gitpython offers many features almost all the features of git while pydriller offers only features that are important when performing msr tasks thus hiding the underlyingcomplexityto theend user.in thissection weexplain the designof pydriller as well as its main apis.esec fse november4 lake buena vista fl usa d.spadini et al.
.
domain object commit.
it contains all the information regarding the commit thehash thecommitter nameandemail theauthor nameand email the message the authored and committed dates a list of itsparents hashes amergecommithastwoparents andthelist of modified files see modification object below .
since loading the entire object is expensive and time consuming e.g.
pydriller needs to retrieve and parse the diff of the commit objects are lazy loaded i.e.
are only computedwhen needed.
modification.
this object carries information regarding a file changedinacommit.amodificationobjecthasthefollowingfields oldpath old pathofthe file can be noneif the file isadded .
new path new path of the file can be noneif the file is deleted .
changetype type added deleted modified or renamed .
diff diffofthefileasgitpresentsit startingwith xx xx .
source code source of the file can be noneif the file is deleted .
added number oflinesadded.
removed number oflinesremoved.
filename the name ofthe file.
.
architecture repositorymining.
this class is in charge of running the msr study.theonlyrequiredparameterofthisclassisthepathtothe git repository to analyze.
based on the git path the framework willreturn the listofcommits inthe repository.
sincemsrstudiesarehighlycustomizable toallowaresearcher tocustomizethestudy weexposeasetofapis makingitpossible to set the dates in which pydriller should start to analyze as well as filtering only specific commits.
the complete list of filters is the following selectstarting point since afterthisdate fromcommit after this commit hash and from tag after this commit tag select ending point to up to this date to commit up to this commit hash and to tag upto this commit tag select by commits single single hash of the commit only in branches onlyconsidercertainbranches onlyinmainbranch only commits that belong to the main branch only no merge onlycommitsthatarenotmergecommits and onlymodificationswithfiletypes onlycommitsinwhichatleastonemodificationwasdoneinthatfiletype e.g.
byspecifying .java only commits withat leastone java file wasmodifiedare visited.
in the following we present some examples of how metrics can be customizedandadaptedto variousmsr studies analyze single commit 2repositorymining path to the repo 3single 6411e3096dd2070438a17b225f4447 since 6dt1 datetime 7repositorymining path to the repo since dt1 between dates 10dt1 datetime 11dt2 datetime 12repositorymining path to the repo since dt1 to dt2 between tags 15first tag tag1 16last tag tag2 17repositorymining path to the repo from tag first tag to tag last tag only commits in main branch 20repositorymining path to the repo only in main branch true only commits in main branch and no merges 23repositorymining path to the repo only in main branch true only no merge true only commits that modified a java file 26repositorymining path to the repo only modifications with file types after the user configured the repositorymining class thus specifying which commits to analyze the user has only to call the traverse commit function that will return the desired list of commits.internally pydriller obtainsthelistofallthecommits filters out the unnecessary ones converts the commits in a domain object and returns the list of resulting commits.
this approach has the advantagethat allthe complexityishiddenfrom users.
furthermore if users needmore thanjust visitingcommits we createdawrapperforthemostcommonutilitiesofgit forexample checkout reset log show a singlecommit.we also built apis to helpresearchersinmsr studies including parse diff the diff presented by git is difficult to parse.
with this api given a diff it returns a dictionary with the added anddeletedlines.forbothgroups thefunctionreturnsatuple corresponding to linenumber inthe file and2 actual line.
get commits that last modified lines this function applies szz .
given a commit object as parameter it returns the set of commits that changed last the lines modified in the files includedinthecommit.thealgorithmworksasfollow forevery file in the commit obtain the diff obtain the list of deleted lines and blame the file and obtain the commits were those lineswere changedlast.
to facilitate the data analysis pydriller gracefully handles gitpythonexceptions.forexample whenretrievingthesourcecode of non utf files e.g.
bytecodes gitpython raisesan exception while pydriller returns an empty string.
hence pydriller reduces theburdenofhandlingseveralexceptionsthatadeveloperwould have to do otherwise.
evaluation toevaluateourtool wecompare pydriller againstthestate ofthe art git framework for python gitpython.
we select five different common msr tasks that we encountered in our experience as researchers in the msr field and implement them using both frameworks.
the tasksfollow task1 calculatingcomplexityoftheaddedlinesforeverycommit.forthesakeofsimplicity wedefinecomplexityasthe number of ifstatements inthe diff.
task2 detectingbuginducingcommits.weuseszz toretrieve the commits where the bug was introduced as normallydone inprevious literature .
task3 obtainingthelistofcommitsthatonlymodifiedjavafiles.
task4 linesofcode per sourcefile over time.
task5 day of the week developers fixed more bugs between two releases.pydriller python framework for git esec fse november4 lake buena vista fl usa table comparisonbetween pydriller andgitpython.
pydriller gitpython total ex1time maxmemory mb loc complexity ex2time maxmemory mb loc complexity 6similar ex3time maxmemory mb loc complexity ex4time maxmemory mb loc complexity ex5time similar maxmemory mb loc complexity 4similar we run thefive tasks implemented inboth pydriller and gitpython on50ossprojects 25belongingtotheeclipsefoundation and to apache.
we selected the projects using ghtorrent taking the most starred projects of the two organizations.
for the sake of simplicity we only report the results of one project apache hadoop.
the results of the other projects can be found inour on line appendix .
wecomparethetoolsunderdifferentmetrics linesofcode loc andcomplexity mccabecomplexity ofbothimplementations as well as their memory consumption and execution time.
table showstheresults.foralltheexercises bothinpydrillerandgitpython thenumberoflinesthatarenotacorefunctionality for example the constructor is three.
we keep this number as it is alwaysthe same for allthe exercises andfor both tools.
regardingexecutiontime pydriller isgenerallyslowerthan gitpython.thisdecreaseinspeedisexpected giventhat pydriller isawrapperbuiltontopofthepythonframework.however the difference is small in the most expensive tasks ex1 and ex4 in which the tools have to analyze the diff or source code of every file in commits pydriller is only minutes slower in the first case.
in the other task pydriller is seconds faster than gitpython.
nevertheless both tools take less than minutes to analyze the entire history of apache hadoop avg.
commits per second .asformemoryconsumption thetoolsbehavesimilarly in some cases the used memory is less than 50mb.
in the most memoryconsumingtask number1 theusedmemorywas169mb.
the large difference between both toolsisinterms oflocand complexityoftheimplementation.fortheformer weseethatusing pydriller results on average in writing less lines of code thanusinggitpython.thebiggestdifferenceisinthetask2 wheretable2 timespentbytheparticipantsoftheexperimentin solvingtasks3 and4 together.
participanttime minutes withpydrillertime minutes withgitpythontotal p1 p2 p3 p4 p5 46 p6 the tool had to retrieve the bug inducing commits using the szz algorithm this problem was solved in loc using pydriller while66 locwithgitpython difference .
we also observe that the complexity of the code written for pydriller is significantly lower than for gitpyhon.
table 1shows that on average the codefor pydriller is less complex.
this is especially the case in tasks that have to deal with retrieving the diff orsource code of the modified files indeed obtaining this informationin pydriller isjust1apicall whilegitpythonrequires manylinesofcode andexceptions handling.
evaluation withdevelopers to furtherevaluate ourtool weinvited six developersto perform the same two tasks using both pydriller and gitpython and to note the time they took to solve the problems as well as their personal opinions on both tools.
all developers had experience in developing with pythonand on performingmsrstudies but they hadnever usedpydrillernorgitpython before.
we asked the participants to solve tasks and .
we chose these tasks because they are simpler than the first two to keep the experiment short and do not require participants to have notions on how to identify bug fixing commits ex5 .
the setting of the experiment isthe following participantsshouldimplementbothtasks firstwith pydriller thenwithgitpython.sinceunderstandinghowtosolvethetasks doesrequire someadditionaltime weaskedtheparticipantsto startwith pydriller .thischoiceclearlypenalizesourtool as participants will have a better intuition about the tasks when pydriller issimplertouse andthatthedifferencebetweenthetwotools willstillbe significant.
participants should take notes about the time it takes them to implement the tasks.
we ask participants to also include the time spent reading the documentation of the two tools since understanding howto use the toolispart of the experiment.
after having implemented both tasks we ask to the participants to elaborate on the different advantages and disadvantages between both tools.
the result of the experiment is shown in table .
five out of six participants spent significantly less time to solve the problems lessintheworstcase lessinthe best case .p5 instead solvedboth problemsinthesameamountoftime theparticipant did not know how to solve the second task and since he startedesec fse november4 lake buena vista fl usa d.spadini et al.
withpydriller thistranslatedinmoretimeinthefirstpart.when he understood how to solve it he moved to gitpython already knowing the solution.
allparticipantsagreedthat pydriller waseasiertousethangitpython .
p6said i thought pydriller was a lot more intuitive than using gitpython.
gitpython works exactly like git so it isn t verywell suited when trying to gain insights about therepository.
similarly p 1affirmed that using pydriller he was able to achieve the same result with simpler and shorter code and that he willcontinuetouse pydriller inhisnextmsrstudies.p 2added thatgitpythonisusefulwhenonehastosimulategitcommandsin python but it can be overcomplicated when the goal is to perform msrstudies forwhich pydriller ismoreappropriate becauseit hidesthis complexityfrom its users.
related tools inthissectionwecomparepydrilleragainsttwoofthemostrecent andusedmsr tools.
boa boa is a domain specific language and infrastructure that eases msr.
the main difference between pydriller and boa is that while the former can be run on every project boa can only be usedontheirsnapshotsofgithuborsourceforge whichcurrently are3and6 yearsold.furthermore pydrilleriswritteninpython.
hence it has all the flexibility of a the programming language and can be used together with other frameworks.
boa on the other hand hasitsowndsl andcannotbeusedwithother external libraries.
furthermore boa currently includes only the history and sourcecodeofjavaprojects while pydriller canbeusedtoanalyze repositoriesofany programminglanguage.
ghtorrent ghtorrentisascalable queriable offlinemirrorof datapresentongithub.themaindifferencebetweenpydrillerand ghtorrentisthat whiletheformerretrievesalltheinformation regardingacommit e.g.
whatfileschanged diffs andsourcecode the latter focuses on github s social data such as pull requests issues andusers.however ghtorrentdoesnotofferthepossibility ofnavigatingthroughthecommitsoranalyzingtheproject ssource code over time whichisafeature of pydriller .
conclusion inthispaper wepresented pydriller apythonframeworkthat helps developers on mining software repositories.
we showed that withpydriller developerscaneasilyextractinformationfromany git repository such as commits developers modifications diffs and source codes since pydriller releases simple apis to help researchersandpractitioners performingmsr.
we evaluated pydriller on exercises comparing it against gitpython.
the evaluation showed that using pydriller results in writing on average half the code and less complex.
furthermore weasked6developerstosolvetwoexercisesusingour tool andtheyallagreedthat pydriller helpedtheminsolvingthe problems inless time withless code.
the first version of pydriller has been released on 9th april andsincethenithasbeendownloadedapproximatively1 times per month as computed through pypinfo 1and google bigquery .
we plan to keepimproving pydriller s performance as even betterwhat msr researchersrequire intheir studies.