identifying and quantifying architectural debt lu xiao yuanfang cai drexel university philadelphia pa usa lx52 yc349 drexel.edurick kazman university of hawaii sei cmu honolulu hi usa kazman hawaii.eduran mo qiong feng drexel university philadelphia pa usa rm859 qf28 drexel.edu abstract our prior work showed that the majority of error prone source les in a software system are architecturally connected.
flawed architectural relations propagate defects among these les and accumulate high maintenance costs over time just like debts accumulate interest.
we model groups of architecturally connected les that accumulate high maintenance costs as architectural debts .
to quantify such debts we formally de ne architectural debt and show how to automatically identify debts quantify their maintenance costs and model these costs over time.
we describe a novel history coupling probability matrix for this purpose and identify architecture debts using patterns of architectural aws shown to correlate with reduced software quality.
we evaluate our approach on large scale open source projects and show that a signi cant portion of total project maintenance e ort is consumed by paying interest on architectural debts.
the top architectural debts covering a small portion to of each project s error prone les capture a signi cant portion to of each project s maintenance e ort.
finally we show that our approach reveals how architectural issues evolve into debts over time.
ccs concepts software and its engineering !software architectures keywords software architecture software quality technical debt .
introduction technical debt td is a metaphor to describe the longterm consequences of shortcuts taken in coding activities to achieve near term goals .
debts are introduced when developers opt for quick and dirty solutions but postpone longer term improvements.
our prior work showed that permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
2most error prone les in a project are architecturally connected through awed relations.
these awed relations can propagate defects among large numbers of les and incur increasing maintenance costs over time.
a awed architecture relation is similar to a debt in that it accumulates penalty in terms of maintenance costs the same way a debt accumulates interest.
we call such aws architectural debts .
although the concept of td has been in uential it has until now largely been a metaphor.
the di erences with real nancial debt are crucial.
a real debt always starts from aprincipal and grows with a certain interest rate.
how to quantify the principal and interest rate in software investments has been a challenge.
our goal is to advance the understanding and management of architectural debt a type of technical debt by quantifying it.
we de ne the concept of architectural debt archdebt as a tuple consisting of a group of architecturally connected les and a model of the maintenance cost growth for such les.
based on this de nition we contribute an approach to automatically locate architecture debts.
once we locate each debt we model its growth using regression models.
our approach to identify archdebt has two parts.
we rst create a novel history coupling probability hcp matrix to manifest the probability of changing one le when another le is changed.
then we index le groups through the lens of patterns of prototypical architectural aws that have been shown to correlate with reduced software quality namely hub anchor submissive anchor dominant and modularity violation .
given an archdebt we quantify the maintenance costs approximated by bug xing churn spent on the les involved in the debt.
from the costs incurred in each release we can model the growth trend using linear logarithmic exponential or polynomial regression models.
these models represent coherent scenarios of stable reducing increasing and uctuating maintenance interest rates respectively.
finally we rank the identi ed architectural debts according to the maintenance costs they have accumulated.
we have evaluated our approach using seven apache open source projects and identi ed many instances between and of archdebts in each project.
the results show that a signi cant portion from to of the maintenance e ort in each project is consumed by paying interest on these debts and that non trivial portions to of the maintenance e ort is consumed by just ve archdebts which represent a small portion of all errorprone les.
our evaluation also revealed that about half of the identi ed debts t linear regression models indicating a ieee acm 38th ieee international conference on software engineering steady increase in the penalty that these debts incur.
about and less than of all debts t polynomial logarithmic and exponential models respectively indicating the interest rate trends of these debts can vary drastically.
finally we qualitatively analyzed the design problems behind debts and how these evolve over time.
this approach will not only enable an analyst to precisely locate architectural debts but also rank and prioritize them so that informed decisions can be made on if where and how to refactor.
although the archdebt detection and modeling approaches we propose only work retrospectively when the penalty has already accumulated this approach can be used to monitor the formation of a debt and thus prevent it from growing early in the software development process.
.
background we now introduce the key concepts our work is based on.
design rule space.
in our prior work we proposed a novel architectural model design rule space drspace based on the baldwin and clark s design rules .
building upon existing de nitions of software architecture we characterize a software architecture as a set of overlapping drspaces each re ecting a unique aspect of the architecture.
each drspace is a subset of a system s source les and some kind of relationships dependencies among these les.
each drspace has one or more leading le s which all other les in the drspace depend on directly or indirectly.
the leading les are usually the les with architectural importance such as interfaces or abstract classes which we calldesign rules .
the relations within a drspace may be structural such as implement extend call or relations may be based on history coupling between source les indicating the number of times two les changed together as recorded in the project s revision history.
there are numerous drspaces in any non trivial software system e.g.
each dependency type forms a drspace les connected by extend and inherit relationships form aninheritance drspace and les that are coupled in the project s revision history form an evolution drspace.
we created an architecture root detection algorithm that computes the intersection between drspaces and the project s error space the set of error prone les in a system .
we showed that the majority of the error prone les are concentrated in just a few drspaces suggesting that these error prone les are not islands they are architecturally connected .
furthermore we showed that these drspaces frequently contain architectural issues aws that we claim are the root causes of error proneness.
design structure matrix dsm .
we use a dsm to represent a drspace.
each element in the dsm is a source le and each cell represents the relationships between the le on the row and the le on the column.
for example figure is a drspace with leading le columnparent .
each cell shows the structural dependencies implement or dp between the le on the row and the le on the column followed by the conditional probability of change propagation.
in the original drspace we used the number of times two les changed together in the project s revision history to represent their history dependency.
in this paper we replace this count with a probability .
for example cell contains implement meaning that the le on row cassandraserver implements the interface on row cassandra cell contains meaning thatwhen cassandra changes there is a probability that cassandraserver will change with it.
architecture issues.
our recent work de ned implemented and validated an algorithm for detecting recurring architectural issues in software systems which we call hotspot patterns including unstable interface where an in uential le changes frequently with its dependents in the revision history modularity violation where structurally decoupled les frequently change together in the project s revision history unhealthy inheritance where a super class depends on its sub class or where a client class depends on both a super class and its sub class cyclic dependency where a set of les forms a dependency cycle.
in the projects we examined we observed a strong correlation between the number of aws a le has and the number of bugs reported and xed in it the number of changes made to it and the amount of e ort spent on it in terms of committed lines of code to x bugs and to make changes .
.
definition and identification in this section we de ne architectural debt archdebt and present an archdebt identi cation approach.
.
archdebt definition we formally de ne the software architecture of a system implemented at release r as a set of overlapping drspaces softarch r fdrspace drspace drspace ng where nis the number of drspaces each revealing a different aspect of the architecture.
for example each dependency type can form a distinct drspace .
we de ne an architectural debt archdebt as a group of architecturally connected les that incur high maintenance costs over time due to their awed connections as follows archdebt filesetsequence debtmodel the rst element filesetsequence is a sequence of le groups each extracted from a di erent project release filesetsequence fileset fileset fileset m where mis the number of releases that archdebt impacts m r the number of project releases.
fileset r r m is a connected le group in release r. the number of les in each fileset may vary in di erent releases.
the second element debtmodel is a formula capturing the growth i.e.
interest rate of the archdebt in the form of maintenance costs for filesetsequence.
.
archdebt identification given this de nition of archdebt we rst identify fileset sequence and then build a debtmodel to capture the interest rate based on the costs filesetsequence has incurred.
there are numerous drspaces in each release and numerous debt candidates le groups in each drspace.
we illustrate our process of searching for a filesetsequence on analogy with searching for web pages on the internet consisting of the following steps as shown in figure crawling this step collects a subset of drspaces from each softarch r r from to r similar to crawling and collecting web pages.
indexing this step identi es indexes a speci c le group fileset from each drspace selected in the rst 489input 2indexing identify debt candidates r1 to rn revision log bug report crawl titan errorspace r1 to rn as ad hb mv input file input files new approach prior approach output files output 1crawling select drspaces softarch r1 to rn seldrspace r1 to rn hcpgen index hcp r1 to rn candidate filesetseq archdebt debtmodels ... archdebt x filesetseq debtmodel ranked archdebs ... source code repo und commercial tool 3modeling compute debt model model 4ranking identify costly archdebt rank archdebt 1 filesetseq debtmodel archdebt 1 filesetseq debtmodel archdebt x filesetseq debtmodel und figure approach framework step then locates sequences of related filesets in di erent releases as a filesetsequence.
modeling we measure the maintenance costs incurred by each sequence of fileset r. an archdebt is de ned as a filesetsequence whose costs increase over time.
ranking we rank the severity of each archdebt according to the amount of maintenance costs they have accumulated in the project s evolution history.
.
.
crawling selecting drspaces we rst de ne the set of error prone les in a particular release ras an error space errorspace r ff f2 f ng where le fi i n was revised to x bugs at least once from release to release r. according to this de nition errorspace ris a subset of errorspace r .
for each release r we select a set of drspaces from softarch r each led by a le in errorspace r and form a selecteddrspace set as the output of crawling selecteddrspace r crawling softarch r errorspace r each drspace in selecteddrspace ris led by an errorprone le in errorspace r and contains other les that depend on the leading error prone le.
if there are n les in errorspace r there are ndrspaces in selecteddrspace r. .
.
indexing identify archdebt candidates next we nd the filesetsequences that are debt candidates.
files in such a sequence must have changed together in the project s revision history.
we rst calculate a history coupling model hcp matrix and then we lter le groups using indexing patterns .
hcp matrix.
in our prior work we used a dsm to model history coupling each cell in the dsm displays the number of times two les changed together.
to manifest how a change to a le in uences other les we propose a new model the history coupling probability hcp matrix .
although each column and row in a hcp still represents a le we use each cell to record the conditional probability of changing the le on the column if the le on the row has been changed i.e.
the odds of changes propagating from le to le.
.
.
.
thred .
discard .
a b d commit1 a b commit2 a b commit3 b d commit4 a c .
.
discard .
.
.
discard .
.
.
.
.
.
.
.
b d a b a c d a b c b a c c a b d a b c .
d .
.
.
figure generate hpc matrix figure shows an example of the creation of a hcp.
part shows les a b c and d that change in commits commit1fa bg commit1 changes aandb commit2fa bg commit3fb dg and commit4fa cg.
first we compute the pair wise conditional change probabilities for any pair of les.
for example the probability of changing lea given that le chas changed denoted by probfajcg is the number of times aandcchange in the same commits divided by the total number of changes to c. similarly probfcjagis the number of times aandcchange in the same commits divided by the total number of changes to a. hence probfajcgis indicating that aalways changes with c and probfcjagis indicating a probability of that cchanges with a. in this relation we label c asdominant andaassubmissive because probfajcg probfcjag.
we compute the probabilities for every pair of les and get the graph in part of figure .
as shown in part we compute the n transitive closure of the graph in part to identify history dependencies between les that change in distinct but potentially related commits.
the conditional probabilities between les without direct connections are the multiplication of the probabilities on the transitive links.
for example les bandcnever change in the same commits but they change with ain commit1 and commit4.
hence there are transitive history connections between bandc.probfbjcgisprobfbjag probfaj cg .
.
.
and probfcjbgisprobfcjag probfaj bg .
.
.
we only keep links with probabilities of at least .
to avoid keeping weak connections.
in case there are multiple paths between two les we keep just the highest probability.
part shows the n transitive closure stored in an adjacency matrix called a hcp matrix.
for each release rof a project we compute a hpc matrix hpc r consisting of les in errorspace r from the bug xing revision history between release to release r. indexing patterns.
now we compute the interaction between selecteddrspaces r andhcp rto nd fileset rfrom each release.
we observe that in most cases even though the number of les in a fileset may vary in di erent releases they are always con490nected to at least one le over all releases.
for example if more child classes are de ned to extend a parent class over time the group of les connected to the parent class grows.
we thus call this one special le the anchor le of the group denoted as le a. we thus de ne fileset ras fileset r fa m rjmr fmi ifrom to ngj 8mi2mr miarchitecturally connected with ain release rg where filesect r2filesetsequence ais the anchor le and the les contained in mrmay change with release r. we call mrthe member les of ain release r. we also de ne two boolean expressions to describe the relationships between two les x andy in release r sr x!
y and hr x!y .sr x!y means ystructurally depends onxin release r.hr x!y means xis dominant and yis submissive in their co changes between release to release r. in hcp r hcp r is the probability of changing y given xhas changed.
if hcp hcp r then x is dominant and yis submissive.
hcp hcp r means xandyare equally dominant.
formally in release r sr x!y is true if y2drspace rx otherwise it is false hr x!y is true if hcp hcp r hcp otherwise it is false for any pair of aandmin afileset r we identify relationships sr a!m sr m!a hr a!m and hr m!a .
each relationship could be either true or false.
we enumerated all combinations of these relationships.
the combinations with hr a!m and hr a!m false are irrelevant to our analysis as we need history to measure debt .
from the remaining possible combinations we dened indexing patterns hub anchor submissive anchor dominant modularity violation .
each pattern corresponds to prototypical architectural issues that proved to correlate with reduced software quality .
given any anchor le a2errorspace r we can calculate itsfileset rausing selecteddrspace randhcp rthrough the lens of the indexing patterns hub the anchor le and each member have structural dependencies in both directions and history dominance in at least one direction.
the anchor is an architectural hub for its members.
this pattern corresponds to cyclic dependency unhealthy inheritance if the anchor le is a super class or interface class and unstable interface if the anchor le has many dependents .
informally such structures are referred to as spaghetti code or big ball of mud .
a fileset ra with anchor le ain release rthat matches a hubpattern is denoted by hbfileset raand is calculated as hbfileset ra index hb a selecteddrspace r hcp r fa m rj8m2mr sr a!m sr m!a hr a!m hr m!a g figure is a hub fileset for the pdfbox project anchored by pdannotation .
the dark grey cell represents the anchor le cell for pdannotation .
the cells showing the historical and structural relationships between member les and the anchor le are in lighter grey.
in this hbfileset the anchor le structurally depends on each member 1pda line dp 2pda squarecircle dp 3pda fileatt dp 4pda dp dp dp dp dp dp 5pda text dp 6pda link extend dp 7pda widget extend dp a stands for annotationfigure hub 1abstracttype 2uuidserializer 3uuidtype ext dp dp 4abstractcell dp 5typecast dp 6integerserializer 7longtype ext dp dp 8datetype ext dp dp figure anchor submissive le and each member le also structurally depends on the anchor le.
when the anchor le changes each member le has a probability of changing as well.
when a member le changes the anchor le always changes with it.
a hbfileset is potentially problematic because the anchor le like a hub is strongly coupled with every member le both structurally and historically.
anchor submissive each member le structurally depends on the anchor le but each member historically dominates the anchor.
this pattern corresponds to an unstable interface where the interface is submissive in changes.
an anchor submissive fileset with anchor ain release rtis asfileset ra index as a selecteddrspace r hcp r fa m rj8m2mr sr a!m s r m!a hr m!a figure shows an asfileset with anchor abstracttype in cassandra.
each member le directly or indirectly depends on the anchor le but when the member les change the anchor le changes with each of them with historical probabilities of to .
a asfileset is problematic because history dominance is in the opposite direction to the structural in uences the anchor should in uence the member les not the other way around.
anchor dominant each member le structurally depends on the anchor le and the anchor le historically dominates each member le.
this pattern corresponds to the other type of unstable interface where the interface is dominant in changes.
an anchor dominant fileset with anchor ain release rtcan be calculated as adfileset ra index ad a selecteddrspace r hcp r fa m rj8m2mr sr a!m s r m!a hr a!m g figure shows an adfileset calculated using anchor columnparent in cassandra.
each member le from row to row structurally depends on cell the anchor le row and when the anchor le changes the member les change as well with probabilities from to cell .
a adfileset presents potential problems where the anchor le is unstable and propagates changes to 1columnparent 2cassandra dp 3cliclient dp dp 4column reader dp dp 5thriftvalidation dp 6cassandraserver dp implement dp figure anchor dominant 1jmxetpembean 2debuggabletpexecutor 3storageservice dp dp use 4columnfamilystore dp 5messagingservice dp dp 6nodeprobe dp 7statuslogger dp dp 8jmxctpexecutor figure modularity violation member les that structurally depend on it.
modularity violation there are no structure dependencies between the anchor and any member however they historically couple with each other.
in a modularity violation the anchor and member les share assumptions secrets that are not represented in any structural connection.
a mv fileset with anchor ain release ris calculated as mv fileset ra index mv a selecteddrspace r hcp r fa m rj8m2mr s r a!m s r m!a hr m!a hr a!m g figure is a mv fileset with anchor jmxctpexecutor row in cassandra.
the anchor le on the bottom of the matrix is structurally isolated from the member les.
however when the anchor le changes there are historically to probabilities that the member les change as well and when the member le jmxetpembean on row changes the anchor le has a chance to change with it.
this pattern identi es potential problems where the anchor le and the member les share common assumptions without explicit structural connections and these assumptions are manifested by historical co change relationships.
identify archdebtcandidates .
for each release r we use each ainerrorspace ras the anchor le to calculate a fileset for each of the patterns hb as ad and mv fileset ra.
the filesetsequence in the hubpattern with anchor le ais denoted by hbfilesetsequence a. similarly for anchor a we can identify as ad and mv filesetsequence a. using any error prone le as the anchor we can identify filesetsequences each of which is an archdebtcandidate .
as a result for each a2errorspace rand for each release r we can exhaustively detect j n r 1errorspace rjcandidates which equals jerrorspace njbecause errorspace n is a super set of all errorspaces in earlier releases.
.
.
modeling build regression model now that we have identi ed the filesetsequences the candidates of archdebt we measure maintenance costs incurred by each fileset within a filesetsequence and debtmodel t .49ln t r2 .
8wicket reque stparameters logarithmic debtmodel t .81e0.385t r2 .
10exponential debtmodel t .
t3 .
t2 .
t .
r2 .
8wicket stockquotelabel polynormial debtmodel t .
t .
r2 .
10hbase keyvalueheap linear pdfbox type1encoding figure types of regression model formulate a debtmodel to capture cost variation.
measure archdebtcandidates .
from each filesetsequence we rst exclude any singleton fileset r that is a set containing just le since this can not involve architecture problems.
after that we de ne the age of a filesetsequence as the number of filesets in it after singleton filesets are ltered out.
then for each fileset r we measure the maintenance e ort denoted by effort fileset r that it consumes by the end of release r. for any le f2fileset r we approximate its maintenance costs as the amount of bug xing churn expended on it by the end of release r. we denote the maintenance cost for le fby release raserrorchurn rf.effort fileset ris the sum of maintenance costs spent on each le in the set effort fileset r x 8f2fileset rerrorchurn rf to qualify as a debt rst a filesetsequence should have long lasting impacts.
this can be evaluated using the age offilesetsequence.
second filesetsequence should require ever increasing maintenance e ort.
suppose a software system has nreleases.
let fileset fandfileset lbe the rst and last element in filesetsequence.
a filesetsequence is identi ed as a real debt if it satis es the following conditions age n c effort fileset l effort fileset f where cis a tunable parameter.
here we use c meaning that filesetsequence in uences at least half of the releases.
otherwise the candidate is not a meaningful debt at least not yet.
the second condition requires that the maintenance costs on filesetsequence increase over time.
formulate debtmodel .
for each filesetsequence identi ed as a real debt we select a regression model as its debtmodel to describe the growing trend the interest rate of maintenance costs over time.
we use four types of regression models linear logarithmic exponential and polynomial up to degree .
figure shows typical examples of these models.
each model represents a coherent scenario.
in a linear model part of figure the penalties of a debt increase at a stable rate in each version.
in a logarithmic model part the penalties of a debt increase more slowly over time e.g.
when devel492opers refactor a group of les they become easier change so the interest rate decreases over time .
in an exponential model part the penalties of a debt increase at ever faster rates over time e.g.
the structure of a tangled group of les worsens often in the early stages of a project before anyone worries about td .
in a polynomial model part the penalties of a debt uctuate over the releases.
we calculate the maintenance costs effort fileset rfor each fileset rin a filesetsequence using equation .
the effort fileset rof all fileset rin a filesetsequence form an array that we call effort array .effort array effort fileset r where fileset ris the ith element of filesetsequence.
we de ne an integer array t r where ris the release number of the ith element in filesetsequence .
each release ris numbered by its order in the release in history.
in the debtmodel of a filesetsequence effort array is the independent value and tis the dependent value.
we created a modelselector algorithm to select a regression model for the relationship between tand effort array .
the formula and r2of the regression model are returned as debtmodel debtmodel modelselector effortarray t we de ne a global parameter r2 thresh r2threshold for modelselector .r2 thresh ranges from to the higher the value the stricter effort array andt t the model.
our modelselector algorithm rst tries to t the effort array andtto a linear regression model.
if the r2 linof the linear model reaches the threshold r2 thresh it returns the linear model.
if not it builds both logarithmic and exponential models and computes their r2values.
if the r2values of both models reach r2 thresh modelselector returns the model that gives a higher r2.
otherwise it returns the model that reaches the threshold.
if the debt ts neither with r2 r2 thresh it tries polynomial models of degrees up to .
a polynomial model where r2 poly r2 thresh or the degree reaches whichever is satis ed rst is returned.
in the modelselector algorithm we give higher priority to linear logarithmic and exponential models over polynomial models.
we do not simply pick the best t i.e.
the model with highest r2 .
the reason is that the linear logarithmic and exponential models present three general types of penalty interest rate stable decreasing and increasing.
the polynomial model however catches minor uctuations of the penalty trend most likely a result of noise due to extraneous factors.
for example the debt in part of figure intuitively a linear model debtmodel r r with r2of .
can t into a polynomial model debtmodel r r6 r5 r4 r3 r2 r with a higher r2 .
.
the polynomial model ts better higher r2 but the linear model is preferred.
as long as a debt penalty generally r2 r2 thresh where e.g.
r2 thresh is .
ts into a linear logarithmic or exponential model we choose those models.
for each filesetsequence we identify its debtmodel.
this completes our archdebt identi cation.
.
.
ranking identify high maintenance archdebt not all architectural debts have the same severity the maintenance costs they incur.
debts with higher maintenance costs deserve more attention.
we rank all the identied architectural debts according to their cumulative maintenance cost as follows.
we de ne a pair pf f errorchurn f where fis an error prone le errorchurn fis the maintenance costs for f approximated by bug xing churn on f. lete ortmap be the set of pf such that8f2errorspace n n is the latest release there exists a pf2e ortmap .effortmap is one of the inputs to the ranking algorithm.
the other input is the identi ed archdebts.
rankeddebts ranking archdebts effortmap in the ranking algorithm we rank the importance of each archdebt according to e ortmap iteratively.
in each iteration we select maxarchdebt that consumes the largest portion of e ort for les in e ortmap from archdebts .
the e ort for duplicate les is excluded and the iteration terminates when all archdebts are ranked.1the top debts returned consume the largest maintenance e ort and deserve more attention and higher priority for refactoring.
.
ev aluation to evaluate the e ectiveness of our approach we investigate the following research question rq whether the le groups identi ed in archdebts generate and grow signi cant amount of maintenance costs?
that is are they true and signi cant debts?
if the identi ed le groups only consume a small portion of overall maintenance e ort then they do not deserve much attention.
similarly if the identi ed le groups cover a large portion of the system itself it is not surprising if they also consume the majority of maintenance e ort.
in both cases we cannot claim that they are debts worthy of attention.
.
subjects we chose apache open source projects as our evaluation subjects.
these projects di er in scale application domain length of history and many other project characteristics.
they are camel a integration framework based on enterprise integration patterns cassandra a distributed dbms cxf a web services framework hadoop a framework for reliable scalable distributed computing hbase the hadoop distributed scalable big data store pdfbox a library for working with pdf documents and wicket a component based web application framework.
a summary of these projects is given in table .
the second column is the start to end time and the total number of months in parentheses for each project.
the third column r shows the number of releases selected per project.
we selected releases to ensure that the time interval between two releases is approximately months.
the column cmt is the number of commits made over the selected history.
the column iss is the number of bug reports extracted from the project s bug tracking system.
the last column shows the size range measured as the number of les in the rst and the last selected release.
.
analysis results to answer our research question we measured the amount of maintenance e ort spent on the archdebts we identi ed.
since we can not directly measure the amount of e ort in working hours or budgets we use error xing churn as an approximation the number of lines of code modi ed and committed to x bugs.
1for pseudo code of all algorithms see drexel.edu lx52 archdebt.html 493table subject projects su bject len gth of history mon r c mt i ss f iles c amel to to c assandra to to c xf to to had oop to to hba se to to p dfbox to to wi cket to to 12345678910111213141516171819202122232425262728percentage of total error fixing churn error churn associated with top archdebts hbase all patterns mv ad as hb figure debt churn consumption hbase we use hbase as an example to illustrate our observations.
figure shows the percentage of maintenance e ort associated with the les in filesets of all identi ed archdebts in hbase.
the x axis is the number from to of identi ed architectural debts.
the y axis is the accumulated percentage of maintenance e ort associated with the top x archdebts.
each line represents the percentage of each type of debt.
this gure depicts from bottom to top you can see hub anchor submissive anchor dominant and modularity violation debts respectively.
the line on the top is the total percentage of the types of debts.
the values of the top line are not simply the sum of the values of the types because di erent types of debts may share some les.
thus we make the following observations in hbase.
architectural debts consume a signi cant percentage of the total project maintenance effort.
a signi cant portion of the maintenance e ort is spent on paying interest on related groups of les.
if they can identify such debts early a project can save signi cant e ort by paying down the debts via refactoring .
as the number of debts increases the total does not reach because not all errors are architecturally connected.
occasionally developers introduce errors that can be xed in isolation.
the top few architectural debts consume a large percentage of maintenance e ort.
the top modularity violation debts in hbase consume of total e ort wherease allmodularity violation debts consume of total e ort.
similar observations hold for anchorsubmissive anchor dominant and hub debts.
the lines atten as the number of debts increases indicating that most of the e ort concentrates in the top few debts.
this means that instead of reviewing all identi ed debts project leaders only need to focus on the top few.
modularity violation debt is the most common and expensive debt.
hub debts consume the least percentage of e ort while anchor dominant and anchorsubmissive take similar percentages.
we can see that the line for modularity violation is close to the line for the sum of all types.
this is because modularity violation debtsinvolve the les in other debts as well.
we made consistent observations from all projects as summarized in table .
column all debts ch shows that for all projects from to of the total maintenance e ort is consumed by architectural debts.
and a large percentage to of the e ort is consumed by the top modularity violation debts shown in sub column ch under modularity vio .
modularity violation debts impact the largest number of les and consume the greatest e ort hub debts consume the least while anchorsubmissive and anchor dominant rotate their orders.
if a debt contains a large number of les it is not surprising that they take a large percentage of e ort.
we observed however that the top architectural debts contain only a small number of les but consume a large amount of the total project e ort.
we compare the number of les in the top architectural debts versus the percentage of e ort they take.
for example in table column modularity vio under top debts shows that in camel there are les of all the error prone les in the top modularityviolation debts and these les consume of the total project bug xing e ort.
similarly in camel the top anchor submissive anchor dominant and hub debts contain only and of the errorprone les but consume and of the total e ort respectively.
from the column all types under top debts we can observe that for all the projects the top architectural debts contain from only to of the error prone les but consume to of the total e ort.
the average ratio of percentage of e ort to the percentage of les in the top debts is .
finally we analyze the le size in lines of code of the debts we identi ed.
much research has shown that le size correlates with error rates and churn.
we would like to know that the debts identi ed by our approach are not just a set of large les.
to show this we counted the loc of the les in the top debts and observed that the sizes of these les are randomly distributed.
figure for example shows the le size distribution of the top modularity violation debts in cassandra.
the x axis is the range of le size means the top largest les means les in the range in loc and so forth.
the y axis is the percentage of les in the top debts that belong to each size range.
for example of the les in top debts are in the top largest les and of the les are in the range of range that is the smallest les .
the top debts do contain a non trivial number of large les from the top size range consistent with other studies showing that large les tend to be problematic.
but figure shows that the top debts contain les in allsize ranges.
in summary we can claim that the architectural debts identi ed by our approach are truly debts that account for a large amount from to of maintenance e ort.
most to of the maintenance e ort concentrates in the top architectural debts which contain only a small percentage to of the project s les.
.
discussion we now discuss which model best describes the interest rate of an archdebt and illustrate how our approach helps to understand and monitor the evolution of archdebts.
494table top debt files vs churn projectsall debts top debts ch all types modularity vio anchor sub.
anchor dom.
hub fls ch fls ch fls ch fls ch fls ch camel cassandra cxf hadoop hbase pdfbox wicket file loc distribution top mv debt cassandra figure top debts file size distribution cassandra .
the interest rate of archdebt for each archdebt we search for a suitable regression model to capture its interest rate as introduced in .
.
using r2 thresh of .
and .
respectively.
the results are reported in table .
the rst column is project name.
the second column is the number of instances of archdebt identi ed in a project.
the third and forth columns are model distributions for r2 thresh of .
and .
respectively.
when r2 thresh .
in all the projects about half to of the debts t a linear regression model with r2 .
.
for other debts where a linear model doesn t t a small percentage ts either a logarithmic to or exponential to model with r2 .
and a polynomial model ts to of the identi ed debts.
when r2 thresh .
the models are less noise tolerant.
we can see that linear model is still common to for all projects.
but a small portion of debts from hbase minus to pdfbox minus can no longer t into linear logarithmic or exponential models but t a polynomial model.
in summary when r2 thresh is .
the linear model is most common about half of the debts t into it.
this indicates that half of archdebts accumulate maintenance interest at a constant rate.
only a small portion of debts accumulate interest at a faster less than in exponential or slower less than in logarithmic rate.
about of the identi ed debts accumulate costs with a more uctuating rate which is captured by a polynomial model.
more archdebts t into a polynomial model as r2 thresh increases.
.
architectural debt evolution we showed in section that the top debts consume a large amount of e ort.
we manually inspected the evolution of these debts and now illustrate how architectural aws evolve into debts over time.
as an example consider the tophub debt with anchor le processordef referred totable debt costs model distribution p roject d sr2 thr eshold r2 thr eshold li n log ex p p oly li n log ex p p oly c amel c assandra c xf had oop hb ase p dfbox w icket aspdef in the following in camel figure .
we have provided snapshots of this debt in release .
.
age release .
.
age and release .
.
age to show its evolution.
snapshots from age to are similar to age .
ext and impl stand for extend and implement dp denotes all other types of structural dependencies.
in release .
.
pdef forms a hub with member les les are its subclasses les are its general dependents andpdef structurally depends on all of them.
note that in this snapshot all les except interceptstrategy depend on routecontext column .
the les in this hub structurally form a strongly connected graph.
according to the revision history pdef changes with all member les with probabilities from to column .
the dependents on rows to of pdef are highly coupled with each other.
this is problematic in ways the parent class pdef depends on each subclass and each dependent class unhealthy inheritance the parent class is unstable and often changes with its subclasses and dependent classes unstable interface .
routecontext forms cyclic dependencies with les cycles .
without xing these aws we expect the maintenance costs of this group to grow.
in release .
.
the impacts of this hub have enlarged pdef has more subclasses and more general dependents and it depends on each of them as well.
each newly involved le also depends on routecontext column .
the revision history shows that pdef changes with its subclasses and dependents with probabilities of to .
also the subclasses and dependents rows to of pdef are highly coupled with each other changing any of them is likely to trigger changes to the rest.
in following releases the hub grows further.
up to release .
.
pdef has subclasses and general dependents the size of the hub tripled compared to the start and as always pdef depends on each of them.
in addition of the general dependents rows to of pdef also become its grandchildren.
the inheritance tree has increased in width and depth.
the revision history shows pdef still changes with its dependents with probabilities from to .
the les in this snapshot are tightly coupled with each other and so changing any le is likely to trigger changes to others.
1processordef dpdp dpdp dp dp dp dp dp dp 2loadbalancedef ext dp dp 3choicedef ext dp dp 4rollbackdef ext dp dp 5routecontext dp dp 6marshaldef dp dp 7policydef dp dp 8trydef dp dp 9unmarshaldef dp dp 10error ref dp dp 11interceptstrategy dp a r .
.
age file churn 1processordef dp dpdp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp 2choicedef ext dp dp 3loadbalancedef ext dp dp 4rollbackdef ext dp dp 5oncompletiondef ext dp dp 6routedef ext dp dp dp 7onexceptiondef ext dp dp 8channel dp dp dp 9def dp implt dp dp dp 10todef dp dp 11threadsdef dp dp 12recipientlistdef dp dp 13routecontext dp dp dp 14marshaldef dp dp 15policydef dp dp 16trydef dp dp 17unmarshaldef dp dp 18error ref dp dp dp dp 19multicastdef dp dp 20interceptstrategy dp b r .
.
age file churn 1processordef dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp 2expressionnode ext dp 3catchdef ext dp dp dp dp dp 4choicedef ext dp dp dp dp 5loadbalancedef ext dp 6recipientlistdef ext dp dp dp dp 7wiretapdef ext dp dp dp 8aggregatedef ext dp dp dp 9resequencedef ext dp dp 10oncompletiondef ext dp dp dp dp dp 11loopdef dp ext dp 12throttledef dp ext dp dp dp 13i consumerdef dp ext dp dp 14whendef dp ext dp 15splitdef dp ext dp dp dp 16delaydef dp ext dp dp dp 17processor helper dp dp dp dp dp dp dp dp 18threadsdef dp dp dp 19otherwisedef dp 20routecontext dp 21policydef dp dp 22trydef dp dp dp dp dp 23transacteddef dp dp 24pipelinedef dp 25samplingdef dp 26multicastdef dp dp dp 27finallydef dp dp 28interceptstrategy c r .
.
age file churn figure camel hub debt evolution anchor processorde nition the maintenance costs spent on this debt t a linear regression model debtmodel rt rt with r2 .
this means that in every release developers contribute .
more lines of code to x errors in the hub anchored by pdef .
although this model can only be obtained after the costs and penalty have accumulated one could use our approach to detect architecture aw patterns at any point as described in monitor how le groups grow monitor the formation of debts and prevent signi cant costs by investing in proper refactorings .
.
related work technical debt.
since cunninghan coined the term tdhas referred to the consequences of short cuts taken in software projects to achieve near term goals.
during the past decade tdhas drawn increasing attention .
li et al.
conducted a mapping study on di erent categories of tdbased on related literature published between and .
they classi ed ten coarse grained tdtypes according to the phases of the software development life cycle such as requirements architectural and code.
they found that code tdis the most well studied type and architectural tdhas also received signi cant attention.
they further categorized architectural tdinto seven sub categories including architectural smells ar chitectural anti patterns complex architectural behavioral dependencies violations of good architectural practices architectural compliance issues systemlevel structural quality issues and all others.
tdcan compromise both functional and quality requirements such as performance security usability and modi ability.
alves et al.
organized types of tdand their key indicators including architectural td.
they described architectural tdas problems encountered in software architecture and referred to issues in software architecture structure dependencies analysis and modularity violations as indicators of architectural td.
their work focused on building an ontology of tdrather than focusing on resolving a speci c type of td.
everton et al.
proposed an approach to identify different types of self admitted tdin software projects by reviewing the comments left by developers.
they identi ed ve types of self admitted td design requirement defect test and documentation td.
according to their study the most common types of tdare design and requirement.
but as the name self admitted suggests the tdidenti ed in their work was limited to ones that the developers are aware of.
there are forms of tdintroduced unwittingly by developers such as the architecture debts we have identi ed.
martini et al.
conceptualized two patterns of archi496tectural td contagious debt and vicious circle.
contagious debt leads to ripple e ects in projects.
vicious circle refers to a more severe contagious debt where the ripple e ects form a loop.
their work has two limitations.
first it intensively relies on interviewing developers to identify these problems.
as stated above it is possible the developers are not aware of all the tdexisting in their project.
furthermore this approach is labor intensive and relies highly on the expertise of the analyst.
second this only identi es two anti patterns and these overlap with each other.
given the substantial research literature it is surprising that de nitions of the types of tdare still largely informal.
in fact the identi cation of tdrelies heavily on interviews or reviewing developers revision comments and these are only problems that the developers are aware of.
many questions in tdresearch remain open.
for example how to precisely de ne the forms of td how to automatically identify these forms of td and how to measure td its costs and consequences.
co change analysis an analysis of co changes in software projects at the package class method and statement level has been used to gain insight into problems in software development.
zimmermann et al.
applied data mining on revision histories to predict likely changes given a change that has already occurred.
kagdi et al.
proposed an approach to calculate the change impact scope of a software entity by combining structural coupling re ected in source code and change coupling recorded in the project s revision history.
their approach improved the accuracy of change impact analysis compared with either technique used independently.
gethers et al.
proposed an integrated approach to identify the impact set of a change request e.g.
a bug ticket in bug tracking database based on data mining of past source code commits and run time traces.
analysis of co changes has also been used in reverse engineering.
beck et al.
used co change analysis to compute clusterings.
they used an evolutionary class dependency graph to represent co change coupling.
they calculated three types of clusterings using only co change coupling only structure dependencies and a combination of the two.
they found that clustering based on the combined approach yielded the best results.
co change analysis has also been applied to investigate problems in software projects such as bugs and code smells.
kouroshfar et al.
investigated how co changes impact bugs.
they found that co changes dispersed across different sub systems are more likely to result in bugs than localized co changes.
girba et al.
used co change patterns to identify hidden dependencies between di erent parts of software system that reveal bad smells.
they de ned history patterns in three granularity levels method level class level and package level.
these patterns can reveal code smells such as similar code cloned code and shortgun surgery.
code smells have also been used as a heuristic for approximating td.
zazworka et al.
reported that not all tdapproximated by code smells will lead to high maintenance costs and not all tdhave code smells.
.
limitations and threats we now brie y discuss our limitations and threats to validity.
first since we have only examined projects and all of these are apache projects we can not guarantee that our results will generalize to other projects with di erentcultures and organizational policies.
second our approach has the limitation that it relies on revision history to identify architectural debt.
for projects without enough history data our approach can still identify groups of les with the potential to become architectural debt.
the building of a debtmodel relies on having adequate history data.
but our pattern matching approach is still feasible for projects with short history.
we plan to evaluate the e ectiveness of our approach on projects without enough history in our future work.
third our approach relies on mining error prone les from a project s revision history and bug tracking data.
we use the bug report id that developers enter into commits to locate error prone les.
the availability and accuracy of such information heavily depend on the project s protocols.
this is both a limitation and threat to validity to our approach.
finally we can t guarantee that error xing churn is the best proxy measure for e ort.
in our future work we plan to explore more e ort proxies and we are collaborating with an industry project that records actual e ort data and we plan to compare this with our proxy measures of e ort.
.
conclusion to quantify and manage architectural td we formally dened the concept of architectural debt and then described an approach to automatically identify such debts to measure their maintenance consequences and to model their growth.
we proposed a novel history model the hcp matrix to approximate the probabilities of change propagation among les and de ned patterns based on the hcp matrix to capture problematic architectural connections among les.
we evaluated our approach on large scale apache open source projects and the results showed that a signi cant portion to of overall maintenance e ort was consumed by paying interest on architectural debts.
this suggests that projects could save a signi cant amount of maintenance costs if they can discover these debts early and pay them down by refactoring.
the top architectural debts in each of the projects consume a non trivial portion to of each project s maintenance e ort but they only contain a small portion of each project s error prone les to .
thus investing in refactoring small groups of les could reap large bene ts.
finally we quanti ed the growing trend of maintenance costs for each debt.
about half of the debts grow linearly meaning that developers pay a consistently increasing penalty on these debts in every release.
and using dsms we qualitatively illustrated how architectural issues connect more les incur more maintenance costs and evolve into debts over time.