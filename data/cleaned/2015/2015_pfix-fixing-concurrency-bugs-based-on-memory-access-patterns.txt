pfix fixing concurrency bugs based on memory access patterns huarui lin school of computer software tianjin university tianjin china linhuaruitju tju.edu.cnzan wang school of computer software tianjin university tianjin china wangzan tju.edu.cnshuang liu school of computer software tianjin university tianjin china shuang.liu tju.edu.cn jun sun singapore university of technology and design singapore sunjun sutd.edu.sgdongdi zhang school of computer software tianjin university tianjin china zhangdongdi tju.edu.cnguangning wei school of computer software tianjin university tianjin china weiguangning tju.edu.cn abstract concurrency bugs of a multi threaded program may only manifest with certain scheduling i.e.
they are heisenbugs which are observedonlyfromtimetotimeifweexecutethesameprogram withthesameinputmultipletimes.theyarenotoriouslyhardto fix.
in this work we propose an approach to automatically fix concurrencybugs.comparedtopreviousapproaches ourkeyideais tosystematicallyfixconcurrencybugsbyinferringlockingpolicies from failure inducing memory access patterns.
that is we auto matically identify memory access patterns which are correlated with the manifestation of the bug and then conjecture what is the intended locking policy of the program.
afterwards we fix theprogram by implementing the locking policy so that the failureinducingmemory accesspatternsaremadeimpossible.wehave implemented our approach in a toolkit called pfix which supports java programs.
we applied pfix to a set of concurrency bugs andareabletoautomaticallyfix19ofthem.incomparison grail which is the state of the art tool for fixing concurrency bugs in java programs can only fix of them correctly.
ccs concepts software and its engineering software testing and debugging keywords multi threading concurrency bugs memory access pattern locking policy automatic fixing corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
reference format huaruilin zanwang shuangliu junsun dongdizhang andguangning wei.
.
pfix fixing concurrency bugs based on memory access patterns.
inproceedings of the 33rd acm ieee international conference on automated software engineering ase september montpellier france.acm newyork ny usa 12pages.
introduction multi threadingisubiquitousnowadayswith thedevelopmentof multi coreandmany coreprocessors.concurrencybugs ofamultithreaded program are bugs which may only manifest with certain scheduling i.e.
theyareheisenbugswhichmayonlybeobservedif we execute the same program with the same input multiple times.
theyareknowntobehardtodebug .thedifficultyinfixing concurrent bugs is at least threefold.
firstly it is challenging to replay a concurrency bug.
even with the right test input we must find a failure inducing scheduling as the bug may manifest only with certain scheduling.
in general there could be exponentially manyschedulingsinthenumberofschedulablepoints.researchers havetackledthisproblembyrecordingtheschedulingduringatest executionsothatthebugcanbereplayed .secondly even withtherecordedscheduling debuggingthemulti threadedbug maystillbechallengingduetothelargenumberofstepsandcontext switches in the test execution i.e.
the execution of the test case with particular scheduling many of which may not be relevant to thebug.aprogrammermustbeableto abstract thetestexecutionsoastoidentifytherootcauseofthebug.recently therehavebeen several proposals on abstracting a test execution using memory access patterns.
it has been shown that memory access patternsare often correlated to the presence of multi threaded bugs .
thirdly itischallengingtofixconcurrencybugsasafixmustbe able to avoid the bug with all possible scheduling.
in this work we investigate the problem of fixing concurrent bugs.
there have been multiple methods and tools proposed forfixing concurrency bugs .
existing approaches fix concurrent bugs resulting in either atomicity violations deadlocks ordataraces .roughlyspeaking existing approaches design their fixes based on a few concrete execution traces which are either obtained fromuser provided bug reportsor authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france h. lin z. wang s. liu j. sun d. zhang g. wei fromruntimemonitoring.wereferthereaderstosection 5fora detailed discussion on existing approaches.
inmostofthecases thefixinexistingapproachesamountsto inserting additional locks and synchronization to inhibit the bad concreteexecutions.in contrary ourapproach isdesignedtosystematicallyfixconcurrencybugsbasedoninferringtheintended lockingpolicy whichallowsustoreuseexistinglocks .asstated in and other places the key to reduce concurrency bugs and ensure thread safety is to design a locking policy according to the program specification.
for instance a well designed locking policymustguardthesamevariablewiththesamelockthroughout theprogramandmustguardrelatedvariableswiththesamelock throughoutthe program.onlybyimplementing awell designed lockingpolicysystematicallythroughouttheprogram wecanguarantee thread safety and thus free of concurrency bugs.
ideally ifthe locking policy is explicitly documented we can fix a concurrencybugbyexaminingwherethelockingpolicyisnotcorrectly implementedand fixit accordingly.in practice howeversoftware engineersoftendonotdocumentthelockingpoliciesproperly.the challenge is then how to infer the locking policy and subsequently fix concurrency bugs systematically.
ourapproachisdesignedasfollows.firstly weapplyexistingapproachestosystematicallyidentifyfailure inducingmemory access patterns with regard to a concurrency bug.
the idea of correlating bugswithmemory accesspatternshasbeenexploredin .
it has been found that memory access patterns are often correlatedwith theroot causeof concurrencybugs .in oursetting the failure inducing memory access patterns represent violationof the locking policy which ought to be implemented systematically to prevent the bug.
afterwards we automatically conjecture what is the intended locking policyof the program.
the idea is to identify a well designed locking which makes the failure inducing memory access patterns impossible.
the last step of our approach is to systematically fix the program by consistently implement ing the conjectured locking policy throughout the program.
our approach is different from those existing approaches on fixing concurrency bugs as our fixes are based on a comprehensive set of failure inducing memory access patterns which have been shown to be complete whereas existing approaches are often based onconcreteexecutionsorparticularpatternslikesingle variable atomicity violation.
furthermore our fixes work through consistentlyimplementingwell formedlockingpoliciesandthusnotonly fixthoseprogramexecutionswhichhavebeenobservedbutalso potentiallythoseunseenones.itisourbeliefthatlockingpolicies should play a central role in building thread safe programs and thus should be the basis of fixing concurrency bugs.
our approach has been implemented in a self contained toolkit called pfix short for pattern based fix for java programs.
pfix is implemented based on existing frameworks including java pathfinder and soot .
we have experimented pfix with a set of concurrency bugs which we collect from previously published repositories.
pfix is able to automatically fix of them.
on average pfixspends33.7secondstofixabug whichweconsideris reasonablyefficient.forbaselinecomparison weapplygrail tothesamesetofbugsanditisonlyabletofix3ofthebugs.we remark that other previously reported tools are either not maintainedortargetdifferentprogramminglanguages e.g.
afix public synchronized stringbuffer append stringbuffer sb if sb null sb null fix synchronized sb .
int len sb.length int newcount count len if newcount value.length expandcapacity newcount .
sb.getchars len value count fix count newcount return this public synchronized stringbuffer delete int start int end if start throw new stringindexoutofboundsexception start if end count end count if start end throw new stringindexoutofboundsexception int len end start if len if shared copy system.arraycopy value start len value start count end .
count len return this public synchronized void getchars int srcbegin int srcend char dst int dstbegin if srcbegin throw new stringindexoutofboundsexception srcbegin if srcend srcend count .
throw new stringindexoutofboundsexception srcend if srcbegin srcend throw new stringindexoutofboundsexception srcbegin srcend system.arraycopy value srcbegin dst dstbegin srcend srcbegin figure a concurrency bug in jdk1.
.
axis and cfix .
furthermore it has been reported that grail is stricter better than afix and axis in .
the remainders of the paper are organized as follows.
section illustrates how our approach works through an example.
section presents the details of our approach step by step.
section 4evaluatesourapproach.section 5discussesrelatedworkandsection concludes.
motivating example in this section we show how our approach works with an illustrative example.
the example is a concurrency bug in the stringbuffer class in jdk1.
.
.
figure1shows the relevant part of the programundertest i.e.
threemethodsofthe stringbuffer class.method appendappendsagivenstringbuffertotheendof thisstringbuffer methoddeletedeletes a substring from index startto indexend fromthisstringbuffer andmethod getcharscopiesfrom thisstring buffer into the destination character array dstwith offset dstbegin.
notethatmethod appendcallsgetchars throughtheinputstring buffersb.
all three methods are synchronized.
atestcasewhichpotentiallyrevealsthebugisshowninfigure .
in the test case two string buffer objects aandbare created and two threads are created one executing a.append b while the other executing b.delete b.length .executingthetestcasemanytimes we might observe a stringindexoutofboundsexception srcend due toline3inmethod getchars.oneconcreteexecutionwhichgeneratesthisexceptionisasfollows.first onethreadexecutesline 1inmethod a.append b togetstringbuffer b slength whichis5.
afterwards theotherthreadexecutesmethod b.delete todelete everycharin b.asaresult b scountbecomes0.next thethread authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pfix fixing concurrency bugs based on memory access patterns ase september montpellier france table memory access patterns in the example memory access pattern susp.
t1 l1 count t2 l4 count t1 l3 count .
t1 l1 count t2 l4 count .
t2 l4 count t1 l3 count .
executingmethod a.append b callsmethod b.getchars atline2 withlenbeing .
when method b.getchars is executed condition srcend count which is is satisfied and thus the exception is thrown.
althoughtherecouldbemanyconcreteexecutionswhichgeneratetheexception wecanabstractlyseethattheexceptionoccurs as long as the following memory access pattern is present thread executes line then thread executes line and then threads executes line to update the same variable count.
in our approach pfix systematically analyzes multiple failing and passing concrete executions in order to automatically identify a list of ranked abstractmemory accesspatternsinordertoidentifytherootcause of the bug.
there are a total of generic patterns and pfix scans througheachconcreteexecutiontocountthenumberoftimesthat an instance of those patterns occurs.
table 1shows the three patterns generated by pfix for this example where l1 l2 l3 andl4 denoteline1 3and4respectively.eachpatterniscomposedofa sequence of steps of the form t s r w which reads thread texecutes instruction sto read variables in rand write variablesin w. notethatthefirstpatternmatchesourunderstanding whereasthe other two are patterns which capture only part of the first pattern.
pfix computes a suspicious score for each pattern based on how frequent they appear in failed executions and passed executions.
the second column of table 1shows the respective suspicious scores.notethatthefirstpatternisalwaysobservedinfailedtest executions and thus has a suspicious score of .
onceweidentifythefailure inducingmemory accesspatterns i.e.
the onesintable weproceed togeneratea fixforthe bug based on the most suspicious pattern first.
for different genericpatterns we have designed different fixes.
according to our bug fixingalgorithm whichwillbepresentedindetailinsection the fix for this step pattern is to add additional synchronization so thatthefirststepandthethirdstepareinthesamesynchronizationblock.intuitively suchafixwouldmakethismemory accesspattern impossibleandthuspreventthebug.thequestionis whichlock object do we use?
to answer this question pfix systematically monitors all concrete executions in order to identify the locking policy.thatis pfixmonitorseachsharedvariableandrecordwhich lock is held when the variable is accessed for either reading or writing .
in this example pfix observes that variable b.countis accessedalwayswithlock bheldandvariable a.countisaccessed always with lock aheld.
it thus conjectures that countin the class is to be guarded by thisaccording to the locking policy.
based on this locking policy pfix then proceeds to analyze whetheritispossibletointroducea synchronized blocksynchronized sb whichenclosesbothline1and3.notethatthelockobject issbsince both line and line access sb.count.
as line and are in different methods it is infeasible to introduce a synchronized blockdirectly.pfixthenanalyzesthecallgraphinordertoidentify acommonmethodwherethe synchronized blockcanbeintroduced.public void test stringbuffer a new stringbuffer hello stringbuffer b new stringbuffer world new thread new runnable public void run a.append b .start new thread new runnable public void run b.delete b.length .start figure a test case for stringbuffer inourexample becauseline3isexecuteddue tothefunctioncall atline2andline1andline2areinthesamefunction pfixthen proceedstointroducea synchronized blockwhichbeginswithline1 andendswithline2 asshowninfigure 1intheformofcomments.
lastly wevalidatethefixedprogramthroughstandardmeans i.e.
extensive testingor usingtools likejavapathfinder and repeat the above discussed steps if necessary.
details of the approach inthissection wepresentdetailsofeachstepinourapproach.the input to pfix is a buggy program as well as a set of executions of a given test case which can be obtained through standard means .
we assume that at least one of the test executions results in failure so that we know there is a concurrency bug .
.
step identify memory access patterns the first step is to identify the failure inducing memory access patterns.
the reason that we focus on memory access patterns is that memory access patterns are often correlated to bugs as shown in .
an alternative is to focus on failure inducing scheduling which is not ideal for multiple reasons.
firstly there mightbeahugenumberofschedulingandmanyofthemmaybe failure inducing.
identifying all of them would be expensive if not infeasible.
secondly even if we are able to identify all of them it is not clear how to fix the program so that all of them are prevented.
in comparison concurrency bugs can be always reduced to one or multiple of a total of generic memory access patterns as shown in .
the idea is to design fixes for each and every one of the patterns so that we can fix concurrency bugs systematically.
amemoryaccesspatternisrepresentedintheformofasequence ofstepsofatestexecution.eachstepisatupleof t s r w where tisathreadid sisabytecodeinstructiongeneratedbyastatement inthe program risa setof variablesbeingread and wisa setof variablesbeingwritten.givenabytecodeinstruction s wewrite ori in s to denote the program statement which generates the bytecode.
in this work we adopt the set of memory access patternsdefinedin shownintable .thesecondcolumnof thetableshowsthememory accesspattern.eachmemory access pattern is a sequence of at most four steps in the test execution whichconcernsonlywithtwothreadsandatmosttwovariables.
asaresult givenatestexecution thenumberofmemory access patterns is bounded by c2 n c2 m c4 kwherenis the number of shared variables mis the number of threads and kis the total number of steps in the test execution.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france h. lin z. wang s. liu j. sun d. zhang g. wei table the generic memory access patterns idmemory access pattern ta si x tb sj x ta si x tb sj x ta si x tb sj x ta si x tb sj x ta sk x ta si x tb sj x ta sk x ta si x tb sj x ta sk x ta si x tb sj x ta sk x ta si x tb sj x ta sk x ta si x tb sj x tb sk y ta sl y ta si x tb sj y tb sk x ta sl y ta si x tb sj y ta sk y tb sl x ta si x tb sj x tb sk y ta sl y ta si x tb sj y tb sk x ta sl y ta si x tb sj x tb sk y ta sl y ta si x tb sj y tb sk x ta sl y ta si x tb sj y ta sk y tb sl x ta si x tb sj y ta sk y tb sl x it has been shown that these memory access patterns capture the essence of multi threaded bugs .
in addition it is shown thatthissetiscomplete asmulti threadedbugscanbereduced to one or more of these patterns.
the memory access patterns can be viewed as an abstraction of the test execution which allows us to get rid of irrelevant details and yet preserve the cause of the multi threaded bug.
based on the frequency of the memory access patterns in the testexecutions wecalculateasuspiciousnessscoreforeachpattern using equation where fail p is the number of failing test executionsinwhichthepattern poccursand succ p isthenumber of passing test executions in which the pattern poccurs.
suspicious p fail p fail p succ p the larger the suspicious score the more likely that the pattern isfailure inducing.therefore wesortthepatternsbasedontheir suspicious scores in the descending order.
.
step identify locking policy once the failure inducing memory access patterns have been identified we proceed to identify the locking policy on the relevant variables.theideaistocheckiftherearelockingpoliciesdesigned forthevariablesandwhetherthereasonofthebugisthatthelockingpolicyhasnotbeenimplementedproperlyonthepartwhere the failure inducing memory access pattern is observed.
formally a locking policy is a function lockp v lwherevis the set of variables and lis the set of locks.
note that we assume that a variable should be guarded by exactly one lock following the discussion in .
we use lockp x yto denote that variable xis guarded by lock y. a locking policy is consistently implemented if andonly ifeveryaccessof any xisguarded byalockon lockp x throughout the program1.
inourapproach weinferthelockingpolicydynamically.thatis wemonitoratruntimewhenalockisheldandreleasedforeachtest execution.foranyvariable x wethenobservewhetheritisaccessed 1except the constructors since they are handled differently in java.
either for reading or writing while some lock yis being held.
we may observe that multiple locks are held while xis accessed in which case lockp x could be any of the held locks or even none of them if we assume that the locking policy is not consistently implemented.ingeneral wecanobtainabagofobservationsinthe form of x y wherexis a variable and yis a lock.
afterwards we heuristicallyconjecturethat lockp x isyif x y occursmorethan anyotherpairs x z inthebag.forinstance intheexampleshown insection weobtain count this foreveryaccessof countinthe class and thus conclude lockp count isthis.
we remark that another way to obtain the locking policy is throughstaticanalysis i.e.
staticallyanalyzewhenalockisapplied andreleased aswellasthevariablesaccessedinbetween.however compared to dynamic analysis static analysis may suffer from imprecision due to aliasing dynamic typing etc.
therefore in our work weadoptdynamicanalysis whichprovidesmoreaccurate results.
.
step fix bugs afterobtainingthelockingpolicy wethenexamineeachfailureinducing memory access pattern from the most suspicious to the least and see whether the bug is due to an inconsistent implementation of the locking policy or rather the locking policy itself isproblematic.
in the following we discuss how a bug is fixed for eachfailure inducingmemoryaccesspattern.thegeneralideais to design a fix such that the corresponding memory access pattern would be avoided.
the algorithm is presented as algorithm whichtakesasinputthefailure inducingpattern patternandthe lockingpolicy lockpwhichwehaveinferredinthepreviousstep.
the algorithm to fix bugs according to memory access pattern to to and to of table a r es h o w nf r o ml i n e1t o9 0t o1 and to of algorithm respectively.
line1to9inalgorithm 1appliesif patternismemory access pattern1to3intable .allofthesepatternshavetwosteps where two different threads read write on a shared variable in certainorder.
they are fixed in the same way.
in the following we use the pattern ta si x tb sj x pattern in table a s an example to illustrate the fix.
to make sure that these two steps are separated in the fixed program we distinguish two cases in fixing the bug.
the first case is that siis not the last access of xin ori in si whichisthesourcecodestatementcontaining si orsj isnotthefirstaccessof xinori in sj .insuchacase weassume thatthebugcanbeavoidedif ori in si isfinishedbeforethread tb preempts it or the other way around.
to achieve that we examine whetherlockp x isdefined.ifitisthecase weenclose ori in si andori in sj in a synchronization block with lock lockp x .i f lockp x is not defined we introduce a new lock l and implement thelockingpolicybyenclosingeveryaccessof xwithalockon l. notethatthesamelockingpolicyshouldbepropagatedthroughout the program for all accesses of x not only those statements in the pattern.ifhowever siisthelastaccessof xinori in si orsjisthe first access of xinori in sj we conclude that the bug occurs if stateori in si is followed by ori in sj and this can not be fixed withamodifiedlockingpolicyon x.thefixisthentopreventsuch ordering.thisisachievedbyintroducingafreshvolatileboolean variablezwithinitialvaluefalse adding if z beforeori in si and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pfix fixing concurrency bugs based on memory access patterns ase september montpellier france algorithm algorithm fix pattern lockp input pattern a failure inducing pattern lockp a locking policy the buggy program output the fixed program based on lockp 1ifpattern is any of pattern in table 2then 2if ta si x is not the last xaccess ofori in si or tb sj x is not the first xaccess ofori in sj then iflockp x does not exist then setlockp x lwherelis a fresh lock and enclose ori in si andori in sj with synchronization on l else encloseori in si and orori in sj with synchronization on lockp x 7else introduce a fresh volatile boolean variable zwith initial value false addif z beforeori in si and addz trueafterori in sj 10ifpattern is any of pattern in table 2then 11iflockp x does not exist then setlockp x lwherelis a fresh lock and enclose ori in sj and enclose ori in sj i andori in sk in the same block with synchronization on l 13else encloseori in sj and enclose ori in sj i andori in sk in the same block with synchronization on lockp x 15ifpattern is any of pattern in table 2then 16iflockp x does not exist and lockp y does not exist then setlockp x lwherelis a fresh lock and enclose the two steps of tain the same block with synchronization on l enclose the two steps of tbin the same block with synchronization on l 19else iflockp x does not exist then setlockp x lockp y enclose the two steps of tain the same block with synchronization on lockp y enclose the two steps of tbin the same block with synchronization on lockp y 23else iflockp y does not exist then setlockp y lockp x enclose the two steps of tain the same block with synchronization on lockp x enclose the two steps of tbin the same block with synchronization on lockp x 27else setlockp x lockp y and and apply the locking policy for every access of xandy .voidtest throwsexception .finaldd new d .
thread d1 newthread public void run d.m1 .
thread d2 newthread public void run d.m2 .
d1.start d2.start .
d1.join d2.join .if d.x assert false d.x classd .intx .voidm1 x .voidm2 x figure an example illustrating repairing addingz trueafterori in sj .
intuitively it is then guaranteed thatori in sj must be completed before ori in si .
toillustratethe differencebetweenthesetwocases letuslook at the example shown in figure .
note that line and line both have two accesses i.e.
one read followed by one write of variableclassd intx object obj newobject voidm1 synchronized obj x voidm2 synchronized obj x figure4 anexamplerepair case1 forprograminfigure classd intx volatile bool flag false voidm1 x flag true voidm2 if flag x figure5 anexamplerepair case2 forprograminfigure x. given the assertion at line one failure inducing pattern which could be identified is d1 l91 d.x d2 l102 d.x .
intuitively itmeansthatthread d2executes m2firstandthread d1reads d.xbefored2finishesexecutingline10.since d1 l91 d.x is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france h. lin z. wang s. liu j. sun d. zhang g. wei notthelastaccessof d.xbythread d1 applyingtheaboverepairing strategy we fix the program by introducing a fresh lock and surrounding both line and with a synchronization block.
this is shown in figure .
ifwechangetheconditionatline7tobetheoneinthecomment d.x one failure inducing pattern which could be identified is d2 l102 d.x d1 l91 d.x whichisaninstanceofpattern2intable .intuitively itmeansthatthread d2executes m2to finishfirstandthread d1executes m1.notethatthememoryaccess patterninthepreviousparagraphisnolongerfailure inducing.the reason is that the assertion failure will be avoided only if thread d1finishesexecutingline9beforethread d2startsexecutingline .
in this case since d2 l102 d.x is the last access of d.xby threadd2 and d1 l91 d.x is the first access of d.xbyd1 applyingtheaboverepairingstrategy wefixtheprogramasshownin figure5.notethat fla isdeclared volatilesoastoavoidvisibility issues due to caching .
the fixes for patterns to are the same as shown in line to 14inalgorithm .intuitively thesefailure inducingpatternscan be prevented if we prevent thread tbfrom executing in between siandsk.
thus the idea is to implement a fix such that siand skareinthesamesynchronizationblock.therearetwocasesto fix the bug.
if lockp x does not exist i.e.
there lacks a locking policy for x we introduce a new lock land enclose siandskin the same synchronization block with lock l and enclose sjwith a synchronization block with lock las well.
note that by right thisnewlockingpolicyon xmustbepropagatedthroughoutthe program.if lockp x doesexist weapplythesame fixusinglock lockp x instead.
the fixes for pattern to are also the same.
intuitively these patterns can be prevented if we implement a fix such that the two steps of thread taandtbin these patterns become atomic.
the remaining question is then which lock to use.
note that becausethese patterns are failure inducing we would assume that xand yarerelatedandthereforethelockingpolicyshouldbesuchthat lockp x lockp y .
we distinguish four cases on fixing the bug.
ifbothlockp x andlockp y arenotdefined weuseafreshlock lto fix the bug.
otherwise if either lockp x orlockp y is defined we use the associated lock to fix the bug.
lastly if both lockp x andlockp y aredefinedbut lockp x nequallockp y weset lockp y to belockp x to fix the bug.
these four cases are handled accordingly in algorithm i.e.
line handle the case where no locking policies for xoryexist line handle the case where one locking policy exists either for x line or y line but not both and line handle the case where lockingpoliciesexistforboth xandy.notethatpfixisdesigned to fix concurrency bugs using synchronization blocks instead oflocks i.e.
java.util.concurrent .locks as synchronization blocks are easier to maintain.
.
step fix the fixed program after the last step we have applied a fix according to the failureinducing memory access pattern and transformed the program to geta fixed version.next weapplyafurthersteptofixthe fixed program.
this step has two main goals.
one is to propagate theupdated locking policy throughout the program.
the other is tomakesurethetransformedprogramisnotonlycompilablebutalso efficient e.g.
without redundant locking .
topropagatetheupdatedlockingpolicy foreachsharedvariable x we analyze the program systematically to identify part of the program which accesses x. for each access we analyze whether theaccessisguardedbyalockbymonitoringwhatarethelocks which are held and not released before executing that part of theprograminallthetestexecutions.letthesetoflocksheldbe denotedas l.wethencheckwhether lincludeslockp x whichis thelockforguarding xaccordingtotheidentifiedlockingpolicy.if it is we do nothing.
otherwise we introduce a synchronized block toenclosethepartoftheprogramwithalockobject lockp x .this way wemakesurethelockingpolicyissystematicallyimplemented throughout the program.
note that because our implementation is based on dynamic analysis we will not propagate the locking policy to the part of the program which is never executed in the test executions.
as demonstrated in section we may not always be able to applythefixaccordingtoalgorithm .forinstance twostatements whichwewouldlikeencloseinthesame synchronized blockmay be scattered in two very different parts of the program.
we thus applyanapproachsimilarto tomakesurethefixedprogram is syntactically correct.
that is we use eclipse ast to check thescope of each synchronization block.
if we find that the addedsynchronization crosses the original block of statements in the program i.e.
ifstatement forloopandwhileloop weadjustthe scope of the added synchronization block so that it can include theentireblockofstatements.ifweneedtoaddsynchronization blocksintwodifferentfunctions wefirstusesoottoidentifythe call function and then find the right place to add synchronization so that the two statements are in the same block.
in order to avoid redundant locking if we find that the added synchronization block is in a constructor function we discard the added synchronization.
.
step test the fixed program asthe laststep wetestthe fixedprogramby usingjpf torunthe fixedprogram100times.werepeatthefixingprocessifthereare errorsoccurduringthetesting.thenumber100ischosenbasedon our experience that a program found to have errors during manual inspections can almost consistently expose errors by executing times with jpf random scheduling.
.
overall algorithm the overall algorithm of our approach is shown in algorithm .
given a buggy program and a test case we run the test case many times in order to obtain a set of concrete test executions.
in our implementation weusejavapathfindertogeneratedifferentscheduling.next werunthestate of the artapproachunicorn to obtain a ranked list of potential failure inducing memory accesspatterns line .
then we infer locking policies dynamically asdiscussed above line .
after the locking policy is obtained wefix the concurrency bug based on our fixing algorithm shown in algorithm line6 .afterapplyingthefixing weapplystep4to fix the fixed program.
lastly we test the fixed program i.e.
run theprogram100timeswiththehelpofjavapathfinder tocheck whetherthebugisindeedfixed line8 .ifallthe100testexecutions authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pfix fixing concurrency bugs based on memory access patterns ase september montpellier france algorithm overall algorithm input a buggy program and a test case output a fixed program 1whiletruedo 2test the buggy program to obtain a set of test executions 3obtain a ranked list of failure inducing pattern p step 4select and remove the most suspicious pattern p 5identify locking policy lockpforp step 6fix p lockp step 7fix the fixed program step 8test the fixed program step 9ifno failure is generated then break figure the overall structure of pfix pass we conclude that the bug is fixed and the algorithm terminates line .
if there are still failures observed during the test executions we repeat the above process.
implementation and evaluation in thissection wediscuss theimplementation detailsof pfix and the evaluation results.
.
implementation the proposed method has been implemented in a self contained toolkit called pfix.
pfix has a total of line of codes and thesource code is available online at .
the overall structure of pfix is shown in figure .
pfix is implemented based on java pathfinder soot eclipse ast and unicorn .
pfix utilizes java pathfinder and unicorn to automatically detect shared variables among multiple threads and provides shared memory accessinformationatruntimeinstep1.unicornisusedtoautomaticallyidentifya rankedlistofsuspicious memory accesspatterns.
basedonthepatternsthatisobtainedfromstep1 pfixidentifies the corresponding locking policies based on java pathfinder and unicorn in step .
then pfix implements our fixing method by utilizing soot and eclipse ast.
soot is a java optimization framework.
in this work we use it to obtain the function call graph of a given program.thefunctioncallgraphisnecessaryinourapproachtohandlecasesinwhichstatementsofamemory accesspatternare in different functions.
in such a case a call graph generated bysoot which allows us to identify the right scope for introducingsynchronized block.
eclipse ast a part of eclipse jdt is used to analyze the program syntactically find the location that the fix patch should be inserted and then fine tune the patch if the added patchresultsincompilationerrors.inthelaststep pfixteststhe fixed program using java pathfinder eclipse ast and unicorn.
.
evaluation settings our evaluation subjects include concurrency bugs in java programs from multiple existing benchmarks including the sir repository pecan s benchmark programs and jacontebe .
notethatduetolimitationsofjavapathfinder unabletoexecute largejavaprograms wearenotabletoapplypfixtoalltheconcur rencybugsinthebenchmarks.intotal wesuccessfullyappliedpfix to concurrency bugs to test our fixing method.
the programs are chosen based on the following reasons.
firstly our methodfocuses on fixing concurrency bugsin java.
therefore we targetprograms which are written in java and are known to have concurrency bugs.
secondly our approach adopts java pathfinder for bug localization and repair.
we thus focus on programs which javapathfindercanhandle .informationontheseconcurrencybugsare summarized in table .
the actual programs are available in our github repository .
inthefollowing weevaluatepfixintermofitseffectivenessand efficiency.allourexperimentresultsareobtainedonacomputer with3.40ghzcpu 16gbmemory.weusewindows10andjdk .
.
for each concurrency bug we first run java pathfinder timestoobtaintestexecutions whichincludebothfailingonesand passing ones .
unicorn is then executed times to obtain memory access patterns in the test executions.
afterwards we apply our approach for fixing the bug as discussed in algorithm based on the most suspicious pattern.
after fixing the bug we run javapathfinder100timesinordertodeterminewhetherthebug has been fixed.
in addition we run random testing times on thefixedprograminordertofurthertestit.ifnobugisreported we conjecture that the bug has been fixed.
otherwise we obtain suspicious patterns and repeat our approach until either we fix the program or run out of suspicious patterns.
for each fixed program wethenmanuallyinspectwhetherthebugistrulyfixed.wetakethe original fix as a reference to check whether pfix fixes the program correctly.
.
evaluation results theevaluationresultsareshownintable .thefirstthreecolumns showthenameoftheprograms thenumberlinesofthenativecode excluding the invoked library and the bug type e.g.
atomicity violation data race consistency bug .
columns to show the evaluationresultswithpfix includingthetime inseconds used to identify the potential failure inducing memory access patterns the time used to fix the bug the number of locks added in order to 2in the future we plan to replace java pathfinder with an approach based on code instrumentation so that our approach is more scalable.
3we use unknown to indicate that the root cause of the bug is complicated and it is hard to classify it into existing types authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france h. lin z. wang s. liu j. sun d. zhang g. wei table evaluation results time is measured in seconds program name line typepfix grail time for patterns time fixing lockfix status time fixing s lockfix status account 102atomicity violation .
.
1success 5success accountsubtype 138atomicity violation .
.
1success 4success airline 51atomicity violation .
.
1success na na na alarmclock unknown .
.
na fail na na na atmoerror data race .
.
1success fail buggyprogram 258atomicity violation .
.
2success fail checkfield 41atomicity violation .
.
2success na na na consisitency 28consistency bug .
.
1success na na na critical 56atomicity violation .
.
2success fail datarace data race .
.
1success na fail even 49atomicity violation .
.
1success fail hashcodetest 258atomicity violation .
.
1success fail linkedlist 204atomicity violation .
.
1success na fail log4j atomicity violation .
.
1success na na na mergesort unknown .
.
na fail fail pingpong data race .
.
1success na na na pool unknown .
.
na fail na na na producerconsumer unknown .
na fail fail reorder2 consistency bug .
.
1success na na na store 44atomicity violation .
.
1success na na na stringbuffer 416atomicity violation .
1success na fail wronglock 73atomicity violation .
.
1success 3success wronglock2 data race .
.
1success fail fixthebugandthefixingstatus successorfail .foreachfix we manuallycheckwhetherthefixiscorrectornot.thedatashows that pfix is able to fix out of in the benchmark.
there are fourcaseswhereourmethodisnotableto completely fixthebug.
we analyze them one by one in the following.
inthecaseofthe producerconsumer program theoriginalprogram tries to guard a static shared variable with a lock on this object.suchalockingpolicyisproblematicastherearemultiple instances of the class in the program and different threads lock on differentthisobjectsbeforeaccessingthestaticvariable whichis as good as no locking at all.
pfix is able to detect this ill formed locking policy and successfully fix it using a shared lock.
however there is a further issue in the program.
that is if the consumer threads are very fast there will be one producer thread waiting forever.
the reason for this issue is that the main method proceeds to check the result i.e.
an assertion without waiting for all producerstofinish.althoughitispossibleforpfixtofindtherelevant failure inducing memory access pattern for this issue and fix it through line in algorithm pfix times out without success.
for the case of the alarmclock program and the poolprogram we manually analyse the source code and found that pfix failed to find therealfailure inducingmemory accesspattern.thisispossible sincethetestexecutionsarerandomlygeneratedandthustheright failure inducing pattern may not always be the most suspicious.forthemergesort program theidentifiedpatterniscomposedof statements from multipleclasses.
pfix fixed the programby introducing a shared static object and adding a synchronized block for each statement in the pattern which unfortunately introduced a deadlock.ingeneral itispossibletointroducedeadlocksaspfixsometimesintroducesadditionalsynchronization.suchproblems can be solved using existing approaches on fixing deadlocks which we leave as future work.
forabaselinecomparison weapplygrail whichisthestateof the art concurrency bug fixing tool for java programs on the sameset ofbenchmarks.
we remarkthatother previously reported tools are either not maintained or target different programming languages e.g.
afix axis andcfix .furthermore it has been reported in that grail is stricter better than afix and axisoverasetofbenchmarks.theresultsofgrailareshownin thelastthreecolumnsoftable .grailisbuiltbasedonpecan whichisatoolfordetectinggeneralaccessanomalies aas inconcurrent programs.aas are similarto thememory access patterns.
pecan generates aas of length to .
our inspection of grail s source code shows that grail is designed to only fix programs with length3aas i.e.
atomicityviolation .amongallthe23programs inourbenchmark only4programs i.e.
account accountsubtype wronglock andbuggyprogram result in aas of length .
in order to run more programs with grail we then manually modify the outputofpecansothatthegeneratedaashavelengthof3.note thattheaasaremodifiedinawaysuchthatthecauseofthebug in the original aa is not tampered.
after the modification grail successfully runs on benchmarks.
the other programs that cannotbeexecutedbygrailaremarked nainthethirdlastcolumn of table3.
out of the buggy programs grail is able to generate fixes for of them.
our manual inspection however shows that only of 4we tried our best to contact the authors of grail and got no response.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pfix fixing concurrency bugs based on memory access patterns ase september montpellier france themarecorrect.inthefollowing weinvestigatewhygrailfails on many of the benchmarks.
grailisunabletofixbugswhichareacrossmultipleclassesor methods.weencountersuchsituationsinprograms linkedlist dataraceandstringbuffer where errors are reported by grail during the fixing process.
grailsometimesfailstoidentifythecorrectscopeforadding locks.
as a result bugs remain after the fix.
this happens for programs evenandcritical.
grail has several implementation issues.
for instance if one aa contains multiple statements at the same line the fixing codes may overwrite each other.
this happens for program wronglock2 buggyprogram and atmoerror.
the result is a program which has a statement for lock release with no matchinglockacquirestatement.incaseof hashcodetest the fix inserts two lock acquire operations but only one lock release operation which results in a deadlock.
lastly grailmaygenerateruntimeexceptionswhenthey are applied to fix certain programs e.g.
program datarace.
thereare4programs i.e.
alarmclock mergesort producerconsumer andpool that neitherpfixnorgrail canfix.all the bugsthatcan be fixed by grail are fixed by pfix.
intermsofefficiency pfixismoreefficient.itsexecutiontime rangesfromafewsecondstoafewminutes whereasgrailisslower in most cases.
for some cases like the program account grail takes 10timesmoreexecutiontimethanpfix.thereasonmaybebecause grail needs to conduct constraint solving during bug fixing which isverytimeconsuming.furthermorenoticethatinmostcases pfix generates a fix which uses less locks than grail.
for all benchmark programs pfix introduces at most locks whereas grail generates as many as locks.
the reason is that pfix is designed to fix the bug based on the intended locking policy i.e.
using existing locks unless a locking policy is missing for some variables .
introducing excessive locks potentially makes the fix hard to comprehend andincreases the likelihood of introducing deadlocks.
.
threats to validity in the following we discuss the threats to validity in our experi ments.
firstly pfix is implemented based on java pathfinder.
as aresult wearenotabletoevaluateourapproachwithverylarge java programs.
while java pathfinder provides a good platform for implementingourapproach e.g.
foridentifyingsharedvariables and obtaining status of locks our method is not restricted to java pathfinder.inthefuture weplantomitigateourimplementation entirely to be based on soot and eclipse ast which hopefully will enable us to handle larger programs.
secondly instep1ofourapproach werelyonexistingapproach toidentifyarankedlistoffailure inducingmemoryaccesspatterns.
such ranking is based on simple statistical measurements and thus may not be accurate.
although the most suspicious pattern is usually the correct one in our experiments with the benchmarkprograms in general there is no guarantee that the real failure inducingpatternwillbethemostsuspicious.furthermore there maybemultiplefailure inducingmemory accesspatterns.different patterns might lead to different fixes some of which may be better than others.thirdly instep4ofourapproach weverifythefixedprogram with random testing.
although we test for times it is possible thattherearestillconcurrencybugsthatarenotrevealed.therefore we manually inspect the fix to determine its validity in our experiments.thisproblemcanbepotentiallysolvedbyadopting approaches like symbolic execution or model checking.
lastly pfixpotentiallyintroducesdeadlocks e.g.
theaccount program and or performance overhead.
this is particularly the case when pfix generates multiple fixes after repeating the fixing process a few times.
this problem can be potentially solved by applyingexistingapproachesonfixingdeadlocks e.g.
to the fixed programs.
related work our approach is inspired and related to mainly three groups of existing work i.e.
fault detection and localization memory access pattern analysis and most importantly concurrency bug fixing.
we review them below.
concurrency bug fixing.
our work is closely related to theline of work on fixing concurrency bug.
different approaches have beenproposedtofixconcurrencybugseffectivelyandefficiently.
thereare manyproposalsto fixconcurrencybugsby eliminating erroneousinterleavingpatterns e.g.
.inparticular huanget al.
proposed to fix concurrency bugs by inserting synchronization.
bradbury et al.
inspired by the use of genetic programming in sequential software debugging proposes to apply genetic programming to fix concurrency bugs.
therearea fewapproachesforfixingatomicityviolationbugs.
afix takes the ctrigger s output as input and adds a mutexlocktotheprogramtofixconcurrencybugs.afixalsomodifies ctriggertooutputallpossiblecombinationsofatomicity violation triples and the complete call stack for each atomicity violation related statements.
it collects each bug report patch and statically identifies patches that can be merged or optimized to improveperformanceorreadability e.g.
byremovingredundantpatchesand merging patches .
on the basis of afix cfix fixes concurrencybugsduetoorderviolation.byaddingsynchronization cfix enforces all a borfirst a b order relationships to fix orderviolation.cfixalsoenforcesmutualexclusionwiththesame method.
axis similar to afix fixes atomicity violations by addingmutualexclusionlocksandsynchronizationmeasures.axis additionally takes efforts to reduce the possibility of introducing deadlocks.
axis abstracts the source program into petri net using the supervisory control theory i.e.
supervision based on place invariants sbpi which turns the problem of program repair intoaconstraintsolvingproblem.alphafixer specializesinfixing atomicity violations it summarizes previous approaches based on locking.
by analyzing the lock acquisitions alphafixer finetunesthelockingsothatitispossibletoreducetheintroductionof deadlocks.
in the name of generating high quality patches liu et al.
proposedhfix whichdesignsfixstrategiesguidedbyasurveyof77manualpatchesofreal worldconcurrencybugs.inadditiontousing mutex locks hfix can also use the create and join operations of threads while modifying the original locks to achieve the purpose of fix.
grail fixes concurrency bugs by adding locks in ways authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france h. lin z. wang s. liu j. sun d. zhang g. wei similartoafixandaxis.comparedtoafix grailadditionallytakes measures for deadlock freedom.
grail builds a petri net analysis model of the buggy program.
the model is context aware andconsiders lock alias by adding constraints to the petri net model.
compared to axis grail guarantees at least the same concurrency levelifnothigher.grailcanbetimeconsumingduetotheuseof constraint solving.
besides grail fails to consider related variables and thus cannot fix multi variable bugs.
althougha lotof workhas beenproposed onconcurrency bug fixing there is still room for improvement as demonstrated in our experiments .
our approach distinguishes itself from the above workinmultipleways.firstly ourfixingisbasedonmemoryaccesspatterns whichistherootcauseoftheconcurrencybugs.it helps us accurately identify the statements which cause the bug.
although some existing approaches like afix and cfix use patterns like p c r which are similar to some of our memory access patterns their approaches are limited to only a few patterns.
in comparison oursetofpatternsareshowntobecomplete .secondly our work fixes concurrency bugs based on inferred locking policywhichallowsustosystematicallyfixbugsthroughoutthe program as well as fixing bugs which involve multiple variables which are not considered by existing tools .
thirdly pfix is more comprehensive.
for instance afix and alphafixer focus on fixing atomicityviolations whereasgrailcannot fixmulti variablebugs.
pfix is able to fix order violations atomic violations data races which involve multiple variables.
memory accesspatternsanalysis.
theideaofanalyzingmemoryaccess patterns to understand detect bugs has been explored in multiplesettings.in luetal.presentedatoolnamedavioand anempiricalstudyonrootcauseof74real worldconcurrencybugs.
aviofocusesondetectingbugscausedbysingle variableatomicity violations i.e.
oneparticularmemory accesspattern.falcon takes multiple test executions as input and computes statistical measurement for memory access patterns related to atomicity and orderviolations.itthenranksthepatternsaccordingtothemeasure i.e.
the suspiciousness score.
griffin groups multiple patterns whicharefoundtoberelatedtoabug.italsoprovidesbuggraphsto help understand the root cause of the bug.
xu et al.
presented an algorithm to identify erroneous event patterns from a failed execution.
it first finds the erroneous switch points and then determines the patterns related to this erroneous switch point which canhelpuserslocalizethebugs.unicorn isthefirsttounifythe useofpatterndetectionandsequencingtolocatenon deadlockconcurrency bugs.
it dynamically collects memory access information andisextendedtodetectbothsingle variableandmulti variableconcurrencybugsbasedonfalcon ssingle variableconcurrencybugs detection.
our approach takes fault related information inthe form of memory access patterns as input and generates fixes accordingly.
fault detection and localization.
our work is related to the line of work on fault detection and localization.
extensive researchhas been conducted on localizing bugs with different strategies.
among them quite a number are designed for sequential programs .thesemethodscollect and analyze runtime information of statements or predicates.
they reportthesuspiciousstatementsorpredicatesasfinalresults.therehave been a number of proposals on fault localization for multithreaded bugs in recent years .
csight generates a communicating finite state machine cfsm model by mining program execution logs.
lazy cseq works with context bounded model checking and supports deadlock detection for concurrent cprograms.recon providesinformationrelatedtobugroot causes by showing the scheduling of a test execution.
recon acquires short fragments of inter thread communications near the bugrootcauses andthenappliesmachinelearningtechniquesto identifythebug relatedfragments.racemob combinesstatic and dynamic bug detection.
during the static phase it uses a static dataracedetectortofindpotentialdataraces.thenracemobdynamically validatesthe suspiciousdata racesand updatesa listof data races to developers.
similarly iterace is also presented for race detection.
however iterace conducts static race detection in java parallel loops.
there are several approaches try to expose concurrent bugs by inserting random disturbances when concurrent programs are accessing shared memory and synchronizing or controling the thread scheduling.
these methods aimtoincreasetheprobabilityoftriggeringtherareinterleaving executionswiththeassumptionthatbugsmaybehiddeninthoseexecutions.
however inserting random delay disturbance may cause high performance overhead.
several techniques such as model checking usejava pathfinder to findconcurrency bugs.
in this work we apply java pathfinder to precisely control thread scheduling.
it leverages controlled executions to check whether certain patterns are relevant.
conclusion in this work we propose an approach to automatically fix concurrency bugs.
our key idea is to systematically fix concurrency bugs by inferring locking policies from failure inducing memory access patterns.wefixtheprogrambyimplementingthelockingpolicy systematicallyandconsistentlysothatthefailureinducingmemoryaccess patterns are made impossible.
we have implemented our approach in a toolkit called pfix which targets java programs.
we applied pfix to a set of concurrency bugs which range from dozens of loc to thousands of loc and are able to automatically fix19ofthem.forfuturework withtheencouragingresultsinthis work weaimtore implementpfixsothatitcanbeappliedfora variety of real world programs.