api deprecation a retrospective analysis and detection method for code examples on the web jing zhou and robert j. walker laboratory for software modification research department of computer science university of calgary calgary canada jing.zhou walker lsmr.org abstract deprecation allows the developers of application programming interfaces apis to signal to other developers that a given api item ought to be avoided.
but little is known about deprecation practices beyond anecdotes.
we examine how api deprecation has been used in open source j ava frameworks and libraries finding that the classic deprecate replace remove cycle is often not followed as many apis were removed without prior deprecation many deprecated apis were subsequently un deprecated and removed apis are even resurrected with surprising frequency.
furthermore we identify several problems in the information commonly not provided to help api consumers transition their dependent code.
as a consequence of deprecation coding examples on the web an increasingly important source of information for developers can easily become outdated.
code examples that demonstrate how to use deprecated apis can be difficult to disregard and a waste of time for developers.
we propose a lightweight version sensitive framework to detect deprecated api usages in source code examples on the web so developers can be informed of such usages before they invest time and energy into studying them.
we reify the framework as a prototype tool d eprecation watcher .
our evaluation on detecting deprecated a ndroid api usages in code examples on s tack overflow shows our tool obtains a precision of and a recall of in a random sample of questions.
ccs concepts software and its engineering !software libraries and repositories documentation keywords api deprecation deprecation practices web based documentation deprecation watcher.
.
introduction software developers use existing frameworks and libraries to save development time and effort.
application programming interfaces apis are the exposed interfaces of underlying software items that are intended to be reused by such developers.
ideally frameworks and libraries keep their apis unchanged and only add new apis or change the underlying implementation of existing apis.
in reality frameworks and libraries evolve over time for the same reasons as any software and this evolution sometimes causes nonbackwards compatible changes to their apis.
any sudden elimination of an api would cause difficulties for the api s consumers sodeprecation of an api temporarily maintains backward compatibility while urging api consumers to transition to better alternatives.
unfortunately we know little about deprecation in practice the problems that it will cause for developers and what could be done to improve the situation.
information about deprecation is generally anecdotal or based on assumptions that are either without supporting evidence or of dubious generality.
there has been much work on general api evolution focusing on migrating client code away from breaking api but this says nothing about deprecation practices.
some work has considered developer reactions to deprecation notes issues only in passing with deprecation or fails to consider how deprecation evolves .
work has been proposed to link web based code examples to concrete apis but this fails to consider the presence of multiple simultaneous api versions only some of which contain deprecated items.
when an api is deprecated it is assumed that api consumers will be aware of it.
according to a survey of over msdn developers developers indicate that they learn about new apis primarily through web search instead of via official documentation.
web searches often take a developer to sites like s tack overflow or software development blogs which have a high coverage of api for many frameworks .
those sites often offer concrete code examples on how to use apis complementing official documentation.
however those examples are rarely updated becoming a source of confusion and frustration when they refer to deleted or deprecated apis.
even the official documentation is not always updated for example the a ndroid method startmanagingcursor cursor in class android.app.listactivity has been deprecated since api level yet it is still used in an example in the class documentation as of api level .
our work seeks to address these shortcomings by performing an in depth retrospective analysis to investigate deprecation practices in open source j ava systems versions in total and by providing a tool d eprecation watcher that informs developers of the presence of deprecated apis in web based code examples.
the tool aims to be fast and conservative only announcing the presence of deprecated api usages when this isdefinite.
we evaluate our tool by comparing its ability to detect deprecated api usages in real posts on s tack overflow involving the a ndroid api with classifications performed manually.
the remainder of the paper is organized as follows.
section presents a motivational scenario for detecting web based usages of deprecated apis.
section presents our retrospective study on api deprecation by tracking how api deprecation occurred and changed over time.
in section we propose a lightweight version sensitive framework to identify deprecated apis in webbased source code examples implemented as our prototype tool deprecation watcher .
section presents our evaluation of deprecation watcher .
section presents a discussion about our work and its implications.
section discusses related work the contributions of this paper are a retrospective analysis of open source j ava systems over versions in total to determine how deprecation is used in practice and over time and a lightweight framework to detect deprecated api usages in source code examples on the web with its associated prototype tool.
.
motiv ation imagine an a ndroid developer who wants to capture a picture from a webview on an a ndroid device.
like a lot of developers instead of searching in the official a ndroid documentation he decides to look for help on the web.
he switches from his work environment a ndroid studio to a web browser and starts a g oogle search with the search terms android capture picture webview.
the top four results for this query returned by g oogle are all from s tack overflow .1the developer selects the first link to see that the title of the question capture picture from android webview matches his query almost exactly and that the question was marked as solved.
a quick glance at the webpage shows that the question has upvotes has been starred by people and that the accepted answer has upvotes and was written by someone with a high reputation.
the question has also been viewed more than times since it was asked.
it seems like the accepted answer would address this developer s problem too see figure so the developer decides to look into it.
after spending a few minutes to understand the code the developer considers integrating it into his own work as the code blocks seem self contained without external dependencies.
therefore the developer should be able to do little to no modification of his own code before he can start integrating the example code.
however once he starts to integrate the code a ndroid studio warns him that the new code contains deprecated apis.
specifically three methods in the code example have been deprecated setpicturelistener and capturepicture in class android.webkit.
webview and onnewpicture in class android.webkit.webview.
picturelistener .
the setpicturelistener andonnewpicture methods were deprecated in api level and capturepicture in api level but the developer uses api level .
the developer decides to find the replacements for the deprecated apis starting with setpicturelistener .
this time he resorts to the official a ndroid documentation to see if this api has been replaced by another one.
however the official documentation for method setpicturelistener merely states this method was deprecated in api level .
this method is now obsolete.
the developer again decides to search the web to see how others might have solved this problem.
he uses the keywords android setpicturelistener obsolete to do another search.
however this time the top result from g oogle is a s tack overflow post that merely refers back to the official documentation.
1all data collected as of september .
figure answer addressing developer s need?
having wasted much time the developer decides to undo the changes to his code and return to his first search instead of looking for replacements to the deprecated apis.
he clicks the second link in the g oogle search results .
the answer to the question states that the answer was found in another s tack overflow post.
so again the developer goes to that answer.
after evaluating the code example here he decides to use it and he succeeds.
at this point the developer has wasted a significant amount of time and energy making multiple false starts.
if he had been able to know whether a code example contains usages of deprecated apis and furthermore which apis used there are deprecated he could have either avoided spending time understanding the code example by immediately searching anew for alternatives or begun looking for the replacements of the deprecated apis early on.
.
a retrospective analysis our first goal is to study how api deprecation has been used in java third party frameworks and libraries.
in particular we focus our study on the deprecation of api methods and constructors because they tend to change more often than other api kinds as seen in anecdotes and informal investigations .
henceforth deprecated apis refers exclusively to deprecated api methods and constructors unless otherwise specified.
we address five research questions rq1 .
is api deprecation underused?
rq2 .
how are deprecated apis documented?
rq3 .
how often does un deprecation occur?
rq4 .
how often are deprecated apis removed later?
rq5 .
when do deprecated apis get removed?
section .
describes our criteria to choose the systems used in the study.
section .
describes our process to gather api deprecation data.
and lastly section .
describes our data analysis address ing the research questions.
detailed data results and graphics are available elsewhere.
.
selection of frameworks and libraries we used mvnr epository 3a search engine for m aven projects on m aven central repository 4to select libraries used in this study.
we selected only projects that are j ava third party frameworks or libraries based on the following criteria.
first we chose open source frameworks and libraries because their source and binary code are relatively easier to obtain than closed source ones source and binary code of a framework or library can help us construct an api change history and pinpoint when exactly an api gets deprecated and when a deprecated api gets removed.
second we chose frameworks and libraries that are well known and widely used by j ava developers changes to the apis in those frameworks and libraries affect a large number of developers.
all the frameworks and libraries we chose were from the most popular projects on mvnr epository .5the ranking is based on how many other projects on m aven central repository depend on it.
third we chose libraries that have existed for at least years so that api deprecations would have time to change in some manner.
we selected j ava open source third party frameworks and libraries for a total of versions for our study.
the average number of releases for the systems in our study is .
while the average time span for the systems is years.
with the exception of three systems jdom logback and neko html the first versions of the systems all start from .
or later in our study.
.
data gathering to track deprecated apis we considered the questions when was an api deprecated and what happened to the api later?
our process of gathering deprecation data follows.
we downloaded as many versions of the libraries as possible from their official website if an official archive was available there.
when an official archive was not available we downloaded the source and binary code of the libraries from the m aven central reposi tory instead.
we used source and binary code because they are the most reliable sources of this information.
after obtaining the library versions we used two tools to process them qd ox6 a parsing tool for j avacode that can extract various information about the code entities therein to parse the annotations and j avadoc of the entities in every version of the libraries to get a list of deprecated apis in each version and c lirr7 a tool to check j ava libraries for binary and source compatibility between versions to find important api changes.
we note also that on m aven central repository a single framework or library can correspond to multiple artifacts e.g.
commons collections corresponds to two different artifacts.
we calculated api changes across such boundaries.
.
data analysis rq1.
is api deprecation underused?
we found that all the systems in our study deprecated some apis during the studied development spans illustrating that api deprecation in j ava third party frameworks and libraries is a common practice.
however we also found that five systems only depre2 accessed in march apis in one version commons logging maven model maven plugin api neko html slf4j the number of deprecated apis in these versions is also small.
we found that the limited use of api deprecation cannot be attributed to the fact that these systems have already stabilized before reaching the version that is the first version used in our study.
for instance neko html only deprecated one api even though its first version used in our study is .
.
it has also removed apis in versions over the course of years which is in sharp contrast with the number of its deprecations.
in the majority of the systems removed apis outnumber deprecated apis significantly and in many cases the two sets do not overlap.
we found that api deprecation is indeed underused since many apis were removed without prior deprecation.
rq2.
how are deprecated apis documented?
deprecation messages are important for developers to decide what to do with deprecated apis.
a deprecation message that links to the replacement of the deprecated api helps developers migrate to the new one.
a deprecation message can also offer other relevant information about the deprecation such as the rationale for the deprecation and when the deprecated api is expected to be removed.
to analyze how library developers use deprecation messages we extracted the deprecation messages associated with every deprecated api not all deprecated apis came with a message but we found that the majority of them did.
when an api does not have an associated message we consider its deprecation message to be empty.
we found that of the systems changed some of their deprecation messages in a later version.
in such cases we use the revised deprecation messages.
we manually examined the deprecation messages to answer the following questions.
how often do deprecation messages refer to a concrete replacement?
we manually classified deprecation messages into four categories based on whether a concrete replacement is given without replacement no mention of a replacement a vague replacement anda concrete replacement .
the difference between the first two categories is that the deprecation message in the former specifically states that there is no replacement for the deprecated api while the latter signifies the absence of any statement.
a vague replacement offers only a general sense for a migration path.
we found that on average only .
of all deprecation messages offered concrete replacements for the deprecated apis.
only two systems c ommons io and neko html offered concrete replacements for all of their deprecated apis but neko html only deprecated one api in total.
for .
out of of the systems concrete replacements were specified for less than of their deprecated apis.
six out of the systems did not refer to a concrete replacement for any of their deprecated apis.
how often do deprecation messages offer explanations?
knowing why a certain api has been deprecated helps developers make informed decisions.
deprecation messages were classified into two categories with explanation andwithout explanation .
we found that on average only .
of the deprecation messages offered an explanation for the deprecated api.
in fact close to half out of of the systems offered no explanation for any of their deprecated apis.
the gson library has the highest percentage overall of messages containing an explanation but still at a mere .
our results show that developers of these systems tend not to explain their decisions in deprecation messages since ides like e clipse can display deprecation messages for deprecated apis developers fail to utilize the most convenient place to communicate their decisions.how often do deprecation messages specify a time frame for deletion?
knowing when an api will be removed in the future affects the priority that developers assign to various changes needed to their projects.
we classify api deprecation messages into three categories no removal plan a vague removal plan and a concrete removal plan .a vague removal plan merely states that the deprecated api will be removed in the future while a concrete removal plan offers the specific future version.
we found that on average only .
of the deprecation messages in the systems offered a concrete removal plan for the deprecated apis.
the majority out of of the systems did not specify any plan for any of their deprecated apis.
only .
out of of the systems had concrete plans for the removal of some of their deprecated apis.
in summary our results for rq2 show that api producers do not make use of deprecation messages well enough to help api consumers migrate from deprecated apis.
less than a quarter of the systems specified all replacements of the deprecated apis.
furthermore most systems do not offer explanations for their api deprecations nor specify when deprecated apis will be removed.
rq3.
how often does un deprecation of apis occur?
apis are sometimes un deprecated.
we tracked deprecated apis in each library over time to see if they stopped being marked as deprecated in a later version.
the results show that almost half in of the systems have un deprecated some of their apis during the time span examined in our study.
by manually examining these cases we observed that in most cases the un deprecated apis still existed at the end of the period.
in systems ju nit log4j and x erces impl some apis were first removed then brought back and immediately marked as deprecated.
we call this phenomenon remove resurrect deprecate in comparison to the classic deprecate replace remove cycle.
we hypothesize that this indicates that library developers have falsely assumed that these apis were not used by api consumers and went forward to remove them.
un deprecation and the phenomenon of remove resurrect deprecate indicate that api producers lack sufficient knowledge of how their systems are being used.
rq4.
how often are deprecated apis removed later?
we tracked deprecated apis in the systems over consecutive versions if they stop appearing in a version they are deemed as removed.
we found that .
of the deprecated apis were later removed in sharp contrast to the reported elsewhere due to raemaekers et al.
having overlooked the j avadoc deprecation tag and artificial boundaries subdividing single projects within the maven central repository .
further investigation found that systems differ greatly in this aspect some removed all their deprecated apis while the majority of them removed none.
we categorize the systems into the following three cases.
all the deprecated apis were removed .
only .
out of of the systems removed all their deprecated apis commons collections commons configuration maven model neko html .
two systems only had one or two api deprecations in total maven model neko html .
none of the deprecated apis have ever been removed .
a total of .
out of of the systems never deleted any of their deprecated apis during the time periods in our study.
some of the deprecated apis were removed .
the remaining .
out of of the systems removed some of their deprecations.
deprecated apis that are not removed yet in this group may or may not be removed in later versions.the fact that more than half of the systems never removed any of their deprecated apis suggests that the developers of these systems are highly concerned with backward compatibility and fear to introduce breaking api changes by removing deprecated apis.
in the extreme there is even evidence that some api producers intend tonever remove deprecated apis if possible .
rq5.
when are deprecated apis removed?
we chose to examine when deprecated apis were removed in systems that have removed more than two deprecated apis because it is hard to generalize from systems that removed less than two deprecated apis.
seven out of the twelve systems fulfill this condition.
we categorized these systems based on when they removed their deprecated apis before version .
during transitions to major releases and other versions .
different frameworks and libraries have different conventions about what is a major release.
for example log4jconsiders .
to be a major release.
all the systems removed deprecated apis during transitions to a major release.
jdom removed its deprecated apis before version .
and during its transition to .
.
five systems removed their deprecations exclusively during their transition to major releases.
since no versions before .
of these systems were used in the study it is unclear if they removed deprecated apis in these versions.
log4jis the only system that removed deprecated apis in non major releases.
it removed out of its deprecated apis in two non major releases .
.
and .
.
.
overall .
of the removed deprecated apis were removed during the transition to major releases and .
of the removed deprecated apis were removed either before version .
or during transitions to major releases.
we hypothesize that api developers are concerned with the backward compatibility of their systems.
we note an inconsistency however since we also found that many apis were removed without being deprecated first.
overall our study shows that deprecation is treated sporadically and inconsistently both within single systems and across systems.
the lack of migration paths explicit removal plans and rationales all limit the api consumer s ability to act both proactively and reactively.
given these problems we could at least do a better job of informing them that an api is deprecated.
.
tool and framework our second goal is to provide a tool for developers to warn about when an example uses deprecated api.
figure shows a code example involving deprecated apis under which a warning message has been inserted by our tool called d eprecation watcher .
the version sensitive framework underlying this tool see figure consists of three components an extractor profiler for code elements a version sensitive api matcher and a visual feedback component.
in d eprecation watcher the code element extractor and visual feedback component work on the client as an extension to the g oogle chrome web browser while the version sensitive api matcher works on a server.
.
extractor profiler the framework needs access to the source code example.
most modern web browsers allow external programs to extend their functionalities.
with the permission of the web browser user they make the html and d ocument object model dom of the current webpage available to extensions.
to extract code elements from the source code examples we first extract the code snippets on a webpage that are contained in pre or code html tags which is the norm on the web today.
wefigure d eprecation watcher identified the usage of a deprecated api in the code example and appended a warning message below it with the details.
code examples visual feedback extractor profiler extension webpage browser api matcher database server figure the structure of the framework.
1protected dialog oncreatedialog intid dialog dialog switch id case dialog new dialog this dialog.setcontentview r.layout.paused dialog.settitle game paused dialog.show break default dialog null return null figure example code containing a call to setcontentview .
also process code snippets and reconstruct the lines in the code snippets before extracting code elements from them.
the extraction is processed locally in the browser.
the next step is to construct a profile for every code element in the source code example see figure .
to match code elements in the code snippets we created javascript based regular expressions see figure matching them to every line in the code snippetvartypevaribleregex w ?
.
w ?
s b w g varmethodregex b w g varcallermethodregex w .
w g varargsregex .
?
figure regular expressions used to extract code elements.
for argsregex the number of arguments in any matched non empty string equals the number of commas plus one.
not used for nested calls.
kind method name setcontentview cname dialog args type void tags figure the profile for the example code element.
in order to construct a profile for them.
the profile that is built for a code element depends on how much information can be extracted given that many code examples on the web lack detailed information such as the fully qualified name of classes and the strategy that the api matcher uses to match a deprecated api since the api matcher uses the code element profile for matching.
many pieces of information about a code element could be used in the profile.
for example for setcontentview in the code example in figure our tool extracts the following types of information kind of code element kind .
the kind of an api can be class interface method constructor or field.
the kind of setcontentview ismethod because it matches the regular expression for a method call.
name of code element name .
the name here is setcontentview .
name of enclosing class cname .
the name of the enclosing class for the code element is dialog .
this information is inferred through the context in the code.
in line a variable named dialog of type dialog is declared which is stored into the context for the code example.
in line setcontentview r.layout.paused is invoked on dialog .
argument count args .
the code element takes one argument.
return type type .
the inferred return type of the code element isvoid.
semantic tags tags .
the tags attached to the post are android and contacts .
the profile for the code element setcontentview constructed with the information above is shown in figure .
the algorithm we use in the extractor profiler is shown in figure .
we have found that the tool works better when we also include code elements from the question posts as part of the context cqbecause answer posts sometimes refer to the types and variables used in the question.
the d eprecation watcher client side asynchronously sends each profile constructed for an example to the server for matching.
.
version sensitive api matcher the version sensitive api matcher must attempt to map each profile to a concrete deprecated api in the target framework or library.
the matcher in our tool matches against a repository of all apis in the target system.
the set of apis in a framework or library can be obtained in several ways as mentioned in section .
.
our api matcher is version sensitive in that it returns its result based on the developer configured version that the api matcher uses.1cq fg context of question 2ca fg context of answer 3p fg set of profiles 4foreach s2q each snippet in question dol reconstruct lines s foreach l2l docq cq extract context l 8foreach a2a each answer in answers do foreach s2a each snippet in answer dol reconstruct lines s foreach l2l doca ca extract context l kind name cname args type tags match regular expressions l iftype null thentype findtype cq p kind name cname args type tags p p p figure algorithm to extract code elements and construct profiles for them.
on the server we built a database of all deprecated api methods by parsing the diff files downloaded from the official a ndroid website.
the diff files were produced by the a ndroid team using the jd ifftool.8each diff file contains the changes to the android api between two consecutive api levels.
we stored information such as the name of the api the enclosing type of the api the deprecated version of the api and the tag android into the database so an api could be matched with a code element profile easily.
we also stored a database of all apis in the newest version of the a ndroid api in the same way.
due to the fact that the code element profile only contains incomplete information of an api we cannot be sure whether there is really a match when a code element profile matches a deprecated api in the database.
therefore we adopt a conservative strategy we only consider there to be a match when allapis matching the profile are deprecated.
the matcher can make use of a set of heuristics to match code element profiles to deprecated apis in the database.
heuristics are necessary because it is difficult to obtain the fully qualified name of an api from a code example on the web directly and sound analyses are likely to be expensive even when possible.
we currently use the name of the code element the simple name of the enclosing type the number of arguments and the return type as the elements in the profile that have to match exactly with a deprecated api to announce the usage of a deprecated api.
the sets of tags have to have at least one element in common.
after the matching process the server returns all matches of deprecated apis.
.
providing visual feedback the visual feedback component must parse the result and visually display the result to the user.
the visual feedback could be designed and implemented in several ways .
first deprecated apis can be highlighted inline in the code snippet mimicking ides where strikethroughs signify that that api has been deprecated.
however code snippets might already contain strikethroughs.
second the feedback could be presented outside the code example.
this option could offer more information about the deprecated apis via text.
users then would have to look through the code to locate where the deprecated apis are used.
finally a hybrid of the two options is possible.
for our tool we chose the second option as least invasive.
when the extension receives the result for a code example from the server it loops through all the apis in the result and constructs html segment containing the information about the deprecated apis.
the information includes the name of the api the enclosing type of the api the version in which the api is deprecated and any deprecation message for the api.
inserted.
in terms of running time performance the non optimized form of deprecation watcher described here as opposed to the batch processing form described below completes its task within a maximum of five seconds on commodity hardware.
.
ev aluation for the evaluation of d eprecation watcher we have two research questions rq6.
how well does d eprecation watcher detect deprecated api usages in source code examples?
rq7.
what factors affect how well d eprecation watcher performs?
.
selection of code snippets we chose to evaluate d eprecation watcher with posts containing code snippets on s tack overflow that are tagged android .
an accepted answer is deemed as the most helpful one by the asker on s tack overflow and is also the first answer a developer tends to look at when browsing the site.
many of these answers include source code examples to demonstrate how to accomplish certain tasks.
in our evaluation d eprecation watcher is configured to use a ndroid api level .
if an api that was deprecated in or before level is detected in a code example d epre cation watcher will append a warning after the code example.
for batch processing we set up a database containing the documents questions and answers to be processed we fed the documents directly to the extractor profiler and we replaced the visual feedback component with a simple collector that records whether deprecated api was detected or not for a given document.
we chose our evaluation posts from s tack overflow s march data dump9with the following process.
we first extracted all questions having an android tag and their answers from the data dump.
our database stores documents in total.
we filtered the documents using the set of all deprecated a ndroid apis by the following two conditions.
the name of a deprecated api must appear in the code examples of the accepted answer.
the enclosing type name of that api must be mentioned in the document.
these conditions leverage the lexical information in a document to filter out documents that cannot possibly be detected as having deprecated api usages by the tool allowing us to focus our manual analyses on relevant cases.
we ended up with documents that satisfied the filtering conditions.
some of the code snippets in the accepted answers of the documents may not contain deprecated api usages because our conditions for filtering are not strict enough.
we then randomly selected documents out of the for our evaluation as detailed manual interpretation of each was needed at this stage.
.
procedure to evaluate d eprecation watcher we reconstructed the url for each question in the documents from its question id and we went to s tack overflow to examine the code snippets.
we labelled them based on whether they contained deprecated a ndroid api methods by manually checking the a ndroid official documentation.
if the api was not present in the documentation we went on to check the api diff files.
the absence of an api in the documentation was usually due to the api s deletion.
manual process was quite time consuming.
first there can be two or more code examples in one answer.
second in order to construct the signature of an api a basic understanding of the code example is required.
in many cases it involves reading the question post and understanding the code snippets inside as well.
third there is a significant amount of context switching involved between checking the a ndroid official documentation and examining the code snippets.
as a result the process of manually examining the code examples in a single answer can easily take minutes.
.
results we used precision and recall to measure the performance of d eprecation watcher .
if an api was identified by d eprecation watcher as deprecated and was manually classified as deprecated it is classified as a true positive tp .
if an api was incorrectly identified as deprecated by d eprecation watcher it is classified as a false positive fp .
if a deprecated api was not correctly identified as such it is classified as a false negative fn .
deprecation watcher identified deprecated a ndroid api usages in the source code examples all of which were correctly identified.
there were deprecated a ndroid api usages in total in the code examples of the accepted answers in the documents.
it thus has a precision of and a recall of for those documents.
considering the sample size the population recall falls in the confidence interval .
we also found that out of the deprecated api usages that deprecation watcher correctly detected only were acknowledged in the answers.
both of these were used deliberately after they were deprecated in order to target devices running older versions of a ndroid .
furthermore only out of all the deprecated api usages were acknowledged by the answers or their comments.
the third one method removeglobalonlayoutlistener ongloballayoutlistener in class android.view.viewtreeobserver was used in a code example before it was deprecated and a comment pointed this out at a later date.
from documents that were filtered away only negative results are possible thus the precision is representative of the entire document set assuming that the random sample was representative.
recall could be impacted by the documents that were filtered away if they contain false negatives.
the first filtering condition retains all documents mentioning a name that matches deprecated api therefore only the second filtering condition could be an issue.
if the enclosing type name is not mentioned in the document there are two possibilities an unrelated type is being used and the matching name is a coincidence but then the occurrence is a true negative or the enclosing type name is not mentioned.
the second case could arise in an example whose enclosing type transitively or implicitly extends a type containing the deprecated api direct and explicit inheritance would cause the document to be retained .
implicit inheritance would involve a sloppy example contravening the s tack overflow policy on examples that is unlikely to result in useful comments and views and so its practical impact would be low.
the transitive inheritance could only involve custom classes because the android documentation lists all inherited entities within a class.
but again this seems unlikely since the example would be complex contravening the s tack overflow policy.
.
.
what factors affect performance?
we have found that almost all fns in the evaluation arise from the fact that d eprecation watcher is limited in extracting information about the code elements in a code example.
more specifically some of the factors that affect how well the tool performs in recall are as follows.intscreenheight short activity.getwindow .
getwindowmanager .getdefaultdisplay .getheight intscreenwidth short activity.getwindow .getwindowmanager .getdefaultdisplay .getwidth figure a code snippet with two chained method api calls.
intindex if getlastnonconfigurationinstance !
null index integer getlastnonconfigurationinstance figure a code snippet with typecasting.
chained method calls .
this factor mostly affects the code element extractor.
since d eprecation watcher relies on simple regular expressions to extract api information it is not able to extract the return types and the enclosing class of apis inside a chained method call an example of this is shown in figure .
deprecation watcher failed to identify the deprecated methodsgetheight andgetwidth in this code snippet because it failed to identify the class they belong to.
in the matching process the api matcher tries to match the profiles of code elements getheight andgetwidth only to find that several apis with the same names exist in different classes and some of them are not deprecated.
as a result d eprecation watcher was not able to correctly map the code elements into deprecated apis.
class hierarchy .
our approach also ignores important type relationships like class inheritance in j ava.
this factor affects both the code element extractor and the api matcher.
the code element extractor cannot identify the types some apis belong to in some cases.
for example if a class aextends class band calls a method m deprecation watcher would not know that method mcomes from class b. the api matcher also matches types directly without taking the class hierarchy in the system into account.
in j ava an object can be type cast explicitly or implicitly to its subclass or superclass type.
in figure the return type of api getlastnonconfigurationinstance in class android.app.activity has been typecast to integer .
as a result d eprecation watcher misconstructs the code element profile for the code element here and consequently the api matcher was not able to return a match.
.
evaluating alternative heuristics the heuristics we used in the evaluation are the name the number of arguments the enclosing type and the return type.
alternative heuristics could lead to a better result.
but the example in figure shows how an extra heuristic may actually hurt the performance.
in that specific example the return type of the api getlastnonconfigurationinstance was typecast to integer .
as a result the tool misconstructs the profile for this code element and no match was found by the api matcher that tried to use all heuristics.
this prompted us to evaluate after the fact the performance on the same examples of three other combinations the name and the number of arguments the name the number of arguments and the return type and the name the number of arguments and the enclosing type.
the results are shown in table .
we found that the combination using only the name and the number of arguments performs as well as the combination that also includes the return type of a code element.
both of them were able to correctly identify a case that the other missed but at the cost of missing a case that the other detected the first set of heuristics was able to correctly detect code element getlastnon configurationinstance in figure while the second set of heuris table three more heuristic combinations were tried.
n name a of arguments r return type e enclosing type.
heuristics tp fp fn precision recall n a .
.
n a r .
.
n a e .
.
1programfragmentfixedfunction.builder builder new programfragmentfixedfunction.builder mrs 2builder.settexture programfragmentfixedfunction.builder.
envmode.replace programfragmentfixedfunction.
builder.format.rgba 3programfragment pf builder.create 4pf.bindsampler sampler.wrap nearest mrs figure a code snippet where return type aided detection.
public void updatepage curlpage page intwidth intheight int index switch index case bitmap front loadbitmap width height page.settexture front curlpage.side front page.setcolor color.rgb curlpage.
side back break ... figure a case of incorrect detection.
tics was not.
however with the help of the return type information the second set of heuristics was able to correctly detect a deprecated api in a code example that the first set was not able to see figure the return type programfragment of the code element create in line helped to detect a usage of deprecated api.
the first two sets of heuristics also incorrectly detected a code element as deprecated api due to the fact that they do not make use of the enclosing type of the code element.
the relevant part of the code example is shown in figure .
the code element settexture was incorrectly detected as a deprecated a ndroid api even though it was from an external library because the type of code element page was not utilized.
we also found that the third combination of heuristics was able to outperform the heuristics we used to evaluate d eprecation watcher despite it not making use of the return type.
we learned two lessons from evaluating these sets of heuristics.
first more heuristics do not necessarily lead to a better result.
the addition of the return type of a code element as a heuristic does not help improve the performance of the tool when other heuristics are also applied.
in the evaluation it proved to be useless when the enclosing type of a code element is included as one of the heuristics.
this is somewhat expected since the return type is not considered as part of the method signature in j avaand two apis differing only in return type cannot co exist in the same class.
second the detailed design of the heuristics matters.
had the code element extractor allowed for the return type to be typecast to another type it would not have misconstructed a code profile in such cases.
the return type would remain as a useless heuristic but would not have hurt the tool s performance.
this has a greater implication it can be hard to add complex heuristics even though in theory they may improve the performance as complex heuristics tend to call for complex error prone implementations.
.
discussion .
why lightweight tooling suffices here deprecation watcher works well despite extracting only simple essentially lexical information from examples and performing only simple analyses thereon.
we were initially surprised at how well this simple approach worked expecting to encounter frequent situations where ambiguity arising from lack of semantic information would lead to poor recommendations.
the fact that such problems occurred rarely can be attributed to the fact that code examples on s tack overflow are intentionally kept simple and selfcontained so as to be easily understood.
d eprecation watcher in its current form could not fare as well if general source code were analyzed.
however alternative analyses of greater complexity would slow down the tool reducing its usability.
.
deprecation messages we found that nearly half of the deprecation messages do not provide information on how to replace the deprecated apis.
a possible cause for this is that there is no standard format for deprecation messages urging conformance from api producers.
as a result developers only include what they think is necessary.
therefore it could be beneficial to establish a standard format and tool support for deprecation messages.
such standardization would also enable the creation of tools to analyze deprecation messages.
for instance to find all the deprecated apis with a replacement and replace them automatically or to generate a report for all the deprecations in a system and prioritize them based on information in the deprecation messages.
we believe such standardization would not create much more overhead for developers of frameworks and libraries.
api deprecation does not happen in every release of a system and when it does happen in a release in most cases not many apis are deprecated simultaneously.
furthermore we observed in the systems we studied many apis get deprecated due to the same underlying change and can be removed in the future in the same version.
a tool could use this information and reduce developers workload.
.
removing apis removing apis without prior deprecation seems dangerous because it can break client code without warning.
two factors may contribute to this phenomenon.
first it is likely unrealistic to deprecate apis and retain them when a framework or library undergoes radical structural changes.
second developers of frameworks and libraries remove apis that they assume are not being used.
when examining release notes we noted that developers often make assumptions about how apis in their systems are being used.
for example in the release notes of c ommons collections .
in the removed classes section the developers state removed unused class abstractuntypedcollectiondecorator .
our results imply that developers are reluctant to remove deprecated apis.
however when they do the removal usually happens either before version .
or during transition to major releases and different systems have different conventions about what constitutes a major release.
many treat any release with an increase in the major release number as a major release while others treat releases with an increase in minor release number as major releases as well.
adopting semantic versioning would be good for both api producers and consumers providing greater clarity over the significance of new versions for planning by both parties.
.
web search in software development web search has proven valuable to developers during software development tasks.
however web search also has its problems codeexamples on the web can be written with different versions of an api and developers can use different versions of the api as well.
when apis are deprecated or removed some source code examples become outdated and are no longer helpful for developers who use the latest version of the api.
at the same time the same source code example can be of different value for developers who use different versions of an api.
web search engines take neither of these factors into consideration in their ranking of online resources.
we expect the usefulness of web search to deteriorate in the future if nothing is done to change this situation.
our work can be seen as an initial attempt to solve this problem.
the framework we propose keeps track of what version of an api a developer uses in the api matcher and assesses whether a source code example on the web using the same api can be useful for the developer by detecting deprecated api usages.
.
threats to validity the choice of libraries.
we used a few criteria when selecting libraries to study.
first all the j ava third party libraries we chose are open source projects.
therefore our results do not necessarily reflect how api deprecation is used in closed source libraries.
second all the libraries we chose are widely used by j ava developers.
as a result our analysis may not be representative of less popular libraries.
third all the libraries in our study have been in existence for at least years.
therefore it may not reflect how new libraries are using api deprecation.
finally we focused only on uses of the android api.
therefore this may not reflect uses of other apis or web based discussions thereof.
the versions of the libraries used in our analysis.
we collected as many versions of the source code and binary code of the libraries as possible in our study so as to pinpoint when apis were deprecated removed or un deprecated.
unfortunately we still were not able to locate some versions of some libraries.
as a result the exact version when the deprecation or deletion of certain apis occurred might not be accurate.
this is particularly relevant to rq5 where we answered the question of when deprecated apis were removed.
however by collecting as many versions of the libraries as possible we were able to ensure any discrepancy between the apparent version and the actual version would be small at worst.
the use of stack overflow .our evaluation made use of only stack overflow posts.
furthermore d eprecation watcher demonstrated strong performance because of the social limitations on examples discussed there.
while the engineering aspects of the tool could easily be translated to similar q a sites it is possible that the s tack overflow social limitations would not be in place.
we believe that this is a dubious concern more complex examples lead to type ambiguity would be just as problematic to humans on other sites and thus there would be as much social pressure to keep it simple stupid.
the choice of posts in the evaluation.
we selected posts that possibly contain deprecated apis through the two criteria mentioned in section .
the first criterion filters out all posts that do not contain deprecated apis.
the second criterion aims to narrow the size of the posts down by another condition the enclosing type name of an api should appear either in the question or in the accepted answer along with that api.
this condition is important to filter out posts that contain apis with a common name such as create because the majority of them are not deprecated.
another rationale behind this criterion is that knowing the type name an api belongs to is also important for a developer to understand the program.
in rare cases the enclosing type name of an api may be missing in both the question and answer text.
in these cases even if a document contains deprecated apis it would not end up in our evaluation set of posts.
.
future work investigate why apis are removed without prior deprecation.
we found evidence that api producers are concerned with backwards compatibility yet many apis were removed without prior deprecation possibly leading to broken client code.
we think this paradox merits further investigation.
we examined a few relevant release notes and found that api producers were aware of the fact that they were removing apis without deprecating them first.
however they justified it with the belief that these apis were not used and the removal of these apis would not affect api consumers.
in several systems we also found that most of the removed apis in question were protected rather than public .
api producers may believe that no user would inherit the classes in question and went forward to remove protected apis.
these hypotheses need further study.
improve deprecation watcher.
deprecation watcher does well in precision because of its conservative api matching strategy.
it only returns a match when it is certain.
on the other hand its performance in recall can be improved.
we found that the main factor affecting its recall during our evaluation is that it does not deal with many parts of a language such as the class hierarchy.
first we can devise more complicated regular expressions to match structural information such as class inheritance and method overriding so more useful heuristics can be used however this alternative may complicate the implementation of the tool significantly.
alternatively we could fully parse code examples to extract information however this alternative could reduce usability because of slowdown.
evaluate with developers.
we evaluated d eprecation watcher in terms of precision and recall but with the involvement of developers we could collect direct evidence that deprecation problems waste time consider the usability of the tool.
for example timely feedback to developers likely matters since this may affect perception of its usefulness.
furthermore we could investigate what information is most useful to developers when a deprecated api is detected to improve the feedback component.
.
related work we consider two classes of related work more closely deprecation practices and web based code examples.
.
deprecation practices previous work from our lab has hinted at issues with api deprecation.
kapur et al.
found that deprecated entities do not always get deleted and deleted entities are not always deprecated they manually studied only three systems and deprecation was not the focus.
cossette and walker found that replacement recommendations in deprecation messages were frequently missing or incorrect again their focus was not on api deprecation.
hou and yao conducted a case study of the evolution of the awt s wing apis to classify the intent behind api deprecations and additions rather than how api deprecation is used.
robbes et al.
studied the ripple effect of api deprecation in a smalltalk ecosystem and how developers react to it finding that deprecation messages cannot be relied upon to be helpful because they can be missing or not offer concrete advice.
their study is done on only two s malltalk systems and might not be representative of how api developers use deprecation in general.
they also focused on how api deprecation in one system affects other systems while our work focuses on how api deprecation is used and how deprecated apis change over time within single systems.
ko et al.
studied the quality of deprecation messages in eight javalibraries and found that of the deprecation messages provide replacement apis while rationales and concrete examples onhow to use new apis are rarely given.
in contrast our study also examines whether deprecation messages provide information on when deprecated apis are expected to be removed since this information helps developers make decisions about when to migrate deprecated apis.
furthermore our study has a much larger scope.
linares v squez et al.
investigated how developers react to api changes by considering the volume of discussions about a ndroid api changes on s tack overflow they found that removing api methods in particular triggers more discussions and from more experienced developers but api deprecation triggers discussion or even confusion as well.
espinha et al.
examined how deprecation policy is used by several web service apis and found that even when a web service gives a long deprecation timeframe before removing its old apis many developers still are not able to migrate their code in time.
in the case of the g oogle mapsapi version google gave a deprecation timeframe of three years initially but had to extend it because many developers were not able to migrate their code in time.
they reached the interesting conclusion that long deprecation periods leave developers too relaxed to migrate deprecated api code.
however their study was done on web service apis while our work focuses on local apis provided by libraries.
raemaekers et al.
studied deprecation patterns in j ava systems on m aven central repository .
they found that deprecated apis were never removed.
however they considered an api to be deprecated only if possessing a deprecated annotation ignoring the presence of the deprecated javadoc tag furthermore they failed to consider that projects there are sometimes subdivided artificially.
many researchers seem to assume that deprecated apis follow the deprecate replace remove cycle where the deprecated api is replaced by a new api and eventually gets removed even if the cycle can take a long time.
however many deprecated apis in various frameworks and libraries have not been removed despite having remained as deprecated for years there is no indication that they will ever be removed.
furthermore in java and many third party libraries some deprecated apis have also been un deprecated which suggests the deprecate replace remove cycle is not the only possibility.
.
web based code examples code examples are helpful for developers to learn apis .
commercial code search engines are able to search code from a vast number of open source projects that are available online.
however they are mostly keyword based which limits their utility.
several code search techniques have been proposed to improve code search by utilizing structural and semantic information of the code to make the results more relevant to developers.
these techniques are only responsible for locating code examples and developers need to assess the code examples themselves.
these code search techniques also value relevancy over timeliness.
two approaches aim to link code elements in a code snippet to concrete apis.
r ecodoc links code like terms in learning resources to concrete api elements in order to solve the problem that the learning resources may not reflect api changes.
the b aker tool tries to link the official documentation of a framework or library with example based resources of the framework or library on the web so developers can benefit from both at the same time.
both approaches use partial program analysis and an oracle to link code elements to concrete apis.
both approaches face the challenge of ambiguity when linking code elements in code examples to a concrete api in a framework or library to uniquely identify an api a fully qualified name is required while names in free text and code snippets tend to be ambiguous.although both approaches work well for their purposes neither of them is able to address the problem of detecting deprecated api usages in source code examples on the web.
b aker assumes that api usages in code examples on the web are written with a specific version of a framework or library in mind and as a result can be mapped to that specific version of the api.
this assumption is problematic for our context because code examples on the web can be written with different versions of the api of a framework or library in mind.
this can be particularly true for new or rapidly evolving frameworks and libraries e.g.
the a ndroid api evolves at the rate of api updates per month on average many of which are deprecations or deletions .
similarly r ecodoconly works on learning resources such as documentation and supporting channels that are known to correspond to a specific version of a framework or library.
in contrast our approach is designed to identify only deprecated apis and does not assume that code examples on the web are written with a specific version of a framework or library this permits d eprecation watcher to be lightweight.
.
conclusion deprecation is an important tool for api producers and api consumers but little is known about it beyond anecdotes and assumptions.
we examined historical data of api deprecation and removal from open source j ava third party frameworks and libraries versions in total .
we found that while deprecation is used by all the systems it is underused many apis were removed without being deprecated first.
our analysis of deprecation messages shows their poor usability just over half of the messages offered concrete replacements for their deprecated apis only .
of the deprecation messages provided a rationale for the deprecated api and a mere .
of them specified a concrete timeframe for the removal of the deprecated api.
we found un deprecation in almost half of the systems we studied.
we identified the phenomenon of removal resurrection deprecation of apis within three systems as well.
more than of all deprecated apis were removed but with uneven distribution more than half of the systems never removed any of their deprecated apis and only .
of the systems removed all their deprecated apis.
almost all of the deprecated andremoved apis were removed either before version .
or during the transition to a major release few apis were removed elsewhere.
to address some of the difficulties that api consumers encounter in the face of deprecation we proposed a version sensitive framework to detect deprecated api usages in source code examples on the web.
by utilizing the api change history of a target framework or library we make our framework version sensitive.
we implemented the framework as a prototype tool called d eprecation watcher which works as an extension to the g oogle chrome web browser.
it gives visual feedback when usages of deprecated api usages in a code example are detected.
in our evaluation d eprecation watcher achieved a precision of .
and a recall of .
in detecting deprecated a ndroid api usages in source code examples in the accepted answers on s tack overflow .
our results have several implications.
first api producers need to provide better deprecation messages.
second they need tool support to better understand how their apis are used so they can have more confidence in removing deprecated apis.
better support for api producers and api consumers would permit decreased risks for both groups.