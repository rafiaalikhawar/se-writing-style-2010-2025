bdci behavioral driven conflict identification fabrizio pastore leonardo mariani daniela micucci university of milano bicocca disco milan italy pastore mariani micucci disco.unimib.it abstract source code management scm systems support software evolution by providing features such as version control branching and conflict detection.
despite the presence of these features support to parallel software development is often limited.
scm systems can only address a subset of the conflicts that might be introduced by developers when concurrently working on multiple parallel branches.
in fact scm systems can detect textual conflicts which are generated by the concurrent modification of the same program locations but they are unable to detect higher order conflicts which are generated by the concurrent modification of different program locations that generate program misbehaviors once merged.
higher order conflicts are painful to detect and expensive to fix because they might be originated by the interference of apparently unrelated changes.
in this paper we present behavioral driven conflict identification bdci a novel approach to conflict detection.
bdci moves the analysis of conflicts from the source code level to the level of program behavior by generating and comparing behavioral models.
the analysis based on behavioral models can reveal interfering changes as soon as they are introduced in the scm system even if they do not introduce any textual conflict.
to evaluate the effectiveness and the cost of the proposed approach we developed bdci f a specific instance of bdci dedicated to the detection of higher order conflicts related to the functional behavior of a program.
the evidence collected by analyzing multiple versions of git and redis suggests that bdci fcan effectively detect higher order conflicts and report how changes might interfere.
ccs concepts software and its engineering software configuration management and version control systems software verification and validation collaboration in software development keywords software evolution conflict detection specification mining testing.
this work has been partially supported by the h2020 learn project which has been funded under the erc consolidator grant program erc grant agreement n. .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn .
.
.
.
reference format fabrizio pastore leonardo mariani daniela micucci.
.
bdci behavioral driven conflict identification.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction software development often requires working with multiple versions and multiple development branches in parallel .
for example developers may need to implement a bug fix without interrupting the development of new features.
this is often done by creating a new development branch dedicated to bug fixing which is later merged with the main branch.
the use of the branching logic gives flexibility to developers but also introduces issues.
in particular merge operations might be extremely painful due to any conflicting and interfering changes that need to be correctly managed in the merged version.
for instance brun et al.
reported that of merge operations in open source projects generate textual conflicts build problems and test failures kasi et al.
analyzed four popular open source projects hosted on github and concluded that conflicts occur regularly with a frequency ranging from to of the merge operations microsoft developers reported that most of the time dedicated to merge operations is spent on resolving conflicts and verifying correctness .
the relevance of the problem is further confirmed by the results of a recent survey conducted internally to microsoft which indicates that novel solutions for conflict detection and resolution are perceived as extremely useful in practice .
source code management scm systems support developers during their activity providing features such as version control branching and conflict detection .
when two branches are merged scm systems can detect and report textual conflicts that is changes occurring in different branches but targeting the same locations in the source files.
since resolving these conflicts might require significant effort especially when done after many changes have been accumulated on the individual branches workspace awareness has been investigated as a possible solution .
the key idea is to make developers aware of the ongoing changes implemented by the other developers in their workspaces so that they can timely react in case of potential textual conflicts.
these techniques are useful but are limited to textual conflicts and cannot detect higher order conflicts .
a higher order conflict takes place when merging two program versions in two different branches produces a faulty program without causing any textual conflict .
this happens when changes affecting different program locations interfere.
for example if two developers independently modify the implementation of a programarxiv .01650v1 aug 2017esec fse september paderborn germany fabrizio pastore leonardo mariani daniela micucci for sorting the items in a collection by changing the type of elements that can be added to the collection in one case and changing the sorting algorithm in the other case the two changes although targeting different areas of the code might not integrate well.
this may occur because the new version of the sorting algorithm might be unable to properly sort the new types of items that can be added to the collection.
these cases are particularly hard to detect because cannot be recognized by simply considering the changed lines of code but it is necessary to take into account the semantics of the program.
detecting and resolving higher order conflicts is painful and time consuming on one side but also extremely actual and important on the other due to the increasing popularity of modern scm systems1 such as git that encourage the use of the branching logic and thus facilitate the introduction of both textual and higher order conflicts.
some approaches address higher order conflicts by enriching workspaces with the capability to report concurrent changes to dependent artifacts such as changes to related classes .
these techniques may facilitate the detection of higher order conflicts but require developers to manually check all the reported changes to determine if they generate any actual higher order conflict.
moreover reporting to users any potential conflict even resulting from indirect dependencies may generate many false alarms while reporting potential conflicts resulting only from direct dependencies may miss several higher order conflicts.
speculative merging has been proposed to mitigate these issues and more efficiently address higher order conflicts .
the underlying assumption is that interfering changes should result in test failures.
thus to detect higher order conflicts the code in the developers workspaces is merged locally with the code extracted from other parallel development branches and then locally built and tested.
speculative merging extensively uses the resources in the developers machines for the merge build and test operations and its effectiveness depends on the fault detection capability of the test cases.
a poor or limited set of tests and assertions might severely limit its effectiveness.
moreover when a test failure is reported developers still have to manually inspect the concurrent changes to understand how they interfere and this might be expensive for non trivial changes.
online continuous integration systems such as travis provide speculative merging as a service thus eliminating the problems related to the consumption of computational resources on developers machines.
however except for resource consumption these systems are still affected by the same limitation than speculative merging that is its capability to detect higherorder conflicts depends on the number and extensiveness of the checks e.g.
the assertions implemented in the test cases.
in this paper we present behavioral driven conflict identification bdci a multi branch server side dynamic analysis technique that detects higher order conflicts in parallel development branches by explicitly deriving and analyzing a representation of the program behavior .
the key idea is that by implementing conflict detection at the level of the program behavior it is possible to detect interfering 1according to recent surveys of the debian projects use modern scm environments and of the medium and large enterprises surveyed in use git.changes at the place where the interference can be observed regardless the place where the changes have been implemented.
for instance changes to apparently unrelated classes may cause interference in a same program location.
this interference might be hard to detect by looking at program dependencies but it is easy to detect when looking at the program behavior because both code changes would affect exactly the same behavior.
bdci leverages specification mining to automatically generate models that represent the behavior of the program and model analysis to both determine how the behavior of the program has changed along each branch and compare the modified behaviors to identify higher order conflicts.
the identified higher order conflicts are returned to developers as soon as they are introduced in parallel branches well before they produce misbehaviors in the merged version allowing developers to timely address conflicts when they are still easy to fix.
since bdci compares mined models to identify higher order conflicts its effectiveness is not dependent on the assertions implemented in the test cases as in speculative merging but it simply requires the availability of some test inputs to run the program.
thus bdci can even work with automatically generated test cases.
moreover bdci provides a richer output compared to state of the art solutions.
in fact bdci indicates how each change has affected the behavior of the program generating information useful to quickly resolve higher order conflicts.
finally although this paper focuses on the functional behavior of a program the concept of analysis defined in bdci can be potentially exploited to investigate how changes impact other classes of behaviors such as performance or security related behaviors.
the empirical results obtained by analyzing multiple changes in the git and redis open source projects show that bdci can reveal higher order conflicts that cannot be detected with speculative merging.
the main contributions of this paper are the definition of bdci a novel and general approach to the detection of higher order conflicts.
the definition of bdci f a specific instance of bdci dedicated to the detection of higher order conflicts on the functional behavior of a program.
the release of a freely available implementation of bdci f which can be downloaded from unimib.it tools bdci .
an empirical validation that provides evidence of the effectiveness of bdci f. the paper is organized as follows.
section introduces the bdci approach and presents bdci f. section introduces a running example.
section describes how bdci fgenerates models of the functional behavior of a program.
section presents how bdci f uses the generated models for the detection of higher order conflicts.
section presents the empirical results.
section discusses related work.
section provides concluding remarks.
bdci bdci raises conflict detection from the source code level as done in current scm systems to the behavioral level by deriving and comparing models that represent the behavior of the software.
thebdci behavioral driven conflict identification esec fse september paderborn germany branch1branch2branch3 code version 1code version code version 5code version 3code version branch4 branch1branch2branch3 behavioral model version 1behavioral model version behavioral model version 5behavioral model version 3behavioral model version branch4 behavioral changesbranch1branch2branch3 behavioral model version 1behavioral model version behavioral model version 5behavioral model version 3behavioral model version branch4 higher order conflicts info about the behaviors responsible for the conflictphase model generationphase model analysis figure the bdci approach.
way bdci analyzes behavioral changes is similar to the way source code changes are handled by regular scm systems.
a commit operation may introduce some changes that modify the behavior of the software thus causing changes in the behavioral models.
changes introduced in parallel development branches can hence be compared according to their effect on the models.
in particular if the changes introduced in two parallel development branches affect the same behaviors in the models the developers will likely experience an interference once the code in these branches is merged.
bdci timely detects and signals these dangerous situations to the developers by analyzing the behavior of parallel software versions.
the bdci approach consists of two phases the model generation phase and the model analysis phase.
these two phases are executed sequentially and might be activated according to different strategies.
for instance they can be executed after a new version is committed to the scm system to detect higher order conflicts between the committed version and the other versions in the parallel development branches after a pull request or a merge operation to detect conflicts between the changes accumulated in two specific branches pull requests and merges are the operations typically used to merge contributions from different developers or every night to detect conflicts among the versions committed during the day and the ones in the other parallel branches.
figure shows the bdci approach applied to a software system developed along four different branches created from a common base version.
in the model generation phase bdci mines the models useful to detect higher order conflicts using a specification mining solution.
depending on the aspect that is investigated these models could target a specific class of program behaviors.
for instance models may potentially represent the functional behavior the performance the security related behavior of an application or a combination of them.
bdci generates behavioral models for all the versions that must be compared and analyzed that is the base version version in figure and the latest versions on the parallel branches versions to in figure .
in the model analysis phase bdci identifies behavioral changes and higher order conflicts relying on the models obtained in the model generation phase.
in particular bdci first identifies behavioral changes by comparing the model of the base version to the models of the versions in the parallel branches.
bdci then detects higher order conflicts by identifying the parallel branches that modified the same behaviors.
figure shows the comparisons performed between version and the versions in the other parallel branches.model analysis naturally detects changes that interfere according to the aspect represented in the models.
if the models represent the functional performance or security behavior of the application the higher order conflicts will consequentially target the functional performance or security behavior of the application respectively.
in addition to reporting the presence of higher order conflicts bdci reports information about the program behaviors responsible for the conflict.
note that interfering changes may often produce observable effects in program locations that are different from the places where the code has been modified.
bdci always returns information about the higher order conflicts by referring to the locations where they produce observable effects that can be exploited by developers to drive the conflict resolution process.
in this paper we focus on detecting higher order conflicts related to the functional behavior of a program.
in particular we show how bdci can be used to discover interfering changes that may result in annoying functional faults when merged into a same program version.
this specific instance of bdci is called bdci f. hereafter we will use the term bdci when describing general aspects and the term bdci fwhen referring to the specific instance of bdci for detecting higher order conflicts in the functional behavior of a program.
to capture the functional behavior of an application bdci ffocuses on function pre and post conditions.
in particular bdci fuses the daikon specification mining technique to discover properties that represent the values that can be assigned to function parameters and the z3 theorem prover to identify changes and conflicts between sets of properties associated with different program versions .
hereafter we will interchangeably use the terms models and properties because program properties and in particular pre and post conditions are the kind of models derived by bdci f. figure graphically illustrates how bdci fworks with specific reference to a software project with four parallel development branches all created from the same base version version .
we present bdci fconsidering the case it is executed after a commit operation.
when executed after a pull request or overnight bdci f simply runs the described analysis on all the relevant program versions.
we suppose version is the latest version committed to the scm system.
for simplicity we present the analysis only considering one property about the parameter port .
in the model generation phase bdci fuses daikon to derive properties for both the version under analysis version in the example and the latest versions available in the other parallel branches versions and in the example .esec fse september paderborn germany fabrizio pastore leonardo mariani daniela micucci branch1branch2branch3 version 1version version 5version port 0version port 2branch4 port 1port 0port higher order conflict detection for version version 5behavioral changes with respect to version version port port 1version no changeversion port port 2version port port legend changed intophase model generation phase model analysis version vs port behavioral changeversion port no behavioral change no conflict refactoring on version version 5version vs port behavioral changeversion port behavioral change higher order conflict non equivalent changes version 5version vs port behavioral changeversion port behavioral change no conflict equivalent changes legend mined by daikon figure the bdci fapproach.
bdci falso derives properties for version which is the latest common ancestor version of the compared versions.
this is necessary because bdci freveals higher order conflicts by comparing the program properties changed in version to the properties changed in versions and one at time.
the set of changes relevant to a comparison between two program versions in two different branches consists of all the changes that have been accumulated on the individual branches.
the effect of these changes on the behavior of the application can be determined by comparing the properties mined for the versions under analysis to the properties mined for their latest common ancestor version.
since in the example all the versions are obtained from version version is the latest common ancestor version.
the left side of figure shows the four branches the five program versions and the properties derived for parameter port .
since daikon mines program properties from traces collected during tests execution we assume that test cases are available under the scm system.
in the model analysis phase represented on the right side of figure bdci ffirst determines the behavioral changes and then identifies the higher order conflicts.
to determine the behavioral changes bdci fcompares the properties derived for each program version in the parallel branches versions to in the example to the properties derived for the latest common ancestor version version in the example.
the top right side of figure shows the behavioral changes identified by bdci f. only the changes in version do not affect the property port which holds both in version and version this may happen for example in the case of pure refactorings .
a higher order conflict occurs when the same property is changed in two different parallel branches.
to discover if version introduced a higher order conflict bdci fcompares the behavioral changes introduced in version to the behavioral changes in the other parallel branches.
the right bottom part of figure reports the outcome of the comparison of version to versions and .the comparison between version and version reports no conflicts because the property has been changed in a branch only while the parallel modification of a same behavior is necessary for the generation of a higher order conflict.
since version and version are characterized by parallel changes that affect the same property in the same way that is they lead to new properties that are equivalent the comparison between these two versions does not produce any conflict.
in our empirical experience we observed this case several times.
the most frequent reason for parallel and equivalent changes is the deployment of a same patch to a critical fault on all the active development branches.
finally a higher order conflict is reported by the comparison between version and version .
the changes in version modify the values that can be assigned to parameter port from port 0to port .
while the changes in version modify the values that can be assigned to parameter port from port 0toport .
changes in versions and could thus interfere on variable port and generate unpredictable results once merged.
bdci automatically identifies and reports this dangerous situation.
running example to illustrate bdci fwe use the simple example of higher order conflict shown in figure .
the example consists of three program versions the base version and two derived versions version and version implemented in two parallel development branches.
both version and version are derived from the base version which represents their latest common ancestor version.
the base version is composed of three c functions.
the getsaving function takes a price per unit a quantity and a discount as parameters and computes the money saved thanks to the discount.
some operations are delegated to auxiliary functions.
the gettotalprice function computes the total price in cents for the considered quantity of items taxes included.
the getdiscountedprice applies the discount rate to the total price.
version implements a new policy for the discount that is the discount is applied only if the price of the items is higher than 1000bdci behavioral driven conflict identification esec fse september paderborn germany int discount int gettotalprice int price int quantity int totalpricewithoutvat price quantity int vat return totalpricewithoutvat totalpricewithoutvat vat int getdiscountedprice int price return price price discount int getsaving int price int quantity int totalprice gettotalprice price quantity int discountedprice getdiscountedprice totalprice return totalprice discountedprice int discount int gettotalprice int price int quantity int totalpricewithoutvat price quantity int vat return totalpricewithoutvat totalpricewithoutvat vat int getdiscountedprice int price begin change if price return price price discount else return price end change int getsaving int price int quantity int totalprice gettotalprice price quantity int discountedprice getdiscountedprice totalprice return totalprice discountedprice int discount int gettotalprice int price int quantity begin change return price quantity end change int getdiscountedprice int price return price price discount int getsaving int price int quantity int totalprice gettotalprice price quantity int discountedprice getdiscountedprice totalprice return totalprice discountedprice base version version derived from base version version derived from base version figure an example of a higher order conflict.
cents i.e.
euros taxes included.
in figure the changed code is the one between the comments begin change and end change .
version implements the new requirement of computing savings without considering taxes.
thus the code that sums taxes to the total price is removed from the gettotalprice function.
the changed code is again indicated with begin change and end change .
note that version and version are correct programs that properly implement the respective requirements.
also note that the two parallel changes considered in the example target different functions and thus do not produce any textual conflict when version and version are merged together the functions could even be in different files .
however merging version with version does not produce a correct program.
the merged version would apply the discount to prices with a value greater than taxes excluded while the requirement specifies that taxes must be included in the computation.
merging these two programs requires adapting the condition in the getdiscountedprice function to work with prices that do not include taxes.
a regular scm system would merge version and version without generating any conflict.
a continuous integration system running regression test cases as well as speculative merging could reveal the problem in the merged version only if the test cases cover the faulty situation and include proper oracles that can detect the effect of the higher order conflict and only after the code has been merged.
in the next sections we show how bdci fcould report this higher order conflict to the developers as soon as version and version have been created and before they are merged.
compared to speculative merging bdci fonly requires the existence of test cases covering the change without requiring any oracle in the test case.
for this reason contrarily to speculative merging if test cases that cover the changes are not present in the program test suite bdci fcan straightforwardly work with automatically generated test cases.
model generation in the model generation phase bdci generates behavioral models for all the program versions that must be compared during the analysis phase.
depending on the policy used to execute bdci the set of program versions that must be compared might slightly change.
for instance when executed after a pull request bdci compares the latest program versions available in the branches that must be merged and when executed overnight bdci compares the latest program versions available in all the active branches.
in every case bdci compares pairs of versions.
for this reason this section and the next section present bdci fby describing how it compares version to version for the example program shown in figure .
the general case where multiple versions are compared can be obtained by iteratively comparing pairs of versions.
bdci fuses daikon as model generator .
daikon generates boolean expressions that represent the values that can be assigned to program variables.
it takes a set of variable values observed at a given program point as input and outputs a set of program properties that hold at the same program point.
for instance if the gettotalprice function is executed multiple times with a positive price and a positive quantity daikon can mine that its return value is always positive.
in order to obtain the samples necessary to run daikon bdci fassumes test cases are available under the scm system which is a standard practice in version control especially when a scm system is equipped with continuous integration capabilities .
in the model generation phase bdci fbuilds the system runs the test cases collects the values assigned to program variables at several program points and invokes daikon to obtain the program properties.
generating properties for every program location in the code requires collecting and processing a huge amount of data and this is not feasible for non trivial programs.
to restrict the focus of the analysis bdci fexploits the knowledge of the changes implemented in each branch.
in particular it automatically determines the functions that have been modified by running the unix diff program against the compared versions and their latest common ancestor version.
as monitoring points bdci fselects all the functions that might be directly influenced by the identified changes.
more precisely esec fse september paderborn germany fabrizio pastore leonardo mariani daniela micucci bdci fcollects data from the entry points and the exit points of all the functions that include modified statements the callers and the callees of these functions.
this simple criterion can be computed efficiently guarantees the selection of a reasonably small set of program points and focuses the analysis on the program locations that are likely to be affected by the changes.
in principle more sophisticated techniques could be used to select monitoring points such as program slicing techniques .
however we preferred to design a technique that is simple fast and returns a small set of observation points rather than a technique that might return a large list of program locations that might make the analysis too expensive or even infeasible.
bdci fconsiders entry and exit points to focus on function preand post conditions which are expected to have a quite stable behavior across versions and ignores the body of functions where extensive changes might easily occur.
the functions with a changed signature are not compared directly but are compared using the callers and callees of these functions as observation points.
in the running example bdci fcollects data about the getdiscountedprice because its body has been modified in version the gettotalprice function because its body has been modified in version and the getsaving function because it invokes the modified functions.
the same three functions are monitored in the base version version and version .
bdci fbuilds all program versions relevant to the analysis in the example the base version version and version and runs the tests available under scm to collect data.
data collection is performed by intercepting the execution at the entry and exit points of the selected functions and logging the values of all the variables in the scope of that locations.
finally bdci fruns daikon on the collected data to derive the pre and post conditions.
table reports the post conditions that bdci fcan derive for the three monitored functions.
the postconditions in version and version that differ from the base version are reported in boldface with gray background.
we omit pre conditions because they are not relevant to the discussion of the running example.
the label retindicates a function return value.
table post conditions of the monitored functions version gettotalprice getdiscountedprice getsaving base version ret price ret price ret version ret price ret price ret version ret price ret price ret model analysis the model analysis phase identifies higher order conflicts by identifying the behavioral changes in the versions that must be compared version and version in the running example and then determining if the compared versions have changed the same behaviors .
to determine the behavioral changes bdci compares the models derived for the versions under analysis against the model derived for their latest common ancestor version.
in the running example bdci fchecks equivalence between the pre and post conditions derived for the gettotalprice the getdiscountedprice and thegetsaving functions in version and and the pre and postconditions derived for the same functions in the base version.
according to the post conditions reported in table the changes in version affect the post conditions of the getdiscountedprice and the getsaving functions.
while the changes in version affect the post conditions of the gettotalprice and the getsaving functions.
to determine if changes generate any higher order conflict bdci fidentifies the pre and post conditions changed in both versions.
we call the set of these pre and post conditions the interfering region .
a non empty interfering region may indicate the presence of a higher order conflict.
in the running example the interfering region for version and version is not empty and consists of the post condition of function getsaving .
bdci freports a higher order conflict only in the case the two versions behave differently that is when the two versions both differ from the base version and differ from each other.
to determine if the interfering region indicates that the two software versions behave differently bdci fchecks the equivalence of the pre and post conditions in the interfering region.
in the running example the post conditions of function getsaving in versions and are not equivalent and bdci freturns a higher order conflict.
note that the knowledge of the changed properties represents a useful information to fix the higher order conflict.
in this case the changed properties clearly show that the changes in version affect the computation of the discount see the changed postcondition of function getdiscountedprice in table the changes in version affect the computation of the total cost see the changed post condition of function gettotalcost in table and these two changes interfere with the computation of the saving see the two changed post conditions of function getsaving in table .
this is a valuable information for developers who can inspect the code directly pointing at the functions that originate the conflict with the knowledge of how and where the changes interfere .
finally since higher order conflicts can be identified as soon as the two versions appear in the scm system before they are merged together developers can timely repair problems thus preventing the risk of experiencing failures with the merged code where the effect of multiple changes can significantly complicate failure analysis.
empirical evaluation in this section we evaluate the effectiveness and the costof bdci f. we investigate the effectiveness by comparing bdci fto state of the art methods based on speculatively merging .
in particular we performed two studies.
the objective of the first study is to investigate if bdci fcan reveal real higher order conflicts that cannot be detected with speculative merging.
to this end we analyzed parallel changes in the git version history and parallel changes in the redis version history for a total of parallel changes analyzed.
we found 7higher order conflicts in git and higher order conflict in redis that could not be revealed with speculative merging due to the limited capability of the test cases to detect behavioral changes.
to compare bdci fand speculative merging not only on the revealed higher order conflicts but also on the missed higher order conflicts we performed a second study.
since we do not knowbdci behavioral driven conflict identification esec fse september paderborn germany in advance all the higher order conflicts present in third party software we used conflicts injected in git for this study.
results show that the two approaches are complemental.
finally we investigate cost by reporting data about the runtime cost of the technique.
in the following we briefly describe our prototype implementation we report the studies with injected and real higher order conflicts and we conclude discussing threats to validity.
.
prototype implementation our prototype implementation targets c programs and consists of two main components the model generation component and the model analysis component.
the model generation component identifies the functions that must be monitored for a given set of changes under analysis implements the monitoring infrastructure for collecting runtime data on top of both the radar framework and the pin tool and integrates daikon to generate functions pre and post conditions.
the model analysis component implements the identification of changed pre and post conditions and integrates the z3 theorem prover to check equivalence between properties.
our prototype implementation and the rest of the experimental material can be downloaded from .
.
real conflicts to investigate how bdci fperforms with real cases we analyzed several parallel changes from the git and redis version history.
for our experiments we selected merges of non trivial complexity the changes in a branch must be distributed among at least different files that do not include a major redesign of the system we limit to the maximum number of functions modified by the changes in a branch .
for the git case study we selected all the merges with the above characteristics merged after sept. for the redis case study we selected merges pushed to the repository after feb .
to avoid the analysis of unrelated changes we focused on changes that either target dependent code changes of statements that use and define the same variables or are followed by a fix commit.
some of the selected cases produced either textual conflicts which could be detected with standard applications for version control or test failures which could be detected with speculative merging.
in addition to these cases the selected portion of the version history of the analyzed applications included a total of cases for git and cases for redis which might potentially produce higher order conflicts not detected with state of the art techniques.
we used these cases as benchmark for bdci fto evaluate its capability to detect higher order conflicts that could not be detected with speculative merging.
table results with real higher order conflicts application parallel changes hoc returned spurious hoc actual hoc analyzed git redis total note that every selected case includes a large number of pervasive changes that must be analyzed with bdci f. in fact the averagenumber of functions that have been changed in two branches under comparison is with a maximum of for git and changed functions with a maximum of for redis.
although the pervasiveness of the changes represents a challenging aspect for techniques that compare program versions bdci fcoped well with this magnitude of changes as suggested by the results that have been obtained.
we analyzed these cases by running bdci fwith the test suites provided with the programs and we discovered a total of higher order conflicts that could not be detected by speculative merging as shown in table .
out of the higher order conflicts conflicts were spurious anomalies.
these conflicts could be quickly discarded because caused by variables that can be legally assigned with conflicting values in two distinct development branches.
in our case the higher order conflict was caused by a file descriptor variable that legally changed its value in two parallel branches.
more interestingly we discovered problematic higher order conflicts in git and in redis.
to confirm the presence of a problem in these cases we implemented a test case that covers the change and passes when executed in the versions before the merge but fails after the merge operation.
we thus confirmed that bdci fhas been able to discover unknown higher order conflicts out of the merge operations that have been analyzed.
we also manually analyzed the rest of the changes without finding any additional higher order conflict further confirming the accuracy of bdci f. to give evidence of the qualitative effectiveness of bdci f here we briefly discuss the higher order conflicts that have been identified.
five higher order conflicts affect the functionality that prints the content of the packets processed by git to the standard output.
the changes in the two branches both affect the heading printed by the function packet trace .
the merged version masks the effect of the changes performed in one of the branches.
bdci fdetected this interference from the pre condition of function trace strbuf fl which is used in packet trace .
a similar problem affects function rdbcheckthenexit that is used by redis to trace errors in the redis database management system.
out of the two remaining higher order conflicts one affects function get wcwidth which computes the length of a unicode character.
the changes in the compared branches affect this function producing an interference in the merged code.
bdci fcould detect this problem from the pre condition of function bisearch which is used in get wcwidth .
the last higher order conflict affects functions cmd clone andcheckout that present different postconditions in the three versions of the software.
this behaviour depends on changes in function wait or whine .
.
injected conflicts to generate higher order conflicts in a controlled way we started from two non conflicting changes targeting depending code blocks and located in two parallel branches in git2 and we systematically mutated one of these changes i.e.
the set of statements that can be mutated is restricted to the statements changed in a branch using the milu mutation testing tool .
since mutations always alter 2for reference the date and time of the git versions that we used are and .esec fse september paderborn germany fabrizio pastore leonardo mariani daniela micucci table results with injected higher order conflicts analyzed casegenerated properties changed outcome base version in version in pre post conditions bdci f spec.
merge version branch branch version in version in number of hoc hoc same del new same del new branch branch conflicts detected detected base case case ssdl no yes case ocng no yes case crcr no no case crcr no yes case crcr no yes case ssdl no yes case ocng no yes case crcr no yes case crcr no yes case crcr no no case ssdl yes no case crcr yes no case crcr yes no case crcr yes no case crcr yes no case crcr yes no case crcr yes no case crcr yes no case ssdl yes yes total the statements already modified by a change the mutated program includes the same logical change than the original program but with a slightly modified semantics induced by the mutation.
of course not all the mutants result in a higher order conflict.
sometimes the mutation does not interfere with the changes implemented by the version in the other parallel branch.
we manually analyzed the resulting mutants and after discarding equivalent redundant and mutants that do not produce higher order conflicts we ended up with a total of cases each consisting of two program versions that include parallel changes that produce a higher order conflict.
we analyzed all the cases using both bdci fand speculative merging.
for bdci f we executed the analysis and collected data about the generated properties and the detected higher order conflicts.
for speculative merging we merged the two program versions built the code executed the test cases and used test failures as detectors of higher order conflicts.
since no test case in the git test suite was designed to cover the changed statements we used a set of manually designed test cases that cover the changes in the analyzed branches to run the program.
table shows the results that we obtained.
column analyzed case lists the cases that have been analyzed.
the first row represents the base case with no mutation and thus with no higher order conflicts.
the successive rows list the analyzed cases.
between brackets we report the mutant operator that has generated the case under analysis see agrawal et al.
for a quick reference about mutant acronyms .
column generated properties reports statistics about the number of pre and post conditions that bdci fhas generated for the base version and the versions in the two branches distinguished as version in branch andversion in branch .
for the two compared versions we also report the number of unchanged same dropped del and newly new identified properties between brackets.
note that these columns report data about the number of individual properties that compose pre and post conditions.
results show that bdci fhas been able to derive hundreds of properties about the values that can be assigned to program variables intuitively suggesting that the mined models well cover thebehavior of the application for the selected functions.
the effect of the changes on these properties varies a lot depending on the nature of the change.
the changes for the version in branch significantly modify the values that can be assigned to program variables resulting in several properties that are dropped and newly mined.
the changes for the version in branch mostly alter the execution flow with little effect on function parameters thus only few properties are affected by the changes.
in particular no property changes in cases from case to case and only few properties change in cases from case to case .
column changed pre post conditions indicates the number of preand post conditions that have been changed in each version.
it is possible to notice that bdci fhas been always able to generate a small but useful number of pre and post conditions that suitably captured the semantics of the change for the version in branch while it succeeded partially with the version in branch .
as already mentioned this is due to the nature of the change that mostly affects the control flow while the properties used by bdci f to discover higher order conflicts mostly capture the data flow of a program.
finally column outcome reports results about the higher order conflicts returned by bdci fand speculative merging.
in the case of bdci f we also report the number of higher order conflicts returned by the technique which intuitively represents the amount of information available to developers to identify the source of the conflict.
the last row indicates the total number of higher order conflicts detected by bdci fand speculative merging.
both bdci fand test execution had similar effectiveness revealing higher order conflicts each.
however the set of revealed conflicts is complemental each technique revealed higher order conflicts that the other technique has not been able to reveal and only higher order conflict has been revealed by both approaches.
two higher order conflicts have not been detected by any technique due to the lack of test cases covering the behaviors that produce the higher order conflicts.
the complementarity between bdci fand speculative merging is due to the intrinsic characteristics of these approaches.
whenbdci behavioral driven conflict identification esec fse september paderborn germany model generation model analysis total time time minutes figure runtime cost of bdci f horizontal box plot .
the interference in the behavior of the application produced by the higher order conflict alters the execution flow and propagates to the output of the application such as for cases from case to case the conflict can be easily detected by the checks performed by the test cases on the output values produced by the tested program but it might be harder to reveal with bdci f. this happens because due to the altered execution flow some functions are not executed and some properties are not generated anymore thus reducing the set of pre and post conditions that can be compared.
in a sense changes that significantly alter the execution flow might leave bdci fwith too few pre and post conditions that can be compared.
although bdci fhas not revealed these cases they can still be potentially addressed with bdci for instance by deriving models that capture the sequences of operations that are executed by a program in addition to the values that can be assigned to program variables.
incorporating this kind of information in the models generated by bdci fis part of our future work.
when the higher order conflict is tricky to detect such as for cases from case to case test cases may fail to reveal it.
for instance tests may fail to propagate the wrong behavior to the output or they may check output variables that are not affected by the interference as happen for cases from to .
on the contrary bdci fdetects interfering behaviors using behavioral models so it is usually enough to execute the changes to obtain models that capture their semantics without any need of propagating the effect of the interference to the output.
in a nutshell bdci fdoes not need test cases but only test inputs that is bdci needs the runtime data to generate behavioral models but it never exploits the oracles in the test cases.
thus bdci might be applied to systems and components that are not maintained together with the test cases as long as test inputs can be generated automatically.
contrarily using test cases to exploit higher order conflicts strongly depends on the effectiveness of the test cases.
overall the complementarity between bdci fand speculative merging might be exploited to effectively address most of the higherorder conflicts .
in fact the union of the two approaches which simply corresponds to both running the test cases and analyzing the behavior of the program with bdci f reveals out of the higher order conflicts considered in the evaluation.
.
efficiency we executed the experiments on a machine equipped with an intel r xeon r cpu .53ghz.
we measured the runtime cost of model generation and model analysis as well as the total runtime cost.
figure shows a box plot of the runtime cost.in general model generation requires less although comparable time than model analysis.
the major costs affecting model generation are the execution of the test cases the monitoring overhead and the many calls to daikon.
model analysis requires several calls to z3 to compare the pre and post conditions to both identify behavioral changes and higher order conflicts.
the overall runtime cost of bdci fhas ranged between and minutes with a mean value of minutes.
these results suggest that bdci fcan be regularly applied to test overnight sessions to pull requests and to sporadically analyze commit operations.
.
threats to validity the main threats to internal validity are about the correctness of our prototype implementation.
we are confident on the correctness of our bdci fimplementation because we executed the tool on several sample cases first to eliminate obvious faults.
in addition for all the results reported in the paper we manually analyzed the considered case and the output produced by bdci f thus reducing the probability that incorrect results are reported.
the main threats to external validity are about the generalizability of our findings.
we experienced bdci fwith a number of parallel changes in non trivial programs and used both real and injected conflicts for the evaluation.
the injected conflicts have been obtained by modifying real changes in parallel branches which should mitigate the risk of generating unrealistic cases.
although additional evidence should be obtained to fully generalize the results the empirical evidence obtained so far already suggests that bdci f could be a useful solution to improve the capability of detecting higher order conflicts early in the development process.
related work the problem of coordinating multiple developers and multiple teams working on a same project is well known in software engineering.
coordination issues cover many abstraction levels from the provisioning of basic functionalities such as computer mediated communication to the provisioning of integrated operations such as continuous coordination .
in this paper we focus on the problem of revealing the code level conflicts that may result from parallel developers activity.
this problem has been already addressed with two main classes of solutions techniques for detecting textual ordirect conflicts and techniques for detecting higher order orindirect conflicts.
techniques for detecting higher order conflicts can be further distinguished in techniques using structural information and techniques using behavioral information.
detection of textual conflicts.
the ability to detect textual conflicts is a fundamental feature of every scm system such as svn and git .
these scm systems although popular are not only limited to textual conflicts but can only detect conflicts reactively that is once two versions have been merged.
since resolving conflicts as soon as they have been introduced in the software is definitely easier than fixing them late once software versions have been merged several techniques for proactive detection of textual conflicts have been defined .
the key idea is that conflict detection should be executed early before the code is merged for instance every time a new version is committedesec fse september paderborn germany fabrizio pastore leonardo mariani daniela micucci to the scm system or even when developers save changes locally to their workspaces.
the result of the analysis can be made available directly in the developer workspace to make developers aware of the ongoing activities and possible conflicts .
some well known techniques for proactive detection of textual conflicts are fastdash which can prevent potential conflicting situations by providing a visual presentation of the developers activities on shared files bscw which provides a web based shared workspace that integrates versioning facilities celine which uses a hierarchical workspace to scale to very large projects and elvin which provides awareness of direct conflicts.
bdci is also a proactive conflict detection technique that can detect conflicts as soon as they are introduced in the scm system.
compared to these techniques bdci is not limited to textual conflicts which are usually easy to detect but is designed to address higher order conflicts which are more challenging to detect .
detection of higher order conflicts using structural information.
higher order conflicts are conflictual changes that do not cause textual conflicts but produce syntactic or semantic problems in the merged version of the program.
these conflicts are particularly difficult to detect and painful to fix .
several techniques addressed the problem of detecting higher order conflicts by computing a representation of the dependencies between the components in a program for instance using a program dependency graph or an abstract syntax tree.
this representation is used to track the changes implemented by the developers and detect possible conflicts such as concurrent changes on dependent artifacts.
the notable solutions implementing this approach differ on the representation of the program dependencies used to identify potential conflicts.
collabvs uses a program call graph tukan uses a program def use graph palant r uses a program dependency graph and syde uses an abstract syntax tree.
program dependencies are an important source of information for potential conflicts but not all changes on dependent artifacts result in higher order conflicts and reporting any potential conflict including the ones originated by indirect dependencies might overwhelm users of false alarms.
while reporting only changes to directly dependent artifacts may miss important and tricky conflicts.
bdci overcomes these issues by working on the behavior of the program rather than on program dependencies.
in this way bdci can exactly establish how and where a change impacts on the behavior of the program and precisely determine if two concurrent changes even in remotely dependent code fragments may cause interferences once merged.
detection of higher order conflicts using behavioral information.
reporting the potential conflicts by looking at the program dependencies still requires developers to analyze the program changes in details to determine the presence of actual conflicts.
as done in bdci a few other techniques tried to improve the detection of higher order conflicts by looking at the impact of changes.
in particular safe commit runs test cases in the background to proactively identify the changes that can be safely committed crystal and wecode speculatively execute merge operations locally to the developer s workspace and run the buildand test processes to discover interfering changes.
specific strategies can be adopted to reduce the cost of test executions .
these techniques share with bdci the idea to look at the behavior of the program to reveal higher order conflicts.
however they only check the portion of the program behavior that is already checked by the oracles in the test cases e.g.
assert statements .
thus they can discover a conflict only if it causes a test failure.
bdci further elaborates the idea of working at the behavioral level to detect conflicts by explicitly generating a representation of the program behavior and studying the impact of concurrent changes on this representation.
while the strategy based on test case execution only checks the input output behavior of a program the strategy based on behavioral models implemented in bdci can detect interfering changes independently on the output generated by a program and the oracles in the test cases.
the empirical results reported in this paper provide evidence of the complementarity between these approaches.
finally when the tasks that developers must execute are known apriori and tracked by the development infrastructure the cassandra approach can be used to recommend developers task orders that minimize the chance to introduce conflicts .
bdci targets the frequent case this knowledge is not available and supports the detection of the conflicts that cannot be prevented by looking at task ordering.
detection of higher order conflicts in non code artifacts.
recently the detection of higher order conflicts gained attention also in the context of collaborative software design where higher order conflicts target design models rather than source code.
flame is a recently defined technique for proactive detection of higher order software design conflicts.
although targeting a different context it would be interesting to consider the possibility to extend flame with a conflict detection analysis working on the model semantics similarly to what bdci does for the code.
conclusions multi branch development of software applications might be challenging and requires proper methods and tools to be performed efficiently.
modern scm systems such as git encourages the use of the branching logic but also increases the number of conflicts that might be introduced while working on multiple concurrent branches.
while the detection and resolution of textual conflicts is extensively supported the detection and resolution of higher order conflicts is still painful and only partially supported.
in this paper we presented behavioral driven conflict identification bdci an approach that introduces the novel idea to raise conflict detection from the source code level to the behavioral level .
the approach leverages two key technologies specification mining to automatically generate models that represent the behavior of the software and model analysis to identify the behaviors modified in each branch and the changes that might result in misbehaviors once merged.
bdci is a general approach that can be potentially applied to multiple aspects of the software under analysis.
in this paper we presented a specific instance of bdci namely bdci f that shows how this analysis can be used to reveal higher order conflicts that may impact on the functional behavior of an application.bdci behavioral driven conflict identification esec fse september paderborn germany artifact description our artifact includes the data necessary to replicate the results obtained with bdci ffor redis and git.
the artifact is available for download at the following url folders 0b8j pv7c6buvetuxqkdnoxboclk.
up to date information about the bdci toolset can be found at it tools bdci .
the artifact consists of a virtualbox3virtual machine with installed ubuntu bdci including its dependencies a set of scripts for re executing bdci on each subject and the rest of the data necessary to replicate the results reported in this paper.
in particular the virtual machine includes the source code the test cases and the intermediate results generated by bdci f e.g.
the data recorded while running the test cases and the models inferred with daikon for each set of versions that has been analyzed.
the intermediate results can be used to execute the model analysis phase without having to execute the test cases and generate the models.
in general our artifact can be exploited for multiple purposes it enables other researchers to replicate the results reported in the paper.
it provides a significant amount of data collected during the execution of the test cases available with git and redis.
such data can be used for different research purposes by other researchers.
it provides a set of scripts that can be adapted to run bdci on different program versions.
it provides a set of changes that introduce behavioral conflicts.
these changes can be reused by other researchers to evaluate their techniques.
.
structure of the artifact the artifact is organized as a virtualbox virtual machine with four virtual disks one disk contains bdci fand the operating system one disk can be used as working directory to run the analysis and the other two disks contain the data for git and redis.
the virtual machine is large it occupies 100gb of disk space after download.
the data and the results generated for each case considered in our experiments have been compressed in a tar.gz archive and needs to be decompressed before running the analysis.
.
replicability each case corresponds to a folder in the artifact.
each folder contains the script replicate.sh that can be executed to run the analysis.
the output of the analysis is saved in the file bdci.out .
note that each folder already contains the pre computed bdci.out file.
the filebdci.out is overwritten when replicate.sh is executed.
in the following we succinctly report the results generated by bdci f. for each case we report conflicts using the syntax model x y model for x model for y where x and y could be or where indicates the base version of the software and and indicate the two versions developed in parallel.
the part model x y identifies the two versions with incompatible models while the part after reports the models.
we use the identifiers as shown in the dataset to identify cases.
git cases .
these cases produce higher order conflicts that affect the functionality that prints the content of the packets processed by git to the standard output.
figure shows the output generated by bdci ffor these five cases.
the changes in the two branches affect the heading printed by the function packet trace .
bdci fdetects this interference from the pre condition of function trace strbuf fl which is used by function packet trace .
higher order conflict function tr ace strbuf f l enter model and and and not data not file not key line and and and not data not file not key line model and and and not data not file not key line and and and not data not file not key line model and and and not data not file not key line and and and not data not file not key line figure results for git cases .
.
.
git case .
figure shows the output generated by bdci f. this case is charachterized by a higher order conflict that affects function get wcwidth which computes the length of a unicode character.
bdci fdetects this problem from the pre condition of function bisearch which is used in function get wcwidth .
higher order conflict function bisearch enter model and max not table and or max max not table model and max not table and max not table model and or max max not table and max not table figure results for the git case .
.
.
git case .
figure shows the output generated by bdci f. the functions cmd clone andcheckout can return different values in different branches.
this behaviour depends on the changes in function wait or whine .
this may create problems in callers that process the returned values.
higher order conflict function cmd clone exit model return or return return model return or return return model or return return or return return figure results for the git case .
.
.
redis case .
figure shows the output generated by bdci f. the conflict targets function rdbcheckthenexit which is used to trace errors in the redis database management system.
a change in the caller code makes the function log a different line number in case of errors see the values associated with parameter where .
this could create issues in tools that process log files.
higher order conflict function rdbcheckthenexit enter model where where model where where model where where figure results for the redis case .esec fse september paderborn germany fabrizio pastore leonardo mariani daniela micucci