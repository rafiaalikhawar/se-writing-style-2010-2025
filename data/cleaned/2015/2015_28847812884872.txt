an analysis of the search spaces for generate and validate patch generation systems fan long and martin rinard mit eecs csail usa fanl rinard csail.mit.edu abstract we present the rst systematic analysis of key characteristics of patch search spaces for automatic patch generation systems.
we analyze sixteen di erent con gurations of the patch search spaces of spr and prophet two current state of the art patch generation systems.
the analysis shows that correct patches are sparse in the search spaces typically at most one correct patch per search space per defect incorrect patches that nevertheless pass all of the test cases in the validation test suite are typically orders of magnitude more abundant and leveraging information other than the test suite is therefore critical for enabling the system to successfully isolate correct patches.
we also characterize a key tradeo in the structure of the search spaces.
larger and richer search spaces that contain correct patches for more defects can actually cause systems to nd fewer not more correct patches.
we identify two reasons for this phenomenon increased validation times because of the presence of more candidate patches and more incorrect patches that pass the test suite and block the discovery of correct patches.
these fundamental properties which are all characterized for the rst time in this paper help explain why past systems often fail to generate correct patches and help identify challenges opportunities and productive future directions for the eld.
categories and subject descriptors d. .
testing and debugging keywords program repair patch generation search space .
introduction software defects are a prominent problem in software development e orts.
motivated by the prospect of reducing human developer involvement researchers have developed a range of techniques that are designed to automatically corpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa acm.
isbn .
.
.
.
defects.
in this paper we focus on generate and validate patch generation systems which work with a test suite of test cases generate a set of candidate patches then test the patched programs against the test suite to nd a patch that validates .
patch quality is a key issue for generate and validate systems.
because the patches are validated only against the test cases in the test suite there is no guarantee that the patch will enable the program to produce correct results for other test cases.
indeed recent research has shown that the majority of patches accepted by many current generate and validate systems fail to generalize to produce correct results for test cases outside the validation test suite and accepted patches can have signi cant negative e ects such as the introduction of new integer and bu er over ow security vulnerabilities unde ned accesses memory leaks and the elimination of core application functionality .
these negative e ects highlight the importance of generating not just plausible patches we de ne plausible patches to be patches that pass all of the test cases in the patch validation test suite but correct patches that do not have latent defects and do not introduce new defects or vulnerabilities.
a rich search space that contains correct patches for target defects can be critical to the success of any automatic patch generation system.
indeed recent research indicates that impoverished search spaces that contain very few correct patches is one of the reasons for the poor performance of some prominent previous patch generation systems .
while more recent systems work with patch spaces that contain signi cantly more correct patches continued progress in the eld requires even richer patch spaces that contain more successful correct patches.
but these richer spaces may also complicate the ability of the system to identify correct patches within the larger sets of plausible but incorrect patches.
.
spr and prophet spr and prophet are two current state of theart generate and validate patch generation systems.
both systems apply transformations to statements identi ed by an error localization algorithm to obtain patches that they validate against a test suite.
spr uses a set of hand coded patch prioritization heuristics.
prophet uses machine learning to characterize features of previously successful human patches and prioritizes candidate patches according to these features.
the goal is to prioritize a correct patch as the rst patch to validate.
the baseline spr and prophet search spaces contain correct patches for out of defects in a benchmark set of ieee acm 38th ieee international conference on software engineering defects from eight open source projects .1for of these defects the rst spr patch to validate is a correct patch.
for of these defects the rst prophet patch to validate is a correct patch.
the genprog ae rsrepair and kali systems in contrast produce correct patches for only genprog rsrepair or ae kali of the defects in this benchmark suite .
moreover the correct spr and prophet patches for the remaining defects lie outside the genprog rsrepair and ae patch spaces which suggests that these systems will never be able to produce correct patches for these remaining defects.
we note that this benchmark set was developed not by us but by others in an attempt to obtain a large unbiased and realistic benchmark set .
as these results highlight the characteristics of the patch search space are central to the success of the patch generation system.
but despite the importance of the search space in the overall success of the system we have been able to nd no previous systematic investigation of how the structure of the search space in uences critical characteristics such as the density of correct and plausible patches and the ability of the system to identify correct patches within the broader class of plausible but potentially incorrect patches.
given the demonstrated negative e ects of plausible but incorrect patches generated by previous systems these characteristics play a critical role in the overall success or failure of any patch generation system that may generate plausible patches with such negative e ects.
.
patch search space analysis we present a systematic analysis of the spr and prophet patch search spaces.
this analysis focuses on the density of correct and plausible patches in the search spaces on the ability of spr and prophet to prioritize correct patches and on the consequences of two kinds of changes both of which increase the size of the search space increases in the number of candidate program statements to which patches are applied and new program transformation operators that can generate additional patches.
starting from the spr and prophet baseline search spaces these changes make it possible to construct a collection of search spaces with each search space characterized by a combination of the set of transformations and the number of candidate program statements that together generate the search space.
we perform our analysis on a benchmark set of real world defects in eight large open source applications.
this benchmark set was used to evaluate many previous patch generation systems .
for each defect we rst analyze the full search space to determine whether or not it contains a correct patch.
we acknowledge that in general determining whether a speci c patch corrects a speci c defect can be di cult or in some cases not even well de ned .
but for the defects in the benchmark set this never happens the correct patches that are within the search spaces are all small all match the corresponding developer patches and the distinction between correct and incorrect patches is clear.
1the paper that presented this benchmark set states that the benchmark set contains defects.
an examination of the relevant commit logs and applications indicates that of these defects are actually deliberate functionality changes not defects.
in this paper we focus on the remaining actual defects as within the scope of the paper.because the full search spaces can in general be too large to exhaustively search within any reasonable time limit we also consider the subset of the search spaces that can be explored by spr and prophet within a reasonable timeout in this paper hours.
working with these explored subsets of spaces we analyze the number of plausible and correct patches that each subset contains and the e ect of the spr and prophet patch prioritization on the ability of these systems to identify correct patches within the much larger sets of plausible but incorrect patches in these search spaces.
.
results overview the experimental results indicate that sparse correct patches correct patches occur only sparsely within the search spaces.
for of the defects the search spaces contain no correct patches.
for of the remaining defects the search spaces contain at most correct patch.
the largest number of correct patches for any defect in any search space is .
relatively abundant plausible patches in comparison with correct patches plausible but incorrect patches are relatively abundant.
for all of the benchmarks except php the explored search spaces typically contain hundreds up to a thousand times more plausible patches than correct patches.
these numbers highlight the di culty of isolating correct patches among the large sets of plausible but incorrect patches.
the explored search spaces for php in contrast typically contain only tens of times more plausible patches than correct patches.
and for three of the php defects all of the one or two plausible patches are correct.
the density of plausible patches is related to the strength of the validation test suite weak test suites lter fewer incorrect patches.
we attribute the di erence in plausible patch density to the strength of the php test suite the php test suite contains an order of magnitude more test cases than any other benchmark.
spr and prophet e ectiveness the spr and prophet patch prioritization mechanisms are both effective at isolating correct patches within the explored plausible patches.
despite the relatively scarcity of correct patches with the baseline search space correct patches for defects are within the rst ten patches to validate for spr correct patches for defects are within the rst ten patches to validate for prophet.
search space tradeo s increasing the search space beyond the spr and prophet baseline increases the number of defects that have a correct patch in the search space.
but it does not increase the ability of spr and prophet to nd correct patches for more defects in fact these increases often cause spr and prophet to nd correct patches for fewer defects!
we attribute this phenomenon to the following tradeo .
increasing the search space also increases the number of candidate patches and may increase the number of plausible patches.
the increased number of candidate patches consumes patch evaluation time and reduces the density of the correct patches in the search space.
the increased number of plausible but incorrect patches increases the chance that such patches will block the correct patch i.e.
that the system will encounter plausible but incorrect patches as the rst patches to validate .
703these facts highlight the importance of including information other than the test suite in the patch evaluation process.
spr includes information in the form of hand coded patch prioritization heuristics.
prophet leverages information available via machine learning from successful human patches.
this information is responsible for the ability of these systems to successfully identify correct patches in the baseline search space.
the results also highlight that there is still room for improvement especially with richer search spaces that contain correct patches for more defects.
previous systems these facts also help explain past results from other systems.
genprog ae and rsrepair generate very few correct patches .
part of the explanation is that the search space exploration algorithms for these systems are no better than random search .2once one appreciates the relative abundance of plausible but incorrect patches and the relative scarcity of correct patches it is clear that any algorithm that is no better than random has very little chance of consistently delivering correct patches without very strong test suites.
and indeed the majority of the patches from these previous systems simply delete functionality and do not actually x the defect .
clearview clearview in sharp contrast does leverage information other than the test suite speci cally learned invariants from previous successful executions .
for nine of the ten defects on which clearview was evaluated clearview successfully patched the defect after evaluating at most three candidate patches.
these results highlight how targeting a defect class and leveraging fruitful sources of information can dramatically increase the successful patch density.
.
future directions our results highlight the scalability challenges associated with generalizing existing search spaces to include correct patches for more defects.
one obvious future direction deployed successfully in past systems is to address scalability issues by developing smaller more precisely targeted search spaces for speci c classes of defects.
an alternative is to infer transformation operations from correct human patches instead using manually de ned transformations .
the goal is to obtain a search space that contains correct patches for common classes of commonly occurring defects while still remaining tractable.
more broadly it is now clear that generate and validate systems must exploit information beyond current validation test suites if they are to successfully correct any but the most trivial classes of defects .
one prominent direction is to exploit existing correct code in large code repositories to obtain new correct patches either via sophisticated machine learning techniques that learn to recognize or even automatically generate correct code automatically transferring correct code either within or between applications or even generalizing and combining multiple blocks of correct code throughout the entire software ecosystem.
encouraging initial progress has been made in all of these directions .
the current challenge is to obtain more sophisticated patches for broader classes of defects.
2other parts of the explanation include search spaces that apparently contain very few correct patches and errors in the patch infrastructure that cause the system to accept patches that do not even pass the test cases in the test suites used to validate the patches .an orthogonal direction is to obtain stronger test suites or even explicit speci cations that can more e ectively lter incorrect patches.
one potential approach is to observe correct input output pairs to learn to recognize or even automatically generate correct outputs for potentially narrowly targeted classes of inputs.
another approach leverages the availability of multiple implementations of the same basic functionality for example multiple image rendering applications to recognize correct outputs.
combining either of these two capabilities with automatic input generation could enable the automatic generation of much stronger test suites with potential applications far beyond automatic patch generation .
speci cation mining may also deliver potentially partial speci cations that can help lter incorrect patches.
.
contributions this paper makes the following contributions patch space analysis it presents an analysis of the patch search spaces of spr and prophet including how these patch spaces respond to the introduction of new transformation operators and increases in candidate program statements.
the analysis characterizes correct patches the density at which correct patches occur in the full search spaces and the explored space subsets.
plausible patches the density at which plausible patches occur in the explored space subsets.
patch prioritization the e ectiveness of the spr and prophet patch prioritization mechanisms at isolating the few correct patches within the much larger set of plausible patches the vast majority of which are not correct .
this paper presents the rst characterization of how correct and plausible patch densities respond to increases in the size and sophistication of the search space.
it also presents the rst characterization of how these search space changes a ect the ability of the patch generation system to identify the few correct patches within the much larger sets of plausible but incorrect patches.
tradeo it identi es and presents results that characterize a tradeo between the size and sophistication of the search space and the ability of the patch generation system to identify correct patches.
to the best of our knowledge this is the rst characterization of this tradeo .
results it presents experimental results from spr and prophet with di erent search spaces.
these results are derived from an analysis of di erent search spaces for the benchmark defects we consider search spaces for each defect and patch generation executions for the defects whose correct patches are inside any of the considered search spaces we run spr and prophet for each of the search spaces for each of these defects .
together these executions consumed over hours of cpu time on amazon ec2 cluster.
the results show sparse correct patches correct patches occur very sparsely within the patch spaces with typically no more than one correct patch in the search space for a given defect.
relatively abundant plausible patches depending on the strength of the validation test suite plausible patches are either two to three orders of magnitude or one order of magnitude more abundant than correct patches.
patch prioritization e ectiveness the spr and prophet patch prioritization algorithms exhibit substantial e ectiveness at isolating correct patches within the large set of plausible patches most of which are incorrect .
challenges of rich search spaces the challenges associated with successfully searching such spaces include increased testing overhead and increased chance of encountering plausible but incorrect patches that block the subsequent discovery of correct patches.
progress in automatic patch generation systems requires the development of new larger and richer patch search spaces that contain correct patches for larger classes of defects.
this paper characterizes for the rst time how current state of the art patch generation systems respond to changes in the size and sophistication of their search spaces.
it therefore identi es future productive directions for the eld and provides a preview of the challenges that the eld will have to overcome to develop systems that work productively with more sophisticated search spaces to successfully patch broader classes of defects.
.
spr and prophet we next present an overview of the two automatic patch generation systems spr and prophet whose search spaces and search algorithms we analyze.
.
design overview spr and prophet start with a defective program to patch and a validation test suite.
the test suite contains a set of negative test cases which the original program does not pass these test cases expose the defect in the program and a set of positive test cases which the original program already passes these test cases prevent regression .
the test cases include correct outputs for every input the negative test cases produce di erent incorrect outputs .
the system generates patches for the program with the following steps error localization the system rst uses an error localizer to identify a set of candidate program statements to modify.
the error localizer recompiles the given application with additional instrumentation.
it inserts a call back before each statement in the source code to record a positive counter value as the timestamp of the statement execution.
the error localizer then invokes the recompiled application on all test cases and produces based on the recorded timestamp values a prioritized list of target statements to modify.
the error localizer prioritizes statements that are executed with more negative test cases executed with fewer positive test cases and executed later during executions with negative test cases.
see the spr and prophet papers for more details .
apply transformations the system then applies a set of transformations to the identi ed program statements to generate the search space of candidate patches.
spr and prophet consider the following transformation schemas condition re nement given a target if statement to patch the system transforms the condition of the if statement by conjoining or disjoining an additional condition to the original if condition.
the following two patterns implement the transformation if c ... if c p ... if c ... if c p ... here if c ... is the target statement to patch in the original program.
cis the original condition that appears in the program.
pis a new condition produced by a condition synthesis algorithm .
condition introduction given a target statement the system transforms the program so that the statement executes only if a guard condition is true.
the following pattern implements the transformation s if p s here sis the target statement to patch in the original program and pis a new synthesized condition.
conditional control flow introduction before a target statement the system inserts a new control ow statement return break or goto an existing label that executes only if a guard condition is true.
the following patterns implement the transformation s if p break s s if p continue s s if p goto l s here sis the target statement to patch in the original program pis a new synthesized condition and lis an existing label in the procedure containing s. insert initialization before a target statement the system inserts a memory initialization statement.
value replacement given a target statement replace an expression in the statement with another expression.
copy and replace given a target statement the system copies an existing statement to the program point before the target statement and then applies a value replacement transformation to the copied statement.
condition synthesis the baseline versions of spr and prophet work with synthesized conditions pof the form e k and e !
k .
here eis acheck expression which we de ne as either a local variable a global variable or a sequence of structure eld accesses.
each check expression e must appear in the basic block containing the synthesized condition.
kis acheck constant which we de ne as a constant drawn from the set of values that the check expression etakes on during the instrumented executions of the unpatched program on the negative test cases.
value replacement the baseline versions of spr and prophet replace either one variable in the target statement with another variable that appears in the basic block containing the statement an invoked function in the statement with another function that has a compatible type signature and is invoked or declared in the source code le containing the statement or in an included header le or a constant in the statement with another constant that appears in the function containing the statement.
evaluate candidate patches the system then evaluates candidate patches in the search space against the supplied test cases.
to e ciently explore the search space spr 705and prophet use staged program repair .
at the rst stage the system operates with parameterized candidate patch templates which may contain an abstract expression.
it instantiates and evaluates concrete patches from a template only if the system determines that there may be a concrete patch from the template that passes the test cases.
for the rst three transformation schemas these schemas manipulate conditions the system rst introduces an abstract condition into the program and determines whether there is a sequence of branch directions for the abstract condition that will enable the patched program to pass the test cases.
if so the system then synthesizes concrete conditions to generate patches.
.
extensions we implement three extensions to the spr and prophet search spaces considering more candidate program statements to patch synthesizing more sophisticated conditions and evaluating more complicated value replacement transformations.
more program statements to patch the baseline spr and prophet con gurations consider the rst program statements identi ed by the error localizer.
we modify spr and prophet to consider the rst and statements.
condition synthesis extension cext we extend the baseline spr and prophet condition synthesis algorithm to include the and operators and to also consider comparisons between two check expressions e.g.
e k e1 e and e1 e where e e1 and e2are check expressions and kis a check constant .
in the rest of this paper we use cext to denote this search space extension.
value replacement extension rext we extend the baseline spr and prophet replacement transformations to also replace a variable or a constant in the target statement with an expression that is composed of either a unary operator and an atomic value i.e.
a variable or a constant which appears in the basic block containing the statement or a binary operator and two such atomic values.
the operators that spr and prophet consider are !
and .
in the rest of this paper we use rext to denote this search space extension.
.
spr prioritization order spr uses a set of hand coded heuristics to prioritize its search of the generated patch space.
these heuristics prioritize patches in the following order patches that change only a branch condition e.g.
tighten and loosen a condition patches that insert an if statement before the rst statement of a compound statement i.e.
c code block patches that insert an if guard around a statement patches that replace a statement insert an initialization statement insert an if statement or insert a statement before the rst statement of a compound statement and nally all the remaining patches.
for each kind of patch it prioritizes statements to patch in the error localization order.
.
prophet prioritization order prophet searches the same patch space as spr but works with a corpus of correct patches from human developers.
it processes this corpus to learn a probabilistic model that assigns a probability to each candidate patch in the searchapp.
loc tests defects spr prophet libti 77k lighttpd 62k php 1046k gmp 145k gzip 491k python 407k wireshark 2814k fbc 97k total table benchmark applications space.
this probability indicates the likelihood that the patch is correct.
it then uses this model to prioritize its search of the patch space.
a key idea behind prophet is that patch correctness depends on not just the patch itself but also on how the patch interacts with the surrounding code extract features for each patch in the corpus prophet analyzes a structural di of the abstract syntax trees of the original and patched code to extract both features which summarize how the patch modi es the program given characteristics of the surrounding code and features which summarize relationships between roles that values accessed by the patch play in the original unpatched program and in the patch.
learn model parameters prophet operates with a parameterized log linear probabilistic model in which the model parameters can be interpreted as weights that capture the importance of di erent features.
prophet learns the model parameters via maximum likelihood estimation i.e.
the prophet learning algorithm attempts to nd parameter values that maximize the probability of observing the collected training database in the probabilistic model.
prophet uses the trained model to rank the patches according to its learned model of patch correctness then evaluates the patches in that order.
previous results as well as additional results presented in this paper show that this learned patch correctness model outperforms spr s heuristics .
this result highlights how leveraging information available in existing large software development projects can signi cantly improve our ability to automatically manipulate large software systems.
.
methodology benchmark application we use a benchmark set of real world defects to perform our search space study.
those defects are from eight large open source applications libti lighttpd the php interpreter gmp gzip python wireshark and fbc .
note that the original benchmark set also includes ostensible defects which correspond to deliberate functionality changes not defects during the application development .
we exclude those functionality changes as outside the scope of our study because they are not actual defects.
table summarizes our benchmark defects.
the rst column app.
presents the name of each application.
the second column loc presents the number of lines of code in the application.
the third column tests presents the number 706defectlocalization rank rext cext lighttpd no no lighttpd no yes python no yes python yes no gmp yes no table search space extensions of the test cases in the supplied test suite of the application.
php is the outlier with an order of magnitude more test cases than any other application.
the fourth column defects presents the number of defects in the benchmark set for each application.
the fth column spr and the sixth column prophet present the patch generation results for the baseline versions of spr and prophet respectively.
each entry is of the form x y where y is the number of defects whose correct patches are inside the search space while x is the number of defects for which the system automatically generates a correct patch as the rst generated patch.
con gure systems we run spr and prophet on each of the di erent search space con gurations derived from all possible combinations of working with the rst or program statements identi ed by the error localizer whether to enable value replacement extension rext and whether to enable condition synthesis extension cext .
we run all of our experiments except those of fbc on amazon ec2 intel xeon .6ghz machines running ubuntu 64bit server .
.
fbc runs only in bit environments so we run all fbc experiments on ec2 intel xeon .4ghz machines running ubuntu 32bit .
.
generate search spaces for each search space and each of the defects in the benchmark set we run the congured spr and prophet to generate and print the search space for that defect.
we then analyze the generated search space and determine whether the space contains a correct patch for the defect.
with all three search space extensions the generated spr and prophet search spaces contain correct patches for ve more defects i.e.
defects in total than the baseline search space.
table summarizes these ve defects.
the rst column defect contains entries of the form x y z where x is the name of the application that contains the defect y is the defective revision in the application repository and z is the reference xed revision in the repository.
the second column localization rank presents the error localization rank of the modi ed program statement in the correct patch for the defect.
the third column rext presents whether the correct patches for the defect require the rext extension value replacement extension the fourth column cext presents whether the correct patches for the defect require the cext extension condition synthesis extension .
generate patches for each search space and each of the defects with correct patches in the search space we run spr and prophet to explore the search space for the defect.
for each run we record all of the plausible patches that the system discovers within the hour timeout.
analyze patches for each defect we analyze the generated plausible patches for the defect to determine whether the patch is correct or incorrect.
.
experimental results we next present the experimental results.
php is an outlier with a test suite that contains an order of magnitude more test cases than the other applications.
we therefore separate the php results from the results from other benchmarks.
we present the result summary for all of the defects for which any of the search spaces contains a correct patch.
see our technical report for the detailed results of each defect in all di erent search space con gurations.
table presents a summary of the results for all of the benchmarks except php.
table presents a summary of the results for the php benchmark.
each row presents patch generation results for spr or prophet with one search space con guration.
the rst column system presents the evaluated system spr or prophet .
the second column loc.
limit presents the number of considered candidate program statements to patch under the con guration.
the third column space extension presents the transformation extensions that are enabled in the con guration no no extensions baseline search space cext condition synthesis extension rext value replacement extension or rext cext both .
the fourth column correct in space presents the number of defects with correct patches that lie inside the full search space for the corresponding con guration.
the fth column correct first presents the number of defects for which the system nds the correct patch as the rst patch that validates against the test suite.
each entry of the sixth column plausible blocked is of the form x y .
here x is the number of defects for which the system discovers a plausible but incorrect patch as the rst patch that validates.
y is the number of defects for which a plausible but incorrect patch blocked a subsequent correct patch i.e.
y is the number of defects for which the system discovers a plausible but incorrect patch as the rst patch that validates and the full search space contains a correct patch for that defect .
each entry of the seventh column timeout is also of the form x y .
here x is the number of defects for which the system does not discover any plausible patch within the hour timeout.
y is the number of defects for which the system does not discover a plausible patch and the full search space contains a correct patch for that defect.
the eighth column space size presents the average number of candidate patch templates in the search space over all of the considered defects.
note that spr and prophet may instantiate multiple concrete patches with the staged program repair technique from a patch template that contains an abstract expression see section .
.
this column shows how the size of the search space grows as a function of the number of candidate statements to patch and the two extensions.
note that the cext transformation extension does not increase the number of patch templates.
instead it increases the number of concrete patches which each patch template generates.
the ninth column correct rank presents the average rank of the rst patch template that generates a correct patch in the search space over all of those defects for which at least one correct patch is inside the search space.
note that the correct rank increases as the size of the search space increases.
each entry of the tenth column plausible in 12h is of the form x y .
here x is the number of defects for which the system discovers a plausible patch within the hour 707systemloc.
space correct plausibletimeoutspace correct plausible correct limit extension in space first blocked size rank in 12h in 12h spr no .
.
spr cext .
.
spr rext .
.
spr rext cext .
.
spr no .
.
spr cext .
.
spr rext .
.
spr rext cext .
.
spr no .
.
spr cext .
.
spr rext .
.
spr rext cext .
.
spr no .
.
spr cext .
.
spr rext .
.
spr rext cext .
.
prophet no .
.
prophet cext .
.
prophet rext .
.
prophet rext cext .
.
prophet no .
.
prophet cext .
.
prophet rext .
.
prophet rext cext .
.
prophet no .
.
prophet cext .
.
prophet rext .
.
prophet rext cext .
.
prophet no .
.
prophet cext .
.
prophet rext .
.
prophet rext cext .
.
table patch generation results with search space extensions excluding php timeout.
y is the sum over the all of the considered defects of the number of plausible patches that the system discovers within the hour timeout.
each entry of the eleventh column correct in 12h is of the form x y .
here x is the number of defects for which the system discovers a correct patch blocked or not within the hour timeout.
y is the number of correct patches that the system discovers within the hour timeout.
.
plausible and correct patch density an examination of the tenth column plausible in 12h in tables and highlights the overall plausible patch densities in the search spaces.
for the benchmarks without php the explored search spaces typically contain hundreds up to a thousand plausible patches per defect.
for php in contrast the explored search spaces typically contain tens of plausible patches per defect.
we attribute this signi cant di erence in the plausible patch density to the quality of the php test suite and its resulting ability to successfully lter out otherwise plausible but incorrect patches.
indeed for three php defects the php test suite is strong enough to lter out all of the patches in the explored search spaces except the correct patch.
an examination of the eleventh column correct in 12h in tables and highlights the overall correct patch densities in the explored search spaces.
in sharp contrast to the plausible patch densities the explored search spaces contain on average less than two correct patches per defect for all of the benchmarks including php.
there are ve defectswith as many as two correct patches in any search space and one defect with as many as four correct patches in any search space.
the remaining defects contain either zero or one correct patch across all of the search spaces.
.
search space tradeoffs an examination of the fourth column correct in space in table shows that the number of correct patches in the full search space increases as the size of the search space increases across all benchmarks except php .
but an examination of the fth column correct first indicates that that this increase does not translate into an increase in the ability of spr or prophet to actually nd these correct patches as the rst patch to validate.
in fact the ability of spr and prophet to isolate a correct patch as the rst patch to validate reaches a maximum at candidate statements with no extensions then in general decreases from there as the size of the search space increases.
for php table shows that the number of correct patches in the space does not signi cantly increase with the size of the search space but that the drop in the number of correct patches found as the rst patch to validate is even more signi cant.
indeed the no prophet con guration nds correct patches as the rst patch to validate while the largest rext cext con guration nds only four!
we attribute these facts to an inherent tradeo in the search spaces.
expanding the search spaces to include more correct patches also includes more implausible and plausible but incorrect patches.
the implausible patches consume 708systemloc.
space correct plausibletimeoutspace correct plausible correct limit extension in space first blocked size rank in 12h in 12h spr no .
.
spr cext .
.
spr rext .
.
spr rext cext .
.
spr no .
.
spr cext .
.
spr rext .
.
spr rext cext .
.
spr no .
.
spr cext .
.
spr rext .
.
spr rext cext .
.
spr no .
.
spr cext .
.
spr rext .
.
spr rext cext .
.
prophet no .
.
prophet cext .
.
prophet rext .
.
prophet rext cext .
.
prophet no .
.
prophet cext .
.
prophet rext .
.
prophet rext cext .
.
prophet no .
.
prophet cext .
.
prophet rext .
.
prophet rext cext .
.
prophet no .
.
prophet cext .
.
prophet rext .
.
prophet rext cext .
.
table patch generation results with search space extensions php only validation time extending the time required to nd the correct patches while the plausible but incorrect patches block the correct patches.
this trend is visible in the y entries in the sixth column in table plausible blocked these entries count the number of blocked correct patches which generally increase as the size of the search space increases.
tables and show how this tradeo makes the baseline spr and prophet con gurations perform best despite working with search spaces that contain fewer correct patches.
increasing the candidate statements beyond never increases the number of correct patches that are rst to validate.
applying the cext and rext extensions also never increases the number of correct patches that are rst to validate.
our results highlight two challenges that spr and prophet and other generate and validate systems face when generating correct patches weak test suites the test suite provides incomplete coverage.
the most obvious problem of the weak test suite is that it may accept incorrect patches.
our results show that especially for larger search spaces plausible but incorrect patches often block correct patches.
for example when we run prophet with the baseline search space no there are only defects whose correct patches are blocked when we run prophet with the largest search space rext cext there are defects whose correct patches are blocked.a more subtle problem is that weak test suites may increase the validation cost of plausible but incorrect patches.
for such a patch spr or prophet has to run the patched application on all test cases in the test suite.
if a stronger test suite is used spr and prophet may invalidate the patch with one test case and skip the remaining test cases.
search space explosion a large search space contains many candidate patch templates and our results show that it may be intractable to validate all of the candidates.
for example with the baseline search space no prophet times out for only two defects whose correct patches are outside the search space with the largest evaluated search space rext cext prophet times out for seven defects whose correct patches are inside the search space .
note that many previous systems neglect the weak test suite problem and do not evaluate whether the generated patches are correct or not.
in contrast our results show that the weak test suite problem is at least as important as the search space explosion problem.
in fact for all evaluated search space con gurations there are more defects for which spr or prophet generates plausible but incorrect patches than for which spr or prophet times out.
.
spr and prophet effectiveness we compare the e ectiveness of the spr and prophet patch prioritization orders by measuring the costs and pay709search space spr prophetrandom random spr prophet no .
.
.
.
cext .
.
.
.
rext .
.
.
.
rext cext .
.
.
.
no .
.
.
.
cext .
.
.
.
rext .
.
.
.
rext cext .
.
.
.
no .
.
.
.
cext .
.
.
.
rext .
.
.
.
rext cext .
.
.
.
no .
.
.
.
cext .
.
.
.
rext .
.
.
.
rext cext .
.
.
.
table costs and payo s of reviewing the first generated patches excluding php search space spr prophetrandom random spr prophet no .
.
.
.
cext .
.
.
.
rext .
.
.
.
rext cext .
.
.
.
no .
.
.
.
cext .
.
.
.
rext .
.
.
.
rext cext .
.
.
.
no .
.
.
.
cext .
.
.
.
rext .
.
.
.
rext cext .
.
.
.
no .
.
.
.
cext .
.
.
.
rext .
.
.
.
rext cext .
.
.
.
table costs and payo s of reviewing the first generated patches php only o s for a human developer who reviews the generated patches to nd a correct patch.
we consider a scenario in which the developer reviews the rst generated patches one by one for each defect until he nds a correct patch.
he gives up if none of the rst patches are correct.
for each system and each search space con guration we compute over the defects that have correct patches in the full spr and prophet search space the total number of patches the developer reviews this number is the cost and the total number of defects for which the developer obtains a correct patch this number is the payo .
we also compute the expected costs and payo s if the developer examines the generated plausible spr and prophet patches in a random order.
see our technical report for the raw data used to compute these numbers.
tables and present these costs and payo s. the rst column presents the search space con guration.
the second and third columns present the costs and payo s for the spr and prophet patch prioritization orders the fourth and fth columns present the corresponding costs and payo s for the random orders.
each entry is of the form x y where x is the total number of patches that the developer reviewsand y is the total number of defects for which he obtains a correct patch.
these numbers highlight the e ectiveness of the spr and prophet patch prioritization in identifying the few correct patches within the many plausible but incorrect patches.
table presents the corresponding results for the php defects.
these numbers highlight the di erence that a stronger test suite can make in the success of nding correct patches.
the correct patch selection probabilities are dramatically higher for php than for the other benchmarks.
but note that as the patch search spaces become large the number of defects for which the developer obtains correct patches become smaller re ecting the increasing inability of the systems to nd any correct patch in the explored space within the hour timeout and the increasing presence of blocking plausible but incorrect patches.
finally these numbers highlight the e ectiveness of the prophet learned patch prioritization following this procedure the developer always obtains correct patches for at least as many defects with prophet as with spr.
.
threats to validity this paper presents a systematic study of search space tradeo s with spr and prophet.
one threat to validity is that our results will not generalize to other benchmark sets and other patch generation systems.
note that the benchmark set was developed by other researchers not by us with the goal of obtaining a large unbiased and realistic benchmark set .
and this same benchmark set has been used to evaluate many previous patch generation systems .
the observations in this paper are consistent with previous results reported for other systems on this benchmark set .
another threat to validity is that stronger test suites will become the norm so that the results for benchmark applications other than php will not generalize to other applications.
we note that comprehensive test coverage is widely considered to be beyond reach for realistic applications and even php which has by far the strongest test suite in the set of benchmark applications has multiple defects for which the number of plausible patches exceeds the number of correct patches by one to two orders of magnitude.
.
related work clearview clearview is a generate and validate system that observes normal executions to learn invariants that characterize safe behavior .
it deploys monitors that detect crashes illegal control transfers and out of bounds write defects.
in response it selects a nearby invariant that the input that triggered the defect violates and generates patches that take a repair action to enforce the invariant.
a red team evaluation found that clearview was able to automatically generate patches that eliminate of targeted firefox vulnerabilities with each defect eliminated after the generation of at most three patches.
we attribute the density with which successful patches appear in the clearview search space in part to the fact that clearview leverages the learned invariant information to focus the search on successful patches and does not rely solely on the validation test suite.
kali kali is a generate and validate system that deploys a simple strategy it simply removes functionality.
al710though kali is obviously not intended to correctly repair a reasonable subset of the defects that occur in practice it is nevertheless at least as e ective in practice as previous strategies that aspire to repair a broad class of defects .
these results are consistent with the results presented in this paper highlight the inadequacy of current test suites to successfully lter incorrect patches and identify one prominent source of the relatively many plausible but incorrect patches that occur in current patch search spaces.
an analysis of kali remove statement patches genprog patches and nopol patches for defects in the defects4j dataset produced results broadly consistent with the results in this paper out of manually analyzed plausible patches the analysis indicates that only patches are undoubtedly correct .
genprog ae and rsrepair genprog ae and rsrepair were all evaluated on for rsrepair a subset of the same benchmark set that we use in this paper to evaluate the spr and prophet search spaces.
the evaluations focus on plausible patches with no attempt to determine whether the patches are correct or not.
unfortunately the presented evaluations of these systems su er from the fact that the testing infrastructure used to validate the candidate patches contains errors that cause the systems to incorrectly accept implausible patches that do not even pass all of the test cases in the validation test suite .
a subsequent study corrects these errors and sheds more light on the subject .
this study found that the systems generate correct patches for only genprog rsrepair or ae of the benchmark defects functionality changes in this benchmark set the systems generate plausible but incorrect patches for genprog rsrepair and ae defects functionality changes and the majority of the plausible patches including all correct patches are equivalent to a single modi cation that deletes functionality.
moreover the correct spr and prophet patches for these defects lie outside the genprog ae and rsrepair search space suggesting that these systems will never be able to generate a correct patch for these defects .
moreover only of the plausible genprog patches are correct only of the analyzed plausible rsrepair patches are correct and only of the plausible ae patches are correct .
these results indicate that the genprog ae and rsrepair search space while containing fewer correct and plausible patches than the richer spr and prophet search spaces still exhibits the basic pattern of sparse correct patches and more abundant plausible but incorrect patches.
a subsequent study of genprog and rsrepair under the name trpautorepair on small student programs provides further support for this hypothesis .
the results indicate that patches validated on one test suite typically fail to generalize to produce correct results on other test suites.
rsrepair uses random search previous research found that the genprog genetic search algorithm performs no better than random search on a subset of the benchmarks .
systems such as genprog that perform no better than random will need to incorporate additional sources of information other than the validation test suite if they are to successfully generate correct patches in the presence of current relatively weak test suites.
3of course if the patch space does not contain correct patches stronger test suites will prevent the system fromcodephage horizontal code transfer repairs otherwise fatal defects by transferring correct code across applications .
it therefore provides another example of how leveraging additional information outside the validation test suite in this case correct code from other applications promotes the automatic generation of successful patches.
but of course horizontal code transfer is not limited to patch generation indeed it shows enormous potential for leveraging the combined talents and labor of software development e orts worldwide to solve a variety of software engineering problems.
speci cations explicit speci cations either provided by a developer or inferred provide an alternative to validation test suites.
researchers have built repair systems that leverage data structure consistency speci cations method contracts access control speci cations assertions and pre and post conditions .
other related work see the full version of this paper for a more comprehensive discussion of related work including dynamic program repair techniques for memory errors null pointer dereference and divide by zero errors in nite loops and memory leaks additional patch generation systems studies of human patch characteristics and task skipping and loop perforation which can improve performance and enable programs to survive tasks or loop iterations that trigger otherwise fatal errors .
.
conclusion the scope of any automatic patch generation system is limited by the range of patches in its search space to repair more defects future systems will need to work with search spaces that contain more correct patches.
this paper characterizes for the rst time how larger and richer search spaces that contain more correct patches can counterintuitively hamper the ability of the system to nd correct patches.
it therefore identi es a key challenge that designers of future systems must overcome for their systems to successfully generate patches for broader classes of defects.
experience with previous successful patch generation systems such as clearview prophet and codephage highlights how leveraging information outside the validation test suite enables these systems to successfully identify the few correct patches within the many plausible patches most of which are incorrect that the test suite validates.
we anticipate that future successful automatic patch generation systems will deploy even more sophisticated techniques that leverage the full range of available information test suites previous successful patches documentation even formal speci cations to successfully identify the correct patches available in larger richer patch search spaces.