enlightened debugging xiangyu li shaowei zhu marcelo d amorim alessandro orso georgia institute of technology federal univesity of pernambuco atlanta ga usa recife pe brazil xiangyu.li swzhu orso cc.gatech.edu damorim cin.ufpe.br abstract numerous automated techniques have been proposed to reduce the cost of software debugging a notoriously time consuming and human intensiveactivity.amongthesetechniques statisticalfault localization sfl is particularly popular.
one issue with sfl is that it is based on strong often unrealistic assumptions on how developersbehavewhendebugging.toaddressthisproblem we propose enlighten an interactive feedback driven fault localizationtechnique.givenafailingtest enlighten leveragessfland dynamic dependence analysis to identify suspicious method invocationsandcorrespondingdatavalues presentsthedeveloper with a query about the most suspicious invocation expressed in terms of inputs and outputs encodes the developer feedback on the correctness of individual data values as extra program specifications and repeats these steps until the fault is found.
weevaluated enlighten in two ways.
first we applied enlighten to real and seeded faults in open source programs using an automatedoracleasasimulateduser forover96 ofthesefaults enlightenrequiredlessthan10interactionswiththesimulated user to localize the fault and a sensitivity analysis showed that the results were robust to erroneous responses.
second we performed anactualuserstudyon4faultswith24participantsandfoundthat participantswhousedenlightenperformedsignificantlybetter than those not using our tool in terms of both number of faults localized and time needed to localize the faults.
ccs concepts software and its engineering software testing and debugging keywords debugging fault localization dynamic analysis in the title we use the term enlightened with its physical rather than spiritual meaning of well informed.
the technique we propose is well informed because it incorporates user feedback in its otherwise automated debugging process.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn ... .
introduction software debugging is a notoriously difficult time consuming and human intensive activity.
the task of locating the faulty code i.e.
fault localization specifically is one of the most challenging parts of debugging.
for this reason countless techniques have been proposedovertheyearstohelpdevelopersdecreasethecostoffault localization anddebuggingingeneral .amongtheseapproaches one that has been particularly successful is statistical fault localization sfl e.g.
.
the intuition behind sfl is that dynamic data collected while running passing and failing test cases can be used to perform a statistical analysis and to compute a suspiciousness value for each entity e.g.
statement basic block or predicate in the program.
basically the suspiciousness of a code entity should be directly resp.
inversely proportional to the number of failing resp.
passing test cases that traverse that entity.
although sfl has been adisruptive change in the area of debugging and has generated a tremendousamountoffollowupresearch ithassomesignificant limitations.mostsfltechniquestendtomakestrong oftenunrealisticassumptionsonhowdevelopersbehavewhendebugging.in particular previousworkhasshownthatitisunrealistictoassume that developers provided with a possibly long list of suspiciousstatements would go through this list in order and immediately spotthefaultwhentheyseeit withoutanyadditionalcontext .
to address these limitations of sfl while still taking advantage ofitsstrengths weproposeenlighten aninteractive feedbackdriven fault localization technique.
we defined enlighten so as to follow the way in which debugging is typically performed with thegoal ofhelping rather thancompletely replacing thehumans intheloop.typically developerswouldstudythefailureathand makehypothesesonwhatthecause s ofthefailuremaybe and examineasubsetoftheexe cutionthatcanconfirmordisprovetheir hypothesis.theywouldthenleveragetheadditionalunderstanding ofthefailureacquiredinthisprocesstomakenewhypothesesor refinetheexistingones examineadditionalsubsetsoftheexecution and so on.
this process would continue until either the developers give up or they find the fault.
enlightenaimstomimicandsupportthisprocessasfollows.
first it uses traditional sfl to formulate an initial hypothesis of where the fault may be.
second it identifies a relevant subset of theexecutionthatcanhelpsupportornegatetheformulatedhypothesis.
intuitively this execution subset is identified in the form of amethod invocationthat resultsin the executionof highlysuspiciousentities.third enlightenpresentsthedeveloperwitha queryabouttheidentifiedmethodinvocation expressedintermsof acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
dynamic dependency graph ddg feedback analyzer incorrect data values test results and coverage sfl calculator ranked list of statements1.
.
.
.
.
.
... query generatordebugging data debugging query feedbacktest runner dependency analyzer test suiteprogram enlighten qn op figure overview of the approach.
theinputandresultingoutputoftheinvocation.fourth enlighten collects the developer feedback on the correctness of individual data values in the provided inputs and outputs and encodes this feedbackasextraprogramspecifications i.e.
extrateststhatcan improve the sfl results .
finally enlighten repeats these steps until the fault is found or the developer decides to stop.
ourapproachcanovercometheimportantlimitationsoftraditionalsflthatwehighlightedearlier.specifically enlightendoes notrequiredeveloperstodecidewhetherastatementinisolation iscorrect butrathertocheckhigh levelinput outputrelationships at the method level.
we believe that operating at the level of ab straction of a method whose semantics is often well understood by developers can make the technique considerably more effective and usable.
moreover developers can skip queries that theycannot answer and as shown in our evaluation the technique isresilient to occasional erroneous responses.
basically when suc cessful enlighten can nicely guide the developers towards the faultbyfollowinganiterativeprocessthatgetstheirinputatalevel of abstraction they can typically understand.
to evaluate enlighten we implemented the approach and performedtwoempiricalstudies.inourfirststudy weusedanautomatedoracletosimulatethepresenceofadeveloperandapplied enlighten to a large number of faults in open source programs.
thefaultsweconsideredincluded27realfaultsand1 780mutation faults whichwegeneratedtoincreasethenumberofdatapoints.as our results show for over of the faults considered enlighten required less than interactions with the simulated user to localize the fault.
in the second part of our evaluation we performed anactualuserstudy.weselected4realfaultsand24participants and assigned to each participant two debugging tasks one to beperformed using enlighten and one to be performed using the debuggingtechnique s oftheirchoice.whenusingenlighten the participantsperformedconsiderablybetterthanwhendebugging withoutthehelpofourtool.theimprovementwassignificantin terms ofboth number offaults localized andtime needed tolocalize the faults.
overall we believe that our results provide a clear indication that enlighten is a promising approach for debugging and fault localization.the main contributions of this paper are enlighten anewdebuggingtechniquethatimprovestraditional fault localization approaches by incorporating user feedback.
atoolthatimplementsenlightenandthatispubliclyavailable togetherwithourexperimentdataandinfrastructure twocomplementaryevaluationsof enlighten anextensive analytical study with simulated users in which we evalu ate enlighten on a large number of faults and an actualuser study in which we evaluate enlighten in a realistic debugging scenario involving real users.
approach figure1providesahigh levelviewof enlightenandshowsinput left side output right side and main components of the technique inside the box .
as the figure shows enlighten takes as inputaprogramanditstestsuiteandproducesasoutputthelikely locationofthefault.thefaultlocalizationprocessof enlighten is iterative and user driven as indicated by the loop and the developer s avatar in the figure.
intuitively at the beginning of the process enlighten has limited knowledge about what may be causing a failure.
each iteration however adds relevant debugging information to enlighten s knowledge base which helps eventually locating the bug.
in the following we first briefly describe the main components of the technique and then discuss them in detail.
thetestrunneranddependencyanalyzer componenttakesas input the faulty program and a test suite for the program and computes foreachtest adynamicdependencegraph testresults coverage information and a set of incorrect data values.
thesflcalculator usesthetestresultsandthecoverageinformationtoproducearankedlistofsuspiciousstatements usinga traditional sfl approach.
thequery generator takes as input the program its test suite and the artifacts produced by the test runner and dependency analyzer and generates debugging queries using the sfl results.
each query consists of a method invocation together with itsinputs parameters plus relevant state and outputs including sideeffects whichthedevelopercanmarkascorrectorincorrect.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
thefeedbackanalyzer takesasinputtheresponsetoadebugging query.
if the developer has found the bug the process stops.
otherwise thefeedbackanalyzerupdatesthedebuggingdata based on the developer feedback and performs another iteration.
conceptually enlighten can operate with test suites that containtestcasestriggeringdifferentfaults.multiplefaultscannegativelyaffecttheinitialsflresults.however becauseenlighten generates queries for a specific test case the feedback provided by the user should overcome the noise introduced by the multiple faults.
moreover there are several techniquesthat can cluster test cases that fail for similar reasons e.g.
and that could be used to specialize the test suite before applying enlighten.
it is also worth noting that debugging queries do notneedtobe formulatedatthegranularityofmethodinvocations andalternative partial program executions could be used instead.
we choose to usemethodcallsbecausemethodsareafundamentalabstraction developersusetoreasonaboutprogramsemantics andthebehavior of many methods should be well understood by the developers.
.
test runner dependency analyzer the test runner is a traditional driver that takes a program and its testsuiteasinputandproducesasoutputthetestresults passor fail coveragedata andasetofincorrectvalues.thislatterisasetof incorrectvaluesthatisinitialized foreachtestcase withthevalue associated with the corresponding failure.
the feedback analyzer thenaddstothesetvaluesmarkedaserroneousbythedevelopersin response to queries.
in our implementation of enlighten which is for java programs a test failure can result in either an uncaught exception or a failing assertion.
in these cases the value associated with the failure is the reference to the object corresponding to the uncaught exception or the failed assertion respectively.
the dependency analyzer conversely produces a dynamic dependence graph ddg for every failing test in the test suite.
in theddg nodesrepresentoccurrencesofstatementsintheprogram whereas edges represent dynamic data or control dependences between these statements.
as it is traditionally done statements that containmorethan one definitionare split so thateach node contains at most one definition .
.
sfl calculator enlightenusesamodifiedversionofochiai toperformsfl.
weselectedochiaibecauseithasbeenshowntoperformwellin practice.
the specific formula we use to compute the suspiciousnessofastatement sissusp s aef radicalbig parenleftbigaep aef parenrightbig parenleftbigaef anf parenrightbig.inthe formula aef resp.
anf denotes the number of failing tests that covered resp.
did not cover s. the term aepdenotes the sum of theweightsofthepassingteststhatcovered s asopposedtothe numberofpassingteststhatcovered sintheoriginalformula .the approach assigns weight .
to the tests in the initial test suite and weight1tothevirtual teststhatencodethefeedbackprovided by the user see section .
.
the rationale for this decision is that we want the human feedback to have a high impact on the sfl results as it relates to very focused partial executions.
we picked these specific numbersso thatthere isan order ofmagnitude difference betweenthetwo.infuturework weplantoexperimentwithdifferent weights and better understand their effect.
in computing theformula statements that are not executed in any test are assigned a suspiciousness score of .
.
query generator enlighteninteractswiththedeveloperthroughdebuggingqueries which are expressed in terms of inputs and outputs of a suspicious methodinvocationandareaboutthecorrectnessofthatinvocation.
the query generation process consists of selecting a failing test selectingasuspiciousmethodinvocation and producinga debugging query.
we now describe each of these steps.
.
.
selecting a failing test.
enlighten generates debugging queries for a failing test.
when multiple failing tests exist and developersdonotspecifytheirtestofchoice thetechniqueselectsthe test that makes the smallest number of method calls.
the rationale is that shorter traces should be easier to debug.
.
.
selecting a suspicious method invocation.
before describing how enlighten selects suspicious method invocations wemust define the concept of value suspiciousness.
traditional sfl techniques e.g.
associate suspiciousness scores to program statements.
enlighten uses these scores to compute thesuspiciousness of values defined within a dynamic method invocation i.e.
a specific runtime instance of a method execution .
inthefollowing slice v invoc denotesthedynamicbackward slice associated withvalue definition v limited todynamic method invocation invoc v.instrdenotes the instruction associated with definition v i.e.
the instruction that defines v andsusp instr denotes the suspiciousness score of instruction instr as computed by the sfl calculator.
enlighten computes the suspiciousness of a value definition vfor a dynamic method invocation invoc in two steps.
first it computes the base suspiciousness of vas base susp v invoc max susp v prime.instr v prime slice v invoc .i t thencomputestheactualvaluesuspiciousnessof v val susp v basedonwhether vaffects throughdirectorindirectdependencies valuesalreadyknowntobeincorrect.specifically enlightencomputesval susp v by multiplying base susp v by anamplifying factorthat is equal to either if no previously labeled incorrect valuedependson v or1plusthenumberofincorrectvaluesthat dependon v otherwise.intuitively valuesthataffectothersthat developers previously labeled as incorrect are more suspicious.
to select the method invocation for the next query enlighten considers the output of all the invocations within the failing test execution being considered where the output includes the state of the objects passed as parameters the values of the modified global variables and objects and the return value or exceptionthrown .
1for each such output item enlighten computes the corresponding valuesuspiciousness i.e.
the value suspiciousness of the corresponding definition .
it then identifies the outputs with the highest value suspiciousness and selects the corresponding method invocation.
in case of ties enlighten prioritizes methods higher in the call chain and chooses randomly when all conditions are equal.
.
.
producing a debugging query.
conceptually a query is a setofquestionsintheform isthisvaluecorrect?
.specifically en lightenreportstothedevelopertheinputsandoutputsofamethod 1enlightencurrentlyignoresdatawrittenthroughi ooperations whichcouldbe added through additional engineering.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1set test passingtests ... 2set value incorrectvalues ... 4incorporatefeedback feedback feedback if feedback.isincorrectinput incorrectvalues.addall feedback.getincorrectinputvaluedefs return for value v feedback.getcorrectoutputvaluedefs test virtualtest new test virtualtest.setcoverage slice v feedback.invoc passingtests.add virtualtest if feedback.hasincorrectoutput response askiffaultfound if response yes return set instr directcov feedback.invoc.getdirectcoverage if response no removecoverage directcov else i don t know test virtualtest new test virtualtest.setcoverage directcov incorrectvalues.addall feedback.getincorrectoutputvaluedefs set instr transitivecov feedback.invoc.gettransitivecoverage restrictsflto transitivecov figure algorithm for incorporating feedback.
callthatproducesthemostsuspiciousoutput seesection2.
.
and highlightsthedatavalueswithvariouscolors andtransparency toindicatetheirrelativesuspiciousness.figure4showsanexample of a debuggingquery where the field numelems is classified as highly suspicious.
developers can answer positively or negatively to any number of questions in a debugging query.
a positive resp.
negative answer indicates that the developer believes the value is correct resp.
incorrect for that specific invocation.
intuitively labelinganoutputasincorrectindicatesthatthebugiseitherinthe methoditselforinoneofthemethodsitcalls.notethatdevelopers can also label an input as incorrect e.g.
an unexpected nullvalue labelinganinputasincorrecttellsenlightentoignorethecurrentinvocationandfocusonmethodsthatledtothisinvocationinstead.
.
feedback analyzer figure2showsthealgorithmforincorporatingthefeedbackprovided by developers through their answers to debugging queries seefigure1 .globalvariables passingtests andincorrectvalues declared at lines and store coverage information for passingtests and a set of known incorrect values observed during a debuggingsession.enlightenincorporatesfeedbackbymodifying these sets.
at lines the algorithm handles the case of the developer marking some values on the input as incorrect method getincorrectinputvaluedefs returnsthesetofvaluedefinitions specified as incorrect by the developer and the algorithm adds those values to the set incorrectvalues and returns.
lines handle the case in which the developer has labeled some output values as correct.
in this case enlighten creates a passing virtual test for each value vlabeled as correct and updates the debugging information accordingly function slicecomputes the dynamic backward slice from v and function setcoverage marks thestatements in theslice ascovered by thenewly created virtual test.
intuitively adding passing virtual tests reduces the suspiciousness of statements related to the computation of v. lines handle the case in which the developer has labeled some output values as incorrect which indicates that there maybe faults in the current method or in one of the methods it calls.enlightenthereforeasksthedevelopertocheckwhetherthefault is in the code of the current method and to provide one of threepossible answers yes no idon primetknow line .
if the developer s answer is yes the fault localization process ends line .
if the answeris no enlightenmarksallthestatementsinthemethod as not covered by any test which has the effect of setting to zero thesuspiciousness of all instructionsin this method line .
notethatthisdoesnotpreventenlightenfromlookingforthe fault in methods called by this method.
finally if the answer is idon primetknow enlighten slightly decreases the suspiciousness of thecurrentmethodbyaddingapassingvirtualtestwhosecoverageconsistsofthestatementsdirectlycoveredbythecurrentinvocation lines .
inthesetwolattercases i.e.
noandidon primetknowanswers the faultlocalizationprocessthencontinues.asinthecaseofincorrect inputvalues enlightenaddsoutputvaluesmarkedasincorrect to the set of known incorrect values.
lines then restrict the computation of sfl suspiciousness to the instructions covered directly or indirectly by the current invocation only.
.
illustrative example tohelpillustratethedetailsofourapproach weintroduceanexample consisting of a simple faulty program.
figure shows the code and corresponding test suite for class boundedstack which implementsastackofboundedsizeandwhichweadaptedfromprevious work .forbrevity weomittedthecodethatchecksthecapacity of the stackin method push.
the faultis located at line method popshould have no effect on an empty stack but it does not check whetherthestackisempty.consequently whenthestackisempty themethod popincorrectlydecrementsthefield numelems denotingthestacksize whichbecomesnegative.thisclasshasthreeunittests andtest t3failswithan arrayindexoutofboundsexception when calling bs.peek at line after calling bs.pop on an emptystack.atthatpoint thefield numelems is andtheexpression size at line evaluates to .
we now describe how enlighten would support a developer in localizing the fault in this code.
first iteration.
the left table in figure shows the initial sfl results line is the most suspicious statement while the actually faultylineisranked intheworstcase atfourthplaceamongthe eightexecutablestatementsoftheprogram.theimprecisionofsfl is caused by the fact that line happens to be invoked only in the failing test case and it thus has a stronger correlation with test failures than the actual faulty statement.
thevaluestoredinfield numelems definedduringtheinvocation ofclear getsitsbasesuspiciousnessscorefromthesuspiciousness ofthedefinitionatline13 whichis1 .
.thisscoreisthenmultiplied by its amplifying factor which is computed based on the set of incorrect data values.
this set initially only contains the exception object thrown when accessing the array elemsat line in t3.
because this exception object has a dynamic dependence on the valuestoredinfield numelems theamplifyingfactorassociatedwith that valuewould be andthe value suspiciousnessfor numelems would therefore be .
see section .
.
.
in this case the value suspiciousness of numelems would be the highestamongstallvaluesobserved.enlightenwouldtherefore authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1public class boundedstack integer elems int numelems boundedstack int max elems new integer void push integer k check size against capacity elems k void pop numelems integer peek if size return null else return elems void clear numelems int size return numelems ... test t1 boundedstack bs new boundedstack bs.push assertequals bs.size test t2 boundedstack bs new boundedstack bs.push bs.push bs.pop assertequals bs.peek test t3 boundedstack bs new boundedstack bs.push bs.clear bs.pop assertequals null bs.peek figure stack and corresponding test suite.
generatea debuggingquery for clear shown infigure4 withthe value of field numelems marked as highly suspicious i.e.
red .
after inspecting the inputs and outputs the developer would findthatthemethodcorrectlyset numelems to0andrespondtothe query accordingly.
as a result enlighten would add a virtual test to the test suite reflecting the positive feedback from the developer on that output value.
the coverage matrix on the right side of figure shows the updated rankings after this first iteration.
note thatfailingtestcasesandpassingvirtualtestcaseshaveweight1 as described in section .
.
second iteration.
the statements at lines and appear at the top of the ranking after the first iteration with suspiciousness .
.line8computesthevalueof bs.numelems inbs.pop while the execution of line and result in an array out of bound exceptioninbs.peek .thevalueof bs.numelems attheexitof pop andthereferenceoftheexceptionthrownby bs.peek havethus a base suspiciousness of .
.
because the observed failure dynamically depends on both these values their value suspiciousness is .
.
.
since there are two invocations that result in the same highest suspiciousness value let us assume that enlighten randomly picks the call to function peekfor the next query.
in this case theexceptionobject alongwiththe this reference would be the output of the call.
given this query the developer would realize that the exception isexpected asitiscausedbyastacksizethatwasalreadynegative attheentryofthecall.thedeveloperwouldthereforemarkfield numelems intheinputasincorrect.enlightenwouldthusaddthe value infield numelems tothesetofknown incorrectvalues which has the effect of increasing the amplifying factor associated withalldefinitionsthataffectthatvalue andreturn seesection2.
.
third iteration.
due to the increasein its amplifying factor during the last iteration the data value bs.numelems inbs.pop figure debugging query on the 1stiteration.
stmt.t1 t2 t3 susp.
.
.
.
.
.
.
.
.
result weight .
.
stmt.t1 t2 t3 t4 susp.
.
.
.
.
.
.
.
.
result weight .
.
figure coverage matrices before after the 1stiteration.
becomes the single most suspicious value definition with a suspiciousness score of .
.
.
enlighten would therefore select the invocation of pop for the third query to the developer.
the developer would likely and quickly understand the failure by observing that the value of this.numelems is at the entry of the call and at its exit and end the fault localization process.
empirical evaluation we conducted two complementary studies to evaluate enlighten an analytical study with simulated users section .
and a user studywithrealusers section3.
.theformerletusevaluateour techniqueon alarge numberof datapoints andunder varioussettings which is typically challenging in studies involving real users.
thestudywithrealusers conversely letusassesstheusefulnessof enlightenwhenconsideringactual developers behavior which can only be approximated in a simulation.
.
study with simulated users in this study we investigated different aspects of enlighten usingsimulatedusersandalargenumberoffaults.specifically we investigated the following research questions rq1.howmanyiterationsarenecessaryforenlightentolocalize a fault?
rq2.whatistheimpactofthecustomizedsflformulaandthe amplifying factor on the effectiveness of enlighten?
rq3.howsensitiveisenlightentoincorrectuserresponsesto debugging queries?
the first question evaluates the performance of enlighten in a scenarioinwhichtheuseralwaysanswersqueriescorrectly.the second question assesses the usefulness of some key features of enlighten.
finally the third question evaluates how the performanceof enlightendegradeswhentheaccuracyofthedevelopers responses degrades.
.
.
experiment setup.
benchmark programs and faults.
as benchmarks we used three open source programs widely used in fault localization research math lang andjsoup.mathandjsoupareavailableintheirpublic authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table benchmarks and faults considered.
benchmark classes methods kloc faults real mutation math lang jsoup repositories whereaslangisavailableinthedefects4jrepository .
mathisalsopartofdefects4j butwithdifferentversions fromtheonesweconsidered.
weselectedthesebenchmarksbecausetheydonotusefeaturesunsupportedbyjavapathfinder which enlighten currently leverages to build ddgs.
table presents these programs and faults.
since each program has multiple versions we report the number of classes number of methods and code size as numeric ranges.
we considered two sets of faults 27realfaults availabletogetherwiththebenchmarks and mutation faults which we created using the mutation tool major .
we discarded faults that traditional sfl ranked in a top position as we wanted to evaluate enlighten in the more challenging and more common cases in which vanilla sfl would not be useful.
this led to discarding of the real faults available.
forthemutationfaults weranmajorinitsdefaultconfiguration and only considered mutants killed by at least one failing test case.
simulatedusers automatedoracles .
weusedautomatedoracles inlieuofrealusers toanswerthequeriesthatenlightengenerated.
consider a query involving a specific invocation iof a method.
to suitably classify an output value as correct or incorrect the oracle re runsiusing the correct version of the program and compares this expected output with that of i s actual execution.
to ensure thatiis executed with the same input as the faulty program the oraclestartsthetestexecutiononthefaultyversionandreplaces thedefinitionofthefaultyclasswiththecorrectonerightbefore invoking i using runtime class re definition .
we assume deterministic executions so that any difference in program state between the two runs on the faulty and correct versions can only be caused by the fault.
also for each query our oracle only provides feedback on the most suspicious of the output values rather than on multiple ones.
note that providing feedback onmultiplevalueswouldhelplocatethefaultinfeweriterations andthuslikelyimprovetheperformanceofourtechnique.however webelievethattheapproachwechosemirrorswellthebehavior ofarealuser whoismorelikelytofocusononeoratmostafew output values than on all of them.
we confirmed this in our user study see section .
.
in the simulated study enlighten terminates when the currentmostsuspiciousdatavalueisactuallyfaulty i.e.
ithasbeen produced by a faulty statement and this value is computed directlyinthecurrentqueriedinvocation.ifthesetwoconditions are not met within iterations enlighten terminates the fault localization process and considers it failed.
metrics.we used two metrics for evaluating the effectiveness of enlighten thenumberofqueriesansweredbythesimulated user before finding the fault and the number of distinct method invocations involved in such queries the same invocation canbecome the most suspicious more than once .
we consider these metrics reasonable approximations of developer effort the formertable summary of results for real faults.
benchmark fault id irof invocs queries default w o wt w o af mathc ak 1 edi ak 1 6f ak 1 m ak 1 vs ak 1 3cdi ak 1 38crvg ak 1 19f ak 2 5mu ak 1 10mu ak 4 8ursu ak 1 langb10 b16 b24 b26 b28 b39 b5 b6 jsoup1 3 4 111 3 4 1 4 2 11 5 2 1 5 2 1 6 1 1cr1 81 6 1 1cr2 141 6 3 average .
.
.
.
measures the number of interactions between the developer and the tool the latter measures the number of times the developer needs to understand a new invocation i.e.
partial execution .
.
.
rq1 how many iterations are necessary for enlighten to localize a fault?
to answer rq1 we ran enlighten on our benchmarksandfaults.wediscusstheresultsfortherealfaultsandthose forthemutationfaultsseparately.table2showsthesummaryof our results for the real faults.
column fault id shows the identifierofthefaultsdocumentedintherepositoriesfromwhichwe obtained them.
column irof initial rank of fault shows the statement level rank of the fault produced by sfl on the first iteration of adebugging session.
column invocs showsthe number ofdistinctmethodinvocationsinthequeriesproducedtolocatethe fault.column queries showsthenumberofqueriesanswered by the simulated user before finding the fault.
column default shows the results obtained with the default configuration of en lighten whereas the remaining columns show results obtained using alternative configurations see section .
.
.
enlightensuccessfullylocalized23ofthe27 faultswithin 10iterationsorless and26ofthe27 faultswithin28iterations orless.in11casesenlightenrequiredonly1querytolocalizethefault eventhoughsfldidnotrankthefaultylinefirst.consideringallthefaultsinthestudy theaveragenumberofiterationsnecessary for localization was .
min max and the average number of invocations involved was .
min max .
we manually inspected the case of lang b26 for which enlighten fails to locate the fault with less than queries.
the faulty invocation is selected for the first time on the 15thdebugging query.
the suspicious output of this invocation is a string thatispartiallyincorrect.however duetotheparticularwaythe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table summary of results for mutation faults.
benchmark mut.
queriesnot found math .
.
.
.
lang .
.
.
.
jsoup .
.
.
.
total .
.
.
.
assertionof thefailingtest iswritten theamplifyingfactor forall characters in the string is the same and the oracle fails to identify the character that is actually incorrect.
in subsequent debugging queries thesamefaultyinvocationisselectedseveraltimes butthe oraclekeepsmissingtheincorrectcharacterforthesamereason.
we conjecture that in this case a real developer would be more likelytospottheerrorintheoutputstringandprovidetheright feedback as humans tend to view strings as a whole instead ofas individual characters.
our oracle is purposely weak to avoid unfairlyfavoringourtechniqueandconsidersthestringasmultiple values as discussed above.
wealsoanalyzedthecorrelationbetween irofand queries and betweenirofand invocs.thepearson scorrelationcoefficient betweenthenumberofqueriesandtheinitialrankofthefaultis .
whichsuggestsaweakpositivecorrelation.thecorrelation coefficientbetweenthenumberofdistinctinvocationsinthequeries and the initial rank of the fault is .
suggesting a moderateto strong positive correlation.
overall the results suggest some correlationbetweentheproblemdifficulty asmeasuredby irof and the performance of enlighten.
however the data also suggests that even in cases where irofhas a considerably high value queriescan be fairly low e.g.
math.m ak 1 and lang.b10 .
table3showsthesummaryofourresultsforthemutationfaults.
column queries showsthenumberofmutantsfor whichthenumberofqueriesneededtolocatethecorresponding fault was between the indicated min and max values.
for example only one query was necessary to locate faults i.e.
mutants inmath whereasbetweentwoandtenquerieswerenecessaryto localize47faultsinlang.overall enlightensuccessfullylocalized of the mutation faults and on average over of all mutation faults were localized with at most queries.
enlighten failed to localize the fault in only .
of the cases.
the results suggestthatenlightenworksslightlybetterformutationfaults thanforrealfaults atleastforthecasesweconsidered.thereason may be that many of the real faults are inherently more difficult to debug aconjecturethatispotentiallysupportedbytheobservation thatsomeofthesefaultswerepresentinthereleasedversionsof popular libraries.
answering rq1 our results show that enlighten can identify alargenumberoffaultswithinafewiterations.with10orless singleanswerstoqueries enlightenlocated85 oftherealfaults and of the mutation faults.
.
.
rq2 whatistheimpactofthecustomizedsflformulaand theamplifyingfactorontheeffectivenessofenlighten?
theweights usedtocomputestatementsuspiciousnessandtheamplifyingfactorusedtocomputevaluesuspiciousnessaretwoimportantaspectsof the design of enlighten.
this research question evaluates theireffectiveness.
to answer rq2 we ran enlighten disabling each ofthesefeatures separatelyandcomparedtheresultssoobtained with those obtained using both features.
table2showstheresultsforthisstudyinthecolumnslabeled queries .
column w o wt shows the number of answers to queriesthatenlightenneededtolocatethefaultwhenweights werenottaken into account i.e.
we simply set to the weights of all tests which are used to compute the term aepof the sfl formula in section .
.
results show that on average enlighten needed .
queries in this setting compared to .
queries in the defaultconfiguration whichcorrespondtoa34 increase.column w o af shows the number of queries when the amplifying factor af wasignored seesection2.
.
.whenusingthisconfiguration enlighten failed to locate the fault jsoup.1 3 4 and needed on average .
queries to locate the remaining faults.
this correspondstoa110 increaseoverthedefaultconfiguration.notethat due to the statistical nature of enlighten it is possible for the configurations w o wt and w o af to perform slightly better in some cases e.g.
math crvg ak 1 but these cases are rare.
weobservedsimilarresultsonmutationfaults whichwedonot report for space reasons.
for w o wt the success rate of locating the fault decreased by .
and the average number of queries increasedby3.
.for w oaf thesuccessratedecreasedby1.
and the average number of queries increased by .
answeringrq2 resultsindicatethatthecustomizedsflformulaandtheamplifyingfactorbothcontributetoimprove enlighten s performance.thecontributionofthecustomizedsflformulais lower compared to the contribution of the amplifying factor.
.
.
rq3 howsensitiveisenlightentoincorrectuserresponses to debugging queries?
so far we haveassumed that developers do notmakemistakes.inpractice however theycanerrbylabeling correct values as incorrect or vice versa.
this research questioninvestigates how sensitive is the performance of enlighten toincorrect values labeled as correct.
we leave to future work the investigation of the opposite case which we consider less likely to happen.
to conduct this study we modified our automatedoracle so that it produced this type of erroneous answers with aconfigurableprobability.specifically weconsiderederrorrates ranging from to with percentage points increments and measured the number of queries and the number of cases in which enlighten fails.
as before we configured the oracle to provide only one answer per query.
table shows for each benchmark and for the different error rates considered the average increase in the number of queries necessarytolocalizeafaultoverthecaseofanidealoracle i.e.
a userthatdoesnotmakemistakes .forexample whentheerroneous answer rate is enlighten needs on average .
more queries to locate a fault.
the results in the table show as expected apositivecorrelationbetweentherateoferroneousanswersand the increase in the number of answers required to locate a fault.however the results also show that enlighten is still able tolocalize the fault in almost all cases.
even with erroneous answers the average success rate was higher than .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table sensitivity of enlighten to human errors.
values indicate the percentual increase in the number of queries overanidealoracle i.e.
auserthatdoesnotmakemistakes .
benchmarkerror rate math .
.
.
.
.
.
lang .
.
.
.
.
.
jsoup .
.
.
.
.
.
average .
.
.
.
.
.
answeringrq3 althoughthenumberofqueriesneededtolocalize a fault increases with the ratio of erroneous answers enlighten cansuccessfullylocatethefaultinmostcaseseveninthepresence of considerable amounts of erroneous feedback.
.
user study inadditiontoourstudywithsimulatedusers weconductedtwo actual user studies to evaluate enlighten in a realistic scenario.
ouruserstudiesinvolvetwodebuggingtaskseach whereeachtask consists of localizing and proposing a fix for a fault in a program.
.
.
study setup.
benchmarks faults and participants.
the software benchmarks and faults we selected are non trivial real faults that existed in releasedversionsofpopularsoftwarelibrarieswritteninjava.to simulateascenarioinwhichparticipantsdebugcodewithwhich they are familiar we wanted software whose semantics should be well understood by a person with a computer science background.
to this end we chose code that involves either basic mathematical concepts or xml parsing.
in addition as we did for our simulated study weselectedfaultsforwhichtraditionalsfltechniquesdo not perform well i.e.
the faulty statements are not ranked among the most suspicious statements .
we do so to avoid trivial cases in which sfl by itself would be enough to localize the fault.
table summarizes the information about the two studies we performed.
foreach studyandeach taskin thatstudy it showsthe benchmark used in the task and a concise description of the correspondingfaultconsidered.asthetableshows thefaultsweused fortasks1 and4wereselectedfromabenchmarkusedinthe simulated study whereas the fault we selected for task was used in a previous user study on sfl techniques .
it is worth noting that although we used the same benchmark for tasks and the partsoftheprograminvolvedinthetwotasksaredifferent.inother words completing task should notaffectthe participants performance in task .
even if it had an effect it should benefit equally participants performing task with and without enlighten.
basedonourassessmentandobservationsduringpilotstudies thepairofdebuggingtasksineachstudyareofsimilardifficulty but thetasksin study2aresignificantlyharder thanthoseinstudy1.
this let us evaluate how enlighten performs on faults at different difficulty levels.
for each of the studies we recruited participants different for each study .
the participants are graduate students enrolled inthecomputerscienceprogrameitheratgeorgiatechoratthe federalunivesityofpernambuco.wealsorequiredtheparticipantstable debugging tasks for the user study.
user study task id benchmark fault description 1task math complex number multiplication error task math least common divisor computation error 2task nanoxml xml qualified name parsing error task jsoup absolute address construction error to have at least three years of programming experience and be familiar with the java language and the eclipse ide.
for each study we randomly assigned the participants to one oftwogroups groupaorgroupb.participantsingroupaperformed task study or task study without enlighten andtask2 study1 ortask4 study2 withenlighten.participants in group b performed task study or task study withoutenlightenandtask1 study1 ortask3 study2 with enlighten.theparticipantsnotusingenlightenwereallowed to use their preferred traditional debugging approach es e.g.
the eclipse ide debugger print statements step by step execution .
we used traditional debugging approaches instead of sfl as ourbaselinefortworeasons.first existingstudiesshowthatsfl tends to produce no measurable advantages over traditional debugging so we do not expect user performance to improve using sfl instead of traditional debugging.
second we believe that traditional debugging is a more objective baseline as it relies on mature well accepted tools known to our participants.
we implemented enlighten as a plugin for the eclipse ide and distributed the materials for the user study as a virtual machine image so as to ensure a uniform experience across all participants.
weinformedthe participantsthatwewould measuretheirperformance while debugging using two debugging approaches without mentioningthatenlightenwasourtechnique.beforethestudy began the participants read a tutorial on the enlighten plugin.
when done with the tutorial they performed their assigned debugging task.
the time limit for each debugging task in study and study was and minutes respectively.
in pilot studies we found that the participants gave up on their tasksduetothecomplexityofthecodeinvolvedandtheirlackof understanding of some of that code.
therefore when performing the actual study we allowed participants in all groups to ask questions about the semantics of a piece of code during the debugging process.
this is akin to the common scenario in which the person who is performing the debugging task asks questions about the code to a developer with deeper knowledge of the softwareinvolved.
we made sure to answer only general questions about whatthemethodsweresupposedtodo andwedidnotanswerany questions about the faults being diagnosed.
.
.
results.
tables6and7showtheresultsofthetwostudies.
in both tables the first two columns show the id and the corre sponding group for each participant.
columns labeled success indicatewhethertheparticipantcorrectlyidentifiedthefaultinthe debuggingtasks y ornot n .columnslabeled time min report the time spent in localizing the fault in case of success .
for both groups the results for the task performed using traditional debuggingareshowninthe3rdand4thcolumns andtheresults for the task performed using enlighten are shown in the 5thand authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table results for user study .
participant grouptask traditional task enlighten success time min success time min a y .
y .
a y .
y .
a y .
y .
a y .
y .
a y .
y .
a y .
y .
task traditional task enlighten success time min success time min b y .
y .
b y .
y .
b y .
y .
b y .
y .
b y .
y .
b y .
y .
average .
.
6thcolumns.
the last row in each table shows the average success rate and debugging time for each task and technique.
in study1 all participantssuccessfully completed bothof their debugging tasks.
on average participants took .
minutes to complete the tasks using traditional debugging and .
minutesto complete the tasks using enlighten.
therefore for the tasksconsidered enlighten reduced the debugging time by onaverage.
this difference is statistically significant with a p value less than .
using a one tailed t test.
instudy2 participantssuccessfullycompleted58.
ofthedebugging tasks using traditional debugging and the average debugging time for these successful cases was .
minutes.
conversely the participants successfully completed all their tasks when usingenlighten andtheaveragetimespentoneachtaskwas9.
minutes.
in these cases therefore the use of enlighten increased the success rate by .
and reduced the debugging time by .
also in this case the differences for both metrics are statistically significant.
the p value of the one tailed t test of the success rates is .
and that of the debugging time is less than .
.
onaverage forthetaskscompletedusingenlighten participants needed67 more queriesthan the perfect oracle tolocalize thefaults whichindicatesthathumansdomakemistakesinansweringqueries.however itisworthnotingthat71 oftheparticipants needed exactly the same number of queries as the perfect oracle.
comparing the reduction in debugging time in the two studies the resultsseem to indicatethat enlighten improves developers efficiency in debugging tasks more significantly for faults that are more difficult to diagnose which we consider a positive result.
attheendoftheuserstudy weaskedtheparticipantstocomplete a questionnaire about whether how enlighten helped them as well as what other information could have been provided by the tool to make it easier to localize and understand the fault.
the two advantages of enlighten most frequently mentioned werethat it points developers to the likely faulty invocation in the execution and itprovidesdetailedprogramstateinformation forinspection.thesetwoaspectsroughlycorrespondtowhatwe considertobethemain improvementswemadeinenlightenover traditional debugging and traditional sfl techniques.
the most wanted feature that enlighten does not currently provide according to the questionnaires is the ability to get the context of thetable results for user study .
participant grouptask traditional task enlighten success time min success time min a n y .
a y .
y .
a n y .
a y .
y .
a y .
y .
a y .
y .
task traditional task enlighten success time min success time min b n y .
b n y .
b y .
y .
b y .
y .
b y .
y .
b n y .
average .
.
.
method invocation in the debugging query including the call stack andthepositionofthecurrentinvocationintheentireexecution.
severalparticipantsthoughtthatthisinformationwouldgivethem a better understanding of the entire debugging process and help them give feedback to debugging queries more efficiently.
it would bestraightforwardtoprovidethisadditionalinformation andwe are planning to do it in future work.
we also interviewed the participants about their general feeling on the debugging experience using enlighten.
multiple participants mentioned that learning to use the enlighten plugin in the time we allocated for the training was challenging.
one partici pant specifically pointed out that it was difficult to change their debuggingmindsetfromatraditionalcode centricparadigmtoa more data centric one.
finally several participants reported thatthey spent a long time inspecting the code of the method in the queryonlytolaterdiscoverthatitwasnotnecessary.wespeculate that these feedback may indicate that people s performance using enlightencouldfurtherimproveafter theygetmorefamiliarwith the technique.
.
limitations and threats to validity the main limitation of our current implementation of enlighten comes from the computation of the dynamic dependence information.duetotheenormousengineeringeffortrequiredtodevelop atoolthatimplementsourapproach thecurrentdynamicdependencyanalyzerdoesnotsupportsomefeaturesofthejavastandard library e.g.
certainencryptionalgorithmsandswing .thisisan implementation specificlimitationandcanbeaddressedwithadditionalengineering.anotherlimitation sharedwithmanyother debugging techniques that rely on dynamic slicing is that the performanceoverheadof enlightenduringprogramexecutioncanbe significant.intheuserstudy however noparticipantcomplained about the running time of enlighten.
themajorinternalthreattovalidityforourevaluationhastodo with possible faults in our implementation of enlighten that may invalidate our results.
to address this threat we carefully checked and unit tested our code during development.
furthermore for the realfaultsinthebenchmark wemanuallyinspectedtheinteractions between the automated oracle and enlighten to confirm that the sequences of debugging queries and feedback were correct.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
themainexternalthreattovalidityisthatthebenchmarkswe usedmightnotberepresentativeoffaultsinreal worldscenarios and orourresultsmaynotgeneralize.tomitigatethisthreat we selected benchmarks that perform different types of tasks manipulating complex data structures performing numeric computations and processing xml files.
in addition in the study with simulated users we evaluated enlighten with both real faults and a large set ofmutationfaults andinthestudywithrealdevelopersweused four different real world faults.
another possible external threat is that the population of participants we recruited for the user study might not be representative of real developers.
to mitigate this threat werequiredtheparticipantstohaveatleastthreeyearsof programming experience.
related work countlesspapershavebeenpublishedondebuggingandfaultlocalization.forthesakeofspace thissectionfocusesonthework that is most closely related to enlighten.
algorithmicdebugging ad isaninteractivedebuggingtechniquethatwasproposedinthefunctionalprogrammingcommunity by shapiro in the early eighties .
similar to our technique ad asksdevelopersquestionsonthecorrectnessofspecificfunction invocationsintheexecutiontreeforagivenfailingtest.thetree isthensystematicallyprunedbasedontheanswerstothesequestions until the fault can be isolated.
enlighten differs from ad intwoimportantways.first adusesbasicheuristicstoidentify whichfunctioninvocationstotarget whereasenlightenleverages sfl and dynamic dependences.
second ad requires developers todeterminewhetherafunctioninvocationiscompletelycorrect whichisdifficultto large portions of the program state.
this problem is common tomost techniques based on ad including our own previous work and tends to make these approaches error prone and impractical.
conversely enlighten asks developers for feedback onindividualinputandoutputvalues whichwe believe andour initial results show is a more realistic approach.
ko and myers proposed whyline an interactive debugger that lets a developer trace incorrect variable values backwards byaskingquestionsabouthowthesevaluescametobe.whyline issimilarinspirittodynamicbackwardslicing theuserfollows a sequence of incorrect variable values through program dependence chainsto get tothe fault.
morerecently lin andcolleagues proposed microbat a feedback driven debugging technique thatimprovesonwhylinebyinferringpatternsinexecutiontraces andusingdeveloperfeedbacktoskippartialprogramexecutions expediting the backward tracing process.
enlighten whyline and microbat all leverage lightweight user feedback to improve faultlocalization.however incontrasttotheseothertechniques the queries enlighten produces are contextualized by methodinvocations as opposed to focused on arbitrary execution points.
this feature not only lets the developer obtain relevant contextual information when answering specific queries but also enables the techniquetojumpacrosscallingcontextsguidedbythesuspiciousness of program statements.
the debugging technique proposed by hao and colleagues sets breakpoints in the faulty program using suspiciousness of programstatementsgivenbysfl.ateachbreakpoint thetechniqueasksthedevelopertoinspecttheprogramusingadebuggertodetermine whether the program statehas been infected by the fault.
the suspiciousness of related statements is then increased or decreasedbyafixedratiobasedontheprovidedfeedback.incontrast to theirapproach enlightenselectsfor inspectiona small setof suspiciousdataitemswithinselectedmethodinvocations itdoes notrequirethedeveloperstofindfaultymemorylocationsinthe entire program state.
in addition enlighten incorporates developers feedbackintothesflalgorithm soastodynamicallyupdate suspiciousnessinformation.infollow upwork haoandcolleaguesproposedvida whichleveragesprogramdependencestofind statementswhosesuspiciousnessmustbeupdated.comparedto vida enlighten asks for feedback onthe input output relations of methods whose intended behavior tends to be well understood rather than on individual program statements.
gong and colleagues proposed an interactive fault localizationtechniquethatcontinuouslyupdatestherankedlistofsuspiciousstatementsastheusermarksstatementsasfaultyandnonfaulty.
the intuition behind the technique is that once a statement is labeled as non faulty the other statements executed in the same failing test case should be considered more suspicious.
like tra ditional sfl approaches and unlike enlighten their technique requires developers to determine the correctness of individual program statementswithout contextual information which has been shown to be problematic .
conclusions we presented enlighten aninteractive feedback driven faultlocalization technique.
enlighten combines sfl algorithmic de bugging and dynamic dependence analysis by leveraging their strengthswhilemitigatingtheirweaknesses.inparticular unlike traditionalsfl enlightenaskdeveloperscontextualizedquestionsthatconsistofqueriesabouttheinputsandoutputsassociatedwith concreteinstancesofsuspiciousmethodinvocations.also unlike algorithmic debugging enlighten lets developers reason in terms of individual input output data items which is important in order to be able to handle large program states.
our empirical results show that enlighten is effective when applied to bothreal world and mutation faults in thebenchmarks weconsidered.specifically ourstudywithsimulatedusersshows that enlighten can localize a majority of the faults with less than 10debuggingqueries andouruserstudyshowsthatenlighten canprovidesignificantimprov ementsovertraditionaldebuggingin termsofbothnumberoffaultslocalizedandtimeneededtolocalize the faults.
infuturework wewillconductadditionaluserstudiestofurther investigateourcoreassumptionthatmethodsareasuitablelevelof abstraction for developers to understand program behavior during debugging.
we will also perform a direct comparison between our approach and traditional sfl techniques in real world scenarios.
finally wewillextendourimplementationtoincorporateitinto additional ides and to remove some of its practical limitations.