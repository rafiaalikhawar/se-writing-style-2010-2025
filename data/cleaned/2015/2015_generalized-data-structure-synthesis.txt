generalized data structure synthesis calvin loncaric loncaric cs.washington.edu paul g. allen school of computer science engineering university of washington seattle wa usamichael d. ernst mernst cs.washington.edu paul g. allen school of computer science engineering university of washington seattle wa usaemina torlak emina cs.washington.edu paul g. allen school of computer science engineering university of washington seattle wa usa abstract data structure synthesis is the task of generating data structure implementations from high level specifications.
recent work in this area has shown potential to save programmer time and reduce the risk of defects.
existing techniques focus on data structures for manipulatingsubsetsofasinglecollection butreal worldprograms often track multiple related collections and aggregate properties such as sums counts minimums and maximums.
thispapershowshowtosynthesizedatastructuresthattrack subsetsandaggregationsofmultiplerelatedcollections.ourtechniquedecomposesthesynthesistaskintoalternatingstepsof query synthesis andincrementalization.thequerysynthesisstepimplementspureoperationsoverthedatastructurestatebyleveraging existing enumerative synthesis techniques specialized to the data structures domain.
the incrementalization step implements imperativestatemodificationsbyre framingthemasfreshqueriesthat determine what to change coupled with a small amount of codeto apply the change.
as an added benefit of this approach over previous work the synthesized data structure is optimized for not onlythequeriesinthespecificationbutalsotherequiredupdateop erations.wehaveevaluatedourapproachinfourlargecasestudies demonstrating that these extensions are broadly applicable.
ccs concepts theoryofcomputation datastructuresdesignandanalysis software and its engineering source code generation keywords program synthesis automatic programming data structures acm reference format calvinloncaric michaeld.ernst andeminatorlak.
.generalizeddata structuresynthesis.in icse 40thinternationalconferenceonsoftware engineering may june gothenburg sweden.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to the association for computing machinery.
acm isbn ... .
introduction many programming tasks can be framed as data structure problems especially in domains like user interfaces or web services wheresoftwaremustmanagesomeinternalstateandalsohandle asynchronousevents.manuallyimplementingcomplexapplicationspecific data structures can be time consuming and error prone.recent research seeks to automatically synthesize data structure implementations from high level specifications thus ensuring correctness and run time efficiency with minimum programmer effort .
existing techniques can synthesize only a narrow range of data structures those that retrieve a subset of a single collection.suchasimpleapilimitstheirapplicability asreal world software often has more complex requirements.
for example the chat server openfire uses a custom inmemory data structure to represent a many to many relationship between users and groups.
this data structure needs to answermany different kinds of queries efficiently such as which users belong to a given group or whether any two users share a group.
it alsoneedsto keepitselfup to dateasusers andgroupsareadded removed andrenamed.despiteitscompleximplementation openfire s user management code has a simple specification.
in general data structure specifications are much smaller than their imple mentations because they do not need to manage memory or be algorithmically efficient.
thispaperpresentsanewtechniquefordatastructuresynthesis that overcomes many of the limitations of previous work.
our tool cozy can synthesize implementations for complex multi collection datastructures includingthosefoundinopenfire fromhigh levelspecifications.likepreviouswork acozyspecificationdeclaresthe abstractstate whatinformation thedatastructure stores queries methodsthatperformpurecomputationsonthestate and updates methodsthatmodifythestate thatthedatastructuremustsupport.
cozythenproducessourcecodethatdeveloperscanuserightaway.
in previous work implementations for update methods were hard coded orderivedusingasetofhand writtenrules .
in cozy update methods are synthesized rather than hardcoded.
thisenablescozytodiscovermorespecializeddatarepresentations thanpreviouswork sincecozycanchoosedifferentrepresentations depending on what kinds of updates appear in the specification.
our technique iteratively improves the data structure specificationusingtwocooperatingcomponents a querysynthesizer that selects a better representation and implementation for each query method and an incrementalization step that ensures the new representation is kept up to date when an update method is called.crucially theincrementalizationstepcanproducespecifications for new query operations to help implement the update procedure.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden calvin loncaric michael d. ernst and emina torlak q1 ... impl new q2 ... impl u1 ... update s update s update s implementation q1 ... impl newspec find an improvement implementation s1 t1 s2 t2 q1 ... impl c ... c ... implementation implementation stop on timeoutconstruct initial implementation incomplete implementation s1 t1 s2 t2 s3 t3 c ... c ... c ... implementation query synthesis u1 ... update s update s u1 ... update s update s incrementalizationdead code eliminations1 t1 s2 t2 s3 t3 c ... c ... c ... u1 ... update s update s s1 t1 s3 t3 c ... c ... q1 ... impl new q2 ... impl new code uses s s3uses s s2update code calls q figure architecture of cozy.
each iteration through the loop performs query synthesis incrementalization and dead code elimination.
figure 2a shows example input and figures 2b and show the corresponding output.
cozythususesthequerysynthesizertoimplementbothpurequeryoperationsandimperativeupdates.ourtechniqueisagnostictothe exactimplementationsofthequerysynthesizerandincrementalization step section 3gives adetailed explanation ofthe concrete choices we made for cozy.
thequerysynthesizerandincrementalizationstepinteractusing concretization functions.
a concretization function expresses a data structure srepresentation itsconcretestate asafunctionofitsab stractstate.
forexample the following concretizationfunction represents the count of elements in an abstract set s c s summationtext.
x s1.
concretization functions allow cozy to reason about the effectsof updates in pure mathematical terms.
the imperative operations.remove e whichremovesaninstanceof efromsifanyis present causesachangetothedatarepresentation.thenewvalue of the count thus becomes c s prime c s e summationtext.
x s e .
cozy s query synthesis step outputs both an efficient implementationforeachqueryandasetofconcretizationfunctionsindicating howthedatashouldberepresented.theincrementalizationstep thenusestheconcretizationfunctionstoproduceaspecification ofthechangetotheconcretestateasaresultofeachupdate.for thecase of s.remove e the changespecificationisthe amountby whichthecountchanges c s prime c s .thesechangespecifications are queries over the abstract state of the data structure and toimplementthemcozyrepeatsthequerysynthesisstep.thetool proceeds in this loop until exhausting its time budget three hours for our evaluation.
contributions ahigh leveldatastructuresynthesisalgorithmwithalternating steps of query synthesis and incrementalization .
query synthesis and incrementalization algorithms .
an implementation called cozy four real world case studies that evaluated cozy s effect on development time correctness and efficiency .
overview this section illustrates cozy s high level algorithm using a simplifiedexampleofareal worlddatastructurefromopenfire.thedata structurethatmanagesusers contactshasbeenafrequentsourceof bugs section .
.
cozy can synthesize a complete implementation for openfire s data structure given its specification.
cozy uses the algorithm shown in figure .
it takes as input an executable specification of the data structure section .
constructs an initial implementation section .
and then iteratively improves its implementation using alternating steps of query synthesis section .
and incrementalization section .
.
a dead codeeliminationstep section2.
prunesdeadcodeassynthesis progresses.
.
specification figure2ashowsacompletecozyspecificationforpartoftheopenfire contact management data structure.
it would be used as the inputtofigure1.inthespecification statedeclarationsdescribe the abstract state of the data structure querydeclarations specify methods that compute values using the abstract state and op declarations specify methods that alter the abstract state.
methods mayalsoincludeassumptions preconditions abouttheirinputs.in somecases cozycanproducebetterimplementationsbyleveraging theseassumptions buttheyareoptionalforspecificationwriters.
callers must ensure that the assumptions hold at each call site.
in openfire users contact lists are implicit and are computed basedonthegroupsthateachuserbelongsto.thedatastructure must be able to efficiently answer the question should user u1 appear in the contacts of user u2?
for any u1andu2.
the query method visiblein figure 2a defines this relationship u1is visible to i.e.
appears in the contacts of u2if there exists a group of which u1is a member and either has been made visible to everyone .visibility everyone o ru2is also a member of .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
generalized data structure synthesis icse may june gothenburg sweden abstract state state users set user state groups set group state members set user group query definition query visible u1 u2 u s e r assumeu1 users assumeu2 users return exists groups u1 members and .visibility everyone or u2 members update operation definition opjoin u user group assumeu users assume groups assume u nelementmembers members.add u a users who are some group whose visibility is everyone state s1 map user bool map from users to the groups of which each one is a member state s2 map user bag group map from user group tuples to boolean indicating whether that user is a member of that group state s3 map user group bool now unused state state v1 set user state v2 set group state v3 set user group new code query visible u1 u2 u s e r return s1 or exists filter .s3 s2 b cs1 users groups members makemap fusers where f u.exists filterp u members p u v .u vand .visibility everyone cs2 users groups members makemap users where u. filter q u members q u v .u vand .visibility nequaleveryone cs3 users groups members makemap m .true members cv1 users groups members users cv2 users groups members groups cv3 users groups members members c figure a an example input to figure that specifies the openfire user and group management data structure.
b new implementation of visibleafter several query synthesis steps.
cozy does not produce the comments which we added for clarity.
since incrementalization and dead code elimination have not yet run the implementation does not properly updatethe new state variables s s2 ands3and still contains some unused state variables.
c concretization functions for the new implementation.
this example has been simplified our experiments section use a fullspecification ofthe datastructure thatalso includesexplicit contacts and additional visibility modes for groups.
as specified visibleruns ino groups members time.
cozy createsamoreefficientimplementationfor visible figure2b that runs ino time where is the maximum number of groups that any one user is a member of.
.
initial implementation whenevercozychoosesadatarepresentation italsocreates for each field in the representation a concretization function that computes the field s representation from the abstract state.
since cozy specificationsareexecutable theycanbeconvertedtoimplementa tions whose concrete state is the same as the abstract state.
for the specification in figure 2a cozy s initial implementation has the variables v1 v2 andv3and trivial concretization functions cv1 users groups members users cv2 users groups members groups cv3 users groups members members eachqueryandupdateoperationcanberewrittenintermsof v1 v2 andv3by simple substitution.
the visiblemethod becomes query visible u1 u2 u s e r assumeu1 v1 assumeu2 v1 return exists v2 u1 v3and .visibility everyone or u2 v3 whilerenamingtheabstractmembersto v1 v2 v3doesnotfunctionally change the specification it creates initial concretization functions for later steps to consume.
.
query synthesis cozysynthesizesanimplementationbyiterativelyfindingimprovementstothedatastructure.thequerysynthesisstepinfigure1 makesanimprovementtosomenon deterministicallychosenquery operation on the data structure.
section .
discusses how cozy makes the choice and the improvement.
figure2showsoutputfromoneofthequerysynthesissteps i.e.
animprovementtothequery visiblethatusesanewrepresentation and has associated concretization functions.
thequerysynthesisstepmayintroducenewstatevariables but it does not drop unused ones.
in figure the red state variables s1 s2 ands3arenew v1 v2 andv3arenowunused.thedeadcode elimination pass will eliminate the unused variables later.
thenewvariables concretizationfunctionsaremorecomplex than the trivial ones introduced for the initial implementation.
the statevariable s1 forinstance hastheconcretizationfunction cs1 whichusesthemakemapprimitivetoconstructanewmapfrom users to booleans.
the makemap primitive takes a collection of keys users and a value function f and builds a map where each keyu usersisassociatedwithvalue f u .fors1 thevalueistrue if the user is a member of a group with visibility set to everyone .
incozy mapsaretotal.lookupsonmissingkeysreturnadefault value false for booleans the empty set for sets and so on.
thus authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden calvin loncaric michael d. ernst and emina torlak opjoin u user group join s1 u join s2 u join s3 u join v1 u join v2 u join v3 u private op join s1 u user group fork altered keys s1 u s1 new value for key s1 k u the join s2 and join s3 implementations have been omitted for brevity.
private op join v1 u user group no op private op join v2 u user group no op private op join v3 u user group v3.add u a find keys of map s1 whose values change when user u joins group g. private query altered keys s1 u user group assumeu users assume groups assume u nelementmembers return k k mapkeys s1 mapkeys s1 prime s1 nequals1 prime compute a new value at key k s1 when user u joins group g. private query new value for key s1 k u user group assumeu users assume groups assume u nelementmembers assume s1 nequals1 prime return s1 prime sub queries for s2 and s3 have been omitted for brevity.
b figure a implementation of the joinupdate operation and b new sub queries that need to be synthesized.
the variable s1 primeis defined as the new value of s1after joinis called cs1 users prime groups prime members prime .
the expression s1 efficiently determines whether user u1is a member of a group with visibility set to everyone .
the concretization functions shown in figure 2c will become theimplementationoftheconstructorforthedatastructure.the constructor takes the abstract state as input and initializes the concrete state.
furthermore the concretization functions enable incrementalization.
.
incrementalization the query synthesis step creates an incorrect data structure the newstatevariables s1 s2 ands3arenotkeptup to datewhen join iscalled.theincrementalizationsteprestorescorrectfunctioning by adding code to jointhat updates the new state variables.
the new code must preserve the concretization functions in figure 2c.
asimplebutinefficientsolutionwouldbetorecomputethevalue of each concrete state variable from scratch.
because an update usually makes asmall changeto theabstract state cozy produces anincremental update that makes small changes to the concrete state in response to a small change to the abstract state.
to incrementally update the concrete state cozy rephrases the update procedure as a set of queries that compute what changesshould take place plus a simple hardcoded snippet that applies thosecomputedchanges.apreviousapproachappliedthissame idea to synthesize remove operations but with concretization functionsitcanbegeneralizedtoinsertionsandotherupdatesas well.ourapproachalsoallowsformorecomplexupdateprocedures likethosethatapplymultiplechangesatonceoronlymakeachange under certain conditions.
figure 3a shows the code that cozy produces to update the concretestateasaresultofauserjoiningagroup.eachconcrete state variable gets its own update procedure e.g.join s1fors1 .
the code for join s1is not synthesized it comes from a lookup table section .
.
however the new code uses two fresh query operations altered keys s1and new value for key s1 figure 3b that determine what changes to apply.
the former computes theset ofmap keys whose valueschange and thelatter computes the new value for each key.
these two queries are added to the data structurespecification andthustheywillbeoptimizedbythequery synthesizer on subsequent iterations.
the definitions of the fresh queries make use of both the old value of s1and the new value s1 prime.
the new value is computed using the specification of joinand the concretization functions.
mathematically joinsets the abstract state to users prime users groups prime groups members prime members u and thus the new value s1 primemust be s1 prime cs1 users prime groups prime members prime makemap fusers where f u.exists filterp u members u p u v .u vand .visibility everyone figure3bshowsthespecificationsfor altered keys s1andnew value for key s1 whichareinefficient.onlateriterations cozy s query synthesizer discovers efficient implementations for both.specifically cozy implements altered keys s1to return the singletonset u if hasvisibility everyone anduisnotalreadyinsuch ag r o u p o r otherwise.
cozy implements new value for key s1 to simply return true.
the implementations of altered keys s1and new value for key s1donotrequireadditionalconcretestate.ingeneral however newconcretestatemightbegeneratedforthefreshqueriesinlater iterations requiring another phase of incrementalization.
.
dead code elimination at each iteration cozy cleans up unused state variables and operations.
for instance the state variable v2can be eliminatedsince it is never read.all code thatkeeps v2up to date canbe eliminated as well.
cozy also deduplicates state variables and fresh queries.
duplicates happen in cases where the same concrete state is useful to multiple different query operations.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
generalized data structure synthesis icse may june gothenburg sweden spec colonequalname specifications s1 s2 ... invariant e m1 m2 ... s colonequalx abstract state colonequalint bool string basic types enum case1 case2 ... enumerations angbracketleft 1 2 ... angbracketright tuples f1 1 f1 2 ... records bag angbracketleft angbracketright bags multisets m colonequalqueryq args... queries assumee returne opu args... updates assumee stmt stmt colonequalx e assignment x.add e insertion x.rm e deletion ife stmt conditional stmt stmt sequencing e colonequalx variables e e e e ... comparisons e e e e e bool operations e?e e conditionals e e e e arithmetic e e ... e.n tuples f e f e ... e.f records e e e e ebag operations mapfe filterfe map and filter flatmapfe map union e sum distincte remove duplicates argminfe argmaxfemin and max f colonequal x.e lambda abstraction figure core specification language spec.
details cozyiterativelyimprovesaspecification section3.
toproduce an implementation.
at each iteration cozy attempts to find an improvementtosomequery section3.
.
theimprovementmay require new concrete state which must be properly maintained in each update method section .
.
finally unused state and code are removed section .
.
.
specification and output languages figure shows the core specification language.
all input specifications are desugared to this core language figure .
cozy s output languageisasupersetofitsinputlanguagethatincludesadditional constructs for maps map angbracketleft angbracketright e makemapfe mapkeys e e len x map x.1x empty x len x areunique x x distinctx x x p x empty filter px x x p x empty filterpx x x y x y x mapffilterpx flatmap x.map y .f x y yx figure expressions that cozy accepts in input specifica tions but desugars into simpler forms.
cozy supports ar bitrary list comprehensions though only two examples ofdesugaring list comprehensions are shown.
maps could be included in the input language but they are not needed a comprehension can group and look up values in a declarativeratherthanproceduralmanner.thisclarifieswhateachexpression computesand reducesthe numberof invariants thatprogrammers need to maintain.
in the output language the makemap primitivetakesanexpression erepresentingthekeysofthemap and a projection fthat gives the value at each key.
mapkeys returnsthekeysofamap.themapindexoperator e returnsthe value of a given key in the given map.
if the key is not in the map this operator returns a default value e.g.false for booleans and the empty set for bags.
we plan to extend cozy with additional primitives for heaps trees and other efficient data structures in the future.
for the case studiesweexamined maps alonearesufficienttodiscoverefficient implementations.
.
synthesis cozyattemptstosynthesizeabetterimplementationforeachquery method in the specification in parallel with one thread per query.
astaticcostmodel figure6 defines better.
wheneverathread discoversabetterimplementation thatimplementationisimmediately passed through the incrementalization step and newqueries it produces get new threads.
the whole specificationundergoes dead code elimination and any old queries that were eliminated have their threads terminated.
each threadsynthesizes improvementsfor its query using enumerativesynthesis anoptimizedformofbrute forcesearch.the core algorithm described here was pioneered by previous work butcozyemploysseveralnovelimprovements.wedescribe the core algorithm first followed by our extensions.
enumerative synthesis explores every possible expression in cozy s output grammar in order of size from smallest to largest.for each expression a verifier e.g.
z3 checks whether the expression satisfies the specification that is they always produce the same result.
if so the expression is emitted.
then the search continues to look for an even better solution.
since cozy employs boundedverification describedbelow theverifieralwaysproduces a result and never times out or returns unknown.
to make the search feasible cozy employs equivalence class deduplication an optimization that skips most expressions in the search space.
the skipping is done safely so that cozy never authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden calvin loncaric michael d. ernst and emina torlak state expressions costs e number of ast nodes in e query expressionscost q e eis a state expression costq x costq e1ope2 costq e1 costq e2 costq filterpe costq e card e costq p x xis a fresh variable costq e costq e card e ... facts about cardinalities e card e x card x if xis an abstract state variable card card e card e1 e2 card e1 card e2 unsat e1 e2 card e1 card e2 partial order on costs sat c1 c2 sat c2 c1 c1 c2 subject to the provable facts about all cardinalities in formulas c1andc2 figure6 staticcostmodel.incozy costsarerepresentedas symbolic formulas over the cardinalities of various collections.
cozy uses a solver sat andunsatfunctions to order costs.
misses a solution if one exists.
equivalence class deduplication requiresalistofexampleinputs.incozy anexampleinputconsists of values for both the abstract state of the data structure and the query arguments.
the example inputs are produced by the verifier everytimeanexpressionfailsverification theverifieryields a new example input.
cozy caches built expressions.
whenever two expressions produce the same output on every example cozy consultsastaticcostmodel describedbelow todecidewhichto keep.inthisway anexpression ssetofoutputsontheexamples puts it in an equivalence class and only one representative of each equivalenceclassiscachedatanygiventime.largerexpressions are only built out of those that survive this deduplication.
furthermore cozy only tries to verify expressions that produce correct outputoneveryexample reducingthenumberofcallstotheverifier.
since the skipping is so aggressive the search must restart everytimeanewexampleisdiscoveredtoensurethatnosolutions are missed.
cozyincludesthreenoveladditionstothecoreenumerativesynthesis algorithm query time distinction asymbolic cost model and diversityinjection.additionally sinceverificationisundecidablefor our specification language cozy uses bounded verification instead of full functional verification.
this technique was also employed by previous work .
query time distinction.
cozy s query synthesis algorithm must solvetwointertwinedproblems choosingagoodrepresentationforthedataandchoosingagoodalgorithmthatexploitsthatrepresen tation.oursolutionistotageachnodeinasynthesizedexpression as either a state expression or aquery expression.
the data structure stores each state expression as a member and incrementally maintains it ateach update operation.a queryexpression is evaluated each time the query is called.
for instance an expression to compute the length of a list could be implemented in several different ways depending on which parts are tagged as state expressions map x.1s bracehtipupleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipdownright bracehtipdownleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipupright stateor map x.1s bracehtipupleft bracehtipdownright bracehtipdownleft bracehtipupright state.
the first case indicates that the data structure stores the length ofsasamemberandreturnsthestoredvaluewhenthequeryis called.
the second case indicates that the data structure stores s as a member and computes the length on demand.
since these two expressionsareequivalent onlythelower costone inthiscase the first is kept during deduplication.
cozy s cost model does not account for the cost of maintaining the state instead that job is delegated to the sub queries generated during incrementalization.
expressions that contain query arguments may not be tagged as state expressions since those values will not be available until the query is executed.
symbolic cost model.
figure shows cozy s novel static cost model.thecostmodelcomparesstateexpressionsbasedontheir complexityintermsofthenumberofastnodes costs .itcompares query time expressions based on their expected run time cost q .
cozy represents costs as symbolic formulas involving the cardinalitiesofvariouscollections.forexample thecostofperformingafilterincludesthecostofevaluatingthepredicateoneveryelement of the collection being filtered.
to determine the ordering between two costs c1andc2 cozy first makes solver calls to establish as many facts as possible about all the cardinalities i.e.
calls to card in each expression.
each call tocardcan then be replaced by a fresh real type variable.
using these assumptions cozy then makes more solver calls.
if there are caseswhere c1islessthan c2 sat c1 c2 andnocaseswhere c1 is more than c2 sat c2 c1 then the expression having cost c1 should always be preferred over the expression having cost c2.
diversityinjection.
inpractice theenumerativesynthesisalgorithmmaytakealongtimetodiscovergoodsolutions especiallyforlanguageslikeourswhereexpressionsizeisnotstronglycorrelated withcost thatis largerexpressionsmayhavelowercost .when thesyntaxtreeforthebestsolutionisofsizefifteenortwenty standardenumerativesynthesismaytakemanycenturiestodiscover it!
for comparison the syntax tree for the efficient implementation ofvisiblein figure requires nodes.
to bias the search toward useful expressions cozy employs a small number of handwritten diversity rules that inject new expressionsintothesearchprocedure.whenevercozyconsidersanew candidateexpression italsoappliestheserulesandconsidersthe resulting expressions.
the diversity rules do not need to be universallycorrectorefficient incorrectexpressionswillberejected bytheverifier andinefficientexpressionswillberejectedbythe cost model.
however incorrect expressions are still cached to help authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
generalized data structure synthesis icse may june gothenburg sweden map introduction filter x .f x yx makemap k .filter x .f x kx map x .f x x cleaners filter x .p1 x p2 x x filter x .p1 x filter x .p2 x x filter x .a x ?b x c x x filter x .a x b x x filter x .
a x c x x relevant subset x v vis a state variable filter x .x vx instantiation e1 e2 vis free ine1 e1 figure cozy s diversity rules.
buildlargerexpressions astheymightappearassubexpressionsof correct solutions later on.
cozy uses the five diversity rules shown in figure .
these diversityrulesarespecializedtocozy sdomainandareintendedto capturesomeintuitionshumanprogrammersmightapply.
map introduction convertssomelinear timefilteroperationsintoefficientmaplookups.
cleaners putexpressionsintonormalform whichhelpscozyidentifypotentialmaplookupsonlateriterations.
the relevantsubset ruleconvertsacollectionintothesubsetthat isalreadystoredonthedatastructure.finally the instantiation rule helps transfer insights about a variable to insights about other expressions.forexample ifcozyhasdiscoveredtheexpressions x sandy theny smight also be important.
inpractice cozy senumerativesearchmachinerydoesnotfunction well without the diversity rules and vice versa.
if the diversity rulesaredisabled cozydoesnotfindagoodsolutiontoanyspecificationforanyofoursubjectprogramswithinathreehourtimeout.similarlyifthediversityrulesareappliedwithouttherestofcozy s enumerative search machinery the search quickly runs out of new expressions and stalls without ever finding a good solution.
bounded verification.
it is undecidable to determine whether an expression in cozy s language satisfies a specification.
thus cozy employs bounded verification collection type variables are limited to a fixed number of elements.
in our experiments we found a limitoffourtobesufficienttoensurecorrectsolutions.thismay bethankstothe small scopehypothesis whichproposesthat most program bugs can be exhibited with small inputs.
there issome evidence that the small scope hypothesis is true for simple programs and we found it to be true in our domain as well.
.
incrementalization after query synthesis picks a new representation for the data the incrementalizationsteprestoresproperfunctioningbyaddingcodetokeepthatrepresentationup to dateasthedatastructurechanges.
cozy sincrementalize procedureaccomplishesthatgoalbyleveraging the existing query synthesis procedure.
injoinfrom section .
cozy updated s1using the code fork altered keys s1 u s1 new value for key s1 k u figure8showstherulesforcozy s incrementalize procedure.since s1has a map type cozy uses the update sketch shown in the figure formaps.anupdatesketchisasmallsnippetofimperativecode thatupdatesthevariable.anupdatesketchmayrequirenewqueryincrementalize x cx input old abstract state and new abstract state prime output code to update concrete state x type update sketch new queries int x x q ... q ... cx prime cx bagforelem q1 ... x.del elem forelem q2 ... x.add elem q1 ... cx cx prime q2 ... cx prime cx mapfork q ... incrementalize x .cx q ... k k mapkeys c x mapkeys c x prime cx nequalcx prime other x q ... q ... cx prime figure rules for incrementalize x cx .cxis the concretization function for x. to update a map type variable incrementalize is called recursively to determine how to update the value at each changed key.
operations in order to function.
in the case of maps the update sketchfindsthekeyswhosevalueshavechangedandupdateseach one in the map.
cozy introduces the new query altered keys s1 to compute which keys have changed.
sincethevaluesin s1arebooleans cozyusesthefallbacksketch for other types to update each value.
this rule uses a new query new value for key s1tocompute from scratch anew valuefor s1 .asdiscussedinsection2.
thenewvaluefor s1 issimply true.
in practice new queries generated by incrementalize often have short and efficient implementations.
.
dead code elimination whenabetterqueryimplementationisfound somestatevariables maygounused.theimperativeoperationsthatkeepthesevariables up to date are unnecessary as are any queries required only by thoseimperative operations andsoforth.
thedeadcodeelimination procedure is important it frequently eliminates variables in this manner as better query solutions are found.
tocleanupunusedstateandoperations cozyusesmark andsweep.
user specified query operations start as roots.
any state thattheyuseismarkedasrelevant andcodetoupdatethatstate isalsomarked.queriesusedbytheupdatecodearethenmarked and so on until fixed point.
finally any unmarked state queries or update code can be safely removed.
.
termination the query synthesis procedure section .
has no formal termination guarantees and as a result neither does cozy itself.
but since the input specification is executable cozy always has a correct solution and the synthesis process can be stopped at any time.
our experiments used a fixed timeout of three hours for synthesis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden calvin loncaric michael d. ernst and emina torlak evaluation cozyhasthreegoals toreduceprogrammereffort toproducebugfree code and to match the performance of handwritten code.
we foundthatusingcozyrequiresanorderofmagnitudefewerlinesof codethanmanualimplementation section4.
makesnomistakesevenwhenhumanprogrammersdo section4.
andoftenmatches the performance of handwritten code section .
.
.
methodology for each of four real world programs section .
we identifiedanimportant complex handwrittendatastructure manually wrote a cozy specification allowed cozya three hourtimeout tosynthesize anewimplementation and replaced the original data structure by the synthesized one.
replacing handwritten code with cozy synthesized code required somelightrefactoringineachprogram.forexample someprogram mersintertwinedatastructurecodewithi ocode.wedisentangled these because cozy does not synthesize i o code.
this refactoring wasonlynecessarybecausetheseprojectsdidnotusecozyfrom day one.
furthermore we believe it results in better code style and easier to understand abstractions.
weranourexperimentsonamachinewith96coresand512gbof memory.cozyspawnsonethreadforeachqueryinthespecification andrunsfastestonamachinewithatleastthatmanycores butdoes not require it.
the openfire specification our largest has query operations thusrequiring12coresforfastestoperation.memory usage steadily climbs the longer cozy runs we have observed it reach gb in the worst case.
the three hour synthesis time does not slow down the editcompile testcycle.sincecozyspecificationsareexecutable they canbeimmediatelytranslatedintousablebutinefficientcode.developerscancodeandtestagainsttheslowversiontogainconfidence in their specification before running the full synthesizer.
we made use of this feature while writing specifications in our evaluation.
.
subject programs ztopo is a topological map viewer implemented in c .
its cacheofmaptilesasynchronouslyloadsmaptilesoverthenetworkandcachesthemondiskorinmemory.thecacheenablesanyother part of the program to query for information about a given map tile.
ztopo was also a target for previous data structure synthesis work .cozyisalsoabletosynthesizetwopartsofthecache thatpreviousworkcouldnot.first cozycansynthesizethecode thataccountsforthetotaldiskandmemoryusageofcachedmap tiles.
second cozy synthesizes a key operation to look up a single elementbyitsuniqueidentifier.previoustoolsimplementedthis operation inefficiently by checking whether a computed collection of results contained a single element or not.
sat4j is aboolean satisfiabilitysolver implementedinjava.
itsvariablestoretracks amongotherthings whenaguesswaslastmade about a variable s value and whether any listeners are watching that variable s state.
sat4j was also a target for previous data structure synthesiswork .
as with ztopo cozy ssynthesized implementation of the sat4j data structure is a closer match to the original than previous tools requiring less wrapper code.table programmer effort.
loc measurements do not include comments or whitespace.
hand written cozy project span commits loc loc ztopo week sat4j years openfire years lucene years openfire is a large scalable irc server implemented in java.
its in memory contact manager is extremely complex.
users contacts can be either explicit added by users manually or implicit present due to users group memberships .
furthermore the contact manager must keep its state in sync with the underlying database as users and groups are created modified and deleted.
thislogichasbeenafrequentsourceofbugs .openfire simplicitcontactsrequirecomputinginformationabouttwodistinct collections users and groups and thus cannot be handled by any previous tool.
lucene is a search engine back end implemented in java.
lucene uses a custom data structure that consumes a stream of words and aggregates key statistics about them.
the data structure has an addmethod that is called once for each token instead of gettingthetokensasonebiglist.thelogicforhandlingeachtoken is tricky since the data structure needs to to be queryable between callstoits addmethod.cozyhelpsavoidthelogicinthe addmethod by having a clean specification that describes the abstract state as a bag of tokens and descriptions of the queries that matter.
.
programmer effort wedonotknowhowmuchtimeprogrammersspentimplementing and debugging the hand written data structures but it was significant.
table shows the size of each implementation in noncommentnon blanklinesofcode.italsoreportshowmanycommits contributed to the currentversion of the data structureimplementation andacrosshowmuchtimethosecommitsweremade.the longtimeperiodsarebecausesat4j openfire andluceneareestablishedprojectsandstillundergoingactivemaintenance.inall three however bugfixeshavebeenmadetothedatastructurein thelastfivecommits indicatingthatfullfunctionalcorrectnesshas been difficult to achieve.
the cozy specifications are an order of magnitude shorter than themanualimplementations.mostofourtimewasspentreverseengineeringtounderstandtheundocumentedexistingimplementa tion onceweunderstoodit writingthespecificationwasquick.forexample writing integrating andtestingtheztopoandsat4jspecificationstooklessthanadayeach.theopenfirerostermanager wasmorechallengingbecausewehadtofirstformalizetheimplicit contacts function a task the developers never carried out.
we alreadyunderstoodthecozyspecificationlanguage section3.
but we believe that a programmer could learn it more quickly than it took us to reverse engineer any one of the programs.
becausethespecificationsareshorter simpler andmoreabstract they are much easier to understand.
programmers writing specificationsarethereforelesslikelytomakemistakes andmistakes authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
generalized data structure synthesis icse may june gothenburg sweden table correctness results.
ztopo has no dedicated issue tracker.
project issues new defects found ztopo n a no sat4j no openfire yes lucene no will be easier to discover diagnose and correct.
the specifications also serve as concise unambiguous documentation.
.
correctness cozy might produce an incorrect data structure because of its use ofboundedverification.wealsomighthavemadeanerrorwhen writingthespecification.tocheckthecorrectnessofthecozy synthesizeddatastructures weensuredthatalltestsineachprojectstill pass.ztopo openfire andlucenehavenoteststhatcoverthedata structurewe replaced.fortheseprojects weverifiedthatour synthesizeddatastructurebehavesidenticallytotheoriginalimplementation during execution of the benchmarks we used in section .
.
table lists how many data structure related issues in each project s respective issue tracker might have been prevented by cozy.mostissuesrelatetodefectiveupdatecodeputtingthedata structureinabadstate.cozyisperfectlypositionedtopreventthosedefects changes to a data structure s abstract state are much easier to specify than the code that updates an optimized representation.
we now discuss some of these issues.
sat4j s variable metadata storage has suffered both performance andfunctionalcorrectnessissuesinthepastthatcozyavoids.today sat4jhasatest suitethatachieves89 statementcoverageonthe datastructurewereplaced andcozy ssynthesizedimplementation passes all tests.
ofsat4j ssevenreportedissues fiverelatetoupdatecode.sat4j s datastructureincludesseveralarraysofdatathatgrowexponentiallyasentriesareadded andthelogictogrowthemandkeepthecapacityinformationup to dateprovedtrickytogetright.thedata structure also supports a reset method to clear all of its internal state but developers did not properly revise its implementation when they introduced new state variables.
cozy can prevent these kindsofproblemssincetheprogrammerdoesnotneedtomaintain the concrete representation.
openfire having amore complexdatastructure hasbeen even more difficult to get right.
section presented only a simplified portion of the openfire roster manager specification.
the full specification has additional rules and visibility modes for groups.
in particular auser u1isvisibletoauser u2ifanyoneoffourdifferent conditions aremet the usershave addedeach otheras explicit contacts u1isinagroupwithvisibilitysetto everyone both users share a group with visibility set to onlygroup o r u1is in a group awith visibility set to onlygroup andu2is a member of a group bconfigured to have visibility onto a. this definition gives rise to two kinds of roster items explicit itemsduetocondition1andimplicititemsduetoconditions2 .
themanuallywrittenimplementationmakesatrade off allexplicit items plus implicit items due to conditions and are held astable performance results.
all times are in seconds.
project time orig.
time cozy ztopo sat4j openfire lucene concreteobjectsinmemory butimplicititemsduetocondition4are constructedon demandtosavememory.developershadtowrite a large amountof code tokeep the implicit contactscorrect when groupschange visibility orwhen groupmembershipchanges.
thatcodehasbeenafrequentsourceofdefects andstillhasopenissues.
for example one issue still open at time of writing reports that whenadministratorsdeleteauserwithoutfirstmanuallyremoving herfromallofhergroups sheremainsinotherusers contactlists.
otherissueswerecausedbythestoredstateoftherostergetting out of syncwiththeabstractstateoftheroster.bycontrast acozyprogrammerdoesnotneedtowritetheupdatecode cozydiscovers its own data representation and determines how to update it in response to changes.
additionally we discovered multiple new failures while replacing the original implementation.2for example the original implementationmakesitpossibletocreateasituationinwhichtwousers see different views of the roster according to one user both are visible to each other while according to another there is only a one wayvisibility.thesynthesizedimplementationdoesnotsufferfromtheseproblems.wedonotknowhowmanysourcecode defects contribute to the observed failures.
even lucene s small data structure has been a source of defects.
overlapping words caused some of its internal statistics to become corrupted because the original developers did not foresee this possibility.
our cozy implementation handles this case gracefully the naturalwaytospecifylucene soperationsdoesnothavethedefect.
.
performance we measured the performance of the handwritten and synthesized implementationsonrealisticworkloads.table3reportsthewallclock time required to run each benchmark to completion.
thebenchmarks are end to end and include application behavior inaddition to the data structure itself the resulting time therefore representstheoveralleffectoneachprogramfromusingthesynthesized data structure.
our benchmarks for ztopo and sat4j are the same ones used to evaluateanearlieriterationofcozy .theztopobenchmark is a log of recorded application usage that we replay.
the cozy synthesizedimplementationoftheztopotilecachematchesthe performance of the existing implementation almost exactly.
the handwritten and synthesized implementations are conceptually identical bothstoremaptilesinlinkedlistsgroupedbytiletype.
the dominant factor affecting performance is the speedof finding tiles by unique id which both implementations do using a hash table.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden calvin loncaric michael d. ernst and emina torlak sat4j s benchmark suite consists of eleven randomly selected inputfilesfromthe2002booleansatisfiabilitysolvercompetition .
the synthesized data structure for sat4j under performs the existingimplementation.thehandwrittencodeexploitssomefacts about the data that cozy does not know in sat4j variable ids can beusedasindexesintoanarraysincetheyalwaysfallbetweenzero andaknownmaximumbound.thisinteractspoorlywithcozy s total semantics for map lookups.
at code generation time cozy mustinsertsafetychecksateverymaplookup.insat4jthosesafety checks are unnecessary and harm performance substantially.
ourbenchmarkforopenfireisareplayedsequenceofactions against its admin panel that offers direct access to the internal roster data structure where users groups and explicit contacts can be modified.
the synthesized structure improves performance slightly.thereareseveralcontributingfactors butthedominant one is that the synthesized data structure can avoid a number of expensive internal representation checks.
to improve correctness thehandwrittenimplementationwilloftencleanupitsownstate whichimposessomeoverhead.bygeneratingcorrectcode cozy avoids these internal checks.
our benchmark for lucene is a series of operations on artificial data.cozy ssynthesizeddatastructureforluceneisverysimilar to the manually written one leading to identical performance.
related work thedatastructuresynthesisproblemdatestothe1970sand iterator inversion atechniqueforconstructingdatastructurestoacceler ate iterative operations .
our syntax for queries is similar to that found in earley s work although our techniques are substantially more powerful.
iterator inversion required handwritten rewrite rules while cozy s exhaustive search discovers complex transformations unaided.
the developers of the setl language took a different approach bysplittingitintoa purelanguageanda representationsub language.
thesub languagespecifieswhatstructurestousewhenrunning pure code .
more recently researchers have investigated dynamictechniquestoachievethesameeffect .beyondsimply choosing better existing implementations of an interface cozy can implementmorecomplexinterfacesthatrequirecomposingdata structure representations.
modernprogramsynthesistechniqueshavebeenappliedtolowleveldatastructurecode .thesetechniquescanhelptowrite pointer and array manipulationsbut unlike our work require the programmer to choose a data representation in advance.
more recently researchers have made headway on synthesizing completedatastructures.relc constructsdatastructureimplementations that track subsets of a collection.
it was later extended to produce safe concurrent data structures .
an earlier version ofcozy usedacustom outlinelanguage todescribedatastructure implementations and was able to synthesize data structures withricherspecificationsthanrelc.bygeneralizingtoarbitrary expressionsandconcretizationfunctions cozycannowsynthesizeafarwiderclassofdatastructures includingthedatastructuresfor openfireandlucenethatrequiremultiplerelatedcollectionsand aggregationoperators.togainthisexpressivenesswehavegiven up decidability relying instead on bounded verification.relc and earlier versions of cozy hada tuning step that used a user supplied benchmark to make low level optimizations.
cozy no longerhasthis step.its effectivenesswas neverfully evaluated andourpowerfulsymboliccostmodelnowfillstherole.somedata structures that cozy originally supported have also been dropped.
these were not necessary for the case studies we explored but we plan to reimplement them to extend cozy s applicability.
cozy shigh levelalgorithmresembles programmingbyrefinement pbr inwhichprogramsareproducedbymanualiterative modificationstoaninitialspecification.unlikepbrtoolssuchas kids designware and fiat each refinement iteration that cozy makes may bear little resemblance to the implementationbeforeit.thisisbecausecozyenumeratespossiblesolutions in a fixed order rather than transforming the input specification.
furthermore cozyrequiresnomanualeffortbeyondwritingaspecification.
the cost of this simplicity is that cozy cannot produce many of the more complicated algorithms derived by pbr systems.
however cozycanautomatepartsofthejob specificallythe finite differencing and data type refinement tasks .
the transformations that cozy performs are akin to the index selectionandviewmaintenance problemsindatabasesystems.index selection is the task of choosing useful indexes to speed up desired queries.autoadmin solvestheproblembyenumeratingmany possibleindexesandusingaqueryplannertodecidewhichwork best.asaresult autoadminislimitedbythesetofoptimization rules available to the query planner.
viewmaintenanceistheproblemofkeepinganindexormaterializedviewup to dateasthedatachanges.materializedviewsaresimilar to cozy s concretization functions they can be computed from the original state of the database.
dbtoaster implements a very efficientviewmaintenancesystem.morerecently thesameteam has worked on generalizing these ideas to collections including nestedcollections .whileit ispossibletoaugment cozywith thesetechniques cozy senumerativesynthesizergenerallydiscov ersthosesamesolutionswithouttheneedformanualrewriterules.
conclusion cozyiseffectivebecauseincrementalizationallowsittoimplement both pure and imperative operations using only a query synthesizer.
a high quality cost function and diversity injection make the query synthesizer powerful and practical.
as a result cozy does not need clever analyses or transformation rules.
our case studies demonstrate that data structure synthesis can improve software development time correctness and efficiency.