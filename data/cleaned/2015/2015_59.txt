jens knoop uwe zdun hrsg.
software engineering lecture notes in informatics lni gesellschaft f ur informatik bonn getting to kno wyou towards acapability model forjava ben hermann1michael reif2michael eichberg3and mira mezini4 abstract developing software from reusable libraries lets de velopers faceasecurity dilemma either be efficient and reuse libraries as the yare or inspect them kno wabout their resource usage butpossibly miss deadlines as reviews are atime consuming process.
in this paper w ep ropose a novelcapability inference mechanism for libraries written in ja va.i tu sesacoarse grained capability model for system resources that can be presented to de velopers.
wefound that the capability inference agrees by .
on expectations to wards capabilities that can be deri vedfrom project documentation.
moreo ver our approach can find capabilities that cannot be disco vered using project documentation.
it is thus ahelpful tool for de velopers mitigating the aforementioned dilemma.
1s ummary the efficienc yo fs oftware de velopment largely depends on an ecosystem of reuse bo99 gr93 .
numerous software libraries are available that solv evarious problems ranging from numerical computations to user interface creation.
the safe use of these libraries is an exigence for the de velopment of software that meets critical time to market constraints.
howe ver when including software libraries into their products software de velopers entrust the code in these libraries with the same security context as the application itself re gardless of the need for this excessi veendorsement.
forinstance asystem that makes use ofalibrary of numerical functions also enables the library to use the filesystem or make network connections although the library does not need these capabilities.
if the library contains malicious code it could mak euse of them.
in commonly used languages lik ejava no effecti vemechanism to limit or isolate software libraries from the application code exists.
so de velopers faceadilemma either trust the component and finish the project in time or be secure revie wthe library ssource code and possibly miss deadlines.
wepropose to consider this excessi veassignment of authority as aviolation of the principle of least privile ge .the principle states that every program should operate under the least set of privilege necessary to complete its job .i no rder to alleviate the described dilemma we introduce an effecti vemechanism in this paper to detect the actual permission need of software libraries written in ja va. drawing inspiration from android we construct acapability model for ja va.i tincludes basic coarse grained capabilities such as the authority to access the filesystem or to open a 1technische uni versit at darmstadt fachbereich informatik fachgebiet softwaretechnik hochschulstra e darmstadt hermann cs.tu darmstadt.de 2reif cs.tu darmstadt.de 3eichberg cs.tu darmstadt.de 4mezini cs.tu darmstadt.de60 ben hermann et al.
network socket.
as ja vaprograms by themselves cannot communicate with the operating system directly anyinteraction with those capabilities has to happen through the use of the ja vanativeinterface jni .
by tracking the calls backwards through the call graph we produce acapability set for every method of the ja vaclass library jcl and by the same mechanism to wards methods of alibrary .w ec an thus effecti vely infer the necessary capabilities of alibrary using our approach.
wecan also infer the subset of these capabilities used by an application as it may not use every functionality supplied by the library.
as the precision of our approach is directly depending on the precision of the algorithm used to calculate the call graph of the library w et ook se veral measures to compute a reasonably precise call graph while not compromising the scalability of the algorithm too severely.w ee valuated our approach by comparing our results against expectations deri ved from api documentation.
wefound that for projects from the qualitas corpus that we evaluated against actual results exceeded expectations and produce afar more accurate footprint of the projects capability usage.
thereby our approach helps de velopers to quickly mak einformed decisions on library reuse without the need for manual inspection of source code or documentation.
in our pursuit to mitigate the software de veloper sdilemma w.r.t.
library reuse we thus contribute the following in our paper an algorithm to propagate capability labels backwards through acall graph alabeling of nati vemethods with their necessary capabilities to bootstrap the process acollection of efficient analysis steps to aid the precision of common call graph algorithms anevaluation of the algorithm against extracted capability expectations from documentation.
weprovide the implementation and all related data of our approach here