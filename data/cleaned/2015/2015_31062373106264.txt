understanding misunderstandings in source code dangopstein?
jakeiannacone?
yu yan loisdelong?
yanyanzhuang martink.
c. yeh justincappos?
?
newyork university usa universityofcolorado colorado springs usa pennsylvania stateuniversity usa abstract humans often mistake the meaning of source code and so misjudge a program s true behavior.
these mistakes can be caused by extremely small isolated patterns in code which can lead to signiicant runtime errors.
these patterns are used in large popularsoftwareprojectsandevenrecommendedinstyleguides.to identifycodepatternsthatmayconfuseprogrammersweextracted a preliminary set of atoms of confusion from known confusing code.weshowempiricallyinanexperimentwith73participants thatthesecodepatternscanleadtoasigniicantlyincreasedrateof misunderstanding versus equivalentcode without the patterns.
we thengoontotakelargerconfusingprogramsandmeasure inan experiment with43 participants theimpact interms ofprogrammer confusion of removing these confusing patterns.
all of our instruments analysiscode anddataarepubliclyavailableonline for replication experimentation andfeedback.
ccs concepts general and reference empirical studies software and its engineering softwareusability keywords programminglanguages program understanding acmreference format d.gopstein j.iannacone y.yan l.delong y.zhuang m.k.
c.yeh j.cappos.
.understandingmisunderstandingsinsourcecode.in proceedings of 11th joint meeting of the european software engineering conference andtheacmsigsoftsymposiumonthefoundationsofsoftwareengineering paderborn germany september 4 8 esec fse 11pages.
introduction source code serves a dual purpose.
it communicates program instructions to machines and programmer intent to people.
unfortunately peopleandmachinesoftendrawdiferentconclusionsabout thebehaviorofapieceofcode.whileadiferenceofinterpretation permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forproitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation ontheirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspeciicpermission and or a fee.
request permissions from permissions acm.org.
esec fse september 4 8 paderborn germany copyright held by the owner author s .
publication rights licensed to associationfor computing machinery.
acm isbn ... .
randomness poorly understood apis or undeined behavior it canalsooccurasaresponsetosmall self containedlinesofcode.
these code patterns which are easy to misinterpret can naturally leadtobugsincode.inturn theconsequencesofthesebugscan includediminished productivity faultyproducts and higher costs.
inthepast50yearssincesoftwarehasbecomeubiquitous we have seen a proliferation of software bugs.
notable examples such asapple s gotofail sslbug ariane5 sloatingpointoverlow bug andat t scascadingnetworkfailure haveshown us that it is extremely diicult to deliver bug free software despite large incentives to do so.
the consequences of the aforementioned bugs were respectively an ssl man in the middle vulnerability to allosxandiosusers thedestructionofa 500mspacecraft and thelossoftransnationalcommunicationfor50millionlongdistance calls.
each of these failures was caused by a single well contained programmingerroratthesyntacticorsemanticlevel ratherthan the algorithmic or system levels of the project.
issues like this are quite common.
while editing this document for submission cloudlare published an analysis of cloudbleed a bug that leakedsensitivecustomerdatapubliclyontheweb.thetwo line snippetofcoderesponsibleforthebugcontainstwoofthesmall self containedpatternswediscusshere pre increment andomitted curlybraces see table1 .
the ability to identify and remove these confusing program elementsisimportantformorethanjusttheavoidanceofaccidents.
the ability to understand pre existing source code is one of the most important elements of a continuously successful software project.confusingcodeafectscomprehension aconceptcentralto allstagesofsoftwaredevelopment particularlymaintenanceand code review.
code review is a valuable tool for validating design decisions anditsefectivenessrestsheavilyonthereadabilityof thesourcecode .variousestimatesplacecodemaintenance or themodiicationofcodeaftertheproducthasalreadybeendelivered as the most expensive phase of development in terms of both timeandmoney .thus beingabletoreliablyidentifyand removecodethatcancausemisunderstandingswillalsoenhance productivityandreduce maintenancecosts.
in this work we seek out and experimentally validate the smallest pieces of code that can routinely cause programmers to misunderstand code.
we call these indivisible misunderstanding causing patterns atomsofconfusion or atoms forshort.theseatomscan serveasanempiricalandquantitativefoundation forunderstandingwhat makescodeconfusing.todothis we selectedprograms thatarealreadyacknowledgedasconfusingtohumans winners of the ioccc the international obfuscated c code contest .
we esec fse september4 paderborn germany gopstein iannacone yan delong zhuang yeh andcappos isolated small patterns of code often contained within a single line from theiocccprograms that were the underlying causeof programmer confusion.
we then performed an empirical human subjects experiment with participants to ind which of these codepatternscausedastatisticallysigniicantamountofconfusion i.e.
lead programmersto believe theprogram containing this pattern behaves diferently than the clanguage speciication dictates .
next we measured the impact of removing these atoms of confusionfromlargerobfuscatedprograms alsodrawnfromioccc winners.
we simpliied the ioccc programs by applying behaviorpreservingtransformationstoremoveidentiiedatoms andused these programs as the basis for a second experiment.
we recruited 43participantswhohadnottakenpartinourpriorexperiment.we were able to determine quantitatively how much we could reduce programmer errorsimply byclarifying theseatoms.
throughthiswork we have madeseveralunique contributions methodology for empirically deriving confusing code patterns.
wedescribeascientiicallysoundmethodforinding validating and measuring the potency of small confusing patterns in code.
our methods are empirical quantitative and objective which results in high quality easily analyzable data.
given the value of replicable work in empirical software engineering we have made replication packets publicly available at so anyone can reproduce orextend our work at any time.
alarge publiclyavailabledataset.
wetested122questionson 116subjectsovertwoirb approved1experiments.allofour anonymized data has already been published to our website aswell sootherresearcherscantest theirownhypotheses onan existing dataset.
statistically signiicant atoms of confusion.
we uncovered assessed and analyzed very small potent sources of confusion.wedescribetheseobfuscatingatomsandthetransformationsthat clarifythem.
survey of these patterns in well known style guidelines.
some ofourindingscontradictexpertopinionsfoundinpopular c style guidelines.
we survey several well known documents and point out the recommendations that conlict with our empirical evidence.
in depth analysis of experiment subject responses.
beyond supporting our primary hypothesis our data ofers many interestingviewsintoprogrammercomprehensionandbehavior.
we explore the potential signiicance of the distributionofwronganswers tothesamequestion the timeit takes programmers to answer correctly and the accuracy of our subjects estimates oftheirownability.
the rest of this paper is laid out as follows.
we begin in section by discussing the many sub ields of computer science from which we drew inspiration or direction for our work.
next we lay out the major concepts that underlie our research questions in section3.insection4 wedescribetheatomsdiscoveredinioccc winners.buildingontheidentiiedatoms weexperimentallytested whichweremoreconfusingthantransformedcode asisdetailed insection5.wetooktheconirmedatomsandmeasuredthesize 1all experiments described in this paper were approved by the institutional review boards irbs at both nyu andpsu.oftheirimpactonsmallprogramsasdescribedinsection6.finally insections 7and9we discuss our results inalarger context.
related work code confusion is a recognized problem that has had many proposed solutions.
speciiccode constructshave beendeemed taboo by the programming community most notably gotostatement global mutable state and magic numbers .
less aggressively programmers have learnedto avoidcertain patterns that have been dubbed code smells or as fowler deined them structures in the code that suggest... the possibility of refactoring .inthiswork weaimtomovetheseideasfromhunches and gut feelings to empirically veriied examples of diicult code.
below we summarize the work of others who have attempted to explainorremedy the challenges of understanding code.
style guides.
manyofthepatternsweidentiiedoverlapwith recommendationsgiveninpopularstyleguides.forexample the gnucodingstandards recommendsavoidingvariablereuse andusingassignmentsasconditionalpredicates.nasa s cstyle guide also warns about several of the patterns we investigate including recommending the use of explicit comparisonsin predicates avoidingtheconditionaloperator andnotusingside efect operatorsinrelational expressions.however wefound situations where style guidelines do not match our indings such as avoidingcurlybracesforsingle statementblocks .wedetailthese indingsinthe discussionsection.
obfuscation.
obfuscationtakeslegiblecodeandtransformsit intoaformthatmasksitsfunction.theobfuscationtechniquesmost closelyrelatedtoourworkarethosethatevaluatethe potency i.e.
humanreadability ofobfuscation.ourworkreversesthegoals ofsuchatechniquebytakingcodethatisdiiculttounderstand and transforming it into a more readable form.
recently avidan and feitelson reported using a variety of indirect metrics such as transparency and low complexity to evaluate the confusion ofobfuscation techniques.
ourworkmore directly evaluatescode confusionbytestingsubjectcomprehension.
metrics.
there have been many eforts to quantify the clarity of software .
multiple studies have shown that the number of lines of code does correlate with the incidence of bugs implying that more code leads to more bugs.
on the other hand cyclomaticcomplexity looksatalllinearly independentcircuits through a program graph.
such a technique is useful for analyzing codeatthefunction module orprogramlevel.theconfusionwe study however tendstomanifestontheexpressionorstatement level whichisiner grainedandoftenhasaverylowcyclomatic complexity.
halstead proposed measures of software based on thecounts proportions anddiversityofoperatorsandoperandsin programs withoutregardtothespeciicoperatorsandoperandsin use.yet wehavefoundthatconfusingelementscanberemovedby simply moving or replacing operators while keeping the halstead metrics constant.
more recently shao and wang measured complexity by the combined cognitive weight of individual control structures branch iteration concurrency etc.
.
however their work treats all interactions between control structures as uniform.
ourresultsindicatethatsomeoperationscanbedisproportionately more confusing thanothersthat compute the same result.
130understandingmisunderstandingsin source code esec fse september4 paderborn germany staticanalysis andtooling.
heuristicscanbeusefulforlaggingpotentially detrimental staticproperties ofaprogram.
these actions can be performed by compilers and static analysis tools suchaslint .insteadofsimplyrejectinginvalidcode compilers almostalwaysincludevalidationcodetoalertprogrammerstotheir mistakes.atthetimeofthiswriting gcchas185warninglags manyof whichpresenthelpfulcomments aboutcommonunclear ordangerous sourcecode patterns discoveredduringcompilation.
in general these tools target issues that overlap with our experiments basedonthecollectiveanecdotalevidenceofthesoftware engineering community.
the theory put forth in this paper can bolsterwork onengineering tools byvalidating theirimplicitassumptions andoferingadditionalpatterns to investigate.
program comprehension.
of the literature in program comprehension the work most related to our investigation is buse and weimer s whichstudiedlocalcodefeaturesofsmallprogram snippets.however theirmethodofdeterminingcodecomplexity isbasedontheopinionofprogrammers whoratedsnippetsona scale of readability.
tashtoush et al.
also designed a model of software readability by asking questions about what features programmersfoundconfusing.wecomplementthispreviouswork bytestingan objective measure ofmisunderstanding.
a few of the speciic code patterns we investigate have been examined in earlier studies.
dolado et al.
tested whether code that contained side efects was more likely to cause subjects to misinterpretitsfunction.theirmethodofevaluationisverysimilar to ours and their results are generally conirmed by ours but their experimentfocusedonlyononecodepattern.jones testeda hypothesisthat therewillbeasigniicantcorrelationbetweena developer s knowledge of relative binary operator precedence and the amount of experience they have had handling the respective binary operator pair .
his experiment involved subjects placing redundantparenthesesaroundexpressionswithtwobinaryoperatorsandmeasuringthecorrectnessoftheplacement.confusion surrounding binary operators is very related to our atom operator precedence .theprimarydiferencebetweenjones methodandours isthathehassubjectsmodifythecodesnippets whileoursareonly asked to hand evaluatethe code.
while testing the presence of confusion against a clarifying transformation is not the primary focus ofhiswork theresultshesharesareconirmedbyourexperiments.
elshof and marcotty s work introduced the idea of clarifyingtransformationstoimprove thereadability ofsource code.we leveragetheseideasinourexperimenttomeasurethemagnitude ofconfusioncausedbyspeciic code elements.
definitions inthissection weexplainthetermsandconceptsusedinourwork.
wedeinethesmallestpatternsincodethatcancausemisunderstandinginprogrammers theprocessusedtopresentthesepatterns to test subjects and the transformations that can remove them.
we alsoreine the scope ofour investigation.
confusion .forthepurposeofthiswork confusion isdeined aswhathappenswhenapersonandamachinereadthesamepiece ofcode yetcome to diferentconclusions aboutits output.ourgoalwastotargetspeciicsituationswhereaprogrammer might tend to misunderstand the behavior of a piece of code.
then welookedwithinthoseinstancestoidentifycommonpatternsof codethatcouldbethesourceofthisconfusion.welabeledthese patterns atoms of confusion .
we restricted our deinition of an atom toonly minimalportions ofcode so that our indings would begeneralizableandoccurfrequentlyinrealprojects.thischoice also ensures that we can design experiments that are very accurate inmeasuringtheextentoftheconfusioncausedbytheatom.for example ifasubjectweretomisinterpret a b itisimportant totestwhethertheywouldmisinterpret a b b aswell.if bothassignmentorpost incrementareconfusingwhentheyappear alone then the confusion is not due to the combination of the two.
exclusions.
we acknowledge a number of factors can lead to programmercomprehensionerrors.totargetprogrammermistakes causedbymisunderstanding asopposedtocognitiveinabilityor lackofinformationweexcludethefollowingfromourexperiments.
non deterministic non deterministic programs are impossible to reliably predict and are therefore outside the scopeofourinvestigation.forexample weavoidthe rand function inour code snippets.
undeined non portable code which is not executed uniformly across various computer environments was excluded.for example a a has nouniversal meaning.
computational programmerssuferfromworkingmemoryandattentionconstraints butthisistangentialto ourinvestigation.anyconfusionthatcouldberemovedby using acalculatorisoutsidethe scope of this work.
apirelated in our experiments we only focus on code for whichthe entire implementationisavailable.
.
normalization before human subjects read source code in either of our experiments we irst performed a normalization step on the programs.
anyinstancesoftheaboveexclusionsfoundintheexperiment s source code was replaced by conceptually equivalent code that contained noknown sources of confusion.wealso made sure not to encode any meta information in our code.
the speciic precautions we took were similar to those used by siegmund et al.
whoalsoenforcedabottom up syntax to semanticsstyleofcomprehensionbyremoving beaconsthatmighttriggeraconnection to pre existing semantic knowledge.
in our case we removed all comments sanitized all string literals renamed all variables to v1 v2 etc.
and every macro to m1 m2 etc.
and we kept all math as simpleas possible whilestillpreservingthe atomof confusion.
.
transformation atoms of confusion are abnormally confusing patterns in code.
we deine atoms relative to functionally equivalent code that does not confuse programmers.we call theremoval ofan indivisibly small sourceofconfusion an atomremoval transformation .thesetransformations substitute confusing code with similar but relatively lessconfusingcode.forexample takethecode v1 f2 .to remove this atom which we call logic as control flow we add an explicit if condition around v1to readif v1 f2 .
thesetransformationsarenotunique asthereisnotnecessarily 131esec fse september4 paderborn germany gopstein iannacone yan delong zhuang yeh andcappos any one right way to write code.
several types of atoms can be obviated in multiple ways and in these cases we used our best judgmenttochoosethemostunderstandablecodetoreplacethe atom.
this can lead to a pitfall where a transformation either fails toremovetheoriginalsourceofconfusion oraddsitsown.this type oferrorreduces the observedpotency ofthe originalatom.
identified atoms tobuildaninitialsetofpotentialatomsofconfusion westudied thecodeofknownconfusingprograms.wetriedtominimizethe amount of confusion from exclusions section and maximize the likelihoodofconfusionfrompotentialatomsinourtestset.with this criteria in mind we chose to explore the winning entries of the international obfuscated c code contest ioccc .
the goal of thiscompetitionistosolicitprogramsthatdemonstrate violations of structured programming non clarity and use of by the k r book c .
iocccwinnersaredesignedtocauseconfusion in programmersand assuch theseprogramsofersuicientexamples of atoms of confusion.
whileioccc entriesmay not be generally representative of real life programs they reveal the same patterns that often docreate confusioninlarge andpopular projects.
theprocessofidentifyingnewpotentialatomsofconfusionwas carriedoutbytwohumancoders.programswerebrokendowninto smallconfusingsections and compared against eachother to ind common recurring patterns.
snippetsof code that were confusing contained no excluded forms of confusion and could be simpliied through a behavior preserving transformation were considered candidates to be atomsofconfusion.
atomexistence experiment theirstofourtwoplannedexperiments figure1 wasdesignedto validatetheinitialsetofatomsidentiiedinsection4.programmers wereshownaseriesofcodesnippetsandaskedtohandevaluate each andsubmitthestandardoutput.questionswereformulatedin pairs each structurally similar but one containing an atom of confusion andtheothertransformedtoremovetheatom.eachsnippet was designed to be minimal that is to show the smallest possible pieceof codetoexhibit theefectof theatom.
onlyone atomwas testedpersnippet.duetothesmallsizeofmostatoms theaverage snippet contained only lines of code most of which was boiler plate.
ignoring blank lines declarations and experimental printf statements the average length of atom related code was .
lines per snippet.
we created three pairs of atom candidate transformed questionsper atom.an example snippetisshowninfigure .
we recruited and tested subjects predominantly students at large north american universities.
each subject was required to have at least months experience with the corc programming languages.
the questions were presented via a web interface.
sourcecodewasdisplayedwithnosyntaxhighlighting sincethe selection of any particular highlighting scheme would bias the subjects abilitytoparsethecode.eightoftheparticipantsweredirectlysupervisedastheytookthetest whiletheremainingsubjects completedthe questionsonline.design randomizedpartialcounterbalanced sample programmers with monthsc c experience.
control tiny program 8lines containingasingleatom.
treatment a versionof the controlcode transformedto remove the atomofconfusion.
nullhypothesis h0 codefrombothcontrolandtreatment groupscan be hand evaluatedwithequal accuracy.
alternative hypothesis ha the existenceof an atomof confusioncauses more errorsthanothercode in hand evaluatedoutputs.
figure summary ofthe atom existenceexperiment void main char v1 printf c n v1 a obfuscatedvoid main char v1 zxcvb printf c n v1 b clariied figure example reversed subscripts snippet pair.
.
experimentalconditions beforeexecutingourfull scaleexperiment weconductedapilot experiment on participants with atoms.
the pilot helped us correct small errors in our instrument and tune the parameters of our full experiment.
due to the large volume of questions we wanted to show in the full experiment we decided not to show everyquestiontoeverysubject.toreducementalfatigue weaimed toconstrainthelengthofeachsessiontoapproximately60minutes for the average participant .
since each question on average took just under a minute to answer in our pilot we chose to show each subject only of each group of question pairings in our fullexperiment assignedcyclically.thismeansthateachsubject received2 3of our questions and each question was received by2 3of all participants.
each subject always saw both the atom candidate andits transformedpair.
wecontrolledforthepossibilityofalearningefect inthree distinctways.firstly werandomizedtheorderofeveryquestion sothatanybiasinherentinthequestionorderingwasdistributed evenly among all participants.
secondly between each atom candidate transformedpairofquestionsweenforcedaminimumdistance of intermediate questions.
this number was chosen by extrapolating from our pilot experiment results.
in the pilot we identiied the optimum distance after which learning efects diminished and thenscaledthisvaluebythenumberofnewquestionsaddedfor the main experiment.
lastly we randomized constant values in the code.
atoms by deinition cannot rely on the speciic value of a constant.
therefore by changing the constant values in our questionsthevalidityoftheatomremainedintact whiletheadded diferences madeitharder to connectthe twoquestionsof apair.
we designed each question such that every common interpretation correctandincorrect wouldresultinadiferentoutput.we did this by using combinations of constants for our variable initializations which create diferent values when combined in diferent ways.forexample ifweweretestingwhethersubjectsunderstood 132understandingmisunderstandingsin source code esec fse september4 paderborn germany table atomcandidatesextractedfromioccc winners atomname description atomexample transformed change of literal encodingall numbers are stored as binary but for convenience we represent numbers in decimal hex or octal.
dependingonthe circumstance certain representationsaremoreunderstandable.printf d printf d preprocessor in statementthe preprocessor replacesdirectives with whitespace.
consequently preprocessor directives may be placed insideastatement.sincethepreprocessordirectiveandthesourcecodearecompiledindiferentphases theyareprocessed independently.int v1 define m1 define m1 int v1 macrooperator precedencemacro