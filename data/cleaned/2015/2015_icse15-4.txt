coexecutability for efficient verification of data model updates ivan boci c tevfik bultany department of computer science university of california santa barbara usa bo cs.ucsb.eduybultan cs.ucsb.edu abstract modern applications use back end data stores for persistent data.
automated verification of the code that updates the data store would prevent bugs that can cause loss or corruption of data.
in this paper we focus on the most challenging part of this problem automated verification of code that updates the data store and contains loops.
due to dependencies between loop iterations verification of code that contains loops is a hard problem and typically requires manual assistance in the form of loop invariants.
we present a fully automated technique that improves verifiability of loops.
we first define coexecution a method for modeling loop iterations that simplifies automated reasoning about loops.
then we present a fully automated static program analysis that detects whether the behavior of a given loop can be modeled using coexecution.
we provide a customized verification technique for coexecutable loops that results in more effective verification.
in our experiments we observed that in of cases modeling loops using coexecution reduces verification time between and orders of magnitude.
in addition the rate of inconclusive verification results in the presence of loops is reduced from down to all without requiring loop invariants or any manual intervention.
i. i ntroduction nowadays it is common for software applications to store their persistent data in a back end data store in the cloud.
for many application domains such as social networking data is the most valuable asset of an application.
hence the correctness of the code that updates the data is of significant concern.
in this paper we present automated verification techniques that improve the verifiability of code that update the data.
typically application programmers write object oriented code for accessing and updating the data in the back end data store.
this code is automatically translated to datastore queries using object relational mapping orm .
modern software development frameworks use the model viewcontroller mvc architecture to separate the user interface code view from the code that handles the user requests controller and the code that accesses and modifies the data store model .
the inherent modularity in this architecture creates opportunities for automated verification.
in a typical restful mvc based application user requests trigger execution of actions that read from or write to the back end data store using an orm library.
data store related bugs can be eliminated by verifying the implementations of these actions.
this work is supported in part by the nsf grant ccf .1class postscontroller def destroy tags ... posts post.where id params ... posts.each do p p.tags.destroy all!
end ... end 11end fig.
.
an example action in our earlier work we demonstrated that one can check invariants about the data store by translating verification queries about actions to satisfiability queries in first order logic fol and then using an automated fol theorem prover to answer the satisfiability queries.
however due to undecidability of fol an automated theorem prover is not guaranteed to come up with a solution every time and sometimes it may time out without providing a conclusive result.
in particular actions that have loops in them are hardest to check automatically.
verification of code that contains loops typically requires manual intervention where the developer has to provide a loop invariant in order to help the theorem prover in reasoning about the loop.
this reduces the level of automation in the verification process and hence its practical applicability.
in this paper we present a fully automated technique that significantly improves the verifiability of actions with loops.
our key contribution is the definition of a concept we call coexecution which while intuitively similar to parallel or concurrent execution does not correspond to an execution on actual hardware.
it is a concept we introduce specifically to make verification easier.
we call a loop coexecutable if coexecution of its iterations is equivalent to their sequential execution.
we present an automated static analysis technique that determines if a loop is coexecutable.
we also developed a customized translation of coexecutable loops to fol that exploits the coexecution semantics and improves verifiability.
we implemented these techniques for verification of actions that update the data model in applications written using the ruby on rails rails framework .
we applied our approach to verification of actions extracted from real world rails applications.
our experimental results demonstrate that exploiting the coexecutability property significantly improves the verifiability of actions with loops.
p1 p2 p3 t1 t2 t3 p1 t1 p2 t1 p2 t2 p3 t2 p1 p2 p3 t3 p1 p2 p3 t3 p1 p2 p3 t2 t3 p2 t2 p3 t2 iteration execution for p1 delta remove t1 p1 t1 p2 t1 iteration execution for p2 delta remove t2 p2 t2 p3 t2 p1 p2 p3 t1 t2 t3 p1 t1 p2 t1 p2 t2 p3 t2 p1 p2 p3 t1 t2 t3 p1 t1 p2 t1 p2 t2 p3 t2 delta union remove t1 t2 p1 t1 p2 t1 p2 t2 p3 t2 p1 p2 p3 t1 t3 p1 t1 p2 t1 p1 p2 p3 t3 iteration execution for p3 delta empty p1 p2 p3 t2 t3 p2 t2 p3 t2 p1 p2 p3 t3 iteration execution for p1 delta remove t1 p1 t1 p2 t1 iteration execution for p2 delta remove t1 t2 p1 t2 p2 t1 p2 t2 p3 t2 iteration execution for p3 delta remove t2 p2 t2 p3 t2 delta union a sequential execution b coexecution fig.
.
sequential execution compared to coexecution the rest of the paper is organized as follows.
section ii provides an overview of the problem and presents coexecution at an intuitive level.
section iii formally defines data stores and sets up the foundation for section iv in which we define coexecution and define and prove the coexecutability condition.
section v presents the static program analysis algorithm that decides whether a given loop is coexecutable.
section vi demonstrates the benefits of modeling loops using coexecution on loops extracted from real world applications.
section vii discusses related work and section viii concludes the paper.
ii.
o verview recently we presented an automated verification framework for verifying the actions that update the data which translates the action code and user specified invariants into a formal model we call abstract data store ads translates verification queries about ads specifications into first order logic fol and verifies them using an off the shelf fol theorem prover .
the key obstacle in automated verification of actions is verification of loops.
the inclusion of even simple loops in actions greatly increases verification time and it also increases the chance that the theorem prover times out without ever reaching a conclusion on whether the given action breaks an invariant.
upon manual inspection of the theorem prover deduction logs we found out that the key issue that the theorem prover struggles with is reasoning about the iteration interdependencies in loops.
in order to verify loops it is necessary for the automated theorem prover to deduce the rules that define which objects and associations will exist after the loop has executed.
to accomplish this the theorem prover has to compute the transitive closure of the loop body which is not expressible in fol hence fol theorem provers cannot make such deductions.
lacking that capability the theorem prover attempts to deduce the state of the data store after the first iteration has executed then after the second iteration has executed etc.
since we do not bound the number of iterations unless the theorem prover discovers a way to violate the invariant without reasoning about the loop which is a very specific case the automateddeduction process employed by the theorem prover does not terminate.
this causes the theorem prover to time out without a conclusive result.
a. coexecution overview figure presents an example rails action based on an open source discussion platform called discourse .
this action deletes all the tagobjects associated with a set of post objects.
the set of post objects that are chosen by the user are assigned to a variable called posts in line .
then using a loop lines to that iterates over each post object in posts with the loop variable p all the tagobjects that are associated with the objects in posts are deleted.
a data store invariant about the discourse application could be that each tagobject in the data store is associated with at least one post object.
in order to verify such an invariant we need to prove that each action that updates the data store such as the one shown in figure preserves the invariant.
as we discussed above actions with loops are especially hard to verify when translated to fol.
the observation that lead to the technique we present in this paper is the loops can often be modeled in a way that does not require iteration interdependency.
and in such cases it is possible to translate the loops to fol in a way that is more amenable to verification.
we call this alternate execution model for loops that removes iteration interdependency coexecution .
consider the action shown in figure .
assume that the initial data store state contains three post objectsp1 p2and p3and three tag objectst1 t2andt3 with the following associations hp1 t1i hp2 t1i hp2 t2i hp3 t2i.
also assume that the loop iterates on all the post objects in the order p1 p2 p3 i.e.
the variable posts is the ordered collection ofp1 p2 p3 .
given this initial state the standard sequential execution semantics of the loop in lines to in figure is shown in figure a where gray rectangles with rounded corners denote states of the data store and solid line arrows denote iteration executions.
the first iteration executed for post p1 deletes all tags of p1and their associations.
we identify the operations executed by this iteration and summarize them as a delta of thisoperation i.e.
the changes in the data store state caused by this operation .
the first iteration removes t1and all associations oft1 hp1 t1iandhp2 t1i .
similarly the second iteration deletes all tags ofp2 resulting in a delta that removes t2 hp2 t2iandhp3 t2i.
finally the third iteration does not alter the data store state as p3is not associated with any tags at that point.
figure b demonstrates the alternate coexecution semantics for the same loop.
instead of executing iterations sequentially to reach the post state we first identify the delta for each iteration directly from the pre state in isolation from other iterations.
as expected the first iteration the one for p1 is identical to the one from figure a .
however the iteration forp2deletes all tags ofp2 its delta removing t1andt2 and all their associations.
note that this delta is different from the delta of the sequential execution iteration for p2shown in figure a .
similarly the iteration for p3deletest2and all associations whereas sequential execution for p3produced an empty delta.
the deltas of these independent executions are combined together using the delta union operation which in this case returns a union of all the delete operations we formally define the deltas and the delta union operation in section iv .
in this example the unified delta removes t1 t2and their associations.
finally we use the unified delta to migrate from the pre state to the post state in one step reaching the same post state we acquired using sequential execution as shown in figure b .
we call this one step execution semantics based on the unified delta coexecution.
for some loops based on the dependencies among loop iterations coexecution will yield a different result than sequential execution.
however coexecution is equivalent to sequential execution for some classes of interdependencies.
note that in our example iterations areinterdependent since the p1 iteration prevents the p2iteration from deleting t1and its associations and yet coexecution and sequential execution produce identical results.
in section iv c we formally define thecoexecutability condition that if true for a given loop guarantees that coexecution of the loop is equivalent to sequential execution of iterations.
in section v we implement this condition as a static program analysis and based on this analysis we are able to translate loops to fol in a manner that is more amenable to verification.
in our analysis we assume that actions that update the data store are executed as transactions which is the case for most mvc based web applications .
hence the database ensures that actions do not interfere with one another during runtime.
effectively all actions can be considered to execute within atomic blocks and hence so are the loops we are verifying.
this gives us to freedom to model operations within a loop in any order as long as the final effects of the loop execution are identical to the effects of sequential execution.
iii.
f ormal model in this section we present the formal model we use for modeling data stores.a.
data store semantically an abstract data store is a structure ds hc r a iiwherecis a set of classes ris a set of relations ais a set of actions and iis a set of invariants.
the set of classes cidentifies the types of objects that can be stored in the data store.
each class can have a single superclass or no superclass superclass c 2c f?g and transitively the superclass relation cannot contain cycles.
a relationr hname c o ct cardi2rcontains the name of the association an origin class co2c a target class ct2c and a cardinality constraint card such as one to one one tomany etc.
.
data store states given a data store ds hc r a ii the set of all possible data store states is denoted asds.
each data store state is a structure ho ti2dswhere ois a set of objects andtis a set of tuples .
together we refer to objects and tuples as entities .
we simplify our notation by using certain operators on objects and tuples indiscriminately.
for a state s ho ti2ds objectoand tupletthat may or may not be in s s fog ho fog ti snfog honfog ti o2s o2os ftg ho t ftgi snftg ho tnftgi t2s t2t objects are instances of classes whereas tuples are instances of relations.
each object o2ois an instance of a class c2cdenoted by c classof o .
each tuple t2tis in the formt hr oo otiwherer hname c o ct cardi2r andclassof oo coandclassof ot ct. for a tuple t hr oo otiwe refer toooas the origin object and otas the target object and 8t hr oo oti 8s2ds t2s oo2 s ot2s.
cardinality constraints of each relation r2rmust be satisfied by every data store state in ds.
note that in the abstract data store model objects do not have basic fields.
this model focuses on objects and how they are associated with one another.
basic fields can be introduced to the model by treating them as associations to a basic type class.
for example an agefield would be an association to one object of the integer class this way of treating basic fields has been used in alloy for example .
observe that in the abstract data store model all updates consist of creations and deletions of entities i.e.
objects and tuples .
actions and invariants given a data store ds hc r a ii adenotes the set of actions.
each action a2acorresponds to a set of possible state transitions hho ti ho0 t0ii ds ds.
actions characterize possible updates to data store states i.e.
the transitions between the states .
given a data store ds hc r a ii iis the set of invariants.
an invariant i2icorresponds to a boolean functioni ds!ffalse truegthat identifies the set of data store states which satisfy the invariant.
behaviors given a data store ds hc r a ii a behavior of a data store ds is an infinite sequence of data store statess0 s1 s2 where 8k sk2ds 9a2a hsk sk 1i2a 8k 8i2i i sk truein other words each behavior of a data store starts with an initial data store state for which all invariants hold and each pair of consecutive states corresponds to execution of a data store action.
given a data store ds hc r a ii all states that appear in a behavior of ds are called the reachable states ofds and denoted as dsr.
b. statements an action is composed of a finite number of statements .
a statement can be represented as a set of pairs of states hs s0i ds ds which semantically represent possible state transitions by means of that statement.
for a statement sand two states sands0 we will use sto denote that hs s0iis a possible execution state transition of s. for example a statement scthat creates an object of class c could be defined as sc 9oc classof oc c oc2s0 oc62s 8e e2s e2s0 e oc as an other example consider a block statementbwhich is a sequence of statements ai for i nfor somen.
statementa1transitions between states sands1if and only if a1.
the set of states that the sequence a1 a2can transition to from sis equal to the union of all states that a2can transition to from any state s1such that a1.
therefore 8s s02ds ds a1 a2 9s12ds a1 a2 .
if we extrapolate this reasoning to the whole block b 8s s02ds ds b 9s1 s2 sn 12ds ds a1 a2 an foreach loop statement aforeach loop statement fe is defined by two parameters the set of objects being iterated over denoted as and the block of code bthat will be executed for each member of .
letj j n. the order of iteration is non deterministic.
bhas access to the iterated object and therefore the set of possible executions of bis affected by the iterated variable.
effectively each iteration is a different state transition we use notation boto refer to a possible execution of an iteration executed for object o. in this case we refer to oas the trigger object .
the formula defining the fe loop is 8s s02ds ds fe 9o1 on2 9s1 sn2ds 8i j2 i6 j oi6 oj bo1 bo2 bon sn s0 in other words a pair of states is an execution of a given loop fe if and only if there exists a selection of objects from and a sequence of states such that the said selection of objects is a permutation of and the said sequence of states is achievable by triggering iterations in the order of the object permutation .
there exists a corner case where an object that is about to trigger an iteration gets deleted by a prior iteration.
we did not include this corner case as part of the definition as it introduces considerable complexity but the semantic is as follows such an iteration will still execute with an empty set iterator variable value.
this behavior is in concordance withour abstraction and the behavior of orm tools when objects are deleted before triggering iterations.
iv.
c oexecutability automated reasoning about loops is difficult since it is necessary to take into account many possible intermediate states that can appear during the loop execution.
a loop invariant can provide a compact characterization of the intermediate loop states and help with automated reasoning but loop invariant discovery is itself a difficult problem and loop invariants are typically specified manually.
the coexecution concept we introduce in this paper is a novel approach that enables us to reason about the loop behavior without loop invariants and reasoning about intermediate states.
below we formally define coexecution.
we also give a condition under which coexecution is equivalent to sequential execution and we call this property coexecutability.
note that multiple iterations of a loop correspond to repeated sequential execution of the loop body.
in order to simplify our presentation we will discuss how any two statements aandbcan be coexecuted which for example can represent the execution of the same loop body twice for different values of the iterator variable .
this discussion can be extended to coexecution of any number of statements and hence is directly applicable to loops by treating iterations of a loop as separate statements.
in this section for brevity and simplicity we will assume that the data store we reason about contains only one class called class and only one relation called relation that associates objects of type class with objects of type class with many to many cardinality.
this allows us to use minimal notation for data store states avoiding the need to explicitly provide type information.
for example the state fa b c ha bi ha cigcontains exactly three objects of type class as well as two tuples of the relation type that associate objectawith the other two.
as we discussed earlier given two statements aandb their sequential composition a bis defined by the sequential execution formula below 8s s02ds ds a b 9si a b a. execution deltas in order to define coexecution we first need to define a way to express the effects of executing statements.
let us define a structurehoc tc od tdifor that purpose ocandtcare sets of objects and tuples respectively that are created by a given execution and odandtdare sets of objects and tuples respectively that are deleted by a given execution.
let us call this structure the delta of an execution.
given an execution from state stos0 we denote the delta of this execution as s0 s. for example if given two states s1 fa b ha bigands2 fa b cg thens2 s1 hfcg fg fg fha bigiands1 s2 hfg fcg fha big fgi.
a delta is consistent if and only if its corresponding create and delete sets are mutually exclusive i.e.
oc od tc td 8t hoo oti2tc oo62od ot62od 8t hoo oti2td oo62oc ot62oc in order to combine the changes done by different executions we introduce the union of two deltas hoc1 tc1 od1 td1i hoc2 tc2 od2 td2i hoc1 oc2 tc1 tc2 od1 od2 td1 td2i we will use this operation to merge the changes done by independently executed statements.
note that the result of the union operation may not be a consistent delta even if all the arguments were individually consistent.
we call deltas conflicting if and only if their union is not consistent.
delta apply operation we will introduce the apply operation that takes a state sand a consistent delta and updates the state as dictated by the delta.
the result is a new state that contains all objects and tuples that existed in sand were not deleted by and all objects and tuples created by .
in addition whenever an object is deleted all the tuples referring to that object are deleted as well.
the apply operation maps a state and a consistent delta into a state and we use the operator to denote this operation.
formally given a state s and a consistent delta hoc tc od tdi 8s ho ti2ds s0 ho0 t0i2ds s0 s 8o o2o0 o2o o2oc o62od 8t hoo oti t2t0 t2t t2tc t62td oo2o0 ot2o0 for example given a state s fa b c ha bigand a delta hfcg fbg fha cig fgi s fa c ha cig.
notice how the creation of object cwas idempotent given that salready had that object and that deletion of object bimplied that all tuples related to bwere deleted as well.
we can observe that 8s s02ds ds s0 s s0 s .
this follows directly from the definition as s0 swill create all entities objects and tuples in s0that are not in sand delete all the entities that are part of sand nots0.
lemma given any two non conflicting deltas 1and 8s2ds s s this lemma follows directly from definitions of delta union and the apply operation.
for simplicity we will limit the proof to objects but the same proof can be extended to cover tuples.
given a state s ho ti non conflicting deltas hoc1 tc1 od1 td1iand hoc2 tc2 od2 td2i and poststatesss hos tsi s 2andsp hop tpi s we proceed to show that any object in ssmust be insp and that any object in spmust be inss.
8o2os o2o o62od1 o62od2 o2oc1 o62od2 o2oc2 8o2os o2o o62od1 o62od2 o2oc1 o2oc2 because these deltas are non conflicting o2oc1 o2 oc2 o62od1 o62od2 .
joining this implication with the previous formula 8o2os o2o o62od1 o62od2 o2oc1 o2oc2 o62od1 o62od2 8o2os o2o o2oc1 o2oc2 o62od1 o62od2 8o2os o2o o2oc1 oc2 o62od1 od2 8o2os o2op s sisi s s s sis sa s sb s sa sbs s sa s u sb s ufig.
.
sequential execution vs. coexecution the inverse implication also holds 8o2op o2o o2oc1 oc2 o62od1 od2 8o2op o2o o62od1 o62od2 o2oc1 o62od2 o2oc2 8o2op o2os a consequence of this property is that the delta apply operation is commutative for non conflicting deltas as delta union is trivially commutative .
b. coexecution coexecution of two statements aandb which we denote asajb means finding the deltas of independent executions of both statements starting from the pre state finding the union of those deltas and applying the union to the pre state.
this is visualized in figure similar to figure but applied to two generic states and any two statements aandb.
formally 8s s02ds ds ajb 9sa sb2ds ds a b s0 s sa s sb s notice that coexecution because of the delta apply operation is defined only if no two possible deltas from the pre state via statementsaandbare conflicting.
for example if statement aadds a new object to a state and statement bdeletes all tuples from a state executing these statements from the state s fa b ha bigindependently will yield the following states sa fa b c ha big s b fa bg therefore sa s hfcg fg fg fgi sb s hfg fg fg fha bigi sa s sb s hfcg fg fg fha bigi and the coexecution ajbwill result in the following state s sa s sb s fa b cg which is the same state to which sequential execution of a andbwould transition from s which means that aandb are coexecutable.
c. coexecutability condition not all statements are coexecutable since coexecution requires non conflicting deltas and even if their deltas are not conflicting the result of coexecution may not be equal to the result of sequential execution.
below we define a coexecutability condition such that given any two statements aandb ifaandbsatisfy the coexecutability condition then their sequential execution is always equivalent to their coexecution.
statement reads creates and deletes we model each statement as a set of potentially non deterministic state transitions.
this definition of statements is very general and widely applicable but makes it difficult to identify a statement s read set.
we need to have access to a statement s read set in order to reason about interdependencies of statements.
in the remainder of this subsection we define how to infer a statement s read create and delete sets from its transition set.
first we define what it means for a delta set to cover a given statement afrom a given set of states s fs1 s2 sng cover a s 8s2s s02ds a s0 s 8s2s a i.e.
a set of deltas covers a statement afrom a set of states sif and only if every state transition achievable from any state insviaais achievable from the same state via some delta in and any transition achievable from any s2svia any delta in is a transition of a. a delta cover precisely describes all possible executions of a statement from a set of states using a single set of deltas.
intuitively the existence of a delta cover shows that the given statement does not need to distinguish between the covered states in order to decide how to proceed with execution.
note that this does not mean that is the collection of all deltas achievable from states in sviaa.
we can demonstrate this by considering a delete all statement with s ds and containing a single delta that creates no entities and deletes all entities that exist in any state in ds.
in this particular case the delta in is different than any delta achievable from any finites2sviaa yet it is true that this coversafroms.
we can now define what it means for a statement atoread an entitye reads a e 9s2ds ds cover a fs feg snfegg this means that areadseif and only if there exists a pair of statess fegandsnfegthat cannot be covered by any for the statement a. this implies that a s actions are dependent one s existence in some way for example if it is deciding whether to delete or not delete some object other than ebased one s existence.
i.e.
if statement areads entity e then in order to describe the behavior of a we need to specifically refer toe.
based on this definition a delete all statement does not read any entity ebecause for any two states s fegand snfegfor any state s there exists a that covers it fhfg fg objects of s feg tuples of s feg ig.
hence using this definition we are able to infer that two delete all statements that are executed back to back are coexecutable although in sequential execution behavior of the second delete all statement changes it becomes a no op due to the presence of the first delete all statement.
we can also define what it means for a statement atocreate ordelete an entity similarly creates a e 9s s02ds a e62s e2s0 deletes a e 9s s02ds a e2s e62s0 recall that since we are abstracting away the basic types any update to the data store state consists of creation and deletion of entities i.e.
objects and associations .
coexecutability condition definition and proof we can now define the coexecutability condition and our main result theorem given two statements aandb if the following condition holds 8s2ds 8e2s reads a e creates b e deletes b e creates a e reads b e deletes b e deletes a e reads b e creates b e then coexecution of aandbis equivalent to their sequential execution i.e.
8s s02ds a b ajb .
in other words aandbarecoexecutable .
the proof of the above theorem is tedious due to the differences between objects and tuples and how they depend on one another e.g.
deleting an object deletes all associated tuples and creating a tuple that is associated with a nonexisting object is impossible etc.
.
in order to simplify the proof without loss of generality we will outline the proof by focusing only on the creation and deletion of objects.
first the condition in theorem implies that no statement can delete an object that can be created by the other.
therefore the deltas from any sviaaandbare not conflicting and coexecution is always defined.
let us take any two states sands0and assume that there exists a state sasuch that a. let us consider any object octhat is created by sa s. all objects created by sa sare not read by b. therefore there exists a delta cover that describes all transitions from s focgandsnfocgviab.
sincesa sis creatingocwe know thatoc62s so this delta cover describes all transitions fromsands focgviab.
let us inspect every member of such a delta set .
if any creates anything in sthen this operation is always redundant for states sands focg so we can remove this operation and still have a delta cover of boverfs s focgg.
we can similarly remove all deletions of all objects outside s focgas redundant operations.
since occannot be deleted by b we know that this trimmed delta cover does not delete anything outsides.
from the definition of a delta cover it follows that the resulting trimmed delta cover is in fact precisely the set of all deltas achievable from sviab.
similar reasoning can be followed for any object odthat is deleted bysa s. it follows that the set of deltas achievable fromsviabcoversboverfs snfodgg.
because the set of all deltas achievable from sviabcovers fs s focgg directly from the definition of delta covers with the prior assumption that an sas.t.
aexists 8s s02ds ds 9sa a b 9sb2ds b s0 sb focg let us generalize and say that sa screates objects ocifor some i ncand deletes objects odifor some i nd.
if we were to now enumerate all objects created and deleted bysa sone by one and apply the above reasoning to them the resulting formula would be 8s s02ds ds 9sa2ds a b 9sb2ds b s0 sb foc1 o cncgnfod1 o dndg category node children statementblock statement either block if formula block block objectsetstmt object set assign variable object set delete object set createtuple object set relation object set deletetuple object set relation object set foreach variable object set block object setvariable createobjectset class dereference object set relation allofclass class subset object set oneof object set union object set empty dereferencecreate object set relation fig.
.
abstract data store statement and object set nodes which is equivalent to 8s s02ds ds 9sa2ds a b 9sb2ds b s0 sb sa s becausesb s sb s and applying non conflicting deltas in sequence is equivalent to applying their union this formula is equivalent to 8s s02ds ds 9sa2ds a b 9sb2ds b s0 s sb s sa s we can move the saquantification and implication 9sa2 ds a to both sides of the inside equivalence 8s s02ds ds 9sa2ds a b 9sa sb2ds ds a b s0 s sb s sa s which is the formula for equivalence of sequential execution and coexecution.
v. s yntactic analysis in order to keep our verification process fully automatic we developed a syntactic check that determines for a given foreach loop whether we can coexecute the iterations while maintaining the loop semantics.
our syntactic analysis works on an intermediate abstract data store ads language and we automatically extract ads language specifications from rails applications using the techniques presented in .
the summary of all statements in our ads language is provided in figure .
the ads language includes constructs for creating and deleting objects createobjectset dereferencecreate delete updating associations createtuple deletetuple variables and assignments variable assign loops foreach conditional and non deterministic branches if either .
most statements use expressions in the form of object sets .
for example a delete statement takes an object set expression and will delete all objects inside this set.
we check the coexecutability condition on foreach statements.
the syntactic check is two fold we analyze if sequential execution is necessary to uphold variable dependencies and if iteration operations may overlap as defined in the coexecutability condition theorem .1program a n a l y s i s 2var d a t a a n a l y s i s d a t a 4f u n c t i o n analyze lo op foreach boolean d a t a .
c l e a r a l l d a t a a n a l y z e s t a t e m e n t loo p f o r type in d a t a s t o r e t y p e s o p e r a t i o n s d a t a .
operationsdoneon type i f o p e r a t i o n s .
hastwodifferentopswithoneglobal then r e t u r n f a l s e end end r e t u r n true end procedure a n a l y z e s t a t e m e n t s t m t s t a t e m e n t c as e type s t m t of block f o r substmt ins t m t .
s u b s t a t e m e n t s do a n a l y z e s t a t e m e n t substmt end d e l e t e objsettype o b j s e t l o c a l a n a l y z e o b j s e t s t m t .
o b j s e t d a t a .
markdelete objsettype o b j s e t l o c a l f o r r e l a t i o n ino b j s e t t y p e .
a s s o c i a t i o n s do d a t a .
markdelete r e l a t i o n f a l s e end o b j e c t s e t s t m t a n a l y z e o b j s e t s t m t .
o b j s e t assignment objsettype o b j s e t l o c a l a n a l y z e o b j s e t s t m t .
o b j s e t s t m t .
v a r i a b l e .
o b j s e t t y p e o b j s e t t y p e s t m t .
v a r i a b l e .
o b j s e t l o c a l o b j s e t l o c a l foreach objsettype o b j s e t l o c a l a n a l y z e o b j s e t s t m t .
o b j s e t d a t a .
markread objsettype o b j s e t l o c a l s t m t .
i t e r a t o r v a r i a b l e .
o b j s e t t y p e o b j s e t t y p e s t m t .
i t e r a t o r v a r i a b l e .
o b j s e t l o c a l o b j s e t l o c a l a n a l y z e s t a t e m e n t s t m t .
block d a t a .
.
.
end end f u n c t i o n a n a l y z e o b j s e t o b j s e t o b j e c t s e t type boolean c as e type o b j s e t of c r e a t e o b j s e t s e t d a t a .
markcreate o b j s e t .
c r e a t e d t y p e true r e t u r n o b j s e t .
c r e a t e d t y p e true v a r i a b l e r e t u r n o b j s e t .
objsettype o b j s e t .
o b j s e t l o c a l d e r e f e r e n c e o r i g i n t y p e o r i g i n l o c a l a n a l y z e o b j s e t o b j s e t .
o r i g i n o b j s e t d a t a .
markread o r i g i n t y p e o r i g i n l o c a l d a t a .
markread o b j s e t .
r e l a t i o n f a l s e r e t u r n o b j s e t .
t a r g e t t y p e false .
.
.
end end fig.
.
syntactic analysis pseudocode first to check if coexecution would invalidate variable dependences we convert the whole action to static single assignment ssa form.
if after converting to ssa and removing unnecessary assignments there exists a phi function assignment at the beginning of the loop s iteration body i.e.
an iteration reads a variable assigned to by a previous iteration or at the end of the loop i.e.
the iteration assigns to a variable that is read after the loop terminates then iterations must be modeled sequentially to preserve variable state.
if the variable dependency check passes we proceed to check whether the loop is coexecutable.
to achieve this we identify every data store class or relation that is touched by a read create or delete operation inside the iteration body.
for example if a delete statement deletes a set of objects of classc we mark that cas well as all c s subclasses havehad a delete operation executed.
in addition since all tuples of deleted objects are deleted as well we mark all relations of these classes and their supertypes as having had a delete operation executed.
we increase the precision of our analysis by identifying whether operations are executed on iteration local objects.
for example if an iteration were to create an object of class c and subsequently delete it then the coexecutability condition would not be violated since no object created by one iteration would be deleted by another but the above syntactic check would fail as cwould have had both a create and a delete operation executed.
in order to facilitate this we denote whether each read create or delete operation is done iteration locally or not.
for example createobjectset creates an object iterationlocally as every iteration will create a different object and these created sets will not overlap.
operations such as dereferencing from an object set return a global domain object set even if a local domain was dereferenced because even if each iteration dereferences from a different object domain the target object sets may overlap.
therefore in order for the syntactic check to pass there must not exist a domain of objects or tuples that has two of the operations read create delete executed where at least one of this operations is not done iteration locally.
the pseudocode for the operation domain analysis is provided in figure .
the analysisdata global variable called data line aggregates information about which domains of objects and tuples are operated on and in what way.
it is essentially a key value structure that maps every class and relation in the data store into a set of operation entries which are pairsho li whereo2 fcreate read delete gandl2 ftrue falseg.
this structure lists for each data store class and relation all the different create read and write operations executed on entities of that particular class or relation and if these operations were executed iteration locally true or not false .
this structure is populated by invoking methods markread markcreate and markdelete on it all of which take two arguments a data store class or relation type and a boolean denoting whether the operation is iteration local e.g.
line .
the analyze function is the entry point of our algorithm lines .
it first clears all information from the data object line then proceeds to gather information in the data object by invoking the analyzestatement on the given loop line .
it then iterates over all classes and relations lines and tests whether there exist two operation entries on the same class or relation such that they contain different fcreate read delete gtypes where at least one of them is executed on a global domain.
if such a pair of operation entries is found the coexecutability check fails and the function returns false line .
otherwise it returns true line .
the analyzestatement procedure takes a statement as an argument and its purpose is to populate the data object with information about which operations are executed on which domain by that statement.
for example a delete statement lines invokes the analyzeobjset method to acquiredomain information about the object set to be deleted line then marks this domain as deleted line .
since the delete statement also deletes all tuples of the deleted objects all relations around the object set s type are iterated over lines and are marked deleted globally line .
the tuples are always deleted on a global domain because even if the deletion is on a local domain these tuples may relate to some other iteration s local domain.
the assignment statement lines does not add any entry to the data object and instead stores the domain of the assigned object set in the variable.
these values will later be extracted when the variable is referred to in lines .
the analyzeobjset function lines is invoked with an object set argument and it returns the domain of the objects inside the object set in form of a htype booleanipair.
in addition object sets may populate the data object themselves.
for example the createobjectset object set lines creates a new object and returns a singleton set containing it.
for each such object set we mark that object s class with the create operation line in an iteration local domain because this object set will contain a different object for each iteration.
the dereference object set lines takes another object set referred to as the origin object set and a relation type.
it contains all the objects that can be reached from the origin object set via at least one tuple of the given relation type.
as such the origin object set is read in the domain supplied by it lines and the relation type is read on the global domain line .
finally the returned domain of this very dereference object set is equal to the target type of the relation and is always global line .
vi.
e xperiments we implemented the analysis and verification techniques presented in this paper in our data model verification tool which is available at in order to evaluate the effect of coexecution on the verification process we implemented two ways to model foreach loops as sequentially executed iterations and as coexecuted iterations .
we looked at the top most popular most starred rails applications hosted on github for real world examples of loops.
four of them do not use activerecord or a relational database.
two of them are not web applications per se but rather web application templates and one has an unorthodox architecture that was not compatible with the data model extraction component of our tool.
out of the remaining of them had no loops in their actions.
we found a total of loops in actions of the remaining applications in discourse in fatfreecrm in tracks in lobsters in sprintapp in redmine and in kandan .
our analysis determined that all these loops were coexecutable.
interestingly of the loops we extracted had empty loop bodies.
this is due to the fact that the abstract data store model we extract abstracts away the fields with basic types.
hence the loops that do not modify the state of the data store as far as the set of objects and associations areconcerned but might change the value of basic type fields of some objects result in empty loop bodies.
note that since the invariants we verify are on sets of objects and their associations the automated abstraction performed by our tool during abstract data store extraction in effect is demonstrating that these loops preserve all invariants.
however during our experiments we found out that the fol theorem prover would occasionally timeout even for loops with an empty body when the sequential semantics is used.
this demonstrates the inherent complexity of reasoning about the sequential loop model even without the complexity of reasoning about the statements in the loop body.
the remaining loops we extracted contain various program structures such as branches object and association creation and deletion as well as loop nesting.
we manually wrote application specific invariants for each application to be used in our experiments.
given an action and an invariant our verification tool generates a set of fol formulas that correspond to axioms and a formula that corresponds to a conjecture.
if the axioms imply the conjecture then this proves that the action preserves the invariant.
we used the spass tool as the fol theorem prover in our experiments.
spass takes the set of fol axioms and the conjecture generated by our tool and attempts to prove that the axioms imply the conjecture.
more precisely spass conjoins the negation of the conjecture with the axioms and starts deducing formulae from this set of axioms.
if a contradiction is ever reached the conjecture is deemed to hold.
if the entire space of deducible formulae is exhausted the conjecture is deemed to not imply from the axioms.
finally since fol is undecidable and the space of deducible formulae may be infinite deduction may never terminate.
we stop verification after minutes at which point we deem the result as inconclusive.
spass guides the formula space exploration using heuristics that can be fine tuned by the user.
we used two heuristics one with the sorts option on and the other with that option off.
the sorts option allows spass to make decisions based on soft sorts .
by turning the sorts option on and off and looking at the deduction logs of spass we noticed that the order of deduction spass takes changes significantly and furthermore in our previous work we found that often one of these heuristics terminates when the other one does not.
therefore running spass with the sorts option on and off gives us very different heuristics for comparison of coexecution and sequential execution.
normally when we encode an action invariant pair in fol the loop semantics are encoded in the axioms section with an invariant being the conjecture.
in order to isolate the effect of the axioms on the overall deduction process we also verified all actions using the conjecture false .
this conjecture often gives us the worst case performance for a set of axioms.
because spass attempts to deduce a contradiction from the axioms and negated conjecture it negates the conjecture to true and hence needs to explore the entire space of deducible formulae to reach a contradiction that does not exist.
if spass terminates with the false conjecture then we can reasonablyapplication kloc of model of avg loop classes loops body size discourse .
.
fatfreecrm .
.
tracks .
.
lobsters .
.
sprintapp .
.
redmine .
.
kandan .
a application statistics loop model heuristic of timeouts total avg time seconds sequentialsorts on .
.
sorts off .
.
coexecutionsorts on .
.
sorts off .
.
b verification statistics c number of action invariants per performance gain factor fig.
.
application and verification statistics expect that it will terminate with other invariants as long as they do not add significant complexity to the verified theorem.
we also included actions that we manually created to explore how the theorem prover handles coexecution vs sequential execution of nested loops and branches in iterations.
in total we had action conjecture pairs.
we translated each one of those to two fol theorems one using coexecution and the other using sequential execution to model loops.
we sent each one of these theorems to two instances of spass with different heuristic settings resulting in verification tasks.
all verification experiments were executed on a computer with an intel core i5 2400s processor and 32gb ram running 64bit linux.
memory consumption never exceeded 200mb.
we specifically looked at how coexecution fared as opposed to sequential execution.
with the sequential execution model out of verification tasks of them timed out .
.
with the coexecution model only tasks out of timed out .
.
the summary of our results can be seen on figure .
figure a summarizes information on the applications we used for evaluation.
figure b summarizes the number of timeouts and average verification time over loop interpretation sequential vs coexecution and heuristic.
figure c summarizes the performance effects of coexecution as opposed to sequential execution.
we had cases in which to compare coexecution and sequential execution under identical action invariants and theorem prover heuristics.
in cases columns labeled 10x and up coexecution improved verification times by at least an order of magnitude.
among them in cases the theorem prover reached a conclusive answer instantly using coexecution and could not deduce a conclusive answer at all with sequential execution column labeled 10000x .
coexecution yielded noimprovement in a total of tasks column 1x .
in these cases either both loop models resulted in a timeout or both methods produced results instantly.
in three cases coexecution produced worse results than the sequential model.
this is not surprising since as we mentioned above the proof search implementation of the theorem prover relies on several heuristics which influence its performance.
in total we found that coexecution reduced the timeout rate from to almost threefold made verification at least an order of magnitude faster of the time with of cases terminating quickly as opposed to not terminating at all.
we conclude that overall coexecution allows for significantly faster verification and significantly decreases the chance of verification never terminating.
vii.
r elated work the contributions of this paper are motivated by our previous work on data model verification .
in our previous work we presented an imperative language for web application data modeling called abstract data store language ads a method for automated extraction of this language from a given rails web application as well as the process of translating ads verification tasks to fol.
in contrast to our earlier work this paper focuses on effective verification of actions that contain loops which is one of the key difficulties in the fol based verification of data models.
using coexecution to model loops is applicable to program verification in general beyond the scope of our previous work.
verification of software using theorem provers has been explored before in projects such as boogie dafny and esc java .
these projects focus on languages such as c c and java and typically require user guidance in the form of explicit pre and post conditions explicit data structure constraints and loop invariants.
while loop invariants may be inferred for certain loops they are ultimately required to reason about the loops.
our method does not require loop invariants and uses static analysis to automatically optimize the loop translation to fol.
while low level languages such as c and java present different challenges then our high level language we believe that modeling loops via coexecution is applicable and would be beneficial for the verification of loops in low level languages as well.
the lack of support for precise reasoning about programming language constructs in theorem provers has been noticed and addressed before .
specifically discusses this problem with regard to ansi c basic types and operations bit vectors and structures pointers and pointer arithmetic.
they address this problem by devising a theorem prover that supports all these elementary operations.
these improvements do not improve on the basic problems with loop verification and the tools that use simplify still require loop invariants .
alloy is a formal language for specifying object oriented data models and their properties.
alloy analyzer is used to verify properties of alloy specifications.
alloy analyzer uses sat based bounded verification techniques as opposed to the fol based unbounded verification techniquewe use.
dynalloy is an extension of alloy that supports dynamic behavior by translating dynamic specifications onto alloy.
while they talk about actions in their work those actions do not correspond to actions in web applications.
instead they are more similar to statements in programming languages .
their work has focused on verification of data structures not behaviors in data models of web applications.
an interesting parallel can be drawn between coexecution of loop iterations and snapshot isolation in the domain of databases .
the coexecutability problem is similar to the problem of equivalence of serializability and snapshot isolation.
however we see no parallel between our delta union and the delta apply operations and snapshot isolation notions such as first committer wins transactions aborting or committing based on conflicts etc.
our purpose is verification viability not scalability or optimization of transactions.
there exists a long body of work focusing on operation commutativity with applications such as automatically parallelizing data structures and computation .
automatic loop parallelization has been researched for decades .
this prior research acknowledges loop dependencies as problematic for parallelization and the potential for performance increase if no such dependencies exist.
while we are also avoiding loop dependencies our purpose is not optimization or making execution scalable but making verification more feasible in practice.
coexecution is a theoretical concept that is not executable in actual hardware.
furthermore there exist parallelizable loops that are not coexecutable.
semantic properties of operations have been used for the purposes of simplifying verification .
this is similar to our approach at a high level.
however we do static analysis of a particular condition that allows us to use a completely alternate definition of a loop whereas iteratively abstracts and subsequently reduces the model in order to infer and enhance atomicity rules without altering the validity of the given invariants.
their problem domain of application goal and solution are fundamentally different.
viii.
c onclusion and future work in this paper we defined coexecution a technique for modeling loop iterations that bypasses the need to model interiteration dependence and the coexecutability condition which tests whether when given a loop coexecution of its iterations is equivalent to its sequential execution.
we developed a static program analysis technique that tests the coexecutability condition on a given loop.
finally we demonstrated that modeling loops using coexecution significantly improves verification viability and performance.
we believe that coexecutability can be useful in other contexts and we plan to investigate its application to other verification problems.
we also plan to continue and extend our work on automated verification of data stores.
for example basic data types are completely abstracted away in our data model specifications.
support for basic data types coupled with an automated abstraction mechanism could enable us to check a richer set of properties on data models in the future.