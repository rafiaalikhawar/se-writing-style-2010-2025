elixir effective object oriented program repair ripon k. saha yingjun lyu hiroaki yoshida mukul r. prasad fujitsu laboratories of america sunnyvale ca usa university of southern california los angeles ca usa rsaha us.fujitsu.com yingjunl usc.edu hyoshida us.fujitsu.com mukul us.fujitsu.com abstract this work is motivated by the pervasive use of method invocations in object oriented oo programs and indeed their prevalence in patches of oo program bugs.
we propose a generate and validate repair technique called e lixir designed to be able to generate such patches.
e lixir aggressively uses method calls on par with local variables fields or constants to construct more expressive repair expressions that go intosynthesizing patches.
the ensuing enlargement of the repair space on account of the wider use of method calls is effectively tackled by using a machine learnt model to rank concrete repairs.
the machine learnt model relies on four features derived from the program context i.e.
the code surrounding the potential repair location and the bug report.
we implement e lixir and evaluate it on two datasets the popular defects4j dataset anda new dataset bugs.jar created by us and against baselineversions of our technique and other techniques representing the state of the art in program repair.
our evaluation shows that e lixir is able to increase the number of correctly repaired bugs in defects4j by from to and by in bugs.jar from to while also significantly out performing other state ofthe art repair techniques including acs hd repair nopol par and jgenprog.
i. i ntroduction as software applications continue to grow in size and complexity and fuel the development of new application domains such as cloud computing big data analytics mobile computing and software defined networks they inevitably produce acorresponding increase in the number of software bugs and ultimately in the cost of fixing these bugs.
for example a studyfrom the university of cambridge showed that as of theglobal cost of debugging software had risen to billionannually .
further the research found that on average software developers spend of their programming time finding and fixing bugs.
automatic software repair techniqueshave the potential to mitigate some of these costs and therebyincrease developer productivity.
object oriented oo languages dominate the programming landscape today.
in fact of the top languages on thetiobe index namely java c c and python areobject oriented or bear at least some object oriented features.however most techniques for automatic program repair with a few notable exceptions have been developed in thecontext of c programs i.e.
procedural programs.
studies have shown that bug patterns can be language specific.
thus the second author was an intern at fujitsu labs of america ca usa during the construction of bugs.jar.there is a strong need to develop automatic repair techniques targeting object oriented programs.
one of the core principles of object oriented language design is the notion of encapsulation whereby the internal data representation of a class object and its implementationof operations is hidden from external users of the class.
exter nal objects can only access this data and operations throughthe public methods of the class object .
thus the construct ofa method invocation mi used inter changeably with the termmethod call in this paper on an object constitutes the basic unit of data access and computation in object oriented pro grams.
in fact according to an empirical study we conductedon three popular java projects discussed in section ii a as many as of program statements in each of these applications contain one or more method invocations.
further according to the same study ofone line bug fixes made during the lifetime of each of these projects involved a change to or insertion of a method invocation.
these data pointsdemonstrate the need to incorporate repair and synthesis ofmethod invocations in a comprehensive manner in the repairof bugs in object oriented programs.
for concreteness the restof the paper uses java as a representative of oo languages.however the discussion would be equally applicable to otheroo languages such as c .
a number of program repair techniques proposed for java programs like par nopol hd repair and acs in fact manipulate method invocations intheir repairs.
however this is done through very specificschemas and with tight restrictions.
for instance nopolis the only tool that synthesizes i.e.
creates from scratch method calls but only on manually specified side effect free parameter free method calls and only as guards of insertedif conditions.
par replaces names or parameters of methodcalls but only with other names or expressions appearing inother method calls in the same method.
a plausible reason for such restrictions documented in a recent work by martinezand monperrus is the combinatorial explosion that wouldresult from expanding the repair space to include a much widerscope of method call modifications and insertions.
figure 2shows a simple example of this using a bug fix from theapache commons lang project that is correctly patched by our proposed tool e lixir .
as shown the patch consists of a single method invocation.
however for constructing such amethod invocation that is correctly typed and in scope thereare more than concrete candidates!
obviously a repair approach cannot afford to iterate through each of them.
.
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research648 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
this work proposes a generate and validate repair technique called e lixir developed for the repair of objectoriented programs.
a key innovation in e lixir is the aggressive use of method calls on par with local variables fields and constants to construct more expressive repair expressions that go into synthesizing patches.
the ensuing enlargement ofthe repair space is effectively tackled by using a machinelearned model to rank concrete repairs.
the machine learned model relies on four features derived from the repair context i.e.
the code surrounding the potential repair location and from the bug report.
the features describe a given identifier which could represent a local variable or object a constant or a method call.
in particular the features quantify how frequently the identifier has been used in the current context the distance of the place of last use from the repairlocation whether similarly named tokens have beenused in the repair context and if the identifier or sub tokens thereof have been referenced in the bug report if oneis present .
variants of some of these features have been usedin heuristics employed in code recommendation bug localization and program repair .
however a key contribution of our work is the choice and specificincarnation of those features in the present context and theiruse in a machine learned model used to guide a program repairtechnique.
also novel is the insight that such a technique caneffectively navigate a huge repair space to fix bugs involvingmethod invocations in oo programs specifically java.
we implement and evaluate e lixir on two datasets the popular defects4j dataset and a new dataset bugs.jar createdby us and against two baseline versions of our technique as well as five other tools techniques representing the state of the art in program repair.
our evaluation shows that e lixir is able to increase the number of correctly repaired bugs in defects4jby85 from to and by for bugs.jar from to while also significantly out performing other state of the art repair techniques including acs hd repair nopol par and jgenprog .
this paper makesthe following key contributions empirical study an empirical study highlighting the prevalence of method invocations in patches of java programs as a motivation for our proposed technique.
technique a novel technique e lixir that aggressively employs method invocations in constructing repairs for java programs and object oriented programs in general.
implementation an implementation of e lixir in our in house java repair framework along with two baseline versions of e lixir .
dataset a new large dataset of bugs and patches bugs.jar made available to the research community at to complement existing datasets like defects4j.
evaluation a comprehensive evaluation of e lixir on two datasets defects4j and bugs.jar and against seven competing techniques including two baseline versionsof e lixir and five external tools techniques acs hdrepair nopol par and jgenprog.
fig.
.
distribution of bug fixing changes.
based on and one line bug fixes in eclipse jdt platform and birt projects respectively.
ii.
m otiv ation this section demonstrates the prevalence of method invocations mi and mi related bugs in java programs through an empirical study and two real world motivating examples.
a. an empirical study on the method invocation construct and its relevance to bugs in java programs the construct of method invocation mi is fundamental to orchestrating data access and computation in oo programs and indeed for enforcing key oo features such as encap sulation.
however it is natural to ask if real world oo programs e.g.
java applications demonstrate a quantitatively greater use of mis than procedure oriented programs e.g.
c .
to investigate this empirically we selected three java projects eclipse jdt platform and birt which are popularjava projects used in bug localization research and the manybugs benchmarks widely used in c program repairresearch representing c applications.
the java projects wereintentionally chosen to be distinct from our experimentaldatasets defects4j and bugs.jar to guard against learning bias.
we parsed all the source code files of both java and c applications excluding test cases and counted the fraction ofexecutable statements having an mi or a function call.
ourresults show that on average of statements in each ofthe java applications have an mi compared to only forthe c programs.
thus this study while decidedly limited in scope supports the hypothesis that java programs use mis substantially more than c programs.
we further analyzed all the one line bug fixes in each of the three java projects to investigate how often mis appear inthose patches.
we focus on one line bug fixes since currentautomatic program repair tools mainly target such fixes.
weused changedistiller to extract the one line bug fixesthroughout each project s history and automatically classifiedeach patch into one of a few mutually exclusive categories based on the type of that statement such as method invocation if condition variable declarations and initializations return statements and assignments etc.
figure plots this classification per project for the top categories.
the results show that of one line bug fixes the most dominant class arestand alone mi statements.
and this does not include indirectmi changes for example changing an mi in the guard of anif condition currently classified as an if condition change in figure .
manually investigating each of the non mi labeled bug fixes revealed that almost of if condition changes authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
bug report summary datef ormatutils.format does not correctly change calendar timezone in certain situations public stringbuffer format calendar calendar stringbuffer buf if mtimezoneforced calendar.gettime lang calendar calendar calendar.clone calendar.settimezone mtimezone return applyrules calendar buf fig.
.
the bug report summary top and fix bottom for lang bug report summary field not initialized in constructor org.apache.commons.lang.localeutils.cavailablelocaleset public static boolean isavailablelocale locale locale return cavailablelocaleset.contains locale return availablelocalelist .contains locale fig.
.
the bug report summary top and fix bottom for lang and at least of other changes variable initializations assignments and return expressions involved mis.
in aggregate of the studied one line bug fixes involved mi changes either stand alone or part of another construct.
these results demonstrate the need to incorporate mirelated modifications in a comprehensive manner in thesearch space examined by a repair tool.
the following examples illustrate the shortcomings of current tools in this respect.
b. motivating examples now we discuss two real world examples that are beyond the scope of current repair tools since they entail synthesis of substantially new mis typically rendered infeasible by a combinatorial explosion in the number of candidate patches.
figure presents a bug fix bug id lang i nt h e apache commons lang project taken from the popular defects4j dataset.
this patch requires the insertion of anew method invocation statement and is outside the repairspace of current repair tools since including such mis wouldincrease the repair search space significantly.
for example to fix this bug e lixir synthesizes valid mis for that location table i .
certainly validating such a large numberof candidates for a given repair location and a transformationschema in a brute force fashion is not practical.
the only waythe existing tools such as spr par or genprog could attempt this bug fix would be by copying and pastingthe same exact statement calendar.gettime from elsewhere in the code.
however this statement is not present elsewhere.
figure shows another bug lang also from commons lang in defects4j.
from an automatic repair point of view this is also a non trivial fix since the object of an mi is replaced by another mi that returns a compatible type list but not exactly the same type type set of object.
current repair tools do not include such complex mi transformations in their repairspace to keep the search manageable.
also the patch cannot be copied verbatim from elsewhere in the program either.
proposed approach our proposed technique e lixir can synthesize the correct patches for both the above bugs by first synthesizing a population of candidate patches and then ranking this candidate population and validatingtable i candidate patches for lang rank synthesized mis format calendar calendar.clear format calendar buf calendar.setlenient mtimezoneforced calendar.gettime other candidates only the top several candidates.
to synthesize the candidates e lixir first extracts atomic elements such as objects variables and literals in scope and then synthesizes validmi e.g.
obj.foo a b and field access e.g.
obj.a e x pressions.
these expressions constitute the building blocks termed repair expression for synthesizing patches and are then plugged into various program transformation schemas togenerate candidate patches.
to effectively deal with the large set of candidate patches resulting from a rich set of repair expressions e lixir ranks the candidates using a machine learned model and only se lects the top few for validation against the test suite.
themachine learned model is built on a set of four simple but potent features described in section iii c. for our motivatingexample bug lang when e lixir instantiates the miinsertion schema described in section iii b1 the correct patch is ranked at 7thout of candidate patches table i and hence can be quickly validated through the test suite.
iii.
e lixir the overall structure of e lixir is presented in figure .
for a given bug e lixir takes as input a buggy program a test suite having at least one bug reproducing test case andoptionally a bug report and produces a patch that passes allthe test cases i.e.
fixes the bug.
e lixir works in four steps.
a bug localization.
this step identifies a list of suspicious statements in the buggy program.
then for each potentialbuggy statement repair location e lixir performs the following steps until a plausible patch1is found.
b generating candidate patches.
elixir includes a set of program transformation schemas described in sec tion iii b1.
for each schema e lixir generates a list of candidate patches by plugging in various repair expressions into the schema and performs the followingsteps until a plausible patch is found.
c ranking and selection of candidate patches.
e lixir uses a machine learned model to rank the candidatepatches and selects the top npatches for validation.
d validating selected candidate patches.
e lixir applies the selected patches one at a time beginning from the topof the ranked list on the buggy program and runs thetest cases.
if all the test cases pass e lixir terminates and returns that patch as a plausible patch.
1a plausible patch is one that simply passes all test cases including failing tests in the test suite but may still be incorrect because the test suite may provide an incomplete specification.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
overview of e lixir .
a. bug localization elixir uses the ochiai technique a popular existing spectrum based bug localization approach to identify potential buggy statements.
according to the ochiai technique e lixir instruments the program at statement level and collects testspectrum i.e.
the statements executed by each test case and computes a suspiciousness score for each statement.
finally all statements are ranked in a descending order of supicious ness score i.e.
the top statement is the most suspicious.
b. generation of candidate patches fixing a bug involves applying appropriate changes at the buggy location.
allowing arbitrarily complex transforma tions can results in an infinite number of candidate patches.therefore program repair tools typically define their repairspace through a fixed set of parameterized program transfor mation schemas paired with a restricted set of expressionsto instantiate those schemas.
we term these expressions asrepair expressions.
for example the schema insertion of a method invocation instantiated with the mi repair expression calendar.gettime yields the patch in figure .
program transformation schemas elixir applies the following program transformation schemas in the presentedorder to produce candidate patches for a given statement.
t1 widening type for a variable declaration statement this schema replaces the type of the variable with a widened type e.g.
float todouble .
t2 changing expression in return statement this schema replaces a returned expression by another expression having compatible types.
t3 checking null pointer if a statement has an object reference this schema adds an if guard that ensures no null object is accessed.
t4 checking array range and collection size if a statement has array