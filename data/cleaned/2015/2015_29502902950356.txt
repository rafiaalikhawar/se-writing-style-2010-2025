multi representational security analysis eunsuk kang eecs uc berkeley berkeley ca usa eunsuk.kang berkeley.edualeksandar milicevic tse microsoft redmond wa usa almili microsoft.comdaniel jackson csail mit cambridge ma usa dnj mit.edu abstract security attacks often exploit aws that are not anticipated in an abstract design but are introduced inadvertently when high level interactions in the design are mapped to low level behaviors in the supporting platform.
this paper proposes a multi representational approach to security analysis where models capturing distinct but possibly overlapping views of a system are automatically composed in order to enable an end to end analysis.
this approach allows the designer to incrementally explore the impact of design decisions on security and discover attacks that span multiple layers of the system.
this paper describes poirot a prototype implementation of the approach and reports on our experience on applying poirot to detect previously unknown security aws in publicly deployed systems.
ccs concepts software and its engineering !formal software veri cation keywords security representation modeling veri cation composition.
.
introduction abstraction is a key ingredient of any successful formal analysis.
most systems are too complex to be fully described at once and so a typical model focuses on a particular aspect of a system at one abstraction layer and omits details that are deemed irrelevant for the analysis at hand.
for example when reasoning about the business work ow of an online store the designer may ignore or defer lower level design decisions such as the choice of underlying communication protocols web frameworks and data structures used.
however in certain domains especially those where security is a paramount concern abstraction can be a doubleedged sword.
a key observation noted since the early days this work was done when the authors were at mit.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse seattle wa usa c acm.
isbn .
.
.
.
poirotview modelspar al mappingpropertyelaboratedmodelviola onfigure overview of poirot.
of security research is that many security attacks arise due to discrepancies between the designer s conceptual view of the system and that of an attacker .
while the designer tends to work with one abstraction at a time the attacker is not bound by such restrictions and may exploit weaknesses across multiple layers of the system.
for example a malicious user of the online store may chain together an attack that exploits a weakness in a standard browser s handling of cookies with a lower level network attack that intercepts packets between two machines.
in this paper we propose a new methodology called multirepresentational security analysis .
our approach allows a designer to perform a security analysis to nd attacks that involve the behavior of the system across multiple abstraction layers.
the analysis can be carried out incrementally starting with an abstract model that represents an initial design of the system the designer can elaborate a part of the model with a choice of representation transforming the model into a more detailed one.
a key element of our approach is a mechanism for systematically composing independent models of a system in order to enable an end to end analysis.
however these models may not be readily amenable to composition due to abstraction mismatch a pair of models may describe a common aspect of the system at di erent layers of abstraction using distinct sets of vocabulary terms.
to resolve this mismatch we allow the designer to specify how various parts of the models are related through their representations .
if some of these relationships are unknown as often is the case during early design stages the designer may leave them unspeci ed.
our mechanism then automatically generates candidate mappings that may leave the resulting system vulnerable to attacks allowing the designer to explore security implications of alternative design decisions.
to demonstrate the feasibility of our approach we have built a prototype tool called poirot .
as shown in figure the tool takes three inputs from the designer a desired security property a set of models that describe di erent views of a system and a potentially partial mapping that relates parts of those models.
poirot then produces an elabopermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
rated model that captures the end to end behavior of the system across those views and a scenario if it exists that demonstrates how the resulting system may violate the given security property.
we have applied poirot to two publicly deployed systems ifttt a system for composing web services and handme.in an online system for tracking personal properties.
we identi ed several security aws in the designs of these systems some of which could be used to carry out previously unknown attacks.
the contributions of this paper are amulti representational approach to security analysis outlined in section in which composition expands the range of behaviors to allow for new security violations that lower level design decisions might introduce a formal speci cation framework that allows distinct views of a system to be modeled and composed using a representation mapping section an analysis technique for automatically generating a mapping that leads to a violation of a property section an experience report on applying poirot our prototype tool section to two case studies section .
.
motiv ating example consider the task of designing an online store.
a typical store o ers a variety of services but we will focus on two basic functions logging in and adding an item to a shopping cart.
a desirable property of the store is the shopping cart integrity that is every item in a customer s cart must be one of the items that were intentionally added by the customer.
initial design and analysis figure a shows a high level model of the store system consisting of three different processes store which provide login and addservices and alice and eve customers who interact with the store by invoking these two services.
login accepts a user id and a password and returns a token that can be used in subsequent interaction with the store.
addtakes an item id and a token and adds the item to the shopping cart of the customer that is identi ed by the token.
in addition we will assume that eve is a malicious person and will deliberately attempt to violate the integrity property by causing the store to add an item of her choice to alice s cart.
each process is associated with a speci cation that describes its behavior for example the speci cation on store may state that it only accepts addrequests that contain a valid token.
the designer wishes to perform an analysis on this initial model to check whether the system satis es the integrity property.
let us rst consider a conventional analysis in which security violations are found by exploring all possible behaviors of the processes including the malicious one.
running an analysis tool such as a model checker might reveal counterexamples to this property ex1 eveinvokes the login service with a victim customer s i.e.
alice user id and password and receives a token that identi es alice .evethen invokes addwith this token and an item id of her choosing successfully causing the store to add that item to alice s cart.
ex2 eveinvokes login with her own id and password and receives a token that matches alice s token.
eveuses this token to add an item of her choice to alice s cart.
alicestorebrowserserverreq method 5url 5set header ... add itemid 5token alice5 browserstore5 server add req eve5 server5 browser req evestore5 5serveralice5 5browsereve5 ?add5 5reqlogin5 5req a ini al store model b http model c a mapping specified between a and b and their composi onlogin uid pwd token login req figure graphical depictions of system models.
a rectangle represents a process grey ones are considered malicious.
a circle represents the participation of a certain type of events by two processes e.g.
in a alice and store engage in login events.
pkq corresponds to the composition of pand q. some events may be associated with multiple representations e.g.
in c flogin reqg means that every login is realized as an http request.
the designer examines the counterexamples and derives additional constraints on the behaviors of the individual processes that would prevent those attacks c1 evedoes not initially have access to the password of another customer prevents ex1 .
c2 the store returns a unique token to each customer in response to login prevents ex2 .
re running the analysis with these constraints no longer returns any counterexample suggesting that the store design ensures the shopping cart integrity.
the constraints represent component speci cations on store and environmental assumptions eve that together establish the property.
note that the level of abstraction in figure a is suitable for reasoning about the essential functionality of the system it omits details that are irrelevant to the business work ow such as what devices store will be deployed on how login and addoperations are implemented or the type of data structure used to represent tokens and item ids.
however as we will see it may be exactly these details that are exploited by the attacker to undermine the store s integrity.
design elaboration being satis ed with the initial design of the store the designer wishes to explore di erent implementation choices and analyze their impact on the security of the system.
in particular she decides that store is to be deployed on a standard http server with login and addimplemented as http requests.
figure b shows an application independent model that describes interactions between a generic http server and a browser including details about http requests and responses.
the designer would like to reuse the domain knowledge captured in this http model by integrating it with the application speci c store model in figure a .
however these two models in their current form are not readily amenable to composition due to abstraction mismatch they describe the system at di erent levels of abstraction using two distinct sets of vocabulary terms.
the designer s task is then to determine how various parts of the abstract store design are to be realized in terms of 182reqaddurlitemiditokentoriginmystore.compathadditemset query ?method?url?set header ?body?response?figure the structures of the addoperation an http request and a url.
the leftmost column in each structure contains the types of parameters.
dotted edges represent di erent choices for encoding the token t inside a request ?
represents an unknown value for the parameter.
their counterparts in the http model.
for example as shown in figure the addoperation has a very di erent structure from an http request which itself consists of complex data types with their own structures such as urls.
thus realizing addas an http request involves a series of decisions such as which http method should be used for this operation?
which url should be allocated?
how should the parameters of add the item id and token be transmitted inside an http request?
some of these decisions may be xed as design constraints e.g.
the hostname for the store site while the rest may be open for the designer to explore.
for instance she may choose to transmit the store token as a browser cookie or encode it as a query parameter inside the url.
but each of these decisions also carries security implications.
once represented as a cookie the token may be subject to cookierelated vulnerabilities on the web.
on the other hand when carried inside a url the token may be exposed to throughout parts of the browser that operate on the url.
exploring design alternatives is a challenging task that requires systematic tool support.
the space of possible design decisions may be large prohibiting any kind of manual exploration and some of those decisions may be irrelevant to the security property being analyzed.
the key idea behind our methodology is to allow the developer to specify a relationship between a pair of abstract and concrete entities by using a representation mapping and express uncertainty over design decisions by leaving some part of the mapping as unspeci ed.
given a partial mapping speci cation our analysis automatically explores the space of candidate mappings and selects ones that lead to a violation of a given security property such a mapping if exist corresponds to a set of insecure design decisions that may leave the resulting system vulnerable to attacks undermining a property that has previously been established.
analysis with partial mapping suppose that the designer provides a mapping indicating that the addoperation is to be realized as a get request with a xed domain and path but does not specify how the item or token parameters associated with addshould be transmitted as part of the request similarly for login .
intuitively this partial speci cation yields a space of possible mappings including ones where the token is encodedinside a header the request body or a query parameter in url as shown in figure .
given the store and http models and the mapping speci cation our analysis engine automatically searches for an insecure mapping if it exists and uses it to construct an elaborated model that describes the deployment of the store onto an http server as shown in figure c .
in this nal system the item parameter of addis encoded as a query parameter inside the url and the token is encoded as a cookie header in the request.
in addition evecan now act as both abrowser interacting with other servers by sending potentially malicious requests and as a server providing its own web pages that may be visited by alice on her browser.
along with the elaborated model the analyzer also produces newcounterexamples to the integrity property absent from the initial design but introduced by insecure design decisions in the generated mapping ex3 alice visits a fake login page set up by eve through req and is tricked into sending her password to eve who then uses this information to log onto the store and add an item of her choosing to alice s cart.
this counterexample corresponds to a type of phishing attack.
ex4 alice visits eve s malicious page which when loaded by alice s browser triggers an additional request to be sent to a url of eve s choosing.
in particular the attacker causes alice s browser to send an addhttp request that contains alice s token as a cookie and thus is accepted by the store as valid.
this counterexample corresponds to a cross site request forgery csrf .
at this point the developer may directly modify the model to rule out these attacks for example she may add an assumption that alice does not give out her password to an untrusted site or require that every addrequest to carry a special csrf token as an additional proof of authentication.
if these modi cations are undesirable she may ask the analyzer to generate an alternative mapping where the token is mapped to a di erent part of an http request which in turn may enable di erent types of attacks .
the steps may be repeated until the analyzer no longer detects a counterexample implying that the current mapping captures a set of design decisions that preserve the security property in the nal deployed system.
.
system modeling in this section we introduce the underlying formalism for constructing models of systems.
we describe a simple process algebra in the style of hoare s csp where the behavior of a system is de ned as a set of event traces performed by concurrent processes.
we then propose an extension to this framework where certain parts of a system may be assigned multiple representations to enable a new kind of composition where models speci ed using distinct alphabets are brought together through a representation mapping .
.
basic framework as the underlying formalism we adapt the trace based semantics of csp .
compared to state based formalisms process algebras emphasize communication between di erent parts of a system and have been successfully used for security modeling and veri cation .
183a system consists of a set of processes that interact with each other by together performing various types of events .
letpbe a set of processes ea set of events and ta set oftraces each of which is a nite sequence of events.
each process pis associated with an alphabet denoted p e which describes the set of events that it may engage in.
we say that t2tis a trace of process piftdescribes one possible history of events that pperforms up to some moment in time.
then the overall behavior of pcan be de ned as the set of all traces that pmay perform and is denoted as beh p t. a pair of processes pandq can be combined into a more complex process that embodies their interaction using the parallel composition operator pkq .
the composition rule states that that both pand qmust synchronize on events that are common to their alphabets beh pkq ft2tjt2 p q t p 2beh p t q 2beh q g where t x is the projection of tonto the event set x. example.
letstore2pbe a process that behaves like an online store o ering two types of services store login add fhi hloginalice add choci hloginalice add toff add chocig beh store here login eis the set of events that describe some user logging onto the store loginaliceis a particular event that corresponds to the login action of the user named alice .
three possible traces of store are shown above an empty trace one that begins with alice logging in and adding a chocolate choc to her cart and another one where a to ee toff is added before a chocolate.
we are interested in understanding not just how the store behaves on its own but also how it interacts with customers.
let us introduce a process named alice who communicates to the store by invoking the latter s services alice login add hloginalice add choci2beh alice consider the above trace that describes alice logging onto the store and adding a chocolate to her cart.
since both the store and alice are able to synchronize on these events this trace is also a valid behavior of their composition i.e.
hloginalice add choci2beh alicekstore but suppose that alice does not like to ees and so she would never add such an item to her cart on her initiation thus event add toffdoes not appear in any trace of alice .
then the following is not a trace of the composition hloginalice add toff add choci 2beh alicekstore even though it is allowed by store since the two processes cannot synchronize on the second event.
.
multi representation extension suppose that our designer wishes to reason about the behavior of the online store when it is deployed as an httpserver.
she is given a process named server developed independently by a domain expert which describes the behavior of a generic web server that is ready to accept any arbitrary http requests server req ideally she should be able to reuse the knowledge captured inserver by integrating it with the store process.
the resulting process named storeserver would describe a specialized web server that o ers the services of an online store.
butstore andserver engage in two distinct sets of events and so applying the parallel composition operator would simply result in a system where the two behave completely independent of each other.
a new composition mechanism is needed in order to allow processes from di erent views of a system to interact with each other.
in the next section we propose a simple extension to the trace based semantics introduced earlier to achieve this composition.
.
.
events as sets of labels a key idea behind our extension is to allow each event to be associated with multiple representations by establishing alabel of an event as a separate notion from the event itself.
let lbe a set of event labels .
then an event is now de ned to be a set of labels e 2l where each label corresponds to one possible description or representation of the event.
similarly the alphabet of a process p is redened to be the set of labels that may appear in any one of p s events p l .
example.
recall the store process from our running example which can now be reformulated as follows store login add hfloginaliceg fadd chocgi2 beh store note that every event in the above trace contains one label this corresponds to the basic case where each event has exactly one representation as in csp.
more complex cases arise when two or more representations possibly originating from independent models of a system are associated with the same event in the world.
recall the structure of an http request event req m u hds b resp where mis the http method uthe url of the request hdsa set of headers bthe request body and resp its response.
to deploy the store as a web server the designer may allocate a certain set of urls for the store operations.
for instance the following url may be designated for the operation of adding a chocolate url choc url originstore pathadd fquery item choc g where originstore and pathaddare particular origin and path values query is a function that constructs a query parameter given some name value pair and urlis a function that constructs a url from an origin a path and a set of query parameters.
then the http request corresponding to this operation can be described as reqchoc req get url choc fcookie token jax2ce g where the token capturing alice s identity value jax2ce is encoded as a cookie header the body and response of 184the request are irrelevant to our discussion and denoted by the placeholder variable .
then in the process storeserver an event that results in a chocolate being added to alice s cart contains two distinct representations e fadd choc reqchocg intuitively this event can be regarded as an abstract add action or as an http request depending on the process that engages in the event.
.
.
composition with a representation mapping let us propose a new composition operator pk mq which introduces a relationship between events with distinct labels as speci ed in the representation mapping m and allows pand qto interact through those events.
a representation mapping is a relation of type l l where a b 2m means that every aevent should also be considered as a b. more precisely this operator requires that whenever porq performs a the other process synchronizes by performing b at the same moment in the composed process the synchronized event appears as the union of the two original events from pand q. this new operator is de ned similarly to the standard parallel composition k beh pk mq ft2tj t p 2beh p t q 2beh q 8e2events t a2e b2l a b 2m b2eg where the constraint on the second line ensures that every event containing aas a label is assigned bas an additional label in the composite process1.
example.
to express the relationship between store and server the following entries may be added in a mapping m f add choc reqchoc loginalice reqalice g where reqchocand reqalice are http encodings of the add chocand loginalice operations respectively.
using this mapping we can construct a process that behaves like the deployment of the store as a http server storeserver storek mserver instoreserver every event containing add chocis accompanied by reqchocas an additional label signifying that the abstract addoperation is implemented as a concrete http request and similarly for loginalice .
for instance consider the following traces from store and server hfloginaliceg fadd chocgi2 beh store hfreqaliceg freqxg freqchocgi2 beh server where reqxis an http request that remains unused for 1the projection a x is now de ned to operate on sets of labels by removing labels from athat do not appear in x.store operations.
during the composition step these two traces are combined into the following trace hfloginalice reqaliceg freqxg fadd choc reqchocgi 2beh storeserver note that the event containing reqxdoes not require synchronization between the two original processes since it is not mapped to any other label in m. .
.
behavioral implications the multi faceted nature of events in our approach enables a modular open extension of a process alphabet.
given some process pthat interacts with qthrough events labeled from set x l pcan be extended to interact with another process r possibly through the same events by assigning additional labels to them from a di erent set y l this extension does not require any modi cation to the existing interaction between pand q. for instance when store is elaborated into storeserver customers e.g.
alice and eve can continue to make use of the store services without being aware of their underlying details as http requests.
similarly the browser will continue to treat each event in storeserver as an http request served at some designated url without necessarily knowing that it implements a particular piece of store functionality.
this type of composition may also introduce new interactions among processes in the world.
when an event in process pgains an additional label during composition it may now be engaged by processes that previously were not able to interact with p. from the security standpoint some of these interactions may be undesirable allowing a malicious actor to undermine an existing property of the system.
for instance let browser be a process that depicts the behavior of a generic browser connected to the web capable of engaging in arbitrary http requests including add toff browser req hfreqtoffgi2 beh browser recall that in section .
we introduced alice as a process that never engages in an add toffevent.
alice and browser do not share any labels in their alphabets and thus cannot in uence each other s behavior.
suppose that during the composition of store andserver add toffis mapped to its http counterpart reqtoff inside the representation mapping.
consequently every event in storeserver that involves adding a to ee to alice s cart contains two labels i.e.
e fadd toff reqtoffg.
since reqtoff is a label that appears in browser storeserver and browser may engage in etogether in other words browser is able to get the store to add a to ee to alice s cart indirectly by exploiting the fact that add toffis implemented as an http request.
.
analysis .
declarative mapping specification in our approach a representation mapping can be specieddeclaratively in the following style s fa b2ljc a b g where cis a constraint that describes a relationship between 185the parameters of aand b we will call this set comprehension samapping speci cation .
a candidate mapping m satis es a speci cation sifcevaluates to true over every tuple in m i.e.
msatis es sif and only if m s. a key feature of this declarative approach is the partiality of a speci cation that is the constraint in smay leave unspeci ed how certain parameters of labels are related to each other.
example.
consider the following speci cation of a mapping between labels of type addand req sm fadd t i req m u hds body resp 2lj m get u url originstore pathadd fquery item i g g this speci cation stipulates that the item id i from the addoperation is to be encoded as a query parameter inside the url but does not say anything about how the token t is encoded or what should be contained inside the headers body or response of the request.
conceptually this speci cation describes the relationships between add andreqin figure the parameters that are not explicitly constrained in scorrespond to unknown design decisions and may take on any values from their respective types.
.
property guided search a partial speci cation of a mapping yields a space of candidate mappings.
among these candidates ones that are of particular importance from the analysis perspective are those that may admit unsafe traces in the resulting system.
intuitively these mappings encode insecure design decisions in that they may introduce new behavior into the system that can potentially be exploited for an attack.
given a mapping speci cation s a single analysis can be used to not only nd a counterexample trace that violates a given property but also generate a mapping that permits such a trace to be a valid behavior of the composed system.
letp1 p2 pnbe the set of nprocesses in the system and s1 s2 sn 1be the set of user speci ed mapping speci cations where skspeci es the relationship between processes pkand pk .
then the mapping generation problem can be stated as nding witnesses to the following existential formula n i 1mi l l n j 1mi sj 9sys2p sys compose fp1 png fm1 mn 1g 9t2beh sys prop t where compose x m returns a process that results from the pairwise composition of the processes in xusing the set of mappings in m compose fp1 png fm1 mn 1g p1k m1p2 k m2 k mn 1pn informally this problem involves generating a set of mappings that satisfy the user speci ed speci cations s1 sj and when used in the composition of given processes allow the resulting system sys to produce a trace that leads to the violation of a given property prop .
reqimp reqtrig addtoff 0reqimp addtoff loginalice reqcookie loginalice 0reqcookie x reqtrig b 0http0view a 0store0view c 0composi?on0figure sample traces from the store example.
an event highlighted red is one that results in a violation of a property.
an x mark on an edge between events e1and e2means e2 cannot occur following e1 rendering the entire trace invalid.
.
example let us apply sfrom section .
to partially specify a mapping mbetween store and server .
in addition to model a customer who interacts with the store through a browser we will use the same mapping to construct a process where alice s events are represented as http requests storeserver storek mserver alicebrowser alicek mbrowser to model the behavior of an attacker we will allow eve to act both as a browser interacting with other servers by sending malicious requests and as a server providing its own pages that may be visited by alice on her browser attacker evek m0 serverkbrowser we want to perform a security analysis against an attacker that behaves non deterministically in the worst possible manner and so we will specify a mapping that does not constrain how evemay make use of server and browser s0 fa b2ljtrueg essentially s0allows the analysis to explore all possible ways of mapping eve s events onto those of browser orserver .
finally we can construct the overall system where the attacker interacts with the store and alice as an attempt to undermine the security of the system storesys storeserverkalicebrowserkattacker given these processes the speci cations sand s0 and the cart integrity property the analysis engine will attempt to generate mand m0such that when used for composition the resulting process storesys allows at least one trace that violates the property.
analysis figure shows traces from three di erent views a the initial store design alicekstore b the generic server browser architecture serverkbrowser and c the deployed store system storesys .
as discussed earlier in section .
trace a is not a valid trace of alicekstore since alice would never perform add toff.
consider trace b which describes the following generic http requests in sequence reqcookie o c a request that returns a value cand stores it as a cookie at the origin oof the request url reqtrig u a request that returns an html document containing an imgtag with a url uin its srcattribute reqimp u cs a request made to a url u implicitly generated by the browser after it receives an html doc186ument containing an imgtag.
also all cookies cs associated with the origin of uare automatically included in the request headers standard browser behavior .
our analysis generates a mapping that relates event labels from the store and http models including ones in figure m f loginalice reqcookie originstore loginalice t add toff reqimp url toff fadd toff tg g where l tis the token parameter associated with event label l and url toffis a url that has the following structure url originstore pathadd fquery item toff g the generated mapping indicates that the token given to alice after the log in is stored as a cookie in her browser which then includes the same cookie in subsequent addrequests to the store server.
along with this mapping the analysis also generates a counterexample trace to demonstrate how the resulting system storesys violates the integrity of the shopping cart trace c in figure .
in this sequence alice rst logs onto the store on her browser and then visits a malicious site set up by eve s server through reqtrig.
this request is speci cally crafted by eve to trigger alice s browser to generate a request at the url url toff that corresponds to the add toff event.
since this triggered request reqimp includes alice s token as a cookie it is deemed by the store as coming from alice causing in the unwanted item to be added to her cart.
.
implementation we have implemented a prototype of our approach in a tool called poirot.
the user interacts with the tool by specifying models in poirot s input language and running the analysis which in turn leverages a constraint solver for generating mappings and counterexamples.
in this section we brie y describe notable aspects of poirot more details about the tool can be found in .
modeling language poirot provides an input language for specifying a system model security properties and representation mappings it is embedded as a domain speci c language in ruby.
notable features of the language includes a module system for encapsulating domain models declarative constraints for de ning guards and mappings and additional language constructs for de ning component states.
analysis engine a poirot model is translated into alloy a modeling language based a rst order relational logic.
its backend tool the alloy analyzer uses an o theshelf sat solver to generate sample instances or check properties of a given model.
the analysis in alloy is exhaustive but bounded up to a user speci ed scope on the size of the domains in the context of poirot these bounds correspond to the number of processes data values and events as well as the length of event traces that will be analyzed.
domain model library poirot contains an extensible library of domain models that can be used to elaborate the user s input system model.
domain models encode di erent types of knowledge including descriptions of protocols architecture styles features and security threats.
for our case studies we populated the library with a number of domain models that describe di erent layers of a web system based on well known security sources such as owasp and capec the models can be categorized as http related http protocol browser scripting sameorigin policy sop cross origin resource sharing cors network related network packets routing dns authentication mechanisms symmetric and public key encryption oauth.
the models are approximately loc in total and took around man months to build most of the e ort was spent on gathering the domain knowledge and ensuring the delity and generality of the models.
note that poirot is not tied to a particular domain and can be used to model other types of systems as long as they can be captured in our formalism.
.
case studies we describe our experience on applying poirot to analyze two publicly deployed systems ifttt and handme.in.
our goal was to answer whether poirot can be used to nd attacks that exploit the details of the system across multiple abstraction layers and its analysis scales to nding realistic attacks.
.
methodology each case study involved the following steps constructing a model of the system in poirot performing an analysis to generate potential attack scenarios and conrming that the scenarios are feasible on the actual system.
in each study we constructed and analyzed the system model in an incremental fashion beginning with an abstract design of the system and mapping it to relevant domain models from poirot s library.
some domain models were employed in both systems e.g.
http protocol browser scripting but others were not e.g oauth was relevant only for ifttt .
the complete models for the case studies and the tool are available at .
each counterexample trace generated by poirot describes a possible attack on at the modeling level .
to con rm whether such an attack is feasible in reality we constructed concrete http requests that correspond to the events and replayed them from our browser using the tamperdata tool .
in total poirot generated counterexamples for ifttt and for handme.in out of these were con rmed to be feasible attacks for each .
the rest were false positives either due to inaccuracies in our models or generated mappings that do not re ect the actual design of the system.
most of these were caused by our initial misunderstanding of the system behavior had we ourselves been the developers of the systems we believe that the false positive rate would have been lower.
.
ifttt ifttt is a system that allows a user to connect tasks from di erent web services using simple conditional statements.
the basic concept in ifttt is a channel a service that exports a number of functions through its api.
ifttt allows a user to make a recipe which consists of a trigger and anaction .
once the recipe is created each time a trigger is performed ifttt automatically executes the corresponding action.
for example one recipe may say that whenever the user is tagged in a facebook photo a post containing the photo should be created on the user s blogger account.
since ifttt performs tasks automatically on the user s behalf possibly accessing her private data the user must approve gettoken doac1oneve authen1cate b oauth a ifttt c http d composi9on ac1vateeve x mkrecipe dotriggeralice reqimp logineve authen1cate mkrecipe approve ac1vateeve gettoken doac1oneve dotriggeralice reqtrig reqimp loginalice reqtrig figure sample traces from ifttt models.
give ifttt a permission to access her accounts on the selected channels for this purpose ifttt employs a thirdparty authorization protocol called oauth .
for example before the recipe can take e ect the user must approve ifttt to access her photos on facebook and create new blog posts on her blogger account.
when ifttt is given a permission to access an account on a channel we say that the channel has been activated for that account.
the goal of this case study was to use poirot to check whether ifttt channels could be connected in an insecure way allowing a malicious person to access information that would not have been possible without ifttt.
in particular we analyzed the following security property a user s private data on a channel should only be accessible from the same user s accounts on other channels.
for our study we constructed a model of the ifttt workow around loc in poirot and composed it against a model of oauth to elaborate its authorization process and the http model from the domain library to reason about how ifttt behaves when deployed on a web server.
constructing and analyzing the overall model took us around .
weeks in total.
since our goal was to analyze the security of ifttt s service composition mechanism instead of looking for aws in a particular web service we did not explicitly model the details of individual web services themselves.
instead we built archetypal descriptions of channels triggers and actions that over approximate all possible data ow throughout the system.
we discuss one of the discovered attacks which exploits details across the three di erent layers of the system ifttt oauth and http.
information leakage with login csrf one way the attacker named eve may attempt to access private data owned by another user alice is to get ifttt to link alice s and eve s accounts through the same recipe.
this way when a trigger is performed on alice s account ifttt would perform the corresponding action on eve s account inadvertently directing data from alice s account to eve s. figure shows sample traces from the three di erent models and their composition.
in the abstract ifttt model which describes its high level work ow such an attack is not possible given an assumption encoded in the alice process that when alice makes a recipe she activates the associated channels only for her accounts.
thus a trace where the creation of alice s recipe mkrecipe is followed by the activation of a channel for eve s account activate eve as shown in figure a is not a valid trace in this model.
figure b shows a sequence of events that occurs in a typical oauth work ow.
it begins with a user authenticat ing herself with an identity provider e.g.
blogger which then asks the user to con rm whether she approves access to her account by a third party e.g.
ifttt .
if so then the third party may obtain an access token to her account directly from the identity provider through gettoken .
finally figure c shows a simple trace where one http request reqimp is triggered by another reqtrig inside a browser in section .
we discussed how this generic sequence may be exploited for a csrf attack in the context of another system.
in the composition of the three models an attack on ifttt becomes possible as shown in figure d .
it begins with a variant of csrf called login csrf where a victim is unknowingly logged into a site under the attacker s account2.
this login event has three representations assigned to it by the generated mapping reqimp which is caused indirectly by eve when alice visits eve s site through reqtrig logineve which results in alice getting logged onto a channel site as eve and authenticate which ful lls the initial authentication step of an oauth process.
in the next step alice proceeds to make a new recipe with an action on that same channel.
since she is already logged onto the site albeit as eve she is not required to authenticate herself with the action channel during the oauth work ow she simply needs to approve ifttt s access to blogger.
once ifttt obtains a token to access eve s account from the action channel this account remains associated with the new recipe.
as a result whenever the trigger is performed on alice s account dotriggeralice ifttt immediately performs the corresponding action on eve s account doaction eve leaking alice s data to eve.
as far as we are aware this was a previously unknown issue with ifttt.
the insecure design decision that enables this attack is the encoding of the login operation on a channel as an http request without protection against csrf.
we con rmed that channel sites on ifttt were vulnerable to this attack and noti ed their developers of the security aw of them have since addressed the issue by adding csrf protection to their login page.
.
handme.in handme.in is a web application designed to facilitate easy recovery of personal items.
in a typical work ow the user purchases a sticker with a unique code written on it and places the sticker on a physical item to be tracked.
if the item is lost its nder can notify the owner of by entering the code and other relevant information e.g.
an arrangement to return the item in person on the site.
it currently has over registered stickers.
the process for the payment of stickers is delegated to paypal which o ers a service called instant payment noti cation ipn .
when a customer initiates to purchase a sticker handme.in redirects her to the paypal ipn site.
after she makes a successful payment on paypal the ipn system will send the customer and billing information to the merchant site which may then nalize the order.
for our study we constructed the models of handme.in and paypal ipn protocols in poirot around loc and 2normally login csrf is considered a minor form of attack because at most it allows the attacker to access a log of the victim s actions e.g.
search history on google .
in context of ifttt however it can be used to carry out an attack with far more serious consequences as discussed here.
188figure average analysis times over trace lengths.
composed them together with the http model.
constructing and analyzing the overall model took around weeks.
we analyzed the following property of the system information about a lost item entered by the nder should be accessible only to the owner of the item.
we brie y describe one feasible attack on the system missing check during payment the ipn service provides no guarantee that the person paying for a product is the same person who will receive the product.
paypal sends back information about the payer e mail billing address etc.
and the merchant may perform further checks to ensure that the product will be delivered to the same person.
handme.in does not perform such checks because it assumes that a user will be directed to the ipn site only by following the standard work ow on handme.in.
this assumption is reasonable at the business logic layer but is violated when the user interacts with the site through a browser.
in particular a web attacker may redirect the user to an ipn site for a sticker that has already been assigned to the attacker the victim might then unknowingly pay for and receive a sticker that is linked to the attacker leading to a violation of property .
this attack combines details from the handme.in paypal and http models.
we noti ed the result of our analysis to the developer who have since addressed all of the reported security aws.
.
analysis performance we evaluate the scalability of poirot s analysis over the two case studies.
as discussed in section the analysis relies on constraint solving over nite domains and so it must be given an explicit scope to bound the number of processes data values events and the maximum length of traces.
figure shows the average analysis times for the two cases studies as the maximum length of traces is varied we used a xed scope of for processes and for data values.
the analyses were performed on a mac os x .
ghz with 4g ram with the lingeling sat solver.
figure shows an exponential growth trend for the analysis times as the trace length increases this is not surprising since the number of possible event combinations that must be explored also grows exponentially.
among the counterexamples that were generated the shortest trace had events and the longest one had events we performed additional analysis up to the trace length of without discovering any more counterexamples.
in all cases the analysis took under seconds.
the results do not necessarily imply that the checked properties are valid as there might exist a counterexample beyond the maximum scope that we used.
however based on our experience applying poirot to a number of examples we believe that the bounds we used were largeenough to capture many common web security attacks.
.
discussion threats to validity there are two potential sources of errors in our case studies delity of the models and insu cient scope used in analysis as discussed above .
to ensure the accuracy of the handme.in system model we closely worked with its lead developer throughout the entire process for ifttt and paypal ipn we consulted available documentation on the system and studied the details of its behavior by inspecting http requests throughout the site.
like in any model based analysis however it is possible that our models inadvertently excluded a detail that would have lead to the discovery of a new counterexample.
building a faithful model is a challenging task in general but we believe that it is not an inherent limitation to our composition and analysis approach.
for example to reduce the modeling e ort and improve its delity poirot could be complemented with techniques on extracting models from logs or implementation some of which have been developed in the context of security .
lessons learned we have used poirot to model and analyze a number of small and large systems the most complex ones being the two systems above.
we were successfully able to reuse the domain models across most of these systems in part because we invested considerable e ort months into ensuring the generality of the models based on our experience we believe that reusability justi es this upfront cost.
we also expect poirot s library to grow in size and applicability over time.
for example we initially created a model of the oauth protocol in order to analyze it and we were able to reuse the same model for the ifttt study.
the implementation for each of the two systems was not available and the public documentation only described the system behavior at the high level work ow or apl level.
thus we had to deal with some uncertainty about how the system was actually implemented as a web application.
being able to express these unknown information as a partial mapping and having an automatic analysis to suggest us potentially insecure design decisions was crucial for our analysis without this ability we would need to manually try out possible mappings in an ad hoc manner.
incrementality in each of the case studies we constructed three increments of the system model composition of an initial design with another abstract model e.g.
ifttt and oauth with an http protocol model and nally with a model of browser scripts.
some of the discovered attacks involved only the logic in the abstract design whereas others also relied on the details in the http and browser models.
for example the attack in section .
combined a weakness in the business logic of handme.in and a browser redirection feature and thus was not discovered until the increment .
but we were also able to nd a much simpler attack in which exploited only a aw in the way handme.in assigned codes to its stickers.
coming up with a complete model of a system at once is often too onerous and so we believe that being able to discover and address security issues in this incremental manner is crucial to reducing the designer s burden.
on the other hand during each increment the analysis step became computationally more challenging as the sat instance generated by the alloy analyzer increased in size.
it would be desirable to be able to reuse where possible some of the re189sults from prior analyses we plan to investigate this problem as a way to improve the scalability of our analysis approach.
.
related work views our work was strongly in uenced by previous research on views in software engineering .
in a typical development process various stakeholders may have di ering views on the system hampering the construction of a single coherent global model.
in the context of security the attacker can be regarded as one of the stakeholders with a malicious intent to sabotage the system exploiting details in a view that di ers from that of the designer.
model merging is an active line of research on techniques and tools for composing independent models.
merging techniques have been developed for various types of models including architectural views behavioral models database schemas and requirements .
among these the works on behavioral models are most closely related to our work .
a common property guaranteed by their frameworks is the preservation of behavior that is when two models m1and m2are merged the resulting model m0re nes the behavior of both m1andm2in comparison our goal is to explore ways in which a property inm1may be violated by added behavior from m2.
reasoning with uncertainty researchers have studied the problem of constructing and analyzing a partial model where certain behavioral or structural aspects of a system are speci ed to be unknown and an analysis is performed to check properties of the system in the absence of those information .
our work di ers from the above approaches in two ways.
first all of these approaches address uncertainty that arises due to delayed decisions about whether a particular feature or characteristic of a system should be included in the nal design.
in comparison our approach deals with uncertainty over potential relationships between two distinct but possibly overlapping views of a system.
such uncertainty may stem from for instance alternative decisions about how a particular abstract operation or data type is to be represented in terms of another more concrete element.
second in the existing approaches uncertainty is expressed over a set of modeling terms with a xed vocabulary.
as a result they do not handle cases in which new distinct elements may be introduced and related to parts of an existing model.
in this sense our work is more closely related to the one by li krishnamurthi and fisler where they propose a methodology for composing a system model against independent features and analyzing their potential impact on the system behavior.
like ours their approach allows new propositions to be introduced into an existing base model giving rise to new behavior and possibly a violation of a previously established property.
the two approaches di er in the type of composition performed.
their composition involves conjoining a feature with a base model at special designated states called interfaces and is particularly suited at reasoning about ordered sequential composition of features.
in comparison our composition involves relating a pair of models across di erent abstraction layers and is intended to reason about the impact of design choices on the underlying representation of a system entity.
security modeling and composition a large body of work exists on modeling systems and protocols for security analysis.
most protocol languages describe a system interms of abstract agents and messages between them and are not designed for elaborating their underlying representations .
several compositional security frameworks have been proposed as a way of establishing the end to end security of a system by combining the properties of individual component models .
in these approaches composition involves bringing together two parallel processes that communicate through a xed interface at the same level of abstraction e.g.
a server and a client .
in comparison our approach involves composing processes that partly or entirely overlap with each other in that they represent the same entity at di erent levels of abstraction e.g.
abstract store and concrete server on which it is deployed .
another related work is georg and her colleagues work on an aspect oriented approach to security modeling and analysis .
in this approach a set of generic attack models called security aspects are instantiated against a primary system model and the alloy analyzer is used to check the composed model against a security property.
our approach di ers from theirs in two ways.
first during the instantiation step the user must provide a full correspondence between two models unlike our approach where a partial mapping is su cient for performing an analysis.
in addition our notion of representation is more general than their notion of correspondence which is limited to a mapping between the names of modeling elements.
their approach does not allow for example a more complex mapping that relates thestructures of two elements e.g.
encoding addasreq .
.
limitations and conclusions in our approach all events are treated as atomic entities.
but sometimes it may be desirable to specify a certain event as itself consisting of a set of more detailed events performed in a particular order.
for instance an http request represented as a single event at a high level of abstraction may actually involve a series of handshakes between the server and the client.
to accurately model such hierarchical relationships our mapping would need to be extended to allow an event to be mapped to a sequence of events.
poirot currently allows the user to specify and check trace properties a type of properties that can be evaluated by inspecting a single execution trace e.g.
nothing bad ever happens .
however certain classes of security properties inherently talk about multiple traces of a system .
for instance a non interference property says that an attacker should not be able to learn new information by observing how the system behavior changes when other users participate in its services.
in order to analyze such properties our analysis would need to be extended to perform a higherorder reasoning where setsof traces are explored at once.
given a partially speci ed m our analysis generates mappings that lead to security violations.
it may also be possible to instead generate a mapping that guarantees that the resulting system satis es a given property this would involve reasoning about each candidate mapping over all possible traces of a system and thus require a higher order analysis.
as a next step we plan to incorporate techniques from software synthesis to provide this capability in poirot.
acknowledgement we thank st ephane lafortune matt mccutchen joseph near stavros tripakis and our reviewers for their insightful comments and suggestions.
this work was supported in part by the nsf award crd and by the singapore university of technology and design.
.