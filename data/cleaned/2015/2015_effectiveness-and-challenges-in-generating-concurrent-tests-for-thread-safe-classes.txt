effectiveness and challenges in generating concurrent tests for thread safe classes valerio terragni usi universit della svizzera italiana switzerland valerio.terragni usi.chmauro pezz usi universit della svizzera italiana switzerland university of milano bicocca italy mauro.pezze usi.ch abstract developingcorrectandefficientconcurrentprogramsisdifficult anderror prone duetothecomplexity ofthreadsynchronization.
often developers alleviate such problem by relying on thread safe classes whichencapsulatemostsynchronization relatedchallenges.
thus testingsuchclassesiscrucialtoensurethereliabilityofthe concurrency aspects of programs.
some recent techniques and correspondingtoolstackletheproblemoftestingthread safeclassesby automaticallygeneratingconcurrenttests.inthispaper wepresent a comprehensive study of the state of the art techniques and anindependent empirical evaluation of the publicly available tools.
we conducted thestudybyexecutingalltoolsonthe jacontebe benchmarkthatcontains47well documentedconcurrencyfaults.
ourresultsshowthat8outof47faults weredetectedbyat leastonetool.bystudyingtheissuesofthetoolsandthegenerated tests we derive insights to guide future research on improving the effectiveness of automated concurrent test generation.
ccs concepts software and its engineering concurrent programming languages software testing and debugging keywords test generation concurrency faults thread safety acm reference format valerio terragni and mauro pezz .
.
effectiveness and challenges in generating concurrent tests for thread safe classes.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september3 montpellier france.
acm new york ny usa 12pages.
introduction concurrent programming is pervasive across application domains due to the widespread of multi core chip technology.
developing correctand efficientconcurrent programsis harddue to the complexity of thread synchronization that suffers from underpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
over synchronization problems.
under synchronization introducessubtle concurrencyfaults likedata racesandatomicityviolations thataredifficulttoexposeattestingtimesincetheymanifestunderspecificnon deterministicthreadinterleavings.oversynchronizationcausesdeadlocksandaffectsperformancebyintroducing overhead and reducing parallelism .
oftendevelopersreducethecomplexityofdevelopingreliable concurrent programs in object oriented shared memory languages for instance javaandc by relying on thread safe classes whichaddresstheimportantchallengeofsynchronizingconcurrent memory accesses in a correct and efficient way .
by delegating the burden of thread synchronization to thread safe classes developers can use the same instance of such classes from multiplethreadswithoutadditionalsynchronization thusrelyingonthe correctnessof thread safe classestoavoidconcurrencyfailures .
ensuringthecorrectnessofthread safeclassesisimportant.itidentifiesconcurrencyfaultsintheimplementationofthethread safe classes and thus in the programs that rely on them.
an effective approach to validate the correctness of thread safe classesconsistsinautomaticallygeneratingconcurrentunittests andcheckingifthegeneratedteststriggerfault revealingthreadin terleavings byrelyingononeofthemanyinterleavingexploration techniques .
a concurrent unit test concurrent test hereafter consists of multiple concurrently executing threads that exercisethepublicinterfaceofaclassundertest.figure 2shows anexampleofconcurrenttestthattriggersaconcurrencyfaultin the thread safe class appenderattachableimpl of thelog4jlibrary shown in figure .
inrecentyears researcheshaveproposedtechniquesforautomatically generating concurrent tests inspired by recent advances in sequential unit test generation .
generating concurrent tests faces new challenges that are not present when generating sequential tests like multi threading non determinism shared states and huge spaces of thread interleavings .
current generators of concurrent tests address the new challenges with different approaches for which there is no clear ev idence of their effectiveness and limitations yet.
although the authors of these approaches have performed experiments to evaluateandcomparethem suchexperimentsaretoonarrowin thecriteriatoselectsubjectsandalsointheanalysisoftheresultsto provide solid evidence of effectiveness and limitations.
to address thisgap thispaper reportsanempirical studyofthe sixcurrently openly accessibleconcurrenttestgeneratorsforthread safeclasses.
the goal of the study is to i assess the effectiveness of the techniques in generating fault revealing tests ii identify and better understand their limitations and iii shed light on future research authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france valerio terragni and mauro pezz faulty appenderattachableimpl class log4j v. .
.
public void removeallappenders if appenderlist !
null intlen appenderlist.size for int i i len i appender a appender appenderlist.elementat i a.close appenderlist.removeallelements appenderlist null figure code related to the log4j concurrency bug .
directions identifying ways in which existing techniques can be improvedornewtechniquesbedefined.inourstudy wereferto the recent jacontebe benchmark of concurrency faults in threadsafe classes published in ase a repository of concurrency faults experienced in the field .
we would like to notice that weselectedthebenchmarkindependentlyfromthestudiedtools toavoidbiasesinselectingthesubjects.ourresultsindicatethat only of the faults can be detected by at least one of the generators of concurrent tests evaluated in this paper.
this indicates both an impressive effectiveness and a large space for improvements.
weanalyzedtheresultsofboththeautomatically generatedand the jacontebe test suites and examined the characteristics of both detected and undetected faults to study the effectiveness and limitationsoftheconcurrenttestgenerators.weidentifiedthree mainissuesthatpreventthemfromgeneratingfault revealingtests and we observed that the issues are shared among the different techniques.wedevisefutureresearchdirectionstoaddressthese problemsandincreasetheoveralleffectivenessofconcurrenttest generation.toeasereproducibility ourexperimentaldataareavailable in our website .
in summary this paper contributes to the state of the art by presenting asurveyontheexistingtechniquesforgeneratingconcurrent unit tests for thread safe classes a large scale experimental and comparative evaluation of the six generators of concurrent tests for java thread safe classesconductedonthejacontebebenchmark which includes concurrency faults an analysis of the effectiveness of these six techniques in detecting concurrency faults a discussion of a set of insights that we gained from the study andthatgivesomeguidelinesforfutureresearchin this area generating concurrent tests thissectionpresentsthepreliminariesandbackgroundoftest generationforexposingconcurrencyfaultsinthread safeclasses in thecontextofconcurrentobject orientedprogramsthatimplement the shared memory programming paradigm.
aconcurrentshared memoryobject orientedprogramiscomposed of a set of classes each composed of a set of methods and fieldsthatcanbeexecutedandaccessedconcurrentlybymultiple threads respectively.aclassis thread safe ifitencapsulatessynchronization mechanisms that prevent incorrect accesses to the classfrommultiplethreads .aclassisthread unsafeotherwise.
sequential prefix 2appenderattachableimpl var0 newappenderattachableimpl 3consoleappender var1 newconsoleappender 4var0.addappender appender var1 newthread new runnable public void run var0.removeallappenders suffix .start newthread new runnable public void run var0.removeallappenders suffix .start figure concurrent test that exposes the bug in figure .
example of synchronization mechanisms are synchronized blocks injava and locks mutexes and semaphores in c. thread safety guarantees that the same instance of a thread safe class can be correctly accessed by multiple threads without additional synchronization other than the one implemented in the class .
writing correct efficient and reliable thread safe classes is hard due to the non deterministic order of memory accesses across threads whichcanleadto thread safetyviolations thatis deviations fromtheexpectedbehavioroftheclasswhenconcurrentlyaccessed.
a key characteristic of such violations is that they manifest nondeterministically duetothenon determinismoftheschedulerthat determines the execution order of threads.
the order of accesses to sharedmemorylocationsisfixedwithinonethread butcanvary across threads.
an interleaving is a total order relation of shared memory accesses amongthreads .
concurrent executionscan manifestmanydifferentinterleavings andonlysome usuallyfew of them expose thread safety violations .
asanexampleofthread safetyviolation figure 1showsthecode snippet of class appenderattachableimpl of thelog4jlibrary part of the jacontebe benchmark .
method removeallappenders checks whether the object instance field appenderlist is initialized line before dereferencing it line and setting the reference to null line12 .theseaccessesarenotproperlysynchronized two threads that concurrently invoke removeallappenders may cause a nullpointerexception bothinaspecificprogramstateandwitha particular thread interleaving line .
in a thread interleaving that triggers the exception a thread t1executes line after a thread t2 executed line and before t2executes line .
aneffectiveapproachforvalidatingthecorrectnessofthreadsafeclassesistheautomatedgenerationofconcurrenttests.figure shows a logical architecture of such approach which is shared among all the surveyed techniques.
in a nutshell given a class under test and optionally a set of auxiliaryclassesthattheclassundertestdependson thetechniques automatically exposes thread safety violations in four consecutive steps i they generate sequential single threaded method call sequences that exercise the public interface of the class under test ii assemble such sequences in a concurrent test that executes concurrently the method call sequences from multiple threads iii exploretheinterleavingspaceofthegeneratedconcurrenttests by means of state of the art interleaving explorers iv check if any of the explored interleavings exposes a thread safety violation.
figure2shows an example of a concurrent test that can reveal the fault revealing interleaving described above.
in this paper we refertothegeneraldefinitionofconcurrenttestpresentedintheseminal paper of pradel and gross .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
effectiveness and challenges in generating concurrent tests for thread safe classes ase september montpellier france class under t est auxiliary classesinput thread interleavingsoutput thread thread call sequence generatorcall sequences assemblerinterleaving explorerconcurrent test method call sequences s1 s2 s3...s1 s2 s3 thread safety oracle thread safety violationsconcurrent test generation interleaving exploration step step step step figure logical architecture of concurrent test generation.
aconcurrenttest isasetofmethodcallsequences whereeach call in a sequence consists of a method signature a possibly empty list of input variables method parameters and an optional output variable method return value .
in an instance method call the first input variable is the object that receives the call for example var0 in the call at line figure .
a test consists of a prefix and a set of suffixes.
a prefixis a call sequence to be executed in a single thread that instantiates the class under test to create the object instances that will be accessed concurrently from multiple threads.
a prefix may need to invoke additional methods to bring an object instance into a particular state that may enable the suffixes totriggerathread safetyviolation.forinstance themethodcall var0.addappender appender var1 at line in figure 2instantiates the shared object field appenderlist in order to satisfy the condition of the if statement at line in figure during the executionoftheconcurrentsuffixes totriggera nullpointerexception whenexecutingthestatementatline6.a suffixisacallsequence to be executed concurrently with other suffixes after executing thecommonprefix.allsuffixessharetheobjectinstancescreated bytheprefix andcanusethemasinputvariablesforsuffixcalls toinvokemethodsthataccessthesharedinstancesconcurrently.
for example all the suffixes in figure 2use the same shared object instance var0of the class under test as an object receiver.
state of the art generators of concurrent tests foracompletesurveyofthemaintechniquestogenerateconcurrent tests we identified a list of relevant papers by querying scholarlywebengines googlescholar acmandieeedigitallibraries withthequery test generation concurrency andrefined the list by ignoring the papers unrelated to concurrent test generation and concurrency fault detection.
we discarded papers that presenttechniquesforgeneratingsequentialtests for generatingconcurrentteststoexposeperformanceissues incorrect substitutability faults or for reproducing concurrency failuresfromcrashstacks whichareoutsidethefocusofthis study.
we discarded techniques presented only in short workshop papers .weexcludedtechniquesthatgeneratetestinputs forconcurrentprograms notablytechniquesthatuseconcolicexecution or symbolic analysis since these techniques generatesonlyinputsandnotconcurrenttests astheoneshown in figure .
table1summarizes the nine relevant techniques that we identifiedinourstudy.thetableindicatesthenameofthetool themain reference thevenueandyearofpublication andthecategoryof thetechnique accordingtothetaxonomyofchoudharyetal.
who classifyconcurrenttestgeneratorsas random based coverage based andsequential test based .table state of the art generators of concurrent tests tool name reference venue year category ballerina icse 2012random basedcontege pldi consuite icst coverage based autocontest icse covcon icse omen fse sequential test basednarada pldi intruder fse minion oopsla insections .
.2and3.
weoverviewthetestgenerationtechniques grouped per category corresponding to steps and in figure3.insection .
wediscusstheinterleavingexplorersand thread safety oracles used by the different techniques corresponding to step and in figure .
.
random based techniques thepioneerrandom basedtechniquesareballerina and contege which generate concurrent tests by randomly combining randomly generated method call sequences with random input parameters.
both ballerina and contege rely on existing interleaving explorers and use linearizability as test oracle.
linearizability reportsa violationwhenevera threadinterleaving produces a behavior that cannot be produced in any linearized test execution where all methods are execute atomically sequentially .
ballerina icse .
nistor et al.
identify as a major challengeofconcurrenttestgenerationthehighcomputationalcost ofexploringtheinterleavingspacesofthegeneratedtests which size grows factorially with the number of shared memory accesses executed by the concurrent suffixes .
ballerina addresses this challengebyconfiningeachconcurrentsuffixtoasinglemethod call limitingthetesttoasinglesharedobjectundertest andgeneratingtestswithexactlytwoconcurrentthreads.ballerinaclusters oracle violationsto reducethe cost ofinspecting them oracleviolations belonging to the same cluster are likely to be either all false alarms or all true errors .
contegepldi2012 .contegeaddressesthesamechallenges of ballerina with a novel linearizability checker that improves efficiency and reduces false alarms over ballerina .
pros random based techniques can efficiently generate concurrent tests since they do not require complex analysis they can generate thousands of concurrent tests in few seconds and can effectively expose easy to find concurrency faults whose manifestation does not depend on a particular program state.
cons random basedtechniquesarelesseffectiveinrevealing hard to find concurrency faults because randomly generated tests tendtorepetitivelytestsimilarprogrambehaviors .weneedto randomly generate thousands or even millions of concurrent tests authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france valerio terragni and mauro pezz to effectively detect hard to find faults due to the low probability ofrandomlygeneratingafailure inducingtest .forexample contege requires more than a million tests to expose a single concurrencyfault .thisisanissue becauseofthehighcomputational cost of exploring the interleaving space of all generated tests.
in practice we can explore only the interleaving space of few tests within an affordable time budget .
.
coverage based techniques coverage basedtechniquesaddressthelimitationsofrandombased techniques by driving the generation of concurrent tests withinterleavingcoveragecriteria .thesetechniques identifyandpruneconcurrentteststhatleadtoredundantbehaviors thread interleavings to steer test generation towards newprogram behaviors thus avoiding the high cost of exploring the interleaving spaces of redundant tests.
a major challenge faced by coverage basedtechniquesisthehighcostofcomputingtheprecise executable domain of interleaving coverage criteria for concurrent programs .
to address this challenge coverage based techniquesrelyoncoveragecriteriathatareefficienttocompute at the cost of approximating the coverage of thread interleavings.
consuiteicst2013 .theseminalcoverage basedconcurrent test generation approach consuite extends evosuite to generate concurrent tests.
consuite statically estimates the coverage requirements as a set of thread interleavings and selects candidate concurrent tests for covering uncovered interleavings by checking if the sequential executions of the suffixes of the tests coverthememoryaccessesthatcomprisethetargetinterleaving.
consuite does not consider the execution context of shared memory accesses and thus ignores concurrency faults that manifestfailure inducinginterleavingsonlyunderspecificexecutioncontexts.
moreover even if the concurrent suffixes cover the target shared memoryaccesseswhenexecutedsequentially thereisno guaranteethatthesuffixesexecutetheaccessesinthespecificorder prescribed by the interleaving coverage target when executed concurrently.
autocontest icse .
autocontest improves over consuite by introducing a context sensitivity coverage metric that can be efficiently computed as it analyses sequential executions andthatincludessynchronizationsensitive lockacquisitions and releases and calling context information.
autocontest overcomesthelimitationsofcomputinganapproximatedsetofcoverage requirements statically prior testing by generating concurrent testsiteratively sothateachtestincreasesthecoveragebasedon the coverage data that are collected during the test generation.
covcon icse .
covcon exploits the concept of concurrent method pairs proposed by deng et al.
that is the set ofpairsofmethodsthatexecuteconcurrently .covconmeasuresthe frequencyof concurrentexecutionsof pairsofmethods to focus the test generation on infrequently or not at all covered pairs .
pros coverage based techniques limit redundant tests thus reducingthenumberofgeneratedtests andconsequentlytheinter leavingexplorationcosts asinprincipleonlytheteststhatincrease interleaving coverage will be analyzed by the computationally expensive interleaving explorer.cons theeffectivenessofcoverage basedtechniquesdepends on the coverage criterion which might either be too expensive tocomputeoritmightmissrelevantcoveragerequirements.the optimaltrade offbetweenanalysiscomputationalcostandprecisionofthecomputedrequirementsisstillunclear.forexample the consuitecoveragecriterionlikelymissescoveragerequirements because of being both statically computed and specific to predefined faulty interleaving patterns.
autocontest efficiently learns coverage requirements while generating method call sequences butcanmisscoveragerequirementsifspecificinputparametersareneededtoobservenewcoveragerequirements.thecovconcoveragecriterioniscomputedefficientlyatmethodlevel butdoesnot capture the many interleaving coverage requirements that involve the shared memory accesses triggered by the methods.
.
sequential test based techniques thesequential test basedtechniquesproposedbysamaketal.
apply the same overall approach to different kinds of concurrency faults omen targets deadlocks narada data races intruder atomicity violations and minion assertion violations.
they analyse concurrent programs starting from a suite of sequential single threaded tests whichcanbeeithermanually written orgeneratedbyexistingsequentialtestgenerators .they analyzetheexecutiontracesobtainedbyexecutingtheinitialtest suitessequentially toidentifyconcurrencyfaultsthatmayoccur when combining multiple sequential tests into concurrent tests.
if such faults are identified these techniques generate concurrenttests which they analyze with interleaving explorers to check if they indeed expose the fault during a concurrent execution.
pros sequential test based techniques do not generate concurrent tests that are irrelevant with respect to the considered type of concurrency fault.
cons theireffectivenessdependsontheinitialsetofsequential tests.thehypothesisthatsequentialtestsexecutedconcurrently are always adequate to expose concurrency faults is not always valid.
sequential tests do not refer to the concurrency structure manuallywrittensequentialtestsaredesignedwithoutconsidering concurrency issues while automatically generated sequential tests are produced referring to sequential based coverage criteria forexample branch coverage .
moreover each sequential testbasedtechniquesimposesarelativelyhighcomputationalcost .
.
interleaving explorers and thread safety oracles generatorsofconcurrenttestscheckifthegeneratedtestsexpose thread safety violations step and in figure by adopting different interleaving explorers and thread safety oracles which comewithdifferentcomputationalcosts presentdiverseproneness to false positives and target different types of faults data races atomicity violations and related failure types exceptions endless hang and logical issues .
table2summarizesthemaininterleavingexplorers selective randomandexhaustivetechniques.
selectivetechniqueslimitthe interleavingspaceexplorationofthegeneratedteststointerleavingsthatmatchpredefinedpatternsofconcurrencyfaults likedata authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
effectiveness and challenges in generating concurrent tests for thread safe classes ase september montpellier france table interleaving explorers and thread safety oracles interleaving implicit oracle internal oracle explorer exceptions endless hang data races atomicity violations random contege covcon narada selective omen autocontest intruder exhaustive ballerina races and atomicity violations .randomtechniques randomly explore the space of possible thread interleavings while exhaustive techniquesexhaustivelyexploreallnon redundantinterleavings .redundantinterleavingsareoftenidentified with partial order reduction techniques .
both random and systematic techniques do not restrict the interleavings to be explored andthereforearenotspecifictoanyparticularkindofconcurrency faults thusdifferingfromselectivetechniques.bothrandomand exhaustivetechniqueshardlyscaletoconcurrenttestswithhuge interleaving spaces since exhaustive techniques are computationallyexpensive andrandomtechniqueshavealowprobabilityof detecting concurrency faults .
in contrast selective techniques aremoreefficient becausetheyfocusonasmallportionoftheinterleavingspace .contege covconandnaradarelyonrandom interleavingexplorers.ballerinareliesontwodifferentexhaustiveinterleavingexplorers.autocontest omenandintruder relyonselectivetechniques assetfuzzer igoodlock and ctrigger respectively.
thread safety oracles are either implicit or internal.
implicit oraclesreportaconcurrencyfaultifanexploredthread interleaving manifests an obvious and visible oracle violation like runtime exceptionsorendlesshangs .implicitoraclescannotdetectfaults thatmanifestaslogicalerrors wrongoutput .
internaloracles detect faults by monitoring the internal program states.
for example theyreportanoracleviolationifanexploredthreadinterleaving matches a predefined pattern of concurrency faults regardless ofobservingaruntimeexceptionoranendlesshang.thus internal oracles can both fail to detect the presence of faults false negatives andsignalthepresenceofanomaliesthatarenotfaults false positives .
contege covcon omen and ballerina rely on implicit oracles while the other techniques on internal oracles.
generating tests and exploring interleaving are two orthogonal problems.assuch inprinciple thetestsgeneratedwhitanytestgeneratorcouldbeanalyzedbyanyinterleavingexplorer .inpractice thisisnotalwaysthecase.forexample autocontest generates concurrent tests with tens of method calls in the concurrentsuffixes.thismaybeincompatiblewithbothexhaustiveandrandominterleavingexplorer sinceexhaustiveexplorationmaybecometooexpensive whilerandomexplorationmaybeineffective as the probability of triggering faulty interleavings decreases with the increase of test length .
experiments in this section we describe the experiments that we designed to evaluate and compare the six openly accessible state of the art concurrent test generators that we selected as a result of our analysisoftheliterature.thegoaloftheexperimentsistoevaluate andcompare howeffectivelyand efficientlythese generatorsfind concurrency faults.table jacontebe benchmark code base label subjects description apache dbcp dbcp database connection pool apache derby derby relational databaseapache groovy groovy dynamic language for jvmopenjdk jdk java development kit apache log4j log4j logging library apache lucene lucene search library apache pool pool object pooling api .
tool selection we experimented with all state of the art techniques for which there exists a publicly available tool contege covcon auto contest omen narada and intruder.
we were not able to experimentwithballerina consuiteandminionbecausethe toolswerenotpublicly availableat thetime ofconducting theexperiments.1the empirical comparison of the tools is facilitated by the fact that all tools generate tests for programs written in java.
we experimented contege and covcon both with the default configurationthatusesstresstestingasinterleavingexplorerand withtheconfigurationthatusesthe exhaustive interleavingexplorer jpf .
such configuration is supported by both tools and we indicate the variants of contege and covcon that rely on jpf as contegejpf and covconjpf respectively.
.
subject selection the criteria for selecting subjects play a crucial role in evaluating and comparing testing techniques .
most of the experiments reported in the surveyed papers refer to previously published papersas abasis for selectingsubjects.
intheir seminal papers both pradel and nistor propose an interesting set of experiments butdonotdiscussthecriteriaforselectingtheexperimental subjects .inthecontextofsequentialtestgeneration fraser and arcuri argue that if the subject selection is unclear in principle it could mean that the presented set of classes represents the entire set of classes on which the particular tool was ever tried but it could also mean it is a subset on which the technique performs particularly well andsuggest to randomlysample open source coderepositoriesinordertoavoidbiases .fraserandarcuri sapproachis suitabletoevaluatetestgeneratortechniqueswithrespecttocoverage since this does not require that the selected subjects contain concurrency faults.
the approach is not well suited for evaluating testgenerationtechniquesthataimtoexposeconcurrencyfaults quickly without aiming to maximise coverage like random based andsequential test basedtechniques.ourexperimentsaimstoevaluate the different techniques referring to an unbiased benchmark thatisabenchmarkofthread safeclasseswithdocumentedconcur rencyfaultsselectedwithoutneitherconcurrenttestgenerationnorsomespecifictechniquesinmind.abenchmarkthatsatisfiesthisrequirement is the jacontebe benchmark recently proposed by lin et al.
.
jacontebe is composed of concurrency faults from sevenjavapopularopensourceprojects seetable andconsiders a wide range of concurrency faults types data races atomicity violations resourceand wait notify deadlocks.thereaderscanfind detaileddescriptionofthesubjectsintheoriginalpaper and 1theminionwebsite at the time of conducting the experiments authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france valerio terragni and mauro pezz companionwebsite wheretheauthorsclaimthatjacontebe isthemostadvisablebenchmarkforevaluatingconcurrencytestingtechniques.competingbenchmarksareeithercomposedoftoy concurrentprograms ibmbenchmarksuite ornotspecifically designedforconcurrencyfaultdetection jpg anddacapo thus without documented concurrency faults.
for each of the concurrency faults subjects the jacontebe benchmarkprovidesthefollowingartifacts i thebinariesofthe code base s buggy version ii the link to the bug report iii the source code of a manually written fault revealing concurrent test jacontebe was built specifically to evaluate interleaving exploration techniques step and in figure and thus it includes fault revealingconcurrenttests.thesecharacteristicsmakejacontebe an excellent benchmark for our study since our goal is to assess the capability of test generators to synthesize concurrenttests step and in figure that can expose the concurrency faults that can be revealed with manually written tests.
.
subject and tool preparation foreachsubject wecollectedtheinputsofthetools theclass undertestandthesetofauxiliaryclasses seefigure .weretrieved the class under test by examining the bug report and the manuallywritten test.
as discussed in section theauxiliary classes are those in which the class under test depends upon.
for example if a methodmofthe classunder testhas aparameter ofnon primitive typea thenais an auxiliary class.
most tools require auxiliary classesasinputtocreateobjectsoftype atobeusedasaparameter for invoking m. we identified a proper set of auxiliary classes by relyingonthecorrespondingmanually writtentestsof jacontebe.
we set the auxiliary classes as all the classes of the program under test excludingtheclassundertestitself thathavebeenreferenced to in the manually written test.
while most of the evaluated tools accept binaries as an input covcon needs the source code because it instruments the source code with an eclipse plug in2.
therefore we retrieved the relevant source code from the corresponding code repositories and we confirmed that the jacontebe tests fail if executed on the source code.
we instrumented the source code of the class under test and all of its superclasses3.
thesequential test basedtools omen naradaandintruder require a set of sequential tests in input as they do not perform step1offigure .wecouldobtainsuchtestsbyextractinghumanwritten sequential tests from public repositories but it would be unfairwithrespecttocoverage basedandrandom basedtechniques that generate concurrent tests relying exclusively on automatically generated codes.
to avoid biases we generated the tests with arandom based generator of sequential tests following the experimentsofchoudharyetal.
.weoptedforrandoop the most popular tool of this type4.
an important configuration choice isthenumberofsequentialtestsforthethreesequential testbasedtools.toomanytestscouldintroduceoverheadduringtheanalysis phase while too few tests could be insufficient to find the fault.
we addressed this issue by iteratively alternating the execution of 3excluding java.lang.object .
4weranrandoopignoringallteststhatdonotinstantiatethecutatleastonceby including the option include if classname appearsrandoopandofthesequential testbasedtools.ateachiteration we doubled the time budget tand the maximum number of tests k of randoop.wechoseaninitialvalueof t 30secondsandk as a recent empirical study indicates that randoop saturates code coverage in less than seconds .
.
evaluation setup we executed the eight tools six techniques and two alternative configurations with a time budget of an hour for each of the jacontebesubjects.werepeatedtheexperimentstentimestocope withtherandomnessofthechoicesofthetoolswhilegenerating tests and exploring interleaving spaces.
the overall machine time of the experiments was days.
we executed our experiment onaserverubuntu16.
.2with64octa corecpusintel xeon e5 4650l .
ghz and gb of ram.
we evaluated the effectiveness of the tools in terms of bug finding capability and their efficiency in terms of the time required to detect the faults which includes the time of both generating the testsandexploringtheirinterleavingspaces step1to4infigure .
wedidnotusecoverageasanevaluationcriterion sinceinthecontext of concurrency testing the only pertinent coverage criteria are those related to thread interleavings .
computing the complete set of dynamically covered interleavings for all the generated tests would be too computationally expensive.
furthermore instrumenting shared memory accesses to collect the covered interleavings would introduce delays that could prevent the manifestation of the fault revealing interleavings.
we do not compare the number oftests generated by each technique because it can be misleading since the length of method call sequences in a concurrent test can varyalotacrosstechniques.forexample autocontestgenerates longsuffixes whilecontegeshortones.moreover sequential test basedtoolsdonotreportalltheconcurrentteststhattheygenerate but only those that they deem as fault revealing.
we manually analyzed the results of each run to identify unsuccessful and successful runs.
we checked the relations of all thread safetyviolationsreportedbythetoolswiththeconcurrency faults under analysis by relying on both the bug report and themanually written concurrent test.
it is important to clarify that wedonotrequiretheautomated generatedconcurrenttestsand thecorrespondingmanually writtenteststobeidentical sinceoften the same concurrency fault can be manifested with different concurrent tests.
.
results table4summarises the results of our experiments by providing fault finding and execution time data for all subjects.
the first and thirdcolumnspresentthecategoryandtheidofeachfault respectively asdefinedbythecuratorsofthejacontebebenchmark .
the second column indicates the type of failure that manifests the fault when executing the manually written test.
thesubjectsareorderedbythefirstandsecondcolumns.the remaining columns show the results for each tool by indicating four possible outcomes i the tool detects the fault check with the number of successful runs that detected the fault and the average detectiontimeofsuccessfulruns ii thetoolcrashes iii the tool does not generate any test iv the tool generates tests but authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
effectiveness and challenges in generating concurrent tests for thread safe classes ase september montpellier france table summary of fault finding results for each tool and jacontebe fault fault category failure type fault id contege contegejpf autocontest covcon covconjpf omen narada intruder inconsistent synch.endless loop dbcp4 logic pool5 race atomicity violationsendless loop groovy6 check sec.
runtime exceptiondbcp3 derby3 groovy1 groovy3 groovy4 jdk6 3 check sec check sec check sec check sec jdk6 4 check sec check sec check sec check sec jdk6 13 check sec check sec check sec check sec jdk7 3 log4j 3 check sec check sec check sec check sec check sec pool1 logicgroovy5 jdk6 1 jdk6 2 jdk6 5 jdk6 14 jdk7 1 jdk7 6 log4j 1 check sec.
resource deadlockendless hangdbcp1 dbcp2 derby1 derby2 derby4 derby5 groovy2 jdk6 6 jdk6 7 check sec.
jdk6 8 jdk6 10 check sec.
check sec.
jdk6 11 jdk6 12 jdk7 2 jdk7 4 log4j 2 wait notify deadlockendless hangjdk6 9 jdk7 5 log4j 4 log4j 5 lucene1 lucene2 pool2 pool3 pool4 summary faults detected average time sec sec sec sec sec sec sec does not detect the fault the last row in table 4summarize theresultsforeachtoolasnumberofdetectedfaultsandaverage detection time.
as discussed in section .
the surveyed techniques rely on different interleaving explorers and thread safety oracles to detect faults of specific categories and failure types.
in table a gray backgroundindicatesthefaultsthatarenotdetectablewithsome tools by either the interleaving explorer or the thread safety oracle adopted by the tool.
covcon contege covconjpf and contegejpfuseinterleavingexplorersthatarenotlimitedtoanyfault category thus they can potentially detect all faults in jacontebe butrelyonimplicitoraclesthatcandetectonlyfaultsthatmanifest exceptionsorendlesshangsastypeoffailure.therefore thesetools coulddetectatmost ofthejacontebefaults.omencandetect only resource deadlocks faults and endless hang failures which amountof34 ofthejacontebefaults.autocontest narada andintruderrelyoninternaloracles whichdonotimposeany restrictionsonthefailuretype butrelyoninterleavingexplorers andoraclesthatarelimitedto race atomicity faults whichamount of ofthejacontebefaults.weexecutedalltoolsonallthe subjects eventhecombinationswiththegraybackground since someconcurrencyfaultscouldmanifestwithfailuretypesdifferent from the ones specified in the jacontebe benchmark.
effectiveness.
contegedetectsfivefaultsthatbelongtotwo differentcategories andthatleadtofailuresofthreetypes.itdetects groovy6 which is not detected by any other tools.
contegejpfdetects three of the faults detected with contege.
autocontest detects two atomicity violations.
covcon detects six faults of two categories and two failure types detecting more faults than any othertool.covconjpfdetectsfourofthefaultsdetectedbycovcon.
omen does not detect any fault.
narada detects one fault log4j 1 which is not detected by any other tool.
intruder detects the fault log6 3 which is also detected by three other tools.
autocontest narada and intruder detect the faults in all the ten runs showingstabilitywithrespecttonon determinismcomparing withtheothertools whichhavealowerfaultdetectionrate.itis worthmentioningthat forsomefaults autocontestcrashesdue toincompatibilityissueswiththeinstrumentationframeworkused to compute the coverage.
for subjects dbcp1 dbcp2 derby1 derby2 andderby4 most of the tools including randoop fail to generate anyteststhatsuccessfullyinstantiatetheclassundertest which requires a complex method call sequence.
efficiency.
the overall detection time varies from seconds for subject log4j 3to seconds for jdk6 13. covcon is the fastestamongthefourtoolsthatdetectedatleastthreefaults with anaveragedetectiontimeof198seconds seelastrowintable followed by contegejpf seconds covconjpf seconds andcontege 780seconds .the readersshouldnotice thatcontegejpf and covconjpfdetect thefaults faster thanthe original configurations despitethefactthatjpfiscomputationallymoreex pensivethantherandominterleavingexplorationof contegeand covcon.thisisbecausecontegejpfandcovconjpfexplored authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france valerio terragni and mauro pezz table common issues and their distribution across the subjects problems percentage faults ids invalid assumptions .
dbcp derby groovy log4j lucene1 jdk6 jdk7 invalid assumption two threads only .
groovy log4j lucene1 invalid assumption one shared object only .
dbcp derby groovy6 jdk6 7 jdk7 4 log4 2 invalid assumption no static invocations .
dbcp3 groovy6 jdk6 jdk7 log4 2 environmental dependencies .
derby1 groovy jdk6 jdk7 lucene inadequacy for wait notify .
jdk6 9 jdk7 5 log4j lucene pool theinterleavingspaceoffewertestsbeforeexposingthefault.this suggests that the random interleaving exploration of contege and covcon easily miss failure inducing interleavings even if the generated test can manifest one.
alltoolsreportsomethread safetyviolationsunrelatedtothe faultsunderanalysis whichmightormightnotbetrueconcurrency faults.contege covcon contegejpfandcovconjpfreport aunrelated concurrentmodificationexception forjdk6 7 jdk6 10 andjdk6 11. intruder and autocontest detect the jdk6 3fault and also report unrelated atomicity violations when analyzing this subject.
omen detect an unrelated deadlock for jdk6 4. automated concurrent test generators find of the jacontebe faults and none of them alone finds more than of the faults.
the average fault detection time ranges from 15to2 617seconds.
results analysis and discussion theexperimentalresultsthatwediscussedintheprevioussectionindicatelimitedcomplementarityamongtheconcurrenttest generators halfofthedetectedfaultsarerevealedbyatleastfour differenttools.theresultsalsoindicatesomeoverallincompletenessofthecurrentapproaches since83 oftheconcurrencyfaults in the jacontebe benchmark are not detected by any tool.
the absence of effective oracles is not the main reason of many undetected faults.
in fact the combinations of failure types and fault categories that characterise each subject of the jacontebe benchmark withtheonlyexceptionof pool5 canberevealedbythe interleavingexplorerandthread safetyoracleofatleastthreetools see table .
this confirms that while automatically generating effective test oracles is a major challenges faced by sequential test generators generatingoraclesforconcurrenttestsis less critical lu et al.
shown that of concurrency faults lead to exceptions or hangs .
moreover yu et al.
proved that internal oracles are effective in detecting those concurrency faults that do not manifest visible oracle violations .
we manually analyzed the results of the experiments to identify andbetterunderstandwhythetoolsfailtoexposetheconsidered concurrency faults.
we relied on the manually written tests in jacontebe to learn the characteristics of the concurrent tests that find faults that are not revealed with automatically generated tests.
weidentifiedthreemainissuesrelatedtoconcurrenttestgeneration invalid assumptions environmental dependencies and inadequacy for wait notify as shown in table .
each subject can suffer from more than one issue.
.
invalid assumptions allsurveyedtechniquesreducethesearchspaceandfacilitate faultdetection byrelying onsome predefinedassumptions onthe concurrentteststhattheygenerate twothreadsonly oneshared objectonlyandnostaticinvocations.ourresultsindicatethatabout of the faults in the jacontebe benchmark cannot be revealed without violating at least one of such assumptions see table .
assumption1 exactlytwoconcurrentthreads.
allsurveyed techniques generate concurrent tests with exactly two concurrent suffixes following the lu et al.
s study that shows that of concurrency faults can be manifested by enforcing a certain partialorder between two concurrent threads only .
by inspecting the failure inducing tests in the jacontebe benchmark we observe that .
spawn two concurrent threads only.
this is an under approximation becausesometestsaredesignedaccording to a stress test methodology which spawns many identical threads forincreasingthechancetotriggerafault revealinginterleaving.
thus some of the faults revealed with tests with more than two concurrentthreadsmaybealsorevealedwithtestswithonlytwo concurrentthreads.werefinedthestudybymanuallyidentifying thefault revealingteststhatadoptastress testmethodology and concludedthat12.
ofthefaultscannotberevealedwithtests with two concurrent threads only.
it is fairly easy to modify the toolsforgeneratingconcurrenttestswithanarbitrarynumberof suffixes totargetalsofaultsthatcanberevealedonlywithmore thantwoconcurrentthreads butitmaydramaticallyimpactonthe performance and effectiveness of the tools.
assumption at most a shared object instance.
most surveyed techniques generate concurrent tests that access from multiplethreadsonlyonesharedobjectoftheclassundertest according to the intuition that accessing a single shared object is enough totriggerfaultsrelatedtoconcurrentaccessestosharedmemory locations5.
however in some cases two or more object instances althoughdistinct mayaccessthesamememorylocations andthus they could trigger concurrency failures.
such failures cannot beexposed with tests that instantiate a single shared object.
for instance in thefault revealingconcurrenttest ofthesubject derby5 in figure the concurrent execution of the suffixes leads to a concurrency failure even if the two suffixes do not access the same sharedobject buttwodifferentobjects basecontainerhandle and storedpage .
this happens because the setter methods in the sequentialprefixmutuallyseteachotherreferences line4and5in figure4 .
by inspecting the jacontebe benchmark we observe that assumption is violated in .
faults.
5onlycontegeandcontegejpfgenerateteststhataccessmorethanoneshared object.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
effectiveness and challenges in generating concurrent tests for thread safe classes ase september montpellier france sequential prefix ... omitted for brevity ... 4storedpage.setexclusive basecontainerhandle 5basecontainerhandle.addobserver storedpage 7newthread new runnable public void run basecontainerhandle.close suffix .start newthread new runnable public void run storedpage.releaseexclusive suffix .start figure manually written test of the subject derby5 showing the case of two shared variables.
assumption only non static methods.
all techniques but contege and contegejpf generate concurrent tests that invoke non staticmethodsofsharedobjectinstancesonly followingtheintuition that most concurrency faults derive from incorrect accesses to dynamic instances.
however some jacontebe concurrencyfaults are exposed only with concurrent tests that either invoke staticmethodsoraccesspublicstaticfields.byinspectingthejacontebe benchmark we observe that assumption is violatedin .
faults.
only contege detects the fault groovy6 which requires the invoking of static methods see table .
.
environmental dependencies a major challenge in generating both sequential and concurrent tests is to properly instantiate environmental dependencies to suitably exercise method call sequences for instance create certain files or database connections.
for example the fault revealing concurrent test for subject jdk6 6in figure 5requires a specific folder structure in the file system.
classic tools for generating sequential testssimulatedependenciesonfilesanddatabaseconnectionswith mocking techniques .
combining concurrent test generators with such techniques may address the environment dependency issues that account for .
of the jacontebe faults.
.
inadequacy for wait notify a relevantaspect of shared memorysynchronization is theuse ofsharedobjectstopassmessages threadsblocktheirexecution waitingto receive messagesfromother threads.
thismechanism is implementedwithprimitives wait notify andnotifyall in java6andwait signal andbroadcast inc .
none of the surveyed techniques supports such mechanism and therefore none generates concurrency tests that can expose failuresinvolvingtheexecutionof waitandnotify.thetwo step concurrent test generation approach illustrated in figure 3and implemented by all the techniques cannot address waitandnotify relatedfailures.thegeneralapproachworksasfollows step1gen eratessingle threadedmethodcallsequences andstep2assembles such sequences in concurrent tests.
step executes each newlygenerated sequence and discards those that either throw excep tions or hang indefinitely.
such sequences are neither extendednor used to assemble new concurrent tests since they are likely 6from java .
the mechanism is also implemented with await signal in thejava.util.concurrent package.
sequential prefix 2finalstring dira projectbase base a 3finalstring dirb projectbase base b 5newthread new runnable public void run file file newfile dira suffix file.mkdirs .start newthread new runnable public void run file file newfile dirb suffix file.mkdirs .start figure manually written test of the subject jdk6 2 showing the case of the environmental dependencies problem.
illegal .discardingsequencesthathangindefinitelyonasinglethreadraisesanissueinthepresenceof waitinvocations ifa method invocation of the class under test puts the executor thread onanobjectwait thenthesequentialtestgeneratorcannotcalla newmethodonadifferentthreadthatwillwakeuptheexecutor a time out exception is raised and the sequence is discarded.
asa result all the concurrent tests that contain invocations of wait arediscarded.however theexecutionof waitisessentialtotrigger wait notify deadlocks.
wait notify faults amount to of the jacontebe subjects.
threats to validity relevant threats to the validity of the results derive from the choice of the subjects the time budget for the experiments the selection of auxiliary classes and the choice of configuration options.
choice of the subjects.
we refer to faults present in opensource java projects and this may not generalize to all programminglanguagesandprogramcharacteristics.generalisingtheresults would require extending the techniques originally defined for java programs to a suitable variety of concurrent programming languages.
time budget for the experiments.
the time budgets of the experimentmayimpactonthenumberofdetectedfaults increasing thetimebudgetmayleadtodetectmorefaults.thenatureofthe undetected faults discussed in table 5and the characteristics of theevaluatedtechniquesindicatethatformanycasesnotechnique would detect any additional faults even with an unlimited time budget.
in our experiments we set the time budget to an hour per subject according to the experiments of the most recent of the surveyed techniques .
selection of auxiliary classes.
we select the auxiliary classes byrelyingonfault triggeringmanually writtentestsprovidedin the jacontebe benchmark.
the existence of such tests nullifies theneedofrunningconcurrenttestgenerators butitisusefulin theevaluation sinceitprovidesasetofauxiliaryclassesthatare sufficient for revealing the fault.
configurationoptions.
theconfigurationoptionsofthetools and the setup of the execution environments may impact on theeffectivenessoftheconsideredtools.wemitigatedthisthreatby comparingthepossibleconfigurationoptionsandinspectingthe feedback from the execution environment.
we also verified thatthe tools when executed in our environment were able to detect the concurrency failures reported in the corresponding papers.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france valerio terragni and mauro pezz related work to our knowledge this paper presents the first independent empiricalstudythatevaluates comparesanddiscussesthestate ofthe artgeneratorsofconcurrenttests.bianchietal.
srecentsurvey proposes acomprehensive viewof thestate of the art techniques forconcurrenttesting anddiscussesthetechniquesbasedonthe published papers .
conversely this paper focuses on concurrent testgeneratorsonlyandprovidesimportantadditionalempirical data.
related empirical studies focus either on techniques that explore the interleaving spaces of manually written concurrent tests or on test generators for sequential programs.
thomson et al.
evaluated schedule bounding techniques for systematicconcurrencytesting preparingabenchmarkof52faulty concurrentprograms .linetal.evaluatedinterleavingexploration techniques step and in figure on the jacontebe benchmark giventhemanually writtentestsininput.hong and kim empirically evaluated detectors of data races .
severalempiricalstudiesevaluatedtestgenerationtechniques for sequential object oriented programs .
xiao et al.
inspected the issues that limit test generators tools in obtaining high structural coverage.
they found that the main issues are i dependenciesonexternalmethods and ii findingasuitable methodsequencetoderivedesiredinputobjectstates.shamshiri et al.
compared three popular generators of sequential tests randoop evosuite andagitarone usingthedefects4j benchmark.theyfoundthattheoracle problem remains the major obstacle as .
of the undetected faultswerecoveredby automaticallygeneratedtestsatleastonce.
fraserandarcurievaluatedevosuite onasetofrandomlyselectedopensourceprojects .unsurprisingly sinceaconcurrent testisaconcatenationofsequentialtests someofthechallenges faced by concurrent test generators are inherited from those faced bysequentialtestgenerators.forexample theobjectcreationprob lem in the presence of complex inputs .
the study presented in thispaperraisesadditionalinsightsandchallengesthatarespecific to concurrent test generation.
conclusion and future research directions in this paper we surveyed the main state of the art techniques forgeneratingconcurrenttests andweempiricallyevaluateand compare the ones for which we have been able to access a publicly availabletool.wesurveyedninetechniquesandcomparedsixof them by referring to the jacontebe benchmark.
our resultsshowthatoveralltheevaluatedtechniquescandetect17 ofthe jacontebe faults which is an impressive result if we consider thatthefaultsremainedundetectedforyearsinpopularcodebases many detected faults are in java which runs in over billions devices .currenttestgeneratorscouldhaverevealedthefaultsand avoided their manifestation in the field.
the generation of concurrent tests is a relatively young but promisingapproach.
ourevaluation resultsindicatea largespace for improving its overall effectiveness.
the analysis of the faults that current techniques do not detect yields insights into the main limitations and indicates future research directions adaptive configuration search space reduction and wait notify handling.adaptiveconfiguration.
currentgeneratorsofconcurrenttests work under some predefined assumptions on the tests being generated as discussed in section .
.
these assumptions can drastically reduce the search space thus improving the efficiency of the techniques but can also prevent the generation of fault revealing tests.
sometoolsallowuserstoenable disablesomeoftheseassumptionsintheformofconfigurationparameters .however notoolprovidesupporttounderstandtheimpactofdifferentconfigurations onthefault detectioncapabilityfor agivenprogramunderanalysis.interestingresearchdirectionsarebothstudyingtechniques to automatically identify a proper configuration and defining selfadaptive interleaving explorers.
covcon and contege are examples of toolsthat canbenefit fromself adaptive strategies.both of them execute each test a fixed number of iterations independently from the nature of the test.
the choice of the number of iterations is important since too few iterations may miss a fault revealing interleaving while too many could waste testing resources.
a selfadaptive strategy could identify an optimal number of iterations foratestbyapproximatingthenumberofthreadinterleavingsthat can be manifested when executing the test itself.
intuitively thenumber of iterations should grow proportionally with respect to suchnumber.luetal.
sformulascouldprovideusefulhintsfora cost effective way to compute such approximations .
search space reduction.
concurrent test generators explore a huge space of tests when generating concurrent tests.
given a classundertest itoftenexistsamyriadofpossiblecombinationsof method invocations and input parameters.
generating all possible testsandexploringtheirinterleavingspaceswithinanaffordable time budget remain infeasible.
an interesting research directionistodefineapproachesthatidentifymethodsthatcannotleadto athread safetyviolationifassembledinthesameconcurrenttest beforegeneratingthetests.generatingconcurrentteststhatinvolve such methods can be avoided without affecting fault detection capabilities.
wait notifyhandling.
asdiscussesinsection .
currenttechniques cannot generate tests that expose wait notify concurrency faults.
to size the impact of this limitation we observe that searchingfor.wait and .notify ingithub.com produces 60millions coderesults.using wait notify synchronizationprimitivesisnota matter of code style since their synchronization behaviour cannot besimulatedusingothersynchronizationprimitiveslikelocks .
an important research direction is to update the four steps framework for concurrent test generation presented in figure .
for instance by recombining all steps to enable simultaneous test generationandinterleavingexploration.testgeneratorscouldgenerate and execute method call sequences on multiple threads simultaneouslysothat ifa waitisexecutedputtingtheexecutingthreadina suspended state another thread can unblock the suspended thread by generating and executing another method call sequence.