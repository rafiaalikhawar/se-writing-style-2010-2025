automated partitioning of android applications for trusted execution environments konstantin rubinov1 lucia rosculete2 t ulika mitra3 abhik roychoudhury3 1deepse group at deib politecnico di milano italy 2application threat intelligence ixia romania 3school of computing national university of singapore singapore email konstantin.rubinov polimi.it luciarosculete gmail.com tulika abhik comp.nus.edu.sg abstract the co existence of critical and non critical applications on computing devices such as mobile phones is becoming commonplace.
the sensitive segments of a critical application should be executed in isolation on trusted execution environments tee so that the associated code and data can be protected from malicious applications.
tee is supported by different technologies and platforms such as arm trustzone that allow logical separation of secure and normal worlds.
we develop an approach for automated partitioning of critical android applications into client code to be run in the normal world and tee commands encapsulating the handling of confidential data to be run in the secure world.
we also reduce the overhead due to transitions between the two worlds by choosing appropriate granularity for the tee commands.
the advantage of our proposed solution is evidenced by efficient partitioning of real world applications.
.
introduction mobile devices have seen the emergence of services that require an increased level of security e.g.
online banking premium content access enterprise networks connection .
at the same time these devices adopt open software platforms allowing consumers to install arbitrary third party applications capable of compromising the critical services.
attackers have responded by investing in exploiting the growing number of such vulnerabilities to gain access to valuable data .
as a countermeasure device manufacturers take a scalable approach to security through hardware protection measures factored in early in the design process.
for example arm trustzone is designed to support trusted execution environment tee a small secure kernel that shares the processor with a rich os e.g.
android .
tee provides hardware enforced security to authorized software trusted applications protecting them from malware in the rich os.
most of this work was done while the first two authors were affiliated to national university of singapore.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citationon the first page.
copyrights for components of this work owned by others than acmmust be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or afee.
request permissions from permissions acm.org.
icse may austin tx usa c circlecopyrt2016 acm.
isbn .
.
.
.
though tee provides security guarantees against strong attacks few applications employ this technology.
enhancing existing mobile applications with tee requires identificationofconfidentialdataandalltheoperationsassociated with this data in complex android applications.
even for in house applications this task can prove daunting in the context of java deep class fields and aliasing.
we propose to fortify existing android applications by automatically partitioning them with respect to their data pro tection needs.
the partitioning abstracts java code segmentsthat manipulate confidential data into candidate trusted applications to be executed in the secure world with higher privileges isolated from less privileged malicious or hijacked applications running in the rich os.
ourapproachautomaticallyanalyses partitions andtransforms existing applications for deployment of their confidential data and computations on tee as trusted applications.
it automates the laborious and prone to human error tasks such as detection of application paths that propagate and operate on confidential data application partitioning in the presence of control dependent secure information flow extraction and grouping of confidential fragments of application and interfacing between the normal and secure worlds.
the approach is suitable for complex real life applications with extended inter procedural inter class secure information flow.
the analysis is precise it extends context and fieldsensitive taint analysis of flowdroid .
the refactored app preserves application semantics satisfies an unidirectional tee execution model and maintains a minimal trusted computing base tcb 1after the addition of trusted applications.
field sensitive analysis produces safe data handles opaquepointers toenforceinformationhidingwhileallowing the rich os to reference confidential data and thereby reduce the unnecessary communication between the two worlds.
our automated partitioning framework takes in an application binary as input and outputs the source code of the refactored application with privileged instructions isolated as static java methods.
presently we require the developer to manually convert these java methods to trusted applications in native code.
but our approach facilitates deploymentof trusted applications through automatic generation of auxiliary tee specific code for establishing interaction between normal and secure worlds.
in the future we plan to takeadvantage of available java to c language translators for transformation of java methods to native code.
our solution guarantees data integrity i.e.
data cannot be modified in an unauthorized or undetected manner.
con1tcb a set of components to be trusted to trust a system.
ieee acm 38th ieee international conference on software engineering rich os tee kernel trusted core environment trusted functionstee functional api tee internal api tee functional api tee client apitrusted execution environment rich os application environment hw secure resourceshw keys secure storage trusted ui crypto accelerators nfc controller etc.
client applications urestorage ure storage cli a li i trusted application drm trusted application payment trusted application corporate hardware platform figure tee system architecture fidential data and computation on these data reside only in tee confidential data can reside in rich os only in encrypted form.
any data accessed through peripherals under control of tee is confidential while any data returned to rich os is not as it can be leaked to unauthorized users .
the approach allows for controlled release of declassified information.
execution of trusted applications in tee may affect execution of applications in rich os however execution in rich os cannot interfere with the execution in tee.
we evaluate our approach with real world android applications and micro benchmarks.
evaluation results highlight the effectiveness of our approach in automatically partitioning complex applications and variety of flow situations arising in android applications.
trusted applications maintain a small tcb size of approximately lines of code loc and low communication overhead.
overall the approach enables confidentiality and integrity enforcement through code transformation while substantially reducing development efforts.
.
background ourapproachfacilitatesapplicationdevelopmentandtransformation for trusted execution environment built using armtrustzone.
armtrustzonetechnologyoffersasystemwidesecuritysolution partitioningthehardwareandsoftware resources so that they exist in one of two worlds secure worldfor the security subsystem and normal world for everything else .
this is achieved with a set of protective measures integrated in the arm processor core memory management unit and the amba axi bus.
despite wide availability of proprietary implementations of tee for platforms with arm trustzone hardware extensions there are few android applications that leverage this technology due to the lack of standardization.
this issue is addressed by global platform that developed the standard for managing applications on secure chip technology and a set of specifications for the tee system architecture .
the overall tee system architecture is shown in figure .
tee offers safe execution of authorized software known astrusted applications tas .
a ta is composed of tee commands that collectively provide secure services to the clients of the ta while enforcing confidentiality integrityand access rights to the resources and data.
each ta is independent and protected against unauthorized access from other tas allowing an ecosystem of application providers.
tas can access security resources and services such as keymanagement cryptography secure storage secure clock trusted display and trusted virtual keyboard via the tee internal api .
client applications running in the rich os can access and exchange data with tas via tee client api.
our main contribution is to automatically extract application segments to be deployed as tee commands in ta.
we automaticallygeneratetheauxiliarycodetoinvokebothtee client api from rich os and tee internal api from tas to provide secure services and establish connection between the trusted and un trusted application segments.
the deployment of tas requires careful analysis of the capabilities and the constraints inherent to the tee.
a critical constraint imposed by tee is that ta contributes to the tcb size which should be kept as small as possible to reduce security risks .
thus ta code should be minimized.
another constraint is imposed by the unidirectional comm u n i c a t i o nb e t w e e nc l i e n ta n dt a s .r i c ho si n i t i a t e st h e communication whereby the processor switches to the secure world executes tee command and finally switches back to the normal world.
tas cannot perform callbacks to the client code.
this constraint is especially challenging in the face of complex control flow and os and ui related operations in android.
.
overview an overview of our approach is shown in figure .
the approach builds on several insights that enable extraction of minimal code fragments to tee and semantic preserving transformation of the application code.
we highlight the intuition behind our approach using a real life example an open source application google authenticator .
the app supports one time password otp security tokens for two factor authentication and implements the hmac based hotp and the time based totp otp generation algorithms.
google authenticator uses either qr code scanning or manual input to obtain an encoded security key issued by google.
the key is decoded and used to calculate a message authentication code mac of a timestamp or a counter to generate otp.
the confidential data in the app includes security key user account information and program state including program clock and an internal counter.
for our example the engineer would first want to protect the confidentiality of the security key by protecting e n t r yp o i n t so ft h ek e y i t sm a n i p u l a t i o na n ds t o r a g e .
manual inspection of the example revealed that the sensitive data and operations are distributed in six medium to large classes of the application.
these are highly uidependent classes with complex control flows owing to the event based nature of the app.
there are more than one hundred methods and over .6k lines of code loc involved in the propagation of the security key across the classes.
analysis and protection of code fragments of this size and complexity require a systematic approach.
the situation is exacerbated by the presence of overlapping flows of sensitive data from different contexts a security key coming from a qr code scanning and from manual key entry.
the multiple entry point components of an android app make it difficult to establish whether extraction of a specific code fragment affects different application flows.
manual transformation of such an app to deploy sensitive operations and data on tee is not trivial.
924sources sinks android app cfg and tags partitioning framework classify context analysis candidate program locations trusted app generation grouping control flow analysis code synthesis taint assign taint array i1 lengthof r1 i1 i1 i0 specialinvoke r0.
java.lang.object void init code fragments 4refactored android app native trusted apps taint analysis flowdroid program annotation trusted app translationnative code wrapping figure an overview of the approach our approach does not require the engineer to inspect the complete application to identify critical or non critical segments thereby relieving him her of the laborious and error prone task.
the approach starts with an automated context sensitive taint analysis to track propagation of the confidential data in the program phase 1in figure .
it collects the intermediate analysis data and results and feeds them to our automated partitioning framework that generates candidate code segments to be deployed as tee commands of a trusted application and refactors original app integrating in it tee command invocations phases 3and4 .
gray areas in figure highlight the external in phase1 or manually supported components in phase .
the approach builds upon and extends the state of the art static taint analysis of flowdroid specifically designed for confidential data leak detection in android applications.
it is lifecycle aware and implements context and field sensitive information flow analysis building on an ifds framework .
taint analysis detects confidential data leaks as propagation of tainted information through the system fromso called sourcesthat introduce confidential data into the system to the sinksthat expose the data to an unprotected environment.
in the scope of our approach developer is only required to indicate the sources of confidential data in the application through program annotations.
any method that reads and returns confidential data is a source.
in the google authenticator example an engineer needs to protect the security key entry and manipulation and indicates two sources intent.getstringextra scan result for obtaining qr code scan result and getenteredkey for getting a manually entered key.
these sources will be transformed into a tee controlled virtual keyboard service to manually enter the key and a secure qr scanner service that uses a tee controlled camera respectively.
asinkin our approach is defined for several situations where confidential data extends beyond the control of the application.
in other words a sink writes confidential data into a resource that can be accessed or controlled outside the application.
in android os such resources include screen network connection storage etc.
in addition specific to android os the data extends beyond the control of the app when one component such as activity of the app communicates with another component of the same app which is not safe any data passed to the rich os can be leaked to unauthorized users.
forgoogle authenticator the taint analysis identifies that the security key flows through six application classes from the sources to a local app database and then depending on the scenario through an otp value to the sinks a text field to be displayed on a screen or to the system clipboard.
we then use the analysis results in the application partitioning algorithm represented by phase 2in figure .
thealgorithm implements our observation that in real world applications a large portion of statements do not process data but only transfer data along secure information flow paths.
for instance in google authenticator ak e yr e a d s t o r efl o w traverses seven methods in three classes where only onemethod getenteredkey processes the data while none of the other methods operates on the confidential data.
our insight is that such a transfer code does not require transformation can remain in rich os and operate on surrogate data unique opaque