craig vs. newton in software model checking daniel dietsch university of freiburg dietsch cs.uni freiburg.dematthias heizmann university of freiburg heizmann cs.uni freiburg.debetim musa university of freiburg musab cs.uni freiburg.de alexander nutz university of freiburg nutz cs.uni freiburg.deandreas podelski university of freiburg podelski cs.uni freiburg.de abstract ever since the seminal work on slam and blast software model checking with counterexample guided abstraction refinement cegar has been an active topic of research.
the crucial procedure here is to analyze a sequence of program statements the counterexample to find building blocks for the overall proof of the program.
we can distinguish two approaches which we name craig andnewton to implement the procedure.
the historically first approach newton named after the tool newton from the slam toolkit is based on symbolic execution.
the second approach craig is based on craig interpolation .
it was widely believed that craig is substantially more effective than newton.
in fact out of the cegar based tools in sv comp are based on craig.
advances in software model checkers based on craig however can go only lockstep with advances in smt solvers with craig interpolation.
it may be time to revisit newton and ask whether newton can be as effective as craig.
we have implemented a total of variants of craig and newton in two different state of the art software model checking tools and present the outcome of our experimental comparison.
ccs concepts software and its engineering formal software verification mathematics of computing interpolation keywords formal verification craig interpolation unsatisfiable cores acm reference format daniel dietsch matthias heizmann betim musa alexander nutz and andreas podelski.
.
craig vs. newton in software model checking.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn .
.
.
.
introduction ever since the seminal work on automatic predicate abstraction of c programs in the slam toolkit software model checking has been an active topic of research .
there have been several variations but the basic idea of counterexample guided abstraction refinement cegar remains often the same.
the idea is to use the correctness proof of a sequence of program statements the spurious counterexample to find building blocks for the overall proof of the program.
the building blocks often called predicates are extracted by a procedure that de assembles the correctness proof of the sequence of program statements.
it is this procedure which is crucial for the effectiveness of cegar based software model checking.
it is crucial because without finding the right predicates the cegar loop must diverge the predicates extracted so far must be sufficient to assemble a correctness proof of the program .
in this paper we present an experimental assessment of two possible approaches which we name craig andnewton respectively.
the name newton refers to a variant of the approach which was implemented already in newton .
the original version of newton is based on symbolic execution here the symbolic execution of the sequence of statements in the counterexample .
historically newton is the first approach for extracting predicates from counterexamples.
it was used also in the first version of blast .
however a subsequent version of blast introduced the approach which is based on craig interpolation .
since then it was widely believed that craig is substantially more effective than newton.
in fact out of the cegar based tools in sv comp are based on craig .
the rationale is that in contrast with newton craig can discover the right predicates that go beyond the syntax of the program.
the work on impact in has shown that the predicates produced by an smt solver with craig interpolation can even be used directly i.e.
without disassembling them further as it was done in slam and blast following the scheme of predicate abstraction .
their use as a module in software model checkers has been a major motivation for very active research on smt solvers with craig interpolation see e.g.
with more and more support for theories to cope with data structures such as arrays and floats .
it must be said however that the support of theories in procedures for craig interpolation generally lags behind relative to procedures for checking satisfiability .
hence it may be time to revisit newton and ask whether newton can be as effective as craig.
we have implemented a series of variants of software model checking which arise from different variants of the two approaches.
esec fse september paderborn germany d. dietsch m. heizmann b. musa a. nutz a. podelski procedure example1 var a b bool var p x int l0 b a l1 x while l2 havoc p l3 assume !a l4 a true l5 x x l6 a false assert a b l0 l1 l2l3 l4 l5 l6 lerrb a x 0havoc p!a a true x x a falsea!
b figure code and control flow graph of a program.
the variables aand bare arrays with integer indices and boolean values.
the condition of the while loop represents a nondeterministic choice.
the specification is given by the assert statement in the last line and states that the arrays aand b store the same values.
this allows us to compare them in an experimental evaluation.
in both approaches craig and newton we can translate a sequence of statements here from the possibly spurious counterexample to an conjunction of logical formulas the conjunction is unsatisfiable if the counterexample is spurious .
craig then computes a sequence of craig interpolants along the conjunction using an interpolating smt solver and considers each interpolant as a predicate at the corresponding position of the statement sequence.
newton uses thepost orwp predicate transformer instead of craig interpolants to compute predicates for each position.
as expected this leads to rather concrete predicates which are mostly useless for complex programs.
thus instead of applying the predicate transformer directly on the counterexample newton first computes an abstraction of the counterexample.
the crux is to find a coarse abstraction that is precise enough to preserve the spuriousness of the counterexample.
in our implementation the abstraction is computed by projecting all statements away that are not contained in the unsatisfiable core of the logical formula of the full counterexample.
example we will give a formal account of the newton approach in the version presented in and variants in the subsequent sections.
in this section we give an example to illustrate the approach.
figure shows a condensed version of a larger verification problem encoding the check whether a c program has a memory leak .
the array astores which addresses on the heap are allocated.
its indices are pointers and its values are booleans.
the statements at the locations l2 l4encode memory allocation.
a non deterministic address havoc p that is not yet allocated !a is taken and it is stored that this address is now allocated a true .
the statement at the location l6encodes memory deallocation it stores that the address pis not allocated anymore a false .
this program is written in the boogie language.
hence the statement at l0assigns to the array ba copy of the array a. the assertstatement at the end holds if the array aand the array bstore the same values at the same positions i.e.
if each allocated memory cell was deallocated.
following the algorithm of a model checker we analyze the correctness of this program as follows.
first we pick some error trace i.e.
some sequence of statements that starts at the initial location and ends at the error location .
let us take the trace depicted in the first column of figure which takes the while loop once.
we analyze this trace and find that it is infeasible.
next we construct a proof for the infeasibility of this trace and try to generalize this proof to an infeasibility proof for all error traces of this program.
a naive approach for this generalization is computing a sequence of assertions along this trace using the post operator.
the resulting sequence of state assertions is depicted in the second column of figure .
the assertion 7before the statement a!
b does not imply the state assertion 2after the statement x .
hence the state assertion 2is not a loop invariant and we fail to generalize this infeasibility proof.
now we augment the generation of state assertions by exploiting unsatisfiable core information that we can get from the smt solver.
first we detect the core reason for the infeasibility of by constructing the trace formula for the trace and using an smt solver to compute an unsatisfiable core of this formula.
here the unsatisfiable core does not contain the conjuncts of the trace formula that correspond to the two assignments to x st2andst6 .
we conclude that both statements are irrelevant for the infeasibility of and construct an abstraction of the trace .
this abstraction is depicted in the third column of figure and obtained by abstracting each statement that is irrelevant for the infeasibility of x and x x by havoc x .
we call the trace an infeasible core of since it abstracts only to an extent that preserves a reason for infeasibility of .
next we use the post operator to compute a sequence of assertions along the infeasible core .
the resulting sequence is depicted in the last column of figure and satisfies the following three properties.
the assertion 7implies the assertion 2 i.e.
2is a loop invariant.
the last assertion is false.
this means that this sequence of assertions is a proof for the infeasibility of .
since the infeasible core is an abstraction of the trace this sequence of assertions is also a proof for the infeasibility of .
from these three properties we conclude that all error traces of the program depicted in figure are infeasible and hence the program is correct.
note that the statements x and x represent the case where some statements make it difficult to find a loop invariant but do not affect the correctness of the program.
in general more statements are irrelevant for the infeasibility of a trace.
inductive sequence of assertions for a trace in this section we fix the notation and the terminology for the central notion discussed in this work which is a sequence of assertions that represents a proof for the infeasibility of a trace.
488craig vs. newton in software model checking esec fse september paderborn germany trace b a st1 x st2 havoc p st3 !a st4 a true st5 x x st6 a false st7 a!
b st8state assertions for true 0 a b 1 a b x 2 a b x 3 a b x a f alse 4 a b x a true 5 a b x a true 6 a b x a f alse 7 f alse 8interpolating trace b a havoc x havoc p !a a true havoc x a false a!
bstate assertions for true 0 a b 1 a b 2 a b 3 a b a f alse 4 a b a true 5 a b a true 6 a b a f alse 7 f alse 8 figure the first column shows a trace taken from the program in figure .
the third column shows an infeasible core of the trace .
this abstraction of is obtained by abstracting x by havoc x and x x by havoc x .
the second and the last column show the sequence of state assertions obtained by iteratively applying post to the and respectively.
in both columns the sequences are slightly interleaved to emphasize that assertion iholds after the execution of statement sti.
in our formal presentation we consider a programming language that consists of three different types of statements namely assume statements denoted by assume where is a boolean expression over the set program variables var assignment statements denoted by x e where xis a program variable an eis a expression over the set of program variables and havoc statements denoted by havoc x where xis a program variable.
the havoc statement assigns non deterministically some value to a variable and is used e.g.
to model input that is read during a program execution.
we represent an assert statement by an assume statement whose successor location in the control flow graph is an error location.
we use first order formulas over program variables to denote assertions.
each statement has the usual semantics which we can define formally using the post operator.
post assume post x e x0.x e where x0is a fresh variable post havoc x x. we call a sequence of statements st1 .
.
.
stnatrace .
given a trace we define the sequence of assertions that we obtain by applying the post operator successively along the statements in the trace starting with the assertion true.
definition .
sequence of assertions computed by post for a trace .
the sequence of assertions computed by post for the trace st1 .
.
.
stnis the sequence 0 .
.
.
ndefined as follows.
0 true i post i sti fori .
.
.
n 1the postcondition of the trace is the last assertion in the sequence above i.e.
post true n. as usual we call a trace infeasible if it does not correspond to a possible program execution.
this is equivalent to the fact that the postcondition of the trace is false i.e.
a trace is infeasible if and only if post true false.
a proof for the infeasibility of a trace can thus be given by the sequence of assertions computed by post for the trace if the trace is infeasible the last assertion in the sequence is necessarily false.
if the trace is of the form st1 .
.
.
stn then the intermediate assertions are of the form post true st1 .
.
.
sti fori .
.
.
n .
we now consider proofs for the infeasibility of a trace in a more general form of sequences where the intermediate assertions can be weaker than post true st1 .
.
.
sti .
definition .
inductive sequence of assertions .
the sequence of assertions 0 .
.
.
nisinductive for the trace st1 .
.
.
stnif the following three conditions hold the sequence starts with true i.e.
0 true the sequence is inductive i.e.
post i sti i 1for i .
.
.
n the sequence ends with false i.e.
n false.
if 0 .
.
.
nis an inductive sequence for the trace st1 .
.
.
stn then post true st1 .
.
.
sti the postcondition of the i th prefix of the trace entails ifori .
.
.
n .
the converse is generally not true.
remark .
a trace is infeasible if and only if the sequence of assertions computed by post for the trace is an inductive sequence of state assertions for the trace.
an example for an inductive sequence of assertions computed by post for an infeasible trace is given in the second column of 489esec fse september paderborn germany d. dietsch m. heizmann b. musa a. nutz a. podelski figure .
we can compute an inductive sequence of assertions via craig interpolation by encoding the sequence of statements as a conjunction of formulas .
infeasible cores in this section we define an abstraction of a trace that is precise enough to preserve infeasibility and we show how we use this abstraction to compute an inductive sequence of assertions.
definition .
abstraction of a statement .
we define the abstraction of a statement stas follows.
abstract st assume true ifstis of the form assume havoc x ifstis of the form x e havoc x ifstis of the form havoc x remark soundness .for each statement stand each assertion the implication post st post abstract st holds.
one may wonder if a skip statement like assume true is also a sound abstraction of an assignment statement.
this is not the case since an assume statement guarantees that no variable is modified.
definition .
abstraction of a trace .
we call a trace st .
.
.st n anabstraction of a trace st1 .
.
.stnif each st iis either the statement stior the abstraction abstract sti .
remark soundness .if the trace st .
.
.st nis an abstraction of st1 .
.
.stnthen the implication post st1.
.
.sti post st .
.
.st i holds for each index iand each assertion .
definition .
infeasible core .
we call an abstraction of an infeasible trace aninfeasible core if is infeasible.
the trace depicted in the third column of figure is an infeasible core of the trace depicted in the first column of figure .
lemma .
.
given an infeasible core st1 .
.
.
stnof an infeasible trace the sequence of assertions 0 .
.
.
ncomputed by post i.e.
0 true i post true st1.
.
.sti is an inductive sequence of assertions for the trace .
proof.
by remark the sequence of assertions computed by post is an inductive sequence of assertions for .
since the is an abstraction of we can use remark to conclude that it is also an inductive sequence of assertions for .
we use remark to prove remark by induction.
.
infeasible cores from unsatisfiable cores given a trace st1 .
.
.
stnwe construct the trace formula fas the conjunction f1 .
.
.
fnwhere each conjunct fiis defined as follows.
fi rename i ifstiisassume xi rename i e ifstiisx e true ifstiishavoc x the function rename i replaces each variable xin the formula by the indexed variable xk where the index kis the last position where xwas modified.
we use the following function index x i to define the index k index x i formally.
index x i ifi i ifstiisx e orhavoc x index x i otherwiseremark .
the trace st1 .
.
.
stnis infeasible if and only if its trace formula f f1 .
.
.
fnis unsatisfiable.
proof.
we show by induction that for all i nthe implicationf1 .
.
.
fi rename i post true st1.
.
.sti holds.
given an unsatisfiable conjunction of formulas f1 fn an unsatisfiable core ucis a subset of conjuncts uc f1 .
.
.
fn such that the conjunction of all conjuncts in the unsatisfiable core ucis unsatisfiable.
we note that an unsatisfiable core is neither required to be minimal nor unique e.g.
the set of all conjuncts f1 .
.
.
fn is always an unsatisfiable core.
next we define our abstraction of an infeasible trace for a given unsatisfiable core of its trace formula.
the idea is to replace each statement in the trace by its abstraction i.e.
havoc orassume true if the unsatisfiable core of the trace formula has dropped the conjunct corresponding to the statement.
definition .
abstract trace for an unsatisfiable core uc .
given an unsatisfiable core ucfor the trace formula f f1 fn of the infeasible trace st1 .
.
.
stn the abstract trace of foruc is the trace st .
.
.
st nwhere the statement st iis defined as follows.
st i sti iffi uc abstract sti otherwise remark .
an abstract trace defined by an unsatisfiable core ucis an infeasible core.
proof.
letf f1 .
.
.
fnbe the trace formula of let uc f1 .
.
.
fn be the unsatisfiable core that defines .
the trace formula of isf f .
.
.
f n where each fiis defined as follows.
f i fi iffi uc true otherwise since the conjunction of all formulas in ucis unsatisfiable the trace is infeasible.
.
backward analysis in this subsection we demonstrate how one can use analogously topost the weakest precondition wpto construct an inductive sequence of assertions.
as usual we define the weakest precondition wpdually to post which means that the equivalence post st wp st holds and for our three kinds of statements the following equalities hold.
wp assume wp x e wp havoc x x. inductively the definition of wpis lifted to traces.
wp st1.
.
.stn wp wp stn st1.
.
.stn remark .
a trace is infeasible iff wp false true definition .
sequence of assertions computed by wpfor a trace .
thesequence of assertions computed by wpfor the trace st1 .
.
.
stn is the sequence 0 .
.
.
ndefined as follows.
n false i wp i sti fori .
.
.
n 490craig vs. newton in software model checking esec fse september paderborn germany var k y int k assume y k while k y y k assert y k y k k y y k y 0true 0 k 1 k y k 2 k y 3 k y 4 f alse 5 figure example program and trace of that program.
note that kis not live at position 2in the trace but it occurs in 2. lemma .
.
given an infeasible core st1 .
.
.
stnof an infeasible trace the sequence of assertions 0 .
.
.
ncomputed by wp i.e.
n f alse i wp f alse sti.
.
.stn is an inductive sequence of assertions for the trace .
live variables we can optimize inductive sequences of assertions based on the idea of live variables.
our goal is to transform the assertion sequence such that it is more likely to contain loop invariants.
figure shows a program on the left and a trace of the program on the right.
next to is the sequence of inductive assertions computed by post.
note that has only one infeasible core which is itself and that neither the assertion 2at the loop entry nor the assertion 4at the loop exit are loop invariants.
furthermore the value of kat position will never be used because it is overwritten by k .
in such a case our optimization existentially quantifies the variable in this assertion.
the resulting formula k.k y k y 0is a loop invariant.
.
future live and past live variables in the following we will introduce the notions of future live and past live variables.
intuitively a variable is future live at a position in a trace if its current value will be read later in the trace.
a variable is past live at a position in a trace if its current value was written or read at an earlier position in the trace.
we say that a statement stwrites a variable x ifsthas the form x e .
we say that a statement streads a variable x ifsthas the form y e or the form assume e where xoccurs in e. we say that the statement havoc x havocs x. definition .
future live and past live .
let st1 .
.
.
stnbe a trace.
we call a variable xfuture live in at position iif there is a statement stjin with j i and stjreads x and for all kwith i k jthe statement stkneither writes nor havocs x. we call a variable xpast live in atiif there is a statement stjin with j i such that stjwrites xor reads x and for all kwith j k i the statement stkdoes not havoc x. we denote the set of future live variables at position iin asfl i and the the set of past live variables atiin aspl i .
formally fl i x var xis future live in ati pl i x var xis past live in ati definition .
projection to future past live variables .
let be an assertion and let v varbe a set of program variables.
let v var vbe the complement of vinvar.
the existential projection of tovis the existential quantification of by all variables in v. ep v v1 .
.
.
vn.
where v1 .
.
.
vn v analogously the universal projection of tovis the universal quantification of by all the variables in v. up v v1 .
.
.
vn.
where v1 .
.
.
vn v lemma .
projection preserves inductivity .
let st1.
.
.stn be a trace.
let a 0 .
.
.
nbe an inductive sequence of assertions for .
then the following two sequences of assertions are also inductive.
ep 0 fl .
.
.
ep n fl n up 0 pl .
.
.
up n pl n proof.
conditions .
and .
are met trivially because quantification has no effect on trueorfalse.post ep i fl i sti ep i fl i is proven by induction and case distinction on the type of the statement sti where we use the following fact.
if the variable x is read at position i 1and there is a k isuch that x is not live at all positions from ktoithen x cannot occur in the subsequence k .
.
.
i. the proof for wp with upandplworks analogously.
algorithm in this section we describe a newton inspired algorithm for computing an inductive sequence of assertions 0 .
.
.
nfor a given infeasible trace st1 .
.
.
stn.
this algorithm comes in eight different variants described by the following steps.
the steps with a bold abbreviation in front of their description are optional.
step is optional for step one may choose a or b and step is optional again.
a can only be applied if a has been chosen and analogously b can only be applied if b has been chosen.
compute trace formula f f1 .
.
.
fnof the trace .
itoptionally let an smt solver compute an unsatisfiable core uc f1 .
.
.
fn for the trace formula f. compute the abstract trace of forucand use it instead of for the remaining computations.
execute one of the following a spcompute post along the trace st1 .
.
.
stn i.e.
set 0totrue and itopost i sti for1 i n. b wp compute wpalong the trace st1 .
.
.
stn i.e.
set ntof alse and itowp i sti for0 i n .
lv optionally and depending on the choice in step .
execute one of the following a for each position i compute the set of future live variables fl i .
project each assertion ito the variables that are future live in at position i. b for each position i compute the set of past live variables pl i .
project each assertion ito the variables that are past live in at position i.
491esec fse september paderborn germany d. dietsch m. heizmann b. musa a. nutz a. podelski implementation and evaluation we implemented the eight newton variations in the software model checkers provided by the open source program analysis framework ultimate1and ran experiments with two state of the art software model checkers ultimate automizer andultimate kojak .
ultimate automizer combines counter example guided abstraction refinement with proof generalization based on automata while ultimate kojak is based on lazy abstraction with interpolants through graph splitting .
we implemented the newton algorithm variants as alternative source of state assertions during the trace infeasibility check of the tool.
both tools can be applied to c programs.
in a first preprocessing step the c program is translated into a boogie program .
afterwards we apply a procedure inlining which allows us to directly handle programs with procedures.
the resulting boogie program uses arrays to model the heap of the system hence an smt solver that supports arrays can be necessary even if the c program does not contain any arrays.
arrays also introduce quantified formulas and since quantified formulas are known to be difficult for smt solvers we implemented various simple preprocessing steps that try to eliminate quantifiers.
the two most noteworthy steps of our partial quantifier elimination make use of the following two facts.
destructive equality resolution der x.x t is equivalent to iftdoes not contain x. unconnected parameter drop upd v1 .
.
.
vn.
1 2is equivalent to 1if 2is satisfiable and each symbol that occurs in 2is an element of v1 .
.
.vn that does not occur in 1or a symbol that occurs in a theory axiom.
for our experimental evaluation we applied both tools to a large set of c programs taken from the repository2of the software verification competition sv comp .
based on those programs we created the following three benchmark sets.
bitvector consists of verification tasks that describe a single reachability problem.
they are taken randomly from the five svcomp subcategories reachsafety arrays reachsafety bitvectors reachsafety heap reachsafety controlflow and systems devicedriverslinux64 reachsafety.
we configured both tools to use a bit precise analysis and the bitvector theory.
integer consists of the same verification tasks as bitvector but this time the tools were configured to use unbounded integers and overapproximate bit wise operations.
hence the theory of bitvectors was not needed.
note that if an overappoximated violation is found the tools give up and report unknown as a result.
memsafety contains verification tasks that require the tools to prove the absence of memory leaks i.e.
memory safety.
they are randomly and evenly selected from the two sv comp subcategories memsafety arrays and memsafety heap.
ultimate s preprocessing encodes the memory safety property as the in equality of two arrays that track the state of the heap of the c program the example from figure shows such an encoding .
a violation of the specification is expressed by the two arrays being different thus often requiring array extensionality.
float contains verification tasks that again describe a single reachability problem.
they represent the sv comp subcategory these programs contain ieee floating point operations and thus require the theory of floating point arithmetic which is notoriously difficult for smt solvers.
furthermore many of the programs do not contain loops.
both tools use two different smt solver instances.
the auxiliary solver is used for simplification and unification of formulas and for other optimizations where an unknown result does not lead to the failure of the whole verification algorithm.
the trace solver is used exclusively to decide feasibility of traces and if enabled to generate craig interpolants that can be used as an inductive sequence of assertions.
we configured both tools to always use z33 as auxiliary solver.
the computation of an inductive sequence of assertions was done by either an interpolating smt solver or one variant of the newton algorithm.
in order to minimize the influence of the solver on the algorithm we compared one variant of newton with different solvers.
we chose smt solvers based on their capabilities and the benchmark set.
princess is unable to compute unsatisfiable cores but supports the theory of arrays and is able to compute craig interpolants.
smtinterpol is able to compute unsatisfiable cores and interpolants but is yet unable to compute interpolants that contain arrays and does not support quantified formulas.
z3is able to compute craig interpolants unsatisfiable cores and supports quantified formulas.
neither princess norsmtinterpol support interpolation for the theory of bitvectors.
the solvers cvc4 and mathsat both support arrays and bitvectors and can produce unsatisfiable cores.
cvc4 can handle quantified formulas mathsat is restricted to formulas that do not contain nested arrays.
hence we used either princess4 smtinterpol5 orz3 for craig interpolation.
for computing unsatisfiable cores we used either cvc46 mathsat7 smtinterpol orz3.
we always used the unsatisfiable core that was provided by the solver after calling get unsat core .
we used version .
r4671 of cvc4 84cb666a6c83 of mathsat build of princess .
327g92cafef of smtinterpol and master bfd1bbc13 of z3.
the hard timeout for all benchmark was seconds.
auxiliary solvers had a time limit of 2s except for the benchmark set float where we increased the limit to 12s due to the complexity of the theory of floats.
each auxiliary solver had a memory limit of 2gb and the software model checkers had a separate memory limit of 6gb.
we ran the benchmark sets on an intel i7 with .6ghz.
.
discussion of evaluation results table shows the qualitative results of the evaluation.
based on these numbers we can see that the newton variant that combines strongest post unsatisfiable cores and live variables it sp lv outperforms craig interpolation on all benchmark sets while being applicable to all scenarios when choosing an appropriate smt solver e.g.
mathsat orz3 .
if we compare the portfolios against each other or z3it sp lv against z3with interpolation we see that variations of newton especially the it sp lv variant can solve substantially more tasks than craig interpolation based techniques.
492craig vs. newton in software model checking esec fse september paderborn germany table the evaluation results.
the columns contain for each tool ultimate automizer andultimate kojak the four benchmark sets and the sum of all four sets.
rows are split into groups.
the first group contains the size of the benchmark sets.
in all following groups each cell contains the number of verification tasks this particular configuration could solve.
the number in parenthesis shows how many tasks were solved exclusively by this configuration.
the second group contains the results for configurations where craig was used as source for inductive state assertions.
the third and fourth group show the results for the different newton variants.
we refer to these variants based on the options we chose with sp or wp and the presence or absence of it and lv.
for it sp lv we prefixed the name with the used trace solver.
the fifth group contains portfolios i.e.
how many verification tasks could be solved by any of the configurations using craig interpolation pcrai it sp lv p it sp lv or all variants pall respectively.
the difference between the total number of tasks and the number of solved tasks is due to timeouts or unknowns.
automizer kojak bitvector integer memsafety float bitvector integer memsafety float no.
of tasks princess z3 smtinterpol cvc4 it sp lv mathsat it sp lv smtinterpol it sp lv z3it sp lv it wp lv it sp it wp sp lv wp lv sp wp pcrai p it sp lv pall cvc4 it sp lv mathsat it sp lv it sp sp lv sp it wp it wp lv wp lv wp z3 z3it sp lv .
.
.
sampleslog s time samplesiterationsiter samples perfect interpolantsperfinter figure ultimate automizer statistics for the benchmark set bitvector .
493esec fse september paderborn germany d. dietsch m. heizmann b. musa a. nutz a. podelski cvc4 it sp lv mathsat it sp lv princess smtinterpol smtinterpol it sp lv it sp sp lv sp it wp it wp lv wp lv wp z3 z3it sp lv .
.
sampleslog s time samplesiterationsiter samples perfect interpolantsperfinter .
.
.
sampleslog s time samplesiterationsiter samples perfect interpolantsperfinter figure ultimate automizer statistics for the benchmark sets memsafety upper three plots and integer lower three plots .
mathsat it sp lv it sp sp lv sp it wp it wp lv wp lv wp z3it sp lv .
.
sampleslog s time samplesiterationsiter samples perfect interpolantsperfinter figure ultimate automizer statistics for the benchmark set float .
nevertheless using craig interpolation allows one to solve certain tasks that could not be solved by any other approach.
for example with z3both tools could solve tasks from the memsafety exclusively.surprisingly the combination of live variables and infeasible cores ic lv is in general not superior over only using infeasible cores ic .
the reason for this are the quantifiers introduced by the live variable projection.
while using live variables it is more likely that more general assertions are obtained however it is also more likely that those assertions contain quantifiers.
z3 494craig vs. newton in software model checking esec fse september paderborn germany is significantly slower if smt queries contain quantified formulas smtinterpol is unable to answer these queries at all.
one important strength of the newton variations is their independence from specific smt theories.
while all selected smt solvers support interpolation for the logics used in the integer set none provide a technique for float .
but contrary to the other benchmark sets float can be solved effectively by only using sp or wp.
the reason for this perhaps counter intuitive result is that many tasks in float do not contain loops.
while ultimate kojak is not as successful as ultimate automizer we can see that both tools show the same behavior regarding the variation of assertion sources.
hence we infer that the software model checking algorithm is not responsible for the differences between the results but indeed the assertion source.
the plots in figures and show qualitative results obtained from ultimate automizer for each of the four benchmark sets.
due to space constraints we omit the results obtained from ultimate kojak .
each figure contains three plots.
each plot shows successfully solved verification tasks of a certain configuration ordered from smallest metric value to largest metric value.
for example consider the plot time and the configuration sp in figure .
the first point of the graph represents the fastest sample that could be solved by this configuration.
it took around .
seconds.
the last point represents the slowest sample sample no.
that could be solved which took around seconds.
the plot time shows the total time needed for solving a verification task in seconds on a logarithmic scale and the plot iter shows the total number of cegar iterations performed on a linear scale.
the plot perfiter shows the percentage of perfect state assertion sequences among all state assertion sequences obtained on a linear scale.
a sequence of state assertions is perfect if the state assertions are not only inductive w.r.t to the trace but also to the path program induced by the trace.
the path program induced by a trace is obtained by projecting the complete program to the statements occurring in the trace.
a perfect state assertion sequence also provides loop invariants for all loops of the path program.
as the total runtime time is determined by the interpolation time we can see that the overall runtime as well as the number of iterations iter correspond to a technique s expected ability to derive inductive invariants if we account for the startup time of smtinterpol andprincess both implemented in java which shifted their plots in comparison.
both plots shows that sp and wp perform poorly in this regard on memsafety andbitvector but not onfloat .
this is due to the fact that many tasks in float consist of loop free programs.
hence inductive invariants are not necessarily needed and simple trace iteration can solve these tasks.
the importance of perfect state assertion sequences is illustrated by our results.
nearly all successful cases in memsafety andbitvector contained only perfect state assertion sequences.
an exception are nearly a quarter of the float tasks that could be solved without any perfect state assertion sequence.
in those cases ultimate automizer simply unrolled loops and could solve the task anyway because not many unrollings were necessary.
in general having perfect state assertion sequences is the decisive factor for successful verification as without them only loop unrolling remains as option.our comparison of the newton algorithm variants against the craig interpolation algorithms shows that craig interpolation is clearly outperformed by the newton algorithms.
even if we remove thefloat set the then best newton variant z3 it sp lv solves and tasks as opposed to the and for z3with craig interpolation.
the reasons for this unexpected outcome are the following.
the solver is unable to interpolate a certain combination of theories.
during interpolation the smt solver has no timeout but can answer with unknown if it uses an incomplete algorithm for the sake of interpolation.
there are multiple proofs for the infeasibility of a trace but the solver selects one that does not lead to perfect state assertion sequences.
the solver selects a useful proof but the interpolation algorithm of the solver creates imperfect state assertions.
the solvers interpolants contain many quantifiers.
these quantifiers are hard for later stages of the software model checking process and can lead to timeouts during simplification and quantifier elimination.
z3 s interpolation engine often suffers from this problem.
reason is an inherent drawback of the newton style algorithms they are limited to formulas that syntactically occur in the program.
overall we can say that if one is faced with the question which technique to use for some arbitrary verification task then the answer is two fold if you are restricted to use just one method to obtain state assertions then use a newton style algorithm.
if you do not have this restriction e.g.
because time is not important for your task then try to use a combination of all the presented techniques and stop in each iteration after you have found perfect state assertions.
.
threats to validity our experiments are subject to some threats to validity.
first although our benchmark source is the sv comp repository which is widely regarded as the de facto standard for software model checking benchmarks we did not control for the complexity of state assertions in a proof.
the randomly selected verification tasks may require only simple state assertions that consist only of formulas syntactically contained in the program.
this would prevent craig interpolation to show its full potential.
we believe that this was not the case as the benchmark set float shows that for such simple programs even sp wp is sufficient.
second our selection of software model checking algorithms trace abstraction inultimate automizer and lazy abstraction with splitting inultimate kojak may benefit state assertions obtained by newton or may not be generalizable to other software model checking algorithms that require state assertions.
we can not rule out that other algorithms may exhibit additional characteristics.
as there are many different tools and variations it is nearly impossible to consider them all.
nevertheless our evaluation also shows the significance of obtaining inductive loop invariants and the direct connection to the source of state assertions we are confident that our results can be generalized to other tools.
495esec fse september paderborn germany d. dietsch m. heizmann b. musa a. nutz a. podelski related work our work touches the very active areas of abstract interpretation software model checking and craig interpolation.
the technique for generating interpolating state assertions described in this paper is closely related to the newton tool .
the main technical difference of our algorithm compared to newton s is that newton iteratively computes the strongest post condition adding one more statement to the trace prefix in each step.
each constraint set inferred this way is checked for consistency by a theorem prover.
when newton encounters an inconsistent constraint set the trace is infeasible.
then newton attempts to minimize the constraint set by leaving out constraints until none can be dropped without the set becoming consistent.
afterwards newton analyzes which statements in the trace can be projected out such that all the constraints in the minimized set are still in the strongest post of the projected trace.
our formalization assumes that the model checker gives a whole path formula to the solver and asks for its feasibility which is the common approach in state of the art interpolating model checkers.
the analogue to newton s projected path can then be obtained through an unsatisfiable core request to the smt solver.
also the quantification of non live variables which we describe in section is not done by newton .newton utilizes only the strongest post operator to automatically obtain predicates for an abstraction the idea of using weakest preconditions wlp for that task was proposed in .
abstract interpretation where abstract domains with join and widening are used to define an abstraction is geared towards generalizing from multiple symbolic executions.
it provides the guarantee that a fixpoint a loop invariant will always be found but it may result in overapproximations that are too coarse to prove a given property.
a wide range of techniques have been developed to identify and recover the corresponding loss of precision see e.g.
.
smt solvers can be used in order to identify the loss of precision .
craig interpolants can be used in order to help recover from the loss of precision .
our work adds to this line of work in abstract interpretation the idea of using the unsatisfiable core in order to define an abstraction.
software model checking where counterexample guided abstraction refinement is used to define an abstraction is geared towards generalizing from a single symbolic execution of the counterexample trace .
the success of the generalization relies on the succinctness of the reasons for infeasibility.
since craig interpolants are a way to capture the essence of the reasons for infeasibility they are used indirectly for extracting predicates or directly .
the approach in constructs a path slice incrementally and does not use unsatisfiable cores.
template based techniques like derive loop invariants from paths.
because they obtain a path invariant from a template via linear constraint solving they are not theory independent.
the unsatisfiable core of a trace formula can be seen as another way to capture the essence of the reasons for infeasibility e.g.
as used in .
the work in uses the unsatisfiable core to address problems with the scalability of current implementations of craig interpolation by decreasing the size of the input formula to the smt solver in a preprocessing step.
our work investigates techniquesbased on the unsatisfiable core as an alternative to computing a sequence of state assertions.
one can usually extract different unsatisfiable cores from a single trace formula.
one way of accomplishing this is iteratively replacing statements that are part of the current unsatisfiable core with sound abstractions e.g.
as described in def.
.
and then computing a new abstraction from the resulting new trace formula .
the different trace formulas obtained by this approach can lead to very different generalizations and thus an interesting problem is choosing the best one.
in the authors present and evaluate different heuristics for this problem.
in contrast to our work they do not compare a theory independent method against craig interpolation but consider the impact of different abstractions of a trace formula i.e.
different inputs for an interpolation engine on the model checking algorithm.
property directed reachability pdr also known as ic3 is another technique that computes generalizing inductive sequences of state assertions.
while pdr has been introduced for model checking of propositional formulas first several adaptations for symbolic model checking exist .
the pdr algorithm holds a sequence of candidate formulas in conjunctive normal form.
those formulas are iteratively strengthened and by prolonging the sequence weakened in the hope that one of them becomes a safe inductive invariant.
in contrast to newton and craig interpolation pdr always attempts to find a safe inductive invariant for a program whereas the state assertions from newton or craig interpolation need not be invariants.
conclusion we considered a central problem in software model checking compute an abstraction that is precise enough to prove the infeasibility of a given trace while coarse enough to prove infeasibility of other traces.
we reimplemented and enhanced the algorithm used by the newton tool into the context of current state of the art software model checkers and smt solvers by implementing it in the software model checkers ultimate automizer andultimate kojak and gave a formal description of the algorithm and several variants of it.
we then compared newton with various craig interpolation techniques implemented in different smt solvers.
the evaluation shows that when faced with an unknown problem one has a higher chance of success using the old newton approach then relying on specialized craig interpolation techniques.
the conclusion that one may be tempted to draw from the outcome of the experimental evaluation may be that newton wins over craig that the effort for implementations of craig for new theories is not need and that years of research are basically futile.
clearly such a conclusion would be wrong.
we believe that on the contrary our work opens a new line of research that aims at understanding the difference between newton and craig.
such a line of research may be worthwhile along with the existing line of research on new procedures that excel on specific application domains.
as always an experimental comparison can only be part of a series of experimental comparisons.