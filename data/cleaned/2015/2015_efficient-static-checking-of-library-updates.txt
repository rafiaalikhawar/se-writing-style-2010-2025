efficient static checking of library updates darius foo ca technologies singapore darius .foo ca .comhendy chua ca technologies singapore hendy .chua ca .comjason yeo ca technologies singapore jason .yeo ca .com ang ming yi ca technologies singapore mingyi .ang ca .comasankhaya sharma ca technologies singapore asankhaya .sharma ca .com abstract software engineering practices have evolved to the point where a developer writing a new application today doesn t start from scratch but reuses a number of open source libraries and components.
these third party libraries evolve independently of the applications in which they are used and may not maintain stable interfaces as bugs and vulnerabilities in them are fixed.
this in turn causes api incompatibilities in downstream applications which must be manually resolved.
oversight here may manifest in many ways from test failures to crashes at runtime.
to address this problem we present a static analysis for automatically and efficiently checking if a library upgrade introduces an api incompatibility.
our analysis does not rely on reported version information from library developers and instead computes the actual differences between methods in libraries across different versions.
the analysis is scalable enabling real time diff queries involving arbitrary pairs of library versions.
it supports a vulnerability remediation product which suggests library upgrades automatically and is lightweight enough to be part of a continuous integration delivery ci cd pipeline.
to evaluate the effectiveness of our approach we determine semantic versioning adherence of a corpus of open source libraries taken from maven central pypi and rubygems.
we find that on average of library versions are in violation of semantic versioning.
we also analyze a collection of popular open source projects from github to determine if we can automatically update libraries in them without causing api incompatibilities.
our results indicate that we can suggest upgrades automatically for of the libraries.
ccs concepts software and its engineering software evolution maintaining software automated static analysis permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
.org .
.3275535keywords automated remediation library upgrades call graphs api diffs semantic versioning acm reference format darius foo hendy chua jason yeo ang ming yi and asankhaya sharma.
.
efficient static checking of library updates.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
.org .
.
introduction the use of open source and third party components has increased in the development of software.
centralized package distribution systems like maven central for java rubygems for ruby and pypi for python make the task of downloading and using these components very convenient for the average developer.
however because third party libraries evolve independently of the applications that use them bugs and vulnerabilities in third party components are hard to trace and fix in downstream applications.
even when vulnerabilities can be fixed by updating to a newer version of a library there can be api incompatibilities with downstream applications which must be manually resolved.
oversight here may manifest in many ways from test failures to crashes at runtime.
one solution is semantic versioning1 semver a structured versioning scheme which relies on adherence to conventions.
library authors number versions with triplets of the form major.minor.
patch and release a major version when introducing a backwardincompatible api change to indicate this to downstream applications.
as this versioning scheme is structured version numbers can be operated on by tools an example is bundler s operator which only upgrades packages across patch version boundaries.
however the compliance of source code to the scheme must be manually enforced and it has been criticized as inadequately able to capture the nuances of change in software development .
to offer a better solution we present a static analysis for automatically and efficiently checking if a library upgrade introduces an api compatibility colloquially termed a breaking change .
we do not rely on a surrogate source of truth such as semantic versioning and instead statically compute the differences between source level elements of the library in particular methods and functions also .org esec fse november lake buena vista fl usa d. foo et al.
taking control flow into account.
our analysis is scalable enabling real time diff queries involving arbitrary pairs of library versions.
our solution forms the basis for a new feature in the ca veracode software composition analysis product which suggests library upgrades automatically and is lightweight enough to be part of a continuous integration delivery ci cd pipeline .
left to their own devices developers do not update dependencies as it is seen as extra effort and added responsibility and the downsides of failing to do so are not as visible.
we believe that the ability to have upgrades automatically carried out but not carelessly with guarantees about their effects would go a long way towards eliminating easily preventable classes of mistakes and vulnerabilities.
a recent study on automated pull requests reached the same conclusions finding that automation caused a increase in upgrades and that notification fatigue and concerns about breaking changes became the bottleneck thereafter.
our analysis directly address the problem of breaking changes in that we can statically show the user which library upgrades are possible without introducing api incompatibilities in their application.
to evaluate the effectiveness of our approach we determine semantic versioning adherence of a corpus of open source libraries collected from our customer scan data.
these libraries cover three different languages from their respective central repositories java maven central python pypi and ruby rubygems .
we find that on average of library versions are in violation of semantic versioning i.e.
they break backward compatibility without a major version update.
we also analyze a sample of popular open source github projects to determine the prevalence of api incompatibilities in practice.
we find that using our static analysis we can automatically suggest upgrades for of the libraries in these open source projects.
our main technical contributions are a static analysis that detects breaking changes in libraries accurately allowing upgrades to be suggested.
a novel method of composing diffs which enables diff queries on arbitrary library version pairs to be answered in real time at the cost of linear space instead of quadratic .
a case study of open source libraries published on maven central pypi and rubygems to assess adherence to semantic versioning.
on average of libraries violate semver in some version and of all library versions violate semver.
related work .
automated library upgrades prior work suggesting automated upgrades ranges from following simple rules such as always updating all dependencies within their constraints and relying on test suites to check for breakage23 to sophisticated attempts to actually patch apis or dependent code by inferring new api usage from examples.
in contrast our approach statically computes diffs to check for breakage and automatically update libraries that do not cause incompatiblities.
other static analysis approaches for analyzing library upgrades make use of dependency analysis symbolic execution and jml contracts to model the semantics of changes.
.deppbot .com .io .
structured diffs textual subsequence based diffs such as those produced by the unix difftool are widely used for visually comparing program fragments and sharing patches.
they can be computed quickly but do not take into account programming language syntax making them unsuitable for applications such as automated program repair.
syntactic diffs utilize syntax to ignore textual details.
they may be computed at multiple levels of abstraction syntactic api diffs include only program elements intended for external use such as classes and methods.
examples are the documents published by apple4and google5to summarize differences between versions of their mobile apis.
umldiff gumtree and wuu yang are implementations of syntactic diffs which compare the syntax trees of source code instead of only interfaces.
diffs may also reflect semantic information such as control flow and state .
semantic diff computes differences in the observable input output behaviour of procedures by reasoning about dependencies between variables.
symdiff checks for partial equivalence between programs terminating executions with identical inputs and outputs.
mezzetti et al.
use a dynamic analysis based on the test suites of dependent libraries to infer library interfaces for comparison.
our approach sits in this category as we compute syntactic api diffs that are enriched with control flow information applying diff composition thereafter to compare arbitrary versions of a given library.
.
semver compliance we conduct a case study of three open source ecosystems maven central rubygems and pypi to evaluate the adherence of library developers to semver scheme.
prior work in this area by raemaekers et al.
goes into much greater detail but only for maven central.
other related studies evaluate breaking changes in open source projects on npm and cran .
approach .
basic diffs consider the problem of computing diffs for library apis.
we begin by computing a minimal language agnostic representation of a library s api which we term a signature .
the representation we use is a set of tuples of an identifier and a hash .
the identifiers give canonical names to the program elements in libraries that we wish to compare.
for example the methods of an object oriented api are represented as a tuple of module class method names and an argument descriptor.
the hashes summarize the content of the program element allowing us to quickly determine if it has changed for example we hash the bytecode of java methods eliding syntactic features such as variable names but including literals and instructions that affect control flow.
given the signatures of two libraries we use myers algorithm to compute a diff an edit script relating them with the slight modification that we key elements by identifier instead of position .apple .com library archive releasenotes general ios10apidiffs index .html .android .com sdk api diff p dp1 changesefficient static checking of library updates esec fse november lake buena vista fl usa class a public int a return public int b int x return x figure example v1 class a method a deleted public int b int x return x modified public int c inserted return figure example v2 method operation a.a i delete a.b i i change a.c i insert table example computed diff from v1tov2 in a sequence.
this gives us a set of tuples of identifier and diff operation where the latter is one of the symbols insert delete or change .change s are opaque as program content is summarized using a hash.
in particular we do not perform a more granular syntax tree based diff like gumtree does.
since diffs are meant to relate the public apis of libraries as a post processing step we exclude program elements which we know not to be publicly accessible.
in java this information is explicit for dynamically typed languages such as python and ruby we rely on heuristics based on variable names and statically known calls to methods that modify access to exclude such elements.
as a running example consider two versions of a java class figures and .
the computed set of diff operations between these two versions is shown in table .
.
transitively changed methods hashing methods gives us an approximate way to detect changes but processing methods in isolation i.e.
ignoring inter procedural control flow causes transitive changes to methods to be missed.
for example if public method m1calls private method m2and only m2has changed we would miss the fact that m1 s semantics is now different if we exclude m2due to its private access.
this is illustrated in figure .
to solve this problem we first build call graphs of library programs our call graph construction algorithm uses standard techniques of cha and vta and is deployed as part of the ca veracode software composition analysis product.
we then use the call graphs to improve diffs given a method mwhose identifier is present in a diff we also include all public methods that call m.mclass a before public int m1 int x return m2 x private int m2 int y return y class a after public int m1 int x syntactically unchanged but returns a different result and so should have a different hash return m2 x private int m2 int y return y changed figure example transitive changes method operation a.a i insert a.b i i change a.c i delete table example computed diff from v2tov3 may or may not be later dropped from the diff depending on if it is public but we will no longer exclude its public callers.
.
fast queries call graph construction is thus necessary for the accuracy of diffs but imposes nontrivial overhead.
for instance the largest libraries on maven central may take hours to completely analyze.
this makes it infeasible to compute accurate diffs on demand say as part of an automated library upgrade step in a ci cd pipeline.
in this section we describe a means of precomputing information that enables real time diff queries on arbitrary pairs of library versions.
a naive approach would be to precompute and store every pair of diffs consuming space that grows quadratically with the number of versions.
this is unlikely to scale since real world libraries have hundreds of versions and in general libraries may have up to one version per commit6.
this for a commonly accessed subset of libraries and a window of recent versions is feasible but shifts the problem to determining this subset and of course only works for versions within the subset.
our approach is to precompute diffs between only consecutive pairs of library versions then compose individual diffs to derive diffs for arbitrary version ranges.
this strikes a good balance requiring a linear amount of space and running quickly enough in practice.
.
diff composition we begin with a concrete example of diff composition.
consider the diffs given in table and table assuming they are computed .com artifact com .lihaoyi ammonite terminalesec fse november lake buena vista fl usa d. foo et al.
method operation a.a i change a.b i i change a.c i missing table example composed diff from v1tov3 data state absent present data diff state state type where insert diff absent present change diff present present delete diff present absent unchanged diff present present missing diff absent absent figure modeling diffs as a type from consecutive library versions v1andv2 and v2andv3 respectively.
method awasdelete d then re insert ed because we no longer have access to its content we must assume conservatively that the reinsertion is different and that it has change d overall.
method bwaschange d in both diffs we can say no more than that it is change d as well.
finally method cwasinsert ed then delete d it is now missing an operation we have not yet defined and we must treat it as such in any further composition of the resulting diff.
the final composed diff is given in table .
we see also that it is impossible for a diff between v3tov4to have that method cisdelete d given that it was never present in v3 to begin with suggesting that composition is partial.
we now formalize diff composition.
as defined earlier a diff is a set of tuples of a method identifier and some diff operation which describes how the method changed across versions.
there are 5primitive diff operations we saw insert delete andchange earlier and introduce two more for explicitness unchanged which means that a method appears unchanged across versions and missing for when it is missing altogether.
the latter two operatons are never produced when diffs are computed but we include and distinguish them because certain compositions of operations are absurd e.g.
insert followed by insert .
the validity of an operation relating two methods across versions depends on the methods states e.g.
a method must be absent for an insert ion of it to make sense and it must be present after.
unchanged andmissing relate methods with different states.
we may represent the diff operations collectively as a type indexed by the states of the method they relate before andafter they are applied.
each diff operation becomes an inhabitant of this type.
this is shown in figure .
the diff composition function must then have the following type compose diff a b diff b c diff a c in this way we partially reduce the problem of checking the validity of a particular composition to determining how the operands ofcompose constrain its result.
compose is uniquely defined on many inputs.
for example compose delete missing must bedelete no other operation is well typed.
the fact that compositon is partial is reflected in the fact that illegal compositions such as compose insert insert are not well typed.icdum i im i c c d c d c d u c d u m i m table diff composition function i c d um i i um i c c d c d c d um i c d um table conflated diff composition function the only ambiguity arises when selecting between change andunchanged as we do not model hashes in our types they have the same type diff present present only methods which are present throughout may be said to have changed or remained unchanged .
we resolve the ambiguity manually choosing change where possible as it is more conservative than unchanged .
the final composition function is given in table .
rows are the first argument and columns are the second.
we represent ill typed combinations with the symbol.
composition is not symmetric compose insert delete missing compose delete insert change however it is associative which can proven by exhaustion .
.
conflating operations it turns out that we can conflate unchanged andmissing into a single operation unknown abbreviated um since they occur in mutually exclusive scenarios.
this is useful in practice.
say we diff a list of items against a list of we would want to store a single insert instead of also storing unchanged s. defaulting to unknown when an item is absent allows us to store the information concisely.
this doesn t change composition semantics proven by exhaustion .
implementing this change gives us the new function in table .
the time complexity of diff composition is linear in the number of library methods and versions like diff computation itself.
.
suggesting upgrades we then use diffs to suggest upgrades and determine if they induce breaking changes.
in the ca veracode software composition analysis product we identify vulnerable versions of a library and suggest upgrades to fix those versions.
given a library at version v1and the set of versions vsof the same library we choose another version from vswhich succeeds v1and does not possess vulnerabilities7 associated with v1.
this may be done using various heuristics and may be further optimized we currently choose the closest version to minimize diff size and induce the fewest breaking changes.
given the library diff and the pair of library versions involved in the upgrade vf rom andvto we restrict it to only delete and change operations this is exactly the set of methods in vf rom 7vulnerability data is assumed to come from an external source such as nvd or a proprietary vulnerability database efficient static checking of library updates esec fse november lake buena vista fl usa figure generated patch to pom.xml type library from to breaking mavenorg.apache.struts struts2 core2.
.
.
.
no mavennet.bull.javamelody javamelody core1.
.
.
.
possibly table report in generated pull request whose callers will be affected by the upgrade.
we then check the call graphs we compute from user code to see if they are calling any affected methods if so we consider the upgrade to be a breaking change.
we use sgl a domain specific language for program analysis to perform the call graph traversal.
the specifics of sgl are described in and are out of scope for this work.
the next step is to generate a patch rendered in figure as a github pull request.
since we patch files typically maintained by hand we take care to minimize changes by parsing the files then using position information to make granular edits.
an example of what we include in generated pull requests is shown in table we specify the to and from versions of the upgrade and say whether or not we could statically determine that the change was breaking.
experiments and evaluation .
semver compliance we analyzed libraries based on our customer scan data across three popular open source library repositories maven central libraries rubygems and pypi computing diffs for library versions in total.
our results indicate that on average of libraries violate semver in some version the actual numbers are rubygems maven central and pypi .
in addition on average of all library versions are in violation actual numbers being rubygems maven central and pypi .
the figure for maven central agrees with prior work which puts the number of violating versions between .
and .
over time.
the overall distribution of violations is shown in figure as a plot of the number of libraries y axis that have a given percentage of versions within them in violation x axis .
as a concrete example consider the popular requests library between versions .
.
and .
.
a minor version bump over which breaking changes are not expected requests.structures.
iteratorproxy was deleted8.
for this not to be considered a semver violation iteratorproxy must not be part of requests pubilc api however it is difficult to determine this using a static analysis as nothing prevents one from importing requests.structures .
.com requests requests compare v2 .
.
.
.
.v2.
.
diff2bdbe7e19f5215e8c319573cdd114f01l16 figure semantic versioning compliance java python ruby projects direct dependencies direct vulnerable dependencies246 suggested upgrades non breaking table api incompatibilities on github consulting human readable sources like commit messages and the change log also yielded nothing in this case so we assume it to be a breaking change.
the fact that such mistakes may slip through is why a manually enforced convention like semver is insufficient to ensure reliable upgrades.
.
api incompatibilities in open source projects we analyzed a collection of popular open source projects from github to determine the impact of api incompatibilities on suggesting upgrades automatically.
a dynamic dependency analysis was first performed to identify libraries included e.g.
as shown in table in java we identified unique direct dependencies of which had known vulnerabilities in our database.
we were then able to suggest upgrades for of those had no safe versions to upgrade to and failed due to the errors in an earlier part of the pipeline such as malformed class files or the inability to successfully compute a call graph .
of the upgrades we are able to statically show that .
are non breaking.
across languages of upgrades are non breaking on average.
we believe the notably lower numbers for python and ruby are due to the difficulties of static call graph construction for those languages and the false positives that result from over approximation.esec fse november lake buena vista fl usa d. foo et al.
discussion .
threats to validity to handle large real world libraries as part of a ci cd product our static analysis techniques rely on a number of approximations which may introduce unsoundness.
they are listed in this section.
limitations of static analysis.
a call graph computed using cha vta over approximates the dynamic control flow of a program causing false positives call graph edges that are never traversed at runtime.
separately bytecode hashing is used to determine if methods have changed.
this results in false positives if methods differ syntactically but are semantically unchanged e.g.
due to refactoring changes or because different versions of compilers may emit different instruction sequences for the same piece of source code.
unsupported language features.
false negatives also occur due to lack of support for dynamic language features such as reflection and classpath introspection.
these manifest as missing call graph edges causing potentially breaking changes to be missed.
computing diffs in isolation.
call graphs and diffs are computed for single libraries at a time.
if a version of a library vadepends on vb and the version that comes after va denoted v a depends on v b we will fail to pick up potential breaking changes due to calls to methods which now have different semantics due to the transitive upgrade from vbtov b. insufficient semantic information.
there is also the issue of insufficient semantic information being statically present in source code.
an example is the access levels of methods in python which are mostly implicit while the runtime does treat underscoreprefixed names specially in some contexts it is mostly a convention.
whether or not an api is meant to be internal is not always deducible from source code and so we necessarily over approximate employ heuristics and guess when analyzing such programs.
conclusion and future work we presented a static analysis for computing diffs between libraries and determining if an upgrade introduces an api incompatibility.
it is scalable supporting real time diff queries involving arbitrary pairs of library versions.
this makes it lightweight enough to be part of a continuous integration delivery ci cd pipeline enabling a vulnerability remediation product that is able to automatically upgrade libraries in of cases.
we also evaluated adherence to the semantic versioning scheme on maven central pypi and rubygems finding that of library versions are in violation.
for future work we aim to improve accuracy and lower false positive rates.
a dynamic analysis could be combined with static call graphs to improve their accuracy and usability and false negative rates could both be improved by accounting for more language features.
another direction is to make results more actionable by generating test cases which exercise code paths which we know to be involved in a breaking upgrade or optimizing the selection of upgrade versions to minimize the manual work users must perform.