angelix scalable multiline program patch synthesis via symbolic analysis sergey mechtaev jooyong yi abhik roychoudhury school of computing national university of singapore singapore mechtaev jooyong abhik comp.nus.edu.sg abstract since debugging is a time consuming activity automated program repair tools such as genprog have garnered interest.
a recent study revealed that the majority of genprog repairs avoid bugs simply by deleting functionality.
we found that spr a state of the art repair tool proposed in still deletes functionality in their many plausible repairs.
unlike generate and validate systems such as genprog and spr semantic analysis based repair techniques synthesize a repair based on semantic information of the program.
while such semantics based repair methods show promise in terms of quality of generated repairs their scalability has been a concern so far.
in this paper we present angelix a novel semantics based repair method that scales up to programs of similar size as are handled by search based repair tools such as genprog and spr.
this shows that angelix is more scalable than previously proposed semantics based repair methods such as semfix and directfix.
furthermore our repair method can repair multiple buggy locations that are dependent on each other.
such repairs are hard to achieve using spr and genprog.
in our experiments angelix generated repairs from large scale real world software such as wireshark and php and these generated repairs include multi location repairs.
we also report our experience in automatically repairing the well known heartbleed vulnerability.
categories and subject descriptors d. .
testing and debugging keywords program repair scalable semantics based repair multiline patch angelic forest introduction the once futuristic idea of automated program repair is gradually becoming a reality.
various automated repair permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
such as genprog par reli x semfix nopol directfix and spr to name only a few have been introduced recently.
these automated repair methods can be classi ed into the following two broad methodologies i.e.
search based methodology e.g.
genprog par and spr and semantics based methodology e.g.
semfix nopol and directfix .
search based repair methodology also known as generate and validate methodology searches within a search space to generate a repair candidate and validate this repair candidate against the provided test suite.
meanwhile the semantics based repair methodology synthesizes a repair using semantic information via symbolic execution and constraint solving .
classifying repair methods into search based repair and semantics based repair is somewhat analogous to classi cation of software testing into search based testing and symbolicexecution based testing .
while such a classi cation may be a bit coarse it helps us understand the current trends in automated program repair.
in genprog a prominent search based repair tool is shown to be scale to large scale real world software such as phpandwireshark .
meanwhile semfix the rst semantics based repair tool is shown to be more e cient than genprog in terms of repairability which is higher as more buggy programs can be repaired and running time although semfix was applied only to relatively small programs.
afterwards in both methodologies the importance of high quality repairs began to be considered resulting in another search based repair tool par and semantics based repair tool directfix .
finally a research e ort argued for explicitly de ning defect classes i.e.
which defects will be xed by a given repair method while constructing repair methods.
currently research in automated program repair considers all the three attributes scalability should scale to large real world programs repairability should repair a large number of defects possibly by covering many defect classes and the quality of repairs should produce repairs which make less changes to the program delete less functionality and are more likely to be accepted by developers .
note that some of these attributes can be deemed to be somewhat qualitative in nature nevertheless it is very important to consider them while building a new repair method.
as an example the latest search based repair tool spr generates more repairs as compared to genprog and the generated repairs are more frequently functionally equivalent to developer provided repairs rather than merely passing the provided tests when applied to large scale real world software.
meanwhile in the case of the semantics based ieee acm 38th ieee international conference on software engineering methodology low scalability has been the main source of criticism despite its promising results in terms of high repairability e.g.
semfix and the high quality of repairs e.g.
which repairs a buggy program by making provably minimal changes to the program .
we show in this paper how the semantics based repair methodology can also scale up to the same level as the most advanced search based repair tools such as spr and genprog.
semantics based repair methods often work by extracting a repair constraint typically via symbolic execution.
this repair constraint acts as a speci cation to guide program synthesis so a patch satisfying the repair constraint can be synthesized.
the key enabler for scalable multiline bug x in this paper is our novel lightweight repair constraint that we call an angelic forest .
this angelic forest is automatically extracted via symbolic execution.
as compared to the repair constraints used in the previous work the angelic forest is simpler and its size is independent of the size of the program under repair thereby making our repair method scale.
our angelic forest despite its simplicity contains enough semantic information to enable multi location bug x. among existing search based repair tools spr does not support multi line xes.
while genprog can change multiple locations of the program a recent study on genprog repairs shows that seemingly complex repairs generated from genprog are in the overwhelming majority of cases in fact functionally equivalent to single line modi cation.
when evaluated with the largest of the genprog icse2012 subjects our open source repair tool angelix successfully generated repairs including on wireshark and php subjects.
the number of repairs generated by angelix is larger than in genprog and also generally comparable to spr .
while in one subject libti angelix generated more repairs than spr and in another subject php spr generated more repairs.
in the remaining subjects both tools produced the same number of repairs.
more importantly we note that even though a recent work points to functionality deleting repairs by genprog the spr tool which was produced by the same authors itself was found to generate many functionality deleting repairs because it generates many trivial branch conditions.
such trivial branch conditions conditions which are always true or always false introduce functionality deletion e.g.
consider the following spr repair for a libti defect where the shaded part is the x inserted by spr.
i f td tdnstrips td tdcompression c o m p r e s s i o n n o n e td tdstripbytecount !
td tdstripbytecount !
we found that in spr the overall functionality deleting repair rate across the genprog benchmark subjects is .
in fact in the libtiff subject the percentage of functionality deleting repairs in the spr tool goes up to an alarming !
!
in contrast our semantic analysis based repair tool produced functionality deleting repairs signi cantly less frequently when the same tests were used .
for the aforementioned defect angelix synthesizes a patch that is identical with the developer provided patch shown in figure 3b which does not delete functionality.
furthermore the repairs generated by angelix include ve multi location bugs which have not been xed by the existing tools.
last but not the least we report that the well known heartbleedvulnerability was automatically xed by our tool generating a repair that is smiliar to the developer provided patch.
to the best of our knowledge ours is the rst work that reports the automated repair on heartbleed.
overall we present a semantic analysis based program repair method which balances the requirements of scalability repairing large programs repairability repairing a large number of defects and patch quality changing the functionality of the program in a way developers would agree with instead of simply deleting functionality .
our tool angelix and its experimental data are available at the following web site motivating example figure shows code changes made to x coreutils bug .
in the buggy version the call of xzalloc line which allocates a block of memory causes a segmentation fault.
a x involves adding an if conditional before the problematic call to xzalloc line .
only when variable max range endpoint has a non zero value xzalloc can be called in the xed version.
in addition to adding an if conditional the x requires removing an existing if statement lines .
without this removal max range endpoint is overwritten with a non zero value of eolrange start line and as a result the new if conditional if max range endpoint cannot successfully prevent the problematic call to xzalloc.
this simple example demonstrates the complexity of multiline repairs xing multiple buggy locations.
the key di culty is that a change made in one location can also change the remaining program execution that should proceed to be repaired.
more conceptually speaking the x space of a given buggy program keeps changing along with the program change made at each buggy location.
the state of the art search based repair algorithm such as spr also known as the generate and validate methodology is currently restricted to xing a single location.
it is unclear as stated in how a search based repair algorithm can be extended to x multiple location bugs such as the one shown in figure 1a while maintaining its e ciency.
meanwhile among the state of the art of semantics based repair methodology such as semfix and directfix directfix already supports multiple location x. essentially directfix maintains all semantic information of the program in the form of a logical formula and this makes it possible to keep track of how the x space changes.
thus semfix is more scalable and applies one line xes while directfix is less scalable but can produce multi line xes.
in this paper we discuss how semantics based repair can scale while preserving its ability to repair multiple locations.
figures 1b 1d show at a high level how our repair algorithm generates a repair from our running example.
the generated repair shown in figure 1d is functionally equivalent to the developer provided repair despite its cosmetic di erences.
the rst piece of a repair if in line makes the statement in line skipped over which is functionally equivalent to removing the corresponding statement.
the second piece of a repair if !
max range endpoint is also functionally equivalent to the developer provided repair if max range endpoint .
here the cosmetic di erence is merely due to our current implementation of the component based synthesis algorithm we use to synthesize a repair.
our repair algorithm starts from transforming the original buggy program into a functionally equivalent one shown in i f max range endpoint eolrange start max range endpoint eol range start printable field xzalloc max range endpoint char bit i f max range endpoint printable field xzalloc max range endpoint char bit a the developer provided bug patch for coreutils bug where multiple locations are repaired1 i f max range endpoint eolrange start max range endpoint eol range start 4if printable field xzalloc max range endpoint char bit b the buggy version after semantics preserving transformation the shaded part is added i f max range endpoint i f printable field xzalloc max range endpoint char bit c suspicious expressions are replaced with symbolic variables1 i f max range endpoint eol range start i f !
max range endpoint printable field xzalloc max range endpoint char bit d a repair generated from our repair algorithm expressions in the shaded areas are synthesized from our repair tool angelix.
figure motivating example figure 1b where we add an if conditional if before each unguarded assignment statement this is heuristics we currently use .
afterwards our repair algorithm replaces usercon gurednmost suspicious expressions chosen based on the result of statistical fault localization with symbolic variables as shown in figure 1c where conditional expressions and the right hand side of an assignment are replaced with symbolic variables.
the user of our repair algorithm can congure the number and kinds of suspicious expressions that can be made symbolic such expressions include conditional expressions right hand sides of assignments and function parameters.
our repair algorithm proceeds to run symbolic execution over the program in figure 1c with provided tests to collect the semantic information necessary to repair the given buggy program.
using this extracted semantic information we synthesize repair expressions.
to synthesize a repair we use component based patch synthesis algorithm based on maxsmt as in our prior work .
this results in a repair close to the original program because the structures of the original buggy expressions are maximally preserved.
the resultant small patches can bring in various bene ts such as improved maintainability of patches simple patches are easier to understand than complex patches and reduced risk for regression simple patches are less likely to change the correct behavior than complex patches .
.
concise semantic signature for repair in order to synthesize a repair our repair algorithm collects the following pieces of semantic information of the program.
first we need to know whether for each test there exists a program path through which a given test passes.
our repair algorithm detects such test passing paths via controlled symbolic execution controlled in the sense that we control which execution paths are explored during symbolic execution by installing symbolic variables in our example and .
in our running example given a program of figure 1c symbolic execution explores di erent paths at the if conditionals in line if and line if .
if a test passing path is not detected we make the next usercon gured nsuspicious expressions as symbolic and repeat the procedure to nd test passing paths.
on the other side the existence of a test passing path that goes through the installed symbols implies the existence of a concrete value for each symbol that makes the test pass.
as the second piece of semantic information we infer these values calledangelic values using a constraint solver.
lastly we need to know the program state called angelic state at each installed symbol in the test passing path.
for example in order to synthesize a repair expression !
max range endpoint at line of figure 1d the value of the variable max range endpoint should be known.
our repair algorithm collects the values of the visible program variables at each symbol installed program location.
these variables are used as synthesis ingredients when synthesizing repair expressions.
the following shows the semantic signature of our running example when two tests t1andt2 are provided.
t1 f h false false i h true false ig t2 f h false true i h true true ig wheretireferes to a test idenotes a test passing path and i variables!values denotes an angelic state.
the preceding semantic signature which we call an angelic forest as de ned in de nition concisely captures all three pieces of semantic information we need to synthesize a repair.
first the fact that there exist two execution paths 1and that make test t1pass is encoded in t1 f 2g.
similarly test t2can also pass in two execution paths and .
note that the suggested repair shown in figure 1d follows path 1in testt1 and 3int2.
second the concrete value of each symbol is denoted at each test passing path.
for example in path symbol and should have value false as denoted with h false false i. the concrete value of symbol does not appear because statement max range endpoint of figure 1c is not executed in path .
meanwhile in path the values of all three symbols appear as denoted with h true false i. lastly angelic state iinforms about the values of variables to use in repair synthesis.
the same variable can have different values along a path and that is why each instance of a symbol is associated with its own angelic state.
in our coreutils example max range endpoint is zero and this is why the suggested repair expression !
max range endpoint returns the concrete value of false as speci ed in .
.
reasons for scalability as will be shown in the experimental results section our repair method can handle programs as large as wireshark kloc and generate multi location repairs.
there are multiple reasons why our repair method scales.
first we use a lightweight semantic signature for program synthesis.
compare our semantic signature with the one used in directfix which can also synthesize multi location repairs.
the semantic signature used in directfix is essentially the semantics of the whole program.
there the relationship between each and every expression appearing in the program is maintained unlike in our new semantic signature.
as a result the semantic signature of directfix becomes more lengthy and complex as the size of the program increases.
it it important to note that the semantic signature is the speci cation for repair synthesis in the sense that a synthesized repair should respect the provided semantic signature as explained with our running example.
our lightweight semantic signature reduces the burden of the repair synthesizer resulting in more e cient repair synthesis.
second our repair algorithm performs controlled symbolic execution with a few selected suspicious expressions instead of usual symbolic input.
using this controlled symbolic execution we explore only a restricted number of feasible execution paths involving only the selected few suspicious expressions.
also we initially perform symbolic execution only with a subset of the provided test suite to reduce the running time of symbolic execution.
only when some of remaining tests fail with the synthesized repair we perform additional symbolic execution with these failing tests.
lastly our repair algorithm initiates repair synthesis only when there exists an angelic forest the semantic signature for repair.
the absence of an angelic forest for a chosen n suspicious locations implies that it is not possible to repair the bug by changing these nlocations.
symbolic execution nds an angelic forest or proves the absence of an angelic forest e ciently by exploring only feasible execution paths.
our repair algorithm does not waste the resources to synthesize a repair if there is no angelic forest.
we note that each of these afore listed techniques is the improvement or extension of earlier work by us and others.
as already mentioned our novel lightweight programsize independent semantic signature is the improvement of the heavyweight semantic signature used in our prior work directfix .
we also mention that the controlled symbolic execution was rst introduced in our prior work semfix although there a symbol is installed only at one location and as a result multi location repair was not possible.
lastly our repair strategy to ignore repair wise infeasible suspicious locations has a similarity with nopol and spr .
while detailed comparison will be provided in section nopol and spr currently cannot x multilocation bugs.
furthermore multi location x seems fundamentally di cult in nopol and spr due to their weaker semantic signatures that do not capture the dependence between multiple program locations.
the unique combination of our novel semantic signature with the existing techniques enables scalable multi location bug xing.
background we use techniques and tools for partial maximum satisability modulo theories partial maxsmt for our repair algorithm.
partial maxsmt for two sets of clauses softand hard is a problem of nding an assignment of the variables that satisfy all hard clauses and maximum possible number of the soft clauses.to synthesize a patch we use component based repair synthesis algorithm cbrs which is a generalization of component based program synthesis to program repair.
in cbrs a component is a variable a constant or a term over components and operations de ned in the given background theory e.g.
x and if 1then 2else where irefers to the input to a component.
an expression is formed by connecting multiple components.
for example the diagram in figure shows that expression x y is formed by connecting the following three components x andy.
each component chas one output cout and one or more inputs cin i. we denote the number of inputs of a component cwith ni c .
to represent the connection between components the input and output of components are associated with distinct variables called location variables .
for example input cin iis associated with its location variable lcin i and output coutwith lcout.
two components are considered connected if and only if the location variable of one component has the same value as the location variable of another component.
to make sure that a synthesized expression is well formed cbrs imposes a well formedness constraint wpf in which cdenotes the set of all available components wpfdef range cons acyc rangedef c2fvg c lcout jcj k2 lcin k jcj consdef c s 2c c c6 slcout6 lsout acycdef c2c k2 lcout lcin k where the range constraint range places all components inputs and outputs within a legal range the consistency constraint cons ensures that the output of each component has a distinct location and the acyclicity constraint acyc prohibits cyclic connections.
cbrs also imposes the semantics constraint for each component and the connections constraint conn that connects location variables with their corresponding components.
conndef c s 2c fvg c k2 lcout lsin k cout sin k lastly structural constraints capture the structure of the original buggy program.
for example the structural constaints for the expression x yare the following structdef l in lxout l in lyout to synthesize a patch for a buggy program using cbrs the structural constraints are passed to a partial maxsmt solver as soft constraints and the rest of the constraints are passed as hard constraints.
then the solver nds a new program that satis es the synthesis speci cation and is syntactically closest to the original buggy program.
methodology our repair methodology consists of the following steps program transformation fault localization extracting a repair constraint and patch synthesis.
in the rst step we perform semantics preserving program transformation to expand the defect class our repair algorithm can x. for example we showed in section that if can be added before each unguarded statement.
more generally our repair framework is transparent to the addition of more semantics preserving program transformation schemes.
in the second step we perform statistical fault localization.
we use the jaccard formula considered most e ective for automated program repair according to .
since our repair algorithm modi es buggy expressions we apply the jaccard formula at the expression level instead of at the statement level.
the last two steps distinguish semantics based repair methods from search based repair methods such as genprog and spr.
semantics based methods extract a repair constraint from the program under repair typically via symbolic execution.
this repair constraint acts as a speci cation to guide program synthesis so a patch satisfying the repair constraint can be synthesized.
the key novelty of our repair method is our new lightweight repair constraint that we call an angelic forest .
the size of this angelic forest is independent of the size of the program under repair.
this is the main reason why our new repair method can scale.
our angelic forest despite its simplicity contains enough semantic information to enable multilocation bug x. in the following we formally de ne our angelic forest de nition based on the de nition of an angelic value de nition and an angelic path de nition .
definition angelic value .
letpbe a program tbe a failing test case ebe a program expression and ekbe its k th appearance in the execution trace of t. angelic value is such that replacing expressions ekwith during the execution of tin the trace makes ppass testt.
definition angelic path .
letebe a set of program expressions of program p andtbe a test case for p. an angelic path t e is a set of triples ek v whereek is thek th instance of an expression e2eappearing in the execution trace of test t vis an angelic value of ek and function variables!values represents angelic state at ekwhich is a mapping from visible variables at the location ofekto their values.
for these triples ek v in an angelic path t e the following property holds replacing all ekin an angelic path with their corresponding angelic valuesvmakes program ppasses the test tand visible variablesxat the location of ekhave values x .
definition angelic forest .
letebe a set of program expressions of program p andtbe a test case for p. angelic forest atfor testtis a collection of angelic paths f t e n t e g. .
angelic forest extraction we extract an angelic forest via controlled custom symbolic execution controlled in the sense that instead of initiating symbolic execution with symbolic input we install symbols at a few suspicious program locations chosen based on a statistical fault localization result to control the execution paths to be explored during symbolic execution.
algorithm shows how we extract an angelic forest.
performing controlled symbolic execution produces a pair of a path condition pcand an actual output oaof the program line .
given the expected output oeavailable in the test we nd a model of pc oa oe i.e.
model min line viaalgorithm angelic forest generation input programp test case i oe input a set of suspicious expressions e output angelic forest a while there is an unexplored path timeout do perform controlled symbolic execution pc oa controlledsymexe i e r pc oa oe ifris satis able then m getmodel r via a constraint solver a a extractangelicpath m end if end while returna algorithm our custom symbolic execution input ekis ak th instance of expression e input a set of suspicious expressions e input sym variables!concretevalues symbolicvalues output the concrete symbolic value of expression ek function evaluateexpr ek e sym ifek2ethen ifekis suspicious forx2visible variables at the location of ekdo addtopathcondition xjekk sym x end for install a symbol for ek return newsymbolicvariable ek else ifekis not suspicious evaluate ekas usual return evaluateexprconventionally ek sym end if end function a constraint solver.
this model is used to extract an angelic path and thereafter grow the angelic forest line .
recall that an angelic forest is a set of angelic paths each of which is a set of triples consisting of an instance of a suspicious expressionek its angelic value the value ekshould return to pass the test and angelic state atek that is a mapping from visible variables at the location of ekto their values.
since the conventional symbolic execution can neither install symbols for chosen suspicious expressions nor maintain the angelic states of suspicious expressions we extend the conventional symbolic execution as described in algorithm .
in our custom symbolic execution symbols are installed during symbolic execution by replacing the value of each instance of a suspicious expression with a fresh symbol line .
if a given ekis not a suspicious expression our custom symbolic execution evaluates ekin the same way as in the conventional symbolic execution line .
in addition we maintain the angelic states of suspicious expressions by augmenting the path condition line .
for each visible variable xat the location of ek thek th instance of suspicious expression e we extend the path condition with xjekk sym x wherexjekkrepresents the variable xin the context of ek and sym x the concrete symbolic value ofxevaluated during symbolic execution.
solving the resultant augmented path conditions via a constraint solver produces an angelic forest.
we implement our custom symbolic execution on top of klee .
.
patch synthesis once an angelic forest is obtained we feed it to our repair synthesizer as a synthesis speci cation.
more speci cally a synthesized repair when executed follows one of the angelic 695yout xy in out in xouti nputoutput x y true false false f igure the circuit diagram on the left represents expressionx y which satis es the speci cation shown on the right as a table.
unconnected components are ignored.
table the example of an angelic forest p athk xjekkyjekkangelic true false false p aths for each test thereby all tests pass.
in these angelic paths each repaired expression returns its corresponding angelic value speci ed in the corresponding angelic path.
our repair synthesizer is an implementation of componentbased repair synthesis cbrs described in section .
cbrs views a program as a circuit of primitive components such as variables and operators.
for example the circuit diagram of figure shows the circuit for a program expression x y .
the boxes and lines represent components and connections respectively.
the goal of cbrs given an original buggy program components and a speci cation of the program to be synthesized is to search for connections between components that satisfy the given speci cation and minimally di er from the connections of the original buggy program.
as an example consider a buggy expression x y. the table of figure shows the desired speci cation for the expression and cbrs modi es the connection of the variablesxandyfrom the component to the component becausex y satis es the given speci cation.
the speci cation of cbrs is provided in the form of an angelic forest extracted by algorithm .
table shows an example of an angelic forest.
for simplicity only one expressioneis considered suspicious in this example the extension to multiple expressions is straightforward .
the rst two columns of the table show a path id and the instance id of e respectively.
in this example path executes expression etwice that is kis either or while path executes e only once.
the angelic forest includes two visible program variables xandy as the program state at the suspicious location.
the values of these variables are shown in the xjekk andyjekkcolumns.
notation xjekkrepresents the variable x in the context of ek thek th instance of e. the last column angelic shows the angelic value of ek.
cbrs performs the search for connections using a constraint solver.
given our example angelic forest we generate the following constraint xje1k yje1k e1 true xje2k yje2k e2 false xje1k yje1k e1 false more generally we generate the following constraint given an angelic forest f i t e g recall that each angelic path i t e in an angelic forest is a set of triples ek v i t e ek v x2dom xjekk x ek v!
wherevis the angelic value of ek anddom refers to the domain of the mapping from the visible variables at the location of ekto their values.
there can be multiple patches satisfying a given repair constraint.
in such cases cbrs nds a patch requiring minimal changes by using maxsmt solver.
the ability to maximally preserve the original source code is important for two reasons.
first our hypothesis is that such a minimal patch would be preferred by developers.
minimal patches are easier to validate and they are less likely to change the correct behavior of the original program than more complex patches as demonstrated in .
second when synthesizing a repair for multiple suspicious expression maxsmt based repair serves as fault localization that is the repair algorithm simultaneously identi es which expressions to modify and how to modify them.
without this property synthesizer would always modify all the suspicious expressions making milti location repair not practical due to the complexity of patches.
as will be shown in section this way of synthesis provides higher quality repairs than spr.
.
optimization to control the number of symbolic execution sessions we use the following iterative approach.
first we start from a small subset of the test suite that provides the highest coverage of the suspicious locations.
then we infer angelic forest for this reduced test suite and synthesize a patch.
if the generated patch causes a regression in the whole test suite we add the counter example test to the test suite.
we repeat these steps until all test cases become passing.
regarding running time there is one more advantage of semanticsbased methods.
contrasting to search based methods where the software under repair is rebuilt and retested frequently due to a high number of repair trails our semantics based method nds a repair in one or a small number of trials and the cost for rebuilding and retesting is signi cantly smaller.
because of type coercion and the absence of a separate boolean type in c programming language it is di cult to distinguish between types of program expressions.
on the other side knowing precise types increases the probability of synthesizing correct repair as well improves the synthesis performance.
for this reason we analyze the usage of suspicious expression and visible variables to collect type constraints.
then these type constraints are used to infer more precise types for program expressions and variables.
as an example we assign a boolean type to the expressions used as if conditions.
.
soundness and completeness while the size of an angelic forest independent of the size of the program it also under approximates the x space that is it cannot capture whole possibly in nite set of values for the suspicious expressions that make the test pass.
our repair method based on an angelic forest is sound in the sense that the repair obtained by our repair method indeed passes all the provided tests.
however our repair method is incomplete in the sense that it may not produce some 696repairs due to the under approximation of angelic values used in an angelic forest that can otherwise be synthesized.
experimental results we evaluate our repair method to answer the following two research questions.
rq1.
can our repair method generate repairs from largescale real world software?
rq2.
can our repair method x multi location bugs?
.
experimental subjects the rst columns of table show our subject programs the size of each program in loc and the number of tests and buggy versions of each subject in the tests and versions columns respectively .
our subjects are taken from the genprog icse2012 benchmark .
these subjects have been also used in the literature to evaluate other repair tools such as genprog and spr .
in particular wireshark and php are among the largest subjects in the benchmark.
we use these large subjects to evaluate the scalability of our repair method.
we omit three subjects of the benchmark python lighttpd and fbc because we could not run these subjects on klee .
klee currently cannot support all library functions.
note that this limitation of klee is orthogonal to our repair approach.
we use the same subjects to evaluate our second research question i.e.
multi location repairability.
furthermore in addition to these subjects in the genprog benchmark we add multi location bugs extracted from corebench to our subject list.
the reason we added multi location bugs additionally is that the genprog benchmark does not have many multi location bugs in the x space of our tool.
we describe the defect class of our repair tool in section .
.
.
tests and the correctness of patches the tests column of table shows the number of tests of each subject in the genprog benchmark.
we recti ed the original test scripts delivered in the genprog benchmark to address the problems pointed out in such as the weak proxy problem.
meanwhile each coreutils version available in corebench contains a failing test that can reproduce the defect.
we use these failing tests and the existing tests available in the subject.
all the repairs generated from our tool are manually inspected for its correctness.
we consider a repair correct only if the generated patch is functionally equivalent to the developer provided patch.
.
experimental configurations our repair tool allows to control the following parameters of our repair algorithm the maximum number of suspicious locations that can be repaired at the same time the kinds of suspicious expressions and the kinds of semanticspreserving program transformation.
first for the maximum number of suspicious locations we used the value between and inclusive .
second for the kinds of suspicious expressions we used the following three levels.
a higher level is more inclusive.
at the lowest level we allow only conditional expressions to be considered suspicious.
at the next level we also consider the right hand side expressions of assignment statements.
at the highest level we also consider function parameters.
at all levels only sidee ect function call free expressions are considered.
lastly for the semantics preserving program transformation we allow to add if before each unguarded statement.
we also allow to add if break at the end of a loop body to be able to produce a repair requiring to break a loop.
we provided our tool with the names of buggy source code les which are known through developer provided xes as in the previous studies .
all our experiments were performed on intel xeon e5 .20ghz cpu with ubuntu .
bit operating system.
we used hours as the timeout of each repair session.
.
defect class as pointed out in de ning defect classes supported by a repair algorithm helps evaluate the e cacy of a repair algorithm how e ectively bugs in the target defect class can be repaired and compare multiple repair algorithms one another which repair algorithm generates repairs more e ectively for the target defect class .
the defect class of our repair algorithm can easily be de ned in terms of the x that can be synthesized.
our repair tool can synthesize sidee ect function call free expressions that can be composed of boolean arithmetic relational operators variables available and constants.
also by using semantics preserving program transformation i.e.
adding if before unguarded statements xes requiring statement deletion is e ectively included in our defect class as shown with the motivating example in section .
however our repair tool currently cannot add a new statement variable.
the w i our defect class column of table shows the number of defects of each subject that are in our defect class.
we manually inspected each developer provided x to check whether the corresponding defect is in our defect class or not.
although there can be other possible xes di erent from a developerprovided x it is infeasible to consider all unknown possible xes.
thus we additionally only inspected xes from other repair tools spr genprog and ae and ours.
the number of defects within our defect class is less than the number of buggy versions shown in the versions column because some bug xes in the benchmark require adding new statements variables.
.
results from the genprog benchmark table shows our results from the genprog benchmark.
the rst ve columns are already explained earlier and self explanatory.
we only mention that subjects of the table are sorted by their sizes.
the fixed defects column shows the number of xed defects by our tool angelix and other tools spr genprog and ae.
similarly the equiv.
to developer fixes column shows the number of xes functionally equivalent to the developer provided xes out of the xed defects.
the results from other tools spr genprog and ae are taken from .
lastly time column shows the average running time of our tool for each subject when repairs were found.
the running time of the other tools are available in their respective papers although each tool is experimented on a di erent type of machine.
in all subjects with di erent sizes between kloc and kloc our tool successfully generated repairs for some defects.
our tool generated repairs for most defects in our defect class out of and more than third of these repairs out of are functionally equivalent to developerprovided repairs.
three defects in our defect class were not xed due to imprecise statistical fault localization e.g.
697table experimental results subject loc tests versionsw i our defect classfixed defects equiv.
to developer fixes time min angelix spr genprog ae angelix spr genprog ae wireshark 2814k php 1046k gzip 491k gmp 145k libti 77k overall table the number of defects exclusively repaired by each repair tool across the subjects subject angelix spr genprog ae wireshark php gzip gmp libti overall buggy initialization of a global variable was not ranked high .
one remaining defect requires modifying a string value a character sequence in a way that cannot be handled by our current solver the length of the string should change in a x .
as shown in the time column the average running time of our repair tool is about half an hour when a repair is found.
angelix an implementation of our new semantics based repair algorithm successfully generates repairs from real world software as large as kloc in minutes on average.
this result shows that a semantics based repair can scale.
angelix xed multi location bugs of the genprog benchmark.
we show these results along with the results from the multi location bugs of coreutils in section .
.
.
.
comparison with other repair tools repairability.
when compared with the state of the art repair tool spr our tool shows higher repairability more defects are repaired in our tool in libti vs and lower repairability in php vs .
in the remaining subjects both tools shows the same repairability.
this varying repairability across the subjects is related to the di erent defect classes of angelix and spr.
for example the defect class of spr contains inserting a function call such as memset and php defects are included in this defect class.
meanwhile angelix can x multiple buggy locations and two libti multi location defects are exclusively xed by our tool.
more generally table shows the number of defects exclusively repaired by each repair tool across the subjects.
our tool produced the most number of unique repairs as compared to spr genprog and ae.
i f td tdnstrips td tdcompression compression none td tdstripbytecount !
td tdstripbytecount a the buggy location of libti d13be72c ccadf48a i f td tdnstrips td tdcompression compression none td tdstripbytecount !
td tdstripbytecount b the repair generated by our tool angelix i f td tdnstrips td tdcompression compression none td tdstripbytecount !
td tdstripbytecount !
c the repair generated by spr figure comparison of repairs from angelix and spr table the number of functionality deleting repairs subjectangelix spr fixes del per fixes del per wireshark php gzip gmp libti overall repair quality.
we also qualitatively compare the repairs from angelix and spr.
figure shows a buggy location of libti d13be72c ccadf48a in a the repair generated by our tool in b and the repair generated by spr in c .
the di erence between the original code and each repair is shaded.
the spr repair looks problematic because it simply deletes functionality by disabling the block of code in the then branch.
indeed this patch is not functionally equivalent to the developer provided patch.
still such an over tting repair an incorrect repair that merely passes the provided tests can be helpful in debugging because the user can at least see that the incorrectly repaired if conditional may be buggy.
however compare this spr repair to the repair generated by our tool shown in figure 3b.
our repair spots the buggy location more precisely down to td td nstrips .
this is because our repair tool generates a repair that is close to the original buggy expression by using 698table experimental results for multi location defects.
defectfixed expressions libti 4a24508 cc79c2b libti 829d8c4 036d7bb coreutils 00743a1f ec48bead coreutils 1dd8a331 d461bfd2 coreutils c5ccf29b a04ddb8d a maxsmt solver.
as a result a problematic buggy location can be pinned down more precisely.
in fact our repair is identical with the developer provided repair in this case.
incorrect repairs that merely delete functionality are common in spr repairs.
table compares the number of repairs that delete functionality between our tool and spr.
in each tool the angelix and spr column respectively we list the number of xes generated in each tool the fixes column the number of functionality deleting xes the del column and the percentage of functionality deleting xes out of generated xes the per column .
in ve subjects used in our experiments of spr generated repairs delete functionality and in the libti subject the percentage goes up to .
even if the three omitted subjects python lighttpd and fbc are also considered the percentage of functionality deleting repairs stays even at a high rate of .
genprog and ae also often generate functionality deleting repairs as reported in .
in comparison angelix generates functionality deleting repairs less frequently .
angelix is not only scalable but also less frequently generates functionality deleting repairs than the existing tools such as spr and genprog.
.
results from multi location bugs table shows the experimental results for multi location defects of the genprog benchmark and coreutils.
the fixed expressions column shows the number of expressions xed by our tool.
angelix produced a repair functionally equivalent to the developer provided one for coreutils 00743a1fec48bead.
meanwhile in coreutils 1dd8a331 d461bfd2 while two conditional expressions are repaired in a functionally similar way to the developer patches the output message is not corrected in our repair because this message is not part of the the oracle in the tests used for repair.
in coreutilsc5ccf29b a04ddb8d the developer provided repair uses function calls that are not used in our repair.
we note that the number of defects covered by our multilocation defect class is limited at least in the two benchmarks we investigated the genprog benchmark and corebench .
many developer provided xes for multi line defects involve adding new variables statements and functions.
we believe that the research in automatic patching should be developed into such more sophisticated patches and our multi location defect class is on the pathway toward such a direction.
to the best of our knowledge only our repair tool can currently generate non functionality deleting xes for multi location bugs in large scale real world software.
experience with the heartbleed bug we applied our repair tool to a buggy version of openssl openssl .
.
beta1 that has the infamous heartbleed1 i f hbtype tls1 hbrequest f .
.
.
memcpy bp pl payload .
.
.
5g a the buggy part of the heartbleed vulnerable openssl i f hbtype tls1 hbrequest payload s s3 rrec.length f receiver side replies with tls1 hbresponse 4g b a x generated by our tool angelix 1if payload s s3 rrec.length return .
.
.
i f hbtype tls1 hbrequest f receiver side replies with tls1 hbresponse 6g else i f hbtype tls1 hbresponse f sender side 9g return c the developer provided repair figure the heartbleed bug and their xes bug.
heartbleed is considered one of the most dangerous in the annals of security vulnerabilities because attackers can exploit heartbleed to steal important con dential data including login cookies passwords and private cryptographic keys without leaving a trace from numerous servers depending on openssl to run their services.
we report that we could automatically x the heartbleed bug using our repair tool.
to the best of our knowledge this is the rst work that reports the automated repair on heartbleed.
the heartbleed bug is an instance of a bu er over read cwe one of common weakness of c c programs.
exploiting this weakness attackers can read beyond the region of a bu er that is originally intended by the programmers.
figure 4a shows where this weakness exists in the heartbleed vulnerable openssl.
the main culprit is memcpy bp pl payload line where attackers can assign payload the third parameter of memcpy that sets the number of bytes to copy from the target memory region a larger value than the size of bu er pl the target memory region.
the programmer of openssl made a common mistake of not putting a bounds check before this problematic memcpy .
we applied angelix to openssl for repairing the heartbleed bug.
we obtained tests from and added four more tests to cover missing corner cases.
figure 4b shows the x generated by our tool in the shaded area.
with this x memcpy cannot be invoked if payload is larger than is allowed by the tls dtls network protocol the buggy code of openssl is the implementation of these protocols .
our repair synthesizer could compose this repair with payload and s s3 rrec.length both of which are in the scope at the xed if conditional they appear in the other parts of the buggy function .
in comparison the developer provided repair is shown in the shaded area of figure 4c.
in both repairs the failure of the bounds check which is performed by the added conditional makes the receiver simply return zero instead of replying with a response packet.
based on our experience with heartbleed we make the following assessment.
automated repair techniques such as angelix are powerful enough to x some of well known and serious software vulnerabilities like heartbleed.
threats to validity since we used for our experiments the subject programs in the existing benchmark previously used to evaluate genprog ae and spr the validity of our experimental results are limited in the same way as for the results of the other tools obtained using the same benchmark.
that is our results may not generalize to other subjects although our repair tool successfully generated repairs for a small number of defects of coreutils and openssl.
however we note that the genprog benchmark we used for our experiments is one of the most extensive one available in the literature the manybugs benchmark has also been released very recently as an extension of the genprog benchmark .
meanwhile our results can be a ected by the con guration of our tool e.g.
the maximum number of suspicious locations .
however given the pervasiveness of cloud computing environments such as amazon ec2 this threat related to tool con guration does not seem as severe as traditionally believed since our tool can be run in parallel in the cloud with each node being assigned a di erent tool con guration.
related work genprog performs search based repair through genetic programming algorithm.
it is the rst general purpose program repair tool that showed the defects of large scale real world software can be automatically xed.
subsequently rsrepair and ae replace the genetic programming algorithm of genprog with random search and adaptive repair search strategies respectively.
while these repair methods scale well a recent study revealed that the quality of the repairs generated from these tools are quite poor the majority of these repairs simply delete functionality.
while par another search based repair tool uses human patch templates to improve the repair quality and validates its improved repair quality through a user study.
however as argued by the results of the user study on par in fact only shows that par repairs more resemble human patches than genprog repairs because repairs are generated through human patch templates .
the latest search based repair tool spr more often generates repairs that are functionally equivalent to developer provided repairs than its preceding search based repair tools by taking into account the partial semantics of conditionals that is the branches that should be taken to pass the tests.
however we found that spr still generates many functionalitydeleting repairs because it often generates trivial branch conditions such as if ... !
.
as reported earlier about half of the reported spr repairs delete functionality.
meanwhile semantics based repair methodology has shown its promise in its high quality of repairs.
the rst approach towards semantics based program repair was semfix where a combination of symbolic analysis and constraint solving was proposed to produce one line xes.
directfix used a maxsmt solver to synthesize minimal changes to the program which make the program pass all tests.
directfix removed the one line x restriction of semfix and yet gave an approach which is substantially less scalable than semfix.
our new repair tool addresses this scalability problem while retaining the ability to produce multi line xes.
while the key enabler for scalability is our novel repair constraint representation i.e angelic forest we also capitalize on the techniques successfully used in our previous work semfix such as controlled symbolic ex ecution.
this makes the angelix repair tool very scalable while generating high quality multi line repairs.
nopol uses an angelic value to synthesize a repair similar to angelix.
however the expressiveness of our angelic forest is substantially larger than the one of an angelic value.
consequently angelix can repair more bugs than nopol.
for example nopol cannot repair if conditionals whose x should take di erent directions at di erent times during execution because a single angelic value is not expressive enough to capture such a repair requirement.
meanwhile spr maintains a sequence of angelic values of a conditional expression instead of a single angelic value.
as a result spr can handle a broader class of defects than nopol.
however it cannot x multi location bugs whose x often requires information about dependence between multiple suspicious locations which cannot be captured only with sequences of angelic values.
even for single location bugs spr often generates functionality deleting repairs.
furthermore even when functionality is not deleted spr often generates templated repairs such as if ...jjregex len which may work only for a speci c test and break for fresh input not covered by the existing tests.
on the contrary our maxsmt based repair synthesizer often synthesizes a repair close to the original buggy expression.
apart from general purpose repair tools like ours there are also other repair approaches targeted for speci c types of defects e.g.
bu er over ow or speci c application domains e.g.
web applications .
also many previous works assume the existence of formal speci cation or contracts unlike test driven approaches such as ours.
lastly minthint suggests a repair hint instead of a patch by allowing some tests to remain failing and thereby performing statistical analysis for a class of semi repairs satisfying this relaxed requirement.
conclusion in this paper we have described how a semantics based repair method can scale to large scale real world software.
the key enabler for this scalability is our novel lightweight repair constraint called angelic forest .
we have shown through experiments that our repair method successfully generate repairs from various real world software including wireshark and php which are the largest programs to which automated repair tools have been applied.
furthermore on top of providing scalability our repair method also produces higher quality repairs than the existing scalable repair tools such as spr and genprog as compared to these existing tools our repair tool produced functionality deleting repairs less frequently in our experiments.
we also have shown that our repair tool successfully xed multi location bugs in realworld software which was not possible in the existing repair tools.
last but not least we have reported the successful patching of the well known heartbleed bug using our repair tool.