debugging with intelligence via probabilistic inference zhaogui xu1 shiqing ma2 xiangyu zhang2 shuofei zhu1and baowen xu1 1state key laboratory of novel software technology nanjing university china 2department of computer science purdue university usa abstract weaimtodebugasinglefailingexecutionwithouttheassistance from other passing failing runs.
in our context debugging is a process with substantial uncertainty lots of decisions have to be madesuchaswhatvariablesshallbeinspectedfirst.todealwith suchuncertainty weproposetoequip machineswithhuman like intelligence.specifically wedevelopahighlyautomateddebugging techniquethataimstocouplehuman likereasoning e.g.
dealing withuncertaintyandfusingknowledge withprogramsemantics based analysis to achieve benefits from the two and mitigate their limitations.
we model debugging as a probabilistic inference problem inwhichthelikelihoodofeachexecutedstatementinstance and variable being correct faulty is modeled by a random variable.
human knowledge human like reasoning rules and program semanticsaremodeledasconditionalprobabilitydistributions also called probabilistic constraints.
solving these constraints identifies the most likely faulty statements.
our results show that the techniqueishighlyeffective.itcanpreciselyidentifyrootcauses for a set of real world bugs in a very small number of interactions withdevelopers muchsmallerthanarecentproposalthatdoesnot encode human intelligence.
our user study also confirms that it substantially improves human productivity.
ccs concepts software and its engineering software testing and debugging keywords debugging probabilistic inference python acm reference format zhaoguixu shiqingma xiangyuzhang shuofeizhuandbaowenxu.
.
debuggingwithintelligenceviaprobabilisticinference.in proceedingsof icse 40thinternationalconferenceonsoftwareengineering gothenburg sweden may june icse pages.
introduction in this paper we aim to tackle the traditional debugging problem given a faulty program and a single failing run identify the corresponding authors.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
cause of the failure.
in our target scenario an oracle to tell the intended behavior for each step of execution is not available.
as such debugging becomes an uncertain procedure in which a lot of decisions have to be made such as which statements aremorelikelyfaulty whichvariablesshouldbeinspectedfirst and whether a function execution shall be stepped into.
algorithmic debugging techniques tend to avoid making decisions by conservativelyincludingallthepossibilities.forexampleindynamicslicing givenafaultyoutput alltheexecutedstatementinstancesthathavecontributedtotheoutputareincludedintheslice.whilethesetechniquescanpreciselymodelandreasonaboutprogramsemantics they lack the capabilities of making appropriate predictions in the presence of uncertainty.
the onus is hence on the developers toinspect the large volume of analysis results.
in contrast duringhuman debugging an experienced developer may not even start fromthevicinityofthefaultyoutput.instead shemayspeculate someplacesinthemiddleofexecutionthatcontainstatescritical to the failure and inspect the corresponding variables.
she decides if a variable has a faulty value based on her experience and domain knowledge.
in many cases she can quickly identify the root cause because she excels at collecting and fusing debugging hints tomakethecorrectdecisions.ononehand manyofthesehintsare highly uncertain e.g.
the variable name correlations between the faulty output variable and the root cause and hence can hardly be leveragedbyalgorithmicdebuggingtechniques.ontheotherhand humans do not have the capacity and stamina to reason about the low level program semantics at a scale close to machines.
human feedback driven debugging was hence proposed to integrate human reasoning and machine analysis .
for instance in a very recent proposal of interactiveslicing the toolreportsstatementinstancesinadynamicslicetothedeveloper oneatatimebasedontheirdistancetothefaultyoutput.thedevelopercanindicateifareportedinstanceisfaulty andifnot what operands ofthe instanceare faulty.
the toolthen recomputesthe dynamicslicefromthefaultyoperands precludingstatementinstances that led to the correct operands in the instance .
however inmostexistingtechniquesincluding thecouplingbetween machines and humans is very primitive the machine analysis is incapableofhandlinguncertaintyandhumansstillhavetomakeallthedecisions.asaresult theysufferfromlimitationssuchasexcessive requests for human intervention and false positives negatives due to human mistakes.
wedevelopatechniquethatallowsmachinestotakeoveralarge partofthehumanreasoningofuncertainty andcouplesuchuncertaintyreasoningwithprecisemodelingoflowlevelprogramsemantics such that we can achieve the benefits of both human and machine reasoningsandmitigatetheirlimitations.inparticular wemodel debuggingasaprobabilisticinferenceprocedure.randomvariables are introduced to denote the likelihood of statement instances and acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden z. xu s. ma x. zhang s. zhu and b. xu variablesbeingcorrect faulty.thesemanticsofeachexecutedstatement is modeled as a conditional probability distribution which is also called probabilistic constraint in this paper e.g.
given x y if xislikelycorrect then yislikelycorrect .theoutputsaremodeled as observations e.g.
the correct outputs are associated with probability .
of being correct and the faulty outputs with probability .
.humandomainknowledgeandfeedbackarealsoencodedas probabilisticconstraints e.g.
thelikelihoodofbeingbuggyfora variable with a name correlated to the name of the faulty output variableishigherthanothers .theseconstraintscanberesolved by a probabilistic inference engine .
the inference procedure is similar to solving smt sat constraints.
the difference lies in that ourinferenceresultsareposteriormarginalprobabilities instead ofsatisfyingvalueassignments thatindicatethelikelihoodofeach statement instance and variable being correct faulty given the observationsandthehumanfeedback .theprocedureisanalogousto applyingforcestoanelasticmesh inwhichtheobservationsand humanfeedbackareanalogoustotheforcesandthecorrelations between statements variables derived from program semantics are analogous to the mesh.
when the mesh finally stabilizes the state of each node on the mesh reflects the effect of the joint force.
comparedtotheaforementionedexistingfeedbackdrivendebugging developers intervention feedbackissubstantiallyreduced asthetechniquecanperformhuman likereasoningindealingwith uncertainty our technique allows developers to be uncertain abouttheirfeedbackandhumanmistakescanbedilutedandeventu allyover poweredbyotherevidences and ithasthefullcapacity of machine analysis by faithfully encoding program semantics.
our contributions are summarized as follows.
we propose the idea of modeling debugging a single failing run as a probabilistic inference problem such that our techniquecanautomaticallyperformbothhuman likereasoning thatfeaturesuncertaintyhandlingandprogramsemantics based reasoning that features precision.
we devise a comprehensive set of rules to encode both programsemantics observations domainknowledge andhuman feedback as conditional probability distributions.
we develop a prototype for debugging python programs.
our evaluation on real world bugs shows that on average our tool can locate a root cause in steps of interaction with the developer for large projects and steps for smaller programsfromstackoverflow.incontrast requiresmore than steps and may miss the root causes.
our user study shows that our tool can reduce debugging time by on average.
the analysis time is within seconds for most cases.
motivation motivatingexample.
fig.1showsasimplifiedcodesnippetfrom a popular python http library requests .
line invokes functionpath url definedinlines1 .insidethefunction theprogramfirstsplitstheinput urlintopathandquery line2 .withthe failure inducing input the resulted values of pathandqueryare t 20c and x respectively.
line encodes the path segment of the url by replacing special characters with their encodings e.g.
spaceto and to totranslateittothestandardhtml1 def path url url path query urlsplit url path encode path if not path path purl purl.append path ifquery purl.append ?
purl.append query purl str make str purl return purl str def make str lst s for iinlst s s i return s url path url print url figure motivating example.
uri format.hence the encoded pathhas thevalue t 2520c after replacing with .
lines validate that pathis not empty.line6appends pathtoalistpurl.lines8 10furtherappend aseparatorsymbol ?
andquerytothelist.line11callsthefunctionmake str to transform purlto a string.
inside make str lines13 17concatenateeachitemin purlandreturnthefinalvalue t 2520c?x .
this code snippet is buggy at line because the pathisdoubleencoded andthecorrectversionshouldcheckifit has already been encoded before executing line .
the expected output should be t 20c?x with the encoding of space.
existingmethods.
inmanualdebugging developersusepdb andpycharm debugger i.e.
thepythonversionofgdb to set breakpoints at places that are considered suspicious and inspect variablevaluesatthosepoints.inthisprocedure developershaveto makealotofdecisionstodealwiththeinherentuncertainty.many ofthedecisionsaremadebasedontheirexperience.forexample the library function append is unlikely to be buggy so that the developers do not need to step into its execution.
however the effectivenessofmanualdebuggingheavilyhingesontheexperience ofdevelopers.moreover humanshavelimitedcapacityofreasoning aboutlowlevelprogramsemantics.forexample itisdifficultfor humans to use debuggers to follow a lengthy data flow path.
many automated debugging techniques such as delta debugging andfault localization arehighly effective.
but they often require a passing run that closely resembles the failingrun oralargesetofpassingandfailingruns toserveasthe referenceto suppressuncertainty.however inpractice reference run s with high quality may not be available.
dynamic slicing identifies a subset of executed statements that contributed to an observed faulty output based on program dependencies.
it makes very conservative assumptions in dealing withuncertainty.
for instance line concatenates two substrings right hand side rhs sandi toproduce theleft hand side lhs s. if the lhs sis observed faulty it assumes both the rhs sandiare potentially faulty and includes both in the slice.
in our example the dynamic slice of the printed value of variable urlat line includes all the statements presented in this example and also the bodies of functions urlsplit andencode that are omitted.
it hence requires a lot of manualefforts to go through statements in the slice in order to identify the root cause.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
debugging with intelligence via probabilistic inference icse may june gothenburg sweden recently aninteractiveapproach wasproposed.itgradually presents statement instances in a dynamic slice to the developer who provides feedback such as whether an instance itself is faulty.
ifnot thedevelopershallindicatewhichoperandoftheinstanceis faulty.the techniquethen computesa newslice startingfrom the faultyoperand.itessentiallyprunespartoftheoriginalslicerelated to thecorrect operand s .
considerour example it firstcomputes the slice of line .
the slice includes all the executed statement instances.
it first presents lines and to the developer one atatime.thedeveloperindicatesthatthosestatementsthemselves are not faulty but rather their operands are faulty.
it then presents line to the developer who indicates that the rhs sis faulty but i isnot.assuch thetechniquecomputesanewsliceon s precluding iand its dependencies.
although the technique does improve over slicing its integration between machines and humans is primitive.
thealgorithmisfullydeterministicanddoesnothandleuncertainty and the developer merely serves as an oracle.
as such the number of human interactions required can be large.
in our example it requires interactions until the root cause is identified.
moreover it does not handle tolerate human mistakes.
for example if the developer mistakenly determines iat line is faulty and the rhs s is correct the root cause can never be reached.
ouridea.
weproposeanautomatedtechniquethatcoupleshumanlikereasoning e.g.
handlinguncertainty leveragingdomainknowl edge andfusingdebugginghintsfromvarioussources withprecise lowlevelprogramsemanticsbasedanalysis.assuch alargepart of the human workload can be shifted to machines.
the idea isto formulate debugging as a probabilistic inference problem.
we introduce randomvariables todenotethelikelihoodofindividual statement instances and variables being correct faulty encode program semantics human reasoning rules as probabilistic constraints andinputs faulty outputs humanfeedbackas observations that aredenotedas priorprobabilities i.e.
probabilitiesbeforeinference .
thepriorprobabilitiesandconstraintsarefedtotheprobabilistic inferenceenginetocomputethe posteriorprobabilities ofindividual statement instances and variables being correct faulty.
the posteriorprobabilityofavariableisoftendifferentfromitsprior probability denotingabetterassessmentafterfusinginformation from other related variables.
next we will walk through the example to intuitively explain howourtechniqueidentifiestherootcause.beforeinference urlat line19isassociatedwithaconstantpriorprobability low .05to indicateitisfaultyand urlatline1isassociatedwith high .
to indicate that it is correct.
it is standard in probabilistic inference not to use .
or .
but rather values very close to them .
sincewehavenoobservationsonotherprogramvariables their prior probabilities are set to a constant uncertain .
.
the inference engine takes the prior probabilities and the probabilistic constraints derived from program semantics and computes the posterior probabilities.
next we present some of the computed posterior probabilities and explain their intuition.
from the program semantics constraints urlis faulty at line 19suggeststhat urlat18and purl str atline12are likelyfaulty withposteriorprobabilities ofbeingcorrect computedas0.
and0.0832afterinference.theprocedureofcomputingposterior probabilities from prior probabilities will be explained in later sections.
the posterior probabilities model the following.
there aretwopossiblereasonsleadingtothefaultyvalueof url.oneisthe executedstatementatline12isbuggy buttheoperand purl str is correct and the other isthe value of operand purl str is faulty.
since there is no other observation indicating the simple return statementisfaulty thecomputedposteriorprobabilitiesindicate that it is more likely that purl str has an incorrect value.
note that a variable being faulty does not mean our tool reports it tothe developer as all the variables along the failure propagationpath i.e.
the dependence path from the root cause to the faultyoutput are faulty but we are interested in the root cause which is a statement instance.
leveraging data flow constraints our tool further infers that variable purl str being likely faulty at line entails that sat line is likely faulty and hence sat line likely faulty with probability being .
.
line is executed three times producing three svalues namely t 2520c t 2520c?
and t 2520c?x .whencomparingthegeneratedoutputwith theexpectedoutput ourtoolalsomarkedthecorrectnessofindividual bytes.
hence at this point it can factor in the observation that the output substring 20c?x created by the last two instances of line is correct.
this suggests that the root cause is unlikely atline16 reflectedbythecomputedposteriorprobability0.
.
instead the first instance of iat line is likely faulty.
our tool also encodes various human domain knowledge as probabilisticconstraints.forexample thenameofthefaultyoutput variableandthenameofafunctionthatcontainstherootcausetend tohavesomecorrelationintermsofnaturallanguagesemantics.as such function path url isconsideredmorerelevantthanfunction make str reflected by larger prior probabilities for statements in theformer.thefirstinstanceof iatline16beingfaultysuggests that the resulted purlat line inside path url is likely faulty i.e.
posterior probability .
being correct .
again there are two possible sources that lead to the faulty state of purlat theappend functionisfaultyand pathisfaulty.ourtoolhas encodedthedomainknowledgethatanexternallibraryfunction is less likely faulty than user code.
this leads to out weighting during inference.
note that it is not a problem for our tool even if the heuristics do not apply e.g.
the root cause does reside in library instead of user code as our technique is probability based.
theeffectofaheuristiccanbeout weightedbyevidencescollected from other sources.
variable pathat line being faulty suggests either a the rhs pathat line is faultyor b line itself is faulty.
the observation that input urlat line 1being correct as itis from the input leads topathandqueryat line are likely correct because they are identical to parts of url.
this further suggests the rhs pathat line islikelycorrect.assuch b islikelytrueandhenceline3isthe statement instance with the lowest posterior probability .
being correct.
note that statement instance probabilities are dif ferent from variable probabilities as the former indicates wherethe root cause is.
although we describe the procedure step by step our tool encodes everything as prior probabilities and probabilistic constraints that are automatically resolved.
in other words the entire aforementioned procedure is conducted internally by our tool and invisible to the developer.
also observe that the inference procedure is bidirectional e.g.
the backward reasoning from the output atline and the forward reasoning from the input at line .
it is iterativeaswellandterminateswhenafixedpointisreached.
these authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden z. xu s. ma x. zhang s. zhu and b. xu figure system framework.
features distinguish our technique from iterative slicing e.g.
ortechniquesthatpresentadynamicslicetothedeveloperthrough interactions e.g.
asslicingdoesnotconductanybidirectional or fixed point probabilistic reasoning but rather traverses program dependencies.thestatementinstancewiththelargestprobability to be faulty is reported to the developer.
if the developer disagrees shecanfurtherprovideherassessmentaboutthe likelihood thatthe operandsinthereportedstatementinstancearefaulty.thefeedbackisencodedasanewobservation i.e.
newpriorprobabilities that can be propagated backward and forward and another round of inference is performed to identify the new root cause candidate.
note that human mistakes in feedback can be tolerated as they do notleadtotheexclusionoftherootcausebutratherjustafewmore extra rounds before locating the root cause.
this faithfully mimics howhumanmistakesaretoleratedinrealworldmanualdebugging.
inourexample ourtoolcorrectlyreportsthetruepositiveinthe first round which is much more effective than .
overview in this section we give an overview of our system.
framework.
fig.
presents the system architecture of our tool.
it consists of four components the tracing component the prob abilistic constraint encoding component the probabilistic inference engine and the feedback component.
the tracing component takesthebuggyprogramandatestinputandgeneratesthetrace ofafailingexecution.theprobabilisticconstraintencodingcomponentautomaticallyencodespriorprobabilitiesandconstraints from various resources.
it consists of two subcomponents variable correctness faultiness probabilistic constraint encoder andstatement instancecorrectness faultinessencoder.theformergeneratesprior probabilitiestoindicateinitialobservationsofvariablecorrectness faultiness.suchpriorprobabilitieshavethreepossibleconstantvalues high .
to denote a variable having a correct value e.g.
an input variable or an output variable holding a correct value low high .
to denote a variable having a faulty value e.g.
a faulty output variable and uncertain .5t o denotewehavenoobservation prior knowledgeaboutavariable mostvariablesfallintothiscategory .itisstandardtousethese constant values as prior probabilities .
we will study the effect ofhavingdifferent highconfigurationsinsection6.besidesprior probabilities it also generates constraints that correlate probabilities according to program semantics e.g.
x ydictates the strong correlation between xandy s probabilities .the inferenceengine takesthepriorprobabilitiesandtheconstraints performsprobabilityinferencetocomputeposteriorprobabilities.theinference procedurecanbeintuitivelyconsideredasaprocessoffusinghintsx runtimevariableset inst executedstatementinstanceset p x inst asserts a variable xor a statement instance instis correct.
s inst asserts a statement instance instis correct from the program structure.
n inst asserts a statement instance instis correct from the naming convention.
c ap brepresents a probabilistic constraint denoting predicate ahas a propagation probability pimplying predicate b. figure basic definitions.
from various observations i.e.
high lowprior probabilities throughthepropagationchannelsdictatedbytheconstraints.at the end many variables that had uncertain prior probabilities now have posterior probabilities different from uncertain indicating their likelihood of being correct faulty.
the secondsubcomponent the statement instanceencoder automatically generates constraints to infer if individual statement instances are correct faulty from variable probabilities and domain knowledge.theearlierinferenceresultsofvariablecorrectness faultiness are provided as prior probabilities to the statement instanceinferenceprocedure.eventually thestatementinstancesare ranked by their posterior probabilities.
the one with the largest probabilityofbeingfaultyisreportedastherootcausecandidate.if the developer disagrees she provides feedback to indicate whether the reported statementinstance containsfaulty variable s which may trigger another round of encoding and inference.
the process is iterative till the root cause is identified.
motivationexamplewalk through.
wesimplifytheexecution traceofthemotivatingexampleinfig.1asthefollowingtoillustrate the workflow of our technique.
e1 url2 url1 l1 e2 p1 url2 l2 e3 path1 m1 l3 e4 s1 path1 ?
l16 e5 s2 s1 query1 l16 e6 url3 s2 l17 table1 simplifiedtraceofthemotivatingexampleinfig.
.
all the runtime variables in the trace are transformed to the static single assignment ssa form so that each of them is defined exactlyonce.thesubscriptofavariableisusedtoidentifyaspecific instance of the variable.
the line numbers of these trace events arealsoshownontheirright e.g.
l2meansline2 .thevalueof variableurl3is faulty whereas url1andquery1are correct.
phase i inferring variable correctness faultiness probabilities.
with the execution trace our encoding component first performs dynamicslicingfromthefaultyoutputvariable s andthenencodes thesemanticsofeacheventintheslice.withthesimplifiedtracein table the faulty output is url3 whose dynamic slice contains all theevents.takeevent e5asanexample.giventhebasicdefinitions shown in fig.
the variable constraints are encoded as follows.
p s1 p query1 .
p s2 p s2 p query1 .
p s1 p s1 p s2 .
p query1 since we do not know which step executes a faulty statement in thisphase weinitiallyassumeeveryexecutedstatementinstance is likely correct.
therefore given the assumption that the addition statement is correct in event e5 constraint represents if both operandsarecorrect theproducedvalueisalsocorrectwithahigh probability high .
.thisprobabilityisassociatedwiththe constraint insteadofavariable andcalledthe propagationprobability.
intuitively it can be considered as an information flow throttle authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
debugging with intelligence via probabilistic inference icse may june gothenburg sweden during inference controlling how much s2 s probability is affected bythoseof s1andquery1.notethatthepowerofprobabilisticinferenceliesinautomaticallycorrecting initialbeliefs assumptions byfusinginformation.forinstance observationsabout s2orvalues computedfrom s2 inotherstatementinstances wouldallowthe enginetoadjusttheprobabilityof s2ine5andpotentiallythebelief about the correctness of e5.
constraints and representiftheresultaswellaseitherone of the two operands are correct the other operand is likely correct.
intuitively since it is a one to one mapping between the operands and the result value for an addition the propagation probability is high.thepropagationprobabilityislowerforotherstatements that denote many to one mapping.
for instance for the statement executedatevent e3 ifweknowboth path1andm1arecorrect the likelihood of the index p1being correct is dependent on if there exist multiple indexes whose corresponding array values are the same as the value of path1.
if there are no other array elements thathavethevalueof path1 p1iscorrect.iftherearemanysuch elements we essentially get no hints about p1 s correctness.
the detailed computation rules of the propagation probability for each kindofstatementarepresentedinsection5.
.
besidesencoding constraints ourtoolalsoencodespriorprobabilities forinputsand outputs .
for example we have the following prior probabilities in the parentheses for the trace in table .
p url3 .
p url1 .
p query1 .
we send the encodings to a probabilistic inference engine to computetheposteriorprobabilityofeachpredicate p x beingtrue.
duringprobabilisticinference arandomvariableisassociatedwitheachpredicatetoindicatethelikelihoodofthepredicatebeingtrue.
theinferenceenginetransformsconstraintsandpriorprobabilities toafactorgraph andthenusesthe sum product algorithmto computethe posteriorprobabilities.
we willdisclose moredetails about probabilistic inference in the next section.
for this example theposteriorprobabilitiesofpredicates p s1 p query1 andp s2 being true are .
.
and .
respectively.
phaseii inferringstatementinstancecorrectness faultinessproba bilities.inthisphase weleveragethevariableprobabilities from phasei anddomainknowledgetodeterminethelikelihoodofeach executedstatementinstancebeingcorrect faulty.particularly we generatethreekindsofconstraints.first wegenerateconstraints correlating variable probabilities and statement instance probabilities.
for event e5 we generate the following constraints.
pe5 s2 pe5 s1 pe5 query1 .
p inste5 pe5 s2 pe5 s1 pe5 query1 .
p inste5 pe5 s2 pe5 s1 pe5 query1 .
p inste5 intuitively constraint represents if all the involved values at event e5are correct the addition operation is likely correct.
constraint represents if the resulted value is faulty and bothoperandsarecorrect theadditionoperationislikelyfaulty.con straint denotes if the resulted value is faulty and at least one operandisfaulty theadditionoperationislikelycorrect.according to constraint since the probabilities of both p s2 .
andp s1 .
are low the statement instance e5is likely correct and the root cause is likely before e5.
second itgeneratesconstraintsfromprogramstructure.inpractice programs often have modular design to achieve functional coherence.therefore ifafunctionincludesalargenumberofstatementsthatareexecutedandincludedintheslice thefunctionis likely to include the faulty statement i.e.
root cause .
in our example more statements from function path url are included in the slicethanfrom make str hencestatementinstancesintheformer function are given priority over those in thelatter.the constraint related to e5is shown in the following.
s inste5 .
p inste5 s inste5 .
predicates inste5 anditspriorprobability0.70representthe prediction of e5being correct based on its structure.
here since e5 is inside make str itsprior probability of correctness is higher than those in path url .
the prior probability .
is derived through program analysis see section .
.
during inference it adds weight to the posterior probability of p inste5 .
third our technique generates constraints from the naming convention.weassumethatfunctionnamesandvariablenames including those of the observed faulty variables follow certainnaming conventions and these names suggest functionalities tosome extent.
if two variable names are correlated in the natural language perspective their functionalities are possibly related too.
forour example the function name path url ismore similarto the name of the observed faulty variable url than the function name make str .it suggeststhat statementinstances infunction path url havestrongercorrelationswiththefailurethanthose infunction make str andhenceshallbegivenhigherpriority.for example the naming constraints of e3are shown as follows.
n inste3 .
p inste3 n inste3 .
predicaten inste3 denotes if e3is predicted to be fault related by naming convention.
the prior probability .
is derived from nlp analysis see section .
.
finally wesendtheseconstraintsandpriorprobabilitiesagain to the inference engine to compute the posterior probabilities of statementinstances.wereportthemostlikelyfaultyinstance.in this example event e3has the smallest probability of being correct.
it is indeed the true root cause.
probabilistic inference in this section we illustrate how probabilistic inference is con ducted.
first of all we present some basic notations.
we denoteeach involved predicate pby an individual random variable x. givenasetofprobabilisticconstraints c1 c2 ... andcm w euse asetofcorrespondingprobabilisticfunctions f1 f2 ... andfmto describethevaluationoftheseconstraints.formally aprobabilistic function fican be presented as the following.
fi x1 x2 ... xk braceleftbiggpif the constraint ciis true.
potherwise wherex1 x2 ... xkdenotetherandomvariablesassociatedwiththe constraint ciandprepresentsthepriorprobabilityoftheconstraint yielding true.
probabilistic inference is essentially to satisfy all the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden z. xu s. ma x. zhang s. zhu and b. xu table boolean constraints with probabilities.
x1x2x3f1 x1 x2 x3 f2 x1 x2 x3 f3 x2 f4 x3 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
constraints.
in this context the conjunction of the constraints can be denoted as the product of all the corresponding probabilistic functions as shown in the following.
f x1 x2 ... xn f1 f2 ... fm thejointprobabilityfunction whichisessentiallythenormalized version of f x1 x2 ... xn is defined as follows.
p x1 x2 ... xn f1 f2 ... fm summationtext x1 ... xn f1 f2 ... fm the posterior marginal probabilityof xi denotedas p xi isthe sum over all variables other than xi .
p xi summationdisplay x1 summationdisplay x2... summationdisplay xi summationdisplay xi ... summationdisplay xnp x1 x2 ... xn example.
weusetheexampleinsection3toillustratemoredetails.
for simplicity we only consider the inference for constraints and in phase i for the event e5.
let random variables x1 x2and x3denotethepredicate p s1 p query1 andp s2 respectively.
hence we have the following formula for constraints and .
c1 x1 x20.
x3c2 x3 x20.
x1 we assume the prior probabilities of x2andx3are .
and .
respectively.
they are denoted as follows.
c3 x2 .
c4 x3 .
wethentransformeachconstrainttoaprobabilityfunction e.g.
theprobabilityfunction f1forconstraint c1ispresentedasfollows.
f1 x1 x2 x3 braceleftbigg0.
if x1 x2 x3 .
otherwise others are transformed similarly.
table presents the values of theprobabilityfunctions.assumewewanttocomputetheposterior marginalprobability p x1 whichmeanstheprobabilityof s1 being correct.
the computation is as follows.
p x1 summationtext x2 x3f1 x2 x3 f2 x2 x3 f3 x2 f4 x3 summationtext x1 x2 x3f1 x1 x2 x3 f2 x1 x2 x3 f3 x2 f4 x3 .
.
.
.
... .
.
.
.
.
.
.
.
... .
.
.
.
.
.
.
itisthesumoftheproductofvaluationswith x1 e.g.
thefirst item0.
.
.
.95istheproductof f1 x1 x2 x3 .
f2 .
f3 .
andf4 .
divided by the sum of the product of all valuations.
implementation.
inpractice thecomputationofposteriormarginal probabilities is very expensive.
in our implementation we representalltheprobabilisticconstraintswithagraphicalmodel calledfactor graph which supports efficient computation.
wea.variableconstraints p pred logicalandtext u uses e p u high p def foreachu uses e p pred p def logicalanddisplay x uses e up x pu p u p def logicalandtext x uses e p x high p pred b.computationrulesof p uin s z x x bopy bop pu high s z xmody px uncertain s y x.fv a l u e s y vv a l u e s x o px objswithattrval f v po.f high s y x values x ov a l u e s i vivalues y v px cltswithidxval vi v pi idxeswithval v o po high s ifx ythens1elses2values x values y px high py high s ifx nequalythens1elses2values x nequalvalues y px .
py .
function definitions n .
.
high nvalues x the value of xobserved during execution objswithattrval a v returns objects having attribute awith value v objswithattr a returns the objects having attribute a cltswithidxval i v returns collections having value vat indexi idxeswithval v c returns indexes containing value vin collection c figure variable constraints.
compute marginal probabilities based on the sum product algorithm .
the algorithm is essentially a procedure of message passing alsocalled beliefpropagation inwhichprobabilitiesare only propagated between adjacent nodes.
in a message passing round each node first updates its probability by integrating all the messagesitreceivesandthensendstheupdatedprobabilitytoits downstream receivers.
the algorithm is iterative and terminates when the probabilities of all nodes converge.
our implementation is based upon libdai a widely used open sourced probabilistic graphical model library.
constraint generation inthissection wepresenthowtogenerateprobabilisticconstraints.
as discussed in section our analysis consists of two phases.
in the first phase we generate variable constraints and in the second we generate statement instance constraints.
.
variable constraint generation inthefirstphase constraintsareconstructedfromtheexecution tracetomodeltheprobabilitiesofvariablesandbranchpredicate states.
note that in this phase we only reason about the correctness faultinessofvariables whichwillbeusedtoinferstatement instancecorrectness faultinessinthenextphase.intuitively our design can be understood as first finding the correctness faultiness ofvariables thenthestatementinstancesthathaveoperandslikely correct but the result variable likely faulty are likely buggy.encoding rules.
fig.
4a presents the encoding rules.
rule encodes the forward causality of a statement instance e denoting the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
debugging with intelligence via probabilistic inference icse may june gothenburg sweden propagationofthelikelihoods ofbeingcorrect fromthecontrol dependence predicate pred i.e.
econtrol depends on pred the uses i.e.
rhs operands of e to the definition i.e.
lhs variable def .
intuitively iftheusesandthecontroldependencearecorrect there isgoodchancethelhsvariablehasacorrectstate.rule encodes the backward causality denoting the propagation of correctness likelihood from the lhs variable to oneof the used variables.
intuitively if the lhs variable the control dependence and all the otherrhsoperandsarecorrect theremainingrhsoperand uhaspu nothigh probability to be correct.
different kinds of statements have different puvalues.
details will be explained later.
rule representsthecausalityforpredicates.ifalltherelatedvariablesin a statement instance ehave correct states the control dependence predis likely correct i.e.
the correct branch has been taken .
computation rules of the backward propagation probabil ityp u.fig.4bpresentspartofthecomputingrulesof pu inrule .theessenceoftheserulesistodetermine pubasedonwhether the computation is a one to one or many to one mapping.
rule specifiesthecomputationruleforstatementsdenotingoneto onemappings.inthiscase puishightoindicateifthelhsis correct arhsoperandisdeterminedtobecorrectwhenallother rhsoperandsarecorrect e.g.
when z x y zandxlikelycorrect indicates ylikelycorrect .
specifiesforamodoperation z xmody zandybeing correct does not hint xis correct.
this is reflected by px uncertain .
which means there is no evidenceindicatingthecorrectnessof x.intuitively givenaspecific yvalue e.g.
y there are many possible values of xthat yield thesame zvalue e.g.
z byz xmody e.g.
x ... .
hence x s correctness is unknown.
is for an attribute read.
it means that yandxcorrect indicates the attribute read o.fis likely correct i.e.
po.f high withotheobjectin x.ontheotherhand if yando.fcorrect the likelihoodof xbeingcorrectdependsonthenumber nofobjects thathavethesame ffieldandthesamefieldvalue v.itiscomputed as n .
particularly when n the probability is high.i fnis large theprobability tends to be0.
i.e.
correctness isunknown .
the rule for attribute write is similar and hence elided.
specifies the rule for an element read of a collection which includes three uses i x andx and one definition y. the rule means when y i andx are correct the likelihood of xcorrect px depends on the number of collection objects that have value v atindexvi wheny x andxarecorrect thelikelihoodof ibeing correct pi depends on the number of indexes in the collection objectothat store the same value v wheny x andiare correct the array element is likely correct.
we use po instead of px becauseduringinference therandomvariableisassociatedwith the collection element o instead of the symbol x .
istheruleforequivalencecheck whichhastwouses xand yandadefinition namely thebranchoutcome.itmeansthatif x andyare equivalent the branch outcome and xcorrect indicates y correct i.e.
py high and similarly the branch outcome and y correctindicates xcorrect.intuitively equivalencerelationdenotes a one to one mapping.
for instance assume x yielding true is correct and is correct a faulty xcannot yield the correct branch outcome.
in contrast indicates that if xandyare inequivalent the branch outcome and xbeing correct does not suggestycorrect.intuitively inequivalenceindicatesamany to onea.variable to statement constraints pe pred pe def logicalandtext u uses e pe u high p inste pe pred pe def logicalortext u uses e pe u high p inste pe pred pe def logicalandtext u uses e pe u high p inste b.program structure constraints s inste high p inste s inste spe spe 1 sliceinfunc e fullslice bracehtipupleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipdownright bracehtipdownleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipupright 2 instsnotinslice e allinsts e bracehtipupleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipdownright bracehtipdownleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipupright c.naming convention constraints n inste high p inste n inste npe npe 1 simfunc e bracehtipupleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipdownright bracehtipdownleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipupright 1 simstmt e bracehtipupleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipdownright bracehtipdownleft bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehext bracehtipupright function definitions 1 x .
.
high x 2 y .
.
high y sliceinfunc e returns the instances in slice that belong to the function of e. fullslice returns all the instances in the slice.
instsnotinslice e returns instances of the statement of ethat are not in the slice.
allinsts e returns all the instances of the statement of e. simfunc e calculates the similarity between the function name of e s statement and the faulty output variable s name.
simstmt e returns the average similarity between each involved variable name inewith the faulty output variable s name.
figure statement instance constraints.
mapping.forinstance assume x nequal10yieldingtrueiscorrectand is correct there aremany values of xthat canyield thecorrect branchoutcomeandhencewecannotgainanyconfidenceabout the correctness of x. the rules for other comparative operations e.g.
and are similarly defined.
.
statement instance constraint generation we generate three kinds of constraints for statement instances variable to statementconstraints modelingthecausalitybetween variable probabilities and statement instance probabilities program structure constraints modeling hints from program structure namingconventionconstraints modelinghintsfromnames.we reason about statement instances instead of statements because aninstanceofafaultystatementmaynotinduceanyfaultystate atall forexample x beingmistakenas x doesnot induce any faulty states for any x nequal10.
in this case we consider the instance as correct.
hence in this paper we do not allow the likelihood of an instance being correct faulty to directly affect the likelihood of another instance of the same statement.
variable to statement constraints.
constraint in fig.
5a denotes that if all the variables involved in a statement instance e includingthecontroldependence thedefinitionandalltheusesarecorrect theinstanceislikelycorrect.constraint representsthat if the control dependence is correct but the definition and at least oneusearefaulty theinstanceislikelycorrect.thisisbecausethe root cause must happen before the current instance.
constraint denotesthatwhenallusesarecorrectbutthedefinitionisfaulty the statement instance is likely faulty i.e.
the root cause .
we use theposteriorvariable probabilitiesfromthepreviousphase asthe prior probabilities of variables in this phase.program structure constraints.
from program structure we can extract hints to enhance inference.
given an instance eof statement s we consider the following two kinds of hints from program structure.
first at the function level we focus on how authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden z. xu s. ma x. zhang s. zhu and b. xu manyinstancesintheslicebelongtothefunctionof s.thelargerthe number themoresuspicious eis becausethefaultyoutputismore likelycomposedinthefunction.
second atthestatementlevel we considerhowmanyotherexecutedinstancesofstatement sarenot intheslice.specifically if sisexecutedmanytimesbutonlyafewof them are included in the slice of the failure the statement instance islesslikelyfaulty.forexample somelow levelutilityfunctions e.g.
make str in the fig.
are called many times at different points and only a few of them are related to the failure.
statement instances in these low level functions are unlikely suspicious.
fig.5bpresentstheprogramstructureconstraintswhere s inste asserts that instance eis correct from the program structure perspective.
the prior probability speofs inste is computed by the average of twoparts.
part 1computes the probabilityat the functionlevel.ifmanyinstancesinthefunctionof eareincludedinthe slice theprobabilitytendstobe low denotingtheyaresuspicious.
otherwise ittendstobe0.
.part 2computestheprobabilityatthe statement level.if manyinstances of thestatement of eare notin the slice the probability tends to be high suggesting correctness.
otherwise it tends to be .
.
namingconventionconstraints.
givenafaultyvariable xand aninstance eofstatement s wecollecttwokindsofnamingconvention hints.
first we measure how similar the function name of statement sistothenameoffaultyoutputvariable x.thehigher the similarity the more suspicious eis.
second at the statement level we consider the similarity between the name of the faultyoutput variable xwith variable names in the statement s. when theaveragesimilarityishigh thesuspiciousnessof eishigh.for example in the example of fig.
instances of line are consideredlesssuspiciousthaninstancesofline11because url ismore similar to purl str purl than to s i .
fig.5cpresentsthenamingconventionconstraintswhere n inste asserts that instance eis correct from the naming convention perspective.
the computation of the prior probability npeofn inste consists of two parts.
part 1computes the probability from the function level naming convention.
intuitively if the similarity ishigh theprobabilityapproaches1 high.otherwise theprobabilityapproaches0.
.part 2computestheprobabilityfromthe statement level naming convention.
thecomputationoflexicalsimilaritiesbetweenstringsissimilar totheoneillustratedinsection5.4inourpriorwork .weomit the details due to the space limitation.
evaluation we implement a prototype in python for debugging python programs.wechoosepythonasithasbecomeoneofthemostpopular programming languages .
we aim to address the following research questions in the evaluation.
rq1 how effective and efficient is our approach in assisting debugging real world bugs?
rq2 how does our tool compare to a recent interactive debugging technique that does not encode human intelligence?
rq3 what is the impact of the threshold high which is the only tunable parameter in our tool.
rq4 what is the impact of the different kinds of statement instance constraints?rq5 howcanourtoolimprovehumanproductivityinpractice?
to answer rq1 rq4 we apply our technique to a set of realworld bugs as shown in table columns .
our benchmarks consist of two kinds of bugs.
the first kind i includes bugs from10popularpythonprojectsongithubandthesecondkind ii includes algorithmic bugs postedon stack overflow.
as shown in column of table some of the projects are among the largest python projects one can find on github with the largest having over54kloc.thecollectedprojectbugs i alsodenotethetypical complexity level.
we use the failure inducing inputs in the bug reports.whencollectingthesebugs weconsideredthediversityof projects.
they mainly fall into the following categories.
fabric remote deployment and administration application.
requests andurllib3 very popular http libraries.
simplejson a widely used json encoding decoding library.
bottle flaskandweb2py widelyusedwebapplicationsystem development frameworks.
werkzeug a popular wsgi utility library for python.
dateutil an extension to the datetime module of python.
scrapy a well known web crawler.
foralgorithmicbugs ii theprogramsmainlyimplementvarious algorithms from project euler and leetcode .
their issue numbers on stackoverflow.com are shown in column .
table3showsthesummaryofourexperimentalresults.columns 6presentthenumbersofeventsandslicedevents.observethat many slices are so large that manual inspection would be difficult.
theevents forprojectbugsare smallerthanweexpected because the failure inducing inputs in bug reports tend to be small as they havegonethroughinputreduction e.g.
usingdelta debugging .
this is very typical for python bugs reported on github.
columns report the number of solved constraints by our tool.
columns variable and stmtinst represent the numbers of solved variableconstraintsandstatementinstanceconstraints respectively.
column reports their total number.effectiveness and efficiency rq1 .
to evaluate the effectiveness of our tool we set the threshold high .
and debug the benchmarkprogramsfollowingtherecommendationssuggested byourtool.wecounttheinteractionswiththetool i.e.
therecommended instances that we have to inspect and provide feedback till the root causes are located.
column pd reports the number ofinteractions includingthefinalrootcausestep.theresultsshow that our approach is highly effective.
we only need to inspect asmall number of steps on average steps for project bugs and5 for algorithmic bugs .
for a few cases e.g.
fabric and requests our tool can directly report the root cause.
note that thisdoesnotsuggestthealgorithmicbugsaremorecomplex.infact they are mostly loop intensive and hence their failure propagation paths often involve many iterative steps.
as a result our tool may requiretheusertoprovidefeedbackformultipleinstancesofthe same statement in different iterations.
columns10 12presentthetracingtime solvingtimeandtotal time respectively.
the solving time is the sum of all the inspection rounds.
the results show that our approach is highly efficient.
especially ourtoolcancompleteinferencesinasecondformost cases.
note that tracing time is a one time cost for each failure.comparisonwith microbat rq2 .
since doesnotsupportpython were implementeditinpythonforthecomparison.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
debugging with intelligence via probabilistic inference icse may june gothenburg sweden table summary of the experiment results benchmarks trace solved constraints time sec inspected steps projects algs.
sloc issue events sliced events variable stmtinst all tracing solving total pd fd ifabric .
.
.
.
.
.
.
.
.
.
.
.
requests .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
simplejson .
.
.
.
.
.
flask .
.
.
bottle .
.
.
.
.
.
werkzeug .
.
.
dateutil .
.
.
.
.
.
scrapy .
.
.
.
.
.
web2py .
.
.
.
.
.
urllib3 .
.
.
average .
.
.
iilcsubstr .
.
.
happynum .
.
.
quadratic .
.
.
primesum .
.
.
triangular .
.
x fibonaci .
.
.
x lcollatzseq .
.
.
amicable .
.
.
mergesort .
.
.
euclid .
.
.
x average .
.
.
wecallthepythonversionof microbatthepymicrobat.wecompare theperformanceofthetwobycountingthenumberofinspected stepsbefore locatingtherootcause.
tosuppress noise i.e.
differences in human feedback four of the authors debugged each case using both tools independently.
we then take the average of the interaction numbers.
to achieve fair comparison our tool requests thesamekindoffeedbackfromthedeveloperas microbat whichis to determine whether operands in a statement instance are correct.
column14 fd intable3presentstheresultsof pymicrobat.the resultsshowthatformostcases thenumberofinteractionsneeded by our tool is much smaller than that by pymicrobat.
observe that pymicrobat failed to locate three algorithmic bugs.
the reason is thatpymicrobat is strictly based on dynamic slicing which may miss root causes due to execution omission .
in contrast our tool can fuse additional debugging hints from multiple sources.
inrequests 1711andlcollatzseq ourtoolrequiresonemorestep.
furtherinspectionshowsthatthetwobugshavesimplecausality so that uncertainty reasoning is not needed.
impact of threshold high rq3 .we study the impact of the threshold highusing three settings namely .
.
and .
.
fig.
presentsthe variation of theneeded steps.
observe thatthe impact of highis small in most cases.
impactofconstraints rq4 .
weonlychoosebugsofkind i as our subjects as kind ii bugs mostly do not have function structuresandtheirvariablenamesarealmostmeaningless.weevaluate the impact of each kind of statement instance constraints bythree additional settings namely only variable to statement instance constraints variable to statement instance constraints withprogram structure constraints and variable to statement instance constraintswithnamingconventionconstraints.notethatvariableto statement instance constraints are the basis in our model.
fig.
shows the variation of the needed steps.
observe that each kind haspositivecontributionformostcases.theimpactsofprogram structure constraints and naming convention constraints on some cases e.g.
fabric and scrapy are prominent.user study rq5 .
weconducted a user study.
we selected four well known algorithmic problems from our benchmark and asked the participants to debug the buggy programs.
table presents the descriptions of the selected bugs.
we invited graduate students fromtheauthors institutetoparticipatethestudy.toavoidbias caused by programming experience variation for each program werandomlypartitionthestudentstotwogroups oneusingour tool and the other using the standard python debugger pdb .
table5presentsthe human debuggingtimecomparison.the shaded columns present the time of using our tool.
observe that ourtool achieves34.
speedupon average.to validatetheperformancedifferenceofthetwogroups weintroducethenulland alternative hypotheses as follows.
h0 there is no significant performance difference between the two groups.
h1 the performancedifference between thetwo is significant.
we use the wilcoxon signed rank test to evaluate the null hypothesesandifthep valueislessthan0.
wewillrejectit.thelast row in table reports the p value of each task.
observe that all of themarelessthan0.
whichmeanstheperformanceimprovement is significant.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden z. xu s. ma x. zhang s. zhu and b. xu figure impact of the threshold high.
figure impact of each kind of constraints.
related work automated debugging and fault localization techniques have been extensively studied.
delta debugging leverages a passing execution closely resembling the failing execution as the reference andusesasophisticatedsearchalgorithmtoidentifytheminimal state differences that trigger the failure.
despite its success it may be difficult to find a reference execution of high quality in practice.
spectrum based fault localization compares program spectra e.g.
codecoverage betweenthefailingandpassingexecutions to identify the most likely root cause.
it is highly effective when many runs are available.
statistical fault localization isolates bugs by contrasting the instrumented predicates at particular points.therearealsovariousproposalsonimprovingfaultlocalizationandapplyingfaultlocalizationindifferentareas .
our approach is different.
first we assume that only a failing run is available for debugging.
second these techniques are mostly deterministic and do not handle uncertainty like we do.
we shift a lot of decision makings from humans to machines.
debugging techniques using a single run have been proposedaswell.forexample linetat.
developedafeedbackbased technique that prunes the search space.
but the technique doesnotreasonaboutuncertaintyandhencecannotmakeuseof uncertainhints whichareveryusefulaccordingtoourexperiment.
zhang et al.
prune dynamic slice with confidence.
however theirmethodofcomputingconfidenceisad hocandtheydonot support probabilistic inference.
many other techniques leverage execution trace for debugging .
however most of them do not support human like reasoning.
there are also techniques leveraging machine learning to locate bugs .
dietz et al.
trains a graphical model called the bernoulli graph model using passing traces to determine the most likely faulty code position.
baah et al.
proposed probabilistic dependence graph which estimates variable states and learnstable debugging tasks for user study.
algorithm description bug causality lcsubstr identifythelongestincreasingsubstring of a given string.indexes incorrectly computed.
quadratic find the maximum number of primes satisfying a quadratic formula euler problem .some intermediate results are not updated in iterations.
fibonaci find thesum ofthe eventerms of thefibonaciseriesuptoacertain number.loop condition is incorrect.
mergesort implement the merge sort for a given number sequence.the comparison operator is wrong.
table results of the user study min .
person task lcsubstr quadratic fibonaci mergesort n1 y1 .
.
.
.
.
.
.
.
n2 y2 .
.
.
.
.
.
.
n3 y3 .
.
.
.
.
.
.
.
n4 y4 .
.
.
.
.
.
.
.
n5 y5 .
.
.
.
.
.
.
.
n6 y6 .
.
.
.
.
.
.
.
n7 y7 .
.
.
.
.
.
.
n8 y8 .
.
.
.
.
.
.
.
avgerage14.
.
.
.
.
.
.
.
.
.
.
.
overall .
p value .
.
.
.
conditional dependencies from both passing and failing runs to facilitate fault localization.deng et al.
encodes thefrequency ofexecutioninahybridgraphicalmodelnamedweightedsystem dependency graph to prioritize heavily trafficked flows to facilitate faultlocalization.ourtechniqueisdifferent.first theyrequirea numberoffailing passingrunstobuildthemodelwhileourtechniqueonlyneedsasinglefailingrun.second thesetechniques learn probabilities from multiple executions whereas our technique infer posterior probabilities from prior distributions.
third their model is static denoting a program whereas our model is dynamic denoting an execution.
fourth our technique can leverage uncertain hints such as those from structure and names.
conclusion we propose a probabilistic inference based debugging technique.
we model the debugging problem as two phases of probabilistic inference inferring variable correctness faultiness probabilities and inferringstatementinstancecorrectness faultinessprobabilities.
our technique allows us to debug by leveraging various hints from execution trace program structure variable names and human feedback.
the results show that our technique can identify rootcausesofasetofreal worldbugsinafewsteps muchfaster than a recent proposal that does not encode human intelligence.
it also substantially improves human productivity.