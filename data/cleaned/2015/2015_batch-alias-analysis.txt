batch alias analysis jyothi v edurada dept.
of cse iit madras vjyothi cse.iitm.ac.inv .
krishna nandivada dept.
of cse iit madras nvk iitm.ac.in abstract many program analysis based tools require precise points to alias information only for some program variables.
to meet this requirement efficiently there have been many works on demand driven analyses that perform only the work necessary to compute the points to or alias information on the requested variables queries .
however these demand driven analyses can be very expensive when applied on large systems where the number of queries can be significant.
such a blow up in analysis time is unacceptable in cases where scalability with real time constraints is crucial for example when program analysis tools are plugged into an ide integrated development environment .
in this paper we propose schemes to improve the scalability of demand driven analyses without compromising on precision.
our work is based on novel ideas for eliminating irrelevant and redundant data flow paths for the given queries.
we introduce the idea of batch analysis which can answer multiple given queries in batch mode.
batch analysis suits the environments with strict time constraints where the queries come in batch.
we present a batch alias analysis framework that can be used to speed up given demand driven alias analysis.
to show the effectiveness of this framework we use two demand driven alias analyses the existing best performing demand driven alias analysis tool for race detection clients and an optimized version thereof that avoids irrelevant computation.
our evaluations on a simulated data race client and on a recent program understanding tool show that batch analysis leads to significant performance gains along with minor gains in precision.
i. i ntroduction points to analysis is the underlying base analysis for many other static analyses for example the analyses designed for callgraph construction bug detection compiler optimizations program understanding and so on.
on one hand there have been several whole program points to analyses over the last two decades that compute the exhaustive solution and meet the requirements of clients that need points to information for many parts of the code.
on the other hand many demand driven analyses have been proposed that compute only necessary results for a fixed set of queries and meet the requirements of clients that need points to information only for a few parts of the code.
whole program analyses are expensive because they are fully exhaustive and compute the points to information for the entire input application.
many of the demand driven analyses are fully on demand work on each query independently and may not scale well to clients with a large number of queries because they recompute a lot of information across different queries.
however an open question similar to the one asked by hind and pioli which is of interest to the community is what is a suitable analysis for clients that fall in between?
that is for the clients that do not requirethe complete whole program information but can trigger a significant number of queries on large applications trigger queries which are not fully on demand i.e.
all the queries can come in a batch and are performance critical that is should suit ide kind of environments.
there are many such clients for example data race detection analyses analyses for identifying refactoring opportunities and so on where the points to or alias queries are available in a batch.
pointer analyses should be designed to be appropriate in cost and precision for specific groups of client problems.
barbara ryder the existing demand driven analyses answer one query at a time fully on demand and none of them provide special treatment when the queries from a client come in batch.
some of these works perform ad hoc caching or summarization to avoid redundant computations across different queries without exploiting the availability of queries in advance and hence they suffer from storing unnecessary information or from missing to store useful information across different queries leading to performance losses.
su et al.
provide a parallel algorithm to process queries from such clients independently but still do not take full advantage of queries arriving in batches.
we are not aware of any work that efficiently answers such batch alias queries.
to address this issue of efficient alias analysis where queries come in batches in this paper we introduce the idea of batch analysis .
it can efficiently serve clients with strict time constraints by modeling a batch query a group of demanddriven queries as a single source multiple destination cflreachability problem.
to present our ideas on batch analysis we use two demand driven alias analyses the existing best performing demand driven alias analysis tool and an optimized version thereof that avoids irrelevant computations with respect to the input queries.
the key step in batch analysis is identifying redundant computations across queries and carefully forming batch queries such that these computations are performed only once in a batch query.
we believe that the insights behind the batch analysis can be extended to other analyses such as points to analysis null pointer analysis etc.
our contributions.
we design a batch alias analysis framework that can efficiently address clients where alias queries come in batch by avoiding redundant computations within batch queries.
we present techniques to optimize demand driven analyses by eliminating irrelevant analysis paths that can improve the performance of the batch analysis further.
we propose a novel type information based approach to eliminate irrelevant 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
analysis paths when solving alias queries and thus improve the performance and precision of demand driven alias analyses.
we present a detailed evaluation using a simulated datarace client and on a recent program understanding tool .
we show that batch analysis leads to significant performance gains along with minor precision gains and the elimination of irrelevant search paths improves performance and precision.
ii.
p reliminaries in this section we first introduce some notations and terminology and then we outline the cfl reachability based demand driven context sensitive alias analysis proposed by yan et al.
implementation available as it serves as our baseline hereafter we refer to it as b asic analyzer .
alias analysis.
we use the notation alias?
a b to represent an alias query between two variables aandb.
to illustrate fig.
shows a modified code snippet from jfreechart1.
.
a chart library .
classes barrenderer and linerenderer extend the abstract class renderer .
methodsclient1 client3 uselinerenderer and methodsclient2 client4 usebarrenderer .
the method apply incharttheme applies theme style to a chart by various chart parameters like renderer.
note that shadowpaint controls the shadows drawn for the bars and hence is specific to barrenderer .
suppose we are interested in finding whether the read of field shadowpaint enabled at line and the write of it at line maybe involved in a data race the alias query is alias?
lsp25 fsp22 .
cfl reachability.
context free language cfl reachability is an extension of graph reachability problem in which a directed graph gwith edges having labels from an alphabet and a context free language lover are considered.
a path pfrom a node nton primeingis called an l path if the word formed by concatenating the labels of edges in p sayw i s a member of l. here n primeis said to be l reachable fromn.
this is a popular mechanism to model field and context sensitivity.
program representation.
interprocedural symbolic pointsto graph ispg forms the basis for the cflreachability based alias analysis.
fig.
shows the ispg for the code in fig.
.
the ispg is constructed in two steps an intraprocedural spg is built locally for each method using placeholders for the objects created outside the method.
the constructed intraprocedural spgs are connected to form the ispg.
an ispg contains three kinds of nodes nodes for local variables shown using ellipses abstract allocation nodes representing allocated objects o o shown using rectangular white boxes and placeholder nodes called as symbolic nodes s s shown using shaded boxes .
edges in ispg the new copy and store statements lead to edges similar to the ones realized in standard points to analysis.
for example for each store statement of the form x.f y a points to edge o1f o2is added if xpoints to o1andypoints to o2 whereo1ando2can be symbolic or allocation nodes for each formal parameter f an edge f sis added where symbolic node srepresents the objectpassed from outside for each field access v.f an edge vf sis added where symbolic node sis used to represent the object that v.f points to.
for each call site of the form v a0.m a1 ... a i ... i an entry edge is added from any allocation or symbolic node that aipoints to in the caller to the symbolic node sithat formal parameter fipoints to in m ii an exit edge is added from any allocation or symbolic node that a return variable points to in mto the symbolic node s that was introduced as a placeholder of the return value in the callerm.
iii an edge v sis added where s same as in ii is the symbolic node representing the object returned from m. for an edge with label t trepresents the reverse edge.
basic analyzer .alias query to b asic analyzer is performed as an on demand single source single target cflreachability problem on ispg.
edge labels in ispg are field names coming from field read write operations and entry and exit labels.
a path between any two nodes n o s and n prime o s in ispg has a string wformed by concatenating these edge labels.
the memory alias relation between nand n primecan be described using cfl memalias as memalias f memalias f memalias memalias entry entry exit exit epsilon1 thus memalias is capturing field sensitivity by looking for matching field names f i nw.
for example in fig.
there is amemalias path between lsp 25andrsp 13withw sp entry 16entry 12entry 13sp exit and hence lsp 25and rsp 13may alias.
context sensitivity is captured using the following grammar that matches entry and exit labels.
c ic i cc epsilon1 i entry i exit i i exit i entry i fig.
shows the demand driven context sensitive alias analysis of b asic analyzer .i f alias?
a b is an alias query on the local variables aandb the algorithm takes n1 n2 as the corresponding input query where n1andn2are the nodes that aandbpoint to respectively in the ispg.
we call n1 n2 as an effective query of sinceaand bcan point to multiple allocation symbolic nodes an alias query can have multiple effective queries.
checkaliasing checks for context sensitive memalias path reachability from n1ton2in the ispg by performing a breadth first traversal.
the procedure maintains two stacks fldstk andcxtstk t o support field sensitivity and context sensitivity.
the function processedge processes each edge by updating fldstk and cxtstk with the edge label when required and returns true when it finds a context mismatch the corresponding path should be ignored detailed definition of this function is elided for space.
if n2is reached from n1and thefldstk is empty it implies that variables aandbare aliases.
the termination check line does not check for cxtstk to be empty as a realizable path may have unbalanced prefix and suffix edges.
caching.
xu et al.
use a whole program pre analysis to cache the reachability strings associated with all the reachable nodes of each ispg node to compute all pairs memalias path authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1void client1 ... 2client3 new linerenderer 3void client2 ... 4barrenderer b new barrenderer 5b.setshadow new shadowpaint 6client4 b 7void client3 linerenderer lr 8charttheme theme ... 9theme.apply lr ... 10void client4 barrenderer br 11charttheme theme ... 12theme.apply br 13rsp br.getshadow ... 14class charttheme 15void apply chartrenderer cr cr.paint ... end17abstract class chartrenderer 18void paint ... ... end 19class barrenderer extends chartrenderer 20shadowpaint sp 21void setshadow shadowpaint fsp fsp.enabled true this .sp fsp 23void getshadow return this .sp 24void paint lsp this .sp if lsp.enabled ... else ... ... end 27class linerenderer extends chartrenderer void paint this ... ... end 29class shadowpaint boolean enabled ... end fig.
running example.
code snippet from jfreechart with minor modifications.
o2client1 s1 lr7client3o4client2 s4this applys2 br10client4 s8 cr15getshadow this s6barrenderer paintthis s10setshadowentry2entry6 entry entry12 entry entry16entry 5o5 fsp22 s11 s7 lsp25sp spentry5 this s5linerenderer paints9sprsp13 s3exit entry13 f field points to edge field points to edge exit edge at call site i entry edge at call site ientryi exit i fig.
symbolic points to graph for the example in fig.
.
reachability information.
yan et al.
in their implementation of b asic analyzer use a caching scheme evolved from that of xu et al.
that caches during the demand driven analysis in contrast to whole program pre analysis and caches only the results of effective queries thus has lower memory overhead than the work of xu et al.
we now briefly discuss this caching scheme termed cache of yan et al.
the code for caching gets executed upon setting an option cachingon .
here for each input query n1 n2 i during the analysis upon visiting a node mwith empty fldstk and callstk to respect field and context sensitivity this scheme uses the prior result of the query m n if available shown in fig.
lines and .
ii in fig.
before returning the answer for n1 n2 is stored lines and .
iii.
o pportunities for improvement our goal is to improve the performance of alias analysis without compromising on precision.
in this section we demonstrate two main opportunities for improving the performance of a demand driven alias analysis for example basic analyzer .
we illustrate the same by using the example program in fig.
.
our identified opportunities can be classified into two categories redundant work discussed in section iii a and irrelevant work discussed in section iii b .1function checkaliasing n1 n2 wl n1 while wl negationslash do remove n fldstk n cxtstk n from wl fldstk cxtstk clone fldstk n cxtstk n foreach edgee n.edges do ignorepath processedge edge fldstk cxtstk ifignorepath negationslash true then m neighbour e n ifm n2 fldstk then ifcachingon then results.add n1 n2 true return true n2andn1are may aliases wl m fldstk cxtstk ifcachingon then results .add n1 n2 false return false fig.
solving alias queries 1ifcachingon fldstk cxtstk then ifeffective query m n is in results then in cache ifresults .get m n istrue then return true else continue fig.
enable caching code to be added to fig.
before line .
a. redundant work to see how b asic analyzer performs redundant work let us consider the example code from fig.
.
suppose we are interested in finding whether the read of field shadowpaint enabled at line and the write of it at line may involve in a data race and hence the alias query becomes 1 alias?
lsp25 rsp13 .
similarly say we are also interested to answer the alias query 2 alias?
lsp25 fsp22 .
the effective query of 1is s7 s3 aslsp25points to s7andrsp13points to s3in the ispg as shown in fig.
.
similarly the effective query of 2is 2 s7 s11 .
paths 2and 1in fig.
are the contextsensitive memalias paths for 1and 2respectively.
fig.
shows the two sub graphs of the ispg in fig.
containing edges of all the paths that are traversed by b asic analyzer for answering 1and 2respectively.
the start node during authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
o2client1 s1 client3o4client2 s4 applys2client4 s8getshadow s6barrenderer paints10 entry2entry6 entry 9entry12 entry entry16entry5 s7sp s5s9sp s3exit entry13 linerenderer paint 1 911o2client1 s1 client3o4client2 s4 applys2client4 s8getshadow s6barrenderer paints10setshadow entry2entry6 entry 9entry12 entry entry16entry5 s11 s7sp sp s5s9sp s3exit entry13 linerenderer paint 2 91112setshadow fig.
sub graphs traversed for answering 1 alias?
lsp25 rsp13 and 2 alias?
lsp25 fsp22 .
both the traversals is s7and the edges are numbered according to their visiting order during the backward traversals.
we can see that the only difference between the traversal of 1and 2 is the edge all other edges are redundantly traversed.
since basic analyzer handles each query independently there are many redundant paths possible across different queries.
as discussed in section i for clients in which the input alias queries come in a batch handling the queries independently adds a lot of overhead due to redundant traversals across queries.
to address such redundant traversals standard demand driven analyses perform optimizations such as caching the results of the previous queries and caching the already analyzed method summaries etc.
however as supported by our evaluation these optimizations are not sufficient to eliminate the possible redundant traversals across different queries.
if the queries are known to be available in batch the information about the query s7 s3 will be known when answering the query s7 s11 or vice versa .
this prior knowledge can be used to avoid redundant path traversals.
in this paper we propose the idea of batch analysis framework to efficiently handle multiple queries coming in batch mode.
we call our batch analysis technique as b at c h analyzer .
b. irrelevant work to see how b asic analyzer performs irrelevant work consider the code shown in fig.
.
suppose we are interested in answering only the alias query alias?
lsp25 fsp22 .
based on the points to edges of the variables involved using the ispg in fig.
we can see that the effective query of is s7 s11 .
to answer this query b asic analyzer performs backward analysis from the start node s7to check for a context sensitive memalias path tos11.b asic analyzer starts with the ispg node s7corresponding to lsp25and reachess4 the ispg node pointed by cr15in method apply and from there reaches the nodes pointed by lr7and br10in methods client3 andclient4 respectively the search continues until s11is found.
fig.
lists the different paths used by b asic analyzer starting froms7until it reaches s11to answer the query the analyzer may trace these paths in any order.
clearly we can see that 1is a context sensitive memalias path from s7to s11and is a relevant path.
however 3and 4are different.
path 3 this is not even a valid path and is not necessary to the query because of the following two reasons s6 s4entry16s5entry16s6 s4entry16s2entry12 s6 s4entry16s1entry9o2entry13 entry2exit 13s9 7 2 3 4 s7sp s3sp s7sp s7sps6 s4entry16s2entry12o4entry6 entry5s10 1 s7sp s11sp s8 fig.
paths traversed on fig.
for alias?
lsp25 fsp22 .
consider the subpath s7 s6 s4 s1of 3. the string on this subpath is spentry16entry9 where the type of s1islinerenderer and the type of s7 isshadowpaint which indicates that linerenderer has a field sp of type shadowpaint .
however from the code in fig.
we can see that only barrenderer has a field sp of type shadowpaint and the subpath traversal happened because of the upcast at the virtual call at line .
consider the subpath s6 s4 s1of 3. the string of this subpath is entry16entry9and hence is a context sensitive memalias path from s6tos1.
therefore it is expected that the types of s6ands1are compatible same type or one is a subtype of another .
however the type of s6isbarrenderer and the type of s1is linerenderer both are not compatible types but are subtypes of chartrenderer .
again in this case the invalid path is resulting due to the underlying implicit type cast.
path 4 like 3even this path is invalid but because of a different reason consider the subpath s6 s4 s5of 4. it is traversing back from s6which belongs to method barrenderer paint tos5which belongs to method linerenderer paint .
as the entry edges to callees linerenderer paint andbarrenderer paint in the ispg are added for the same call site at line in fig.
the information from linerenderer paint cannot propagate to barrenderer paint at runtime and hence the subpath s6tos5and thereby path 4are invalid paths.
when processing the entry and exit edges b asic analyzer does not recognize the paths across different target callees of the same virtual call site and hence allows such invalid paths.
to summarize we see that even though b asic analyzer traverses paths like 3and 4 such paths are irrelevant for answering the query .
these irrelevant traversals affect the performance as well as the precision of the demand driven authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
query unifier autoanswerer batch analyzeralias informationalias queries 1 2... n batch queries g1 g2...g m fig.
block diagram of the batch alias analysis framework.
analysis.
further it is challenging to detect such irrelevant paths for an on the fly query during the analysis.
note that context sensitivity cannot capture these invalid paths as it checks only for matching call return pairs and all the invalid paths discussed above respects do not violate this check.
this paper proposes a general type information based technique to avoid processing of such irrelevant paths which can be applied to any pointer analysis based analysis to improve its precision and performance.
we call our technique as s mart analyzer .
we discuss b a tch analyzer our batch alias analysis technique in section iv and s mart analyzer our optimized demand driven alias analysis technique in section v. iv .
b at c h analyzer we now discuss the details of our proposed batch analysis framework which can use a plugged in demand driven analyser for example b asic analyzer o rs mart analyzer discussed in section v to efficiently answer batch queries by avoiding redundant computation.
as discussed in sections i and iii in batch analysis all the possible alias queries from a client are known in advance.
note that a na ve way to reduce the redundant computations across different queries is to cache all the intermediate traversed paths and reuse them upon re analysis.
however such techniques store a lot of information not scalable which may or may not be reused in future b at c h analyzer overcomes these challenges.
fig.
depicts our batch alias analysis framework.
our approach consists of two steps query unification to group the queries into a set of batch queries to make them more amenable to batch processing.
answering batch queries by using the insights of batch analysis and the underlying demand driven analysis engine.
batch query generation.
figure shows the core of our batch alias analysis framework.
we group a subset gof standard alias queries to a batch query such that the redundant computations are eliminated completely across the queries in g. the function unifytobatchqrys depicts how the batch queries are created.
the input to the function is the set of all effective queries 1 2 ... n of the input alias queries 1 2 ... n prime .
note that n n primebecause an alias query ican have more than one effective query if a variable in i points to more than one symbolic allocation node in the ispg.
answer to iis true if at least one of its effective queries answer is true and is false when all of its effective queries answers are false.
the function unifytobatchqrys treats the effective queries n1 n2 and n2 n1 as the same query.
the function unifytobatchqrys unifies the effective queries into groups such that all the effective queriesinput q ni mi n i n number of effective queries output rj n j 1whererjstores the boolean value of nj mj 1procedure batchanalysis q 2s unifytobatchqrys q foreachg sprocessed in the order of decreasing size do autoanswer g batchqrycheckaliasing g 6function unifytobatchqrys q q ni mi k i 7g foreach nx mx qdo cnt nx cnt mx max nodewithmaxcnt cnt n ... n k m1 ... m k foreach nx mx qdo ifnx maxormx max theng g nx mx return g unifytobatchqrys q g fig.
batch alias analysis input g nk m1 nk m2 nk mm output rj n j 1whererjstores the boolean value of nk mj 1procedure batchqrycheckaliasing g 2d m1 m2 ... m m wl nk while wl negationslash do remove n fldstk n cxtstk n from wl fldstk cxtstk clone fldstk n cxtstk n foreachedge n.edges do ignorepath processedge edge fldstk cxtstk ifignorepath negationslash true then n2 neighbour e n if mj ds .
t .m j n2 fldstk then d d mj rj true ifd then return wl wl n2 fldstk cxtstk foreachmj ddorj false fig.
alias analysis for batch queries with a common node in them are unified into the same group.
each such group becomes a batch query.
however two effective queries with a common node may still be present in two different groups.
for example if the set q of input queries to the function are a b c a d c m n p q c r a m .
here c a can be included in the group where a b is present or in the group where d c is present.
the function breaks such ties by greedily grouping the query with the group that can have higher number of queries in it see lines note cnt is a local array.
thus the set of batch queries for qis a b a c a m c d c r m n p q .
answering batch queries.
given a batch query gwith queries sharing a common node and an underlying demanddriven alias analyzer for example s mart analyzer we now discuss how b at c h analyzer answers these queries.
as shown in fig.
we first check if gcan be answered based on the queries answered so far we do so by invoking the function autoanswer .
if not we invoke the function batchqrycheckaliasing .
we process the groups in the decreasing order of their size.
if the group has only element the function batchqrycheckaliasing invokes the checkaliasing function of the underlying demand driven analysis for example fig.
not shown explicitly.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
n1 n2n3n4 n5 n6 n7 fig.
alias analysis paths in the ispg.
in b a tch analyzer a batch query is formulated as a single source multiple destination cfl reachability problem.
hence batchqrycheckaliasing in fig.
works similar to function checkaliasing in fig.
.
the function starts from a common start node nkand searches for the destination nodes of all individual effective queries in the batch query g. an individual query in gterminates at line when a context sensitive memalias path is found to its destination node otherwise it terminates at line .
when the function terminates all the individual queries in gare answered.
unlike basic analyzer b a tch analyzer performs no redundant traversals across the queries in g because b at c h analyzer never re traverses the common paths across the queries in g unless the retraversal is required even for b asic analyzer to solve an individual query.
here we can see the advantage of a batch analysis in which the redundant traversals across different queries can be avoided without caching.
autoanswerer attempts individual effective queries using prior solved queries.
for example if alias?
n1 n2 alias?
n2 n3 true alias?
n1 n3 true.
thus we can see that b a tch analyzer avoids redundant path traversals without caching any intermediate results by treating a set of individual queries in a batch query as a singlesource multiple destination cfl reachability problem instead of treating it as many single source single destination cflreachability problems and autoanswerer further avoids redundant path traversals.
discussion we briefly describe the differences similarities between cache see section ii and the batch analysis technique using the graph in fig.
that shows ispg nodes withmemalias paths joining them.
note that we use cache to compare and not its precursor as cache takes the input demand driven queries into consideration for caching.
consider the batch query g1 n1 n4 n5 n7 .
here the batch analysis will traverse each of the paths in the graph only once.
in contrast cache re traverses the paths n1 squigglerightn2 andn2 squigglerightn3across the queries in g1 n1 n4 n1 n5 and n1 n7 here path n2 squigglerightn3may also be traversed when answering n1 n7 because the traversal is performed in bfs breadth first search manner.
however say if a batch query g0 n3 n4 n5 is solved before g1 batch analysis retraverses the paths n3ton4andn3ton5 whereas cache reuses those paths if the individual queries in g0are solved before solving the individual queries in g1.
hence in theory neither of the techniques is more precise than the other see section vi for an empirical comparison .
note that caching can complement batching.
for example the answers to the individual queries n3 n4 and n3 n5 ofg0can be cached and reused when solving a latter batch query like g1.statement type information alloc x new copy x y 1 typ x 2 typ new typ y 2 cmpt 1 1 cmpt 2 load x y.f store y.f x 1 typ x 2 typ y 2 1 call r a0.m a1 .. ai .. equivalent to assignments fi ai r mret where fiis theithformal parameter ofmandmretis the variable returned in m fig.
type relations in the statements that affect points to information.
typ e returns the static type of expression e. v. s mart analyzer in this section we use a novel type based approach to reduce the irrelevant work performed during demand driven analysis.
our approach is based on identifying relevant types for the queries and by detecting edges that need not be traversed termed imaginary adjacent ispg edges .
a. relevant types our goal now is to provide a general scheme to avoid demand driven alias or points to analysis via invalid paths that occur due to upcasting and downcasting in codes written in languages that support subtype polymorphism.
our strategy is based on identifying the set of relevant types for a given input query .
to avoid traversing irrelevant paths during backward analysis we process a node only if the node has a relevant type with respect to .
our approach is based on the following two definitions.
definition compatible types .
given a type all the sub types and supertypes of are the compatible types of .
thus for a set of types t we compute its set of compatible typescmpt t t t tis a sub type or a super type of where t .
definition type enclosing .
we say a type primeencloses a type prime primeif there exists a sequence 1 2 3 ... ksuch that 1 prime k prime primeand for all i k there is a field of type i 1in i represented by i i .
fig.
shows the compatible types and type enclosing relations in the program statements that affect the points to information.
for example for an assignment copy statement the lhs variable s type belongs to the compatible types of the rhs variable and vice versa.
for a store statement the base variable s type of the lhs field access encloses the type of the rhs variable.
the types of actual arguments and of lhs variable at a call statement relate to the types of formal parameters and of a return expression in the callee in a manner similar to that of a copy statement.
as the edges in ispg are constructed by processing these program statements see section ii entry exit edges represent compatible type relations and field edges represent type enclosing relations.
definition declared types .
if alias?
a b is an input query and 1is the declared type of variable aand 2 is the declared type of variable b then we define the set of declared types 1 2 asdtype .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
definition relevant types .
we define the set of relevant types for a given query as cmpt d cmpt e wheredis thedtype ande encloses primeand prime cmpt d .
let alias?
a b is the input query and s1 s2 is one of the effective queries of .
a context sensitive memalias path of starts from s1whose declared type is say 1and passes through intermediate nodes connected via field edges that represent type enclosing relations w.r.t.
1 o r entry exit edges that represent compatible type relations and finally reaches s2whose declared type is say 2. thus the set of relevant types for where dtype 1 2 captures the set of types of the nodes that can appear in a context sensitive memalias path of .
a context sensitive memalias path has the following key property property .
if a path is a context sensitive memalias path for a query then a node nappears in iffstatic type n rtype where rtype set of relevant types for .
our s mart analyzer computes relevant types and uses property to answer a query .
it processes the edges by calling processedge section ii connected to a node in the worklist only if its type is in the set of relevant types of and thus avoids the irrelevant paths that can be taken by b asic analyzer .
we now demonstrate the same on the example query alias?
lsp25 fsp22 from section iii.
here dtype shadowpaint and the set of relevant types of isrtype shadowpaint barrenderer chartrenderer object .rtype includes barrenderer as it encloses shadowpaint and includes chartrenderer object because they are the comaptible types of barrenderer .
consider the paths 1and 3in fig.
traversed by b asic analyzer for answering the query .
path 1is a context sensitive memalias path and hence the types of nodes in path 1 shadowpaint barrenderer chartrenderer are included in the set rtype .a s linerenderer the type of node s1in 3 is not included in the set rtype path 3cannot be a context sensitive memalias path for and hence it is not relevant to .
similarly path 4in fig.
is not relevant to .s mart analyzer avoids traversing through paths 3and 4 thereby reducing the search space.
note that the idea of relevant types is not specific to cflreachability based demand driven alias analysis and is directly applicable to any demand driven points to alias analysis as the data flow in all these analyses is similar.
b. imaginary adjacent edges our goal now is to detect and thereby avoid invalid path traversals discussed in case in section iii b which happens whenever there are multiple target callees at a virtual call site.
let s1 s2 be an effective alias query.
let us consider a method mcaller which calls a method mcallee at a call site x. letpbe a path from s1which has an edge e1 n1 n2 in it such that n1is inmcallee andn2is inmcaller .
pathpis an invalid path if the edge e1has anadjacent edge e2 n2 n3 inpsuch that n3is inm prime callee wherem prime callee negationslash mcallee is another target callee of mcaller at the same call site x. hence we focus on detecting such imaginary adjacent edges to avoid invalid paths.
in particular we look for adjacent edge pair e1 e2 in pathp s1.n1.e1n2.
e2n3.nk.
edge directions are omitted for simplicity where n1is inmcallee n2is inmcaller n3is inm prime callee andmcallee andm prime callee are the target callees of mcaller at the same call sitex.
we take this into consideration by noting that as we are interested in a traversal from a callee to a caller and again to a callee e1ande2should have opposite directions.
thus we ignore paths with e1 e2 pair having edge labels as entry x entry x o r exit x exit x .
to identify such adjacent edge pair combinations s mart analyzer memoizes the last processed edge.
it marks the edges with unique ids to store the call site information.
thus s mart analyzer further reduces the search space over that obtained using relevant types by eliminating invalid paths due to imaginary adjacent edges.
vi.
i mplementa tion and ev alua tion implementation.
our algorithms are implemented by extending the soot framework we consider the following seven variants for our evaluation.
basic fig.
existing basic analyzer rt fig.
with use of relevant types section v a vc fig.
with only valid paths at virtual call sites section v b smart smart analyzer fig.
with extensions in rt and vc batch ba tch analyzer using basic in fig.
and s batch ba tch analyzer using smart in fig.
.
cache fig.
with fig.
and with caching option enabled.
we used the implementations of yan et al.
for basic and cache.
note that we do not choose the recent demand driven works as baselines for our work as they are not suitable we found them to take significantly more time compared to basic for data race kind of clients that require simpler alias information.
we investigate the following three research questions rq1 is batch analysis efficient compared to a conventional demand driven analysis?
rq2 is batch analysis beneficial compared to caching?
rq3 what is the impact of eliminating irrelevant paths on the precision and the performance of a demand driven analysis?
experimental setup.
we have run all our experiments on an amd .3ghz machine by allocating 64gb heap space to the jvm.
for rq1 we evaluate our techniques on two clients a data race detection tool simulated and a refactoring tool existing .
for rq2 and rq3 we only use the data race detection client.
for all the rqs the set of all the queries for a benchmark is collected and passed as an argument to the function batchanalysis see fig.
.
we simulate a data race detector client as done by yan et al.
by considering all the queries of the form alias?
x y where for some field f x.f andy.f are accessed in two program statements soot s jimple ir statements of the application code with at least one statement in the two being a field write operation.
for this client we evaluate our technique using twelve java programs from the dacapo benchmark authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
dacapo dacapo used by client bench rm bench rm bench rm antlr avrora avrora bloat luindex fop chart lusearch javageom eclipse pmd jfreechart fop jocular hsqldb rackj jython sunflow xalan ur fig.
benchmarks used for the experiments.
rm reachable methods is as computed by spark .
suite .
we have used i four benchmarks from the latest dacapo version dacapo .
mr1 bach.jar all the ones that could be processed by the tamiflex to eliminate reflective calls and soot combination and ii eight nonoverlapping ones from dacapo as listed in the first and the third columns of fig.
.
the figure also lists the number of callgraph reachable methods as computed by spark .
next we consider an existing client auto scst a program understanding tool which automatically identifies refactoring opportunities for two important refactorings replace type code with subclass sc refactoring and replace type code with state st refactoring that are required for performing replace conditional with polymorphism refactoring.
for many client analyses such as auto scst chord and so on the alias queries can come in batches.
auto scst has strict time budgets to identify the refactoring opportunities because it is an eclipse plugin ide plugin .
the tool classifies an identified refactoring opportunity represented using the class and field pair angbracketleftc f angbracketright for st refactoring if there is a control path from a read dereference x.f to a write dereference y.f both the dereferences refer to the field fofc andxandy are aliases.
since the refactoring opportunities are independent of each other and all the opportunities are identified before displaying to the developer the set of all the queries is available as input to batchanalysis fig.
.
for auto scst we use the eight open source applications used by v edurada and nandivada .
the last two columns in fig.
show the details of the applications.
note that for the overlapping benchmarks the entries in fourth column are different from that of the ones in the last column owing to the differences in benchmark versions and the callgraph configurations.
for all the experiments we use the cutoff used by by yan et al.
and set the budget as traversed ispg nodes for i each demand driven query in case of basic and ii each batch query in case of ba tch and s ba tch.
we also enable summarization to memoize intermediate method level summaries results for all the library methods.
a. rq1 benefits of batch analysis we first discuss about the analysis times of basic ba tch and s ba tch and then about their precision on the datarace detection client followed by on the client auto scst.
fig and fig.
show the comparison of the time takenby the implementations and of their precisions respectively.
the second column in fig.
a lists the number of alias queries coming from the data race client for each benchmark and the third column lists the number of their corresponding batch queries.
we can see that the number of batch queries are quite less than that of the actual queries this is because of the query unifier step in the batch analysis framework.
similarly in fig.
b columns and list the number of alias queries generated by auto scst and resulting batch queries.
results on data race detection client.
fig.
a shows the analysis times of all the three implementations to answer the alias queries.
ba tch runs geomean .
up to .
faster than basic and s ba tch runs geomean .
up to .
faster than basic.
s ba tch performs geomean .
up to .
faster than ba tch showing the impact of eliminating irrelevant path traversals.
we have studied the number of budget exceptions of all the three implementations detailed plots skipped for space .
we found ba tch and s ba tch lead to .
and .
geomean less budget exceptions than basic respectively points to the performance improvements and scalability due to the batch alias analysis.
note that the percentage reduction in the number of budget exceptions is due to the batching of queries.
for example say out of a given set of ten demanddriven queries six got timed out with basic.
if these ten are grouped as a single batch query then ba tch would timeout only once as they are all solved together.
thus the number of budget exceptions reduce from six to one hence would lead to overall faster execution .
note that basic and ba tch would give the same answer for the remaining four.
columns and in fig.
a show the precision of all the three implementations.
each entry shows the number of true answers of the data race queries and thus indicate the number of possible data races lower the number higher the precision.
ba tch reports up to .
less data races than basic see avrora .
the precision of ba tch and basic varies slightly because ba tch transforms some effective queries from a b to b a form during the unification step see section iv .
because of this swapping ba tch may avoid hitting budget exceptions in some cases leads to improved precision.
however such swapping may also lead to newer budget exceptions or encounter static globals in the backward analysis and conservatively answers true leads to reduced precision.
for example for the program hsqldb ba tch reports two more data races than basic but we found that number of such cases have been very minimal.
similar to ba tch s ba tch reports up to .
less data races than basic for xalan and reports .
more data races for luindex .
we found that overall ba tch and sba tch report minor improvements in precision .
and .
geomean less data races than basic respectively.
summary.
overall compared to basic over dacapo benchmarks ba tch and s ba tch run .
up to .
and .
up to .
faster respectively with minor precision gains attests to the importance of batch analysis.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
antlr bloat chart eclipse fop hsqldb jython xalan avrora luindex lusearch pmdtime log scale basic batch s batch a impact on data race queries on dacapo benchmark suite .
avrora fop geom jfree jocular rackj sun owunicodetime log scale basic smart batch s batch b impact of batch analysis on queries from auto scst.
fig.
timing comparison in seconds .
bench alias batch precision queries queries basic rt vc smart ba tch s ba tch antlr bloat chart eclipse fop hsqldb jython xalan avrora luindex lusearch pmd a precision on data race queries.
bench alias batch precision queries queries basic smart ba tch s ba tch avrora fop javageom jfreechart jocular rackj sunflow ur b precision on queries from the client auto scst.
fig.
precision comparison in terms of the number of aliases detected lower the better .
results on auto scst.
smart ba tch and s ba tch show similar performance and precision improvements over basic on auto scst.
fig.
b shows the analysis times of all the four implementations on auto scst.
smart ba tch and s ba tch run .
.
and .
geomean faster than basic respectively and up to .
.
and .
faster than basic respectively .
in terms of number of budget exceptions smart ba tch and s ba tch have .
and .
geomean less budget exceptions than basic respectively.
in fig.
b columns list the number of true answers for the alias queries.
smart ba tch and s ba tch report up to .
fop up to .
avrora and up to .
avrora respectively less aliases than basic.
in ur fop andjocular the reason for precision losses of ba tch and s ba tch is again because of the swapping of queries in the unification step.
we found that overall smart reports .
geomean less data races than basic and ba tch and sba tch report .
and .
geomean more data races than basic.
the geomean percentages for ba tch and sba tch are mainly biased by the precision differences in ur.summary.
the performance improvements show the benefits of batch analysis over demand driven analysis and the need for a batch analysis framework for real world clients like auto scst to answer alias queries in batch mode.
discussion.
for the tested benchmarks auto answerer see section iv had no impact.
but in practice we can easily visualise cases where auto answerer can be impactful.
hence we keep the auto answerer step intact especially considering minimal overheads due to auto answerer.
b. rq2 batch analysis vs caching we now compare ba tch and s ba tch against cache see section ii to show the performance of our batch analysis technique against caching.
as it is known the performance of cache may depend on the order of queries.
for each benchmark we use the data race queries obtained by iterating over the methods in the order as given by the spark call graph as used by yan et al.
.
fig.
shows the performance of cache against basic ba tch and s ba tch on the queries from the data race detection client.
cache performs .
geomean better than basic whereas ba tch and s ba tch perform .
and .
geomean better than basic respectively.
clearly authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
antlr bloat chart eclipse fop hsqldb jython xalan avrora luindex lusearch pmdtime log scale basic cache batch s batch fig.
caching against batch analysis on data race queries.
our batch analysis techniques outperform cache in terms of the number of budget exceptions cache ba tch and s ba tch have .
.
and .
geomean less budget exceptions than basic respectively asserting the improvements in analysis timings.
in case of hsqldb we see that caching shows negative effects which can happen when the benefits from reusing the cached entries get subsumed by the cost of searching the cached entries.
we have also tried enabling caching for ba tch and for s ba tch and we observed that caching has minimal impact on batching techniques ba tch improved by .
s ba tch s performance decreased by .
geomean .
this shows that our batch analysis technique subsumes most of the benefits of caching.
in terms of precision cache reports .
geomean more data races than basic whereas ba tch and sba tch reported .
and .
geomean less data races than basic respectively.
note that the reason for precision loss for cache compared to basic is because of not differentiating the cached queries of form a b with their swapped form b a during reuse similar to batch analysis .
summary.
overall compared to cache ba tch and s ba tch run .
and .
faster respectively.
we argue that batch analysis technique mostly subsumes the benefits of caching and outperforms it.
c. rq3 performance of smart analyzer we first discuss about the analysis times of the implementations basic smart rt and vc and then about their precision.
fig.
shows the analysis times of all the four implementations to answer the alias queries.
smart performs .
geomean better than basic up to .
better .
we explain the reasons behind the performance difference by studying the performance of rt and vc.
in fig.
it can be seen that for most of the benchmarks rt and vc perform better than basic.
the reason for rt and vc not showing performance benefits over basic in some cases is the following basic may conservatively answer an alias query as true via an irrelevant path whereas rt or vc may try for the precise answer false by searching a much longer relevant search space can be expensive.
for example in the case of the program chart rt takes .
antlr bloat chart eclipse fop hsqldb jython xalan avrora luindex lusearch pmdtime log scale basic rt vc smart fig.
impact of irrelevant path elimination dacapo suite .
bench total types avg a v g time msec relevant types relevant types antlr .
bloat .
chart .
eclipse .
fop .
hsqldb .
jython .
xalan .
avrora .
luindex .
lusearch .
pmd .
fig.
details on the computed relevant types.
more time than basic also realizes improved precision see fig.
a .
in fig.
we show that the overheads of the rt implementation cannot be the reason for such performance degradation.
fig.
lists the total time taken by rt to find the relevant types for all the queries in last column and the average number of relevant types for a query in third column .
we can see that the average time taken by rt to find relevant types is almost negligible.
rt performs up to .
lusearch better than basic geomean .
the negative value is mainly because of the difference in performance on chart .
vc performs geomean .
up to better than basic.
in fig.
a columns show the precision of all the four implementations.
smart reports up to .
less data races than basic for xalan .
smart can be more precise than basic when smart finishes the search within the time budget and basic fails to finish because of irrelevant traversals or basic conservatively hits a static global or a destination node via an irrelevant path.
for the chart program the .
performance loss of rt can be attributed to the .
precision improvements for that program.
vc also shows up to .
precision improvements.
we found that overall rt vc and smart report .
.
and .
geomean less data races than basic respectively.
summary.
overall compared to basic smart runs .
up to .
faster with minor precision gains on authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
dacapo benchmarks.
it shows that demand driven analyses can be made performant by avoiding irrelevant path traversals.
vii.
r ela ted work there exist many prior works on alias points to analysis.
sridharan et al.
present a survey of the alias analysis techniques for object oriented programs.
ryder and hind present insightful discussions on different dimensions on pointer analysis.
in this section we mainly focus our discussion to the works that are closely related to our approach.
demand driven points to alias analyses.
many researchers have focused on improving the scalability of demand driven points to analysis based on cfl reachability to suit the environments like just in time jit compilers and interactive development environments ides .
past works further improved the performance of cfl reachability based solution by answering the alias queries directly without computing the points to information and show that for answering may alias queries a demanddriven alias analysis is more efficient than a demand driven points to analysis.
boomerang is a demand driven flow field and context sensitive pointer analysis built on top of the ifds interprocedural finite distributive subset problems framework.
it supports all alias to find all aliases of a given variable along with its points to information queries that are required for the clients like taint analysis.
since it requires all alias queries in cases of simple demand driven points to alias queries it can perform more work than that required to answer the input demand driven queries.
recently sp ath et al.
have presented a demand driven flow fieldand context sensitive pointer analysis which encodes contextsensitivity and field sensitivity as a separate synchronized cfl reachability problems using the concept of synchronized pushdown systems spds .
all these techniques answer one query at a time fully on demand and none of them exploit the resulting advantages when the queries come in batch.
these works perform ad hoc caching or summarization to avoid redundant computations across different queries without exploiting the availability of queries in advance in batch mode.
hence they suffer from storing unnecessary information and or from missing to store useful information across different queries leading to performance losses.
we overcome these challenges by proposing a batch analysis framework that can handle multiple queries in a batch mode.
we instantiate a batch version of the popular demand driven analysis of yan et al.
.
we have observed the recent demanddriven works although more precise than that of yan et al.
do not suit for clients where the number of alias queries is large.
further most of the techniques discussed above suffer from the issue of irrelevant path traversals which is addressed in this paper.
analyses that handle queries in batch.
su et al.
proposed a parallel algorithm to cfl reachability based demanddriven context sensitive points to analysis to meet the requirements of clients where the queries come in batch.
the technique processes the queries independently on differentcores allowing some data sharing across different queries based on few heuristics.
in this paper we propose a sequential algorithm which processes multiple queries together in one pass as a batch query.
hence our technique does not require data sharing across individual queries in a batch query.
there have been prior works not demand driven that present target client specific solutions improving the precision based on a complete set of queries .
in contrast we present a scheme to improve the performance and precision by exploiting the underlying features of batch queries.
their techniques are complimentary to our approach.
type based optimizations in points to alias analyses.
diwan et al.
use type information and propose different alias analyses for modula a statically typed type safe language.
for java many past works perform type based checks to avoid invalid data flow paths and thus improve the precision and efficiency of the points to analysis.
the work of sridharan et al.
hereafter referred to as sri uses type based optimizations that subsumes the ones used by lhot ak and hendren and sridharan et al.
.
the type based checks of sri use compatible types to avoid marking possible aliasing nodes in two phases during a whole program pre analysis by avoiding the addition of some match edges ahead of time not dependent on demanddriven queries on the fly when answering a points to query by not considering nodes whose types are incompatible with the type of the query variable.
in contrast we consider enclosing types along with compatible types used in sri for constructing the set of relevant types with respect to the given demand driven queries and use them to avoid traversing irrelevant paths in the ispg.
viii.
c onclusion demand driven analyses can be costly when applied on large systems where the number of queries is high.
this is not acceptable in cases when the clients of the analyses are plugged into an ide kind of resource bound environments.
we propose the idea of batch alias analysis that can efficiently address such clients by avoiding redundant computations within batch queries.
batch analysis suits the environments with strict time constraints where the queries come in batch.
our proposed techniques publicly available improve the performance by avoiding redundant and irrelevant computation.
our evaluation shows that the proposed batch analysis leads to significant performance gains along with minor gains in precision.
we also show that the elimination of irrelevant search paths can improve the performance and the precision of the demand driven alias analysis of yan at al.
the best one suitable for race detection type of clients .
acknowledgment we thank the shepherd the pc chairs and all the reviewers for their valuable comments.
we thank dacang yan harry xu and atanas rountev for making their code publicly available .
jyothi v edurada is supported by the tcs research scholarship program for her doctoral studies.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.