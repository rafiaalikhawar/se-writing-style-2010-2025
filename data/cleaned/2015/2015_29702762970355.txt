lockpeeker detecting latent locks in java apis ziyi lin1 hao zhong2 yuting chen2 jianjun zhao3 1school of software shanghai jiao tong university china 2department of computer science and engineering shanghai jiao tong university china 3department of advanced information technology kyushu university japan linziyi zhonghao chenyt sjtu.edu.cn zhao ait.kyushu u.ac.jp abstract detecting lock related defects has long been a hot research topic in software engineering.
many efforts have been spent on detecting such deadlocks in concurrent software systems.
however latent locks may be hidden in application programming interface api methods whose source code may not be accessible to developers.
many apis have latent locks.
for example our study has shown that j2se alone can have latent locks.
as latent locks are less known by developers they can cause deadlocks that are hard to perceive or diagnose.
meanwhile the state of the art tools mostly handle api methods as black boxes and cannot detect deadlocks that involve such latent locks.
in this paper we propose a novel black box testing approach called lockpeeker that reveals latent locks in java apis.
the essential idea of lockpeeker is that latent locks of a given api method can be revealed by testing the method and summarizing the locking effects during testing execution.
we have evaluated lockpeeker on ten real world java projects.
our evaluation results show that lockpeeker detects .
of latent locks in api methods and it enables state of the art tools to detect deadlocks that otherwise cannot be detected.
ccs concepts software and its engineering !software testing and debugging keywords latent lock deadlock detection api method .
introduction in multi threaded programs locks are used to exclusively access memories.
defects such as deadlocks and livelocks can be raised when locks are inappropriately enforced and or released by threads.
as such defects decrease code quality many approaches have been proposed to detect locking related defects.
with the support of the these approaches many concurrency bugs have been detected and some are previously unknown .
corresponding co authorsin modern programming apis are widely used but their locks may not be well documented.
latent locks can live in api sources.
in this paper we refer to a lock located inside an api whose source is unaccessible as a latent lock .
we have conducted a preliminary study by analyzing the source files of j2se1.
the results show there are locks behind j2se apis.
these locks can be taken as latent locks if developers do not step into their sources.
latent locks typically exist in two types of apis close sourced apis which are encrypted e.g.
commercial libraries and apis whose programming languages are different from the programming languages of client code e.g.
native c c c assembly apis that are called through java native api .
as developers may not be able to access the source code of encrypted or native apis it becomes impossible to find latent locks inside and detect defects related to these locks.
motivating example and the state of the art.
latent locks can cause serious bugs such as deadlocks.
figure 1a shows a simplified version of eclipse birt 2871022which contains a deadlock caused by latent locks.
when a thread thread ofthread1 starts it invokes the j2se method forname line when a thread thread ofthread2 starts it acquires a lock onobj line .
as shown in figure 1b a deadlock can happen because the native method forname0 acquires a lock on its parameter loader thread 1can invoke loadclass and acquire a lock on obj lines when holding loader at the same time thread 2invokes forname and acquires loader line when holding obj.
however even the thread dump as figure 1c shows does not state that locks are held and acquired in the native method.
without any knowledge that a thread can lock a classloader when invoking forname0 a program analysis tool cannot detect the deadlock.
to the best of our knowledge previous deadlock detecting approaches are less effective in finding such bugs since they omit analyzing apis and are often not comprehensive enough to analyze the cross language sources.
for example our previous work shows that existing tools e.g.
jpf and checkmate cannot detect deadlocks that involve latent locks in native code.
as surveyed by hong and kim to detect lock related defects all the existing approaches construct execution models for sources under analysis.
for example sorrentino et al.
dynamically record reads and writes to shared variables and construct an execution model for the program in analysis.
however when sources are unavailable it is difficult to determine which variables are shared and thus difficult to detect the corresponding concurrency bugs.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september singapore singapore c acm.
... .
.
public class simplebirt287102 .
private simpleclassloader loader .
private object obj .
class thread1 extends thread .
public void run .
class.forname java.lang.object true loader .
.
class thread2 extends thread .
public void run .
synchronized obj .
class.forname java.lang.object true loader .
.
class simpleclassloader extends classloader .
public class ?
loadclass string name .
synchronized obj ... .
return super.loadclass name .
.
private static native class ?
forname0 string name boolean initialize classloader loader class ?
caller a buggy code t1 t2 acq obj acq loader acq obj rel obj rel loader18 acq loader rel loader rel obj15 non deadlock execution deadlock execution legends event in ordinary method event in api method line number in left program b deadlock execution thread at java.lang.class.forname0 native method at java.lang.class.forname class.java at simplebirt287102 thread2.run simplebirt287102.java locked 0x00000000d5eee710 a java.lang.object thread at simplebirt287102 simpleclassloa der.loadclass simplebirt28710 .java waiting to lock 0x00000000d5eee710 a java.lang.object at java.lang.class.forname0 native method at java.lang.class.forname class.java at simplebirt287102 thread1.run simplebirt287102.java c thread dump figure buggy code simplified from birt .
some approaches can analyze api methods if their source code is available.
some other approaches generate replacements for api methods.
for example shafiei and breugel manually write replacement code for native methods.
as another example kalinovsky introduces a technique that decompiles java bytecode.
however as a replacement is usually not precisely equivalent to the original method a latent lock in the original api method may not appear in its replacement.
our approach.
having observed that api methods are not easy to analyze and believing that proper replacements can facilitate program analysis we propose in this paper an approach named lockpeeker that leverages locking behavior s effect in java to construct a locking model for each api method.
such effect is reserved in any java api no matter whether it is encrypted or native.
the model clearly presents whether some latent locks can be enforced in an api method and thus aids program analysis tools in detecting deadlocks intertwined by explicit and latent locks.
however there remain many difficulties of generating such locking behavior models since locked resources locking structures andlocking conditions are not explicitly defined even in their api documents.
many related questions are raised are there locks in an api method?
which object s will be locked within the api method?
what are the relations among locks?
are they nested?
is there any conditions for locking?
without answering these questions it is not possible to construct a precise locking behavior model for an api method since its details are still blind to analysis.
lockpeeker has two major steps to detect latent locks in java api methods it repeatedly executes a target method and collects the locks triggered during execution through which a lock tree structure is synthesized and locking conditions are inferred by observing which test inputs trigger the locks.
synthesized lock trees can be leveraged by existing tools for deadlock analysis.
this paper makes the following contributions problem statement .
to the best of our knowledge we are the first to state the research problem of detecting latent locks in api methods.
the research problem can motivate follow up work that leads to more practical approaches and tools.
approach .
we propose a novel approach called lockpeeker that detects latent locks in java api methods.
the essential idea of lockpeeker is that given an api method to perform an extensive unit testing of this method through which a tree of latent locks within the method can be derived by observing whether any locks can be enforced and the locking condition s can be inferred by learning which lock s can be acquired by which test input s .
implementation and evaluation .
we have implemented a tool to support lockpeeker and evaluated lockpeeker on ten realworld java projects.
our results show that lockpeeker detects .
of locks in api methods.
furthermore lockpeeker allows locking trees and locking conditions to be generated for java api methods which helps find deadlocks that otherwise cannot be detected from such methods.
the rest is organized as follows.
section introduce our preliminaries.
section presents our approach.
section evaluates lockpeeker.
section surveys related work.
section discusses relevant issues and the future work.
section concludes this paper.
.
preliminaries in this paper we advocate the idea of inferring the locking structure and the associated conditions for a java api method.
in java a thread can use the synchronized keyword to acquire an object s intrinsic lock that enforces exclusive access to the object allowing a block of statements be exclusively executed.
more sophisticated locking idioms e.g.
using a lock object are supported in the java.util.concurrent.locks package.
for simplifying our discussion we focus on intrinsic locks in this paper because a lock object can be interpreted as one or more intrinsic locks.
369i receiver this v1 v2 true v3 a f1 b f2 c v3 default f1 v1 v2 f2 default api code .
public class example .
private object f1 .
private object f2 .
foo int v1 boolean v2 object v3 .
synchronized v3 .
if v1 v2 .
synchronized f1 ... .
.
synchronized f2 ... .
.
getters and setters for f1 and f2 .
v v3 v f1 v f2 receiver parameters fields slt clt true figure example of slt and clt.
the slt represents the locking structure of the foo method.
the clt provides locking conditions.
the getters and setters for the fields in api code are omitted.
in a method locks can be sequentially or nestedly acquired and released many times under certain conditions.
lock tree and lock order graph have been proposed to describe how locks are organized in threads for deadlock detection.
a lock tree is typically related to a thread and its nodes are stateless its root represents the thread and each node represents a lock acquired by the thread.
we use a similar tree to represent locking structure and locking conditions in a method.
moreover we need stateful information i.e.
test inputs of the target method on the tree to infer the locking conditions.
we use a test input interface to collect all variables used for testing a target method.
correspondingly a test instance is composed of the concrete values for a test input interface in a test session.
we extend a lock tree to a stateful lock tree slt .
definition s tateful lock tree .for a method m declared in a class c a stateful lock tree describes when a lock is triggered the execution structure and the test instance of m. the root i denotes a test instance that triggers the lock including the receiver the this object or c class the parameters of mand the fields of c. a nodehvidenotes the variable that contributes the lock.
a parent child relation between two nodes indicates that two locks are nestedly enforced the parent corresponds to the outer lock and the child the inner one.
the locks can be conditionally enforced.
we thus use condition lock tree clt to represent such a locking structure and the locking conditions in a method definition c ondition lock tree .for a method its clt is an slt whose nodes are supplemented with conditions.
the root con denotes the default condition for all nodes.
a nodehv conidenotes the variable on which the lock is placed and the condition to trigger the lock.
a child can be associated with a condition stronger than its parent s condition.
the condition on root is by default true indicating that the lock is triggered unconditionally.
any condition on a node is by default the same as the condition on its parent.
for example figure shows an slt and a corresponding clt derived from the foo method.
the root of the slt contains a test instance consists of receiver method parameters and class fields.
node v3isfoo s third parameter and nodes f1andf2are class mutating inputs generating slt inferring conditions generating clts synthesizing condition synthesizing structure picking input constructing slt merging slts merging clts clt api method figure overview of lockpeeker.
fields where v3andf1are nested locks represented by the left subtree and f2is a lock separately represented by the right subtree.
the locking condition is shown on the clt.
node f1has a specified condition indicating the variable f1is locked under the condition v1 0jjv2 and other nodes conditions are by default true indicating that they are locked unconditionally.
we explain more details of slts and clts in section .
.
.
approach this section first presents an overview of lockpeeker section .
and then presents how to synthesize the structure of a clt section .
and how to infer the conditions of the clt section .
.
.
overview lockpeeker constructs a clt describing the locks for a target method m. as shown in figure lockpeeker takes two major steps in constructing a clt step constructing slts .
lockpeeker iteratively generates test instances and executes m. at each iteration lockpeeker checks whether locks are triggered in m if a test instance can trigger locks an slt is constructed to represent the observed locks.
in this step we can generate many slts for a given api method each corresponding to one test instance.
step merging slts into a clt .
lockpeeker merges the slts into a clt whose nodes conditions are inferred by learning the test instances.
the clt represents the observable locks and locking conditions in m allowing a program replacement to be created.
the program replacement allows existing tools to step into m during locking analysis.
.
synthesizing structure .
.
constructing slts for a target api method m lockpeeker constructs an slt for mthrough performing a unit testing of the method.
we formalize a detection process as follow slt par thread acquire i thread call m i where parrequires that the two threads shall run in parallel idenotes a test instance idenotes a variable of i and sltdenotes a slt that describes the observed locks in the execution.
a simple construction involves two threads thread 1is a thread acquiring a lock on i thread 2another calling m. once thread 2is blocked to wait for locking i iis the object locked in m. therefore lockpeeker firstly starts thread 1and then thread and observes whether thread 2is blocked while invoking m i.e.
whether iis locked within m. 370algorithm constructing an slt input a test instance iand an api method m output an slt with locks ret ret root i for each iinido thread .start lock i thread .suspend thread .start call m i ifthread 2is blocked on acquiring ithen tree tree i nestinglocks checknesting t2 ifnestinglocks6 then tree add nestinglocks else tree add i end if ret ret.merge tree end if thread .terminate thread .terminate end for algorithm cur.merge target input current slt cur objective slt to merge target output current slt merged with the objective slt ifissimple then return corresponding slt end if for each targetchild intarget children do node2add null for each curchild incur children do iftargetchild issame curchild then node2add null curchild curchild merge targetchild break else node2add targetchild end if end for ifnode2add6 null then cur add node2add end if end for return cur when two non nested locks are observed we cannot determine which lock is ahead of another as we do not have the source of m. however for the purpose of deadlock detection only the nested locking sequence matters.
algorithm shows an iterative process of constructing for a method an slt w.r.t.
a test instance.
it creates the slt s root ret based on the test instance i line .
for each variable iini thread 1is started to acquire a lock on i. after the lock is acquired thread suspends and keeps holding it lines .
thread 2is then started to invoke mwithias its input values by reflection lines .
the two threads are observed by the main thread .
line checks whether thread 2is blocked and more importantly whether thread happens to be blocked by the intrinsic lock that is being held by v3 f1 f2 f2 f1 v3 v3 f1 f2 f2 f1 v3 slt slt slt slt a slt equivalent relation.
slt1andslt2are equivalent but slt3 andslt4are not.
v3 f1 f2 v3 f2 v3 f1 f1 slt slt slt 3slt b slt containing relation.
slt1contains slt2andslt3 butslt2is not a subtree of slt1 while slt3is.slt4is not contained in slt1.
figure equivalent and containing relations of slts.
only structures are considered values in the roots are ignored.
thread asthread 2may also be blocked for the other reasons e.g.
an invocation of the wait method in m .
if so an empty slttree is created line and checknesting3is called to check whether there exist nested locks line .
if there are nested locks they are all added into tree lines .
only the current checking object iis added otherwise line .
after that tree is merged into ret line .
the merging of slts can be performed by checking whether an slt can be equivalent to another or contained by another relation slt e quivalent .two slts are structurally equivalent regardless of the test instance denoted as slt1 slt2 as shown in figure 4a.
relation slt c ontaining .one slt slt1contains another slt2 denoted as slt2 slt1 if there exists an slt1 s subtree which can be added to a certain node of slt2 s such that slt1 slt2 as shown in figure 4b.
algorithm shows how function merge works.
it firstly checks if the two candidate slts to merge satisfy relation or relation and returns cur for relation or the containing slt for relation lines .
otherwise it moves on to traverse target s children nodes and compares each one say targetchild with each of cur s child node say curchild .
if targetchild and curchild are same nodes node 1hv1iandnode 2hv2iare same when v1 v2 their subtrees are merged recursively lines .
if no same node can be found targetchild is added as a new child lines .
we next use the foo method in figure to illustrate the merge function.
let two slts tree1andtree2 be merged tree1has only one node v3 and tree2has two parent child nodes v3and f1 .
as tree1 tree the merge function returns tree2and eliminates a redundant tree i.e.
tree1 .
iftree1has only one node f2 the merging of tree1andtree2results the slt in figure .
picking up detection candidates.
a method may have a large set of variables in its test interface as locking candidates.
for a method mdeclared in a class c the locking candidates can be categorized into four sets smp the parameters of m si the receiver the this object and the class object of c sf the fields of c and se the environment objects .
our empirical study which will be explained in section .
clearly shows that locks on environment 3function checknesting takes the blocked thread as input.
it retrieves the thread s information by calling getthreadinfo method from threadmxbean .
371objects and parameters are rare while it will be quite difficult to explore all environment variables w.r.t.
black box apis.
thus we omitse but leave it for future work.
in our study we consider only the following sets as locking candidates sc smp si sf lockpeeker also omits variables whose types are primitive e.g.
integer andfloat since it is error prone to lock such resources.
indeed many programmers believe that it is a bad practice to acquire locks on variables of primitive types.
for example findbugs determines such locks as bugs4.
therefore we assume developers follow the good practise but spend more resources on checking the locks on non primitive variables for efficiency.
.
.
mutating test instances algorithm constructs an slt from an initial test instance which is related to a set of default values for its variables e.g.
0forint variables and true forboolean variables.
for complex types they are instantiated with their simplest constructors with the support of reflection.
if such variables do not have visible constructors mocked objects are then taken with the support of mockito5.
meanwhile using the default values can detect the structures of simple locks e.g.
theforname0 method but is insufficient for those methods with complicated structures e.g.
thefoo method in figure .
as test instances with different values for their variables can reveal locks in different branches we mutate the initial test instance to explore complicated structures.
however it is infeasible to completely determine how many mutants are sufficient too few mutants may not explore all necessary branches meanwhile it is expensive to use a number of mutants to test the method if few conditional locks exists within the method.
lockpeeker takes a two phase exploration strategy to tackle this problem.
lockpeeker first takes a blind exploration phase to detect whether the locks are conditional and what their structure s are.
the variable values of a test instance are randomly mutated for exploring branches.
lockpeeker reuses the mutation operators that are proposed by alexander et al.
.
besides mutating individual values lockpeeker considers a combination of values.
for example if an value is of a boolean type lockpeeker keeps it as true orfalse and tries values for other variables.
the blind exploration needs to terminate in a limited number of iterations.
we have evaluated the blind exploration phase the details will be explained in section .
and the results show is a reasonable threshold to terminate the exploration.
next lockpeeker takes a guided exploration phase in which a greedy heuristic is used to search for more slts for condition boundaries.
as the locking condition s structure has been detected in this phase only the variables that are involved in the condition are mutated.
the rationale of this is based on an assumption that slts are neighbors.
thus it is feasible to find more slts by exploring the neighbors of a found slt.
for example if the root of slt m is an integer whose value is m lockpeeker first tries m nand m n where nis randomly picked.
if two stls slt m nand slt m n are built lockpeeker compares the built stls for the next mutation if slt m n slt m6 slt m n lockpeeker takes a fast mutation strategy to look for the boundary which lies between mandm n ifslt m n6 slt m slt m n the boundary value is explored between m nandm.
it explores the boundary value in both directions by enlarging notherwise.
strategy.
lockpeeker takes a fast mutation strategy for exploring the boundary values effectively.
let two slts s1ands2 be inequivalent and their test instances be i1 i1 i1 i1 n and i2 i2 i2 i2 n .
we search for the boundary value i0 i0 i0 i0 n between i1andi2.
during the search lockpeeker changes the numeric values to their averages but does not change the nominal values.
based on the new test instance i3 lockpeeker builds a new slt s3 .
ifs3 equals to s1 lockpeeker searches between i3andi2 ifs3equals tos2 lockpeeker searches between i3andi1.
the search process continues until iis close to zero.
.
synthesizing condition after exploring boundary values by mutating inputs lockpeeker generates many discrete slts.
it infers conditions and deduces a clt out of those generated slts to represent the locks of an api method.
for simplicity we assume that an input is compared with only an operator e.g.
and and the values to compare are constants.
inferring a decision tree lockpeeker uses a decision tree to classify slts.
in a decision tree a leaf represents a tree structure that is shared by a number of slts the path from the root to a leaf represents a classification rule for the tree structure.
lockpeeker infers the decision tree with the c4.
algorithm implemented in an open source machine learning tool weka .
the algorithm takes encoded slts as its inputs and infers a decision tree.
an slt is encoded by its tree structure and inputs where the tree structure is used for classifying and the input values for inferring rules for each classification.
constructing clts based on the decision tree lockpeeker constructs clts.
a tree structure can be restored from a leaf of a decision tree dt and the condition for such tree structure be deduced from the path from dt s root to the leaf.
the clt is constructed by putting the condition to the root of the tree structure.
multiple leaves can lead to the same tree structure indicating the condition for such a clt is a union of all the paths.
merging clts algorithm describes how clts are merged.
most of the algorithm is similar to algorithm except that no checks for relation or relation are performed at the beginning because nodes conditions are still required to merge even if any of the relations is satisfied conditions are combined with an oroperator line when two nodes are same nodes node 1hv1 con 1iand node 2hv2 con 2iare same if v1 v2 .
figure shows an example of the whole process of revealing latent locks in the foo method in figure .
it starts from an initial test instance which is then iteratively mutated to generate slts.
two slts tree 1andtree have two nodes and the other two slts tree 2andtree have three nodes more slts with similar structures are not shown.
after they are encoded tree 1and tree 4are grouped into locktree andtree 2andtree 3are grouped intolocktree .
lockpeeker infers a decision tree with three leaves from encoded slts.
the right two leaves refer to locktree and the left leaf refers to locktree .
based on the decision tree lockpeeker constructs two clts with conditions specified on roots.
locktree s condition is parsed from the decision tree s leftmost path locktree s condition is parsed from the other two paths.
at last two ctls are merged into one and merged conditions are simplified i.e.
f1 s condition is simplified to v1 0 v2 true and the other nodes conditions true .
372f1 v3 f2 v3 f2 v2 true v false v v2 false v v3 f1 v1 v2 true f2 attributes class v1 v2 v3 false a locktree true a locktree true a locktree false a locktree false a locktree false a locktree true a locktree false a locktree ...yes yes no no locktree 1locktree 2locktree f a t a f a f a ...f1 v3 f2 locktree locktree 2api method input mutating generating encoding inferring deducing merging if v2 true if v1 synthesizing structure synthesizing condition v3 f2 f1 v3 f2 f2 v3 tree 1tree tree 3tree 4figure an example of the whole process to construct a clt from a target api method.
only method parameters are shown for simplicity.
algorithm cur.cmerge target input current clt cur objective clt to merge target output current clt merged with the objective clt for each targetchild intarget children do node2add null for each curchild incur children do iftargetchild issame curchild then node2add null curchild condition curchild condition targetchild condition curchild curchild cmerge targetchild break else node2add targetchild end if end for ifnode2add6 null then cur add node2add end if end for return cur .
ev aluation we have developed a tool for lockpeeker and conducted evaluations on ten open source projects.
the evaluation is to answer the following four research questions rq1 how effective is lockpeeker in revealing locks in java api methods section .
?
rq2 what kinds of deadlocks can be detected if our detected latent locks are integrated section .
?
rq3 what is the significance of lockpeeker s threshold section .
?
rq4 what are the essential test instance variables that may trigger locks section .
?
correspondingly our evaluation results which will be explained in this section indicate that lockpeeker detects .
locks from real world project methods with our detected latent locks existing tools are able to detect real deadlocks that involve latent locks in native methods when the threshold is we have .
of confidence that the conditions and structures of locks can be fully revealed and a majority of locks are placed on method parameters fields and receivers.table subjects.
in this table m and em represent the total number of methods and the number of evaluated methods respectively l and el represent the total number of locks and the number of evaluated locks respectively.
project loc m em l el version dbcp .
derby .
.
.
ftpserver .
.
groovy .
.
hsqldb .
.
log4j .
.
lucene .
.
pool .
tomcat .
.
xalan .
.
total .
rq1.
detected locks in this section we have evaluated lockpeeker with real world java programs for its capability of finding latent locks.
.
.
setup subjects ten popular open source projects used in concurrency testing researches are employed as our subjects .
lockpeeker takes their methods as api methods and does not analyze their code.
the ground truth is established by a code reading of these projects.
we firstly searched in the ten projects the synchronized keywords that are enforced within methods and in total synchronized keywords were found in methods.
the results were analyzed by three software engineering graduate students to identify the sources of locking objects the locking structures and locking conditions.
this work is manually completed as few tools can just meet our requirements.
as discussed in section .
.
we focus on locking candidates from method parameters fields and receivers.
to guarantee the representativeness we selected locks from all of the three types which include methods with locks all of the methods that acquire locks on method parameters were selected and for fields and receivers we randomly selected ten methods from each project.
we thus obtained methods that acquire locks on fields and methods that acquire locks on receivers.
there are two overlapping methods for parameters and fields.
table shows our subjects.
columns project version loc m em list their project names versions project sizes the numbers of methods that have locks and the number of methods used in the evaluation respectively.
columns l and el list the 373table results of detecting locks.
projectsparameter field receiver total rc1 rc2 locks rc1 rc2 locks rc1 rc2 locks rc1 rc2 locks dbcp n a n a derby .
.
.
.
.
.
ftpserver n a n a .
.
groovy .
.
hsqldb .
.
log4j .
.
.
lucene .
.
.
.
pool n a n a n a n a tomcat .
.
.
.
.
.
xalan n a n a .
.
total .
.
.
.
.
.
.
.
numbers of synchronized keywords inside methods and those of evaluated locks respectively.
metrics we compared our detected locks with the ground truth at three levels whether a lock is detected whether the relations sibling nesting among locks are detected where the sibling sequence is ignored and whether the branching specifications e.g.
condition expressions catch clause and loops are detected.
when all tree levels are reached we say that the lock is strictly detected .
when the first two levels are reached the lock is loosely detected .
meanwhile even if a detected lock is loosely correct it helps reveal deadlocks.
the definitions of our recall are rc strictly detected total rc loosely detected total where strictly detected orloosely detected denotes the number of the strictly or loosely detected locks and total denotes the total number of locks.
default call sequence and input values to reveal locks a method shall be invoked with appropriate call sequences and values.
typically tools analyze sources to obtain call sequences and values.
for example grt can generate correct call sequences.
but such techniques are not ready for api methods whose source are inaccessible.
we thus use the default values for primitive objects instantiate complicated objects by their default constructors or mocked objects but omit call sequences.
.
.
result lockpeeker does not report any false positives in the evaluation.
we manually compare the reported locks with the ground truth.
all reported locks reside in the subject programs.
table shows the recalls of our detected locks.
columns parameter field and receiver list detected locks on method parameters fields and receivers respectively.
column total lists total detected locks.
sub columns rc rc and locks list the rc 1s rc 2s and the number of locks respectively.
the results show that lockpeeker detects .
of locks in total and it effectively detects all of the three types of locks.
we inspected the inferred locks and found that some inferred locks are complicated.
for example the forceflush method in derby has a nested lock when a boolean field is false .
below shows the relevant code i f s t o p s h i p p i n g return synchronized f o r c e f l u s h s e m a p h o r e synchronized objlstsync .
.
.
.
.
.
lockpeeker successfully detects structures and conditions of many such locks.
however it fails in detecting locks due to two main reasons the details shall be discussed in section .
insufficient call sequences and input values .
out of locks are not detected since special call sequences and input values are needed to trigger these locks.
as api methods are in black boxes it is infeasible to explore call sequences and input values.
complicated code structures .
out of locks are not detected since their structures and conditions are rather complicated.
in addition as discussed in section .
.
lockpeeker omits searching for the locks on variables of primitive types.
it is worth noticing that programmers can enforce locks on such variables in practice which violates our initial assumption.
for example the programmers of the xalan project acquire locks on variables of the boolean types.
in summary our results lead to the first observation lockpeeker is able to detect more than two thirds of locks in real world apis even if their sources are inaccessible.
in addition the variety of the subjects in table is high.
although lockpeeker is less effective in detecting locks from complicated methods these complicated methods are not evenly distributed in the selected subjects.
.
rq2.
detected deadlocks .
.
setup we integrate lockpeeker with a deadlock detection tool named checkmate whose idea is originally proposed by joshi et al.
and reimplemented in our previous work .
checkmate instruments source code of a program under analysis to collect its concurrency behaviors including synchronizing starting joining waiting and notifying threads .
after executing the instrumented program checkmate records a trace program which is an execution model of the original program.
checkmate then employs jpf to detect deadlocks from the execution model.
we compared the capabilities of checkmate in detecting deadlocks before and after it is integrated with lockpeeker.
subjects .
table shows the descriptions and the repair time of our selected deadlocks.
the following call sequences trigger deadlocks with latent locks .
the new relic bug of jboss.6the native method forname0 has a latent lock.
thread1 lock forname0 s parameter moduleclassloader !lock verifier 374table found real world deadlock bugs that involve latent locks.
bug bug description repair time new relic with jboss jboss does not start up correctly because of a deadlock in threads when new relic is enabled.
unknown ibm iv 30066in jvm class loading there is a validation whether a class is already in loading process or not.
but it may deadlock during this validation.
days eclipse birt 287102a deadlock happens when a data import thread opens a lot of files in a loop and another thread attempts to initialize a birt report engine in the same time.
days groovy 4736when multiple threads uses groovyclassloader to get groovy classes or just work with them and an other s threads change the sources then deadlock can happen.
years found l o c k s i n t h e method j a v a .
l a n g .
c l a s s .
forname0 ljava l a n g s t r i n g zljava l a n g c l a s s l o a d e r ljava l a n g c l a s s synchronized p3 p3 t h e t h i r d method p a r a m e t e r figure an example of latent lock reported by lockpeeker.
thread2 lock verifier !lock moduleclassloader .
.
ibm iv .7the native method fornameimpl has a latent lock.
thread1 lock fornameimpl s parameter extclassloader !waiting thread2 terminates thread2 lock extclassloader !terminate .
.
eclipse birt .8the native method forname0 has a latent lock.
thread1 lock forname0 s parameter childfirsturlclassloader !lock jarfile thread2 lock jarfile !lock childfirsturlclassloader .
.
groovy .9the two native methods forname0 andgetdeclaredfields0 both have latent locks.
thread1 lock hashmap !lock groovyclassloader innerloader ingetdeclaredfields0 thread2 lock forname0 s parameter groovyclassloader innerloader !lock hashmap .
.
.
result checkmate originally detects none of the four deadlocks.
after it is integrated with lockpeeker checkmate detects all the four deadlocks since lockpeeker supplements checkmate with the latent locks inside the unanalyzable api methods.
example we use birt in figure to illustrate how our detected locks improve checkmate.
checkmate alone does not report the deadlock in birt as it is not aware of the existence of latent locks inside the native method forname0 .
the trace program figure 7a generated from the buggy code figure 1a shows that the two threads both request the lock on obj1 .
checkmate alone does not report any deadlock for this because there is actually no cyclic locking behaviors in the trace program.
lockpeeker supports checkmate with support in finding potential deadlock in two steps detecting latent locks.
lockpeeker scans all the api methods that are called in the buggy code and finds that the forname0 method has a latent lock on its third method parameter which is named as p3.
for the native method lockpeeker swg1iv30066 public class traceprogram static object obj1 new object static thread t1 new thread public void run synchronized obj1 static thread t2 new thread public void run synchronized obj1 public static void main string args t1.start t2.start a original trace program generated by checkmate when lockpeeker is not integrated.
public class traceprogram static object obj1 new object static object obj2 new object static thread t1 new thread public void run synchronized obj2 synchronized obj1 static thread t2 new thread public void run synchronized obj1 synchronized obj2 public static void main string args t1.start t2.start b new trace program generated by checkmate when lockpeeker is integrated.
figure simplebirt287102 s trace programs generated by checkmate with and without lockpeeker.
generated a clt that has only one node p3 indicating that the method has a latent lock on its third parameter with condition true .
figure shows the reported latent locks.
supplementing detected latent locks on objective code.
we make latent locks visible to checkmate by explicitly supplementing them as program replacements in the objective code along with the actual api call.
in particular when an api method mhas no callback we add program replacement before the call site of m. ifmhas callback we firstly check if the callback is within the scope any latent lock and surround it with corresponding lock and conditions .
thus duplicated locks are added but they will not affect the actual api execution because when the added lock is reached the thread must have hold the same lock already.
checkmate executes the resulting program and generates a new trace program figure 7b which has the latent lock.
as highlighted by the gray background a new lock on obj2 and relevant locking statements are newly generated.
jpf thus can report the deadlock in birt by checking the new trace program.
since the combination of lockpeeker and checkmate advocates an idea of modifying the objective code rather than modifying checkmate itself the resulting program with supplemented method replacements can also be used by other tools for detecting deadlocks.
however it still requires human efforts in matching locking scopes and callbacks i.e.
determining into which locations the method replacements should be instrumented we plan to automate the matching process in future.
.
rq3.
significance of threshold as section .
explains the blind exploration phase requires a threshold to terminate its exploration.
here we use different threshold values to evaluate the impacts of the threshold on different types of conditions.
375table significance of the threshold.
project method condition type pi20 c1 c2 c1 c2 c1 c2 c1 c2 c1 c2 tomcat getservlet nominal .
derby skip numeric .
derby setsharedstate nominals .
hsqldb delete numerics .
derby isvalid nominal numeric .
tomcat run numerics .
total .
.
.
.
.
.
.
.
.
.
.
.
.
setup the impacts of the threshold highly depend on locking condition s structures.
subjects.
according to our analysis on the locks in table conditions on locks can be atomic conditions or compound ones.
an atom condition can be a nominal condition that determines whether values equalize to constants or a numeric condition in which numeric values are compared.
a compound condition is composed of two or more atomic conditions.
it has two types of information a condition structure for organizing two or more atomic conditions using logical operators and constant values indicating options of nominal conditions and boundary values of numeric ones.
we found that out of locks have conditions.
most conditions are simple since out of have two or less atomic conditions.
as compound locking conditions consisting of four or more atomic conditions are rare we analyzed those consisting of at most three atomic conditions.
from the ten projects in table we investigated the significance of the threshold by selecting six methods.
each method has locking conditions.
thus we collected two atomic conditions three compound conditions with two atoms and a compound condition with three atoms.
we simplified each method such that the method only keeps the locking conditions and locking actions.
the representativeness of the samples can be calculated by representativeness condition type total where condition type is the number of locks in a type and total the number of total locks with conditions in our evaluation .
metrics.
we randomly searched the test instances.
following the guideline of arcuri and briand for each threshold value we executed our approach for one hundred times.
we define two criteria to measure our results c1 structure detected total run c2 detected total run where structure detected is the times of correctly detecting the condition structures of locks detected the times of correctly detecting both the condition structures and their boundary values and total run is one hundred.
.
.
results table shows the results.
columns project method and condition type list the sampled projects methods and condition types.
column pi lists the representativeness values that are calculated by equation .
columns to list c1andc2 values calculated by equations and when threshold values are set from to .
the results indicate that in blind exploration phase is sufficient for detecting both structures and values for most condition .
.
.
.
.
.
.
.8smpsisfsese sf si smpfigure the distribution of locks of the ten open source projects.
smp si sf and sedenote the locks on method parameters receivers fields and environment variables.
types i.e.
the top five types .
however blind exploration alone cannot handle more complicated types as it fails in detecting conditions for three numeric conditions.
to reveal the overall impact of a threshold for c1andc2 their total values are calculated as total c1 x pi c1 total c2 x pi c2 when the threshold value is the total values of c1andc2 are .
and .
respectively.
when we chose some larger threshold values the total values of c1andc2did not increase significantly.
thereafter we selected as the default threshold value when the total values of c1andc2are .
and .
.
the total value of c2only increases to when the threshold is .
.
rq4.
essential variables we next investigate which variables can trigger locks in api methods.
.
.
setup to answer which variables in test instances can cause locks inside api methods we asked the three graduate students in section .
to classify locks into categories according to their origins.
they analyzed all the locks in table .
.
.
result the locks fall into the four categories figure m s parameters denoted as smp.
an instance of class c usually referred by this or the class object of c i.e.
c.class denoted as si.
class c s fields denoted as sf.
instances returned values from other classes considered as environment variables denoted as se.
our study shows that the three types of locks such as sf si andsmpcover most locks nearly two thirds out of the locks are acquired on fields sf more than a quarter out 376of of locks are acquired on their receivers si the remaining locks are acquired on environment variables se and method parameters smp .
.
threats to validity the threat to external validity includes the representativeness of our selected subjects.
our evaluations were conducted on the ten open source projects.
although the ten projects have nearly one million lines of code and are widely used our analyzed code is limited and the data from other projects can be different.
the threat could be further reduced by introducing more projects as our subject in future work which shall cover more locking idioms.
the internal threat comes from the false negatives.
in our evaluation some locking candidates are omitted.
although rare locks on secan still exist leading to some false negatives.
we plan to find a solution to exploring the environment variables for api methods and revealing latent locks on sein our future work.
.
related work deadlock detection in apis researchers have tackled the problem of detecting deadlocks caused by third party libraries.
williams et al.
statically build lock order graphs for both api code and client code and then detects cycles in such graphs.
jula et al.
instrument both api code and client code to collect locking behaviors.
from collected behaviors they mine deadlock patterns and avoid code from entering same patterns again.
samak and ramanathan take a multi threaded library as input and synthesize relevant multi threaded tests from the input and analyze the associated execution traces for deadlocks.
all the preceding approaches require accessible and analyzable api or native code and thus are not able to detect deadlocks that involve api code.
in the contrast our approach detects latent locks in api code allowing detecting corresponding deadlocks.
deadlock detection for deadlock detection execution models can be built via static or dynamic analysis.
static approaches employ various static analysis techniques e.g.
call graph analysis and points to analysis to look for cyclic acquisitions in program source.
dynamic approaches execute and record traces of a target program and then analyze traces that are generated from non deadlock execution to find potential deadlocks.
the two types of approaches typically omit api or native methods assuming these methods are irrelevant to deadlocks.
our approach complements the preceding approaches since it detects latent locks in api or native methods.
api and multilingual code analysis the research on multilingual code analysis is related since api code and source code are typically two types of code.
hong et al.
proposed new mutation operators in native code to locate faults for multilingual bugs.
kondoh and onodera statically analyze jni programs to detect four types of bugs such as error checking memory leak invalid uses of a local reference and jni calls on critical regions.
li and tan work on exception checking for jni.
lee et al.
focus on the debugging environment for multilingual programs.
tan studies the define use constrains for multilingual programs.
tang et al.
summarize api code to speed up code analysis.
henzinger et al.
infer automata from api code.
zhong et al.
infer specifications from api code while pandita et al.
infer specifications from both api documents and api code.
there is very limited research considering concurrency in multilingual code analysis.
li et al.
statically extract memoryaccess models for both client code and native code and inserts locks to guarantee atomicity.comparatively our approach synthesizes locking code for api methods complementing the preceding approaches.
.
discussion and future work as the first work on detecting latent locks in apis there are still adequate places for improvements.
to provide insights for followup researchers we carefully analyze the failures in table and we identify the following directions that need further exploration call sequences and inputs when a target method requires sophisticated call sequences and input values to activate a lock acquisition lockpeeker may not provide enough information to support such method invocations.
therefore the target method execution may be ended too early to reach the locks causing no false negatives.
however it is possible to support such situation by analyzing apis documents or searching code base for existing client code that calls such apis to find necessary preconditions to assure method execution.
repeated locks a thread can lock a resource multiple times in a method sequentially or nestedly but algorithm can detect only the first locking.
suppose a lock l is acquired twice in thread and to reveal the second locking activity it requires thread 2to holdljust between the two acquisitions.
in addition for a nested situation the acquisition in thread 2will be blocked if the object is already locked.
our current implementation still cannot handle the situations but it may be feasible with the support of jdi10 java debugging interface .
complicated condition branch lockpeeker cannot recognize complicated condition branches and conditions on complicated objects.
for example lockpeeker can discover locks inside catch clauses when the target method step into it but cannot infer the corresponding try catch clauses.
as another example it is common in java to check conditions relevant to the returned value of a method invocation but lockpeeker fails in recognizing such conditions.
.
conclusion locks can be latent in api methods which are not rare but difficult to be detected.
as existing approaches typically treat api methods as empty boxes they are insufficient to detect deadlocks that involve latent locks in api methods.
in this paper we propose a novel approach called lockpeeker that detects latent locks in java api methods by extensively testing a method observing the locking behaviors and inferring the locking structure and conditions.
our evaluation results have demonstrated that lockpeeker is capable of derive a clear locking tree for an api method with a small set of test instances.
we believe that developers can use lockpeeker to identify the latent locks in api methods and improve the robustness of java applications.
.
acknowledgment we would like to thank the anonymous reviewers for their constructive comments.
we would also thank weizhao yuan yingyi wang and xuliang liu for their help in analyzing subject projects.
this work is sponsored by the program in china no.
2015cb352203 the national nature science foundation of china no.
no.
and no.
and the grant of science and technology commission of shanghai municipality no.
15dz1100305 .
architecture.html .