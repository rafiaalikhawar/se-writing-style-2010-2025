how practitioners perceive coding proficiency xin xia zhiyuan wan pavneet singh kochhar and david lo college of computer science and technology zhejiang university hangzhou china faculty of information technology monash university melbourne australia microsoft v ancouver canada school of information systems singapore management university singapore singapore xin.xia monash.edu wanzhiyuan zju.edu.cn pavneetk microsoft.com davidlo smu.edu.sg abstract coding proficiency is essential to software practitioners.
unfortunately our understanding on coding proficiency often translates to vague stereotypes e.g.
able to write good code .
the lack of specificity hinders employers from measuring a software engineer s coding proficiency and software engineers from improving their coding proficiency skills.
this raises an important question what skills matter to improve one s coding proficiency.
to answer this question we perform an empirical study by surveying software practitioners from countries across continents.
we first identify coding proficiency skills grouped into nine categories by interviewing developers from three companies.
we then ask our survey respondents to rate the level of importance for these skills and provide rationales of their ratings.
our study highlights a total of important skills that receive an average rating of .
and above important and very important along with rationales given by proponents and dissenters.
we discuss implications of our findings to researchers educators and practitioners.
i. i ntroduction every software system needs code.
organizations and companies want to hire people with excellent hard and soft skills to create the needed code.
previous studies have looked at soft skills .
for example li et al.
investigated soft skills for software engineers by interviewing software engineers in microsoft and they divided the soft skills into four categories personal characteristics decision making teammates and software product.
however hard skills have not been investigated much.
in this paper we investigate what hard skills contribute to coding proficiency.
we refer to these hard skills as coding proficiency skills the skills necessary to efficiently and effectively write high quality code.
v arious tests and tools have been developed to improve coding proficiency .
additionally coding proficiency skills are also often assessed in a number of technical job interviews .
a large number of hard skills may contribute to one s coding proficiency.
often a large investment of time is needed to acquire a new hard skill and given the limited resources we all have in terms of time and energy we often need to make choices.
what hard skills are necessary?
what hard skill should i invest in next?
these questions are often in the mind of both novices and experienced developers who need to learn new hard skills to remain relevant in the ever changing and fast corresponding author.paced it industry.
they may also be in the mind of recruiters who need to select competent software engineers.
in this work we sought to figure out the hard skills that contribute to coding proficiency and estimate their importance.
we first interviewed software practitioners from three software companies and derived coding proficiency skills grouped into categories general coding skills programming language and infrastructure skills refactoring and reuse requirement engineering software design understanding and learning interacting with environments bug prevention and fixing and estimation.
we then invited thousands of practitioners1from various backgrounds through emails to take our survey including those who work in small to large companies and organizations e.g.
google microsoft linkedin and intel and those who contribute to open source projects on github.
in our survey we asked respondents to rate the identified skills according to their importance and provide rating rationales.
we highlighted coding proficiency skills that are perceived as important and very important along with rationales given by proponents and dissenters.
we make the following contributions we perform a mixed qualitative and quantitative study to investigate how practitioners perceive coding proficiency.
we present our results from our interviews as well as a survey of software practitioners from countries across five continents.
we derive coding proficiency skills that are grouped into categories and rated based on survey responses.
these skills can help novices and software practitioner to be more aware of skills that others deem as very important.
we highlight important coding proficiency skills and the rationales behind the importance ratings for these skills from survey responses.
the remainder of this paper is structured as follows.
section ii briefly mentions related work.
section iii describes our methodology.
section iv presents the results.
we discuss implications and threats to validity in section v. we conclude and present future work in section vi.
1the respondents of our survey are required to have experience in coding.
ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ii.
r ela ted work a. studies on developer expertise the closest work to ours is li et al.
s study .
they interviewed software engineers in microsoft to produce a list ofsoft skills that a great software engineer should have.
these skills are grouped into four categories personal characteristics decision making teammates and software product.
different from this work coding proficiency skills go beyond soft skills and most of them have not been studied by li et al.
we aim to fill this gap in research and complement their findings.
prior work performed empirical studies on how to be a star engineer and conclude nine strategies what employers in a game company look for in new graduates daily work of new hires in microsoft how developers investigate source code and the relevance of computer science and software engineering education based on a survey of respondents .
different from these studies our work involves a wide range of coding proficiency skills validated by practitioners who come from different countries and work for different companies.
b. studies on measuring developer productivity prior studies explored factors that contribute to the productivity of developers including characteristics of workplace and organization team size better management staffing incentives and component reuse .
recently researchers have also investigated developers perceptions on productivity how to summarize and measure development activity correlations between personality style and performance in computer programming .
their findings include reducing context switches and setting goals could improve productivity developers with openness to experience personality have a positive association with breadthfirst programming style i.e.
developers incrementally build up a system by implementing a portion of each functionality and developers with conscientiousness personality have a positive association with depth first programming style i.e.
developers implement a specific functionality to completion before considering others .
our work is related to but different from the above studies we investigate developers perceptions on coding proficiency particularly the importance of various hard skills .
iii.
r esearch methodology our study consisted of open ended interviews and a validation survey.
in the open ended interviews we interviewed developers to get their insights into coding proficiency skills that a software engineer should have.
at the end of the interviews we finalized a collection of skills that can contribute to one s coding proficiency.
in the survey we evaluated the importance of the skills by surveying software practitioners from various background by means of an online survey.
each respondent spent minutes to rate the importance of the skills and provided rationales that support the ratings.a.
open ended interviews protocol the first author conducted face to face interviews with software practitioners each interview was completed within an hour.
the interviews were semi structured and divided into three parts.
part we asked some demographic questions such as the experience the interviewee has on software development testing project management and also asked interviewees to describe the projects they have done.
part we asked open ended questions to understand coding skills.
the questions include are you satisfied with your coding proficiency?
how do you improve coding proficiency?
what skills would affect coding proficiency?
the purpose of this part was to allow the interviewees to speak freely about coding proficiency without any bias.
part we prepared candidate topics by carefully reading the table of contents of representative coding textbooks e.g.
skimming the contexts of those textbooks and referring to high rated posts on popular q a websites e.g.
.
the candidate coding proficiency skills span topics i.e.
bug fixing program comprehension programming language implementation testing tool usage and others.
we picked a list of topics that have not been explicitly mentioned in the open discussion and asked the interviewees to further discuss those topics.
at the end of each interview we thanked the interviewee and briefly informed him her what we plan to do with his her responses.
participant selection we selected full time employees from three it companies in china namely insigma global service igs hengtian and a financial company for confidentiality reason we can only refer to as ss .
igs and hengtian are two outsourcing companies which have more than and employees respectively.
ss mainly builds it solutions to support the financial service of commercial banks.
the selection criteria are as follows we contacted the hr departments of these three companies to get a list of employees.
we then removed the employees who are interns working at a client s company2 adminstration management or not available due to other reasons e.g.
on vacation or on leave .
in the end we have and candidates left from hengtian igs and ss respectively.
to reduce the potential interference to one s work the hr departments suggested inviting of the candidates to join our interviews.
we randomly selected and employees from hengtian igs and ss and invite them to join our interviews through emails.
out of the emails received automatic replies notifying us of the absence of the receiver declined our invitation did not reply to our email accepted our invitation.
out of these developers canceled their appointments before the interview.
2since igs and hengtian are outsourcing companies some of their employees need to work onsite.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i skills that contribute to coding proficiency followed by the average likert scores from the survey responses very unimportant unimportant neutral important very important .
c1.
general coding skills s1 write code efficiently i.e.
clear coding task in a short amount of time .
s2 write efficient code e.g.
the code can run very fast use less memory .
s3 write well documented code .
s4 write parallel programs that leverage multiple threads and processes .
s5 write code that embeds well with code written by others e.g.
write code for a large project team which has many developers and require much collaboration4.
c2.
programming language and infrastructure s6 master multiple program languages .
s7 master legacy programming languages e.g.
cobol .
s8 master popular programming languages e.g.
java .
s9 master big data infrastructure e.g.
hadoop elastic search .
c3.
refactoring and reuse s10 recognize and extract reusable code from a larger code base .
s11 package document and distribute a software library for others to reuse .
s12 able to reuse code created internally rather than reinventing the wheel .
s13 reuse suitable third party libraries rather than reinventing the wheel .
s14 refactor code by identifying and eliminating code and architecture smells .
c4.
requirement engineering s15 extract an abstraction or a model from a requirement e.g.
in uml format .
s16 implement a functionality correctly according to the requirement .
s17 recognize mismatches between requirement and implementation .
c5.
software design s18 break down a complex coding task into smaller tasks that can be implemented separately4.
s19 implement functionality following a modular design .
s20 implement functionality following suitable design patterns e.g.
singleton factory .
s21 implement functionality avoiding design anti patterns e.g.
god class brain class feature envy .
c6.
understanding and learning s22 understand existing code in a short period of time .
s23 understand trade offs between different system architectures .
s24 read and understand most books articles related to the programming languages the developer mastered3.
s25 acquire new domain specific knowledge or learn new programming languages fast4.
s26 learn the usage of new tools fast .
c7.
interacting with environments s27 work with multiple ides such as eclipse and visual studio .
s28 work with multiple oses such as linux windows .
s29 modify the programming environment to tailor it to the developers personal styles3.
s30 work with a version control system e.g.
svn git .
s31 work with a bug tracking system e.g.
jira bugzilla .
s32 work with a code review system e.g.
gerrit .
c8.
bug prevention and fixing s33 locate and fix bugs fast and accurately .
s34 write good unit test cases to detect potential bugs .
s35 write good integration test cases to detect potential bugs .
s36 write good system test cases to detect potential bugs .
c9.
estimation s37 estimate well the effort needed to implement a new functionality .
s38 estimate the space and time cost of executing a piece of code .
our interviewees have varied job roles and experience.
the interviewees participated in various projects located in the united states canada japan ireland and germany.
table iii presents the detailed information of the interviewees see appendix a3 .
in the remainder of the paper we denote these interviewees as p1 to p15.
data analysis we processed the recorded interviews by following the steps below transcribing and coding we used a transcription service provided by a third party company to transcribe recordings to transcripts.
we then read the transcripts and coded the tran3 during the coding process we dropped the sentences which are not related to coding proficiency or belong to soft skills4.
finally we generated a total of cards for the coded sentences to cards for each interview.
open card sorting we performed open card sorting to categorize generated cards for thematic similarity.
iteration we randomly chose of the cards and discussed the themes in these cards.
the themes that emerged during the sorting were not chosen beforehand.
the resulting initial classification scheme contains coding proficiency skills as shown in table i except s7 s24 s27 and s28 .
iteration two authors independently categorized the remaining cards into the initial classification scheme.
they left cards that cannot be categorized to be discussed later.
after discussing the themes in the left cards more coding proficiency skills emerged i.e.
s7 s24 s27 and s28 in table i. two authors then separately categorized the left cards.
we use cohen s kappa to measure the agreement between the two labelers.
the overall kappa value was .
which indicates strong agreement between the labelers.
after completing the labeling process the two labelers discussed their disagreements to reach a common decision.
finally we get coding proficiency skills grouped into categories as shown in table i. b. survey protocol we designed a survey to rate the skills based on the perceived importance.
to support respondents from china we translated our survey to chinese before publishing the survey.
our survey consists of three parts part demographic we asked demographic questions to understand the respondents background e.g.
their number of years of professional experience .
part ratings of skills we then presented the skills and ask our respondents to rate each of them with one of the following ratings very important important neutral unimportant very unimportant .
a respondent can also specify that he she prefers not answer or don t understand a particular skill.
we included this option to reduce the possibility of respondents to provide arbitrary answers.
part rationales for each respondent we randomly sampled two skills that he she has rated as important very important and another two skills that he she has rated as unimportant very unimportant and asked the rationales of their ratings5.
respondent selection we aim to get a sufficient number of software practitioners from diverse backgrounds.
we followed a multi pronged strategy to recruit respondents 4during our interview our interviewees also mentioned soft skills.
however since our focus is on hard skills we discarded them during the card sorting process.
we define a skill as soft skill if it is related to personal characteristics decision making teammates or software product as defined in li et al.
s study and not related to coding proficiency.
5note that we use surveygizmo functionality to randomly sample skills based on those marked as very important or very unimportant.
due to surveygizmo limitation it is not possible to include complicated logic.
still since the process is random if two skills have equal likelihood of being selected as very important or very unimportant they should have equal chance to be selected for respondents to provide their rationales.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
we contacted professionals from various countries and it companies and asked their help to disseminate our survey to some of their colleagues and friends.
we sent emails to our contacts in microsoft google linkedin box.com infosys tata consultancy services hengtian igs and other small to large companies from various countries to fill up the survey and disseminate it.
by following this strategy we hope to recruit respondents of professional developers in the industry from diverse organizations and backgrounds.
we tended to recruit active practitioners in open source projects in addition to professionals working in industry.
we used github rest apis to mine the commit logs of projects hosted on github and identified contributors with more than commits.
in total we identified email addresses and sent invitations to these addresses.
out of these emails were not delivered received automatic replies notifying us of the receiver s absence.
in the email we emphasized that the respondents should have experience coding but the role can vary i.e.
we welcomed all software practitioners including developers tester and project managers.
we received a total of responses from countries across five continents.
the top two countries where the respondents reside are china and the united states.
the professional experience of our respondents varies from .
years to years with an average of .
years.
for the open source practitioners we sent emails and got response return rate .
for the industrial professionals it is hard to estimate return rate.
this is because we personally invited our industry contacts to participate and distribute survey to some colleagues.
we cannot know the exact number of colleagues to whom they distribute the survey.
data analysis we collate the ratings that our respondents provide.
we drop i don t understand and i prefer not to answer ratings that form a small minority of all ratings.
next we convert these ratings to likert scores from very unimportant to very important .
next we compute the average likert score of each skill.
furthermore we extract comments that our survey respondents give to explain the reason why they think a particular skill is important very important or unimportant very unimportant.
iv .
r esults in this section we describe how software practitioners rated the coding proficiency skills grouped into nine categories along with the rationales that our respondents provided to support their ratings.
we consider three research questions rq1 how do practitioners perceive the derived coding proficiency skills?
rq2 what are the highly ranked coding proficiency skills as practitioners deem important?
rq3 what are the practitioners rationales for perceiving a particular coding proficiency skill important or unimportant?
all os prof explow expmed exphigh dev test pm fig.
survey respondents demographics.
the number indicates the count of each demographic group.
a. rq1 importance of the skills table i presents the average likert score of the skills from all respondents in the third column.
we observe that out of the skills have an average likert score above .
indicating that the skills are perceived as important and very important by our respondents.
we further investigate the ratings of various demographic groups as below main job role respondents who are developers dev testers test or project managers pm .
experience level respondents with low experience explow i e. we define as the with the least experience in years with medium experience expmed or with most experience exphigh i..e we define as the with the most experience in years.
education level respondents with without advanced degrees adv nonadv .
open source developers vs. professionals respondents who are open source developers os or professionals prof .
the grouping of respondents on experience follows prior work e.g.
carver et al.
and lo et al.
.
same demographic categories are also used by previous studies .
we notice that pms might work as developers before tester might require coding skills as well.
in our survey we emphasize that our respondents should have coding experience.
figure presents the distributions of respondents across different demographic groups majority of the respondents are developers and of the respondents are testers and pms respectively.
more developers and less pms come from open source projects as compared to the respondents from commercial projects e.g.
pms are from commercial projects while only pms are from open source software project.
as respondent s experience increases the percentage of testers decreases while the percentage of pms increases.
figure shows the importance ratings of the coding proficiency skills across various demographic groups.
we observe that all demographics give more v ery important and important ratings as compared to unimportant or v ery unimportant .
only a minority gave unimportant and v ery unimportant ratings less than across all demographic groups.
more than respondents across all demographic groups rated the coding proficiency skills authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
importance of the coding proficiency skills to respondents of various demographic categories.
as v ery important or important and around across all demographic groups rated the coding proficiency skills as v ery important .
in addition we observe a few differences between various demographic groups the differences are significant by using fisher s exact test with bonferroni correction at a confidence level testers consider coding proficiency skills more important than developers and project managers.
low experience practitioners consider these coding proficiency skills more important than practitioners with medium and high experience.
professional developers perceive coding proficiency skills more important than open source developers.
respondents with advanced degrees consider coding proficiency skills more important than their counterparts without advanced degrees.
b. rq2 highly ranked skills to further analyze the results we applied scott knott effect size difference esd test to group the skills into statistically distinct ranks according to their likert scores.
note that we excluded responses that select i don t know for our scott knott dsd test.
as shown in tantithamthavorn et al.
s study the scott knott test assumed that the data is normally distributed which might create groups that are trivially different from one another.
to address the limitations of scott knott test tantithamthavorn et al.
proposed the scott knott effect size difference esd test to correct the non normal distribution of an input dataset and leverage a hierarchical clustering to partition the set of treatment means in our case means of likert scores into statistically distinct groups with non negligible effect sizes.
table ii presents the skills as ranked according to the scott knott esd test in terms of means of likert scores for all the respondents.
in addition we identify and discuss high rated coding proficiency skills across the various demographic categories i.e.
different job roles and experience levels in appendix b .
c. rq3 rationales in the remainder of the paper we use enc 33or enc 37to denote the rationale why respondents perceive a skill as important or unimportant.
we carefully read all the comments from the respondents and removed comments which do not describetable ii skills as ranked according to the scott knott esd test all respondents .
group skill s18 break down a complex coding task into smaller tasks s30 work with a version control system s19 implement functionality following a modular design s5 write code that embeds well with code written by others s33 locate and fix bugs fast and accurately s17 recognize mismatches between requirement and implementation s16 implement a functionality correctly according to the requirement s14 refactor code by identifying and eliminating code and architecture smells s13 reuse suitable third party libraries s12 reuse code created internally s34 write good unit test cases to detect potential bugs s10 recognize and extract reusable code from a larger code base s11 package document and distribute a software library s22 s26 s3 s23 s35 s25 s1 s36 s38 s24 s31 s37 s21 s20 s32 s29 s6 s4 s15 s8 s28 s9 master big data infrastructure s27 work with multiple ides s7 master legacy programming languages any rationale.
for each skill the first two authors manually extracted key phrases from the comments and grouped comments based on the key phrases.
take two comments in s7 for example not widely used anymore in many large projects and the majority of programming jobs won t involve these at all both express that legacy programming languages are not widely used.
thus we put them into one group.
note that some comments may belong to multiple groups because they listed more than one reasons.
we broke these comments down and put into multiple groups.
we present the comments on the most highly ranked skills group in table ii and that on the most lowly ranked skills group in table ii .
additionally we list comments for selected skills whose importance is controversial in nature i.e.
receiving close number of positive and negative comments .
for the complete list of the comments on skills please refer to appendix c .
most highly ranked skills group in table ii break down a complex coding task into smaller tasks s18 .
respondents consider s18 as important since it helps developers to solve complex problems allows developers to create reusable and maintainable code supports effective distribution of tasks among team members and makes quality assurance checks e.g.
creation of unit tests code review etc.
easier.
enc the more complex problem is it is harder to implement breaking it into smaller tasks helps others focus on the implementation.
enc because if you don t you will end up with an unmaintainable mess.
enc this is necessary for unit testing as well as dividing work among a team .
work with a version control system s30 .
respondents consider s30 as important since version control systems support team work facilitate reusability by tracking reusable versions of a program and allow developers to revert to older versions when latest versions are problematic.
enc this is fundamental to the ability of people to work in a team writing code together .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
enc different versions of projects might correspond to different requirements from different clients which improves the reusability .
enc if problems appear in a new version version control system can trace back to a right older version.
implement functionality following a modular design s19 .
respondents explained that modular design helps create understandable reusable and maintainable code and supports collaboration among developers.
enc keeping things separated as much as possible helps improve readability of the code ... enc modular design contributes to the collaboration between developers and it is easier to share work in big teams.
write code that embeds well with others code in a large project team s5 .
respondents describe wellembedded code as an important skill most software projects are challenging enough to require team work software maintenance requires one to build upon existing code often written by others and novice developers have little experience working in a large project.
enc ... without being able to work with other a lot of time will be lost to finish a project.
enc if i m going to hire someone they need to know how to do maintenance programming and their code should work with the team s code.
enc it is important to all developers especially for junior developers since they are lack of experience on working in a large project team.
note that low experience respondents list this skill as the most important skill.
locate and fix bugs fast and accurately s33 .
due to the complexity of software systems bugs are inevitable and bug localization and fixing are two of the most important activities during software development and maintenance .
respondents noted that software quality is crucial and others may depend on a piece of code a developer is fixing enc it doesn t matter how quickly your code runs if it does the wrong thing .
enc ... all new code that you write will slow down your entire team as others will have to find and fix your bugs for you.
recognize mismatches between requirement and implementation s17 .
respondents state that developing the right thing considering various subtleties of a requirement is challenging and yet crucial and detecting mismatches early prevents wastage of time and resources enc someone who does not understand the subtleties of a requirement and is satisfied with an approximate implementation is a burden .
on the other hand someone who can consistently understand requirements precisely and provide matching implementations can be an amazing asset to a team .
enc because if there is a mismatch the contract is void and the implementation needs to be completed correctly.
it was a waste of time and effort.
implement a functionality correctly according to requirement s16 .
respondents consider s16 as important since it is one of the most important metric to evaluate project success enc that is why we are implementing the software and will make the product successful .
at the end of the day it is the ultimate goal of the profession .
in contrast some argue that ability to collect valid requirement is even more important enc actually it is more important to first confirm that the requirement is valid and useful .
we notice high experience respondents rank s16 in group .refactor code by identifying and eliminating code and architecture smells s14 .
code refactoring is one of the hot topics in software engineering .
the purpose of code refactoring is to eliminate code and architecture smells from systems to make them robust for future change and decrease maintenance cost.
respondents explain that smells are common and often introduced due to tight software schedule it allows developers to improve software design and it allows developers to payoff technical debts and create maintainable code enc more often than not people say they re it quick as prototype but don t even see half the problems they ve introduced.
enc you need to be able to understand the deficiencies in designs in real life you don t want to hit a screw with a hammer why would you do it in code?
enc beginner programmers can write tons of bad code quickly.
they need to learn how to pay down technical debt otherwise it can kill a projects long term momentum.
most lowly ranked skills grou p7 9i nt able ii master legacy programming languages s7 .
all respondents consider s7 as unimportant.
the rationales include majority of programming jobs do not require the mastery of legacy programming languages many new technologies are introduced and time and effort are needed to acquire competencies of those new technologies and learning legacy languages may not help in improving one s skill in newer technologies enc it s rare that that comes up in my work.
it s a niche case that where it matters is important but not part of most developers careers.
enc it would be waste of time to learn antiquated langu age it s better to spend time learning something new .
enc mastering a dead language might be fun but it probably won t contribute to your success as much as mastering a current language.
work with multiple ides s27 .
detractors point at that good developers do not need multiple ides and can work even with simple text editors ides may be in the way when coding in multiple programming languages and learning a new ide may require substantial time investment.
enc all best coders i ve seen and i believe it s a rule in general are perfectly fine with simple text editor e.g.
notepad.
enc ides are just helpers and good tools for uni language programmers.
for polyglots programmer it is often something in the way .
generally using emacs or vim is preferred.
enc any ide will work and stick with one would be better because learning ide can also take time.
proponents argue on the value of using the best ide for a job enc when working with different projects or languages the preferred ide can be different .
note that low experience respondents perceive this skill as the second most unimportant coding proficiency skill.
master big data infrastructure s9 .
respondents consider explain that there are not many big data projects and most of important development tasks are not big data things and understanding the principle of how to run code efficiently is more important enc this is context specific .
so in some jobs this might be important but it s not essential to being a good software developer at all.
.
enc it s important to have an understanding ofthe cost of running your code and how it scales .
but it s not perse necessary to have knowledge of big data infrastructures that s a quite specific a niche.
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
selected controversial skills group in table ii complete coding task in short time s1 .
respondents consider s1 as important since it is a basic skill to acquire project schedule is tight it allows developers to have more time to test code and it allows one to learn more things by completing more projects enc the project schedule is always tight we have to clear a coding task in a short amount of time.
enc having more time to test the code to reduce the bugs.
enc writing faster means you can do more experiments which means you ll learn faster.
nonetheless some respondents believe that emphasis should be put on producing good design and writing good code.
this may require more upfront investment in time but benefit in the long run.
hastily written code may have many bugs.
other respondents work on the projects with flexible schedule enc we should spend some time on designing before we write the code.
enc my open source projects are developed on free time s oi ti sn o t important how much it takes.
write well documented code s3 .
respondents consider well documented code important because it promotes reuse promotes inclusion of newcomers helps in program evolution tasks.
enc without documentation the code has no value and can not be reused by others.
enc well documented code is essential for project maintenance inclusion of newcomers and the projects with high turnover rate.
enc the code written needs to be understandable for other team members to be able to modify or adapt later down the timeline or in cases where the developer is no longer active on the project.
however not everyone regards s3 as an important skill because they believe developers should write simple selfexplaining and clearly structured code.
enc documentation doesn t matter much as long as it the code is clearly structured and the developers are able to talk about it.
master multiple programming languages s6 .
proponents note that multiple languages expand the view of problems and help collaborate with developers across a broad range of projects new programming languages are introduced over time and different programming languages have their own strengths and weaknesses.
enc this helps a developer look at a problem from different perspectives and understand other developer perspectives enc the technology is changing and what used to be cobol c c is moving to golang rust node javascript ... enc different languages have their own strengths and weaknesses as well as problem domains they are good at.
on the other hand others consider it as unimportant because programming languages are similar and deep mastery of one language may matter more to get a job.
enc much programming knowledge is general .
for example if you are proficient with java you should be able to apply these skills to c as it is a very similar language.
enc the opposite is really true these days mastery of one language and one popular framework within a language is the best way to get a job and it s where the most effective programmers tend to be.
interestingly many practitioners hold negative opinions on mastery of multiple languages while the balance tilts towards viewing s6 as important.
master popular programming languages s8 .
supporters argue that popular languages can serve as lingua franca thatconnects practitioners and one needs to master these to remain relevant in the job market.
enc it s always good when talking about something specific to go back to something more general something everyone knows .
.
enc if you don t your work will not be relevant .
others hold an opposite view arguing that popular languages may not be best languages for various problems.
one should be able to pick an appropriate language given a specific problem rather than being swayed to popular languages.
enc popular languages are not necessarily good languages .
what languages one should use depends on situation .
popularity has little to do with the usefulness.
enc ... you need have the correct language for the current problem no the popular one.
languages are just tools to express your idea .
extract an abstraction or a model from a requirement e.g.
uml s15 .
supporters state that uml separates developers from coders helps in planning and ensuring that the end product matches requirements works as a communication tool among developers and helps newcomers to get started.
enc because this ability separates developers from coders ... enc if we don t have a model when we write code for some period e.g.
two months we may forget what the original purposes of the code.
enc uml can be used as a tool for communication purpose and help newcomers to understand the project .
ho quang et al.
also found that collaboration and communication is the most important motivation to use uml and the use of uml can help new contributors to get started but there is no evidence that the use of uml can help to attract new contributors .
however a substantial population of our respondents hold an opposite opinion they do not find uml useful many experts do not use uml open source developers do not prefer to be constrained by model and software requirements change often.
enc i ve not found uml diagrams to be useful for anything but filler in giant specification documents.
enc i ve never known anyone who i have respected that uses uml format .
for example donald knuth ken thompson unix go ... these are highprofile names but just about anyone i ve worked with has never used uml.
enc opensource developers usually do what they like or love to do.
they love imaging and creating.
there is no point in telling them what to code so precisely ... enc requirements change all the time and only as soon as you implement it you see all consequences and come across unexpected side effects.
it s better not to overthink requirements.
implement functionality following design patterns s20 .
proponents argue that design patterns give the code additional structure to make it easy to understand and communicate and help the improve the ability to apply abstract design ideas to concrete code implementations.
enc design patterns give the code additional structure that makes it easier to understand and to communicate.
enc relying on these patterns indicates a depth of knowledge and ability to apply abstract design ideas to concrete code implementations.
in contrast detractors state that writing understandable code does not necessarily need design patterns they mostly apply to oo object oriented languages which have conflict with other good coding practices being overly pattern driven leads to overly abstract solutions design patterns are often improperly used and become to anti patterns and design patterns make code hard to understand and maintain.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
enc code should be obvious .
design patterns are a tool which can help not an end.
enc patterns tend to be routed in certain paradigms say oo.
they also tend tofall out of other good coding practices .
enc being overly pattern driven trends to lead to overly abstract solutions ... enc for the most part design patterns are now followed slavishly and became anti patterns .
i don t want to have abstractfactoryfactorygenerator classes in my codebase.
enc sometime the code optimized by using design patterns are hard to understand and maintain ... implement functionality avoiding design anti patterns s21 .
proponents argue that avoiding anti patterns helps avoid common mistakes makes code easy to understand and helps avoid overcomplicate solutions.
enc shows proficiency with different kinds of problems and understanding of what mistakes are common .
to avoid running into design problems later on when working on a bigger project.
enc ... bad patterns lead to unmaintainable code hard to find and hardto fix bugs and make it difficult to scale a developer team to work on multiple parts of the codebase.
enc design patterns do not solve everything and people tend to overcomplicate solutions with them when there are simpler solutions that don t necessarily have a name.
on the other hand detractors are more pragmatic and opine.
they argue that what matters more is getting work done rather than actively caring for anti patterns.
enc i think that the goal of code is to get work done not to be perfect .
avoiding an anti pattern makes sense but sometimes it s ok to do those things to get the job done.
understand existing code in a short period of time s22 .
proponents mention that understanding code is needed by developers when interacting with existing systems is important for code review allows developers to identify reuse opportunities and help get up to speed quickly when joining a new team or helping out in a new task.
enc more often than not developers will be faced with interacting with existing systems .
enc in open source we review peers code a lot ... this provides another developers philosophy of their design.
enc if they take too much time to understand the code either they may take far too much time to write their own and be quickly discouraged or they may miss useful piece of code that could save them a lot of time.
enc for newcomers if they can understand the code quickly they will join the development orbug fix task fast .
detractors state that good things take time and rushing through things may not result in good comprehension.
enc most projects are complicated and take a long time to get to know intimately.
being able to understand patterns in projects and eventually fully comprehend them is more important than picking them up in a short period of time.
good things take time.
write good unit test cases to detect potential bugs s34 .
proponents argue that unit tests can serve as good documentation and communicate intent and prevent regression bugs.
enc using code to validate code tends to help with communicating intent and maintaining that documentation over time .
enc because tests are critical to prevent regression bugs .
detractors view unit tests require much time to create and maintain with little return and some view other forms of testing to be more important.
enc usually unit tests take lots of time with no or small return .
they require lots of maintenance and usually influence on module design.
enc unit tests ... fail to detect structural inter unit misdesigns and give a false sense of security.
write good integration test cases to detect potential bugs s35 .
proponents argue that integration tests are valuable to ensure that code changes do not introduce adverse impact with high degree of confidence and help simulate what a user may do and detect problems early.
enc excellent integration tests are the proof of writing code for the right purpose and also enable very fast refactorings with high degrees of confidence.
enc the ability to write the integration test cases is more a capability to spot potential issues by imagining what a user would do ... a minority of respondents hold a negative opinion since integration tests may not be suitable for some software projects.
enc most of the software i write is not well suited to typical testing methods .
integration tests are as far as i go and even that only occasionally.
estimate well the effort needed to implement a new functionality s37 .
supporters state that estimation helps in planning a software engineer can also attract others to join his her effort if estimation works well good understanding of a problem is an essential first step towards creating a good solution and estimation helps determine project feasibility.
enc so you can plan better .
if estimate well a software engineer can also attract others to join his her effort especially in open source development setting enc it s important to understand a problem before attempting to implement it but prototype development can be an important part of the learning process.
enc because it allows you to make accurate guesses estimations on the feasibility and chance for a successful implementation of requested new features .
detractors note that estimation are often inaccurate many software engineers do not care about estimates.
enc estimates are unlikely to bear much relationship to reality .
try it and see.
v. d iscussion a. implications for researchers skill measurement impact analysis and automated tutoring our work highlights the skills that are perceived important by our respondents.
as a next step future research could develop measurements to operationalize these skills.
such measurements can be defined based on artifacts that a software engineer has created github profile cv and a set of tests or questionnaires.
one can then investigate how accurate such measurements are against for example peer assessments or self declarations.
such measurements can also help managers assess software engineers educators assess students software engineers and students assess themselves and make improvements .
it would also be highly interesting to investigate the impact of varying different skills to the project outcomes or project teams.
furthermore it would be worthwhile to develop automated tutoring tools to help software engineers improve their coding proficiency skills.
uml .
looking at ratings and comments that we receive for s15 we note a substantial push back on modelling among our respondents.
numerous respondents find uml diagrams which often require much time to create to be not useful authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
for their work especially due to the high rate of requirement changes.
many prefer writing code than drawing uml diagrams.
this poses a challenge as well as an opportunity for researchers to create a new modelling technique that is easy to use by practitioners can deal with the high rate of requirement changes and can be nicely linked with source code that developers write.
our findings are consistent with petre s .
petre investigated developers from companies and of them did not use uml at all.
moreover ho quang et al.
found that collaboration and communication is the most important motivation to use uml thus would be interesting to investigate how to build even more effective models that can be adopted more widely to communicate various pieces of information.
design patterns validation new patterns and recommendation systems similar to modelling a substantial number of our respondents push back on design patterns.
detractors argue that design patterns mostly apply for oo which can be improperly or overly used.
this leads to very abstract solutions impairing understanding may conflict with other good practices and many good patterns are not listed as design patterns.
this may give opportunities to researchers to validate claims made by developers through a controlled experiment or field study or by looking into historical data stored in software repositories e.g.
by correlating design pattern use and number of bugs etc.
create or curate additional design patterns that apply to many different languages beyond oo languages by interviewing practitioners for best practices or by mining software repositories design tools that can give advice on design pattern misuse and recommend suitable actions to make applying design patterns a net benefit.
our findings are consistent with prior studies .
jaafar et al.
investigated the relationship between design patterns and faults by performing an empirical study on six design patterns and anti patterns in argouml jfreechart and xercesj and they found classes which have dependencies with antipatterns are more fault prone than others .
wendorff et al.
investigated the misuse of design pattern in a large industrial project and he found that developers misuse design patterns since they do not understand the rationale behind the patterns or the implementation does not match the project requirement.
scanniello et al.
setup four controlled experiments with participants to investigate the relationship between design patterns and program comprehension and they found that documenting design pattern instances can help to improve the efficiency of source code understanding for respondents with adequate level of experience .
for educators twenty one skills are rated as important or above by the majority of our survey respondents.
we make the following recommendations based on high rated skills and our respondent comments general coding skills educators should emphasize on abilities to code efficiently write efficient code document well and embed one s code well to other s code.
document well is often less emphasized in standard computer science curriculum but it is highly valued by practitioners.
also note that ascompared to the above skills advanced topics like parallel programming receive less support from our respondents.
programming language and infrastructure educators should put less emphasis on specific programming languages but more on programming paradigms.
refactoring and reuse the skills under this category are highly valued by our respondents.
thus educators should emphasize more on these skills e.g.
recognizing and extracting reusable code from a larger code base and refactoring code by identifying and eliminating code and architecture smells.
often these skills are neglected in many standard cs courses which focus on ability to write code from scratch.
requirement engineering and software design educators should teach more problem solving skills e.g.
divide and conquer basic design skills e.g.
modular design and provide project based courses to help students decompose and solve complex problems write well modularized program and train students to implement requirements correctly and detect mismatches.
these skills are highly valued by practitioners.
note that basic design skills e.g.
modular design are more valued by our respondents than skills that are often viewed as more advanced e.g.
uml modeling and design patterns .
understanding and learning educators should put more emphasis on program comprehension skills and ability to appreciate trade offs.
the earlier is often lacking in many basic cs courses as students are often not exposed to read and understand large amount of code.
educators can also introduce more domain concepts which go beyond traditional cs.
for example they can encourage students to take classes on specialized domains e.g.
accountancy and finance .
moreover educators should train students on acquiring new skills and tools fast i.e.
the ability of learning to learn.
these skills are highly valued by practitioners.
interacting with environments educators should at least introduce version control systems which receive a much higher rating than other development tools.
bug prevention and fixing educators should put emphasis on debugging and testing skills as they are highly valued by practitioners.
for practitioners many practitioners are often not clear on how to improve their coding proficiency .
our findings conclude a number of skills that our respondents aspire to achieve.
the average ratings of all skills except one are above .
all except five are above .
and skills are above .
.
we also provide rationales on why each skill is perceived as important or not.
for many skills our respondents have different opinions and we highlight all sides of the argument to help practitioners decide upon which set of skills to improve based on their circumstances.
besides our findings may help practitioners better present themselves to prospective employers.
for the skills that experienced practitioners value practitioners can demonstrate to prospective employers that they have or can develop these skills.
on the other side of the coin managers and recruiters could identify suitable candidates by checking their proficien932 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
cy on the listed skills especially those that are marked as important or very important by many practitioners.
b. threats to v alidity construct v alidity.
our interviewees come from three companies.
projects done in these companies cover a wide range of domains.
developers working there have also worked in other companies.
however they may not be representative of all developers.
to mitigate this potential bias we have carefully chosen questions and topics for the interviews and performed a survey that involve a large population of developers from various companies around the world.
our survey respondents complete the survey based on their belief and perception.
it is possible that they conflate the skills that are very important and the skills that are very relevant to their projects or industrial contexts.
to mitigate this threat we have tried to survey many people a total of practitioners from various companies in countries across continents participated.
internal v alidity.
it is possible that some of our survey respondents do not understand some of the skills well.
to reduce this threat to validity we provide i don t understand i prefer not to answer option in our survey and we find that the number of respondents who choose this option to be small .
.
we also translate our survey to chinese to ensure that respondents from china can understand our survey well.
it is also possible that we draw wrong conclusions about respondents perceptions from their comments.
to minimize this threat we read transcripts many times and checked the survey results and the corresponding comments several times.
the selection of skills produced at the end of the interview may not be comprehensive and may be biased to the background of experts who may not be able to articulate their own skills focus more on skills that involve public demonstrations and who may praise skills that have no actual benefit to performance whom we interviewed.
to mitigate this bias we have taken the following steps aside from asking direct questions of what skills they deem important we also ask them to discuss topics that they have not explicitly mentioned.
the topics were selected from software engineering text books online resources they include bug fixing program comprehension programming language implementation testing tool usage and others.
we have performed a survey to check whether the interviewees opinion is perceived to be correct by many practitioners.
external v alidity.
to improve the generalizability of our findings we have interviewed respondents from companies and surveyed respondents from countries across continents working for various companies including microsoft google linkedin box.com infosys tata consultancy services hengtian igs and other various small to large companies or contributing to open source projects hosted on github.
still our findings may not generalize to represent the perception of all software engineers.
for example most of the respondents are from asia north america and europe and there are only two respondents from south america and noneof the respondents are from africa.
moreover considering most of the users on github are male our findings might not be generalized to female developers.
in the future it would be interesting to perform another study to investigate how female developers perceive coding proficiency.
moreover each respondent rates each skill thus each skill receives responses.
this is substantial considering prior studies include similar number of respondents i.e.
and respondents to rate many statements i.e.
and statements .
another threat related to the completeness of our coding proficiency skills.
in this paper we finalized these skills based on the open ended interviews of interviewees.
also in the end of our survey we also asked the respondents to provide the additional coding proficiency skills.
among the responses respondents provided comments for additional skills.
we also manually analyze these additional skills and removed comments which are related to soft skills e.g.
good working behavior effective communication and the key is good communication and social skills general skills for all engineers e.g.
understanding of grammar and math or noises e.g.
n a yes or no .
next we applied closed card sorting to categorize the remaining comments i.e.
we tried to categorize them into the skills and we left the comments which belong to none of these skills.
we notice most of the comments provided supplementary explanation to our skills e.g.
ability to pick the right level of abstraction is an explanation for s15 extract an abstraction or a model from a requirement rapid prototyping is an explanation for s1 write code efficiently .
moreover we only found two additional skills that are not covered by our survey i.e.
write awesome sql and use of agile methodologies like scrum kanban or gtd .
this threat could be removed by including these two skills and inviting more respondents.
vi.
c onclusion and future work in this work we survey practitioners from diverse backgrounds on their perceptions of coding proficiency.
we derive a total of skills which are grouped into categories from our interviews and ask survey respondents to rate the importance of these skills and provide the rationales of the ratings.
we find that all but of the skills receive an average rating of more than .
neutral all but receive an average rating of more than .
between neutral and important and receive an average rating of .
and above important and very important .
our findings can help practitioners by highlighting important skills to acquire and educators by recommending important skills to include in the curriculum.
the findings also highlight opportunities that software engineering researchers can work on to better help practitioners in their tasks.
future work could work on some of these opportunities and expand our study to address some of the threats to validity.
acknowledgement this research was partially supported by the national key research and development program of china 2018yfb1003904 and nsfc program no.
.
replication package authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.