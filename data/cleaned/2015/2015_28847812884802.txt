improving refactoring speed by 10x jongwook kim don batory university of texas at austin fjongwook batoryg cs.utexas.edudanny dig oregon state university digd eecs.oregonstate.edumaider azanza university of the basque country upv ehu maider.azanza ehu.eus abstract refactoring engines are standard tools in today s integrated development environments ides .
they allow programmers to perform one refactoring at a time but programmers need more.
most design patterns in the gang of four text can be written as a refactoring script a programmatic sequence of refactorings.
in this paper we present r3 a new java refactoring engine that supports refactoring scripts.
it builds a main memory non persistent database to encode java entity declarations e.g.
packages classes methods their containment relationships and language features such as inheritance and modi ers.
unlike classical refactoring engines that modify abstract syntax trees asts r3refactorings modify only the database refactored code is produced only when pretty printing asts that reference database changes.
r3performs comparable precondition checks to those of the eclipse java development tools jdt butr3 s codebase is about half the size of the jdt refactoring engine and runs an order of magnitude faster.
further a user study shows that r3improved the success rate of retro tting design patterns by up to .
.
introduction refactoring is a core technology in software development.
all major ides today o er some form of refactoring support refactoring is central to popular software design movements such as agile and extreme programming .
in the last decade refactoring tools have revolutionized how software is developed.
they enable programmers to continuously explore the design space of large codebases while preserving existing behavior.
modern ides such as eclipse netbeans intellij idea and visual studio incorporate refactorings in their top menu and often compete on the basis of refactoring support.
despite vast interest and progress a key functionality that many have recognized to be missing in ides is scripting .
most design patterns in the gang of four text can be expressed as a refactoring script a programmatic permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c acm.
isbn .
.
.
.
of refactorings .
adding and removing design patterns manually is laborious repetitious error prone and often too di cult to do try creating a visitor with over 10methods the bene ts of scripting become clear.
we recently added scripting to eclipse jdt exposing the core declarations of a java program packages classes methods etc.
as objects whose methods are jdt refactorings.
refactoring scripts that add or remove design patterns are short java methods.
our tool called r2 is detailed in the next section.
experiments revealed jdt refactoring engine jdtre is ill suited for scripting for three reasons reliability.
jdtre is buggy .
we led new bugs to date but only a fraction has been xed in the latest version of eclipse.
prior to the current release one r2script executed 6jdt refactorings producing a program with 27compilation errors.
another script invoked 96refactorings producing a program with 100compilation errors.
these errors are notdue to r2 but are egregious bugs in jdtre.
we are constantly discovering more.
worse is waiting months or years for a repair .
we rediscovered a bug that took 5years to be xed .
note we are not in a position to repair jdtre.
there is no reason for us to believe our patches would be accepted.
we report bugs as others do.
expressivity.
we found the need for additional primitive refactorings and to repair existing refactorings.
jdtre refuses to move methods that include the super keyword moving methods with super reference s is really useful.
we also had to turn o parameter optimization for example to make jdt refactorings produce design patterns correctly .
speed.
jdtre s achilles heel is its speed it is surprisingly slow.
while a single jdt refactoring is fast executing many is not.
r2scripts that invoke 20refactorings take over 10seconds.
one script invoked 554refactorings and took 5minutes to execute.
programmers expect refactorings to be instantaneous.
we concluded that a radically di erent approach to build refactoring engines for scripting was needed to remove these problems.
our novel solution called r3 creates a database of program elements such as classes methods elds their containment relationships and java language features such as inheritance and modi ers.
precondition checks consult harvested values in database tuples refactorings alter the database.
asts are never changed refactored code is produced only when pretty printing asts that reference database changes.
this strategy yields a increase in refactoring speed and a smaller codebase.
ieee acm 38th ieee international conference on software engineering the contributions of this paper are a novel foundation r3 of database pretty printing for designing a new generation of refactoring engines that support scripting r3 s codebase is a mere 4k loc and does not use eclipse language toolkit ltk utilities e cient ways to evaluate refactoring preconditions boolean properties of asts are harvested during database creation where precondition checks consult their values and the database supports fast searches an empirical evaluation of r3on6case studies executed 52scripts.
r3runs at least faster on average in two cases faster than jdtre and a user study involving classes undergraduates and graduates showed r3improved the success rate of retro tting design patterns by up to .
.
a recap of r2 most classical design patterns can be expressed by a series of refactorings .
in we leveraged the jdtre to provide a practical way to write such scripts.
class graphic void draw ... class square extends graphic void draw ... class picture extends graphic void add graphic g ... void draw ... package square drawpicture draw addgraphic drawcompiler source abstract syntax tree ast ast methid name args clsid m1 draw m2 add c1 m3 draw m4 draw ast clsid name parent c1 graphic c2 square c1 c3 picture c1 traversalrclass rmethod r3databaseclass graphic void draw ... class square extends graphic void draw ... class picture extends graphic void add graphic g ... void draw ... figure a java program.r2is a java package.
its objects correspond to java entity declarations such as packages classes methods etc.
the program in figure has seven r2objects.
there are 3classes graphic square picture and methods three draws and oneadd.
methods of r2objects are jdt refactorings or database retrievals.
representative methods are listed in table .
r2type method name semantics rpackage newclassadd a new class to the package rclassaddsingletonapply singleton pattern to the class getallmethodsreturn a list of r2objects that are all methods of the class getpackagereturn the r2object of its own package newconstructorass a new constructor to the class newmethodadd a new method stub to the class newfield add a new eld to the class setinterface set to implement an interface rmethod getrelativesreturn a list of r2objects of methods with the same signature rrelativelistaddparameteradd a parameter with its default value to all methods moveanddelegatemove methods to a class leaving behind a delegate rename rename all methods table methods of r2.
r2refactoring scripts are short java methods.
here are two examples.
figure is an r2script that creates an adapter.
a programmer uses the eclipse gui to identify a java class cthat is to be adapted to java interface i. the programmer then invokes r2 smakeadapter refactoring just like a built in eclipse refactoring which in turn invokes i.makeadapter c n where nis the name of the adapter class to be created.
class nis created in the same pack age as interface i line to which is added a eld named adaptee of type cand a constructor to initialize adaptee lines .
a stub is generated for each method in interface i line .
the created class nimplements interface i line .
the r2object for nis returned as the result of makeadapter .
member of rinterface class rclass makeadapter rclass c string n rclass adapter this .
getpackage .
newclass n rfield f adapter .
newfield c adaptee adapter .
newconstructor f for rmethod m this .
getallmethods adapter .
newmethod m adapter .
setinterface this return adapter figure r2 makeadapter method.
figure is an r2script to create a visitor design pattern.
using the eclipse gui a programmer identi es a method called a seed in a class hierarchy that s he wants to create a visitor s he then invokes r2 smakevisitor refactoring from the eclipse gui.
so invokes seed makevisitor n where seed isr2object of the seed and nis the name of the visitor class to be created.
makevisitor gets the seed s package creates a visitor class vwith name nin that package and makes va singleton lines .
next all methods with the same signature as the seed are collected onto a list.
every method on the list is renamed to accept line and then a parameter of type vis added whose default value is the singleton eld of n line .
the index value that is returned is the index number of the visitor parameter.
only movable methods e.g.
abstract orinterface methods cannot be moved are relocated to class n leaving behind delegates respectively line .
all methods in the visitor class are renamed to visit .makevisitor returns v the r2 visitor class object.
member of rmethod class rclass makevisitor string n rpackage pkg this .
getpackage rclass v pkg .
newclass n rfield singleton v. addsingleton rrelativelist relatives this .
getrelatives relatives .
rename accept int index relatives .
addparameter singleton relatives .
moveanddelegate index v. getallmethods .
rename visit return v figure r2 makevisitor method.
these examples of loc are typical of r2scripts they are very short.
we implemented 18of the 23design patterns in the gang of four text using r2.
eight patterns including visitor are fully automatable as there are no programmer to do s. another ten are partially automatable.
this includes adapter where only stubs are generated.
some of the remaining patterns are automatable such as state and mediator 1while others fa cade and iterator are 1state is a typical mde application .
mediator is the essence of 1146so application speci c that little or nothing is reusable .
java is a practical scripting language writing r2scripts is like writing regular java code.
programmers do not need to learn a domain speci c language dsl for program transformations.
r2scripts invoke jdt refactorings and create new program elements.
although using java as a scripting language is great jdtre is not as mentioned in the introduction reliability and speed being the biggest detractors .
jdtre was never designed for scripting refactorings.
hence the motivation for r3.
.
r3 concepts .
modularity perspectives elementary physics inspired r3.
a physical object looks di erent depending upon an observer s location.
silhouette portraits of people are di erent from frontal portraits.
just as viewpoints of a physical object are created by rotations and translations called coordinate transformations that preserve object properties r3does the same for programs it refactors programs by pretty printing without changing the program s asts or behavior.
to see how we strip away object oriented oo notation.
a method implements an absolute function the reason for absolute is explained shortly where all method parameters are explicit as they would be in a c language declaration.
figure 4a is the signature of an absolute function foowith three parameters whose types are b c d. a foo c c d d a foo b b d d static a foo b b c c d d a foo b b c c d d a b c d if expr stmt a if expr then stmt if expr stmt b c expr stmtyes no d figure an absolute function and its relative methods.
iffoois displayed as a member of class b figure 4b is its signature the bparameter becomes this and is otherwise implicit.
if foois displayed as a member of class c figure 4c is its signature where the cparameter is this.
we say thenatural homes of an absolute function are its parameter types.
the natural homes for method fooare b c d. if foois displayed as a member of class e not a natural home it appears as the static method of figure 4d which has no implicit this parameter.
amodularity perspective assigns absolute functions to class declarations.
the idea generalizes to other entity declarations e.g.
packages classes elds and their containment relationships.
to illustrate nested classes generalize absolute functions in an interesting way.
figure 5a shows class bnested inside class a. method mof class bhas the absolute function void m a a b b a.i a.i b.j although m displays without parameters inside b it really has two implicit parameters this of type b and a this of outer type a .
we see that m can be displayed as a member of class ausing our modularity perspective techniques by making the bparameter explicit.
see figure 5b.
a coordinate transformation interpretation also explains why refactoring engines do not move methods of anonymous classes.
consider figure 5c.
the absolute function of method phas signature p a a ?b where ?
denotes an gui builders.
neither are appropriate for a refactoring engine.
class a inti class b intj void m i i j a b class a inti void m b b i i b.j class b intj void k c c a a c.i c.i a.j class a inti void t new b intj void p i i j c figure nested classes.
anonymous subclass of b. since ?
has no name to display refactoring engines refuse to move p. inr3 by creating a database of program elements and their containment relationships classical refactorings become simple database modi cations and never alter the asts of the target program.
the ast is absolute or immutable it appears di erent relative to the modularity perspective from which it is displayed.
the move instance method refactoring which is what figure is about is a coordinate transformation for software it preserves the semantic properties of a program.
the same holds for other primitive refactorings.
.
the r3 database r3maintains an internal non persistent database to record changes in perspective.
when r3parses compilation units of a program it creates relational database tables for all declaration types in a program.
each tuple of the rclass table represents a unique class declaration in the program.
among rclass attributes is a pointer to the ast of that class.
each tuple of the rmethod table represents a unique method or absolute function declaration in the program.
each rmethod tuple points to the ast of its method and to the rclass tuple in which that method is a member.
similarly there are tables for package declarations rpackage eld rfield etc.
there are no tables for java executable statements or expressions only classes interfaces elds methods and parameters as these are the focus of gang offour design patterns and almost all classical refactorings.
program source is compiled into asts which are traversed to populate r3tables.
figure shows the basic set up.
three rclass tuples graphic square picture are created.
so too are four rmethod tuples graphic.
draw square.
draw picture.
add picture.
draw that are linked to the rclass tuple for which each is a member.
refactorings update this database.
renaming a method updates the name eld of that method s r3tuple.
moving a method to another class updates the method s r3tuple to point to its new class.
only when an ast is rendered displayed is the information in the r3database revealed.
when a method s ast is displayed the name of the method is extracted from the method s r3tuple.
when a class is displayed the tuples of the elds methods constructors etc.
that belong to it are extracted from the database.
the asts of these tuples are then displayed relative to their current class.
figure sketches the rclass display method it prints the class keyword the current class name extends clause with its superclass name and implements clause with interface name s all names obtained from the database.
then each member that is assigned to that class is displayed following by the display of the closing brace g .r3reproduces the original order in which members appeared for ease of subsequent reference by programmers and preserves all source code comments.
rendering is fast and less involved than updating asts 1147class graphic void draw ... class square extends graphic void draw ... class picture extends graphic void add graphic g ... void draw ... package square drawpicture draw addgraphic drawcompilersourceabstract syntax tree ast methid name args clsid m1 draw m2 add c1 m3 draw m4 draw ast clsid name parent c1 graphic c2 square c1 c3 picture c1 traversalrclass rmethoddatabaseclass graphic void draw ... class square extends graphic void draw ... class picture extends graphic void add graphic g ... void draw ... figure r3database.
and moving ast subtrees from one parent to another.
consider the changes that are needed when absolute method foo figure 4a is moved from class btoc.
all invocations of foo such as b foo c d are altered to c foo b d .
a rendering simply changes the order in which arguments are displayed it is more work to consistently update pointers when making this change to an ast.
void display ast.displayheader list rmember mlist getmemberlist for rmember m mlist m.display ast.displayfooter class a extends b implements i member1 member2 member3 b code that is displayed a method to display an rclass tuple class a t voidm b b t t null a can t move with non local type tclass a t voidm b b t t null b can move with local type t c generic entity targetclass a t voidm t t figure rclass display method.
typical refactoring engines modify asts.
in contrast r3eliminates ast manipulation.
r3still needs to create asts when new program elements are needed but other than that r3does not manipulate asts.
as we report later a consequence of the above is that the codebase for r3 is much smaller and simpler than jdtre.
.
primitive refactorings we now explain some representative primitive refactorings to see how they are implemented in r3.
in the refactoring community behavior preservation is determined by statically analyzing whether the input code passes the refactoring s preconditions .
if all preconditions are met the refactoring engine is allowed to change the program code.
we partition our discussion on refactorings into two segments database changes corresponding to code transformations in conventional refactorings considered in this section and precondition checks discussed in the next section .
.
.
rename method rename instance method modi es the name eld of the method s rmethod tuple.
this refactoring like most have a database transaction quality.
consider a class hierarchy where all classes have their own method foo.
to rename foo tobarcan be expressed as a loop where getrelatives nds all overriding overridden methods with the same signature asfoo for rmethod m foo.getrelatives m.rename bar until the loop completes not all methods are renamed and preserving program semantics is not guaranteed.
r3 performs renames on sets of overriding overridden methodswith identical signatures and by being a set operation does not expose an inconsistent database to users rrelativelist relatives foo.getrelatives relatives.rename bar .
.
change method signature change method signature adds removes and reorders method parameters.
encoded in the r3database is a list of formal parameters for every method.
adding a parameter to a method simply adds the parameter and its default value to the database.
when the method is displayed it is shown with its new parameter method calls are displayed with its default argument.
prior work found that highly parameterized refactorings with options name parameter add delete reorder exception delegate discourage the use of refactorings and make them harder to understand.
accordingly r3has separate methods to add remove and reorder parameters.
line below nds the r3tuple for a eld with name fin class c of package p. the eld s type serves as the type of the new parameter and a reference to that eld is the parameter s default value line .
the new parameter by default becomes the last formal parameter of method m. line makes it the rst parameter of method m rfield v rfield .
find p c f rparameter newparam m. addparameter v newparam .
setindex like rename addparameter has a set based version.
.
.
move method via parameter the move instance method refactoring in r3changes the home class of a method m. recall that a home parameter is any parameter of m and a home class is the class of a home parameter.
moving mto a home class simply updates m sr3 tuple to point to the tuple of its home class.
presuming cis a home class the code below moves method mto the class c m.move c .
.
move method via field the move via eld refactoring is illustrated in figure .
method min class a whose absolute signature is c m a a b b is moved to class dvia eld d. a local invocation m b becomes d m this b .
here is where scripting comes in handy move via eld is the following r3script member of rmethod class void moveviafield rfield f rparameter newhome addparameter f move newhome 1148class a d d c m b b ... ... m b ... a call class d class a d d ... d.m this b ... a call class d c m a a b b ... move via field void moveviafield rclassparametertype rfield?
defaultvalue addparameter parametertype defaultvalue movetoclass parametertype figure move via field refactoring.
.
.
introducing new program elements r3introduces complex new code declarations classes methods elds etc.
into an existing program by creating a compilation unit with these declarations.
the le is compiled and the database is updated with new declarations which are then embedded into the existing program via move refactorings.
the code below shows how to create a custom method mul whose r3object is mth string s package pkg n class c n int mul return n rpackage p rproject.getpackage prj pkg rcompilationunit cu p.createcu s rclass cls p.getclass c rmethod mth cls.getmethod mul once the needed methods and elds are removed from compilation unit cu the unit can be marked deleted in the database using the r3remove refactoring.
the ast of curemains but at pretty printing time no text of its now empty compilation unit is produced.
.
.
scripting refactorings r3supports all refactorings that are essential to introduce or remove design patterns from existing programs.
r3 s interface is compatible with r2.
that is r2scripts port to r3.
this gives us the ability to script refactorings to retro t design patterns into java programs and we can build compound refactorings as compositions of primitive refactorings.
we already saw scripts for makeadapter figure makevisitor figure and moveviafield in section .
.
.
.
preconditions precondition checks are themajor performance drain in refactoring engines.
jdtre is typical it checks preconditions as needed.
every refactoring call r on an r3object objrequires a conjunction of precondition checks obj obj obj n where i is a primitive precondition.
for example the jdt move instance method refactoring has 19distinct checks which are also present in r3 if any one fails the move is disallowed.
since jdtre does not know if a programmer will invoke obj r jdtre does the obvious thing by evaluating obj obj obj n only when needed.
r3is di erent.
we too do not know what refactorings a programmer will invoke.
but we can precompute the value of many not all i for all r3objects at database build time even though we may never use these values.
for each i we add a boolean attribute to r3tables to indicate whether a tuple s ast satis es i .
the checks for a refactoring then become a conjunction of these boolean attributes.
the r3database is created by traversing the asts of a program and collecting semantic information.
sopopulates the r3database with tuples and assigns boolean values to these checks.
further in cases where harvested boolean values are insu cient we optimized the r3database to facilitate fast searches e.g.
r3collects all