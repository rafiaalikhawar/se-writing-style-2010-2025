fast and precise symbolic analysis of concurrency bugs in device drivers pantazis deligiannis department of computing imperial college london uk p.deligiannis imperial.ac.ukalastair f. donaldson department of computing imperial college london uk alastair.donaldson imperial.ac.ukzvonimir rakamari c school of computing university of utah usa zvonimir cs.utah.edu abstract concurrency errors such as data races make device drivers notoriously hard to develop and debug without automated tool support.
we present w hoop a new automated approach that statically analyzes drivers for data races.
w hoop is empowered by symbolic pairwise lockset analysis a novel analysis that can soundly detect all potential races in a driver.
our analysis avoids reasoning about thread interleavings and thus scales well.
exploiting the race freedom guarantees provided by whoop we achieve a sound partial order reduction that significantly accelerates c orral an industrial strength bug finder for concurrent programs.
using the combination of w hoop and corral we analyzed drivers from the linux .
kernel achieving .
speedups over standalone c orral .
i. i ntroduction device drivers are complex pieces of system level software operating at the thin boundary between hardware and software to provide an interface between the operating system and the devices that are attached to a computer.
drivers are notoriously hard to develop and debug .
this has a negative impact on hardware product releases as time to market is commonly dominated by driver development verification and validation schedules .
even after a driver has shipped it typically has many undetected errors chou et al.
gathered data from years of linux kernel releases and found that the relative error rate in driver source code is up to times higher than in any other part of the kernel while swift et al.
found that of the system crashes in windows xp are due to faulty drivers.
regarding concurrency bugs a recent study established that they account for of the total bugs in linux drivers showcasing their significance.
the majority of these concurrency bugs were data races ordeadlocks in various configuration functions and hot plugging handlers.
concurrency bugs are exacerbated by the complex and hostile environment in which drivers operate .
the os can invoke drivers from multiple threads a hardware device can issue interrupt requests that cause running processes to block and switch execution context and the user may remove a device hot plugging while some operation is still running.
these scenarios can cause data races if insufficient synchronization mechanisms are in place to control concurrent access to shared resources.
data races are a source of undefined behavior in c and lead to nondeterministically occurring bugs that can be hard to reproduce isolate and fix especially in the context of complex operating systems.
several techniques have been successfully used to analyze device drivers but most focus on generic sequentialprogram properties and protocol bugs.
linux kernel analyzers such as sparse coccinelle and lockdep can find deadlocks in kernel source code but are unable to detect races.
techniques that can detect races in drivers are usually either overly unsound i.e.
can miss real bugs or imprecise i.e.
can report false bugs and typically sacrifice precision for scalability.
thus there is a clear need for new tools that can detect races efficiently and precisely.
we present w hoop an automated approach for static data race analysis in device drivers.
w hoop is empowered by symbolic pairwise lockset analysis which attempts to prove a driver race free by i deriving a sound sequential program thatover approximates the originally concurrent program ii instrumenting it to record locksets and iii using the locksets to assert that all accesses to the same shared resource are consistently protected by a common lock.
reducing analysis to reasoning over a sequential program avoids the need to enumerate thread interleavings and allows reuse of existing successful sequential verification techniques.
we show that we can exploit the race freedom guarantees provided by our symbolic analysis to achieve a sound partial order reduction that significantly accelerates c orral a precise bug finder used by microsoft to analyze drivers and other concurrent programs.
using w hoop and c orral we analyzed drivers from the linux .
kernel.
our combination achieves analysis speedups in the range of .
for most of our benchmarks compared with using c orral in isolation.
for two drivers we observed even greater speedups of and .
w hoop currently supports linux drivers but our approach is conceptually generic and could be applied to analyze drivers for other operating systems as well as concurrent systems that use a similar programming model e.g.
file systems .
to summarize our contributions are as follows we propose symbolic pairwise lockset analysis a sound and scalable technique for automatically verifying the absence of data races in device drivers.
we present w hoop a tool that leverages our approach for analyzing data races in device drivers.
we show that we can achieve a sound partial order reduction using our technique to accelerate c orral an industrial strength bug finder.
we analyze linux drivers showing that w hoop is efficient at race checking and accelerating c orral .static loff t nvram llseek struct file file loff t offset int origin switch origin ... case offset file f pos break racy ... if offset return einval file f pos offset racy return file f pos racy fig.
.
racy entry point in the generic nvram linux .
driver.
ii.
b ackground concurrency in device drivers modern operating systems address the demand for responsiveness and performance in device drivers by providing multiple sources of concurrency an arbitrary number of entry points from the same driver can be invoked concurrently a running driver process can block causing the driver to switch execution to another process and hardware interrupts can be handled concurrently.
these forms of concurrent execution are prone to data races .
definition adata race occurs when two distinct threads access a shared memory location at least one of the accesses is a write access at least one of the accesses is non atomic and there is no mechanism in place to prevent these accesses from being simultaneous.
fig.
shows a racy entry point nvram llseek in the generic nvram linux .
device driver.
this entry point can be invoked concurrently from two threads with the same file struct as a parameter.
this can lead to multiple possible data races because the threads can access the f pos field of file in arbitrary order.
our tool w hoop seexiii was able to find these races automatically see xv .
the most common method for avoiding races is by protecting sets of program statements that access a shared resource with locks forming critical sections .
fig.
shows how to use locking to eliminate the races in fig.
.
careless use of locks has many well known pitfalls coarse grained locking can hurt performance as it limits the opportunity for concurrency while fine grained locking can easily lead to deadlocks.
although the linux kernel provides sophisticated lock free synchronization mechanisms such as atomic read modify write operations in this work we focus on locks as they are widely used.
lockset analysis lockset analysis is a lightweight race detection method proposed in the context of eraser a dynamic data race detector.
the idea is to track the set of locks i.e.
lockset that are consistently used to protect a memory location during program execution.
an empty lockset suggests that a memory location may be accessed simultaneously by two or more threads.
consequently the analysis reports a potential race on that memory location.
lockset analysis for a concurrent program starts by creating acurrent lockset cls tfor each thread tof the program and a lockset lssfor each shared variable sused in the program.
every cls tis initially empty because the threads 1we treat lock free operations soundly by regarding them as not providing any protection between threads this can lead to false alarms.static loff t nvram llseek struct file file loff t offset int origin mutex lock nvram mutex lock switch origin ... case offset file f pos break ... if offset mutex unlock nvram mutex unlock return einval file f pos offset loff t res file f pos store result mutex unlock nvram mutex unlock return res fig.
.
introducing a lock to eliminate the races in the previous example.
do not hold any locks when they start executing.
in addition every lssis initialized to the set of all locks manipulated by the program since initially each access to sis vacuously protected by every lock.
the program is executed as usual with threads scheduled according to the os scheduler except that instrumentation is added to update locksets as follows.
after each lock andunlock operation by t cls tis updated to reflect the locks currently held by t. when taccesses s lssis updated to the intersection of lsswithcls t which removes any locks that are not common to the two locksets.
if lssbecomes empty as a result a warning is issued that the access to smay be unprotected.
fig.
shows an example of applying lockset analysis to a concurrent program consisting of two threads t1andt2 both accessing a global variable a. initially lsa which is the lockset for a contains all possible locks in the program mandn.
during execution of t1 the thread writes awithout holding n and thus nis removed from lsa.
next during execution of t2 the thread writes awithout holding m and thuslsabecomes empty.
as a result a warning is reported because the two threads do not consistently protect a. in contrast to more sophisticated race analyses that encode a happens before relation between threads e.g.
using vector clocks lockset analysis is easy to implement lightweight and thus has the potential to scale well.
the technique though can report false alarms since a violation of the locking discipline does not always correspond to a real data race .
furthermore the code coverage in dynamic lockset analyzers such as eraser is limited by the execution paths that are explored under a given scheduler.
to counter the above limitations techniques such as locksmith and relay have explored the idea of applying lockset analysis statically using dataflow analysis.
in this paper we present a novel symbolic lockset analysis method that involves generating verification conditions which are then discharged to a theorem prover.
iii.
t hewhoop approach we now present symbolic pairwise lockset analysis a novel method for data race analysis in device drivers.
in xiii a we describe how the approach works in a semi formal manner with respect to a simple concurrent programming model.
in xiii b we explain how we have implemented our analysis in at1clst2lsa warning access to a may not be protectedt2 clst1 program m n lock m lock n write a unlock n write a unlock m m n m n m n m n m m m m n m n m m lock m write a unlock m write a m m m m m initialcompute lockset intersection at access pointsfig.
.
applying lockset analysis on a concurrent program.
practical tool w hoop that can be applied directly to driver source code.
a. symbolic pairwise lockset analysis our approach considers for a given driver every pair of entry points that can potentially execute concurrently.
for each such pair we use symbolic verification to check whether it is possible for the pair to race on a shared memory location.
we soundly model the effects of additional threads by treating the driver shared state abstractly when an entry point reads from the shared state a nondeterministic value is returned.
restricting to pairs of entry points rather than analyzing all entry points simultaneously exploits the fact that data races occur between pairs of threads and limits the complexity of the generated verification conditions.2the trade off is that a quadratic number of entry point pairs must be checked.
in xiii b we discuss optimizations based on device driver domain knowledge to reduce the number of pairs to some extent.
symbolic verification of a pair of entry points works by i instrumenting each entry point with additional state to record locksets and ii attempting to verify a sequential program that executes the instrumented entry points in sequence.
a postcondition for the sequential program asserts for every shared location that the locksets for each entry point with respect to this location have a non empty intersection.
verification of the resulting sequential program can be undertaken using any sound method in practice we employ the boogie verification engine which requires procedure specifications and loop invariants to be generated after which verification conditions vcs are generated and discharged to an automated theorem prover.
we now detail the approach in a semi formal manner in the context of a simple concurrent programming model.
concurrent programming model we consider a concurrent programming model where an unbounded number of threads execute a set of pre defined thread templates .
at any given point of execution a certain number of threads are active each thread executing a particular template.
in the context of 2in principle our approach could be applied at a coarser level of granularity such as by considering all entry points one after the other taking into account that an entry point can race with itself.
however using pairwise analysis has the additional advantage that it enables us to easily run the analysis for each pair in parallel for performance although we leave this for future work.statement notes x e private assignment where x2vtandeis an expression overvt x f e procedure call where x2vt eis a sequence of expressions over vt fis the name of a procedure in procst s e shared write where s2vsandeis an expression over vt x s shared read where x2vtands2vs lock m mutex lock where m2m unlock m mutex unlock where m2m fig.
.
the allowed statements in our simple programming model.
device drivers a thread template corresponds to a driver entry point.
multiple instances of the same thread template may execute concurrently just as multiple invocations of a single driver entry point may be concurrent.
further threads may start executing at any point during execution in the context of device drivers this corresponds to the os invoking additional driver entry points.3for ease of presentation only our model does not feature aggregate data types pointers or dynamic memory allocation.
these arehandled by our implementation and inxiii b we discuss interesting practical issues arising from the handling of a full blown language.
aconcurrent program is described by a finite set of shared variables vs a finite set of mutexes m and a finite set of thread templates .
a thread template tconsists of a finite set of procedures procstand a finite set of private variables vt. a designated procedure main t2procstdenotes the starting point for execution of tby a thread.
each procedure of procst is represented by a control flow graph of basic blocks where each block contains a sequence of statements.
a basic block either has a single successor or a pair of successors.
in the latter case an exit condition over thread private variables determines the successor to which control should flow on block exit.
the allowed statements are shown in fig.
and include designated statements for reading from and writing to shared variables.
in particular shared variables may not appear in arbitrary expressions.
this restriction simplifies our presentation of lockset instrumentation below and is trivial to enforce by pre processing.
we do not specify the form of expressions nor the types of variables assuming a standard set of data types and operations.
semantics letibe an infinite set from which dynamic thread ids will be drawn.
the state of a running concurrent program consists of a valuation of the shared variables vs a mapping that associates each mutex in mwith an id fromi recording which thread currently holds the mutex or with a special value ?
2i to indicate that the mutex is not held by any thread and a list of thread states .
each thread state has an associated thread template t the type of the thread and multiple threads may have the same associated template and consists of an id drawn fromi an index indicating the next statement of t to be executed by the thread and a valuation of the thread private variables vt. if multiple threads are instances of the same template t then each thread carries a separate valuation of the private variables for this template.
3we do notconsider the case where one thread spawns another thread which does not typically occur in the context of drivers rather we aim to capture the scenario where additional threads are launched by the environment.original statement instrumented statement s e wi wi fsg lss i lss i cls i x s ri ri fsg lss i lss i cls i havoc xi lock m cls i cls i fmg unlock m cls i cls infmg fig.
.
instrumenting statements for lockset analysis.
initially the valuation of shared variables is arbitrary no mutexes are held i.e.
each mutex maps to ?
and the list of thread states is empty.
at any point of execution a new thread state may be added to the list of thread states.
this involves selecting a thread template tand an id i2i that has not been previously used during program execution setting the point of execution for the new thread state to be the first statement of main t and choosing an arbitrary valuation for the private variables vt. we consider a standard interleaving model of concurrency at any execution point a thread may execute its current statement unless that statement has the form lock m and mutex mis held by some thread.
executing a statement updates the thread private and shared state in a standard manner.
for example if a thread following template t executes s e where s2vsandeis an expression over vt the shared variable valuation is updated so that shas the value determined by evaluating ein the context of the thread s private variable valuation.
because our interest is in data race analysis for race free programming we are not concerned with relaxed memory behavior race free programs exhibit only sequentially consistent behaviors.
a thread terminates if it reaches the end of main t in which case its state is removed from the list of thread states.
since our interest is in analysis of device drivers which are reactive programs we do not consider the notion of global program termination.
lockset instrumentation for templates tandu which can be equal we want to check whether it is possible for a thread executing tto race with a thread executing u in the presence of arbitrarily many further concurrently executing threads.
to this end we first instrument a template tfor lockset analysis seexii .
given an arbitrary symbol i we define the instrumentation of twith respect to i denoted ti.
there are two aspects to this instrumentation phase renaming andlockset instrumentation .
renaming is straightforward each occurrence of a private variable x2vtused in tis replaced with a renamed variable xiinti and every procedure f2procst is renamed both at its declaration site and at all call sites to fiinti.
the purpose of renaming is to ensure that when we analyze a pair of templates tandu both templates execute distinct procedures and operate on distinct private data.
this is vital in the case where tanduare the same.
lockset instrumentation introduces sets ri p vs and wi p vs to track the shared variables that have been read from and written to respectively by the thread executing t a current lockset cls i p m to record the mutexes currently held by the thread and for each shared variable s2vs a lockset lss ito record the mutexes that are consistently held when the thread accesses s. the statements of each procedurecls i ri wi cls j rj wj fors2vsdolss i m lss j m main ti main uj assert8s2vs s2wi rj wj s2wj ri wi lss i lss j6 fig.
.
the sequential program to be analyzed to prove race freedom for a pair of thread templates.
intithat access shared variables and mutexes are instrumented to manipulate these sets as shown in fig.
.
for a shared variable assignment s e we record in withatshas been written to and update lss ito eliminate any mutexes that are not currently held those mutexes that are not in cls i .
a shared variable read x sis instrumented analogously with an additional havoc command which we discuss below.
instrumentation of mutex manipulation commands lock m andunlock m involves updating cls ito add and remove mutex m respectively.
shared state abstraction recall that while our aim is to perform race analysis for pairs of threads we must be sure to account for possible side effects due to other threads that are running concurrently.
the instrumentation of fig.
achieves this via nondeterminism when reading from a shared variable s a nondeterministic value is returned.
this is reflected by the use of a havoc command which sets its argument to an arbitrary value.
because all shared state accesses are abstracted in this fashion it is possible to completely dispense with the shared variables after the lockset instrumentation has been performed.
as a result when instrumenting a shared variable write the effect of the write is not explicitly modeled.
sequentialization fig.
shows the sequential program that we analyze to prove race freedom for a pair of thread templates tandu.
assuming that tanduhave been instrumented using distinct symbols iandj yielding tianduj the sequential program operates as follows.
first the read write and current locksets for tiandujare initialized to be empty and for each shared variable s the locksets lss iandlss jare initialized to the full set of mutexes m. the main procedures of the instrumented thread templates main tiandmain uj are then executed in turn the order does not matter due to renaming .
finally an assertion checks for consistent use of mutexes if sis written during execution of tiand accessed during execution of uj or vice versa then the locksets lss i andlss jmust contain at least one common mutex.
soundness we sketch an argument that if the program of fig.
is correct i.e.
the assertion described above holds invariantly at the end of the program then it is impossible for a thread executing template tto race with a thread executing template u under the assumption that the threads are guaranteed to terminate.
let us assume that the program of fig.
is correct and suppose by way of contradiction that a thread executing tcan in fact race with a thread executing u on some shared variable s. by our hypothesis that the program is correct and that the threads terminate the assertion checked at the end of the program guarantees that at least one mutex saym belongs to both lss iandlss j. by the definition of a lockset and according to the manner in which sharedboogie ivlcode instrumentedwith yieldsdata racereportsno errors under given bounds whoop error tracesz3chauffeursmacklinux driver source code in cboogie ivl codellvm irlinuxenvironmentalmodelinstrumentationsequentializationinvariant generationboogieverification enginecorrala.
translation phaseb.
symbolic lockset analysis phasec.
bug finding phase clang llvmentry point informationfig.
.
the w hoop architecture empowered by state of the art compilation clang llvm and smack and verification boogie and c orral tools.
accesses are instrumented in fig.
this means that mis held during every access to sby both tianduj.
as a result m must be unlocked and locked between the two accesses which contradicts that the pair of accesses is racing.
in the presence of non termination the assertion at the end of fig.
may not be reached.
the termination analysis problem for device drivers has been widely studied see e.g.
and in the remainder of the paper we do not consider termination issues assuming that the drivers we analyze in our experimental evaluation see xv are terminating.
b. implementation in whoop the simple concurrent programming model of xiii a is deliberately idealistic to make it easy to describe our symbolic verification technique.
in practice linux drivers are written in c our technique does not know up front which are the driver entry points drivers do not work with a cleanly specified set of named locks and rather than having a given set of named shared variables we have arbitrary memory accesses via pointers.
we now explain how we have taken the conceptual ideas fromxiii a and used them to build w hoop a practical automated tool for detecting data races in drivers.
architecture fig.
depicts the w hoop toolchain.
the input to w hoop is a linux driver written in c together with an environmental model4that is required to close the driver so that it can be analyzed for races.
initially w hoop uses three llvm based tools chauffeur clang and smack to translate the driver and its environmental model into an abstract program written in the boogie intermediate verification language ivl .
boogie is a simple imperative language with well defined semantics that is used as the input to a number of cutting edge verifiers e.g.
the boogie verifier and c orral .
next w hoop instruments and sequentializes the program to perform symbolic pairwise lockset analysis see fig.
b and xiii a using the boogie verification engine.
after the verification phase ends w hoop can exploit any inferred race freedom guarantees to accelerate precise race checking with c orral see fig.
c and xiv .
we engineered the chauffeur5and w hoop6components of our toolchain denoted with grey boxes in fig.
.
for 4this consists of stub header files modeling relevant linux kernel apis.
struct file operations nvram fops .llseek nvram llseek .read read nvram .write write nvram .unlocked ioctl nvram unlocked ioctl fig.
.
entry point definitions in the generic nvram driver.
the remaining components we were able to reuse industrialstrength tools that are robust and battle proven via their use in many complex software projects.
extracting entry point information chauffeur is a clangbased tool that traverses the abstract syntax tree ast of the original driver and extracts all entry point identifier names together with the identifier names of their corresponding kernel functions.
linux drivers define entry points in a standard way see fig.
for an example of how the generic nvram driver defines the entry points for file operations chauffeur identifies these definitions in the ast and outputs the relevant information in an xml file which is parsed by w hoop to be used during the instrumentation.
translation for verification next the driver is compiled by clang to llvm ir a low level assembly like language in single static assignment ssa form.
function calls e.g.
for locking and unlocking are preserved in this translation and hence we do not need to keep track of them separately.
smack then translates the driver from llvm ir to boogie ivl which is the input language of w hoop .
an important feature of smack is that it leverages the pointer alias analyses of llvm to efficiently model the heap manipulation operations of c programs in boogie ivl.
thus w hoop does not need to directly deal with pointers and alias analysis.
to achieve scalability smack uses a split memory model that exploits an alias analysis to soundly partition memory locations into non overlapping equivalence classes that do not alias.
this has been shown to lead to more tractable verification compared with a monolithic model where the heap is considered to be an array of bytes .
the split memory model is based on memory regions which are maps of integers that model the heap.
a benefit of using this model is that distinct memory regions denote disjoint sections of the heap.
we leverage this knowledge inside w hoop to guide and optimize our lockset instrumentation and analysis and to create a finegrained context switch instrumentation as discussed in xiv.identifying locks when the instrumentation phase begins whoop performs an inter procedural static analysis at boogie ivl level to identify all available locks and rewrite each one both at declaration and at all access sites to a unique boogie constant.
representing all locks statically instead of using their original smack pointer based representation makes it easier for w hoop to perform lockset instrumentation and locksetbased invariant generation.
currently w hoop supports linux kernel mutex and spinlock operations it is easy to enhance it with knowledge of other locking primitives.
if w hoop cannot reliably infer a unique lock instance e.g.
because it is stored in an unbounded data structure of locks such as an array or a list it will exit with a warning.
however we have never encountered this in practice since a small fixed number of locks is advocated by linux experts as good practice when developing drivers .
watchdog race checking instrumentation data race detection is performed by introducing sets containing the locks that are consistently held when accessing each shared variable and sets containing all shared variables that are read and written seexiii a and the instrumentation of fig.
.
these sets can be modeled directly in boogie as characteristic functions using maps.
however this requires the use of quantifiers to express properties related to set contents.
for instance to express that a setxof elements of type ais empty where xis represented as a map from atobool we would require the quantified expression8a a x .
it is well known that automated theorem proving in the presence of quantified constraints is challenging and that theorem provers such as z3 are often much more effective when quantifiers are avoided.
to avoid quantifiers and the associated theorem proving burden we use instead a watchdog race checking instrumentation adapted from previous work .
suppose we are analyzing entry points tandu and that after translation into boogie ivl these entry points share a common memory region mr. when analyzing tandufor races we introduce an unconstrained symbolic constant watched mr representing some unspecified index into mr we call this the watched offset formr.
we then attempt to prove that it is impossible fortanduto race on mr at index watched mr. if we can succeed in proving this we know that tandumust be racefree for the whole mr since the watched offset was arbitrary.
this technique of choosing an arbitrary index to analyze for each map manipulated by an entry point pair can be seen as a form of quantifier elimination rather than asking the underlying theorem prover to reason for all indices of mr in a quantified manner we eliminate the quantifier in our encoding and instead ask the theorem prover to reason about a single but arbitrary index of mr. generating loop and procedure summaries early in the development of w hoop we experimented with analyzing recursion free drivers using full inlining.
we found that this did not scale to large drivers and that some drivers do exhibit recursion e.g.
the r8169 ethernet driver see xv .
to make our analysis scale while maintaining precision and to support recursion we use the houdini algorithm to automatically compute summaries pre and post conditions and loop invariants .
given a pool of candidate pre conditions post conditions and loop invariants houdini repeatedly attempts to verify each procedure.
initially the entire candidatepool is considered.
if verification fails due to an incorrect candidate this candidate is discarded.
the process repeats until a fixpoint is reached.
the possibly empty set of remaining candidates has been proven to hold and can be used to summarize calls and loops during further program analysis.
houdini does not generate the initial pool of candidates whoop generates them using a set of heuristics and passes them to houdini as a starting point.
this is done based on syntactic patterns extracted from an inter procedural pass over the code for an entry point.
we give two examples for clarity we use notation from the simple concurrent programming model ofxiii a. if we observe syntactically that procedure fof entry point tmay write to but does not read from shared variable s then when instrumenting twith symbol i we guess s2wiands 2rias post conditions for fi.
these guesses may be incorrect for instance if the potential write to sturns out to be in dead code or if a read from s has already been issued on entry to fi.
similarly if syntactic analysis indicates that fmay unlock mutex m we guess m 2cls ias a post condition for fi this guess may be incorrect for instance if the unlock operation is not reachable or if a subsequent lock operation acquires the mutex again.
we stress that guessing incorrect candidate invariants does not compromise the soundness of verification w hoop is free to speculate candidates that are later deemed to be incorrect and thus discarded by houdini.
the balance we try to strike is to have w hoop generate sufficient candidates to enable precise lockset analysis without generating so many candidates that the speed of the houdini algorithm is prohibitively slow.
verification and error reporting for each entry point pair the instrumented sequential program equipped with procedure and loop summaries is given to the boogie verification engine.
for each procedure in the program boogie generates a vc and discharges it to the z3 theorem prover.
in particular the verification for the root level procedure implementing the sequential program sketched in fig.
encodes the race freedom check for the entry point pair.
successful verification implies that the pair is race free while an error i.e.
counterexample denotes a potential data race and is reported to the user.
to improve usability w hoop has a built in error reporter that matches counterexamples to source code.
the following is a race that w hoop found and reported for the example of fig.
generic nvram.c error potential read write race read by entry point nvram llseek generic nvram.c return file f pos write by entry point nvram llseek generic nvram.c file f pos offset optimizations we have implemented various optimizations to increase the precision and performance of w hoop .
we comment on the two most effective ones.
first we enriched w hoop with information regarding kernel imposed serialization to increase precision.
the linux kernel can serialize calls to entry points thus forcing them to run in sequence instead of an interleaved manner.
for example a large number of networking entry points are mutually serialized with rtnl a network specific kernel lock.
we discovered this when w hoop reported many races between a number of networking entry points of the r8169 driver see xv when we investigated the source of these races we found out that these entry points could not race in reality because of rtnl.whoop exploits this knowledge and does not create pairs for entry points that are mutually serialized by the kernel.
this is an ongoing manual effort the more drivers we study the more such properties we discover to make w hoop more precise.
second we soundly reduce the number of memory regions that are analyzed for races.
if memory region mr is accessed by only one entry point in a pair then trivially the pair cannot race on mr. we thus disable lockset analysis for mr. this can reduce the complexity of vcs that need to be solved by the theorem prover speeding up the verification process.
practical assumptions related to soundness whoop is soundy it aims in principle to perform a sound analysis that can prove absence of races but suffers from some known sources of unsoundness which we now comment on.
we assume that the formal parameters of an entry point do not alias and thus cannot race.
this is a potentially unsound feature that can be turned off using a command line option.
without this assumption we have observed w hoop reporting false alarms and in our experience so far we have not missed any races by assuming non overlapping parameters.
we also rely on the soundness of our best effort environmental model and on exploiting domain specific knowledge related to entry point serialization by the linux kernel.
in addition to inheriting soundness issues arising from currently unknown bugs in w hoop and in the external tools that whoop relies on we acknowledge that i the .
.
release of smack we used is subject to sources of unsoundness e.g.
it models integers as an infinite set rather than as a finite set of bit vectors and its memory model can potentially be unsound in typically rare situations where programs use unaligned byte level memory accesses 8and ii that the combination of clang and smack commits our approach to specific choices related to undefined and implementationdefined aspects of the c language when translating to boogie.
however w hoop makes no fundamental assumptions related to these translation decisions meaning that a more accurate c to boogie translation would automatically lead to a more accurate analysis with w hoop .
limitations as a lockset analyzer w hoop can be imprecise because a violation of the locking discipline does not always correspond to a real race e.g.
when lock free synchronization is used .
w hoop also uses over approximation which can be another source of imprecision.
furthermore the tool does not check for dynamically created locks or for locks provided by external libraries although the latter could be addressed by providing a mechanism for users to declare custom locks.
we also do not currently treat interrupt handlers in a special way we just assume that they can execute concurrently with any entry point.
one way to address this is to model interrupt specific kernel functions e.g.
for enabling disabling interrupts .
another limitation of w hoop is that it is unable to verify drivers designed to be accessed by only a single process at a time.
this single open device mode can be enforced by atomically testing at the beginning of an entry point a global flag that indicates device availability if the flag is set 8note that currently bit vectors and unaligned byte level memory accesses are soundly and precisely handled by smack as of release .
.
.then the checking entry point executes else it blocks.
because whoop over approximates read accesses to shared variables and thus this flag it can falsely report a pair as racy.
however experts advise against serializing drivers in this way as it inhibits user ingenuity e.g.
a user might expect that a driver can be accessed concurrently for performance .
statically analyzing drivers requires closing the environment by abstracting away the low level implementation details.
to this end we developed a simple model for the linux kernel that consists of nondeterministic stub functions.
a limitation of our model is that it can be inaccurate leading to semantic mismatches that can in turn lead to false positives and or false negatives.
however we currently only focus on finding data races and thus can get away with over approximating large parts of the linux kernel without losing too much precision.
making our model more precise is an ongoing manual effort that requires linux kernel expertise.
we argue that further work on the model is orthogonal to the contributions of this paper.
also even if our symbolic analysis results in false positives whoop can still use the results to significantly speedup a more precise bug finder as seen in xiv andxv.
iv.
a ccelerating precise race checking whoop is a sound but imprecise static race analyzer.
for developers who deem false alarms as unacceptable we consider a method for leveraging the full or partial race freedom guarantees provided by w hoop to accelerate c orral a precise bug finder used by microsoft to analyze windows drivers .
because c orral operates on boogie programs it was easy to integrate it into our toolchain see fig.
c .
our technique though is general and capable in principle of accelerating any concurrency bug finder that operates by interleaving threads at shared memory operations.
corral is a symbolic bounded verifier for boogie ivl that uses the z3 smt solver to statically reason about program behaviors.
it checks for violations of provided assertions and reports a precise counterexample if an assertion violation is found.
c orral performs bounded exploration of a concurrent program in two steps.
first given a bound on the number of allowed context switches the concurrent program is appropriately sequentialized and the generated sequential version preserves reachable states of the original concurrent program up to the context bound .
then c orral attempts to prove bounded in terms of the number of loop iterations and recursion depth sequential reachability of a bug in a goal directed lazy fashion to postpone state space explosion when analyzing a large program.
it uses two key techniques to achieve this i variable abstraction where it attempts to identify a minimal set of shared variables that have to be precisely tracked in order to discharge all assertions and ii stratified inlining where it attempts to inline procedures on demand as they are required for proving program assertions.
race checking instrumentation to detect data races with corral w hoop outputs a boogie program instrumented with a simple but effective encoding of race checks .
whenever there is a write access to a shared variable s whoop instruments the program as follows s e original write yield allow for a context switch assert s e check written valuelikewise whenever there is a read access to s w hoop instruments the program as follows x s original read yield allow for a context switch assert x s check read value ayield statement denotes a nondeterministic context switch and is used by c orral to guide the sequentialization.
corral is inherently unsound i.e.
can miss real races because it performs bounded verification.
however c orral is precise and assuming a precise environmental model it will only report true races.
w hoop takes advantage of this precision to report only feasible races.
note that our instrumentation conveniently tolerates some benign races it does not report a read write race if the write access updates the shared memory location with the same value that already existed it also does not report a write write race if the two write accesses update the shared memory location with the same value which can be different from the pre existing value .
in this work we use c orral to analyze individual pairs of entry points.
we do not use any abstraction to model additional threads as we want c orral to report only true races.
because we only analyze pairs though c orral will miss races that require more than two threads to manifest.
we could extend our setup so that more than two threads are considered by corral but because the number of threads that an os kernel might launch is unknown in general we are inevitably limited by some fixed maximum thread count.
sound partial order reduction by default and assuming no race freedom guarantees w hoop instruments a yield after each shared memory access of each entry point and after every lock and unlock operation.9whoop then sends this instrumented program to c orral which leverages sequentialization to explore all possible thread interleavings up to a pre defined bound.
our approach to accelerating c orral is simple and yet effective if thanks to w hoop s analysis we know that a given statement that accesses shared memory cannot be involved in a data race then we do not instrument ayield after this statement and we also omit the assert that would check for a race.
this is a form of partial order reduction and reduces the number of context switches that c orral must consider in a sound manner there is no impact on the bugs that will be detected.
this is because each access for which a yield is suppressed is guaranteed to be protected by some lock a consequence of lockset analysis .
if the access is a write its effects are not visible by the other entry point in the pair until the lock is released.
if the access is a read the value of the shared location cannot change until the lock is released.
the fact that a yield is placed after each unlock operation suffices to take account of communication between entry points via the shared memory location.
we have implemented two different yield instrumentations in w hoop yield epp and yield mr. the first instruments yield statements in a binary fashion if w hoop proves an entry point pair epp as race free then it will instrument ayield only after each lock and unlock statement of the 9we acknowledge that in the presence of data races and relaxed memory even considering all interleavings of shared memory accesses may be insufficient to find all bugs.pair else if w hoop finds that a pair might race then it will instrument a yield after all visible operations of the pair.
yield mr is a finer grained instrumentation it instruments a yield only after each access to a memory region mr that might race in the pair regardless if the pair has not been fully proven as race free and after each lock and unlock statement.
in our experiments see xv yield mr is significantly faster than yield epp.
our partial order reduction is able in principle to accelerate corral forarbitrary bug finding in concurrent programs.
although we did preliminary explorations in this direction identifying useful safety properties to check was challenging since drivers typically contain no assertions.
thus in this paper we use c orral solely to find data races.
v. e valuation we performed experiments to validate the usefulness of the whoop approach xiii and its combination with c orral xiv .
we first present race checking results from running whoop and c orral on drivers taken from the linux .
kernel.10we then evaluate the runtime performance and scalability of c orral using different yield instrumentations and context switch bounds.
our results demonstrate that w hoop can efficiently accelerate race checking with c orral .
experimental setup we performed all experiments on a .40ghz intel core i7 cpu with 16gb ram running ubuntu linux .
.
lts llvm .
smack .
.
z3 .
.
boogie rev.
and c orral rev.
.
we also used mono .
.
to run boogie and c orral .
we configured corral with a time budget of hours t.o.
denotes timeout a context switch bound csb of and and the default recursion depth bound of .
benchmarks we evaluate our methodology against drivers from the linux .
kernel.
we chose non trivial drivers of several types block char ethernet near field communication nfc universal serial bus usb and watchdog.
for all these drivers we had to understand their environment and manually model it this required approximately two months of work.
race checking table i presents statistics for our benchmarks lines of code loc number of possible entry point pairs pairs number of smack memory regions mrs number of racy pairs racy pairs and number of racy memory regions racy mrs reported by w hoop and number of data races discovered by c orral using a csb of races found .
using a higher csb than did not uncover any further races this might mean that all races in our benchmarks can manifest with a csb of or that c orral hit its default recursion depth bound of before discovering a deeper bug.
although we experimented with higher recursion depth bounds we were unable to discover any races that could not be exposed with the default recursion depth bound.
we can see in table i that w hoop reports more races than c orral does.
this is because w hoop employs an overapproximating shared state abstraction to conservatively model 11the number of racy memory regions can be less than the number of races found by c orral w hoop might find that a memory region is racy but the same memory region might race in several program statements.table i. p rogram statistics and race checking results from applying whoop and corral on our benchmarks .
whoop corral racy racy races benchmarks loc pairs mrs pairs mrs found generic nvram pc8736x gpio machzwd ssu100 intel scuwd ds1286 dtlk fs3270 gdrom swim intel nfcsim ps3vram sonypi sx8 8139too r8169 the effects of additional threads when analyzing an entry point pair and because lockset analysis is inherently imprecise both factors can lead to false positives.
on the other hand c orral is precise but can miss races because only a limited number of context switches are considered.
another issue with c orral is loop coverage due to unsound loop unrolling.
to tackle this we enable the built in loop over approximation described in previous work .
this can potentially lead c orral to report false bugs but we have not seen this in practice.
furthermore when we apply c orral to a pair of entry points we just check the specific pair and do not account for the effects of other threads see xiv this can also cause c orral to miss some races.
note that standalone c orral did not discover any races that w hoop did not already report.
this is expected as w hoop aims for soundness and increases our confidence in the implementation of w hoop .
most of the races that w hoop and c orral discovered fall into two categories.
the first is about accessing a global counter or flag from concurrent entry points without holding a lock.
this might be for performance and indeed a lot of the races we found might be benign.
even benign races though lead to undefined behavior according to the c standard.
the second is about an entry point modifying a field of a struct either global or passed as a parameter without holding a lock.
this can lead to a race if another entry point simultaneously accesses the same field of the same struct.
as an example of the second category we found the following race in the generic nvram driver see fig.
the llseek entry point accesses the file offset file f pos without holding a lock file is passed as a parameter to llseek .
this causes a race if the kernel invokes llseek from another thread while passing the same file object as a parameter.
we observed that another char driver using the same apis does use a lock to protect the offset access in its respective llseek entry point leading us to suspect that the race we found in generic nvram is not benign.
accelerating c orral table ii presents runtime results from using w hoop standalone c orral and w hoop c orral to analysis time in seconds using whoop corral yield mr 10100100010000toanalysis time in seconds using corral yield all 2x speedup 10x speedup fig.
.
scatter plot showing the runtime speedups that c orral achieves using w hoop with the yield mr instrumentation.
the symbols and represent a context switch bound of and respectively.
to analyze our benchmarks while fig.
plots the runtime speedups that c orral achieves using w hoop with the yieldmr instrumentation.
standalone c orral uses yield all which instruments context switches i.e.
yield statements after all visible operations while w hoop c orral uses yield epp and yield mr which instrument context switches in a more fine grained fashion see xiv .
the table also shows the number of context switches per instrumentation y .
all reported times are in seconds and averaged over three runs.
whoop uses over approximation to scale and as expected executes significantly faster than c orral in all our benchmarks.
for example c orral times out in all configurations with and without w hoop when trying to analyze the r8169 ethernet driver while w hoop manages to analyze the same driver in .
seconds.
we believe that the reason behind this is that the r8169 driver has deeply nested recursion in some of its entry points which puts burden on c orral s stratified inlining.
this is not an issue for w hoop which uses procedure summarization.
this shows that w hoop has value as a standalone analyzer.
using the race freedom guarantees from w hoop we managed to significantly accelerate c orral in most of our benchmarks the best results were achieved using yield mr. fig.
shows that most speedups using yield mr are between .
and in ssu100 and pc8736x gpio with a csb of we achieved a speedup of and respectively.
we noticed that a higher csb typically results in greater speedups when exploiting w hoop .
this is expected as complexity grows exponentially with csb and hence w hoop s reduction helps more at a higher csb.
however there are cases where w hoop might slow down c orral .
we noticed this in the sx8 driver whoop verified out of memory regions but did not fully verify any of the pairs c orral on the other hand analyzed the only two pairs of the driver in just .
seconds csb of .table ii.
c omparison with different yield instrumentation granularities and context switch bounds .
whoop corral whoop c orral timeyield all time sec yield epp time sec yield mr time sec benchmarks sec y csb csb csb y csb csb csb y csb csb csb generic nvram .
.
.
.
.
.
.
.
.
.
pc8736x gpio .
.
.
.
.
.
.
.
.
.
machzwd .
.
.
.
.
.
.
.
.
.
ssu100 .
.
.
.
.
.
.
.
.
.
intel scuwd .
.
.
.
.
.
.
.
.
.
ds1286 .
.
.
.
.
.
.
.
.
.
dtlk .
.
.
.
.
.
.
.
.
.
fs3270 .
.
.
t.o.
.
.
.
.
.
.
gdrom .
.
.
.
.
.
.
.
.
.
swim .
.
.
t.o.
.
.
t.o.
.
.
t.o.
intel nfcsim .
.
.
.
.
.
.
.
.
.
ps3vram .
.
.
t.o.
.
.
t.o.
.
.
t.o.
sonypi .
.
t.o.
t.o.
.
t.o.
t.o.
.
t.o.
t.o.
sx8 .
.
.
.
.
.
.
.
.
.
8139too .
.
.
t.o.
.
.
t.o.
.
.
t.o.
r8169 .
t.o.
t.o.
t.o.
t.o.
t.o.
t.o.
t.o.
t.o.
t.o.
we believe that in this case the overhead of running w hoop outweighed the benefits of using yield epp or yield mr. other tools we tried to compare w hoop with other similar approaches seexvi .
however we found this to be hard in practice we downloaded locksmith but could not get it to work with the .
linux drivers the tool was last updated in we also could not find source code or binaries of other tools .
vi.
r elated work static race analysis is a promising alternative to dynamic techniques which restrict analysis to the schedule chosen by a possibly controlled scheduler providing limited coverage .
warlock and locklint are notable static race analyzers.
in comparison to w hoop these tools rely heavily on user annotations.
most related to our lockset analysis are the static lockset analyzers relay and locksmith .
both tools though have several limitations.
relay found warnings when analyzing the linux kernel with only of them being true data races.
to tackle this issue relay employs unsound post analysis filters and hence can also filter out real bugs.
locksmith was successfully applied in several small pthreads applications and mediumsized linux device drivers but the authors reported that the tool was unable to run on several large programs hinting at its limited scalability.
w hoop aims to achieve scalability andprecision the first via novel symbolic pairwise lockset analysis and the second by accelerating c orral an industrial strength precise bug finder.
choi et al.
combine static analysis and runtime access caching to speed up dynamic race detection.
kahlon et al.
use a divide and conquer algorithm that partitions all pointers of a program that do not alias in disjoint sets to achieve scalability more recently they used abstract interpretation to achieve a sound partial order reduction on the set of thread interleavings and statically reduce the number of false race warnings .
das et al.
employ inter procedural alias analysis and verifiable user annotations to split programs intodisjoint sections based on non communicating accesses of shared data and eliminate redundant checks during dynamic race detection.
w hoop uses symbolic lockset analysis which involves generating verification conditions and discharging them to a theorem prover and then employs c orral to filter out false races.
our pairwise approach to analyzing driver entry points employing abstraction to model additional threads was inspired by the two thread reduction used by the gpuverify tool in the analysis of data parallel opencl and cuda kernels .
the idea of pairwise analysis of components in a concurrent system has been broadly applied notably in model checking of cache coherence protocols .
vii.
c onclusions in this paper we presented w hoop a new automated approach for detecting all possible data races in device drivers.
compared to traditional data race detection techniques that are based on happens before and typically attempt to explore as many thread interleavings as possible and thus face code coverage and scalability issues w hoop uses over approximation and symbolic pairwise lockset analysis which scales well.
exploiting the race freedom guarantees provided by w hoop we showed that we can achieve a sound partial order reduction that can significantly accelerate c orral a state of the art concurrency bug finder.