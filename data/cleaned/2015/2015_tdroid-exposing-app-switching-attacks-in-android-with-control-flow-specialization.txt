tdroid exposing app switching attacks in android with control flow specialization jie liu unsw sydney australia jieliu cse.unsw.edu.audiyu wu unsw sydney australia diyuwu cse.unsw.edu.aujingling xue unsw sydney australia jingling cse.unsw.edu.au abstract the android multitasking mechanism can be plagued with app switching attacks in which a malicious app replaces the legitimate top activity of the focused app with one of its own thus mounting e.g.
phishingand denial of serviceattacks.
existingmarket level defenses are still ineffective as static analysis is fundamentally unabletoreasonabouttheintentionofanappanddynamicanalysis has low coverage.
weintroducetdroid anewmarket levelapproachtodetecting app switching attacks.
the challenge lies in how to handle a plethoraofinput dependentbranchpredicates forminganexponential number of paths that control the execution of the code responsibleforlaunchingsuchattacks.tdroidtacklesthischallenge by combining static and dynamic analysis to analyze an app withoutproducinganyfalsepositives.initsstaticanalysis tdroid transforms the app into runnable slices containing potentially app switching attacks one slice per attack.
in its dynamic analysis tdroid executes these slices on an android phone or emulator to exposetheirmaliciousguis.thenoveltyliesintheuseofanew trigger orientedslicing techniquein producingrunnable slicesso thatcertaininput dependentbranchpredicatesarespecializedto execute always some fixed branches.
evaluated with a large set of malware apps tdroid is shown to outperformthe state ofthe art by detecting substantiallymoreapp switching attacks in a few minutes per app on average.
ccs concepts securityandprivacy softwareandapplicationsecurity keywords android gui security static analysis dynamic analysis acm reference format jie liu diyu wu and jingling xue.
.
tdroid exposing app switching attacks in android with control flow specialization.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september3 montpellier france.
acm new york ny usa 12pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
introduction the android multitasking mechanism has been plagued by severesecurity risks .weintroduceanew programanalysistool tdroid deployable at the market level for detecting app switching attacks before they hit the users .
in such an attack a malicious app can replace the legitimate top activity of the focused app withoneofitsown openedbytypicallycalling startactivity thereby mounting e.g.
phishing and denial of service attacks.
challenge.
consideramalwareappthatrunsinthebackground keepingtrackofthedevicestatus.oncethedevicehasreacheda specificstate determinedbyan input dependentbranchpredicate involvingsomeenvironmentvariables themalwarewillexecute somemaliciouscodeforlaunchinganappswitchingattack.such attacks can be launched without requiring any permissions for all appsinstalledonacompromiseddeviceunderallandroidversions.
the challenge lies in how to handle a plethora of input dependent branchpredicates forminganexponentialnumberofpaths that control the execution of the code responsible for launching such attacks.state of the art.
to mitigate app switching attacks as a special caseofguiattacks severalon devicedefenseshavebeenproposed including byaddingasecurityindicatorshowingtheapp identity being interacted with and by raising an alert dialog deployableonlyinrooteddevices .accordingto however such passivedefensesareonlymarginallyeffective yetattheexpense of negatively impacting system performance and user experience.
to prevent app switching attacks market level defenses which canbeusedduringthevettingprocess arepreferred.staticanalysis dynamic analysis and their hybrids have all been tried but with onlylimitedsuccessinhandlinginput dependentbranchpredicates.
for static analysis we are only aware of which can detect appswitchingattacks.theirtool referredtohereasstadef scansanappforthecodeforobtainingtheinformationaboutthefocused appandthecodeforstartinganewactivity.iftheformerreaches the latter then the app is flagged as suspicious.
as a static analysis stadef can only report warnings about possible app switching attacksinasuspiciousapp whosecodemuststillbeinspectedbya human before any final decision can be made.
fordynamicanalysis general purposeguitestingtools suchas google s monkey randomized sapienz search based andstoat model based canalsobeusedfordetectingapp switching attacks with malicious guis visually inspected and confirmed by a human analyst .
however these tools have low coverage asevaluatedinsection asmanyinput dependentbranch predicates guiding malicious code may become true only after gui testing e.g.
when a targeted victim app is subsequently installed .
static and dynamic analysis can be used together.
fuzzdroid which combines symbolic execution enhanced static authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jie liu diyu wu and jingling xue analysis and dynamic fuzzing to expose the malicious behaviors in an app can be used for detecting app switching attacks.
however its symbolic execution mechanism cannot generate the test inputs required to satisfy all the input dependent branch predicates for two reasons.
first all such predicates form an exponential number of paths to be explored.
second its fuzzing technique only models some simple apis but a malware app can for example inspect the devicestatusbyusingmanydifferentapis.thus thechancesfor reaching some malicious code are still low as evaluated later .
our solution.
we present tdroid a market level approach that combines static and dynamic analysis to detect app switch ing attacks.
in its static analysis tdroid identifies suspicious startactivity callsleadingtosuchattacksinanappandtransformstheappintoanumberofrunnableslicescontainingpotentially app switching attacks one slice per attack.
in its dynamic analysis tdroidsimplyexecutestheserunnableslicesonanandroid device or emulator to expose the malicious calls hidden in theseslices.ahumananalystwillflagacall andtheunderlying app as malicious if its exposed ui screenshot is malicious as discussed in section .
therefore no false positives are produced.
the key novelty of tdroid lies in its use of a new triggerorientedslicingtechniqueforbuildingrunnableslicesthatallow app switching attacks to be exposed.
traditional slicing which reasons about data and control dependences does not apply since all the input dependent branch predicates that guide some maliciouscodecannotbeslicedaway.incontrast tdroidwillspecialize such predicatesso that the guided maliciouscode is forced to be always executed.
we have evaluated tdroid with a set of malware apps labeled with bank ransom or fraud in the android malware dataset .
these apps do not have the ground truth about app switching attacks.
statically tdroid finds suspicious startactivity callsin1062suspiciousapps.dynamically tdroidexposesuisin978outof1062apps with878appscontaining app switching attacks confirmed by a human analyst.
tdroid is fast by spending an average of .
seconds per app for the apps that are both statically and dynamically analyzed.
tdroidoutperformsthestateoftheartsubstantially.asastatic analysis tool for finding app switching attacks stadef r e portsonly1642suspicious startactivity callsin770suspicious apps also reported by tdroid with suspicious calls missedby tdroid.
note that such pure static error reports are not useful unless a human analyst actually reads the code of these apps.
in addition we have also compared tdroid with four representative general purpose analysis tools which can also be used fordetectingappswitchingattacks using20malwareapps withonefromeachdistinctmalwarefamily containing58suspicious startactivity calls identified by tdroid.
given a budget of 3hoursperapp google smonkey sapienz stoat and fuzzdroid have achieved their recall rates percentage hitratesforthesecalls as8.
.
.
and18.
respectively.
in contrast tdroid s recall rate is .
.
we have also evaluated tdroid using a set of goodware apps to confirm its effectiveness as a market level tool.
in summary this paper makes the following contributions with theartifactforreproducingallourresultsdownloadableat https tdroidtool.github.io anovelmarket levelsecuritydefense tdroid fordefeating app switching attacks via a hybrid analysis a new trigger oriented slicing technique for constructing runnable slices containing app switching attacks and adynamicanalysisforexecutingrunnableslicesonandroid devices or emulators to expose malicious guis.
background .
android components androidappsareconstructedfromfourtypesof components activity a window containing ui components service an operation running in the background broadcast receiver a listener responding to a system or app announcement and content provider a component managinga setof datashared with otherapps .
three ofthefourcomponenttypes activity service andbroadcastreceiver are activated by an asynchronous message called an intent.
activity lies at the heart of the android programming framework due to its event driven nature.
an activity acts as a container consisting of different gui elements e.g.
views and text boxes through which users interact with an app for transitions between differentactivities.conceptually anappexecutesalongtheactivity transition paths and other callbacks are sprawled out of them.
.
app switching attacks suchattacksaimtostealthefocusofthetop i.e.
foregroundapp .
thisisachievedwhenamaliciousappreplacesthelegitimatetop activitywithoneofitsown.appswitchingattackscanbeexploited for different purposes.
as a ui spoofing attack discussed in section3 a malware app waits until a specific victim app has been installed and then triggers an app switch with a fake ui requesting software update in order to lure users to download another malware app e.g.
a malicious version mimicking the victim app .
as a denial of service attack a malware app continuously monitors the device status to ensure that it is the top app and triggers an app switch otherwise possibly until a ransom has been paid.
.
intermediate representation ir given an app tdroid works on its jimple ir a three address bytecode ir constructed by soot .
thefollowing types of control flow statements exist jumps including goto return and throw treated as return two way branches for if statements and switches i.e.
multi way branches which are not desugared into two wayifstatements .thecfg controlflowgraph ofamethod is constructed in the standard way except for its explicit representation of jump statements and switch statements.
for convenience a basic block in a cfg consists of one single statement.
lets1ands2be two statements in the cfg of a method.
we write s1 ds2ifs2is data dependent on s1ands1 cs2ifs2is control dependent on s1.
motivating example figure1shows an example abstracted from bankun one of the most widespread malware families .bankunmasquerades as google play.
once executed it checks to see if the device has installedanyofthefivemajor legitimatekoreanbankingapps.if authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
tdroid exposing app switching attacks in android with control flow specialization ase september montpellier france 1public class notifications extends service 2public void oncreate super.oncreate checkstatus 5private void checkstatus int bk type string pack name for int j j config.bklist.length j if getinstalledpkgnames .contains config.
bklist bk type j pack name config.bklist intent bkmain new intent this bkmain.class bkmain.addflags intent.flag activity new task bkmain.putextra pkgn pack name if bk type bkmain.putextra bk startactivity bkmain ... else if bk type bkmain.putextra bk startactivity bkmain 26public class bkmain extends activity protected void oncreate bundle savedinstancestate super.oncreate savedinstancestate intent bkintent getintent if bkintent !
null logger.i uninstall bkintent.getstringextra pkgn switch bkintent.getstringextra bk case setcontentview r.layout.kb main activity return ... case setcontentview r.layout.sh main activity return figure the malware app bankun.
new version released.
please reinstall.
confirmnotification new version released.
please reinstall.
confirmnotification kb kookmin bank figure bankun s fake ui for software update bk type .
aparticularbankingappisinstalled bankunwillperformanapp switching attack to display a fake ui requesting software update to lure users to download a rogue version of the same banking app.
in addition bankunalso steals sms messages contacts and device information from the compromised devices.
without loss of generality the code for attacking two banking apps identified as and is given but the code for the other three identified as is similar and thus elided lines and .
the service named notifications lines monitors the device in the background.
in lines the device is checked foraninstalledbankingappin config.bklist withthelastone selected as the victim recorded in bk type andpack name .
in lines13 startactivity iscalledtostartanactivityoftype bkmainwith a fake ui requesting software update for the victim.
thebranchpredicateinline16 line21 isinput dependent guidingthemaliciouscodeinlines17 lines22 .inlines32 the activity bkmaindraws a fake ui for the victim targeted with different uis for different banking apps.
figure 2shows the fake uiforthebankingapp identifiedas0 requestinganewerbuta rogue version to be downloaded.
.
existing approaches the market level solutions reviewed in section andevaluatedinsection areineffectiveforvetting bankun.with purestaticanalysis stadef cannotdetectappswitchingattacks inbankun sincetherearethe startactivity callsformaking anappswitch lines18and23 butnotanycodeforcheckingthe focused app.
even if bankunis flagged as suspicious a human analyst must still read the code to know why it is malicious.
with pure dynamic analysis google s monkey sapienz and stoat will always fail if no targeted banking app in config.bklist is installed yet during testing in which case by type always .
evenif somebanking apps in config.bklist areinstalled thesetoolswillstillfailinexposing the malicious uis in bankunifcheckstatus is never triggered.
by combining symbolic execution enhanced static analysis and dynamic fuzzing fuzzdroid has achieved an improved coverage but will still be ineffective for bankun.
as the input dependent branchpredicateinline9cannotbemodeledaccurately by type 1is expected.
thus no startactivity call can be triggered.
.
the tdroid approach figure3gives an overview of tdroid.
given an apk file tdroid first performs a static pre analysis to look for all suspicious startactivity calls that may lead to app switching attacks.
wefocuson startactivity sinceitisthemostwidelyusedapi forstartinganactivityingoodwareandmalware .however our approach can be generalized to handle other activity starting apis.
tdroid then handles each suspicious startactivity call separately.
tdroid first constructs its runnable slices in static backward slicing and then executes these slices in dynamic execution toexposethemalicious startactivity call byexposing malicious uis .
as malicious activities of different class types may be started at the same startactivity call different slices as highlighted may be generated one per malicious activity.
wewillfocusonthesuspiciouscallinline18 identifiedas i18.
the others in lines and are handled similarly.
.
.
pre analysis.
the objective is to identify all suspicious startactivity calls that may lead to app switching attacks.
astartactivity call in an app is suspicious if it satisfies two conditions section the app is currently running in the backgroundand thecall startactivity maycausethelegitimate top activity to be replaced by one of his own activities.
fori18 bankun is activated by a call to notifications.oncreate lines a non user driven callback.
thus i18can be triggered when bankunruns in the background.thenanactivityoftype bkmaincanbeopened.based on the attribute of the intent object line bkmain passed to i18 the opened activity can be the top activity.
thus i18is a suspicious call.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jie liu diyu wu and jingling xue static backward slicing trigger oriented slicingcontrol flow specializationslice slice n....slice slice n....runnable slice runnable slice n....runnable slice runnable slice n.... static backward slicing trigger oriented slicing control flow specialization slice slice n.... runnable slice runnable slice n.... dynamic execution repackaging downsized apk execution mobile emulator screenshots of malicious uissuspicious startactivity calls apk apk pre analysis conditions for app switching attacks apk s pre analys is pre analysis conditions for a pp switching attack s conditions for app switching attacks figure a schematic overview of the components in tdroid.
.
.
static backward slicing.
for each suspicious startactivity call we first apply a novel trigger oriented slicing technique to generate backward slices with specializable branchpredicatesforthecall.werelyonthefollowinginsightto identify heuristically specializable branch predicates.
property .
letsbe a backward slice computed for a method m. let pbe a branch predicate in m.i fpcontrols only one single non empty execution path in s such that pdoes not read the same memoryaddressthatisalsoreadalongthepath then pisspecializable to always execute that path only.
we then apply a new control flow specialization technique to both addthemissingcontrol flowstatements includingjump statements in the methods contained in these slices and specialize the specializable and missing branch predicates thus added.
tdroid is simple and efficient in terms of generating and running the slices thus obtained as evaluated later .
giveni18 we compute some backward slices affecting i18.
the class type for its associated activity is bkmain lines .
so only one slice will be generated.
we start with the slicing criterion scbkmain i18 i.e.
the three statements identified by their line numbers.
in addition to line we have also included lines33and36sincethesearewherethemaliciousuisaredrawn inthecallbackmethod bkmain.oncreate triggeredatline18 despite the fact that lines and appear lexically after line .
trigger oriented slicing.
traditionally the backwardslicecomputedfor scbkmain i18 consistsoflines6 .thus theinput dependentpredicatein line16isincluded.asdiscussedearlier applyingaguitestingtool to such a slice will hardly expose the hidden malicious behaviors.
tocompute thebackwardslice for scbkmain i18 tdroidproceedssimilarlyastraditionally exceptthatcertaininputdependent branch predicates are flagged as specializable property1 .notethatapredicatethatisinitiallyspecializablecanbecome non specializable as the slice grows.
for i18 bk type inline16willbespecializedwithabooleanconstanttoensurethat i18is always triggered.
as a result all the statements affecting the definitions of bk type are no longer in the slice.
trigger oriented slicinghastwobenefits.first itislightweight costing22.2seconds perappinourevaluation.second itimprovesthecodecoverage of a subsequent dynamic analysis.
let us see how tdroid computes the slice from scbkmain i18 with the initial slice being tbkmain i18 scbkmain i18 .
at this stage no branch predicates arespecializableyet.letusstartfromlines33and36.as c33and32 c36 line32isaddedto tbkmain i18 .aslines33and36 are in two different branches controlled by line property 1is violated.
so line is not specializable.
as c32 line is added to tbkmain i18 .
line is not specializable by property as the variable bkintent used in line is also used in line .
letusnowstartfromline18.as d32isadatadependence through the intent object associated with i18 line is simply addedtotbkmain i18 .as16 c17and16 c18 line16isadded totbkmain i18 .n o w tbkmain i18 .b y property line16isflaggedasspecializablesinceitdoesnotuse anyvariablealsousedinthesinglepath lines17and18 controlled byline16 in tbkmain i18 .notethatthestatementsthatdefinethe values used at specializable predicates are ignored.
finally d17 d18 d30 and29 d32.s ow e obtaintbkmain i18 with line as the only predicate flagged as specializable.
notifications.checkstatus label1 if true goto label3 if true goto label2 label2 goto label1 label3 intent bkmain new intent this bkmain.
class if false goto label4 bkmain.putextra bk startactivity bkmain return label4 if true goto label5 label5 return bkmain.oncreate intent bkintent getintent if bkintent null goto label1 switch bkintent.getstringextra bk case setcontentview r.layout.kb main activity return case setcontentview r.layout.sh main activity return default goto label1 label1 return label3 intent bkmain new intent this bkmain.
class if false goto label4 bkmain.putextra bk this.startactivity bkmain intent bkintent getintent if bkintent null goto label1 switch bkintent.getstringextra bk case setcontentview r.layout.kb main activity case setcontentview r.layout.sh main activity figure the simplified slice for i18in soot s jimple ir after control flow specialization.
the statements in tbkmain i18 are highlighted in with line marked in .
the statements in tbkmain i18 tbkmain i18 appear in the white background.
control flow specialization.
figure4displays the slice tbkmain i18 in soot s jimple ir consisting of the statements highlightedinthered background .the branchpredicate inline has been specialized so that line is always triggered.
this slice is not yet runnable as some jump statements for ensuring its correct execution are missing.
instead of complex algorithms for adding missing jumps tdroidadoptsasimpleyeteffectiveapproach.foreverymethod authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
tdroid exposing app switching attacks in android with control flow specialization ase september montpellier france mintbkmain i18 there are two steps.
first we add all missing control flowstatements in mtotbkmain i18 toobtain arunnable slice tbkmain i18 .infigure theaddedstatementsin tbkmain i18 tbkmain i18 appearinthewhitebackground.second thenewlyaddedbranch predicates in lines and are specialized to execute some fixed branches section .
.forline8 correspondingtoaloop theloop body is always skipped.
for each if statement in lines and either branch can be specialized as being taken.
notifications.checkstatus label1 if true goto label3 if true goto label2 label2 goto label1 label3 intent bkmain new intent this bkmain.
class if false goto label4 bkmain.putextra bk startactivity bkmain return label4 if true goto label5 label5 return bkmain.oncreate intent bkintent getintent if bkintent null goto label1 switch bkintent.getstringextra bk case setcontentview r.layout.kb main activity return case setcontentview r.layout.sh main activity return default goto label1 label1 return label3 intent bkmain new intent mainactivity .ctx bkmain.
class if false goto label4 bkmain.putextra bk intent bkintent getintent if bkintent null goto label1 switch bkintent.getstringextra bk case setcontentview r.layout.kb main activity case setcontentview r.layout.sh main activity 16l1 bkmain.addflags intent.flag activity new task l2 super.oncreate savedinstancestate l3 reachreport.reporttargetreached mainactivity .ctx.startactivity bkmain mainactivity .ctx mainactivity .ctx figure a repackaged version of figure 4with all the changes shown in the blue background .
.
.
dynamic execution.
werepackage tbkmain i18 toadownsized apk file to expose its malicious ui by dynamic execution.
public class mainactivity extends activity 2public static context ctx 3protected void oncreate bundle bundle 4super.oncreate bundle 5ctx getapplicationcontext 6new notifications .checkstatus figure6 thelauncheractivityofthedownsizedapkfor i18.
repackaging.
in figure checkstatus is the entry method to activate i18.
we make use of the launcher activity in figure 6to call checkstatus even if it is non public on anotifications object created ourselves rather than by the android framework .
thus in lines and of figure this of type notifications can no longer be used as a context object.
rather as shown in the repackaged version in figure a contextobjectoftype contextthatismadeavailableinastaticfield mainactivity.ctx is used instead.
l1is added to force an app switch since this is possible originally section .
.
.
as the android framework is not modeled accurately during the slicing some data and control dependences related to callbacks are missing.
l2 as the super call in bkmain.oncreate is added.
finally l3is added so that screenshots are taken and analyzed.
execution.
we install the downsized apk for i18on an unmodified android phone or emulator and then execute it to exposethemaliciousuiinfigure .similarly themaliciousuisfor the other four banking apps can also be exposed.
app switching attack astartactivity call issuspicious in opening a top activity if itsatisfiestwoconditions theappcanruninthebackground and theappcanreplacethelegitimatetopactivitywithoneof its own to therefore steal the focus to become the focused app .
.
background running apps fora startactivity call itscontainingappcanruninthebackgroundifthecallcanbeactivatedbyanon user drivencallback.
user drivencallbacks manageuserinteractions including lifecycle callbacks for activities and ui components e.g.
dialogs and menus defining some changes to their visible state run time eventsandbehaviors and guieventhandlercallbacks respondingtouseractions e.g.
clickingabutton .
non user drivencallbacks requirenodirectuserinteractions includingthelifecyclecallbacks forservices e.g.
service.oncreate broadcastreceivers e.g.
broadcastrecevier.onreceive and content providers e.g.
contentprovider.oncreate .
bankuninfigure 1canbeactivatedtoruninthebackgroundby the non user drive callback notifications.oncreate line .
.
app switching an activity that is opened at a startactivity can become a topactivity determinedbythreefactorsreportedin theclass type of the android component from which the call is made the launchmode attribute for the opened activity and the flags set for itsassociatedintentobject.inthispaper wefindthatafourthinfluencing factor the taskaffinity attribute of the opened activity is also relevant.
table1 theninescenarioswherestartactivity canopena top activity where as usual means don t care .
receiver type of startactivity launchmode taskaffinityintent flags flag activity non activity new task activity new task clear task activity singletop new task multiple task activity standard new task multiple task activity singletask clear task activity singleinstance activity singletop non default new task activity standard non default new task activity singletask non default as android s official documentation does not state clearly when an opened activity can become a top one we have developed a tool as in to explore all possible combinations of the four factors.werestrictourselvestoandroid4.
oneofthemostwidelydistributedversions.however thebasicprinciplebehindappliestootherversions.table 1givesatotalofninescenariosforanactivity to become the top one with the last three being new.
considerthe startactivity calli18infigure 1thatisexamined in section .
the class type of the receiver object on which startactivity iscalledisa notifications service.inaddition its associated intent bkmainis set with the flag new task .
thus i18is suspicious falling into the first casein table regardless of the class type of any activity that may be opened.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jie liu diyu wu and jingling xue the tdroid design we describe our algorithms for realizing the five components in tdroid depicted in figure .
given an app tdroid works on its jimpleir section bytakingasinput thecallgraph cgforthe app the cfgs of its methods data and control dependences and thealias information in cg .in section wewillexplain how are obtained in our implementation.
given an app pre analysis is first performed to find all the suspicious startactivity callsincg.foreachsuspiciouscall i our static analysis comes into play first.
trigger oriented slicing first obtains a set t i of slices for i one per malicious activity that may be opened at iand control flow specialization then expands it into a set t i of runnable slices by performing branch predicatespecialization.next ourdynamicanalysistakesover.for eachrunnableslice repackaging firstturnsitintoadownsized apk file and execution then takes care of executing it on an android device or emulator to expose the malicious ui.
.
pre analysis for each startactivity calli we check to see if it is suspicious by verifying the two conditions in section .
our subsequent algorithmsapplytoeachsuspiciouscallinisolation.inourexample discussed in section .
.
i18is suspicious.
.
trigger oriented slicing givenasuspicious startactivity calli algorithm named toslicer generates a set t i of slices interprocedurally one slicett i for each class type tassociated with the malicious activities opened at i. for simplicity we assume the absence of static variables in the app considere d. however global variables can be handled in the standard manner .
let us start with toslicer line s .
we first find the set of classtypesfortheopenedactivitiesat i line3 .foreachclasstype representing suspicious activities lines and we then set up its slicingcriterion sct i line9 andcallinterslicertocompute interprocedurallyabackwardslicestartingfromallthepointsin sct i one at a time lines .
at this stage all branch predicates are not specializable yet lines .
to set up sct i weincludenotonly ibutalsoalltheui drawingcalls e.g.
calls for modifying the ui contents in dialog activity or window that can be reached from all the lifecycle callbacks of class tincg.
let us now consider interslicer lines .
interslicer computes a backward slice interprocedurally from the statement s as is done traditionally except that certain branch predicates are flagged as specializable property .
therefore it suffices to explain only the parts inside the three blue boxes.
in line we ignore all the statements that define the values used at a specializablebranchpredicate.inlines26 weflaganewlyaddedbranch predicate as specializable if property 1is satisfied.
in lines werecognizethatapredicatethatwaspreviouslyspecializableis no longer specializable as tt i has grown big .
thus the slicing process must now be restarted from these predicates line .
itiseasytocheckif s containedinmethod m satisfiesproperty ornot.tmisthecurrentslicefor m line16 .let s1 snbethe nsuccessors of sin the cfg of m denoted gm.
let p si be the setofbasicblocks confinedwithin tm reachablefrom si whichalgorithm trigger oriented slicing.
input i output t i 1function toslicer 2t i 3setofacttypes set of types of the activities opened at i 4foreacht setofacttypes do ifiis suspicious with respect to t section4 then tt i foreachbranch predicate sin cgdo s.spec false sct i iand all the ui drawing calls reachable in the lifecycle callbacks of class tincg foreachs sct i do tt i interslicer s tt i t i tt i 13returnt i 14procedure interslicer s tt i 15letmbe the method containing statement s 16tm s prime primeis contained in m s prime prime tt i 17worklist s 18whileworklist nequal do s worklist .remove tm.add s foreachs prime nelementtmin the cfg of mdo ifs prime ds sis not a predicate !s.spec then worklist .add s prime else ifs prime csthen worklist .add s prime ifs primesatisfies property 1then s prime.spec true foreachs prime s prime prime tm s prime prime.spec true do ifs primedoes not satisfy property 1then s prime.spec false worklist .add s prime 32tt i tm 33ifany statement in tmuse any of m s parameters then setofcallsites set of call sites for mincg foreachs prime setofcallcites do tt i interslicer s prime tt i 37returntt i includes siitself in gm.
we know that ssatisfies property 1when the following two conditions are met.
there exists only one unique lessorequalslanti lessorequalslantnsuch that p si is non empty.
this can be done by performing a standard control flow reachability analysis on gm.
let abe a memory address read by any statement s primeinp si directlyorindirectlyif s primeisacallsite .then sdoesnotalsoread from a. this can be done based on the def use chains for local variables and alias information for field accesses .
in our example the class type of the activities opened at i18 isbkmain.
given that scbkmain i18 the final slice tbkmain i18 computed is given in section .
.
where line is specializable.
thus t i18 tbkmain i18 .
.
control flow specialization given a slice tt i algorithm 2transforms and expands it into arunnableslice tt i byperformingtwoflavorsofcontrolflow specialization.inourexample figure 4demonstratesthetransition fromtbkmain i18 totbkmain i18 fori18.
in lines we specialize every specializable branch predicate identified in tt i to always execute the only branch contained authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
tdroid exposing app switching attacks in android with control flow specialization ase september montpellier france algorithm control flow specialization.
input tt i output tt i 1function cfspec 2foreachbranch predicate sintt i s.t.s.spec truedo specialize it to execute its unique branch in tt i 4tt i tt i 5foreachmethodm contained in tt i i nc gdo add the missing control flow statements of mtott i foreacheach thus added branch predicate sdo ifsrepresents a branch predicate for a loop then specialize sto skip its associated loop body else ifsreaches along any of its branches say b a statement of mintt i then specialize sto execute b else specialize sto execute any of its branches 14returntt i intt i .
in our example bk type in line is specializable forcingi18to be always executed in figure .
in lines we add all the missing control flow statements including jump statements contained in the methods in tt i so thattt i is runnable.
in figure fori18 all such newly added control flow statements in tbkmain i18 tbkmain i18 are showninthewhitebackground.foreverynewlyintroducedbranch predicate which is guaranteed not to control any statement in tt i by construction it is specialized depending on which of the three cases it falls into lines .
in figure fori18 tbkmain i18 tbkmain i18 contains three such branch predicates in lines and of the original app in figure which are specialized respectively according to the three cases in that order.
.
repackaging givenarunnableslice tt i wewillrepackageitintoanapkfile.
there are four tasks illustrated using our example.
first we create the launcher activity mainactivity fortt i .
the one for tbkmain i18 is given in figure .
let m1 mn be the predecessor less methods regardless of their access modifiers backwards reachable from iincg.
let cibe the class where miis defined.
for each mi we add new ci .mi t o mainactivity .
fortbkmain i18 as shown in figure new notifications .checkstatus is added.
second each object of c ithus created can no longer request app level operations such as launching activities.
regardless ofthe object used for calling startactivity ati we replace it by a context object of type context stored in a global variable mainactivity.ctx as demonstrated for i18in figure line and figure lines and .
for tt i an opened activity of type tcan be the topactivity.
thus wesimply setthe attribute of the intent associated with ias new task e.g.
line l1 for i18in figure5 so that this is also true for mainactivity.ctx .
third astheandroidframeworkisnotmodeledaccurately some data and control dependences may be missing.
given tt i w eexamine each of the lifecycle callbacks in class t. we add each missing super call e.g.
line l2 for i18in figure t ott i .
finally we inject code into the lifecycle callback oncreate of class tfortt i the entry method for the opened activity of type t in order to capture the malicious ui shown.
for i18 this is done by the call in line l3 in figure .
.
execution foreachrepackagedapkfile werunitonanandroiddeviceoremulatortoexposeitsmaliciousui.thescreenshotcapturedfor i18inbankunisgiveninfigure .ahumananalystcanseeclearly thatbankun which masquerades as google play is malicious.
evaluation wehaveevaluatedtdroidusingbothgoodwareandmalwareapps.
with goodware which do not contain app switching attacks we showthattdroidisbothefficientandeffectiveasamarket level vetting tool.
with malware we both confirm this finding and show furtherthattdroidoutperformsthestateoftheartindetecting substantially more app switching attacks.
below we first discuss ourresultsforgoodwarebrieflyandthenourresultsformalware extensively.
withgoodware wehaveusedatotalof85androidappsfromthe popularandroidapprepositoryf droid .tominimizebiases towardscertainappcategories weselectedtop5appsfromthetop chartsinall17appcategories on23march2018 .tdroidanalyzeseach app in .
seconds on average.
statically tdroid finds suspicious startactivity callsin6apps mqttpublisher plugin kwik efis linphone little sir echo etesync and clock .
dynamically tdroid exposes the uis in of these7calls mqttpublisher plugin kwik efis linphone little sir echo etesync and clock .
for the startactivity call in etesync tdroid has failed to expose its ui.
in this case the underlying slice is incomplete since some data dependencies related to ipc inter process communication are missing.
the times in seconds elapsed on analyzing these seven apps are mqttpublisher plugin .
kwik efis .
linphone .
little sir echo .
etesync .
and clock .
.
as benign apps rarely open a top activity when running in the background as expected tdroid reports only afew suspicious startactivity calls.
in addition tdroid can analyze such real world apps efficiently and effectively.
with malware we address three research questions rqs rq1.cantdroiddetectappswitchingattackseffectivelyand efficiently with a hybrid static dynamic analysis?
rq2.is tdroid more effective than special purpose tools developed for detecting app switching attacks?
rq3.is tdroid more effective than general purpose tools that can also be used to find app switching attacks?
we consideranew popularandroid malwaredataset .we started by selecting a set of all the malware apps from all the 26families widelyusedin labeledwith bank ransom or fraud .
however apps cannot be decompiledby dexpler successfully.
we have finally settled with a set of 3814malwareapps.despitethelabels theseappsdonothavethe ground truth about any hidden app switching attacks.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jie liu diyu wu and jingling xue to address rq1 we show how tdroid can for the first time detectwhichofthese3814appsdefinitelycontainappswitching attacks.
to address rq2 we show that tdroid s static analysis can discover more suspicious startactivity calls and more suspicious apps than stadef the only special purpose tool available which applies static analysis to detectingapp switching attacks.toaddressrq3 weshowthattdroidcanfindsubstantially moreapp switchingattacks thanthreerepresentativeguitesting tools google smonkey sapienz andstoat aswell as a hybrid analysis tool fuzzdroid .
implementations.
wehaveimplementedtdroidinsoot inabout8klocofjavacode.givenanapp inanapkfile wefirst usedexpler toconvertitsdalvikbytecodeintosoot sjimple ir.wethenrunflowdroid onthejimplecodetobuildacall graphfortheapp.flowdroidachievesthisbyworkingwithsoot s pointeranalysis spark tocreate adummy main consistingof the callbacks found iteratively in the app.
we make use of the data and control dependences alias information and the cfgs forthemethodsinthecallgraphprovidedbysoot.inparticular thedatadependencesforthe extras storedintotheintentfora startactivity call are tracked.
for example in section .
.
d32isfoundbylinkingtheuseof bk at getstringextra inbkmain.oncreate line with its definition in putextra innotifications.oncreate line .
for stadef we have implemented it based on the algorithm described by its authors as it is not open sourced .
for google s monkey sapienz stoat andfuzzdroid we use their open source tools.
tdroid runs on a desktop computer while the app being analyzed runs on an android emulator.
the android debug bridge adb is used to facilitate communication between the desktop and emulator.
google s monkey sapienz stoat and fuzzdroid operate similarly.
experimental setup.
ourdesktopcomputerrunsona64 bit ubuntu16.04with8cores .20ghzintelxeon r cpu and256gb ram.ourandroidemulatorisanexus5withthekitkatversion sdk .
api level one of the most widely distributed android versions.
the analysis time of an app is the average of runs.
.
rq1 tdroid s effectiveness and efficiency figure7depicts our results on analyzing the malware apps from malware families.
statically tdroid finds suspicious startactivity calls in suspicious apps spreading across 20outofthe26malwarefamilies inanaverageof16.4secondsper app.dynamically tdroidhassucceededinrunning92.
of the suspicious apps to completion with .
being malicious confirmedbyvisualinspection inanaverageof160.
seconds including both the static and dynamic analysis times per app.theseresultsdemonstrateagaintdroid seffectivenessand efficiency making it deployable as a market level vetting tool.
tdroidfailedinexecuting84suspiciousapps.for49ofthese apps their original apk files are faulty not executable .
for the remaining35apps theirrepackagedapkfilesareincompletesince their underlying slices are incomplete due to e.g.
the unsound handling of reflection and the android framework in soot .
.
.
.
.
.
.
0102030405060percentage distribution apps a apps analyzed b attack classification bankbot simplelocker bankun spambot golddream c selective screenshots produced figure7 thetdroidresults.theappswitchingattacksfallinto six categories 1sensitive data theft 2phishing ui spoofing 3loss of availability 4malware infection suspicious webviews and 6admin privilege escalation.
let us examine the results in figure 7in more detail.
figure a dividesthe878maliciousappsintosixcategories withtheirpercentage distributions shown in figure b and their representative malicious uis in figure c .
loss of availability is the mostly dominantattackcategory .
followedby phishing .
andthen sensitivedatatheft .
.somemalwareapps .
exploit an admin privilege escalation attack to lure users to give theiradminprivilegestopreventthemfrombeinguninstalled.some malware apps .
e.g.
bankun attempt to injectnew malware appsintothecompromiseddevices.others .
displaymalicious webviews with possibly malicious urls.
to examine tdroid further we have randomly picked one sample from each of the families containing suspicious startactivity calls.
table 2shows the malware samples selected column our results columns and the types ofattackslaunched column7 .tdroidfindsstatically58suspicious startactivity callsandexposesdynamicallytheirassociated uisin of thesecalls in under55 minutes withan average ofaboutoneminutepercall .fortheremaining3calls theircorresponding slices are incomplete as mentioned above .
for one infakeavand one in slembunk some data dependencies through sharedpreferences aremissing.foranotheronein slembunk its associated intent object is incomplete.
for the startactivity calls with exposed uis are malicious and the remaining four which reside in fakedoc fakeplayer nandrobox and zitmo are benign.
thus the other 16appsare malicious capableoflaunching appswitchingattacks.
.
rq2 special purpose detection stadeffinds1642suspicious startactivity callsin770apps in .
seconds per app on average.
as discussed earlier tdroid authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
tdroid exposing app switching attacks in android with control flow specialization ase september montpellier france table effectiveness and efficiency of tdroid in handling a set of selected malware samples.
apk md5tdroidattack types of suspicious startactivity calls of calls with exposed uis of malicious calls time secs aples 0c9eccbd1f0ed4ed29178f5b2f785b7f .
bankbot 2ba4663a14899854fff429a6d6035cc2 .
bankun 110001afe867f8e1e79790b2336ec96d .
fakeav 418b5b165ac8b2d9611a4c7acdff0c8c .
fakedoc 063846036d6b5d45998879ae2cc142ab .
fakeplayer 2337a421045aaebe2be6497dab822826 .
fusob 63c980138792a5fab4fd6e5f1ac6a938 .
golddream 31ff6d0c28cae40d2e97fa7770973fdd .
gumen d30e857aaba02275c54b76badb1bc855 .
jisut 004d0c40db80d291804c44d531bf7b64 .
koler 1e341a93ea251267b7af6548f49752f5 .
nandrobox 4d871daec6a4270a70f42800f9a932f2 .
roop 7584538eb727cc7acf57c3b1b55ff8e3 .
simplelocker 0b7e470f80205786e00e277fc1d4c224 .
slembunk 41c9add2be9f4b04047ab232eb08058f .
smszombie 0e5dd82f8aeddc76160576c512804930 .
spambot 0c5b3709f970af266393d0206633dec6 .
svpeng 9a0617349c91000b04a0cf887c63c40e .
triada de52d8cbccdb32dbdf576966031bf2bd .
zitmo 003bb03ec84313dc73a86af3876a128d .
total .
024681012stadef tdroidtdroid stadef figure comparing tdroid and stadef on detecting suspiciousstartactivity callsinthe20selectedmalwareapps.
finds suspicious calls in apps in .
seconds per app onaverage.stadefreports63 suspicious callsmissedbytdroid butonlyasubsetofsuspiciousappsreportedbytdroid.intotal tdroid has found malicious startactivity calls in malicious apps which are not flagged as suspicious by stadef.
itisimportanttonoteagainthatstadef asapurestaticanalysis tool isnotsuitableforvettingapps sinceahumananalystmuststill read the code of all suspicious apps to make a final decision.
forthe63suspicious startactivity callsreportedbystadef but missed by tdroid we have inspected their relevant code.
due to obfuscation it is unclear whether of these calls are malicious ornot.passingthemtotdroidisstillinconclusiveastheytryto access a database that could not be reproduced in our emulation environment.theremaining48callsareallmalicious capableof launching app switching attacks.
tdroid has missed these callssincetheyareallmadefromasynchronoustasksstartedbyuser driven callbacks e.g.
onclick when these malicious apps are initially running in the foreground.
given these calls tdroid can expose their malicious uis in .
seconds each.
figure8showsthattdroidismoreeffectivethanstadefinfindingsuspicious startactivity callsinthe20selectedmalware apps .asdiscussedinsection .
tdroidreports58suspiciouscalls ofwhich51aremalicious in16apps.incontrast stadef reports only25 suspiciouscalls also reportedby tdroid whichareallmaliciousin10apps.inparticular stadefmissesappswitching attacks in the six malicious apps bankun golddream gumen simplelocker smszombie andspambot.
recallthattdroidfinds no attacks in fakedoc fakeplayer nandrobox andzitmo.
.
rq3 general purpose detection we compare tdroid with four representative general purpose tools google s monkey randomized sapienz search based stoat model based and fuzzdroid which all involve executing an app to expose its malicious behaviors.
the first three aim for high coverage while the last attempts to reach a particular program point.
therefore the criterion used here is the recallrate measuredasthepercentagehitrateforthesuspicious startactivity detected by tdroid s static analysis.
for these four tools the per app budget allocated hours.
table comparing tdroid with google s monkey sapienz stoat and fuzzdroid in terms of their ability in exposing the malicious uis for the suspi cious startactivity calls found by tdroid s static analysisin the selected malware apps .
tool of suspicious calls reached monkey .
sapienz .
stoat .
fuzzdroid .
tdroid .
table3showsthattdroidissignificantlymoreeffectivethan the state of the art in exposing the malicious uis hidden at the58 suspicious startactivity calls found by tdroid s static analysisinthe20selectedmalwareapps .thisismainly because these existing tools cannot handle effectively the inputdependent branch predicates which come in a variety of flavors in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france jie liu diyu wu and jingling xue malwareapps.forexample manymaliciousapps suchas aples spambot andgolddream launch app switching attacks after some system broadcasts e.g.
reboot completed network connectivity changed and device woke up are sent.
to improve the coverage i.e.
recall rate of google s monkey .
sapienz and stoat inject system level events randomly but are only marginally more effective with their recall rates being .
and .
respectively .
to go further fuzzdroid applies static analysis to model system broadcasts and generates candidate environments with dynamic fuzzing toreach a particular code location.
however due to its incomplete handlingofsystemapisandeventdependencies amongothers fuzzdroidisonlyrelativelymoreeffective at18.
.byapplyingtrigger orientedslicing tdroidcanavoidevaluatingexplicitly many input dependent predicates achieving a recall rate of .
.
.
limitations tdroid performs its trigger oriented slicing for an app on a call graph built by flowdroid together with soot s spark pointer analysis in the soot framework.
as reflection is handled only partially in soot the call graph may be incomplete.
this can be improvedbyincorporatingamorepowerfulreflectionanalysistool .
in addition flowdroid does not support intercomponent communication icc .
currently the data dependences for the extras added to the intent objects at startactivity aretracked.thecallgraphcanalsobeincompletethisway.this can be improved by adding an icc analysis .
persistent storage apis such as sharedpreferences are widely used in android apps.
therefore the statements operating on persistent data by these apis can be distributed throughout an app.
currently we do not model thedata dependencies through persistent storage resulting in incomplete slices sometimes section .
.
related work gui security.
earlier papers show the possibility of launching ui spoofing and denial of service attacks in android by playing tricky maneuvers on the currently active task oftheforegroundapp.inparticular feltetal.
assesstherisk ofphishing attacksonmobiledevices drivenbyinter appcontrol transfers.ren etal.
study thetaskhijacking attacksinwhich theattackercanlettheactivitiesofamalwareappresidesideby sidewiththoseofavictimappinthesametaskandhijacktheuser sessions of the victim app.
chen et al.
reveal that gui confidentiality can be breached by a shared memory side channel.
he et al.
investigatebroadlyanumberofapi relatedcompatibility issues in android apps due to api evolution.
several techniques exist for defeating gui attacks .
bianchietal.
introducestadef thestaticanalysiscompared with tdroid and an on device defense for mitigating gui attacks includingappswitchingattacks .renetal.
alsoproposean on device defense for rooted devices.
in this paper we focus on developing a market level hybrid analysis for defending against app switching attacks.
programslicing.
therehavebeenmanyextensionsofweiser s slicing technique including thin slicing path slicing and tailoring .
there are others focusing on handling jumpstatements unstructured programs jumps and switches and exceptions .
toobtaindatadependencesrequiredinslicing thealiasinginformation in the program can often be computed by applying a pointer analysis algorithm .
inthispaper tdroidproducesrunnableslicesbyconsidering not only data and control dependences as in the prior work but also control flow specialization in order to expose the malicious uis easily.
guitesting.
toimprovethecoverageofgoogle smonkey throughoptimizingtestsequences sapienz embracesmultiobjectivesearch basedtestingandstoat resortstoautomated model based testing.
dynodroid applies an observe selectexecuteprincipletogenerateuiandsysteminputs.evodroid adoptssegmentedevolutionarytestingtoimprovecoverage.puma isaprogrammableuiautomationframeworkforimplementing various state based test strategies.
some other recent work for facilitating gui testing can also be found in .
despite these advances gui testing tools are still poor in test coverage.
in contrast tdroid has significantly improved coverage for detecting app switching attacks by applying a new triggeroriented slicing technique.
hybridanalysis.
appdoctor combinesstaticslicingand dynamic execution to find bugs triggered by user actions.
credminer proceeds similarly to study the prevalence of unsafe developercredentialuses.however itexecutesslicesinacustom engine requiring a precise model of the android os and libraries.
harvester isdesignedtoextractruntimevaluesfromandroid apps by executing a traditional backward slice of an app on an android device or emulator to log the values of interest such as someclassandmethodnames.fuzzdroid whichiscompared with tdroid in section .
combines static analysis and dynamic fuzzingtogeneratecandidateenvironmentstosteeranapptowards acodelocation.bothharvesterandfuzzdroidneedtohandle adequately a large number of system apis in android.
in this paper tdroid combines a novel trigger oriented slicing approach and dynamic execution to find app switching attacks effectively.
conclusion we have introduced a new market level approach tdroid for detectingappswitchingattacksinandroidapps bycombininga trigger oriented slicing technique and dynamic execution.
tdroid issubstantiallymoreeffectiveindetectingappswitchingattacks thanthe stateof theart.
inaddition tdroidhastwo otherimmediate benefits.
first tdroid can be used to extract dynamic values from android apps that are of interest to a human analyst such as sms messages and reflective call targets.
second tdroid can help gui testing tools improve their coverage.