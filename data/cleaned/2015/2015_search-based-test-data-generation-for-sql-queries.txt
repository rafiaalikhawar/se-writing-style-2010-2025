search based test data generation for sql queries jeroen castelein1 maur cio aniche1 mozhan soltani1 annibale panichella1 arie van deursen1 1delft university of technology 2snt university of luxembourg jeroencastelein11 gmail.com m.f.aniche m.soltani a.panichella a.vandeursen tudelft.nl abstract database centric systems strongly rely on sql queries to manage andmanipulatetheirdata.thesesqlcommandscanrangefrom very simple selections to queries that involve several tables subqueries andgroupingoperations.and aswithanyimportantpiece of code developers should properly test sql queries.
in order to completely test a sql query developers need to create test datathat exercise all possible coverage targets in a query e.g.
joins andwherepredicates.andindeed thistaskcanbechallenging and time consuming for complex queries.
previous studies havemodeled the problem of generating test data as a constraint satisfactionproblemand withthehelpofsatsolvers generatethe requireddata.however suchapproacheshavestronglimitations such as partial support for queries with joins subqueries andstrings whicharecommonlyusedinsqlqueries .inthispaper we model test data generation for sql queries as a search based problem.
then we devise and evaluate three different approaches basedonrandomsearch biasedrandomsearch andgeneticalgorithms gas .thega inparticular usesafitnessfunctionbased on information extracted from the physical query plan of a databaseengineassearchguidance.wethenevaluateeachapproach in queries extracted from three open source software andoneindustrialsoftwaresystem.ourresultsshowthatgaisableto completely cover .
of all queries in the dataset requiring onlyafewsecondsperquery.moreover itdoesnotsufferfromthe limitations affecting state of the art techniques.
ccs concepts software and its engineering software verification and validation search based software engineering keywords search basedsoftwareengineering automatedtestdatageneration sql databases.
acm reference format jeroencastelein1 maur cioaniche1 mozhansoltani1 annibalepanichella1 arievandeursen1.
.search basedtestdatagenerationforsqlqueries.
inproceedingsoficse 40thinternationalconferenceonsoftwareengineering gothenburg sweden may june icse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden copyright held by the owner author s .
publication rights licensed to association for computing machinery.
acm isbn ... .
introduction sql queries form the heart of database centric applications which can range from systems dealing with customer relations to applicationsmanaging medicaldata forhospitals.
softwareengineers are thenrequiredtotestsuchsqlqueriesasintensivelyastheytest program code.
however the complexity of generating test data requiredtofullytestasqlquerygrowstogetherwiththecomplexity of the query itself.
consider a sql query that joins two tables and contains two predicates select items.
frominvoice joinitems oninvoice.id items.invoiceid whereamount ortaxfree true this sql query returns all items of invoices that either have amount greater than or that are tax free.
to test this query rigorously the tester may want to follow some coverage criteria such as to exercise all branches that can be executed in this sql query.thus thetesterneedstotarget1 thejoinrelation the left predicate amount to be evaluated to true the right predicate taxfree true to be evaluated to true.
for that to happen the two tables should contain the right data thatsatisfies each of these targets.
while in this illustrative example generating test data can be done by a human in more complex cases e.g.
queries with multiple joins predicates and subqueries the number of targets grows and the generation of data that test all the branches of a sql query becomes a difficult and time consuming task.
researchers have proposed approaches to automatically generatetestdatatosupportdeveloperstestingsqlqueries .
these approaches transform the test data generation problem into a constraint satisfaction problem .
subsequently they use constraintsolvers suchasalloy andchoco togeneratetest datasolvingtheconstraints.however suchapproachessufferfrom twoimportantproblemsthatmaypreventthemfrombeingused inlargesoftwaresystems first duetolimitationsoftheexisting constraintsolvertools theseapproachescommonlydonotsupportstringsandanykindofstringmanipulation.secondly mappingtheentiresqllanguagetoaconstraintsatisfactionproblemisahighly complextask.asaconsequence theseapproachescommonlydo not support join expressions subqueries and specific database functions such as date time functions.
at thesame time sqlqueries often contain joins subqueries strings and database specific functions.
for example of the queriesinsuitecrm alargeopensourcewebapplicationthatmanagescustomerrelationships containatleastasinglejoin and28 of the queries in alura a closed source e learning web application containatleastonesubquery.consequently theaforementioned limitationsofexistingsolutionsclearlyreducetheirapplicability to real software systems.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden castelein et al.
toovercometheidentifiedlimitations wemodeltheproblemof test data generation for sql queries as a search based problem.w e optedforsearch basedtechniquessincetheyhavebeensuccessfully appliedinvarioussoftwaretestingscenarios e.g.
white boxunit testing and regression testing handling complex data structures e.g.
javaobjects andforstringsearchproblems .
given a sql query its respective database schema and a collectionofcoveragerequirements weimplementandevaluatethree differentsearchapproaches namelyrandomsearch biasedrandom search and genetic algorithms to populate tables with test data meetingagiventestingcriterion.therandomsearchexploresaset of randomly generated data the biased random search improves the pure random search by seeding constants that can be extracted from the sql query under test.
finally the genetic algorithm ga is guided by a fitness function based on data collected from the physical query plan generated by a fully functioning instrumented database engine.
weprovideanimplementationofthethreeapproachesinatool namedevosql.toevaluatethethreeapproaches weexecutethem on queries extracted from software systems one of them being from an industry partner.
our results show that the ga isable to completely cover queries .
of our dataset.
on average the ga takes seconds to cover queries up to different coverage targets and seconds to cover queries upto different coverage targets.
interestingly we observe that the ga does not get stuck in joins subqueries or string manipulation and thus shows advantages over the two other search algorithms.
our study leads to the following four contributions aformulationofthetestdatagenerationproblemforsql queriesasasearchproblemtogetherwiththedefinitionof three different search algorithms tailored to generate test data for sql queries section .
anopensourcejavaimplementationoftheapproach namely evosql section .
anempiricalstudyontheeffectiveness performance and difficultiesthatthethreeapproachesfaceon2 135queries extracted from four software systems section demonstrating that the genetic algorithm reaches full coverage for almostallcasesin2 15seconds makingtheapproachusable in a practical setting.
areplicationpackagecontainingthequeriesandschemas usedinourevaluationthatcanhelpresearchersinreproducing and improving our results .
sql test adequacy to enable the generation of test data for sql queries we must first select a test adequacy criterion.
sql queries contain different syntax and semantics that can be exercised e.g.
joining grouping and aggregation.
consider the following sql query select fromproduct wherecategory toy itcontainsatleasttwodifferentscenariosthatcouldbetested when a row contains category toy and when a row containscategory !
toy .tuya et al.
propose sqlfpc a full predicate coverage criterion for sql queries which takes into account logical operators joins grouping aggregations subqueries caseexpressionsandnull values.givenasqlquery sqlfpcproducescoveragetargetsin sql formats.
such sql targets are satisfied when the database returns at least a single row after being populated with test data and then executed.
asanexample sqlfpcwouldgeneratetwocoveragetargetsfor the query above select from product where category toy which is in this case the same as the sql under test and select from product where not category toy which represents the negative counterpart.
adatabasethatcontainstworows row1 toy row2 car would achieve of coverage for the sql under test as row satisfies target and row satisfies target .
inthispaper weadoptthecoveragecriterionbytuyaetal.
.
nevertheless we devise our approach in a way that other coveragecriteriacanbeused.ourapproachonlyrequiresacoveragecriterionthat1 producesasetofcoveragetargetsinsqlformat and2 each targetisconsideredsatisfiedwhenadatabasereturnsnon empty results after executing it against the generated data.
approach given an sql query under test our goal is to generate test data thatsatisfiesacoveragecriterion.thetestdatagenerationproblem can be formulated as follows definition .
search problem .
letr r1 ... rm bethe set of coverage targets for a query qaccording to a coverage criterion.
find test data sthat satisfies all coverage targets in r. toallowtheapplicationofsearch basedtechniques we i design anencodingschemeforrepresentingsolutionsoftheproblemin definition3.
ii defineafitnessfunctionmeasuringtheoptimality of each solution iii select three search algorithms to find optimal solutionsandthussolvingourproblem.theseaspectsaredescribed in detail in the next subsections.
.
solution representation given a coverage target for a sql query the search space is represented by all possible combinations of database tables whose rows satisfy the target.
a database table has a specified and previously definedinthesupplieddatabaseschema numberofcolumnsand canstoreanynumberofrows.thecolumnsdefinethedatatype e.g.
stringorinteger thateachcellinarowcanstore.asanexample a table product has three columns namewhich stores strings pricewhich stores doubles and sizewhich stores integers.
rows in this table always contain three elements the first cell stores a string the second stores a double and the third stores an integer.
our encoding scheme represents the set of database tables that areusedinthesqlquery whereeachofthemcontainsalistofnon emptyrows.morespecifically acandidatesolutionisasetoftables t t1 ... tn whereeachtable tiiscomposedofrows i.e.
ti braceleftbigr1 ... rk bracerightbig.eachrowcontainscells i.e.
rj v1 ... vc where cis the number of columns in ti.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
search based test data generation for sql queries icse may june gothenburg sweden duv prgho huudul 6whs a single step6 duv 7luhv duv wluhblg 7luhv lg prgho huudul 6whs w ll g7 l l g6whs b two steps figure1 twoexamplesofsqlquerieswiththecorresponding steps in a physical query plan.
thetablesandcolumnsofacandidatesolutionaredefinedbythe tables appearing in the target to solve.
for example let us consider thetarget select from product where price .
and size .
a candidate solution for this target contains a list of rows for the previously defined table product.
as an example a candidate solution for the query is product braceleftbigr1 angbracketleftbig primetv prime .
angbracketrightbig bracerightbig .
fitness function todeterminehowcloseacandidatesolution tisfromcoveringa querytargetweneedtodefineaproperfitnessfunction.usually the fitnessfunctionisadistancemeasure f t thattakesas inputacandidatesolution tandreturnszeroifandonlyif tsatisfies the given target.
in our case the fitness function is computed by analyzingtheexecutionofasqlqueryinadatabaseengineandits physical query plan the plan that the database internally devises toprocessthequery.therefore beforedescribingourfitnessfunction we need to introduce and describe the physical query plan.
.
.
physical query plan.
for any sql query to be executed databases first convert the query into a physical query plan which indicates the operations required to process the query as wellastheorderbywhichtheyneedtobeperformed.theresulting physicalqueryplancanbeviewedasanorderedlistofrelational algebraoperationsineachofitsnodes.asanexample nodescould contain a joinbetween two tables or a predicate expressed in awherestatement.
in the following we refer to these relational algebra operations in the physical query plan asstepsto satisfy.
figure1depictstwoexamplesofsqlqueriesandhighlightsthe states in the corresponding physical query plan.
figure 1a contains asqlquerywithasinglestep whichcontainsasingleselectionop eration model ferrari .thesqlqueryinfigure1bcontains two steps the physical query plan first commands the database to work on the join step one and then after that step is done to workontheselection steptwo .inthesecondcase ifthe joindoes notproduceanoutput i.e.
thepredicate cars.tire id tires.id isnottrueforanyrowinboth carsandtirestable thedatabase realizes that the query will return an empty result and stops its execution before proceeding to step two.
theorderofthestepsinthe physicalqueryplan aswellasthe orderofoperationsineachstepisautomaticallycomputedbythe databaseenginethatperformsdifferentcostcalculationstocome up with the best order to execute them .
the physical query plan also takes into account the priorities that an operation may have over another e.g.
a subquery may need to be executed beforeajoin.
nevertheless to cover a given query target r a solution hastogothroughallthestepsinthequeryplan whichwillonly happen if all predicates are evaluated to truefor at least once.
.
.
fitness function definition.
executingacandidatesolution against a given coverage target corresponds to executing all the stepsintheplan.ifasolution tfullysatisfiesallsteps i.e.
predicates inallsteps thenitsatisfiesthecoveragetargetundertest.given our coverage criterion satisfying a coverage target means that the query under test when executed in a database that contains the solutiont yields a non empty result.
if tdoes not cover the given target it implies that some steps are not satisfied and the database engine terminates the execution before completing the last stepin the query plan.
in this case we can measure the distance of t to cover the target by counting the number of yet unsatisfied steps step level and measuring how far tis to satisfy the step where the database engine stopped its execution prematurely step distance .
therefore given a candidate solution tand a coverage target r we design our fitness function as follows d t r step level t r step distance t l in the equation above step level t r measures the number of steps in the physical query plan not executed by the database enginewhenrunning tagainstthetarget r.thesecondfunction clausestep distance t l measures the distance of tin satisfying thefirststep lofthephysicalqueryplan thatisnotfullysatisfied byt i.e.
thestep distance is computed for the step lwhere the database engine stopped its execution.
a steplis satisfied by tif all relational algebra operations in lare satisfied.
therefore let ol braceleftbigop1 ... oph bracerightbigbe the set of operations in a given step l the corresponding step distance for a solutiontis defined as step distance t l h summationdisplay i 1 whereopiisthei thoperationin l dist t opi denotesthedistance ofttosatisfytherelationaloperation opi and isthenormalizing function x x x widely used in search based software testing .accordingtoequation3 thestepdistanceresultsin values in the range and it is obtained by summing up the distances dist t opi foralloperationsinthestepunderanalysis.
alloperationscontributeinequalmannerto step distance t l as theyarenormalizedbeforebeingaggregatedwiththesumoperator.
the actual distance dist t opi for each operation opi olis defined depending on the type of the values being involved.
in particular we identify the following operations and their corresponding operation distances i comparison operators.
the existing comparison operations in sql i.e.
and can involve either numbers booleans strings dates orthespecialvalue null.fornumbersand boolean values the distance dist t opi corresponds to the standardbranchdistance definedbykorel .forexample thedistance for the equality price isabs price .
for strings we use theenhanced edit distance defined by alshraideh et al.
that combines the standard edit distance with the character distance.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden castelein et al.
we selected this distance as it performs best when dealing with stringvaluesintestdatageneration .fordates thedistanceis computedasthesumofthedifferencesforeachnumericalcalendar part year month day hour minute second and millisecond.
ii logicaloperators.
forlogicaloperations e.g.
and weusedthe traditional branchdistance rules that aggregate thedistances of the logical expressions predicates involved in the operation.
for example the branch distance for the operation price .
and size .
isd .
iii sql operators.
there arefive operators thatare specific for sql whichare between is not null in likeandexists.for theseoperators wedefinethecorrespondingoperationdistances as described in the following.
thebetween operatorverifieswhetheragivenvalue viswithin thetwogivenbounds i.e.
if lb v ubwithlbandubbeingthe lower and the upper bound respectively.
in sql this is equivalent tolb vandv uband therefore we use the corresponding branch distance rule for the andoperator.
theis null operator returns truewhen the value vunder inspectionis null andfalseotherwise.the is not null operator isequivalentto not is null .therefore itisequivalenttothe boolean operator v nequalnulland it is treated as the not equal operator when computing the operation distance.
theinoperatorverifieswhetheragivenvalue lv lefttermofthe operation iscontainedinthelistontherightpartoftheoperation.
suchalistcanbeaconstantlistwritteninthequeryortheresultofasubquery.thisoperatorreturns trueifatleastoneofthevaluesin thelistisequalto lv.therefore theoperationdistancecorresponds totheminimumbranchdistancebetweeneachelement einthelist andlv i.e.
dist t opi min e listabs lv e .
thelikeoperatorperformspatternmatchingonastring.therefore itsoperationdistancecorrespondstothebranchdistanceforpattern matching defined by alshraideh et al.
.
theexistsoperator takes a subquery as a parameter.
if the subquery once executed returns a value then the operation is satisfiedanditsoperationdistanceiszero.otherwise theoperation distance corresponds to the operation distance of the subquery.
thejoinoperator merges two tables based on a list of join conditions e.g.
thecondition cars.tire id tires.id forthesql query in figure 1b.
join conditions are equality operators between two columns or between pairs of columns to satisfy.
therefore theoperationdistanceforajoinoperationiscomputedbasedon thebranchdistanceforequalityoperators dist t opi isequalto the sum of the branch distances applied to all join conditions inopi.
.
search algorithms in this paper we consider three different search algorithms geneticalgorithms gas randomsearch and biasedrandom search.
the details of these algorithms are discussed below.
.
.
genetic algorithms.
gas are stochastic search algorithms inspired by the darwinian natural selection.
these algorithmse v olv eapoolof nsolutions calledpopulation usingthefitness function to measure the quality of each solution.
initially the population consists of randomly generated solutions that correspond inourcase tosetofsolutionsasdescribedinsection3.1andfilledwithrandomlygeneratedvalues e.g.
randomintegers .thepopulationisevolvedviaselectionandreproductionthroughvarious iterations called generations.
in each generation individuals in the population are evaluated as follows each individual is inserted intoanin memorydatabaseengineandexecutedagainstthetarget under analysis.
the in memory database is instrumented to give thecompleteexecutiontraceofthequery step by step.thisexecution trace is therefore used to computed the corresponding fitness functionasdescribedinsection3.
.afterevaluatingallindividualsinthepopulations the fittestindividuals parents areselected using the tournament selection and then recombined using crossoverandmutation.thesetwogeneticoperatorsgeneratenew individuals offsprings thatinherit someproperties tables inour case fromtheirparents.then parentsandoffspringscompetewith each other and the nfittest individuals according to the fitness functionforthetargetunderanalysis areselectedtoformthepopulation of the next generation elitism .
the selection reproduction cycle ends if one individual in the current population achieves azero fitness value meaning that it covers the given coverage target otherwise the search is terminated when the maximum search budget allocated for the current target is reached.
thedetailsofthegeneticoperatorsimplementedforourproblem are discussed in the next paragraphs.
crossover .
as explained in section .
in our case an individual or solutions is a set of tables t t1 ... tn .
therefore the crossover operator has to generate two offspring by shuffling the tables in the parent solutions.
to this aim we used theuniform crossover given two parents t t1 ... tn and x x1 ... xn the uniform crossover uses a random binary vector crossover mask to decide which offspring inherits each table intandx.
the mask b b1 ... bn has the same length as the parents i.e.
the number nof tables one binary element for each table in the solutions.
if the binary element biis one then the first offspring inherits the table ti from the first parent while the secondoffspringinherits xi fromthesecondparent otherwise thefirstoffspringinherits xiwhilethesecondinherits ti.notice that parents and offsprings always have the same number of tables.
mutation .whenanindividual t t1 ... tn ismutated there is a nprobability for each table ti tto be mutated so on average onetableismutatedin t.threetypesofmutationscanbe appliedtoeach ti t whichareinorderoftheirapplication delete change and insert.
these operations have the same probability pm ofbeingappliedandarenotmutuallyexclusive i.e.
morethanone mutationcanbeappliedtothesametable ti.letti braceleftbigr1 ... rk bracerightbig beonetablewith krowsinagivensolution ttomutate.thedelete mutation consists in deleting one random row from ti.
the change mutation modifies each row rin a table tiwith a probability pc.
a row is modified by randomly changing one of its values.
let rjbe the row to mutate each cell in rjis modified with a1 cprobability where cisthenumberofcolumnsin ti.elements are mutated depending on their types floating point numbers are modified using the polynomial mutation which is standard forrealnumbers integersaremutatedbyusinga deltamutation i.e.
by adding or removing a deltavalue randomly generated from the interval a date is mutated by applying the same delta mutation to all its calendar parts e.g.
days strings are mutated byadding removingorreplacingcharacters finally booleans authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
search based test data generation for sql queries icse may june gothenburg sweden are mutated by flipping their values e.g.
from true to false .
if the column to mutate is nullable one of its value is set to nullwith a probability pnull.
thelastmutationoperatoraddsonerowtoagiventable ti.it eitherduplicatesoneexistingrowin toritaddsanewlyrandomly generated row i.e.
a row containing randomly generated values .
inagivenqueryundertest notallcolumnsofthetableareexercised.therefore welimititssearchspacebyignoringcolumnsthat arenotusedbyanypredicate andinstead consideringtheother columns to which we refer to as mutable columns.
the approach usesanaivetechniquetoidentifythemutablecolumns ifacolumn is used anywhere in the query s important clauses from where group by having it is added to the list of mutable columns.
seedingstrategies .seedingisthetechniqueofinsertingvalues fromaseedingpoolintothepopulationwithsomeprobability.the valuesintheseedingpoolareextractedusingtheknowledgetaken from the query under test.
our ga uses a seeding pool containing allconstants e.g.
stringsandintegers appearinginthequery.this is because a query may contain comparisons with constant values.
each constant in the query is extracted and added to the column seedingpool whichwillbeusedtobeseededintocolumnsofthe generated individuals when mutating a row.
we use a further seeding strategy specific for join operations.
a typical sql predicate for joining two tables together is an equality between two columns.
each predicate of the form column1 column2adds a logical link between the two columns.
therefore theseedingisappliedbycopyingsomevaluesfrom column1into columncolumn2 and vice versa.
postprocessing.
readabilityofthegenerateddataisimportant when it comes to comprehending the sqlquery and writing test casesforit.toimprovethereadabilityofthegenerateddata whenasolutionisfound weapplyanaive rowminimization technique for each table tiin the generated solution t we remove all rows that do not contribute to covering the coverage target under analysis.
.
.
random search.
asforgas randomsearchisexecuted against each target to cover independently.
it iteratively generates randomsolutions andthisprocessisrepeateduntilthecoverage targetissatisfied i.e.
thecoveragetarget whenexecutedagainst the generated data yields a non empty result or the maximum search budget allocated for the current target is reached.
random search is a simple algorithm that does not evolve existing solutions.
however it is often used in the literature as baseline the to test the complexity of the problem to solve and to assess the need for more advanced algorithms e.g.
gas .
moreover randomsearchhasbeenshowntooutperformothersearchalgorithms when solving specific problems .
.
.
biased random search.
in addition to the simple random search algorithm in this paper we used another variant of random search that uses the same seeding strategy used in gas.
therefore randomly generated solutions contain with a given probability values seeded from the constants appearing in the query i.e.
from thecolumnseeding orobtainedbyapplyingtheseedingstrategy specific for join operations.
.
.
search budget allocation.
all search algorithms described above can optimize only one single coverage target at one time.
tosolve multiple coverage targets they have to be executed several times one run is executed independently for each coverage target.
therefore the total search budget sbgiven to test each query qis divided in equal manner among all coverage targets of the sqlfpc coveragecriterion .inotherwords thelocalbudgetassigned foreachcoveragetargetis sl sb m wheremisthetotalnumber oftargetsfor q.ifoneofthecoveragetargetsissatisfiedwithout fully consuming the local budget sl the saved search time is used todynamicallyincrease thebudgetsfortheremaininguncovered targets.
thecoveragetargetsgeneratedforaquerydifferfromeachother for only few spare operations and predicates i.e.
they are very similar .
therefore test data covering one target may be very close to covering other similar targets according to their fitness functions .
for this reason some solutions generated when optimizing previous coverage targets are used to seed the initial population in the ga. our implementation evosql we provide evosql a tool implementing the database engine instrumentation thefitnessfunctionandthethreesearchalgorithms described in the previous section.
evosql takes as input a query a database schema and a time budget and returns test data for each sqlfpc coverage target.
our implementation is available open source and can be found in our github as well as in our appendix .
evosql internally uses hsqldb1 a java relational database engine that supports the latest sql standards and is able to runin memory.
we modified the source code of the database engineto instrument the physical query plan generated during a query execution which is used to calculate our fitness function.
toextractthecoveragetargets ourtoolusesthewebservicethat ismadeavailablebytuya etal.
.thewebservicereceivesasan input the sql query and the database schema and returns a list of coverage targets in sql format.
wedisabledinternaloptimizationsofhsqldbastheywould reducetheamountofinformationwecouldcollect.inparticular wedisabled indexing asitexcludesrowsthatdonotsatisfypredicates of indexed columns without individually evaluating them and lazyand oroptimizations i.e.
short circuitevaluation which makes the engine potentially not evaluate all predicates.
empirical study thegoalofthisstudyistoevaluatetheeffectivenessofthethreedifferentsearchalgorithmswhengeneratingtestdataforsqlqueries.
more specifically we investigate the following research questions rq1 whatisthecoverageachievedbytheproposedsearchbased algorithms?
rq2 whatistheperformanceoftheproposedsearch based algorithms?
rq3 whatcausesthedifferentapproachestonotachieve100 coverage?
1hsqldb authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden castelein et al.
applicationtotal queriesqueries w o bad syntaxunique queriesfinal queries alura espocrm suitecrm erpnext total table queries collected per application p r o p e r t y predicates joins subqueries functions columns targets table2 numberofqueriesaccordingtotheirdifferentproperties .
context of the study we evaluate the different search algorithms on queries taken from four software systems alura2is a closed source java e learning platform that uses hibernate as layer between application and database.
hibernategeneratessqlqueriesbasedonincomingdatarequests.
espocrm3is an open source web application to manage customerrelationships crm .itusesarestapibackend writteninphpwhichcommunicateswithamysqldatabase.
suitecrm4isanotheropensourcecrm.itisaforkofthe sugarcrm communityedition andis written inphp.
the databaseitusescanbeeithermysql mariadborsqlserver.
for our evaluation we used mysql.
erpnext5isanend to endbusinesssolutionthatmanages business information erp stands for enterprise resource planning .itisbuiltontopofthepython javascriptframeworkfrapp and uses mariadb.
wechosethesesystemsbecausetheyaredatabase centric i.e.
they make intensive use of databases and thus contain a large number of sql queries.
in addition these systems are written in three differentprogramminglanguages java php andpython givingusa morediversesampleofprojectsandqueries asthewayadeveloper writesasqlquerymightbeinfluencedbytheoverallecosystem ofthechosenlanguage e.g.
javadeveloperstypicallyusedhibernate to generate sql queries .
apart from the industrial system all others can be found on github enabling other researchers to reproduce our results.
2alura 3espocrm 4suitecrm 5erpnext system and mining the generated database logs.
table shows the total number of queries collected per system as well as the number of queries selected in our empirical evaluation.
for the query selection we analyzed all extracted queries to filter out non executable andduplicatedqueries.inparticular wefilteredout hsqldband sqlfpc non compliant sql i.e.
queries containing sql constructsthatarenotsupportedbyeitherhsqldborsqlfpc.we also removed duplicatedqueries i.e.
similar queries differing by some constant values.
for example the queries select from t wherea andselect from t wherea are similar as theironlydifferenceisaconstant 1and2 .asthereisnodifference in solving these queries we exclude duplicated queries.
finally we ignoredqueries with no predicates or other constraints i.e.
queries with no conditional branches to be exercised and thus without coverage targets.
in table we report the characteristics of the queries in our dataset.
as expected the number of coverage targets of a query is strongly correlated with the number of its properties spearman correlation .
p value .
.
as queries with fewer properties couldbeeasiertosolvethan complex querieswithmoreproperties we control our results by the number of coverage targets.
.
configuration of the search parameters theperformanceofsearchalgorithmsisinfluencedbyalargenumber of parameters.
to identify the best configuration of parameters fortheappliedgeneticalgorithm ga weexecutedthealgorithm inatrainingsetthatcontained100queries.wecarefullydevised thistrainingsettocontainallsqlconstructsthataresupportedby hsqldb such as joins wheres subqueries and string functions.
thetrainingsetisavailableinouronlineappendix .toevaluate various possible configurations we opted for a set of values and thresholdsthatarecommonlyusedinapplyingevolutionarysearch algorithms on similar software engineering problems .
the exercised configurations for different probabilities in a total of different combinations are as follows nullmutation pnull .
.
.
inserting deletingorduplicatingarow pm rowchangemutation pc n wherenisthe numberofrowsinthemutatedtable seeding .
.
.
and crossover .
.
.
.
foreachcombinationofprobabilities weexecutedtheapproach times and averaged the execution time of the complete training set.
at the end we selected the configuration with the smallest executiontime.thebestconfigurationweidentifiedisasthefollowing population size .
tournament size .
nullmutation pnull .
.
inserting deleting and duplicating pm .
row change mutation pc .
seeding .
crossover .
.
cloning from previous target population .
.
the time budget for the search process is minutes.
finally to comparethebiasedrandomsearchwiththega wesetthesame probability for seeding individuals which is .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
search based test data generation for sql queries icse may june gothenburg sweden .
experimental procedure to answer rq we executed the three approaches on the entire dataset.giventherandomizednaturalofthealgorithms weexecute eachofthem10times.weperform10runs theminimumsuggestedinliterature andacommonchoiceforexpensiveexperiments whichisourcase.foreachquery weaveragetheircoverage across the executions.
we consider a query to be successfully coveredif its average coverage is meaning that all its targets were covered in all executions.
if any target was not covered in anyoftheexecutions thatqueryisconsideredtobe notfullycovered.
such definition gives us the worst case view on the results.
throughout the research we have experienced that some of the coverage targets that are produced by sqlfpc are infeasible.
in mostofthesecases thisisduetosomecombinationofpredicates that cannotbe satisfied e.g.
a and a .
suchinfeasible targetsmayaffecttheanalysisofourresults asaquerywouldthen be marked as not succesfully covered.
we manually analyzed each targetproducedbysqlfpc andremovedthemfromouranalysis.
intheend weremoved127outofthe12 991totalcoveragetargets.
toanswerrq weanalyzetheaverageexecutiontimeperquery in each approach.
once more we control the queries by their coveragetargetstoanalyzewhetherthishasaneffectontheexecution time.
we provide descriptive statistics of each approach.
finally toanswerrq wetrainandunderstandaj48decision tree that classifies whether a coverage target is likely to be coveredornotbasedontheresultsinrq usingr s rwekapackage.
we use the following sql constructs as features to the model numberoftablesused numberofbasepredicates doesnotinclude and or andnotoperators number of inner joins number of left joins number of right joins number of subqueries numberof aggregate functions min max sum avg count number of non aggregate functions e.g.
datenow ifnull number of columns numberof whereclauses numberof group by clauses number of havingclauses number of string equality predicates number of date equality predicates number of exist predicates numberoflike predicates numberofifnull functions andthe sql query s total number of coverage targets.
asclasses failedandsuccessfulcoveragetargets arenotevenly balanced there are more failing cases in the random search andmore successful cases in the biased and ga search we applysmote synthetic minority over sampling technique to gen erate extra data points for the smaller class .
this way both classes have equal size which prevents the classifier from generatingabiasedmodel.finally toenablethemodeltobeunderstoodby ahuman welimitthenumberofleavesinthetreeby10.wealso reporttheaccuracyofthegeneratedmodels i.e.
thepercentageof instancesinourdatasetthatarecorrectlyclassifiedbythemodel.
the accuracy gives us an estimate of how much we can trust on the model.
replicationpackage.
weprovideanopensourcereplicationpackage thatcontains ourimplementationsofthethreesearchbased algorithms the r scripts used to generate the analysis and the queries and schemas from all systems but the closedsource application alura which enables researchers to replicate and further compare with other tools.
results .
rq what is the coverage achieved by the proposed search based algorithms?
infigure2 weshowaboxplotofaveragecoveragethateachsearchbased approach achieved.
in addition in table we present the number of queries each approach was able to completely cover controlledbythenumberofcoveragetargets.fromthisdata we observe that the random search proved to be highly inefficient.
among the2 135queries therandombaselinewasabletocompletelycover only .
of them.
it also achieved a partial median coverage of only .
among the remaining queries and completely failed i.e.
achieved coverage in queries .
.
its ability to findasolutionquicklydecreasesasthenumberofcoveragetargets increases.inpractice randomsearchwasonlyabletocompletely coverquerieswithlessthan8coveragetargets.still thenumber oftimesitfailsisrelativelyhigheveninquerieswithlesstargets e.g.
the random search was not able to solve any of the queries with1or2coveragetargetsinsuitecrm andonly34outof263 queries with or coverage targets in erpnext.
thebiasedsearchpresentsgoodefficacyinquerieswithless than coverage targets.
the biased search was able to completely cover queries had a partial median coverage of .
andcompletelyfailedonlyin11queries .
.forqueries withlessthan10coveragetargets thebiasedsearchcouldonlynot completelycover66outof1 906queries .
.however itseffec tivenessalsodecreasesasthenumberofcoveragetargetsincreases.
in particular it rapidly decreases after targets it solved only out of the queries .
with more than targets and only out of the queries with more than coverage targets.
the ga is the most effective approach.
it completely covered queries .
had a partial median coverage of .
amongtheremainingones anddidnotcompletelyfailinanyofthequeriesinthedataset.thegaachievedhighefficacyinquerieswithlessthan10coveragetargets asitdidnotcompletelycoveredonly3outof1 906queries.ho wever westill observethatitsperformance decreases as the number of coverage targets increases.
still thedecrease is much smaller than in the previous approaches.
even in queries with more than coverage targets the ga was able to solve out of the existing queries .
.
.
rq what is the performance of the proposed search based algorithms?
in table we show descriptive statistics of the average runtime of each approach.
in addition in figure we show the average query coverage given a time budget for the biased and ga approaches respectively.
we do not present data for the random search as it failsinmostcases andthusisnotacompetitor thefulldatacan be found in our online appendix .
we observe that thebiasedsearchisthefastestforqueriesupto5 6coverage targets.boththegaandthebiasedsearchareabletosolvequeries upto6coveragetargetsinlessthanonesecond.however thebiased search is even faster than the ga for such cases e.g.
for queries authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden castelein et al.
of targets1 queries queries queries queries random biased ga random biased ga random biased ga random biased ga alura suitecrm erpnext espocrm of targets9 queries queries queries queries random biased ga random biased ga random biased ga random biased ga alura suitecrm erpnext espocrm table number of completely successfully covered sql queries vs their total number.
.
.
.
.
.
alura suitecrm erpnext espocrm all systemcoveragealgorithm random biasedga figure the average coverage for a sql query achieved by eachsearch basedapproach after10executions.figurebet ter visualized in colors.
with coverage targets the biased search has a median runtime of .
seconds compared to .
of the ga a difference of .17s .
the ga becomes much faster than the biased search as the numberofcoveragetargetsincrease.
assoonasthenumberof coverage targets starts to increase boththe biased search and the gabecomeslower.however theruntimeofthebiasedsearchgrows rapidly while the ga s runtime growth is less aggressive.
as an example the median runtime for the biased search in queries with 9to10coveragetargetsis5.95secondswhilegapresentsamedian of .
seconds for to coverage targets the biased search takes on average .
seconds a 12x increase when compared to targets while the ga takes .
seconds an increase of .4x .
a time budget of one minute is enough for the ga to completelycoversimplequeriesandtocoveratleast70 ofcom plexqueries.
atimebudgetofoneminuteis onaverage sufficient forthegatocompletelycoverquerieswith6coveragetargetsor less for the biased search the same occurs for queries with or lesscoveragetargets.however forcomplexqueries thegiven300.
.
.
.
biased0.
.
.
.
ga figure the average coverage of a sql query y axis in a given time budget x axis in minutes controlled by thenumber of coverage targets.
figure better visualized in col ors.
1st quantile median 3rd quantile biased ga biased ga biased ga .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table descriptive statistics of the biased and ga approaches average runtime in seconds .
minutesbudgetdoesnotseemenoughforthebiasedsearch.inparticular even after minutes queries with more than coverage targetsachieveonly51 mediancoverage notevenappearingin the figure due to our scale .
on the other hand the ga needs a single minute to cover at least of queries with more than targets and90 inqueriesrangingfrom16to20targets.toachieve90 ofcoverageinquerieswithmorethan20targets theganeeds on average minutes.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
search based test data generation for sql queries icse may june gothenburg sweden .
rq what causes the different approaches to not achieve coverage?
thedecisiontreemodelsgeneratedaftertherandomsearch biased search andgaresults achievedanaccuracyof85.
.
and .
respectively.inthefollowingparagraphs wepresentand discuss them therandomsearchcannotdealwithjoinsandstrings.
the model classifies any query with joins as a failing one.
in addition even in queries with no joins the existence of a single string equality also makes the model to classify the target as failing.
thebiasedsearchsuffersfromquerieswithmanypredicates.
the model classifies any query with more than predicates as a failing one.
on the other hand queries with predicates or less are classified as successful.
when the query contains between 4and6predicates themodelusesthenumberofjoinsasawayto differentiatebetweenthem themodelclassifiesthetargetswiththeexistence of a single join as a failing one.
interestingly the strings feature does not appear in the model we discusss more about this in section .
the size of the query impacts the ga. the classifier classifies anyquerywithlessthan5predicatesorwithmorethan5predicates and less than columns as successful.
no other feature seemedrelevant to the model meaning that the number of columns in a query is what impacts the performance of the algorithm.
discussion .
biased search vs genetic algorithm ourresultsindicatethatbiasedsearch althoughhighlyefficientfor simple queries suffers in queries with many predicates.
the numbersalsoshowthat forsimplequeries itsruntimeperformancecan beevenbetterthanthatachievedbythega.thiscanbeexplained in two ways first the experimental dataset contains several string comparisons and non complex like commands both of which can besolvedbyseeding.ourdataset however didnotcontainmore complex string manipulation functions such as concatenations left right length reverse orcombinationsofthem.althoughourdataset suggests that these operations do not often appear in sql queries developers can use such functions.
after further investigation with manually created cases that did actuallycontainsuchoperations weobservedthatthegaisthe onlyapproachthatisabletofindsolutioninsuchcases.forexample the queries select from product where length name and left name refri and right name gerator andselect from product where reverse name rotaregirfer are not solved by the biased search.
on the other hand giventheinstrumentationthatweperforminthedatabase enginetoguidethefitnessfunction thegaapproachsolvesthis particular query in a few seconds.
although these queries are just examples theyillustratehowthebiasedsearchisunabletosolve complex cases where guidance is needed.
second althoughthegaimplementationhasaninitialization stepthatissimilartowhathappensinthebiasedsearch atevery iterationoftheevolution thegaspendstimecalculatingthefit nesses and applying the search operators.
all these calculationsdo not happen in the biased search.
thus for less complex queries these extra actions that are taken by the ga explain the small difference in the runtime performance.
itisalsoworthnoticingthattheinefficiencyofgacanbedueto the single target search strategy ga is re executed multiple times once for each coverage target.
h owever such a search strategy oftenleadstoaninefficientallocationofthesearchbudget as the order by which the targets are optimized over independent runs byga stronglyimpacts thesearch effectiveness .
toaddress this limitation various multi target evolutionary algorithms have been proposed literature in the context of white box unit testing .
therefore better results may be obtained when using these multi target strategies whose evaluation is part of our future agenda.
.
implications wedesignedandimplementedevosqlwiththeworkingdeveloper in mind and anticipate the following usage scenarios i query unit testing as we saw in our experimental dataset queries can be highly complex containing many predicates and subqueries.evosqlprovidesdeveloperswithtestdatathatcompletely exercises the query enabling them to verify whether the behavior of the query is exactly as expected.
ii query regression testing supportdevelopersinrefactoring or evolving their queries using data sets generated from an earlier version as an oracle to ensure that the queries preserve the desired behavior.
iii integration testing support developers in writing integration tests helping them to create the right data sets enabling them to trigger and test interesting interactions between code and queries.
theuseofgeneticalgorithmsforgeneratingsqltestdataopens up interesting areas for future research.
our current approach based on hsqldb only exercises queries expressed by the standard sql92 specification.
different databases e.g.
mysql oracle postgres providetheirownfunctions datatypes andconstructs whichwerenotincludedinthisstudy.oracle forexample provides a data type to store xml.
for each database specific function ordata type our proposed fitness function can be optimized withtailored branch distances mutation operators and random data generation.
fromanintegrationperspective dependenciesonexternalinfrastructures suchasdatabasesandfiles currentlyhinderthepowerof automated test generation tools .
researchers have worked on achieving high branch coverage of source code that interacts with such infrastructure by either generating database test data from scratch or using previously existing databases .
however we discuss in section they suffer from different limitations.
our ga approach has no such restrictions suggesting that the interplay of our technique and source code test generation could increase test coverage substantially.
finally we did not consider local search or memetic algorithms thecombinationoflocalandglobalsearch .futureresearch mayexploretheimpactofcombininglocalsearchwiththeglobal one on the coverage rate and performance.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden castelein et al.
.
threats to validity withrespecttointernalvalidity wecollectedthe2 135fromthe foursystemsafterexecutingtheirexistingtestsuitesandextracting the sql queries from the database logs.
thus our dataset is limitedbythequeriesthatareactuallyexercisedbytheirtestsuites.
however as we see in table the final dataset has shown to be diverse rangingfromsimplequerieswithfewconstructstolargeand complexquerieswithmorethan20columnsandcoveragepaths.
the analysis of the infeasible targets that were generated by sqlfpc was performed manually.
to reduce the risk of classifying afeasiblequeryasinfeasible theanalysiswereconductedbythe first two authors of this paper.
we defined the internal probabilities of the ga approach after performing experimenting different combinations of probabilities in a set of tests.
as testing all possibleprobabilitieswouldimplyinanexplosionofcombinations we experimented a set of well known intervals in the field .
nevertheless theremightbebetterconfigurations andfuturework needs to be conducted on this matter.
withrespecttoexternalvalidity weanalyzed2 135fromfour differentsystems threeofthembeingopensourceandoneofthem beinganindustrysystem.althoughsystemsweredifferentintheir programminglanguagesaswellasintheirnature moreresearch needstobeconductedtogeneralizeourresultstosqlqueriesin any software system.
related work several approaches have been introduced by researchers with similar goals to evosql generating test data or testdatabasesbasedononeormoresqlqueries.theseapproaches are based on constraint solving which transform sql queries to constraintsandapplyconstraintssolverstosatisfythem.therefore these approaches suffer from two main limitations namely they arenotabletodescribetheentiresqlsyntaxasconstraints and solvers may not be able to satisfy certain constraints e.g.
when sqlqueriesinvolvecommonconstructionssuchassubqueriesand string predicates in our evaluation set .
of queries contained such constructions .
evosqltakesadifferentapproachandbenefitsfromusingan existing fully functioning sql database engine.
as a consequence allqueriesusingstandardsqlsyntaxaresupported.unfortunately to the best of our knowledge none of the tools discussed in thissection are available for download and re implementating them wouldbeahighlydemandingtask.thispreventedusfrom empirical comparison between them and evosql.
in the following we discuss the existing approaches based on what is reported in their papers and highlight the differences between our approach and them.
qagrow presented by su rez cabal et al.
generates test databases for a set of queries using sqlfpc as coverage criterion.theapproachgeneratestestdatabasesbyformulatingthe problem of generating data for a query as a constraint satisfac tion problem in which the current database state is also taken intoaccount.theythenuseasatsolver choco togenerate thetestdata.theyevaluatedtheirapproachon215queriestaken fromaclosed sourcesystem.onthesequeries theyachieved99.
sqlfpccoverage inabouttwominutestime.however qagrow does not solve queries which contain strings and subqueries.
emmietal.
describeanalgorithmtoautomaticallygenerate test input for database applications.
their goal however is not to test the sql query itself but maximizing branch coverage of theprogramcodeundertest.theapproachalsousesaconstraint solver where the constraints are a combination of the path constraints in the program and the database constraints.
although the approachhandlesstringconstraints equality inequalityandlike it supports only fromandwhereclauses but no joins.
khaleketal.
presentadusa atoolthatgeneratestestdata for sql queries.
the paper uses the generated data to find faults in database systems such as mysql and hsqldb.
thus they generate repeated test data for the same sql query.
the approach modelssqlqueriesinto alloy specifications.adusasupports from where group by andhavingclauses.however adusaonly supportsnaturaljoins animplicitjoinbetweentwotables using commoncolumnnames andcrossjoins whichhavenopredicates .
in addition the alloy solver is unable to solve string constraints.
theqagentool presentedbybinnigetal.
alsogenerates test databases with the goal of testing a dbms.
the approach uses aconstraintsolvertogeneratetestdata.themodelisbuiltusing symbolic query processing their extension of symbolic execution.
qagen does not support subqueries and solely supports joins that use foreign key constraints in the joinpredicate.
finally mcminn et al.
have worked on generating tests fortheintegrityconstraints e.g.
mustnotbenull constraint thatmayexistinadatabaseschemausingasearch basedapproach.
theirworkcomplementsoursas inpractice developersmustcompletelytesttheirdatabases thisincludesboththeintegrityofthe schemas as well as executed sql queries.
conclusion thegoalofthispaperistounderstandhowtoautomaticallygenerate test data systematically covering realistic sql queries.
toachieve this goal we model test data generation for sql queries as a search based problem.
we devise and evaluate three different approaches basedonrandomsearch biasedrandomsearch and geneticalgorithms.wedefineafitnessfunctionthatcanbeusedto steer such algorithms towards an optimal solution containing the appropriate data to reach a given coverage target.
we offer an implementation of our approach in the open source tool evosql which we use to evaluate the applicability of ourapproach in practice.
using the queries collected from reallifesystems wedemonstratethat evosqlcanhandlethefull sql standard including subqueries joins and string handling achieves coverage for of our queries and manages to do so in seconds in most of the cases.
our work paves the way for systematic and automated unit integration and regression testing of sql queries.
furthermore weanticipateinterestingfutureresearchintermsoffurtheroptimizing the performance and effectiveness of the genetic algorithm takingevosqlbeyondstandardsql makinguseofallintegrity constraintsoftheschemato speedupthesear ch andlettingthegeneticalgorithmtakeinformationobtainedfromthesystem ssource code into account as well.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
search based test data generation for sql queries icse may june gothenburg sweden