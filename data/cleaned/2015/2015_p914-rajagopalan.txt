rdit race detection from incomplete traces arun k. rajagopalan texas a m university college station texas usa arunxls tamu.edujeff huang texas a m university college station texas usa jeff cse.tamu.edu abstract we present rdit a novel dynamic algorithm to precisely detect data races in multi threaded programs with incomplete trace information the presence of missing events.
rdit enhances the classical happens before algorithm by relaxing the need to collect the full execution trace while still guaranteeing full precision.
the key idea behind rdit is to abstract away the missing events by capturing the invocation data of the missing methods.
this provides valuable information to approximate the possible synchronization behavior introduced by the missing events.
by making the least conservative approximation that two missing methods introduce synchronization only when they access common data rdit guarantees to detect a maximal set of true races from the information available.
we have conducted a preliminary study of rdit on a real system and our results show that rdit is promising it detects no false positive when events are missed whereas happens before reports many.
categories and subject descriptors d. .
software engineering testing and debugging diagnostics debugging aids general terms algorithms design theory keywords missing trace data race happens before precise reachable addresses .
introduction one of the most serious problem in today s concurrent software systems is probably data races.
they manifest nondeterministically often appearing only on very rare executions and have caused many real world problems.
these include the therac medical accidents and the blackout in the usa and canada .
to detect data races researchers have proposed a wide range of techniques both static and dynamic targeting di erent types of software at various stages of the software development process.
most detectors are based on one of three techniques lockset happens before or a combination of the two.a crucial issue in these tools are false alarms.
because data races are di cult to diagnose and validate any false alarms could signi cantly decrease programmer productivity and make the tool less useful.
however it remains highly challenging to develop a false alarm free race detection technique.
the general problem of precisely identifying all data races is np hard and the lockset algorithm is known to be incomplete.
the di culty comes not only from the algorithmic complexity but also from various practical issues.
although happens before hb is precise theoretically in practice hb based techniques tend to report many false positives.
.
missing events a primary practical factor causing false positives are missing events.
happens before is often applied on a dynamic execution trace of events performed by the threads.
to guarantee preciseness happens before requires that the trace information be complete that is all critical events are captured.
this is however a strong requirement for large scale programs and is not easily achievable.
sometimes we may even desire to miss certain events for performance reasons.
some common situations where we miss events are external libraries these may be loaded in a di erent language or even on the y over the network where we do not have access to add necessary instrumentation to capture the events.
performance sensitive applications such applications may hand o execution of critical sections to an optimized external program usually written in a lower level language.
system calls calls into the host operating system s libraries.
some examples include sending and receiving data over the network bus in mpi programming.
these calls are inherently synchronized.
localized debugging programmers may be interested in debugging a speci c section of the application for data races and can choose to skip instrumenting large sections of their program to speed up run time.
in all these situations we may end up missing vital trace information.
if the missing section contains synchronization primitives that would have led to a hb edge happensbefore based tools would generate false positives.
example .
consider the trace in figure .
we have two threads t1 and t2 performing a write event e1 and read event e2 on a common address x. the grayed out region in between the two events e1 ande2 is the region of interest where we would like to check for any synchronization.
the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
914figure ad hoc synchronization in the missing methods results in false positives reported by happens before.
synchronization can either be in the form of a hb edge inducing event such as lock unlock fork join or an ad hoc synchronization which causes an ordering in the program execution.
in the absence of any such synchronization we will ag e1 ande2 as a race.
when all computations in this region are missed e1 e2 will be reported as a race.
however this is a false alarm when the two missing methods introduce an ad hoc synchronization on a shared address y set to initially .
thread t1 after performing the write to x setsy .
before thread t2 can perform the read of x it waits while the value of y6 .
thus read x from thread t2 can occur only after the write x from thread t1.
the shared address yis used as a barrier in thread t2 to induce a desired ordering.
.
our new idea in this paper we explore an enhancement to the happensbefore algorithm that relaxes the need to collect complete trace information that is to precisely detect data races in the presence of missing events.
a naive technique to avoiding false positives would involve adding hb edges between all missing events that occur on di erent threads.
although this approach is guaranteed to detect no false positives it is overly conservative and misses a lot of true data races as we shall see below.
our new algorithm rdit uses program analysis to reason about the missing events and provides the guarantee that all detected races are real races at the cost of fewer detected races.
however as compared to the naive approach rdit detects a maximal set of true data races from the available program trace.
our key observation is that although the computations inside the missing methods cannot be instrumented we can usually capture the invocation of those missing methods.
the runtime data at the invocation sites actually provides valuable information to approximate the behavior of the missing methods.
consider our example in figure .
both missing methods have accesses to the same memory address y. in the absence of this shared address there is no possibility for these two missing methods to introduce any synchronization.
more generally if the two missing methods in threads t1 and t2 reach addresses a and b respectively and if a6 b then we can safely conclude that no ordering can be induced in t1 and t2 through this pair of missing methods.
this observation leads to our rst contribution gathering a set of reachable addresses at the invocation of each miss ing method.
we abstract each external library or missing method call as two events methodbegin andmethodend .
only if the reachable addresses of two missing methods overlap we add the necessary hb edges on the abstracted events.
with this enhancement the same happens before algorithm can be applied to detect races without any change.
we have conducted a preliminary study on a popular database system apache derby and our results show that our algorithm is promising it detects zero false positives whereas the original happens before algorithm reports many false alarms.
we next introduce necessary background on race detection with happens before then describe our rdit algorithm in more detail.
.
data races and happens before a data race occurs when there are unordered con icting accesses in the program without proper synchronization.
happens before analysis has been implemented in many state of the art dynamic race detection tools such as threadsanitizer fasttrack and rvpredict .
these tools usually have two phases an instrumentation phase that generates an execution trace and an analysis phase that takes the trace as an input and detects races either online or o ine.
all necessary information needed for race detection is collected during the instrumentation phase.
this includes several program events such as read write lock unlock wait notify etc.
in addition various run time parameters such as thread id memory address etc.
are also collected to aid the analysis.
the amount of information gathered in this phase is limited by the run time slowdown we are able to tolerate.
thus the goal during instrumentation is to minimize the run time overhead while collecting all the information needed for the analysis.
the gathered execution trace is then fed to the analysis engine.
happens before analysis proceeds by building a directed acyclic graph dag representing the trace.
the vertices of this graph correspond to program events such as read write while the edges correspond to hb edges.
a hb edge is added between two events if they are performed by the same thread or there is some synchronization such as fork join lock unlock wait notify between them.
if two con icting events a read write or a write write event pair do not have a path between them in the dag then the two events are reported as a race.
in practice happens before is typically implemented using vector clocks or its variants to realize the principle of lamport clocks .
in addition to the program order synchronization events result in hb edges and cause the vector clock to update.
every con icting access to shared memory leads to a check against the vector clocks of the threads involved.
if the vector clocks of two con icting accesses are not comparable meaning that the two accesses are not ordered then a data race is detected.
.
algorithm in our new algorithm every missing method comprises of two events a methodbegin and amethodend .
the instrumentation phase is tasked with gathering this information.
we refer to this pair of events as a barrierpair.
915figure a program trace consisting of threads and barrierpairs.
hb edges are added between the barrierpairs if they have overlapping reachable addresses.
for example figure illustrates six barrierpairs in a trace a b c d e andf.
the shaded region indicates the region of program execution where missing events are encountered.
a barrierpair contains the following attributes a thread id denoting the thread that called the missing method.
amethodbegin event corresponding to the invocation of the missing method.
amethodend event corresponding to the return of the missing method.
a set of addresses that can be reached by this barrierpair.
a possibly empty set of recorded events that occur in between the begin and end events of the barrierpair for the particular thread.
rdit an extension of the happens before algorithm is described in algorithm .
if the trace is missing events synchronization events in particular then the dag constructed by happens before will have missing edges between its vertices giving us false positives.
since we aim to achieve no false positive we conservatively approximate the synchronization behavior of the missing methods and add a hb edge between missing methods that share at least one common address in its reachable address set.
while this approach is conservative it is the least conservative one because as long as the reachable address sets of two missing methods intersect they may use the intersected address to synchronize.
in other words our algorithm guarantees that we detect a maximal set of true races from the information available.
our algorithm proceeds in two phases the rst phase gathers all the barrierpairs from the program trace and the second phase adds hb edges between barrierpairs from different threads that have at least one common reachable address.
associated with each thread is a beginstack .
this stack stores the methodbegin events encountered by this particular thread.
for every methodbegin event we push onto the stack and for every methodend event encountered we pop from the top of stack.
this ensures that a correct barrierpair is constructed.
for all other events we leave the original happens before algorithm unmodi ed.
at the end of the rst phase we would have constructed a dag fromalgorithm the rdit algorithm input input trace bparray initialization for all threads t in do t beginstack end for process trace and gather barrierpairs for all eventsein do t e tid thread id ife methodbegin then t beginstack push e else ife methodend then mbegin t beginstack pop bp new barrierpair mbegin e bparray add bp else process normal hb events end if end for add hb edges between barrierpairs for all bp1 bp2 inbparray do ifbp1 tid6 bp2 tidthen ifbp1 addr bp2 addr6 then addhbedge bp1 events bp events end if end if end for call the original happensbefore algorithm for all e1 e2 in do if e1 e2 con ict then happensbefore e1 e2 end if end for the execution trace containing hb edges between synchronization events that were recorded.
in order to account for the missing events the second phase then takes this dag as input and iterates through all pairs of barrierpairs.
we add hb edges between the rst barrierpair from each of the di erent threads that satis es the criteria of at least one common reachable address.
since hb is transitive it su ces to add hb edges on the begin end events.
the added hb edge is always in the direction of increasing trace location i.e.
a hb edge between two events e1 ande2 goes from e1!e2 ife1 occurs before e2 in the trace.
figure illustrates a trace with hb edges added between barrierpairs that intersect.
finally we perform race detection using the original hb algorithm.
a pair of nodes are said to be con icting if they are either a read write or a write write pair.
we look at all such pairs of con icting events e1 e2 in the trace and check if there exists a path from e1!e2 in the dag.
if such a path does not exist then we report a race.
in the preceding algorithm analysis we have made the assumption that the addresses that are used to perform synchronization are local in scope i.e.
they are passed in as a parameter at the missing method s invocation site.
for addresses that are global in scope such as public static variables in java their contribution to synchronization is 916ignored as their inclusion would reduce rdit to the naive approach.
although global addresses could then potentially result in false positives reported by our algorithm this is a minor concern since such programming practices are discouraged and are rarely seen in large production grade programs.
.
preliminary results implementation we have implemented rdit in rvpredict a dynamic race detection tool for java programs.
instrumentation is performed using asm .
during instrumentation we insert logger methods into source byte code that records all the necessary events.
the set of reachable addresses of a particular method is computed as the union of the set of reachable addresses of each of its parameters.
to calculate the reachable address set of a particular object we perform a breadth rst search through its declared elds and inheritance stack.
each unique address is pushed onto a queue.
we iterate this process until the queue is empty.
the set of addresses we gather in this way is the complete set of addresses reachable by that particular method.
results we evaluated our tool against apache derby a widely used open source java database management system.
since the application is large we can easily simulate missing events.
to simulate the condition of missing events we randomly exclude certain classes and packages from being instrumented.
table shows the reported number of races by happens before and our rdit algorithm with various number of randomly missed classes.
all experiments were conducted on an core linux machine with openjdk .
.
and 32gb heap space.
table results on apache derby database missing classes hb rdit rdit false positives our results show that when no class is excluded both happens before and rdit report races.
however when random classes were excluded a large number of races are reported by happens before whereas rdit consistently reported races only.
we also manually inspected these races and found that all races reported by rdit were real that is rdit reported no false positive .
on the contrary we found many false alarms among those races reported by happens before.
moreover for some races it was very di cult and time consuming to determine their validity and as such we were not able to make a conclusive judgment.
.
related work data race detection has been widely discussed in the literature.
our technique is distinguished in that it is the rst to address the practical problem of missing events.
although happens before is precise its guarantee of no false positive is only true when the entire execution trace is available.
several techniques exist to improve accuracy of the detected races through runtime validation.
these techniques take a set of potential races as input and execute theprogram again trying to simulate the inter leavings necessary to induce the race.
if the conditions to reproduce the race are not met the race is marked as norace and not reported.
while these techniques can prune false positives they require multiple runs of the program and thus su er from livelocks and missed true races.
.
acknowledgment we would like to thank the anonymous reviewers for their constructive comments.
this research is supported by faculty start up funds from texas a m university and a google faculty research award to je huang.
.
conclusion and future work we have presented a novel enhancement to the classical happens before algorithm that ensures preciseness in situations when the trace information is incomplete missing events.
our algorithm requires only a single run of the program and guarantees no false positive.
we have implemented rdit in java and conducted a preliminary evaluation on a large database application.
our results show that our algorithm detects only real races even when arbitrary sections of code are missed.
our study opens several interesting directions for future work.
first we plan to formalize the barrierpair model of our algorithm and establish it s theoretical soundness.
second we plan to fully realize our algorithm and evaluate its performance on several larger real world multi threaded systems.
third we plan to optimize runtime performance and integrate our algorithm in popular race detection tools with large user base such as threadsanitizer.
.