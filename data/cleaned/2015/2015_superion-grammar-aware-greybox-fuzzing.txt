superion grammar aware greybox fuzzing junjie wang bihuan chen lei wei yang liu school of computer science and engineering nanyang technological university singapore school of computer science and shanghai key laboratory of data science fudan university china college of information science zhejiang sci tech university china abstract in recent years coverage based greybox fuzzing has proven itself to be one of the most effective techniques for finding security bugs in practice.
particularly american fuzzy lop afl for short is deemed to be a great success in fuzzing relatively simple test inputs.
unfortunately when it meets structured test inputs such as xml and javascript those grammar blind trimming and mutation strategies in afl hinder the effectiveness and efficiency.
to this end we propose a grammar aware coverage based greybox fuzzing approach to fuzz programs that process structured inputs.
given the grammar which is often publicly available of test inputs we introduce a grammar aware trimming strategy to trim test inputs at the tree level using the abstract syntax trees asts of parsed test inputs.
further we introduce two grammar aware mutation strategies i.e.
enhanced dictionary based mutation and tree based mutation .
specifically tree based mutation works via replacing subtrees using the asts of parsed test inputs.
equipped with grammar awareness our approach can carry the fuzzing exploration into width and depth.
we implemented our approach as an extension to afl named superion and evaluated the effectiveness of superion using largescale programs i.e.
an xml engine libplist and three javascript engines webkit jerryscript and chakracore .
our results have demonstrated that superion can improve the code coverage i.e.
.
and .
in line and function coverage and bug finding capability i.e.
new bugs among which we discovered new vulnerabilities with cves assigned and .2k usd bug bounty rewards received over afl and jsfunfuzz.
index t erms greybox fuzzing structured inputs asts i. i ntroduction fuzzing or fuzz testing is an automated software testing technique to feed a large amount of invalid or unexpected test inputs to a target program in the hope of triggering unintended program behaviors e.g.
assertion failures crashes or hangs.
since its introduction in the early 1990s fuzzing has become one of the most effective techniques to find vulnerabilities in realworld programs for ensuring software security .
it has been applied to testing various applications ranging from rendering engines and image processors to compilers and interpreters.
a fuzzer can be classified as generation based e.g.
or mutation based e.g.
depending on whether test inputs are generated by the knowledge of the input format or grammar or by modifying well formed test inputs.
a fuzzer can also be classified as whitebox e.g.
greybox e.g.
or blackbox e.g.
depending on the degree of leveraging a target program s internal structure which reflects the tradeoffs between effectiveness and efficiency.
in this paper we focus on mutation based greybox fuzzing.
coverage based greybox fuzzing.
one of the most successful mutation based greybox fuzzing techniques is coverage target programselect test inputtrim test inputmutate test input execute programupdate queueinstrument program fig.
the general workflow of afl based greybox fuzzing which uses the coverage information of each executed test input to determine the test inputs that should be retained for further incremental fuzzing.
afl is a stateof the art coverage based greybox fuzzer which has discovered thousands of high profile vulnerabilities.
thus without the loss of generality we consider afl as the typical implementation of coverage based greybox fuzzing.
as shown in fig.
afl takes the target program as an input and works in two steps instrumenting the target program and fuzzing the instrumented program.
the instrumentation step injects code at branch points to capture branch edge coverage together with branch hit counts which are bucketized to small powers of two .
a test input is said to have new coverage if it either hits a new branch or achieves a new hit count for an already exercised branch.
the fuzzing step can be broken down into five sub steps.
specifically a test input is first selected from a queue where the initial test inputs as well as the test inputs that have new coverage are stored.
then the test input is trimmed to the smallest size that does not change the measured behavior of the program as the size of test inputs has a dramatic impact on the fuzzing efficiency.
the trimmed test input is then mutated to generate new test inputs and the program is executed with respect to each mutated test input.
finally the queue is updated by adding those mutated test inputs to the queue if they achieve new coverage while the mutated test inputs that achieve no new coverage are discarded.
this fuzzing loop continues by selecting a new test input from the queue.
challenges.
the current coverage based greybox fuzzers can effectively fuzz programs that process compact and unstructured inputs e.g.
images .
however some challenges arise when they are used to target programs that process structured inputs e.g.
xml and javascript that often follow specific grammars.
such programs often process the inputs in stages i.e.
syntax parsing semantic checking and application execution .
on one hand the trimming strategies e.g.
removal of chunks of data in afl are grammar blind and hence can easily violate the grammar or destroy the input structure.
as a result most test inputs in the queue cannot be effectively trimmed to keep them syntax valid.
this is especially the case when the target program ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
target programselect test inputtrim test inputmutate test input execute programupdate queueinstrument programgrammar fig.
the general workflow of superion with the highlighted differences from afl see fig.
can process a part of a test input triggering coverage but errors out on the remaining part.
this will greatly affect the efficiency of afl because it needs to spend more time on fuzzing the test inputs whose structures are destroyed but only finds parsing errors and gets stuck at the syntax parsing stage which heavily limits the capability of fuzzers in finding deep bugs.
on the other hand the mutation strategies e.g.
bit flipping in afl are grammar blind and hence most of the mutated test inputs fail to pass syntax parsing and are rejected at an early stage of processing.
as a result it is difficult for afl to achieve grammar aware mutations.
besides afl spends a large amount of time struggling with syntax correctness while only finding parsing errors.
thus the effectiveness of afl to find deep bugs is heavily limited for programs that process structured inputs.
the proposed approach.
to address the challenges we propose a new grammar aware coverage based greybox fuzzing approach for programs that process structured inputs.
we also implement the proposed approach as an extension to afl named superion1.
our approach takes as inputs a target program and a grammar of the test inputs that is often publicly available.
based on the grammar we parse each test input into an abstract syntax tree ast .
using asts we introduce a grammar aware trimming strategy that can effectively trim test inputs while keeping the input structure valid.
this is realized by iteratively removing each subtree in the ast of a test input and observing coverage differences.
moreover we propose two grammar aware mutation strategies that can quickly carry the fuzzing exploration beyond syntax parsing.
we first enhance afl s dictionary based mutation strategy by inserting overwriting tokens in a grammaraware manner and then propose a tree based mutation strategy that replaces one subtree in the ast of a test input with the subtree from itself or another test input in the queue.
to evaluate the effectiveness of superion we conducted experiments on one xml engine libplist and three javascript engines webkit jerryscript and chakracore.
we compared our approach with afl with respect to the code coverage and bugfinding capability.
the results have demonstrated that superion can effectively improve the code coverage over afl by .
in line coverage and .
in function coverage and superion can significantly improve the bug finding capability over afl by finding new bugs among which six were found by afl .
among these bugs new vulnerabilities were discovered with cves assigned and we received .2k usd bug bounty 1superion is an autobot combiner in the cartoon the transformers .
?xm lversion .
encoding utf ?
plist version .
dict key some ascii string key string string data data dict plist fig.
an example of afl s built in trimming rewards.
besides we compared superion with jsfunfuzz which is a successful fuzzer specifically designed for javascript.
however it failed to find any new bugs.
moreover we have demonstrated that our grammar aware trimming strategy can effectively trim test inputs while keeping them syntax valid and our grammar aware mutation strategies can effectively generate new test inputs that can trigger new coverage.
contributions.
the contributions of this work are we proposed a novel grammar aware coverage based greybox fuzzing approach for programs that process structured inputs which complements existing coverage based greybox fuzzers.
we implemented our approach and made it open source2 and conducted experiments to demonstrate its effectiveness.
we found new bugs among which we found new vulnerabilities with cves assigned and received .2k usd bug bounty rewards.
ii.
o urapproach to address the challenges of coverage based greybox fuzzing section i we propose a novel grammar aware coverage based greybox fuzzing approach which targets programs that process structured inputs.
we implement the approach as an extension to afl named superion.
fig.
2introduces the workflow of superion and highlights the differences from afl see fig.
.
in particular a context free grammar of the test inputs is needed which is often publicly available e.g.
in antlr s community .
we introduce a grammar aware trimming strategy section ii a and two grammar aware mutation strategies section ii b with the purpose of making afl grammar aware.
a. grammar aware trimming strategy the built in trimming strategy in afl is grammar blind and treats a test input as chunks of data.
basically it first divides the test input to be trimmed into chunks of len n bytes where lenis the length of the test inputs in bytes and then tries to remove each chunk sequentially.
if the coverage remains the same after the removal of a chunk this chunk is trimmed.
note thatnstarts at and increments by a power of two up to .
this strategy is very effective for unstructured inputs.
however it cannot effectively prune structured inputs while keeping them syntax valid possibly making afl stuck in the fuzzing exploration of syntax parsing without finding deep bugs.
example.
fig.3gives an example of afl s built in trimming on an xml test input with respect to libplist an xml engine where l versio and dict plis are trimmed highlighted by strikethrough .
the trimmed test input is syntax invalid but still has the same coverage as the original test input because the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm grammar aware trimming input the test input to be trimmed in the grammar g output the trimmed test input ret while true do parse inaccording to ginto an ast tree ifthere are any parsing errors then return built in trimming in end if foreach subtree nintree do ret remove nfrom tree run the target program against ret ifcoverage remains the same then in ret break else addnback to tree end if ifnis the last subtree in tree then return ret end if end for end while ... try eval m if .some this.unwatch x this.
prototype else true return null catch ex try eval m while null a gi catch ex try eval nbreak m n catch ex try eval l if window .x return null else if uneval window .
propertyisenumerable x collectgarbage catch ex try eval for..in for var xin .hasownproperty .hasownproperty x for..in m for var inthis .slice catch ex try eval if else if x4 null catch ex try eval catch ex try eval for va rx xi nx x catch ex try eval if uneval x x va r x false else if null n.unwatch x throw window else return catch ex ... fig.
an example of grammar aware trimming implementation of libplist does not adhere to xml s grammar specification.
hence the trimmed test input is used for further fuzzing even though its grammar is destroyed.
to ensure the syntax validity of trimmed test inputs we propose a grammar aware trimming strategy whose procedure is given in algorithm .
it first parses the test input to be trimmed inaccording to the grammar ginto an ast tree line .
if any parsing errors occur as in s structure may be destroyed by mutations then it uses afl s built in trimming strategy rather than directly discarding it line otherwise it attempts to trim a subtree nfrom tree line .
if the coverage is different after nis trimmed then ncannot be trimmed line and it tries to trim next subtree otherwise nis trimmed and it re parses the remaining test input line and then repeats the procedure until no subtree can be trimmed line .
thus we resort to afl s built in trimming only when our treebased trimming is not applicable.
this is because sometimes invalidity is also useful.
example.
fig.4shows an example of our trimming strategy on a javascript test input where a complete try catch statement highlighted by strikethrough is trimmed without raising any coverage difference.
it is almost impossible for afl s builtin trimming strategy to prune such a complete statement.
b. grammar aware mutation strategies the default mutation strategies e.g.
bit flipping or token insertion in afl are too fine grained and grammar blind to keep the input structure following the underlying grammar.
therefore algorithm dictionary based mutation input the test input in the dictionary d output the set of mutated test inputs t t l the length of in fori i l do j i curr u8 in s address i current byte of in next u8 in s address j next byte of in while j l curr andnext are alphabet or digit do j j next u8 in s address j end while foreach token dinddo insert datiofin overwrite itojofinwith d t t in end for i j end for overwrite insert... a 0x1 a ... ... a 0x1 a ...... a 0x1 a ... ... a 0x1 a 0const1 ... a original... a 0x1 a ... ... a 0x1 a ...... a 0x1 a ... ... a 0x1 consta ...overwrite insert b enhanced fig.
an example of dictionary based mutation we propose two grammar aware mutation strategies to improve the mutation effectiveness on triggering new program behaviors.
enhanced dictionary based mutation dictionary based mutation was introduced to make up for the grammar blind nature of afl.
the dictionary is actually a list of basic syntax tokens e.g.
reserved keywords which can be provided by users or automatically identified by afl.
every token is inserted between every two bytes of the test input to be mutated or written over every byte sequence of the same length of the token.
such mutations can produce syntax valid test inputs but are inefficient as most of the generated inputs have destroyed structures.
therefore we propose the enhanced dictionary based mutation as shown in algorithm .
this algorithm leverages the key fact that the tokens e.g.
variable names function names or reserved keywords in a structured test input normally only consist of alphabets or digits.
hence it first locates the token boundaries in a test input by iteratively checking whether the current and next byte are both alphabet or digit line .
then it inserts each token in the dictionary to each located boundary which avoids the insertion between the consecutive sequence of alphabets and digits and thus greatly decreases the number of token insertions line .
similarly it writes each token in the dictionary over the content between every two located boundaries which also greatly decreases the number of token overwrites.
such token insertions and overwrites not only maintains the structure of mutated test inputs but also decreases the number of mutated test inputs hence greatly improving the effectiveness and efficiency of dictionary based mutation.
example.
fig.
5illustrates the difference between the original and enhanced dictionary based mutation.
in the original one 01is not treated as a whole and thus 1can be overwritten by andconst can be inserted between 0and1 which destroys the structure without introducing any new coverage.
in the en726 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm tree based mutation input the test input tar the grammar g the test input pro output the set of mutated test inputs t t s the set of subtrees in tar andpro parse tar according to ginto an ast tar tree heuristic ifthere are any parsing errors then return end if foreach subtree nintar tree do heuristic s s n end for parse pro according to ginto an ast pro tree heuristic ifthere is no parsing error then foreach subtree ninpro tree do heuristic s s n end for end if foreach subtree nintar tree do heuristic foreach subtree sinsdo ret replace nintar tree s copy with s t t ret end for end for return t hanced one 01is identified as a whole and hence the mutated test inputs in fig.
5awill not be produced.
instead it can generate the mutated test inputs in fig.
5bmore efficiently which are taken from our experiments and both lead to new coverage.
tree based mutation dictionary based mutation is aware of the underlying grammar in an implicit way.
to be explicitly aware of the grammar and thus producing syntax valid test inputs we utilize the grammar knowledge and design a tree based mutation which works at the level of asts.
different from the tokens used in dictionary based mutation ast actually models a test input as objects with named properties and is designed to represent all the information about a test input.
thus asts provide a suitable granularity for a fuzzer to mutate test inputs.
algorithm 3shows the procedure of our tree based mutation.
it takes as inputs a test input tarto be mutated the grammar g and a test input prothat is randomly chosen from the queue.
it first parses taraccording to ginto an ast tartree and if any parsing errors occur taris a syntax invalid test input and we do not apply tree based mutation to tar line .
if no error occurs it traverses tartree and stores each subtree in a sets line .
then it parses prointo an ast pro tree and stores each subtree of pro tree insif there is no parsing error line .
here sserves as the content provider of mutation.
then for each subtree nintartree it replaces nwith each of the subtree sinsto generate a new mutated test input line .
finally it returns the set of mutated test inputs.
notice that we do not consider the node type when replacing subtrees because that will harm the general applicability of superion.
the size of this returned set can be the multiplication of the number of subtrees in tartree and the number of subtrees in tartree andpro tree which could be very large.
as an example our tree based mutation on tarandprowhose number of subtrees is respectively and will generate 000test inputs.
this will add burden to the program execution step during fuzzing making fuzzing less efficient.
to relieve the burden we design three heuristics to reduce the number of mutated test inputs.
for clarity we do not elaborate these heuristics in algorithm but only show where they are applied.table i target languages and their structure and samples language symbols structure level samples xml weak javascript strong heuristic restricting the size of test inputs.
we limit the size of test inputs i.e.
tarandproin algorithm as bytes long line 3and10 .
hence we do not apply tree based mutation to tariftaris more than bytes long and we do not use subtrees of proas the content provider of mutation ifprois more than bytes long.
the reasons are that a larger test input usually needs a larger number of mutations more memory is required to store the ast of a larger test input and a larger test input often has a slower execution speed.
heuristic restricting the number of mutations.
if there are more than subtrees in tarandpro we randomly select from all subtrees in sas the content provider of mutation line .
thus we keep the number of mutations on each test input in the queue under to make sure that each test input in the queue has the chance to get mutated.
heuristic restricting the size of subtrees.
we limit the size of subtrees i.e.
each subtree in sin algorithm as bytes long line 7and12 .
thus we do not use the subtrees of tarandproas the content provider of mutation if the subtree is more than bytes long.
notice that bytes are long enough to include complex statements.
the threshold values in these heuristics were empirically established as good ones.
example.
fig.
6shows an example of our tree based mutation.
the left side is the ast of the test input to be mutated i.e.
tarin algorithm and the right side is the ast of the test input that provides the content of mutation i.e.
proin algorithm .
here the subtree corresponding to the expression x 2intar is replaced with the subtree corresponding to the expression number x inpro resulting in a new test input.
iii.
e v aluation we implemented superion in lines of c c code by extending afl .
particularly given the grammar of test inputs we adopted antlr to generate the lexer and parser and used antlr c runtime to parse test inputs and realize our trimming and mutation strategies.
hence our approach is general and easily adoptable for other structured test inputs.
a. evaluation setup to evaluate the effectiveness and generality of our approach we selected two target languages and four target programs and compared our approach with afl with respect to the bugfinding capability and code coverage.
target languages.
we chose xml and javascript as the target languages with different structure level.
their grammars are all publicly available in antlr s community .
in particular xml is a widely used markup language.
as shown in the second column of table i the xml grammar only contains eight symbols.
thus xml can be considered to be weakly structured.
javascript is an interpreted language and its grammar contains symbols.
thus its structure level can be regarded as strong.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
fig.
an example of tree based mutation table ii target programs and their fuzzing configuration program version lines func.
coverage timespan libplist .
edge months webkit .
.
block months jerryscript .
edge months chakracore .
.
block months as indicated by the last column of table i we crawled xml samples from the internet and javascript samples from the test inputs of the two open source javascript engines webkit and jerryscript.
they were used as the initial test inputs i.e.
seeds for fuzzing.
as suggested by afl afl cmin should be used to identify the set of functionally distinct seeds that exercise different code paths in the target program when a large number of seeds are available.
therefore we used afl cmin on the samples and identified and distinct xml and javascript samples as the seeds for fuzzing as shown in the parentheses in the last column of table i. notice that before fuzzing we pre processed the javascript samples by removing all the comments because comments account for a considerable percentage of waste of mutation.
target programs.
we selected one open source xml engine libplist and three open source javascript engines webkit jerryscript and chakracore as the programs for fuzzing.
the first four columns of table iilist the program details including the version the number of lines of code and the number of functions.
particularly libplist is a small portable c library to handle apple property list format files in binary or xml.
it is widely used on ios and mac os.
webkit is a cross platform web browser engine.
it powers safari ibooks and app store and various mac os ios and linux applications.
jerryscript is a lightweight javascript engine for internet of things intended to run on a very constrained device.
chakracore is the core part of the chakra javascript engine that powers microsoft edge.
we chose these programs because they are security critical and widely fuzzed.
thus finding bugs in them are significant.
as shown in the fifth column of table ii we used edge coverage for libplist and jerryscript during fuzzing but block coverage for others due to non determinism i.e.
different executionsof a test input lead to different coverage .
besides we excluded the non deterministic code in webkit and chakracore from instrumentation following the technique in kafl .
at the time of writing we have fuzzed these programs for about three months.
for libplist and jerryscript we have completed more than cycles of fuzzing.
for webkit and chakracore due to their large size we have not finished one cycle yet.
here a cycle means the fuzzer went over all the interesting test inputs triggering new coverage discovered so far fuzzed them and looped back to the very beginning.
research questions.
using the previous evaluation setup we aim to answer the following five research questions.
rq1 how is the bug finding capability of superion?
rq2 how is the code coverage of superion?
rq3 how effective is our grammar aware trimming?
rq4 how effective is our grammar aware mutation?
rq5 what is the performance overhead of superion?
we conducted all the experiments on machines with intel xeon cpu e5 2697v3 cores and 64gb memory running bit ubuntu .
as the operating system.
b. discovered bugs and vulnerabilities rq1 table iiilists the unique bugs found by superion.
in libplist we discovered new bugs from which we found new vulnerabilities with cve identifiers assigned.
in webkit new bugs were found.
seven of them were vulnerabilities with five cve identifiers assigned and others are pending for advisories.
it is worth mentioning that these bugs obtained high appraisals e.g.
thank you for the awesome test case and this bug has existed for a long time.
a quick look through blame would say for years or so .
in jerryscript we found four previously unknown bugs from which we found four vulnerabilities with three cve identifiers assigned.
in chakracore we discovered three new bugs and one of them was a vulnerability.
note that we received .2k usd bug bounty rewards.
with respect to the type of these bugs see the third column of table iii of them are buffer overflow of them are integer overflow of them are memory corruption of them are arbitrary address access of them is uninitialized memory read and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii unique bugs discovered by superion program bug type afl jsfunfuzz libplistcve buffer overflow n a cve buffer overflow n a cve memory corruption n a cve memory corruption n a cve memory corruption n a cve buffer overflow n a cve buffer overflow n a cve buffer overflow n a cve memory corruption n a bug assertion failure n a cve integer overflow n a webkitcve arbitrary access cve use after free cve buffer overflow cve arbitrary access cve integer overflow bug assertion failure bug uninitialized memory read bug null pointer deref bug assertion failure bug assertion failure bug assertion failure bug null pointer deref bug null pointer deref bug buffer overflow bug assertion failure bug assertion failure jerryscriptcve buffer overflow n a cve buffer overflow n a cve buffer overflow n a bug buffer overflow n a chakracorecve buffer overflow bug null pointer deref bug null pointer deref of them is use after free.
these are all vulnerabilities.
besides of them are null pointer dereference and of them are assertion failure.
these are all denial of service bugs.
all these bugs have been confirmed and of them have been fixed.
comparison to afl.
among these bugs afl only discovered six of them as shown in the fourth column of table iii in three months and did not discover any other new bugs.
this indicates that superion significantly improves the bug finding capability of coverage based grey box fuzzers which owes to the grammar awareness in superion.
specifically for relatively weakly structured inputs such as xml afl discovered bugs while superion not only found all these bugs but also found more bugs than afl.
differently for highly structured inputs such as javascript afl barely found any bugs.
only one bug about utf encoding problem was found by afl in jerryscript.
all other bugs in javascript engines were found by superion s tree based mutation.
this shows the significance of injecting grammar awareness into coverage based grey box fuzzers.
comparison to jsfunfuzz.
we also compared superion with jsfunfuzz which is a successful grammar aware fuzzer specifically designed for testing javascript engines.
jsfunfuzz can be used to fuzz webkit and chakracore but it fails to fuzz jerryscript because its generated javascript inputs have many javascript features that are not supported by jerryscript.
after three months of fuzzing jsfunfuzz only found hundreds of out table iv code coverage of the target programs programline coverage function coverage seeds afl superion seeds afl superion libplist .
.
.
.
.
.
webkit .
.
.
.
.
.
jerryscript .
.
.
.
.
.
chakracore .
.
.
.
.
.
of memory crashes in webkit and chakracore but failed to find any bugs as indicated by the last column of table iii .
this is because jsfunfuzz uses manually specified rules to express the grammar rules the generated inputs should satisfy.
however it is daunting or even impossible to manually express all the required rules.
instead superion directly uses the grammar automatically during trimming and mutation.
in summary superion can significantly improve the bugfinding capability of coverage based grey box fuzzers e.g.
we found new bugs among which we discovered new vulnerabilities with cve identifiers assigned .
c. code coverage rq2 apart from the bug finding capability we also measured the code coverage of fuzzing.
the results are shown in table iv including the line and function coverage of the target programs.
in particular we list the coverage achieved by initial seeds afl and superion.
the coverage was calculated using afl cov .
we were not able to calculate the coverage for jsfunfuzz due to two reasons jsfunfuzz does not keep the javascript samples executed and jsfunfuzz is very efficient and executes millions of javascript samples until it triggers a crash which makes the coverage computation infeasible.
for line coverage the initial seeds covered .
lines of libplist .
lines of webkit .
lines of jerryscript and .
lines of chakracore.
by fuzzing afl respectively increased their line coverage to .
.
.
and .
.
on average afl further covered .
of the code.
superion improved the line coverage to .
.
.
and .
respectively and it further covered .
of the code on average.
overall superion outperformed afl by .
in line coverage because the grammar awareness in superion carries the fuzzing exploration towards the application execution stage.
on the other hand for function coverage the initial seeds covered .
functions on average and afl and superion increased the function coverage to .
and .
respectively.
generally superion outperformed afl by .
in function coverage due to its grammar awareness.
in summary superion can significantly improve the code coverage of coverage based grey box fuzzers e.g.
.
in line coverage and .
in function coverage .
d. effectiveness of grammar aware trimming rq3 table vcompares the trimming ratio i.e.
the ratio of bytes trimmed from test inputs and the grammar validity ratio i.e.
the ratio of test inputs that are grammar valid after trimming using the built in trimming in afl and the tree based trimming in superion.
numerically for libplist the built in trimming in afl trimmed out .
of bytes in xml test inputs on average authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table v comparison results of trimming strategies programtrimming ratio grammar validity ratio built in tree based built in tree based libplist .
.
.
webkit .
.
.
jerryscript .
.
.
chakracore .
.
.
while our tree based trimming trimmed out .
on average.
on the other hand .
of test inputs after the built in trimming were grammar valid but of test inputs after our treebased trimming were grammar valid and can be further used to conduct our grammar aware mutation.
similarly the built in trimming respectively trimmed out .
.
and .
of bytes in javascript test inputs for webkit jerryscript and chakracore while our tree based trimming respectively trimmed out .
.
and .
for webkit jerryscript and chakracore.
on the other hand our treebased trimming increased the grammar validity ratio for webkit jerryscript and chakracore from .
.
and .
to which can facilitate our grammar aware mutation by improving the chance of applying grammar aware mutation which is more effective in generating test inputs that can trigger new coverage as will be discussed in section iii e .
in summary although with a relatively low trimming ratio our grammar aware trimming strategy can significantly improve the grammar validity ratio for the test inputs after trimming which facilitates our grammar aware mutation.
e. effectiveness of grammar aware mutation rq4 to evaluate the effectiveness of our grammar aware mutation strategies we compared them with those built in mutation strategies of afl which include bit flips flip1 flip2 flip4 one two four bit s flips byte flips flip8 flip16 flip32 one two four byte s flips arithmetics arith8 arith16 arith32 subtracting or adding small integers to bit values value overwrite interest8 interest16 interest32 setting interesting 32bit values to bit values havoc random application of bit flips byte flips arithmetics and value overwrite and splice splicing together two random test inputs from the queue and then applying havoc .
for the ease of presentation our enhanced dictionary based mutation strategy is referred to as ui insertion of user supplied tokens uo overwrite with user supplied tokens ai insertion of automatically extracted tokens and ao overwrite with automatically extracted tokens and our tree based mutation strategy is referred to as tree.
fig.7shows the number of interesting test inputs i.e.
triggering new coverage discovered by different mutation strategies as we fuzzed webkit.
because of space limit we omit the similar results for the other three projects.
the x axis denotes the number of test inputs that superion sequentially took from the queue and processed and the y axis denotes the corresponding number of interesting test inputs produced by different mutation strategies.
as the process of different test inputs often takes different time we do not use time to represent the x axis.
besides for clarity fig.
7omits the results when all the mutation strategies become ineffective in continuously producing interesting test inputs i.e.
when the curves in fig.
7change gently .
the results vary across different seeds.
even with seeds fixed the results may also vary across different runs due to the random nature of some mutation strategies i.e.
havoc splice and tree .
however the trend remains the same across runs and we only discuss the trend which holds across runs.
in the beginning bit and byte flips take a leading position in producing interesting test inputs.
the reasons are that i bit and byte flips often destroy the input structure and trigger previously unseen error handling paths and ii bit and byte flips are the first mutation strategy to be sequentially applied thus having the opportunity to first trigger the new coverage that could also be triggered by other mutation strategies.
gradually the number of interesting test inputs generated by our grammar aware mutation strategies outperform other mutation strategies.
specifically treeand uosignificantly outperform other mutation strategies.
these results indicate that grammar aware mutation strategies are effective in producing interesting test inputs.
besides we also explore the efficiency of different mutation strategies in producing interesting test inputs.
the results are shown in fig.
where the x axis is the same to fig.
7and the y axis denotes the ratio of interesting test inputs to the total number of generated test inputs.
surprisingly all the mutation strategies are very inefficient in producing interesting test inputs i.e.
only two of the mutated test inputs can trigger new coverage.
thus a huge amount of fuzzing efforts are wasted in mutating and executed test inputs.
therefore adaptive mutation rather than exhaustive mutation should be designed to smartly apply mutation strategies.
moreover to evaluate our enhancement to dictionary based mutation we compared the dictionary overwrite and insertion in afl with those in superion.
the results are reported in fig.
where the x axis is the same to fig.
and the y axis in fig.
9a and fig.
9brepresent the number of times each mutation is applied and the number of interesting test inputs generated.
we can see that our enhanced dictionary based mutation greatly decreases the number of mutation applications by half while still generating significantly more interesting test inputs.
in summary our grammar aware mutation strategies are effective in generating test inputs that trigger new coverage compared to the built in mutation strategies in afl.
the efficiency of all mutation strategies needs to be improved.
f .
performance overhead rq5 the fuzzing process of a test input includes three major steps parsing mutation and execution.
among them the parsing step is one off for each test input followed by a large number of mutations and executions.
in fig.
10aand10b we show the parsing time of javascript xml test inputs in milliseconds the y axis with respect to the size of test input files in bytes the x axis .
without loss of generality we only report the results for the test inputs kept in the queue.
in detail the parsing time includes the time to read parse and traverse a test input file.
approximately the parsing time is linearly correlated to the size authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
flip1 flip2 flip4 flip8 flip16 flip32050010001500200025003000 arith8 arith16 arith32 int8int16 int32050010001500200025003000 uouiaoaitree havoc splice fig.
the effectiveness of different mutation strategies in producing test inputs that trigger new coverage .
.
.
.
.
.
.
.
flip1 flip2 flip4 flip8 flip16 flip3200.
.
.
.
.
.
.
.
arith8 arith16 arith32 int8int16 int3200.
.
.
.
.
.
.
.
uouiaoaitree havoc splice fig.
the efficiency of different mutation strategies in producing test inputs that trigger new coverage a the number of mutation applications b the effectiveness in producing interesting test inputs fig.
comparison results of dictionary based mutations a javascript test inputs010203040506070 b xml test inputs fig.
the time to read parse and traverse test inputs with respect to different size of test input files.
javascript test inputs size is mostly under kb and their parsing time is .
milliseconds on average and the parsing time of xml test inputs is .
milliseconds on average.
notice that the parser generated using anltr is not optimized for the performance.
we may reduce the execution time further by improving the parser s implementation.apart from the parsing time the major performance overhead superion imposes on mutation and execution is caused by our tree based mutation.
table vireports the overhead of applying tree based mutation in the second column as well as the corresponding overhead of executing the mutated test input in the third column .
for small projects like libplist it is very fast to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table vi performance overhead on target programs program tree based mutation ms execution ms libplist .
.
webkit .
.
jerryscript .
.
chakracore .
.
perform tree based mutation and execution i.e.
the mutation took .
ms and the execution took .
ms on average.
for large projects such as webkit jerryscript and chakracore the execution took much more time e.g.
executing a javascript input on chakracore took .
ms while the mutation took .
ms on average.
considering the improvements to bugfinding capability and code coverage the performance overhead introduced by superion is acceptable.
in summary superion introduces additional overhead due to our grammar aware tree based mutation strategy.
however such overhead is still acceptable considering the improved bug finding capability and code coverage.
g. case study the javascript code fragment in fig.
11gives a representative test input that was generated by superion and triggered an integer overflow vulnerability in webkit assigned cve .
in particular this vulnerability is triggered because the method setinput in class regexpcachedresult forgets to reify the leftcontext andrightcontext .
as a result when later webkit attempts to reify them it will end up using indices into an old input string to create a substring of a new input string.
for the test input in fig.
webkit tried to get a substring through jssubstring whose length is i.e.
length of a i.e.
m result.end of ss as shown in fig.
which is a very large number when treated as positive.
thus an integer overflow vulnerability is caused.
the test input in fig.
11was actually simplified from a large test input for the ease of presentation.
it was generated by applying our tree based mutation on the two test inputs in fig.
13and fig.
.
this proof of concept was not generated through one mutation but was generated after several times of mutations.
the intermediate test inputs that triggered new coverage were kept and added to the queue for further mutations.
eventually it evolved into the proof of concept.
this vulnerability was not triggered by afl.
this indicates that afl s built in mutation is not effective in fuzzing programs that process structured inputs where our tree based mutation becomes effective.
h. discussion threats.
first we did not evaluate superion on standardized data sets e.g.
la v a and cgc .
many of the programs in these data sets process unstructured inputs or are difficult to come up with a grammar.
hence we did not use them.
instead we used four real life large scale well fuzzed programs.
second we did not empirically compare superion with the two mostly closely related grammar aware mutation based fuzzers langfuzz and ifuzzer .
langfuzz is not publicly available.
it heavily relies on the seed which is a collection of proofof concepts pocs that are difficult to obtain.
superion doesvar str ss var re str.replace b w b g regexp.input a regexp.rightcontext fig.
a proof of concept of cve jsstring regexpcachedresult rightcontext execstate exec jsobject owner make sure we re reified.
lastresult exec owner if !m reifiedrightcontext unsigned length m reifiedinput length m reifiedrightcontext.set exec vm owner m result.end !
length ?
jssubstring exec m reifiedinput.get m result.end length m result.end jsemptystring exec return m reifiedrightcontext.get fig.
the vulnerable code fragment for cve ... var str ss var re str.replace b w b g ... fig.
source test input to trigger cve ... write regexp.input regexp.input ... write regexp.rightcontext regexp.rightcontext ... fig.
source test input to trigger cve not require such prior knowledge and thus we did not compare superion with langfuzz.
ifuzzer is open source but it lacks sufficient documentation to set up.
moreover most bugs found by ifuzzer were not vulnerabilities and only one cve was exposed in their evaluation.
instead we compared superion with jsfunfuzz a successful grammar aware generation based fuzzer for javascript engines.
third we did not have a statistical significance analysis argued by klees et al.
.
this is due to the large time scale and resources involved in fuzzing real life and large scale programs for finding serious vulnerabilities.
limitation.
superion needs a user provided grammar which limits the applicability to only publicly documented formats that have specified grammars.
therefore superion may have trouble finding proprietary grammars or undocumented extensions to standard grammars.
however several automatic grammar inference techniques have been proposed we plan to integrate such techniques to have wider applicability.
iv .
r elated work instead of listing all related work we focus our discussion on the most relevant fuzzing work in five aspects guided mutation grammar based mutation block based generation grammarbased generation and fuzzing boosting.
guided mutation.
mutation based fuzzing was proposed to generate test inputs by randomly mutating well formed test inputs .
then a large body of work has been developed to use heuristics to guide mutation.
afl steelix fairfuzz and collafl use coverage to achieve the guidance and slowfuzz and perffuzz further use resource usage to realize the guidance.
buzzfuzz vuzzer and angora leverage taint analysis to identify those interesting bytes for mutation.
sage babi c et al.
pham et al.
and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
badger leverage symbolic execution to facilitate fuzzing.
dowser taintscope and borg integrate taint analysis with symbolic execution to guide fuzzing.
driller combines fuzzing and concolic execution to discover deep bugs.
karg en and shahmehri perform mutations on the machine code of the generating programs instead of directly on a test input in order to leverage the information about the input format encoded in the generating programs.
in summary these fuzzing techniques target programs that process compact or unstructured inputs which become less effective for programs that process structured inputs.
complementary to them superion can effectively fuzz programs that process structured inputs.
it is worth mentioning that application specific fuzzers have been attracting great interests e.g.
compiler fuzzing kernel fuzzing iot internet of things fuzzing os fuzzing and smart contract fuzzing .
it is interesting to investigate how to extend our general purpose fuzzer e.g.
by designing new mutation operators or feedback mechanisms to be effective in fuzzing specific applications.
grammar based mutation.
several techniques have been proposed to perform mutations based on grammar.
mongodb s fuzzer wreaks controlled havoc on the ast of a javascript test input.
while our tree based mutation is similar superion conducts the mutations in an incremental way by keeping those interesting intermediate test inputs for further fuzzing.
similarly 4sqli applies a set of mutation operators on valid sqls to generate syntactically correct and executable sqls that can reveal sql vulnerabilities.
however both mongodb and 4sqli are specifically designed for javascript or sql and hence they may not work for other structured inputs.
superion is general for other structured inputs as long as their grammar is available.
langfuzz uses a grammar to separate previously failing test input to code fragments and save them into a fragment pool.
then some code fragments of a test input are mutated by replacing them with the same type of code fragments in the pool.
similarly ifuzzer uses the grammar to extract code fragments from test inputs and recomposes them in an evolutionary way.
different from these two blackbox fuzzers superion brings grammar awareness into coverage based greybox fuzzers.
block based generation.
as some bytes in a test input are used collectively as a single value in the program they should be considered together as a block during fuzzing.
following this observation testminer first mines literals from a corpus of test inputs and then queries the mined data for values suitable for a given method under test.
these predicted values are then used as test inputs during test generation.
it is not clear whether it works well for highly structured inputs such as javascript as they experimented with simple formats such as iban sql e mail and network address.
spike and peach use input models specifying the format of data chunks and integrity constraints to regard test inputs as blocks of data and leverage mutations to generate new test inputs.
while being effective in fuzzing programs that process weakly structured inputs e.g.
images and protocols these approaches become less effective for highly structured inputs e.g.
javascript .
complementary to them superion is designed for such highly structured inputs.grammar based generation.
another line of work is to use the grammar to directly generate test inputs.
mangleme is an automated broken html generator and browser fuzzer.
jsfunfuzz uses specific knowledge about past and common vulnerabilities and hard coded rules to generate new test inputs.
dewey et al.
propose to use constraint logic programming for program generation.
valotta uses his domain knowledge to manually build a fuzzer to test browsers.
while being effective in finding vulnerabilities they all rely on some hard coded or manually specified rules to express semantic rules which hinder their applications to a wider audience.
godefroid et al.
apply symbolic execution to generate grammar based constraints and use grammar based constraint solver to generate test inputs.
csmith iteratively and randomly selects one production rule in the grammar to generate c programs.
domato generates test inputs from scratch given the grammars that specify html css structures and javascript objects properties and functions.
domato also fuzzed webkit for three months but none of our bugs were found by domato.
this is a strong evidence that superion has the characteristics that grammar aware fuzzers without coverage feedback do not have.
skyfire and treefuzz learn a probabilistic model from the grammar and a corpus of test inputs to generate test inputs.
they are generation based while superion is grammaraware mutation based which incrementally utilizes the interesting behaviors embedded in previous interesting test inputs.
fuzzing boosting.
another thread of work focuses on improving the efficiency of fuzzing e.g.
seed selection seed scheduling parameter tuning directed fuzzing to reproduce crashes or assess potential bugs found by vulnerable code matching and operating primitives .
these boosting techniques are orthogonal to superion.
v. c onclusions in this paper we propose a grammar aware coverage based greybox fuzzing approach superion for programs that process structured inputs.
specifically we propose a grammar aware trimming strategy and two grammar aware mutation strategies to effectively trim and mutate test inputs while keeping the input structure valid quickly carrying the fuzzing exploration into width and depth.
our experimental study on several xml and javascript engines has demonstrated that superion improved code coverage and bug finding capability over afl.
moreover superion found new bugs among which new vulnerabilities were discovered and cves were assigned.
acknowledgment we would like to thank micha zalewski for the american fuzzy lop fuzzer.
this research was supported in part by the national research foundation prime ministers office singapore under its national cybersecurity r d program award no.
nrf2014ncr ncr001 award no.
nrf2016ncrncr002 and administered by the national cybersecurity r d directorate.
bihuan chen is the corresponding author of this paper.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.