auto patching dom based xss at scale inian parameshwaran enrico budianto shweta shinde hung dang atul sadhu prateek saxena national university of singapore singapore inian enricob shweta24 hungdang atulsadh prateeks comp.nus.edu.sg abstract dom based cross site scripting xss is a client side code injection vulnerability that results from unsafe dynamic code generation in javascript applications and has few known practical defenses.
we study dynamic code evaluation practices on nearly a quarter million urls crawled starting from the the alexa top websites.
of 082cases of dynamic html js code generation we observe use unsafe string interpolation for dynamic code generation a well known dangerous coding practice.
to remedy this we propose a technique to generate secure patches that replace unsafe string interpolation with safer code that utilizes programmatic dom construction techniques.
our system transparently auto patches the vulnerable site while incurring only overhead.
the patching mechanism requires no access to server side code or modification to browsers and thus is practical as a turnkey defense.
categories and subject descriptors d. .
automatic programming d. .
testing and debugging d. .
operating systems security and protection keywords web security taint analysis dom based xss auto patching .
introduction javascript has become a de facto scripting language that powers popular web applications browser extensions or add ons html5 mobile applications e.g.
webview windows metro apps and server side applications e.g.
nodejs apps .
recent experimental systems have demonstrated that javascript can be used to develop traditional games browsers and even an operating system .
however presently applications built with javascript are fraught with security holes for example code injection in javascript applications such as dom based xss is known to be highly pervasive and an elusive category of vulnerabilities for many commercial scanners to find .
a majority of popular web sitesincluding google twitter and yahoo have recently been vulnerable to these attacks .
dom based xss has few known practical defenses.
conceptually several defense in depth techniques are known to thwart dombased xss however their practical deployment requires intrusive changes to the application and do not retain compatibility with older browsers.
for example content security policy csp and capability controlled dom are two techniques that can ensure that javascript code only from whitelisted sources can be evaluated in a website.
however these techniques require significant rewriting of applications to be made practical and as result less than of the sites have deployed these protections .
further these techniques work only on browser backends that support csp or ecmascript features.
defenses which rely on browser specific implementations or new language features fail to protect applications on existing browser and html5 backends.
at the same time the number of browser backends are proliferating there are over mobile browser vendors on the official android market each with over a million users .
the root cause of dom based xss vulnerabilities is unsafe software engineering or coding practices specifically the use of unsafe string interpolation in dynamic code evaluation constructs.
a common defense developers employ is to validate or sanitize untrusted data before using it in dynamic code evaluation constructs.
however this mechanism is well known to be prone to errors in designing sanitization routines and mediating on all uses of dynamic code evaluation constructs consistently .
in this paper we propose a new approach to protecting javascript applications based on auto patching.
our approach aims to retrofit protection to existing javascript applications requiring only standard browser features available in existing browser implementations.
most previous prevention techniques have targeted browser based script blocking or application of sanitization routines in client side code rather than rectifying the code to perform safe code evaluation.
our proposed approach is to automatically synthesize secure code patches which replaces unsafe application logic responsible for dynamic code evaluation.
the generated patches generate dynamic code without invoking the html parser with untrusted strings in the browser.
instead our patches directly construct the rendered page by using alternative dom construction api a well known robust programming practice which eliminates the need for sanitization .
we develop a complete system called d exter js for automatically synthesizing patches for dom based xss vulnerabilities in javascript applications.
d exter js performs dynamic analysis to detect and repair dom based xss bugs in real web applications.
our automatically synthesized patches are directly deployed on the website via a hot patching mechanism we develop offering a quickfigure a cumulative distribution function cdf of zero day exploits found in alexa top sites.
defense that requires no developer effort.
our patches are browseragnostic require no browser or server side code modifications and do not require users to install any plug ins or add ons.
results .
we have released our core analysis engine d exter js as a cloud hosted proxy for detecting dom xss .
in our evaluation we have used d exter js on nearly a quarter million urls crawled starting from the alexa top websites.
first we find dom based xss vulnerabilities are exploitable a finding that is consistent with similar reports .
d exter js generates exploit exhibiting witnesses for these exploitable cases automatically.
second we find that of the 082dynamically generated code fragments observed during our evaluation of the cases utilize unsafe string interpolation.
this suggests that disabling all dynamic code evaluation is likely impractical and perhaps an overkill since developers often use safe programming practices in dynamic code evaluation.
finally our system successfully generates safe patches for all the vulnerabilities it confirms to be exploitable.
the auto patched websites show an average performance overhead of which is not significantly perceivable for interactive use.
this enables auto patching as a turnkey defense for existing sites.
contributions.
in summary we make the following contributions automated patching we propose a backwards compatible auto patching defense for dom based xss.
our approach requires no modification of browsers or server side code and requires no developer effort.
browser agnostic fine grained tainting dexter js comprises of a browser agnostic javascript rewriting engine performing character precise fine grained taint analysis robustly.
it is tested on several popular web browsers including firefox chrome internet explorer and safari.
we have released it for public testing .
new findings we carry out an extensive evaluation of the alexa top sites.
we crawl links from the top alexa websites and analyzed javascript code from urls resulting in over 082distinct dynamic code evaluation instances constructed from untrusted data.
first we find that approximately of these instances arise only on certain browsers owing to subtle browser variations highlighting the advantages of browser agnostic detection and defenses.
second we find that developers use unsafe coding practices when generating dynamic web content in of all the cases.
third a total of 820distinct zero day dombased xss vulnerabilities across 89different domains were confirmed to be exploitable.
583of these exploits were from the alexa top domains figure the remaining were from external iframes embedded in these websites.
finally all the found vulnerabilities are auto patched with a average performance overhead of .
.
problem overview as opposed to traditional reflected and persistent xss dombased xss executes purely at the client side rendering server side sanitization insufficient.
we give an example to motivate the specific problem we tackle in this work.
.
motivating example dom based xss is a code injection vulnerability in which a web attacker is able to inject malicious javascript in a client s web session.
in the attack we assume that the attacker can entice an unsuspecting user into visiting a url of his choice.
the attacker embeds the attack payload either directly into the maliciously crafted url pointing to the victim website or may load the victim s web page in an iframe and subsequently pass data to it say via the postmessage api .
using these mechanisms the attacker can control some data which the victim site consumes when executed on the client s browser.
a simple example of a vulnerable javascript application is shown in figure a .
in the attack the user clicks an attacker provided url which he can craft targeting the victim s web browser e.g.
img src onerror alert .
the vulnerable javascript code runs in the domain foo.com .
the code snippet programmatically reads the location of the webpage using location.href .
it constructs a string with this information and uses the browser s dynamic html generation constructs likeinnerhtml to render the string as html code in the client s browser.
the attack succeeds because the javascript code renders attackercontrolled strings an img tag embedded in the url in this case as html content.
the attacker s payload automatically triggers a javascript event allowing the attacker to run arbitrary code on behalf of the origin foo.com .
as a preventive measure against xss attacks several browsers deploy client side xss filters .
these filters are quite effective against its server side counterpart reflected xss .
however dom based xss attack vectors can easily bypass these browser based xss filters .
safe sanitization of untrusted string embedded in html content is a known difficult problem prone to errors .
safer coding practices.
a cleaner and more effective approach is to avoid using code evaluation constructs such as innerhtml on unsafe data as a safer coding practice.
for example the logic in figure a can be alternatively programmed with safer code shown in figure b which preserves the intended functionality of the original code.
the vulnerable code interpolates untrusted string values into a fixed string and then evaluates the interpolated string as html.
instead the safe code renders the same visual dom using safer dom construction api without invoking the html parser.
as discussed in previous work c.f.
blueprint this approach preserves the intended structure of the dynamically generated html and cleanly separates the code from attacker controlled data.
other code evaluation constructs that evaluate strings e.g.
eval event attributes can similarly be replaced with programmatic constructs that avoid string interpolation e.g.
using json.
parse instead .
in our large scale evaluation we find that developers often make use of programmatic dom manipulation e.g.
attaching attributes or extending dom hierarchies rather than unsafe html evaluation on attacker controlled data e.g.
using innerhtml .
direct code evaluation of strings interpolated from attacker controlled data such as in our vulnerable example accounts for less than of the cases.
our defense goal is to identify and convert such vulnerable constructs to safe code by patching the application.1234567891011varevil location.href vard newdate varn d.getdate varx document.getelementbyid target varv1 document.createelement a v1.setattribute id n varv2 document.createtextnode evil v1.append v2 varv3 document.createelement div v3.appendchild v1 x.appendchild v3 12345varevil location.href vard newdate varn d.getdate varx document.getelementbyid target x.innerhtml div a id n evil a div a b firefox src onerror alert figure a example of string interpolation followed by code evaluation unsafe coding practice .
b example of code which uses programmatic dom constructs and avoids dom based xss attack safe coding practice .
div a id n evil a div test harness12 patch div a id img src onerror alert a div patch points taint infotemplatetemplate db patchedjavascriptruntime input patch synthesis pre deployment phase patched execution post deployment phase safe dom tree figure approach overview of dexter js patch point identification template inference hot patching template selection runtime template instantiation for safe dom rendering.
.
problem statement we refer to all the points in the program where attacker controlled data is used in a code evaluation construct as dynamic code evaluation points dce points .
only a fraction of these are actually vulnerable to dom based xss and are candidates for autopatching1.
this subset is called as patch points .
by default d exterjs generates patches for patch points.
developers can configure d exter js to generate patches for other unconfirmed dce points as well.
goal auto patching vulnerable applications.
dexter js takes as input a website which may be vulnerable to dom based xss a benign test harness and a list of browser backends on which the website renders correctly2.
as output d exter js generates a list of confirmed dom based xss exploits and the auto patched javascript application that invokes the patch see figure .
the code patch applied by d exter js to safeguard vulnerable web applications should satisfy the following properties.
correctness.
the patch should render a valid dom tree preserving the structure of the dom created by the original operation at the patch points for inputs observed during the execution of the test harness.
this property specifies a necessary condition to ensure that the patch does not break the original functionality of the application.
safety.
the patch should never execute script code from data under the direct control of the attacker for all inputs reaching the patch points.
browser agnostic.
the patch added by d exter js should 1rest of them may not be exploitable by the virtue of proper sanitization defense in place.
2the test harness can either be a set of functional test cases selenium scripts or a url test suite.
alternatively d exter js can automatically crawl to generate the test harness.not use any non standard or browser specific language features that are unsupported by the given set of browsers.
low overhead.
the patched applications should have a minimal performance overhead.
overview deployment setting.
dexter js does not require any user installation on the client s end or access to the server side code.
website developers and testing teams can use d exter js service via a proxy to analyze and auto patch their applications.
therefore the instrumented code can be easily sent out from proxy server to their web browser or analyzed by a cloud based browser backend.
d exter js aims to achieve scalability and compatibility with existing web applications and platforms.
.dexter jsapproach dexter js system comprises of two phases shown in figure a pre deployment analysis phase and patched execution in the deployment phase.
in pre deployment analysis d exter js executes the application under the given test harness.
during this process it observes if the application uses any string interpolation for code generation.
for each such instance d exter js infers a set of benign dom or parse trees that the application intends to generate by evaluating the interpolated string.
in essence these benign parse trees define a fixed template which can be instantiated at runtime with attacker controlled values safely3.
in our pre deployment testing we create a database of such whitelisted or allowed templates and instrument the application to instantiate the templates securely at runtime.
in deployment the instrumented patches inserted by dexter js select the appropriate template from the whitelisted database and instantiates it using safe programmatic dom construction api available in all commodity web browsers.
3our templated execution is analogous to how prepared statements in sql help avoid sql injection.
.
patch synthesis during the pre deployment phase d exter js first instruments and analyzes the given javascript application see figure .
this includes extracting the position of all dce points verifying if they are exploitable and marking the exploitable dce points as patchpoints.
d exter js utilizes character precise dynamic taint tracking to infer dce points.
further d exter js infers the template structure using the taint information identifying the attacker controlled bytes in the string used for generating client side code.
table default sources and sinks used by dexter js.
sources sinks html innerhtml outerhtml script.src image.src script.text script.textcontent script.innertext write writeln javascript eval settimeout setinterval locationurl baseuri documenturi window.location document.location location.hash location.search location.hrefwindow.location document.location location.href location.assign location.replace storagecookie localstorage sessionstoragecookie localstorage sessionstorage postmessage postmessage data window.postmessage .
.
identifying patch points vulnerabilities dynamic taint analysis.
we use dynamic taint analysis to detect all flows from unsafe input sources i.e.
can be controlled by attacker to code execution sinks .
for this our d exter js server instruments client side application code and runs the instrumented code in multiple browsers.
during this benign run of the application the character precise taint tracking records all the flows that use the tainted portions of the string in code execution constructs.
the code execution sinks for these flows are then marked as dce points.
for example the instrumented code must report the taint flow from the taint source location.href line to the taint sink x.innerhtml in figure a .
d exter js uses the sources and sinks defined in table by default.
we build a source to source rewriting infrastructure for embedding fine grained dynamic taint tracking logic in the original application.
the challenges in implementing such a system that scales and is robust for real world applications are discussed separately in section .
d exter js s taint analysis engine instruments application code to perform both positive and negative tainting .
by definition positive tainting identifies and tracks trusted data originating from constants.
on the other hand negative tainting focuses on untrusted data derived from attacker controlled inputs.
tracking both positive and negative taint helps us determine the set of values which are neither positively nor negatively tainted.
for example values which are derived from sources such as date math.random etc.
are non deterministic but benign.
the attacker controls only parts of the string which are negatively tainted.
this information is later used for auto generating patches.
verifying exploitability.
dexter js verifies whether the dce points are actually exploitable and if so marks them as patchpoints.
it generates browser specific exploits based on the exact context wherein the tainted data is being interpreted .
our attack rules are based on publicly known strategies such as the xss filter evasion cheat sheet .
finally d exter js executes all the generated candidate attack vectors in commodity browsers and verifies their exploitability.
all the confirmed exploitable flows are then grouped as patch points and are given to the next phase of the dexter js system for patching see figure step .
.
.
template inference dexter js treats each patch point separately and gives it a unique identifier id.
during a benign run in the pre deployment phase dexter js s synthesis engine records every runtime string sthat has been passed to a particular patch point p. apart from the string the engine also receives a corresponding taint type tfor each character that forms s. recall that the taint type of each character can either be positive negative or non deterministic .
to determine a benign parse tree of s dexter js relies on commodity browser engine to programmatically convert sinto a dom tree object.
this is done via an api parsefromstring which is available in all mainstream browsers.
using the resulting dom tree object of s along with the taint information t the synthesis engine then determines nodes of the dom tree which are negatively tainted under the attacker s control and nodes which are positively or non deterministically tainted.
this dom tree information along with the augmented taint information for each node is referred to as a template .
the template is a model of the benign structure of code generated at p. using a template d exter js can determine all the static parts of the tree i.e.
positively tainted nodes and then use it to fix the expected structure.
on the other hand all the nodes in the tree that are either negatively or nondeterministically tainted are considered as holes which are intended to be filled based on the runtime string at p. finally d exter js collects all the templates generated at each patch point into a whitelisted template database .
example .
we illustrate d exter js s template inference process with the help of the running example discussed in section .
in figure a innerhtml the sink in this case is used to add a new anchor tag inside a div element.
d exter js receives a tainted string salong with its associated taint range t. next the synthesis engine parses sinto its corresponding dom tree.
along with this dom tree and the taint information tobtained from step it generates a template see figure step .
the synthesis engine uses this template to infer that the div element is a static structure whereas the values of idandtext of a element are holes.
.
.
hot patching during the pre deployment phase d exter js also adds hooks at the patch points such that the program will execute the patch function instead of the original code evaluation construct.
this is akin to the notion of hot patching during software updates .
thepatch function implementation is added to the beginning of the instrumented program in global scope ensuring its visibility throughout the program.
figure step illustrates the redirection of control flow through hot patching from innerhtml topatch function.
.
patched execution all the heavy weight analysis for identifying the patch points is done before deployment.
once the application is deployed on the server only instantiating the correct patch is delegated to runtime thus minimizing the performance overhead at runtime.
.
.
runtime template instantiation thepatch function takes in two parameters the static identifieridof the patch point and a runtime string s0which is passed to the dce point.
d exter js inserts the database of whitelisted templates obtained during the template inference step along with the patch function into the vulnerable page before deployment.
the patch function queries this database based on the id to find the right template to be applied to the runtime string s0.holedivainnerhtmlid holepatch divainnertextid n img src onerror alert templaterendered dom safedomapi whitelistedtem p latedatabase runtime string s div a id img src onerror alert a div created using setattribute created using createtextnode appendchild figure template instantiation showing how the template holes are populated from the input and rendered using safe dom construction api.
safe dom rendering.
the goal of the patch function is to renders0such that the dom tree generated in the browser is free from xss payloads and contains valid benign markup.
to do this we use the b uild safe dom procedure shown in algorithm line .
the first preparatory step is to parse s0into a preliminary dom structure which is not rendered directly as it is derived from the untrusted string s0 line .
then we match this structure with a template from the whitelisted template database variable tmpl at line .
the matching procedure starts from the root comparing each node of the preliminary dom with the template recursively line .
if the template and the preliminary dom match at all nodes except at the holes then the algorithm has found runtime values to fill in the holes.
this is illustrated in figure .
the final step is to generate code and render the entire dom tree securely see figure step .
the fixed structure of the template is constructed directly from the whitelisted template not from the preliminary dom using standard dom construction apis.
the values that match the holes in the preliminary dom derived from s0are rendered via safe dom construction api that do not interpret strings as code.
specifically these apis are setattribute andcreatetextnode underlined at line which prevent script execution .
the entire approach only renders whitelisted nodes completely independent of runtime values in s0 and uses non code evaluating constructs to append strings from s0 to the rendered tree.
thus this is a principled approach to separate code from data.
as a result all untrusted strings are prevented from reaching code evaluating dom api and achieve the equivalent of executing the safe code shown in figure b .
if the template and the preliminary dom do not match at all nodes except for the holes this is a template which has not been encountered in our testing.
in such cases we have two options either to proceed with the rendering which may be vulnerable or to avoid rendering the string preserving compatibility .
we leave this as a configurable option to the end system user our default presently is to be safe and not render the string.
there are possible cases where just using safe dom construction techniques are not enough.
this can happen if attacker controlled data is used inside a script tag event attributes or in the src attribute of a script oriframe tag.
however such cases were extremely rare in our evaluation of urls and were often non exploitable because of existing sanitization.
nonetheless our algorithm uses a whitelisted policy for the resource name for the rendered string similar to what has been proposed in the previous work .
this is indicated as the context valid check in algorithm to protect against such cases.
.
.
runtime template selection there can be multiple templates for a given patch point if multiple control flow paths reach the same patch point for example if there is an if else branch before the patch point .
in this case dexter js should determine which one of these templates is toalgorithm patching technique using safe dom construction procedure patch id s0 tmpl get template id build safe dom get rootnode tmpl get rootnode parse s0 procedure build safe dom nt nr ifnris root and nt tagname6 nr tagname then issue warning else if nt tagname nr tagname then forattribute ainlist attr nr do ifa 2list attr nt then restructure nt html stringify a else nt setattribute a name context valid a value ifnt children length nr children length then forc2list child nr c02list child nt do build safe dom c0 c else isnewtmpl true forc2list child nr do ifis unique c nr children then c0 get associated node c nt children ifc0is then restructure nt html stringify c else isnewtmpl false build safe dom c0 c ifisnewtmpl istrue then issue warning procedure restructure n elm str hole get hole n ifhole is an attribute then sval context valid hole value elm str n setattribute hole name sval else if hole is a child node then text node doc createtextnode context valid em str n appendchild text node be imposed on the runtime string see figure step .
previous works also face this challenge in the context of server side code and there are several ways to handle this.
scriptgard uses the code path and the calling context in the program to determine the appropriate choice of structure.
in our work we resolve ambiguity in contexts using the dom position the identity of the parent dom node to which the newly generated dom sub tree will be attached.
if the dom position is the same for two templates at a patch point d exter js can record information about the path context along with the template.
this is obtained by path profiling during pre deployment testing.
in this case we can use the path context at runtime to resolve the ambiguity as done in scriptgard .
dynamic path context aggregation requires additional profiling but is only necessary in an extremely small number of cases where the dom position alone is not sufficient to resolve the ambiguity.
a richer and more expressive template language could be used instead of a whitelisted template database to account for these variations.
however in our evaluation we have not seen this selection ambiguity given the relatively small number of patchpoints per web application i.e.
we always have a unique patch to apply at each patch point based on the dom position.
.
js analysis engine dexter js system analyzes all the javascript code dynamically to determine if the application is unsafe specifically if any attackercontrolled value is used as code to generate html.
we design our own information flow analysis for tracking attacker controlled data.
.
technical challenges several previous works propose both static and dynamic analysisof javascript .
however several challenges arise when achieving the same goals in the context of auto patching problem.
browser independent javascript analysis.
for compatibility and effectiveness the analysis and patching logic should not be integrated in a specific browser or a javascript engine.
an alternative is to leverage the language s object level abstraction which makes the approach more generic .
complete mediation on executing javascript.
javascript supports dynamic code generation via eval reflection etc.
to hot patch all the dom based xss vulnerabilities in a given web application it is essential to instrument code generated through these constructs on the fly.
robust handling of complete javascript features.
javascript has many complex built in constructs native functions and primitive operators.
it is crucial to handle these language semantics in our instrumentation to preserve the original functionality of the application.
.
design taint tracking engine source rewriting.
one of the main challenges in carrying out browser independent program analysis is that browsers vary a lot making such an analysis cumbersome if it is not done through source code rewriting.
building such a fine grained transformation system that can scale up is non trivial.
in fact recent tools alternatively resort to either record replay or combine static and dynamic techniques to tackle the challenges posed by features and subtleties of javascript .
we explain how d exter js achieves robustness and a clean design in its instrumentation for inlining taint tracking logic some of which build upon the ideas of object wrapping previously proposed but incorporate many additional new strategies to maintain complete compatibility with real javascript code.
dexter js performs source to source rewriting for characterprecise taint tracking for strings.
it instruments javascript on the fly via a proxy server as the website is executed under the given test harness.
the taint propagation logic and metadata is kept within the website s execution context in the browser.
such heavy weight instrumentation is quite intrusive and we explain two key choices dexter js makes regarding where to keep taint metadata and how to instrument each string operation in the javascript application.
the subtleties of preserving application correctness in the presence of such instrumentation is discussed in section .
.
.
.
attaching taint metadata dynamic taint analysis needs to store the taint information for primarily strings in the program to detect xss flows .
in this section we discuss various approaches to store taint metadata which do not scale and how our solution of object wrapping is both scalable and plays well with javascript semantics.
storage in a separate namespace.
traditional dynamic taint analysis for languages such as c store the taint metadata in a separate namespace e.g.
shadow memory .
this is not a viable solution since javascript cannot access the address of any variable.
storage in a global namespace.
taint metadata can be stored in the same namespace of the program using alpha renaming of metadata variables to resolve namespace conflicts.
however since scoping rules are inconsistent across different browser implementations as we show in our evaluation reasoning about the namespace of a variable is not straightforward.
further storing the taint metadata in the global namespace quickly blows up the program s memory usage.
using a fixed set of variables analogous to fixed set of registers available in the cpus to store the taint metadata leads tooverly complex spilling management in the instrumentation .
we adopt a more efficient solution that works generically for global and function scoped data.
per string storage.
in all the above strategies the taint information of each variable is stored in separate variables.
storing the taint information as a property of the string would preclude costly lookups in taint maps.
this is an elegant solution which solves scoping as well as performance challenges.
we adopt this approach with one caveat attaching properties to primitive data types like string literals fails silently in javascript see listing .
listing infeasibility of attaching taint with string literals.
1var a foo a is a string literal 2a.taint true 3console.log a.taint prints undefined listing conversion to objects to track taint information.
1var a new string foo a is string object 2a.taint true 3console.log a.taint prints true although javascript does not allow adding properties to string literals objects have no such limitation.
therefore a viable strategy is to box the string literals to string objects and then attach the taint property to them4.
further this mechanism implicitly propagates the taint in cases of assignments and function calls.
hence we convert all the string literal to string objects and then use them to store the taint information.
note that there are subtle differences in the semantics of string objects and string literals as discussed in section .
.
.
.
inlining propagator logic the exact point of insertion of the taint propagation statements in the instrumented code is also a crucial design choice.
na ve approaches like inserting such statements after every statement of the original program leads to re execution of code in our taint propagation statements breaking the semantics of the program.
our taint propagation logic has to be embedded at a more fine grained level within the original program.
to solve this challenge d exter js uses a standard feature of javascript called immediately invoked function expression or iife .
this feature allows a function to be defined and immediately invoked within a single block scope construct and has consistent semantics in all browser implementations.
an example of our instrumentation for the code statement in figure a is shown in figure b .
1var a b foo a 1var a function 2var rhs b return rhs foo b figure a un instrumented input program.
b iife used to group taint analysis statements.
our mechanism of using iife has several advantages in achieving memory efficiency and nesting of instrumentation.
first it uses function scoping so temporary variables used in the instrumentation rhs are scoped within the iife and can be garbage collected immediately after the iife finishes executing.
second since iife is a function closure it has access to all the variables declared outside the iife.
for example bcan be used within the iife even though it wasn t declared within it.
this preserves the original scope of the un instrumented statement.
third iife encapsulation also extends naturally to nesting of iife scopes that is necessary to compute taint for multiple sub expressions of a larger expression.
4our definition is similar to the concept of boxing in java.
.
completeness in handling javascript dexter js handles a variety of practical cases for javascript in the wild.
we discuss the interesting challenges here and our solution to handle these.
.
.
dynamic evaluation javascript supports various dynamic code generation constructs likeeval and the function constructor as well as constructs for fetching data from external sources dynamically.
at times the arguments to these functions are only known during runtime and hence can be instrumented only then.
to this end the arguments to these functions are sent back to the d exter js s instrumentation server using xmlhttprequest .
this returns the instrumented version of the code which is then passed to the respective function.
the input program using eval and a na ve instrumented program of the same is shown below with some details elided for brevity.
listing sample code using eval 1var code var a 2eval code the value of a is here listing na ve instrumentation strategy for eval 1var code var a function var temp1 code temp2 new xmlhttprequest temp2.open post instrumentationserverip false temp2.send temp1 temp2.responsetext contains instrumented code return eval temp2.responsetext a is not defined here recall that d exter js wraps eval using an iife as shown in listing .
however eval function poses an interesting case any variable that is created using eval will bound to the scope where eval is called.
therefore the variable awould only be defined within the iife and accessing aoutside it would result in a reference error thereby breaking the original program semantics.
for such cases e.g.
instrumenting eval where iife instrumentation results in incorrectness we instead use a sequence expression to group statements without creating a function scope.
sequence expressions syntactically expr expr combines multiple expressions into a single expression .
the final correct instrumentation logic for listing is shown in listing .
listing sequence expressions to instrument eval 1var code var a temp1 code temp2 new xmlhttprequest temp2.open post instrumentationserverip false temp2.send temp1 temp2.responsetext contains instrumented code temp3 eval temp2.responsetext temp3 the value of a is here .
.
reflection javascript has constructs for reflection permitting application code to self inspect and manipulate program code during runtime.
for example it can be used for listing all properties of an object or searching for a particular string inside a function definition.
as an example in listing if the function foo is transformed into another function called wrap foo by the instrumentation foo.caller will return wrap foo instead of bar.
listing function foo accesses its caller s object through caller property.
temp is the string representation of bar 1function foo var temp foo.caller.tostring 2function bar foo 3bar to handle reflection d exter js hooks reflection constructs and returns values that match the original application semantics.
reflection is used quite commonly on popular websites we discusstwo common idioms and how d exter js handles such cases.
as a first example function.caller property returns the function that invoked the specified function.
since we use iife to aid in the instrumentation process this changes the value of the caller property and may lead to a change in the intended program behavior.
we ensure that we return the correct value of this property by recursively calling it till we find an un instrumented function.
as a second example consider a snippet of code inspecting the tostring property of a function.
the tostring property of a function returns a string representation of the function s declaration as shown in listing .
in this example a.tostring returns the string representation of the instrumented function whereas the expected behavior would be to return the string representation of the un instrumented function.
since there is no simple way to convert the instrumented code snippet back to its original version the results of each instrumentation is stored on the server.
the tostring function of each function is then overridden to request the un instrumented version from the server which is then used in the program.
d exter js handles these and many such real world cases in a similar fashion.
listing program using tostring property of a function 1function a foo bar 2a.tostring function a foo bar .
.
built in constructs and native functions special javascript constructs such as value of this for in arguments and re definitions of native functions must be preserved even in the instrumented version of the javascript program.
we discuss how d exter js wraps