borrowing your enemy s arrows the case of code reuse in android via direct inter app code invocation jun gao university of luxembourg luxembourg jun.gao uni.luli li monash university australia li.li monash.edupingfan kong university of luxembourg luxembourg pingfan.kong uni.lu tegawend f. bissyand university of luxembourg luxembourg tegawende.bissyande uni.lujacques klein university of luxembourg luxembourg jacques.klein uni.lu abstract the android ecosystem offers different facilities to enable communication among app components and across apps to ensure that rich services can be composed through functionality reuse.
at the heart of this system is the inter component communication icc scheme which has been largely studied in the literature.
less known in the community is another powerful mechanism that allows for direct inter app code invocation which opens up for different reuse scenarios both legitimate or malicious.
this paper exposes the general workflow for this mechanism which beyond iccs enables app developers to access and invoke functionalities either entire java classes methods or object fields implemented in other apps using official android apis.
we experimentally showcase how this reuse mechanism can be leveraged to plagiarize supposedly protected functionalities.
typically we were able to leverage this mechanism to bypass security guards that a popular video broadcaster has placed for preventing access to its video database from outside its provided app.
we further contribute with a static analysis toolkit named dicider for detecting direct inter app code invocations in apps.
an empirical analysis of the usage prevalence of this reuse mechanism is then conducted.
finally we discuss the usage contexts as well as the implications of this studied reuse mechanism.
ccs concepts security and privacy software security engineering .
keywords android java reflection dici acm reference format jun gao li li pingfan kong tegawend f. bissyand and jacques klein.
.
borrowing your enemy s arrows the case of code reuse in android corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa association for computing machinery.
acm isbn .
.
.
.
direct inter app code invocation.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
.
introduction code reuse a.k.a.
software reuse is a form of knowledge reuse in software development that is fundamental to accelerate innovation.
its practice in software engineering is as old as programming itself and has been exacerbated recently within mobile programming frameworks to respond to the needs for keeping up with market requirements of up to date functionalities.
the facilities offered by android in this respect have even enabled a large number of software authors to contribute to the application ecosystem often with little professional training .
reusability is at the core of the android ecosystem which builds on the popular linux kernel and the java and xml languages to benefit of the extent of device drivers and software libraries to bootstrap functionality development.
unfortunately the staged compilation process as well as the packaging model makes android apps straightforward to reverse engineer and copy.
this has led to a situation where cloning a.k.a.
repackaging is commonplace .
at an inner level android intents and intent filters facilitate decoupling and assembling of app components providing opportunities for reuse of existing components to interact with new components.
for example malware writers are extensively exploring these reuse facilities to piggyback malicious code on legitimate app by leveraging events e.g.
sms incoming broadcast to trigger malware execution.
more generally component hijacking in android has been largely investigated in the literature by evading permission checks an android app may access resources that it is not allowed to.
in this respect inter component communication icc analyses have been proposed to track data leaks as well as to detect permission redelegations attacks .
further investigations were performed in the literature towards uncovering potential app collusion i.e.
cases where a set of apps are able to carry out a threat in a collaborative fashion.
app collusion is indeed generally associated to information leakage and inter app communication where developers leverage android implicit and explicit messaging services to orchestrate legitimate rich scenarios or devise sophisticated attacks.esec fse november virtual event usa jun gao li li pingfan kong tegawend f. bissyand and jacques klein in this paper we dissect a less advertised reuse mechanism that is available in the android framework through which developers can invoke a given functionality code implemented in another app.
we refer to it as direct inter app code invocation dici .
to the best of our knowledge this mechanism was never mentioned in the android research literature.
dici is often used in legitimate contexts such as across google mobile services1to enable functionality reuse among apps.
nevertheless as we will demonstrate in section dici can be used maliciously to plagiarize other wise protected functionalities and by pass standalone app analysis.
the dici mechanism achieves inter app interactions without leveraging the android standard inter component communication primitives.
this mechanism builds on java reflection and a set of dedicated api methods that are provided within the android framework.
dici differs from existing reuse mechanisms in various ways in contrast to cloning of entire apps or copy paste of code fragments dici does not require including the targeted functionality code in the attacking app.
this property is leveraged by attackers to bypass security assessment where the attacking app is analysed.
it also results in an app of smaller size while avoiding potential decompilation issues e.g.
some code cannot be decompiled properly with the attacked app.
finally the attacking app is easy to maintain when the attacked app is updated.
last but not lest dici also requires little understanding of the implementation details of the leveraged apps since developers only need to know and invoke the entry method for a given functionality relevant methods and classes will be loaded and invoked automatically even for native methods.
unlike icc dici can allow the invocation of functionality that is not implemented within an android component such as a library function in another app.
in other words dici widens the reuse surface with dici any code can be invoked not only code that is in specific components such as with icc.
finally dici can be leveraged to implement stealthy code reuse.
indeed while with icc the developer of the reuse target may be aware that her code could be reused it is not necessarily the case for dici.
in android a component such as an activity or a service has its exported attribute set as true when the developer wishes to allow icc from another app.
such a developer may then take appropriate measures to ensure component security.
in the case of dici a developer of an app is not aware that her code will be invoked by a third party.
the main contributions of our work are we expose a little advertised reuse mechanism within the android ecosystem.
in particular we demonstrate how it can be leveraged to perform stealthy functionality plagiarism that may not be covered by standard licensing scheme.
we develop a static analysis tool dicider for the detection of dicis in android apps.
we perform an empirical analysis on the prevalence of dicis among a large dataset of apps retrieved from the androzoo repository .
we further provide extensive discussions on how and why developers use dicis through an analysis of sample cases.
we propose an example of countermeasure that could be used by developers to protect their apps against dici.
1gms are the apps by google that often come pre installed on android devices.
they are not part of the android open source project2 dissection of the dici mechanism we provide a problem statement for the direct inter app code invocation mechanism section .
and showcase some motivating examples of reuse based on this mechanism section .
.
.
direct inter app code invocation in android given the lack of related information on the mechanism of direct inter app code invocation within the android research literature we contribute to the body of knowledge by presented an overview of the mechanism.
dici is a mechanism for inter app communication i.e.
the possibility for one app to leverage resources either functionality or information from another app during its execution .
figure summarizes how inter app communication works in android by illustrating dici in comparison with the standard icc i.e.
inter component communication .
comp1android frameworkcomp2app1app2cls2android icc intent dici figure the two types of inter app communication android icc and dici.
icc is the standard mechanism used by developers as recommended in the android documentation to achieve inter app communication.
its capabilities and challenges have been and still remain intensively studied in the research literature.
icc is an android specific mechanism that was implemented to enable interaction among android components i.e.
the basic units that are composed to form apps.
indeed the four types of components namely activity service broadcast receiver and content provider which are responsible for different tasks cannot directly invoke each other s functionalities.
developers must then rely on specific icc methods such as startactivity to achieve this interaction.
as illustrated in figure an android icc is triggered by the android framework.
thus there is no direct connection between the source and target components at the code implementation level .
when the target component of an icc belong to a different app than the source component an inter app communication is implemented.
beyond icc we have come across cases in the practice of android app development where inter app communication can be achieved through direct code invocation.
we refer to such a mechanism as dici.
as illustrated in figure dici can not only bypass the android icc mechanism to realize inter app communication but also directly invoke non component code e.g.
standard java class cls2 in figure .
the latter capability is not available through the recommended icc mechanism.
problem statement.
to date icc based inter app communication has been widely investigated by the research community .
the literature provides extensive results on trackingborrowing your enemy s arrows esec fse november virtual event usa information flow through icc statically flagging how such interapp communications are leveraged by attackers to achieve malicious behaviours e.g.
privacy leaks .
studies of how malware is written in bulk through reusing legitimate apps i.e.
piggybacking have mainly focused on investigating how icc is relied upon to trigger malicious payload.
our hypothesis is that dici yielding a larger reuse surface poses challenges that are at least as acute as for icc.
indeed dici may be used by attackers to achieve malicious code invocations while bypassing the security analysis tools which have been focused on icc based scenarios.
furthermore our work raises awareness among the developer community on the possibility of having their functionalities reused without their knowledge by either plagiarists or malicious attackers.
finally for the research community exposure to this reuse mechanism in the android realm re opens a variety of research directions.
.
dici in action we highlight the possibilities that offer the dici mechanism with two motivational use cases.
both cases involve the development of apps that reuse code available in other apps.
stealthapp is designed to orchestrate an app collusion scenario for private data leak.
in this example we focus on the possibility of leveraging dici to hide malicious code in order to increase the chances of escaping detections that are attempted via static analyses.
tiktokdownloader showcases the critical possibilities that dici provides in terms of plagiarism.
in this example functionalities including backend infrastructure of one of the most popular apps in the world namely tiktok are reused to build at no cost a video sharing app.
in particular we show that we can reuse several tiktok functionalities we can provide additional functionalities that are initially forbidden by tiktok we can even leverage the full infrastructure of tiktok.
.
.
malicious code hiding.
the international mobile equipment identity imei is a number used as a standard to identify mobile phones.
it is considered to be a key private information and should be kept private .
consequently apis to obtain the imei are classically considered in the list of sources for data flow analyses thus facilitating detection of leaks even when icc are used.
we propose to leverage dici to orchestrate the leakage of theimei via sms the goal is to build exclusively on code that is implemented from other apps to retrieve then to leak the imei.
we consider this use case to be reasonable since on a given device it is highly likely to identify other apps that implement a code fragment for sending sms and another app that has code where the imei is retrieved.
by so we ensure that there is no explicit code in our developed app i.e.
stealthapp where neither imei collection can be matched e.g.
via tracking calls to api nor leaking via sms can be identified.
therefore our implementation of such a collusion with dici challenges the detection of security leaks in stealthapp .
listing provides an excerpt of the code used in stealthapp to invoke a method getdeviceid at line from another app org.communicorpbulgaria.bgradio at line .
note that in thiscode the actual api provided by the framework i.e.
android.
telephony.telephonymanager is hidden.
dici is implemented in this case through reflection after obtaining the context of the app that implements the code to reuse lines .
based on this context the class loader of the app can be obtained line and used to load relevant classes in the app line .
the method object is acquired with the class object containing it line .
since getdeviceid which is implemented by the target app is a static method it is invoked directly to finally get the imei number lines .
1private string getimei string imei null context invokee this .
createpackagecontext org .
communicorpbulgaria .
bgradio context .
context include code context .
context ignore security classloader loader invokee .
getclassloader class util loader .
loadclass org .
ccb .
radioapp .
components .
utils method getdeviceid util .
getdeclaredmethod getdeviceid context .
class imei string getdeviceid .
invoke null this return imei listing retrieval of imei through reflection for thirdparty code reuse similarly a method from another third party app is invoked to send the obtained imei via sms as shown2in listing .
this method is named sendsms line but it cannot be confused with framework apis for sending apis.
instead this method is contained in class commonutils line from app com.globalcanofworms.
android.simpleweatheralert line .
1private void sendmsg string num string msg context invokee this .
createpackagecontext com .
globalcanofworms .
android .
simpleweatheralert context .
context include code context .
context ignore security classloader loader invokee .
getclassloader class util loader .
loadclass com .
globalcanofworms .
android .
coreweatheralert .
commonutils method sendsms util .
getdeclaredmethod sendsms context .class string .class string .
class sendsms .
invoke null this num msg listing data transfer via sms through reflection for third party code reuse stealthapp performs a malicious behavior through app collusion without explicitly implementing any malicious code.
as long as all the apps targeted for reuse are available on the users device its imei can be leaked and yet both dynamic and static scanning techniques will systematically fail to spot this leak if apps are analyzed individually.
in any case even when the apps are available it is important to note that the use of reflection makes the use static analysis techniques challenging.
while some techniques e.g.
code instrumentation of reflective calls into direct calls with droidra have been proposed in the literature to overcome limitations raised by reflection these techniques generally target in app code e.g.
dynamically loaded classes from an extra dex file such method would not work for dici since the method that should be called is not present in the analyzed app.
2the aforementioned code snippets are simplified with absence of exception handling.esec fse november virtual event usa jun gao li li pingfan kong tegawend f. bissyand and jacques klein blimitations of the stealthapp use case we have developed a naive app collusion system with stealthapp as a proof ofconcept of hiding malicious code with dici.
the goal with this use case is not to implement a sophisticated attack.
besides its simplicity this use case presents several limitations availability of target apps.
the implementation of the malicious behavior depends on the installation status of other apps to orchestrate the app collusion.
their probability of availability on the device could lower the possibility of the execution of the malicious code.
nevertheless we can expect attackers to leverage the diversity of apps that are shipped with new devices.
for example hackers could list all the functionalities offered by the apps that are already installed on all devices from a specific manufacture or consider only focusing on popular apps to increase the probability of being able to realise the scenario on millions of devices.
finally note that the official api packagemanager.queryintentactivities with intent category set to category launcher can be used to retrieve at runtime the relevant information on installed apps on the current device.
permissions.
another limitation is that permissions of other apps will not be granted to stealthapp when stealthapp is invoking their code.
therefore when a method is protected by a permission this permission must be granted as well to the app before invoking the third party code.
for our imei leakage example the read phone state andsend sms permissions are required instealthapp .
nevertheless because of the recurrence of permission over privilege i.e.
apps ask for more permissions than they need in the android ecosystem attacks such as the one perpetrated by stealthapp can go unnoticed.
process access.
finally it is noteworthy that in the case of icc when an app a is calling a component of an app b that component is launched in the process of b i.e.
the target code that is run in b can access the internal data of b. with dici when an app a invokes code from b this code is launched in the process of a meaning that this code cannot actually access internal data of b. nevertheless despite this limitation for accessing more resources accessing functionality implementation poses different threats as we will show in the second use case.
.
.
functionality plagiarism.
tiktok is a highly popular videosharing app.
it has more than million installs on google play alone.
in line with the necessity to control copyrights of video submitters as well as due to commercial needs to strongly bind users all the shared videos can only be viewed and downloaded through the single tiktok app.
among other constraints tiktok does not allow allow batch downloading i.e.
the possibility to download all of the videos of a single user at once .
in order to block download requests originating from third party interfaces each request need to be appended with a one time signature for the tiktok server to verify the legitimacy of the request.
this signature is calculated by an algorithm implemented within the user app with certain information such as user id time stamps etc.
these mechanisms are rather effective against the typical cloning i.e.
repackaging attack or the reverse engineering of the tiktok app in order to exploit the backend infrastructure and resources of tiktok notably the database of videos.we will show now that with dici it is actually possible to reuse the code of tiktok to achieve the objective of exploiting the tiktok infrastructure.
typically we were able to implement our own batch downloader that we call tiktokdownloader to download tiktok videos by accessing and plagiarizing the signing algorithm implementation in the tiktok app.
as shown in figure the developed app will require just to input a user id to specify the videos of which user must be downloaded.
a search user id b downloaded videos figure batch downloader snapshots tiktok implements video search and download via rest endpoints i.e.
an url where requests can be specified for actions or resources .
however as endpoints are accessed via requests that are transmitted in plain text with logical structures they can be obtained manipulated and used easily by third parties.
thus to reserve the exclusive use of these endpoints to tiktok itself a onetime signature is required to be appended to each endpoint when requesting the server.
after investigating the dex3code of tiktok we identified a method whose obfuscated name is a within class com.ss.android.ugc.aweme.app.a.c which computes the signature for the app to access the tiktop server resources.
listing presents the implementation code of method a which is the target of our plagiarism scenario.
1private string a string str int i string userinfo string str3 int servertime networkutils .
getservertime if servertime i else i servertime string str4 str ts i hashmap hashmap new hashmap d.a hashmap true string strarr new string int i2 for string str5 hashmap .
keyset string str6 string hashmap .
get str5 if str5 null str5 3jadx is used here for the decompiling it can be found at jadxborrowing your enemy s arrows esec fse november virtual event usa if str6 null str6 int i3 i2 strarr str5 strarr str6 i2 i3 userinfo userinfo .
getuserinfo i urldecoder .
decode str4 strarr int length userinfo .
length string substring userinfo .
substring length str3 str4 as substring cp userinfo .
substring length length mas com .ss.
android .
common .
applog .i.
bytearraytohexstr com .ss.
sys .
ces .a.e substring .
getbytes return str3 listing simplified signing method from tiktok tiktokdownloader implements the dici mechanism to invoke the method illustrated in listing in order to sign the endpoints and then request the server with the signed endpoints.
it is worth to mention that all of the relevant classes such as networkutils in line will be automatically loaded as well.
this constitutes a powerful capability of the dici mechanism since even native libraries generally preserved from reverse engineering due to their machine binary format can also be reached for example in the sample code getuserinfo line bytearraytohexstr line and e line are all sensitive code that are embedded in native code.
the usage scenario of our tiktokdownloader app is that it is installed on a device where the user already has an account on tiktok.
the dici mechanism in this case has led to the implementation of copyright infringement attacks since video uploaders did not provide any rights to tiktokdownloader to access their content .
another critical point is that dici allowed to easily plagiarized the tiktok code in a stealthy tiktokdownloader did not copy the code nor did it rewrite in some way instead it just invokes it at runtime a case that is not comprehensively studied in the literature of code plagiarism.
apps availability and responsible disclosure we provide on github the source code of both use case apps as artefacts for further research .
both apps have been tested on a nexus device running android version .
.
.
we have also responsibly informed tiktok owner company about the risk posed by dici with respect to the possibility to bypass their security infrastructure to access users copyrighted videos.
tool design aiming at automatically inferring the usage of dicis in android apps we design and implement a prototype tool called dicider which takes as input an android apk file and outputs a list of dici paths that trace how direct inter app code invocations are planned in the analyzed app.
an overview of the working process ofdicider is presented in figure .
overall dicider follows four steps to pinpoint dici instances.
we now briefly introduce these steps.
call graphcall contextsdici relevantapi calls api scan call graphconstruction context awareflow sensitivedata flow analysis dicidetection endanalysisdicipathsandroid apknot all levels of apis found or level api flags invalidfigure static analysis for uncovering dicis.
.
step call graph construction dicis are implemented following a sequence of api calls e.g.
to obtain the third party app context load the relevant class invoke the target code etc.
.
we thus propose to construct the call graph of the input android app to facilitate further analyses.
to that end dicider relies on the soot framework as well as the flowdroid precise taint analysis tool.
to realize this analysis the apk is first disassembled and the app dalvik bytecode is transformed into jimple the intermediate representation that is leveraged in soot.
then this jimple code is analyzed by soot to yield a call graph of the app.
we recall that android apps do not come with a single entrypoint e.g.
main in classical java applications to start app execution.
instead the app can be started from different entry points from any app components which complexifies the construction of a single call graph.
to address this problem flowdroid constructs a dummy main method for analysis.
this dummy main method takes into account all the possible entry points of the app i.e.
components and their lifecycle methods e.g.
onstart onstop as well as all the leveraged callback methods onclick .
the reason why lifecycle methods and callback methods are needed to be explicitly included is that these methods are not explicitly connected at the code level.
the prepared dummy main method then enables the soot to construct the call graph of the app and subsequently to traverse all the app code in their possible execution contexts.
note that soot implements several in house call graphs construction algorithms such as cha and spark.
while the cha algorithm is faster than spark it is rather more imprecise .
given that in our work precision of call graph is a key property to ensure that dicider yields good performance we choose to leverage the spark algorithm to build the call graph with the correct api calling sequences modeled .
.
step api scan once the call graph is constructed the second step that is unfolded is to identify the relevant apis that contribute to the realization of dicis.
then one must assess the parameters of these api calls to further confirm potential code reuse scenarios.
api presence detection dicider performs a quick scan over the call graph to check if dici relevant apis of the android framework are leveraged by the app.
the presence of such apis is a primary condition for the presence of dicis in the analyzed app.
if such apis do not exist there is no need to proceed further and the analysis of the app is safely halted.
which are the dici relevant apis?
in section .
our use case description highlighted a sample sequence call of specific android apis.
following up on this example we have carefully investigatedesec fse november virtual event usa jun gao li li pingfan kong tegawend f. bissyand and jacques klein apis that are used in the same principles and tag them as dicirelevant.table enumerates all dici relevant apis considered by dicider along with their implementation class signature return type and a textual description.
since dicis are performed through a sequence of calls of several dici relevant apis each api may be necessary at different position level within the sequence.
we indicate for each dici relevant api the level of that api which represents the position of its call within an instance of dici call sequence.
generally a successful dici needs to involve at least one api in each of the five levels apis.
level obtain the context of another app.
level obtain the corresponding class loader using the obtained context of the other app.
level load the class to be directly invoked of the other app through the obtained class loader.
level locate the constructor method orfield to be directly reused from the loaded class.
level finally access the previously located constructor method or field reflectively .
if the method or field is not declared as static an additional step is needed to instantiate an object of the class.
dicider uses the list of dici relevant apis to check whether the analyzed apk contains such apis.
in particular if the analyzed apk does not contain at least one dici relevant api of each of the five levels enumerated previously the api call sequence is ignored at this stage and dicider terminates with no dici paths detected.
... ...context include codecontext restrictedcontext device protected storage f1context ignore securityf2f4f0f8null figure example options that can be applied when creating contexts via package names.
api parameter checking there is another constraint that may keep dici from happening in practice.
this constraint is brought by the second parameter of the createpackagecontext api.
this second parameter known as flags allows developers to specify via bitwise operators how should the package context be created.
some of the options that developers can specify are highlighted in figure and briefly explained below.
f0 or .
the default option.
none of the other options are enabled.
f1 or .
if enabled it allows the context to access the code implemented in the loaded package .
otherwise only resource files are allowed to be accessed.
f2 or .
this option will ask the context to ignore any security restrictions.
when enabled along with context include code it will allow code to be loadedinto a process even when it is not safe to do so.
as recommended by google developers should use this option with extreme care4.
f4 or this option will allow the context to disable specific features of its accessed resources.
f8 or .
this option allows the context to access apis even at device protected storage.
in order to invoke the code of other apps when creating the context via createpackagecontext the f1 option has to be enabled.
therefore in this step we further take efforts to trace the value of the flags parameter through backward constant propagation of located createpackagecontext usages.
if the f1 option is not enabled the corresponding api call will not be considered so as to avoid false positive results.
.
step context aware flow sensitive data flow analysis while a call graph is relevant to spot call sequences of dici relevant apis this sequence may actually not be about implementing a dici.
indeed apis may be invoked under different contexts leading to a situation where there is no actual inter app interaction.
thus we need to ensure that the code block that is eventually invoked is indeed reused from another app.
let us consider the example provided in listing .
this listing is similar to the beginning of listing for the case of malicious code hiding there is a difference in that the loader is instantiated by calling this.getclassloader rather than invokee.getclassloader .
as a result although the apis of the first two levels are invoked following the ideal sequence i.e.
level method is called before the level method they cannot jointly form a dici as the loader is not obtained from the context invokee but the current context i.e.
this .
1context invokee this .
createpackagecontext org .
communicorpbulgaria .
bgradio context .
context include code context .
context ignore security 5classloader loader this .
getclassloader classloader loader invokee .
getclassloader listing an example code showing the necessity of taking context into consideration.
we address the challenging of keeping track of the data flow between api calls by performing a context aware data flow analysis to ensure that the apis are all called under the same context.
nevertheless instead of performing a generic context aware data flow analysis which tracks all the flow of all the variables and hence could be compute intensive dicider implements a dedicated contextaware data flow analysis for which only the contexts related to the dici relevant apis are tracked.
.
step dici usage identification finally in the last step dicider leverages the results of the previous steps to pinpoint dici paths.
we recall that the output of step is a dici path which is a sequence of api calls with a least one api for each defined level and called under the same context.
however at this stage it is still not established which app class and method are invoked via dici i.e.
what is the target code for your enemy s arrows esec fse november virtual event usa table dici relevant apis level class signature return description android.content.context createpackagecontext java.lang.string int android.content.context used to create a new context object of a specified application.
the arguments are application name and creation flags.
with flag context include code and context ignore security the code of another application can be loaded.
android.content.context getclassloader java.lang.classloader get the class loader.
java.lang.classloader loadclass java.lang.string java.lang.class get a specified class object by passing the name of the class.
java.lang.classgetconstructor java.lang.class java.lang.reflect.constructorget the constructor of a class with the argument specifying the signature.
getdeclaredconstructor java.lang.class java.lang.classgetdeclaredmethod java.lang.string java.lang.class java.lang.reflect.methodget the method of a class with the arguments specifying the signature.
getmethod java.lang.string java.lang.class java.lang.classgetdeclaredfield java.lang.string java.lang.reflect.field get the field of a class by passing the name.getfield java.lang.string java.lang.class newinstance java.lang.object instantiate a class with its zero argument constructor.
java.lang.reflect.constructor newinstance java.lang.object java.lang.object instantiate a class with the specified constructor.
java.lang.reflect.method invoke java.lang.object java.lang.object java.lang.object invoke the method.
the first argument specifies the instance of the class and passing null indicates a class method.
java.lang.reflect.fieldset java.lang.object java.lang.object voidset the field with a certain value.
the first argument indicates the object to which the field belongs and nullmeans the field is static.
for set java.lang.object the asterisk can be replaced with boolean byte char double float int long and short.
for example setint int .set java.lang.object get java.lang.object java.lang.object get the value of a field.
the asterisk stands for the same primary types mentioned in set java.lang.object .get java.lang.object 5java.lang.reflect.method setaccessible boolean voidset the accessibility of the method field or constructor.
java.lang.reflect.field java.lang.reflect.constructor reuse.
we introduce a lightweight constant string propagation moduleindicider which goes one step deeper to infer what are the methods fields that are accessed via dici.
to that end given a fifth level api such as java.lang.reflect.method.invoke we perform a backward string analysis to infer which is the reflectivelyaccessed artifact.
regarding the example shown in listing for the invoke method illustrated in line our backward string analysis aims at inferring that the method which is called via reflection is getdeviceid of the class org.ccb.radioapp.components.utils in app org.communicorpbulgaria.bgradio .
evaluation we empirically assess dicider and investigate the use of dicis in the real world.
research questions the study is driven by the following research questions rqs .
rq1 candicider spot dicis in real world android apps?
to answer this rq we investigate on the one hand the recurrence of dicis in apps collected from various markets.
on the other hand we study the prevalence of dicis among goodware and malware apps respectively.
rq2 how dici usages evolve over time?
to answer this rq we consider both the evolution of number of apps leveraging dicis within markets as well as the evolution of dicis usages within app lineages i.e.
based on their updates .
rq3 for what purposes do developers implement dicis?
we consider a number of real world examples to dissect the purposes of dici usages.
dataset the evaluation is conducted on apps collected from androzoo a continuously growing repository of android apps.at the time of writing the dataset size was over million apks crawled from the google play official store as well as from alternative markets and repositories.
some metadata on the apps are also collected via the toolkits provided by li et al.
.
implementation dicider is built based on the soot framework and leverages flowdroid taint analysis implementation.
dicider provides reasonable performance on a commodity computer .
ghz quad core intel core i7 cpu with 16gb memory the average time consumption for analysing a single apk is about .
seconds.
.
rq1 dicis in real world apps the goal is to run dicider in order to attempt the detection of dicis in real world android apps.
to that end we sample android apps following their market provenance.
comparison among markets.
currently the top sources ranked based on the number of apps crawled in androzoo are google play playdrone anzhi and appchina.
however since playdrone is a specific subset of apps originally crawled from google play we do not consider playdrone as a distinct provenance.
thus we consider mainly the remaining sources and randomly select apps from each provenance5leading to a total of android apps.
table provides statistics of the execution of dicider on the 75k real world apps.
overall dicider is able to detect a significant number of dicis.
at the market level we notice that apps from the official market google play are much more likely to contain dicis than apps from the alternative markets.
a priori this is 5since dicider may fail to analyze some apps due to unexpected corner cases such as the given apk does not contain dex file in practice we have randomly listed all apps and sequentially tested them until the quota of is reached for each provenance.esec fse november virtual event usa jun gao li li pingfan kong tegawend f. bissyand and jacques klein table dici comparison among markets google anzhi appchina total of successfully analyzed apps of apps with dicis percentage of apps with dicis .
.
.
.
of detected dicis median of dicis per app61 reassuring since alternate markets are known to include more malicious samples than the official markets .
nevertheless when looking at the median number of dicis per app apps from marketanzhi exhibit a remarkably higher number of dicis than for other markets when considering apps that implement this reuse mechanism.
figure gives a more concrete understanding of the difference between anzhi and the other markets from the perspective of dici per app.
further statistical investigations of google play cases reveal that about of dicis are from a class named com.google.android.gms.dynamite.dynamitemodule .
google mobile services and dicis.
we focus on the dynamitemodule class that is recurrently involved with dicis of googleplay apps.
based on its package name we suspect that it is may be part of the official google mobile service gms apis.
the official documentation does not however mention such a package.
we postulate that such a package may have been intentionally omitted from the documentation to avoid uses by third party developers.
nevertheless we undertake to confirm the presence of this class within gms by explicitly requesting gradle dependency management to find the gms libraries and included them in a toy demo app.
afterwards we manually analyzed the content of the class to further check what it does through dici.
according to the analysis report of dicider dynamitemodule code instantiates a class named com.google.android.gms.dynamite.idynamiteloader from the app named com.google.android.gms .
to further check how this instance is used we proceed to reverse engineer an app that contains gms apis the code of such apis are not open sourced.
according to the decompiled code this class implements the interface android.os.ibinder which is designed for in and cross process calls7 and is used to query a local interface here.
although this class is also under the package of gms dynamite according to its name.
it cannot be found in the gms libraries.
since there is quite little information about these libraries.
we can only infer that the app com.google.android.gms is the gms framework which is supposed to be embedded into the android os and direct inter app code invocation is the way to access the framework.
we also consider class org.xwalk.core.
xwalkcorewrapper which contributes to most dicis in anzhi dataset.
class xwalkcorewrapperis from a project called crosswalk which was once founded by intel s open source technology center8.
it is a web app runtime to provide manipulability to browser.
the class uses dicis to access functionalities of its own app.
while we studied the recurrent cases in this rqs we will consider the remaining in google play datasets for answering rq3.
comparison between benign apps and malware.
androzoo not only crawls android apps but also the antivirus reports 7according to official document at os ibinder 8see project page at 010203040506070google anzhi appchina figure distribution of dici per app from virustotal for each app.
for a given app androzoo indicates the number of anti virus products which flag the app as a malware among a total of about anti virus products .
we rely on this information to build our dataset of goodware and malware.
for goodware we consider apps selected from androzoo with no flag from any anti virus product.
for malware we consider apps selected from androzoo with at least flags i.e.
at least half of the anti virus have a consensus on app maliciousness .
table presents the comparison between goodware and malware.
surprisingly overall malware actually use much less dicis compared to benign apps.
however by further checking the source package of dicis we find that for benign apps the dominated class is again com.google.android.gms.dynamite.dynamitemodule while for malware this class only contributes a quarter of dici usages.
this has two implications the scope of using dici for benign scenarios is still limited although many instances of benign apps because of their reliance on gms are actually hosting code that use the dici mechanism malicious apps on the other hand may have indeed been leveraging dicis.
table dici comparison between goodware and malware benign malware of successfully analyzed apps of apps with dicis percentage of apps with dicis .
.
of detected dicis median of dicis per app91 answer to rq1 dicider is able to detect dicis in real word apps.
this reuse mechanism is actually seen in many apps although mostly due to the use of the gms libraries where class com.google.android.gms.
dynamite.dynamitemodule heavily relies on dici.
there are however cases of malware leveraging dici outside the scope of gms libraries.
.
rq2 evolution of dici usages as shown in rq1 com.google.android.gms.dynamite.dynamitemodule is the major source of dicis.
we noticed that this class was not present in the android ecosystem since the beginning of android.
thus we propose to study the evolution in time of the number of dicis within android apps.
to perform this experiment we consider app lineages i.e.
different versions of apps over time .
to that end we consider a large lineage dataset proposed by gao et al.
based on the androzoo repository.
most of the lineages are spread over several years but for each year we consider only the latest apk version in that year for a given lineage.
the statistics of apks per year from the lineage dataset in the literature is listed in table .borrowing your enemy s arrows esec fse november virtual event usa table apks considered from the lineage dataset we run dicider on this dataset and compute the percentage of apks containing dicis for each year.
the result is presented in figure .
a clear increasing trend can be observed after year .
by further investigating the dici contributors we notice that the main reason is still the gms libraries.
we find that before there are no contributors from gms libraries.
however starting from the main contributors are all from gms libraries although the source packages shift from internal mainly in to dynamite after .
unfortunately these library not being part of the android open source project we cannot find any information about the apis publication and update time.
we infer however that starting from gms libraries start to be more and more used android applications.
year0.
.
.
.
.
figure percentage of apks contain dici by leveraging lineage we also have the chance to investigate update patterns through checking the status of dici usages in different versions of a same app.
for this experiment we consider all lineages with at least one dici present in at least one apk of the lineage and lineage with at least apks.
table presents the distribution of different update patterns.
in a large majority of the cases dicis are not implemented in the initial version of the app.
instead it is added during an update.
table apks of each year of lineages in which a dici has been introduced by an update .
of lineages in which a dici has been removed after an update .
of lineages in which a dici has been in all versions .
of lineages with dici added then removed and then added .
answer to rq2 over time the use of the dici mechanism has progressively become boomed among android apps mainly due to the availability of the gms library.
nevertheless it is noteworthy that dicis can be implemented during app updates which may cause concerns for update attacks since it is well known that users are less wary of apps during updates .
.
rq3 purposes of using dicis tables and enumerate respectively the top dici contributor packages where dicis are invoked and the top apps that are targeted by dici reuse cases.
these statistics are based on the lineage dataset described above.
we note that besides the fact thata gms package is a top contributor for dici usage the gms app is also the top app whose code is largely targeted for direct inter app invocation.
from the package and app names we can notice the connection between some of them such as package com.jb.gosms.util tries to access code in app com.jb.gosms.emoji .
actually by manually checking all the top contributors we confirm that they all try to access apps with similar names.
for these cases we can infer that they try to access the code from the app owned by same developers to perform app collusion scenarios.
table top dici contributor packages rank package number com.google.android.gms com.lbe.doubleagent.client com.jb.gosms.util net.pierrox.lightning launcher.b com.dokdoapps.utility.googleservicemanager com.handcent.common.v kl.ime.oh.h com.google.android.apps org.xwalk.core.reflectionhelper cn.longmaster.common.pluginfx table top dici invoked apps rank package number com.google.android.gms com.jb.gosms.emoji klye.hanwriting org.xwalk.core net.pierrox.lightning locker p com.pansi.msg.plugin.custom notify com.pansi.msg.plugin.regins com.shocktech.guaguahappy com.pansi.msg.plugin.emoji we take one more step to reveal the purpose of apps using dicis by deeply exploring some apps.
plugin implementation through dici.
the app with package name kl.ime.oh10is a multi language keyboard app developed by honso with more than million installs on google play .
it is found using methods from another app with package name klye.hanwriting which is a chinese keyboard plugin app also can be found on google play with the same developer11.
by searching apps from the same developer more plugins for other languages can be found as well.
we further notice that when the code loading failed the app will return a string to ask to download chinese plugin .
thus we can infer that this app implemented a plugin functionality by using the dici code reuse mechanism.
we found several apps performing similar plugin behaviour.
app named com.jb.gosms is found with loading methods from an app with package name com.jb.gosms.emoji and a broadcastreceiver is registered to check if the app is newly installed or uninstalled.
app com.pansi.msg loads code from different apps which are com.pansi.msg.plugin.custom notify com.pansi.msg.
plugin.emoji andcom.pansi.msg.plugin.regins .
and app net.pierrox.
lightning launcher loaded code from net.pierrox.lightning locker p .
we further notice that for the value of flags when creating the app context some of them used value instead of which omits the flag 10it can be downloaded from androzoo by using the sha256 04e37d1ce54c7e326a7 714f56b35f922df9eaf5aad190fc5fd61716f84176d3e and the app can be found on google play with link 11the page link is november virtual event usa jun gao li li pingfan kong tegawend f. bissyand and jacques klein ofcontext ignore security .
this could be because all these apps are from the same developer i.e.
containing same signatures .
nevertheless it is an interesting feature to be considered by static analyzers when assessing the security risks.
keeping up with best practices through gms.
we find another use of the dici code reuse mechanism which is to load up to date functionalities matching the best practices of android programming available via com.google.android.gms .gms stands for google mobile services andcom.google.android.gms is the google play services packages.
the loader apps try to invoke the method insertprovider from class com.google.android.gms.common.security.providerinstallerimpl .
according to the official documentation from google12 the purpose is to update the security provider to protect against ssl exploits.
however the relevant method mentioned in the document is installifneeded which is different from the one we found.
by further checking the source code of method installifneeded we find that the fundamental method is also insertprovider .
some developers may also notice this.
thus instead of invoking the documented method and include all relevant libraries they chose to directly invoke the fundamental method.
all these loader apps are with package name of com.monese.monese.live nya.miku.wishmaster and com.levelup.touiteur respectively13.
countermeasures we now discuss possible countermeasures that could be leveraged by app developers to protect their app code from being reused in a stealthy way through dici.
1public class antitheftapp extends application private static antitheftapp theinstance override public void oncreate super .
oncreate theinstance this public static antitheftapp getinstance return theinstance public void verify listing implementation of application instance based verification we found a straightforward countermeasure that until now we could not find a way to break.
the idea is to check with the code to protect what is the instance of the application that is executing it.
indeed to the best of our knowledge there is no means to get or generate an instance of another app.
listing presents the code that a developer could use to protect her app.
first to record the app s instance a slight modification to the application class is required here antitheftapp .
specifically we create a private instance field line and assign the current instance to this field line .
then we create an empty method called verify lines to .
the purpose of this method is to check the availability of the stored application instance i.e.
theinstance at line and an empty method is already enough.
indeed when getinstance .verify is called in the original app nothing happens.
however when this method is called in the plagiarist app the app will crash because theinstance has not been initialized 13the sha256s are e953776572e4e84cb64d0abf442211fc9a5eddf0bdef7e5dfc47 c94756c714ab 8b16dbd2d4951bdab16f2aa9aabcbc8bee91264dab78f2bcafd3ee31 7b84e27c 06e280b615d5cf68e6bd3f89e27ff11fdbcfce7d038aaccfe87c486f4715 9eb6and yet it cannot be instantiated or overwritten by attacking code in other apps.
finally to protect from being reused via dici app developer can simply write antitheftapp.getinstance .verify at the beginning of each method she wants to protect.
other possibilities so far we have only attempted to protect dicis at the app code level.
yet we believe many other features could also be leveraged to protect dicis.
indeed on the one hand native libraries or javascript code for webkit based apps could be leveraged as they increase significantly the complexity of the code making it non trivial to be bypassed by attackers.
on the other hand some system features could be leveraged as well.
for example each android app will be allocated with a private directory that cannot be accessed by other apps and thereby could be leveraged to check the identity of the active app.
last but not least from the android framework point of view there are various countermeasures could be applied.
for example android os could provide a mechanism similar to permission and component management for the interapp code invocation functionality.
it could limit the code access within apps from the same developers or allow a declaration in the androidmanifest file to specify which part of the code i.e.
classes can be accessed publicly by other apps through dicis.
it also can be limited based on the privileges of linux users.
limitations the fact that our prototype tool has revealed various dici usages in real world android apps shows that our tool is useful to pinpoint them.
nonetheless the implementation of our tool has come with various limitations.
first of all since the dummy main method construction approach is borrowed from flowdroid all the relevant limitations reported by flowdroid also apply to our approach.
for example unsoundness can arise if certain callbacks in android lifecycles are overlooked when building the dummy main method.
second dicider directly adopts the constant propagation approach provided by soot which unfortunately only supports intra procedural analysis.
as a result although it is not our main focus of this work certain reflectively accessed methods or fields could be missed by our approach.
we keep this for future work.
at the moment dicider does not take into account native libraries and is oblivious to multiple threading implementations which may result in unsound results as well.
not only the implementation of our prototype tool comes with limitations the validity of our experimental results may also be threatened by the experimental setup we designed in this work.
the major threat to the validity lies in the choice of selected android apps.
although we rely on a random selection from androzoo to prepare the real world apps for analysis since the distributions of apps in different markets available in androzoo vary significantly we cannot guarantee the representativeness of these apps.
furthermore we leverage the app assembly time to build app lineages in this work.
the app assembly time as experimentally revealed by li et al.
may not be accurate to represent the app release time.
hence the app lineages we leverage to study the evolution of dici usages may not be reliable as well.
in this work we try to mitigate this by following the same approach of our fellow researchers to build the app lineages which have been demonstrated to be useful to support app evolution studies.borrowing your enemy s arrows esec fse november virtual event usa related work to the best of our knowledge this paper presents the first work disclosing the possibility of direct inter app code invocation among android apps and subsequently detecting dici usages in android apps.
as a result there is no related work specifically focusing on this problem.
however the research community has proposed various contributions in the domain of static analysis of android apps.
moreover some works focused on the problems of inter component communication icc and inter app communication iac which are closely related to dici.
we now discuss the representative ones.
static analysis of android apps many state of the art works have adopted static analysis as one of their fundamental parts to perform their research investigations.
as presented in a recent survey done by li et al.
there are over papers published mainly in the software engineering and security community proposed to analyze android apps statically.
as revealed in their survey static analysis has been largely conducted to uncover security and privacy issues such as privacy leaks detection advertisement violations and malware detection .
also the survey discloses that the well known soot framework is the most adopted basic support tool in the community to implement static analysis approaches.
we remind that the soot framework is also leveraged by dicider to detect the usage of dicis.
static analysis has also been used by researchers to scan for app defects including energy issues fix runtime crashes improve the realization of dynamic testing appraoches .
focus on inter component communication android apps differ from traditional java apps in that there is no single entry point e.g.
the main method in the apps.
apps are composed of multiple basic components.
to pass on data among these components android has a special inter component communication icc mechanism.
however malware may also use this mechanism to achieve their malicious behaviors e.g.
steal users private data.
to this end our community has proposed various approaches to mitigate the attacks related to android iccs.
as an example epicc is proposed to reduce the icc problem to an instance of the interprocedural distributive environment ide problem and finds icc vulnerabilities with far fewer false positives.
iccta is a static taint analyzer to detect privacy leaks among components in android applications.
it goes beyond existing icc leaks detection tools like .
focus on inter application communication android s interapplication communication iac mechanism allows for reuse of functionality across apps via intent s. contrary to the technique described in this paper iac is intended for functionality sharing.
however this mechanism also raises concerns for vulnerabilities crossing android apps.
thereby the research community has also proposed various approaches to mitigate possible vulnerabilities brought by iac.
for example li et al.
have proposed a tool called apkcombiner aiming to combine multiple apps together to a single app so as to reduce an iac problem to an icc problem.
as a result this tool allows all the aforementioned icc aware approaches to resolving iac problems without modifications.
permissionflow can reliably and accurately detect vulnerable information flows among android applications.
intentdroid is acloud based testing algorithm for android apps for automated discovery of android iac vulnerabilities.
comdroid is another tool to detect icc related malicious behaviors in android apps e.g.
sniffing message contents and injecting forged messages.
unfortunately since dici leverages a totally different channel to implement inter app communication all the aforementioned existing works cannot be directly applied to detect dici usages in android apps.
our prototype tool dicider fills this gap by providing a means to statically pinpoint dici usages in android apps which could be considered as a complement to the state ofthe art.
conclusion in this paper we disclose to the software engineering community a novel mechanism allowing direct inter app code invocation dici among installed android apps on mobile devices.
through concrete motivating examples we demonstrate that dici can be leveraged to successfully perform malicious attacks and plagiarize the core function of the competitor s apps.
we then introduce to the community a static analyzer called dicider to automatically locate the usage of dicis in android apps.
experiments on a large set of android apps reveal that dicider is indeed capable of detecting dicis in android apps and the usage of dicis tends to increase over time which may cause concerns for update attacks since users might be less wary of apps during updates.
acknowledgment this work is supported by the fonds national de la recherche fnr luxembourg under both projects pride15 spsquared and characterize c17 is as well as by the european union under the horizon sparta project grant agreement no .
this work is also supported by the australian research council arc under projects de200100016 and dp200100020.
we thank dr. daoyuan li for providing technical support in developing the tiktokdownloader use case and dr. alexandre bartel for his guidance in using soot andflowdroid .