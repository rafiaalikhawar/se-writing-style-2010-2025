automated refactoring of legacy java software to default methods raffi khatchadourian city university of new york raffi.khatchadourian hunter.cuny.eduhidehiko masuhara tokyo institute of technology masuhara acm.org abstract java default methods which allow interfaces to contain instance method implementations are useful for the skeletal implementation software design pattern.
however it is not easy to transform existing software to exploit default methods as it requires analyzing complex type hierarchies resolving multiple implementation inheritance issues reconciling differences between class and interface methods and analyzing tie breakers dispatch precedence with overriding class methods to preserve type correctness and confirm semantics preservation.
in this paper we present an efficient fully automated type constraint based refactoring approach that assists developers in taking advantage of enhanced interfaces for their legacy java software.
the approach features an extensive rule set that covers various corner cases where default methods cannot be used.
to demonstrate applicability we implemented our approach as an eclipse plug in and applied it to real world java projects as well as submitted pull requests to popular github repositories.
the indication is that it is useful in migrating skeletal implementation methods to interfaces as default methods sheds light onto the pattern s usage and provides insight to language designers on how this new construct applies to existing software.
keywords refactoring java interfaces default methods i. i ntroduction with the introduction of enhanced interfaces in java developers can now write default instance methods which include an implementation that implementers will inherit if they do not provide their own .
although the original motivation was to enable developers to add new functionality to existing interfaces without breaking clients default methods can be used as a replacement of the skeletal implementation pattern .
this pattern centers around creating an abstract skeletal implementation class which implementers extend that provides a partial interface implementation making the interface easier to implement.
while there are many advantages in migrating legacy code using the skeletal implementation pattern to instead use default methods e.g.
foregoing the need for subclassing having classes inherit behavior but not state from multiple interfaces facilitating local reasoning so may require significant manual effort especially in large projects.
particularly there are subtle language and semantic restrictions e.g.
interfaces cannot declare instance fields.
it requires preserving type correctness by analyzing complex type hierarchies resolving issues arising from multiple implementation inheritance reconciling differences between class and interface methods and ensuring tie breakers with overriding classmethods i.e.
rules governing dispatch precedence between class and default methods with the same signature do not alter semantics all of which will be elaborated on later.
we propose an efficient fully automated semanticspreserving refactoring approach that assists developers in taking advantage of enhanced interfaces.
the approach based on type constraints works on large scale projects with minimal intervention and features an extensive rule set covering various corner cases where default methods cannot be used.
it identifies instances of the pattern and safely migrates class method implementations to interfaces as default methods.
the related p ull upmethod refactoring safely moves methods from a subclass into a super class.
its goal is to solely reduce redundant code whereas ours includes opening classes to inheritance allowing classes to inherit multiple interface definitions etc.
moreover our approach deals with multiple inheritance a more complicated type hierarchy involving interfaces semantic differences due to class tiebreaking and differences between class method headers and corresponding interface method declarations.
the refactoring approach is implemented as an open source eclipse plug in.
the experimental evaluation used a set of java projects of varying size and domain with a total of .
million lines of code.
additionally we submitted pull requests patches of the refactoring results to popular github repositories.
our study indicates that i the analysis cost is practical with average running time of .
seconds per input method and .
seconds per thousand lines of code ii the skeletal implementation pattern is commonly used in legacy java software and iii the proposed approach is useful in refactoring method implementations into default methods despite language restrictions.
it also provides insight to language designers on how this new language constructs applies to existing software.
this work makes the following specific contributions approach design.
we present a novel automated refactoring approach for migration to java enhanced interface default methods.
the approach infers which methods can be safely migrated to default methods via an exhaustive formulation of refactoring preconditions.
we present new type constraints involving default methods and other modern java constructs as well as a scheme for semantics preservation in the context of tie breaking rules with classes.
furthermore we identify all code changes required to perform the migration including ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
removal and replacement of skeletal implementation classes.
implementation and experimental evaluation.
the approach is implemented as an open source eclipse plug in to ensure real world applicability.
a study on java programs indicates that the proposed techniques are effective and practical and a pull request study demonstrates that the results are well grounded.
these results advance the state of the art in automated tool support for the evolution of legacy java code to modern java technologies.
ii.
m otiv ating example in this section we present an example that will be used throughout the paper to highlight the motivation of using default methods in legacy java code the refactoring challenges involved and how our approach applies in particular situations.
fig.
portrays a hypothetical collection type hierarchy snippet.
fig.
contains the corresponding uml class diagram.
the hierarchy has been simplified for presentation with only portions relevant to our refactoring shown and illustrates specific issues that can arise with the refactoring.
the original system white space added for alignment is pictured in fig.
a while fig.
b depicts the same system with several methods migrated to interfaces as default methods.
removed code is struck through added code is underlined and replaced code is both underlined and emphasized.
both systems are type correct and semantically equivalent.
several interfaces including collection andlist with the latter extending the former meaning that any concrete class extending list must provide or inherit implementations of methods declared in both interfaces are shown in fig.
a .
note that unlike classes java interfaces can extend multiple interfaces.
methods exist for determining a collection s size adding an element whether it isempty its capacity and whether it is atcapacity .
note that the abstract keyword is optional for interface methods.
several methods also exist for list s including setting a list s size removing its last element adding an element line whose declaration overrides that of the super interface collection commonly done for documentation replacing an element at a specified position printing it to a specified stream and copying it.
several methods are denoted as so called optional operations as e.g.
not all list types may support modification.
in such cases implementers may throw an exception when these methods are invoked.
abslist an abstract class providing a skeletal implementation of a sequential variable length list is declared on line .
its purpose is to assist concrete classes in implementing the interface by declaring appropriate instance fields line and basic method implementations for the more primitive operations.
since it is abstract it is not required to implement all interface methods.
for the optional removelist the provided implementation line simply throws an unsupportedoperationexception .
this way concrete implementers extending abslist that support element removal can override it with a working implementation while others need not override it.
the provided implementationofprint sends the standard string representation of the list to the stream.
abslist s are also copiable line the provided implementation of which returns null instead of throwing an exception in the case that copying is unsupported.
aqueue interface snippet line contains two methods one default for offer ing and adding elements respectively with the former returning true if the operation was successful andfalse otherwise e.g.
if the queue is full and the latter written in terms of the former throwing an exception.
absqueue line provides a skeletal implementation ofqueue1by extending abslist similar to an adapter pattern .
unlike abslist it supplies functioning implementations for removelast useful for a pop operation not shown and add while also customizing the print method.
another extension of abslist absunmodlist which does not support the add operation is declared on line .
absstack line specializes abscontainer and both it and absset line implement collection providing isempty implementations.
types implementing the comparator interface line can order objects defaultcomparator line of which ccomparator line extends supplies a basic ordering using hashes.
lastly a main method line declares several concrete subclasses of various skeletal implementations of classes via anonymous inner classes line .
fig.
a illustrates the skeletal implementation pattern several drawbacks for which include inheritance.
due to single class inheritance restrictions there is no clean way for absqueue to simultaneously benefit from abslist and subclass another class.
moreover absqueue could not easily take advantage of skeletal implementations split over multiple abstract classes .
modularity.
there is no syntactic path between list and abslist i.e.
no syntax exists in list that refers to abslist .
in general a whole program analysis may be required to find suitable skeletal implementers for interfaces as they may be split across different files and packages .
bloated libraries.
abslist implements many of list s methods.
this extra class can further complicate large libraries and make maintenance difficult.
additionally method declarations are needed in both interfaces and classes to represent a single method and its default implementation.
java default methods.
default methods enable skeletal implementations in interfaces thereby foregoing separate classes.
moreover interface implementers need not search for separate skeletal implementations classes.
lastly implementers can extend other classes as well as inherit behaviors but not state from multiple interfaces which can reduce the need for code duplication and forwarding methods .
fig.
b shows a refactored version of the running example in which several skeletal implementations in classes have been migrated to interfaces as default methods.
in the ab1offer uses a double to demonstrate issues related to strictfp .
2implementers already extending a class can use the pattern via delegation to an internal class at the expense of auxiliary forwarding code.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1interface collection e int size void add e elem add to this collection optional .
boolean isempty int capacity abstract boolean atcapacity 8interface list e extends collection e void setsize int i throws exception void removelast optional operation.
void add e elem append to this list optional .
void set int i namedarg value elementtoset e e void print printstream stream list e copy interface copiable e e copy abstract class abslist e implements list e copiable list e object elems int size instance fields.
override public int size return this .size override public void setsize int i this .size i override public boolean isempty return this .size override public int capacity return this .elems.length override public boolean atcapacity return this .size this .capacity override public void removelast throw new unsupportedoperationexception override public void set int i namedarg value el e e this .elems e override public void print printstream out out.println this override public abslist e copy try return abslist e this .clone catch exception e return null functionalinterface strictfp interface queue e boolean offer e elem default void add e elem if !offer elem throw new runtimeexception full abstract class absqueue e extends abslist e implements queue e override public void removelast if !isempty this .setsize this .size override public void add e elem resize if necessary.
this .set this .size elem this .setsize this .size override public void print printstream out super .print out out.println printing queue ... override managedoperation public boolean offer e elem if size .
capacity add elem return true else return false abstract class absunmodlist e extends abslist e override public void add e elem throw new unsupportedoperationexception abstract class abscontainer ... abstract class absstack e extends abscontainer implements collection e override public boolean isempty return this .size abstract class absset e implements collection e override public boolean isempty int size this .size return size interface comparator t int compare t o1 t o2 abstract class defaultcomparator t implements comparator t override public int compare t o1 t o2 return objects.hashcode o1 objects.hashcode o2 class ccomparator t extends defaultcomparator t ... class main public static void main string args absqueue integer queue1 new absqueue integer queue1.removelast abslist integer queue2 queue1.copy queue string queue3 s true assert new absunmodlist string .isempty absstack stack ... collection col stack abscontainer container stack a using abstract skeletal implementation classes to ease interface implementation.1interface collection e int size void add e elem add to this collection optional .
default boolean isempty return this .size int capacity abstract default boolean atcapacity return this .size this .capacity 8interface list e extends collection e void setsize int i throws exception default void removelast optional operation.
throw new unsupportedoperationexception default void add e elem append to this list optional .
throw new unsupportedoperationexception void set int i namedarg value elementtoset e e default void print printstream out out.println this list e copy interface copiable e e copy abstract class abslist e implements list e copiable list e object elems int size instance fields.
override public int size return this .size override public void setsize int i this .size i override public boolean isempty return this.size override public int capacity return this .elems.length override public boolean atcapacity return this.size this .capacity override public void removelast throw new unsupportedoperationexception override public void set int i namedarg value el e e this .elems e override public void print printstream out out.println this override public abslist e copy try return abslist e this .clone catch exception e return null functionalinterface strictfp interface queue e boolean offer e elem default void add e elem if !offer elem throw new runtimeexception full abstract class absqueue e extends abslist e implements queue e override public void removelast if !isempty this .setsize this .size override public void add e elem resize if necessary.
this .set this .size elem this .setsize this .size override public void print printstream out super .print out out.println printing queue ... override managedoperation public boolean offer e elem if size .
capacity add elem return true else return false abstract class absunmodlist e extends abslist e override public void add e elem throw new unsupportedoperationexception abstract class abscontainer ... abstract class absstack e extends abscontainer implements collection e override public boolean isempty return this.size abstract class absset e implements collection e override public boolean isempty int size this .size return size interface comparator t default int compare t o1 t o2 return objects.hashcode o1 objects.hashcode o2 abstract class defaultcomparator t implements comparator t override public int compare t o1 to2 return objects.hashcode o1 objects.hashcode o2 class ccomparator t implements defaultcomparator t ... class main public static void main string args absqueue integer queue1 new absqueue integer queue1.removelast abslist integer queue2 queue1.copy queue string queue3 s true assert new absunmodlist string .isempty absstack stack ... collection col stack abscontainer container stack b improvements after our refactoring is applied.
fig.
.
a running example of a collection type hierarchy inspired by .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
collection type hierarchy uml class diagram.
stract classes the migrated methods were completely removed including the method header and override annotations.
for each migrated method the default keyword was inserted before the method return type and the delimiter was replaced with the body from the abstract class.
in the case of collection.atcapacity theabstract keyword on the method was removed line as the method is now concrete.
forlist.print the parameter name was altered to match that of the migrated method implementation.
now developers considering implementing the interfaces can clearly recognize list.removelast as optional and what should happen when it is not implemented.
classes can inherit the default method collection.isempty without the need for finding and inheriting from a separate class or duplicating existing or writing new forwarding code.
absunmodlist and defaultcomparator were completely removed in fig.
b .
ccomprator now implements comparator rather than extending defaultcomparator line and inherits the default implementation of compare from the interface freeing it to extend other classes.
similar transformations are also required for classes extending absunmodlist but are slightly different depending on context.
for example the anonymous inner class aic declared on line now uses the interface rather than the class in its constructor call making developer intent more explicit.
iii.
p roblem analysis to highlight refactoring challenges we examine fig.
a more carefully revealing the following inabslist methods isempty atcapacity removelast print i n absunmodlist method add i n absstack method isempty and in defaultcomparator method compare can be migrated without affecting type correctness and program semantics as classes now inherit them as default methods.
the transformation also occurs unambiguously each method has a well defined unique destination interface.
several methods are migrated to indirect interfaces i.e.
those not explicitly implemented by their declaring class but rather a super class up the type hierarchy.
the target method collection.isempty has multiple source methods abslist.isempty absstack.isempty absset.isempty .
only the first two were migrated due to common implementations.
3the override annotation is not carried over to the default method since the method body is no longer in an overriding relationship.
4alternatively each parameter reference could have been modified to match the interface parameter however changing only one location is less invasive.
5absset.isempty contains an unjustifiably different implementation to demonstrate issues that arise in complicated type hierarchies.
methods size setsize capacity and set in abslist cannot be migrated because they access instance fields of the receiver which cannot be migrated.
also offer inabsqueue cannot be migrated because size andcapacity are not declared in queue .
nevertheless exploring composite refactorings that may compensate in certain cases is an area for future work.
methods add inabsunmodlist and copy in abslist have multiple interface abstract target methods for which they provide implementations.
specifically since absunmodlist extends abslist abslist implements list and list extends collection absunmodlist provides an add implementation for methods in both interfaces.
the migration must be to list otherwise migrating to collection would result in a compilation error at line because the new default implementation would be squelched by the corresponding abstract method in list further down the hierarchy.
in the case of copy since abslist implements multiple interfaces the ambiguity occurs across the type hierarchy as both the list and copiable interfaces declare a copy method.
method setsize inabslist also cannot be migrated to list asabslist.setsize does not declare that an exception is thrown while list.setsize does note that this is type correct .
migrating it would result in a compiletime error at the call at line because removelast does not deal with the declared thrown exception.
also in the same class copy cannot be migrated to list as so would result in a compile time error at line because queue1.copy would return list which is not a subtype of abslist .
the same method could also not be migrated to copiable because the returned value ofabslist e line is not type compatible with the generic return type efrom copiable .
copy inabslist also cannot be migrated because it calls clone which is a protected method of object .
while interfaces do not extend object they implicitly declare abstract methods for only each public object method which does not include clone .
moreover print inabsqueue cannot be migrated as it contains an unqualified reference to super which is disallowed in interfaces to prevent the diamond problem .
note that queue is functional via the annotation at line meaning that lambda expressions can be used to represent types implementing the interface.
an interface may also beeffectively functional i.e.
an annotation is not required to instantiate an interface using a lambda expression.
it is required that functional interfaces have exactly one abstract method so that it is not ambiguous as to which method is invoked when the lambda expression is evaluated ch.
.
.
as such migrating offer from absqueue to queue would result in a type incorrect program because queue would no longer have any abstract methods thus invalidating the lambda expression on line .
method add inabsqueue would be otherwise fine to migrate to list however so would produce a type84 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
incorrect program as absqueue would inherit multiple interface methods i.e.
add from list andqueue .
such a situation is disallowed by java s typing rules.6note that this situation would also arise even if queue.add were default.
furthermore the same problem would emerge in absqueue hadadd been defined in one of its subclasses.
queue isstrictfp line meaning all calculations within its methods use strict floating point math.
while not related to type correctness migrating offer from absqueue line to queue could possibly alter semantics as it is not strictfp .
the modifier can also be used at the method level where a similar mismatch can occur.
additionally there is an difference in annotation types between the two methods possibly affecting processing frameworks like dependency injection.
set inabslist line also has an annotation difference with the method in list line except here the difference is in the annotation value .
migrating method removelast inabsqueue line tolist does not result in any type incorrect code however semantics would be altered as the run time target of the call at line would change to the method in abslist .
this is because absqueue would inherit two different different versions of removelast one from class abslist and the other from interface list .
in this situation classes take precedence over interfaces.
moreover we would have this problem had the conflicting method come from a directly implemented interface rather than from the class hierarchy.
as a result of the refactoring absunmodlist line is now empty i.e.
no methods fields or inner types remain.
as such it can be removed and the reference at line can be replaced with its super class see fig.
b .
although absstack line is now also empty it cannot be removed because replacing the reference at line with its super class would produce an error at line as it does not implement collection .
replacing it with the implemented interface would also cause an error at line asabscontainer is not a super type of collection .
defaultcomparator line is now empty as well and can be removed with the reference at line being replaced with the implemented interface and changing extends to implements .
however we must ensure that subclasses like ccomparator do not contain