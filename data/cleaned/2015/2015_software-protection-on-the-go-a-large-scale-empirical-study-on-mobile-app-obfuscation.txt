softwareprotectiononthego alarge scaleempiricalstudyon mobile app obfuscation pei wang pxw172 ist.psu.edu the pennsylvania state universityqinkun bao qub14 ist.psu.edu the pennsylvania state universityli wang lzw158 ist.psu.edu the pennsylvania state universityshuai wang szw175 ist.psu.edu the pennsylvania state university zhaofeng chen chenzhaofeng baidu.com baidu x labtao wei lenx baidu.com baidu x labdinghao wu dwu ist.psu.edu the pennsylvania state university abstract the prosperity of smartphone markets has raised new concerns about software security on mobile platforms leading to a growingdemandforeffectivesoftwareobfuscationtechniques.dueto variousdifferencesbetweenthemobileanddesktopecosystems obfuscation facesboth technical andnon technical challengeswhen appliedtomobilesoftware.althoughtherehavebeenquiteafew software security solution providers launching their mobile app obfuscation services it is yet unclear how real world mobile developers perform obfuscation as part of their software engineering practices.
our research takes a first step to systematically studying the deployment of software obfuscation techniques in mobile software development.
with the help of an automated but coarse grained method we computed the likelihood of an app being obfuscated for over a million app samples crawled from apple app store.
we then inspected the top instances and managed to identify obfuscated versions of ios apps.
by analyzing this sample set with extensive manual effort we made various observations thatrevealthestatusquoofmobileobfuscationintherealworld providing insights into understanding and improving the situation of software protection on mobile platforms.
ccs concepts softwareanditsengineering softwarereverseengineering securityandprivacy softwaresecurityengineering mobile and wireless security keywords obfuscation reverse engineering mobile app empirical study part of the research was done during an internship at baidu x lab.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
reference format pei wang qinkun bao li wang shuai wang zhaofeng chen tao wei anddinghaowu.
.softwareprotectiononthego alarge scaleempiricalstudyonmobileappobfuscation.in icse 40thinternationalconference on software engineering may june gothenburg sweden.
acm newyork ny usa 11pages.
introduction concerns on security breaches targeting mobile apps have kept rising in past years.
it was reported the piracy rates of popular mobileappscanapproachto60 .researchbygibleretal.
foundthatasurprisinglylargeportionofmobileapplicationsare copies ofothers .besidesthesetraditionalintellectualpropertytheftproblems theindustryisalsofacingnewsecuritythreatsastherearenowmanybusinessesheavilyrelyingonmobiledevices tooperate amongwhichthefraudulentandmaliciouscampaigns conducted through automatically manipulating a massive number ofmobiledevices areparticularlyharmfultothemobileecosystems.fromatechnicalpointofview reverseengineeringmobile apps in generaltakes less effort than traditionaldesktop software due to the wide use of reflective programming languages like java andobjective candtheregulatedbinarystructuresrestrictedby themobilehardwareandsoftwareenvironments.thesoaringof unprecedented security challenges and the lack of natural defenses call have driven mobile developers to seek additional protections.
one of the most important software protection technologies is software obfuscation which is a kind of semantics preservingprogram transformations that aim to make software code more difficult for automated tools and humans to analyze.
although obfuscation relatedresearchtopicshavebeenintensivelystudied fordecades mostpreviousworkfocusesonin labtechnicalanalysis oftheeffectivenessofnewobfuscationtechniques or countermeasures against obfuscation when it is misused by malwarewriters .asfaraswehavelearned littleemphasisis putoninvestigatinghowbenignsoftwareauthorstakeobfuscation as part of their development process in the real world which is criticalforsoftwareobfuscationtechniquestobepractical.topush this line of research forward we aim to investigate the answers to the following important research questions rq1 what are the characteristics of obfuscated mobile apps?
rq2 in what patterns are mobile apps typically obfuscated?
rq3 how does app review acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang et al.
affecttheadoptionofobfuscation?
andrq4 howresilientarethe obfuscated apps to malicious reverse engineering?
todevelopmeaningfulconclusions itismostadequatetoconduct an empirical study on a reasonably large set of recently developed and supposedly benign mobile apps obfuscated by their vendors.unfortunately thereisnosuchadatasetavailableforpublicaccess sowedecidedtocollectsamplesindependently.thereare currentlytwomajorplatformsinmobilesoftwaremarkets i.e.
ios andandroid.althoughtheysharemanycommoncharacteristics there are also notable differences.
some previous research has indirectlyorimplicitlytouchedthetopicofmobileappobfuscation butthefocusismostlyonandroid.forexample thestudybyzhouand jiang on android malware revealed some obfuscated samples .
linares v squez et al.
and glanz et al.
investigated android app repacking with the potential disturbance of obfuscation considered.
on theother hand the ios platformreceived notably less attention which mismatches its share in the market.
with over abillioniosmobiledevicessold therearereportedlymillionsof softwareprogrammersworkingoniosappdevelopment.inthis study we chose to work on ios for a dual purpose of filling in the blankofempiricalstudiesonmobileappobfuscationandenriching scientific research on this important mobile platform.
to obtain a representative sample set we crawled freeios appinstances fromtheofficial appleapp store.we then estimatedthelikelihoodofeachinstancebeingobfuscatedbased on a variant of a statistical language model previously proposed for studying software source code .
we picked the top most likely obfuscated samples and identified that are truly obfuscatedwithmanualverification.foreachsample wefurther conductedin depthinvestigationstounderstandhowobfuscation was applied.
in general effectively analyzing a large amount of obfuscated binary code can be extremely difficult since most existing program analysis techniques have either scalability or accuracyissues regarding obfuscated code.
moreover analyzing ios apps has its own unique challenges one of which is caused by the wide use ofstatically linked third party libraries .
to overcome these obstaclesaltogether ourstudycombinedautomatedanalysiswithaconsiderableamountofmanualeffortfromknowledgeablesoftwarereverseengineerswithindustryexperience.afterexaminingallthesamples weformulated8findingsregardingtheproposedresearch questions.
in summary we made the following contributions in this research we are the first to conduct a comprehensive empirical studytargeting mobile software obfuscation.
our research focuses onios aninfluentialmobileplatformthatdidnotreceive enough attention from the academia in contrast to android.
we developed a scalable detection algorithm to estimate the likelihoodofaniosappbeingobfuscatedandappliedittoa largequantityofappscrawledfromappstore.aftermanually analyzing the most likely obfuscated instances weidentified539trulyobfuscatediosappswithatotalof different versions.
as far as we know this is the first scientificallycollectedsamplesetofobfuscatediosmobile apps.weplantosharethesesampleswiththecommunity in the future.
to overcome the limitations of existing automated software analysisonobfuscatedbinaries weinvestedover600manhoursinmanuallyexaminingtheobfuscatediosapps extracting detailed information about how these apps are protectedbydifferentobfuscationalgorithms.thehumaneffort assured the accuracy of our analysis and therefore the credibility of our findings.
wemadevariousobservationsaboutthecharacteristicsof obfuscated apps the obfuscation patterns applied and their resiliencetoreverseengineering.ourfindingscanshedlight on future research on mobile software protection.
background .
significance of the problem obfuscation is one of the most important software protection techniques that prevent software from being reverse engineered maliciously.
the status of its application and presence among pub lishedsoftwareiscloselyrelatedtothestateofsecurityinasoftware ecosystem.
previous research on mobile software engineeringrevealedthatobfuscationhasbeenacommonpracticeonandroid yet the figure for ios is mostly missing.
since ios is typically considered a more secure system than android for being more closed it may be susceptible that obfuscation on ios could be as prevalent as on android.
however some recent security incidents have shown that with the help of productionqualitybinaryanalysistoolslikeidapro iosreverseengineeringisnotasdifficultasitisgenerallyrecognized.forexample it is foundthat ios developers similarlysuffer from severesoftware piracy issues like android developers .
it is also reported that therehavebeenpopulariosappsbeingrepackagedwithmalicious payloadforstealingsensitiveuserdata .tohelpiosdevelopers counter these threats some reputed software security solution providers have launched their ios app obfuscation services .
for more secure ios software engineering it is imperative to obtain a thorough understanding about the current practice of applyingobfuscationiniosappdevelopment.thebenefitsofsuchanunderstandingaretwo fold vendorsofobfuscationtoolscanbetter tune their development based on the status quo while researchers interestedinanalyzingiosapprepositoriescangraspasenseabout when and how obfuscation may affect their analysis.
.
technical challenges of the study despite both being mobile platforms ios and android are dras tically different in many technical aspects.
as a result our study facesunprecedentedchallengesthatneednottobeconsideredby similar work targeting android.
.
.
obfuscation detection and analysis.
detectingandanalyzingobfuscatedbinarieshaslongbeenanopenresearchproblemand isstillbeingactivelystudied .todate theaccuracyof automated obfuscation detection is not satisfying enough to fit our demand.therefore wedecidedtoundertakemanualanalysisasthe majorresearch methodologyofthestudy withsomelight weight automated methods as assistance.
unlike android developers that can use an app obfuscator embedded into the official development toolchain iosdevelopersdonotgetanyreceiveofficialsupport authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
empirical study on mobile app obfuscation icse may june gothenburg sweden thushavingtorelyonthird partytoolsorself madeobfuscators.
consideringthelargenumberofobfuscationtechniquespotentially available itisimpracticalforanempiricalstudyrelyingonmanual effort to cover all of them.
this poses another challenge requiring us to identify a group of obfuscation techniques analyzable with our limited labor yet representative enough.
.
.
static third party libraries.
third party libraries have been an indispensable part of mobile apps.
it is possible that an app accidentally gotobfuscatedduetotheinclusionofobfuscated libraries without the awareness of app developers.
our analysisneeds to capture such situations to avoid drawing biased conclu sions.unlikeandroidappsthatarewritteninjava iosappsare written in languages that are more static e.g.
c c objective c and swift.
due to apple s security policies ios apps cannot use dynamiclibrariesfromothervendorsuntilios8 meaningallthird partylibrarieshavetobestaticallylinkedintoappexecutables.the consequence is that there is no clear boundary between library code and an app s own code making library detection in ios apps auniquechallenge .thisiscompletelydifferentfromthe library identification problem on android where application code is naturally assorted through the java package hierarchy.
methodology we adopted a three step process to conduct the empirical study.
the first step is to select a representative collection of obfuscation techniques to consider for reasons explained in section .
.
.
the second step is to search for a reasonably large set of ios apps that areobfuscatedbeforerelease.todate thereisnosuchapublicly availabledataset.miningobfuscatedsamplesfrombenigniosapps is one of the major contributions of our work.
for the third step weinspecteachobfuscatedappinmoredepthandaggregatethe harvested information to deduce empirical findings.
.
considered obfuscations afterdecadesofdevelopment therearenownumerousobfuscation techniques available.
a comprehensive review by schrittwieser et al.
included classes of obfuscation methods proposed by previous research.
for this study we would like to focus on obfuscations popular among mobile developers and therefore worthyofin depthinvestigation.weusedgoogletosearchforcommercial and opensource tools that can obfuscateios applications.
by studyingthestatementsandtechnicalwhitepapersofthetop10 results we identified four families of obfuscations that are most widely supported i.e.
symbol renaming exotic string encoding controlflowflattening anddecompilationdisruption.compared toallknownobfuscationalgorithms thisisarelativelysmallset withthemajorreasonbeingthattheuniquehardwareandsoftware environment on ios devices imposes strict restrictions on the form of executable code.
for example ios does not allow normal userapplications to dynamically generate executable code rendering self modifying obfuscation technically impossible to implement.
a graphicalillustrationofthefourobfuscationalgorithmfamiliesis given by figure while the technical details are briefly introduced as follows.
symbolrenaming.
itisrecommendedbycommonsoftwareengineering practices that programmers should make sensible namesforfunctionsandvariablessymbols.thepreferredprogramming languages for developing ios apps i.e.
objective c and swift are reflectiveorpartiallyreflective.therefore namesofmanyglobal symbolshavetoberetainedinthedistributedbinariestosupport by namefunctiondispatchingatruntime.symbolrenamingscrambles these names to prevent information leakage.
exoticstring encoding.
string literals sometimes disclose important information about the software.
some obfuscation algorithmsconvertstringliteralsintorepresentationsthatarenotunderstandable by humans.
the converted strings are decoded before use during run time.
decompilationdisruption.
itiscommonforobfuscationsto prevent the recovery of high level program structures from binary code.typicalmethodsofthiskindincludeinterleavingcodeand data to disturb disassembly inserting opaque predicates to forge invalidcontrolflows andemployingcertainmachineinstruction patterns in unconventional ways to confuse decompilers.
control flow flattening.
this technique flattens the original control flow graph of a function by rewriting the procedure into a huge switch like structure .
this makes the logical links between basic blocks obscure.
.
mining obfuscated ios apps toobtainareasonablylargesamplesetwithoutbeingbiased our collectionstartswiththeentireappleappstore.however itshould be noted that we do not aim to find all obfuscated apps in the store.
from february to october in we crawled free iosapp instances includingdifferent versionsof thesame app.
we then try to identify apps that are obfuscated by at least one of the four families of algorithms in section .
.
ideally we could run automateddetectionoverallthecrawledappsforeachobfuscation technique subsumed by the four families.
however obfuscation detection itself is a non trivial task and is still being actively researched .
for many obfuscation algorithms considered by our study it is prohibitively expensive if possible at all to automatically detect their presence in over a million instances.
totacklethisproblem weidentifya baselineobfuscationalgorithmwhichissupposedtobethemostwidelyadoptedinmobile development.ifdevelopersindeedconsiderprotectingtheirproducts it is very likely that more than one obfuscation algorithm will be employed.
in such cases detecting the baseline obfuscation can help us identify the heavily obfuscated samples.
based on this insight we developed an automated method to identify scrambled symbol names since symbol renaming is considered by a large volumeofpreviousresearchthemostprevalentobfuscationmethod onmobileplatforms .inpractice symbolnamescramblingimposeslittleexecutioncostwhilebeinghighlyeffectivein disturbing manual analysis.
details of the detection algorithm are presented in section .
afterrunningthealgorithmforallcrawledappinstances weobtainedthelikelihoodofeachappbeingobfuscatedbysymbolnamescrambling.basedontheavailableman labor weexaminedthetop 6600mostlikelyobfuscatedsamples ofwhich601areconformed tobetruepositivesbymanualverification.thesesamples which can be further grouped into applications identified by a unique id assigned by app store are taken as the data set for subsequent authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang et al.
interface person nsobject property nsstring name property int age property nsstring addr end interface alji09 nsobject property nsstring kjihad property int z9kmv property nsstring nm23d end a symbol renamingconst char str1 a plain string string xor masked by 0xab const char str1 xea x8b xdb xc7 xca xc2 xc5 x8b xd8 xdf xd9 xc2 xc5 xcc x85 void decode const char s char d while s d s 0xab d b exotic string encoding c decompilation disruption1 switch d control flow flattening figure illustration of obfuscation techniques considered in the study crawl apps from app store instances automated baseline obfuscation detection pick top positives manual verification versions of apps the6600cut off is based on the maximum labor available for manual verification figure workflow for sampling obfuscated ios apps study.
this sampling process is illustrated by figure .
we again emphasizethat these601samplesshouldnotberegardedasallthe obfuscated apps among the 582crawled instances.
we set the cut off at to bound the manual work within a manageable amount.
.
per app inspection in addition to symbol scrambling we need to further confirm what otherobfuscation techniqueswere appliedtothe apps.this step needs to be conducted manually to achieve the highest possible accuracy.toassuretheconsistencyacrosstheresultsfromdifferentinspectors wedevelopedasetofelaborateprotocolstostandardize the inspection process.
.
.
detecting obfuscation.
to detect the presence of antidecompilation obfuscation techniques we use ida pro a commercial integrated reverse engineering environment that has been widely regarded as the de facto industry standard for analyzing binary code.
ida pro can automatically dissect a binary executable into functions and translate the assembly code of each function to a high level representation similar to c. we consider that a binary isprotected byanti decompilationtechniques ifidapro reports too many failures.
all results were manually validated.
to identify flattened control flows we developed a binary analysisframeworktodisassembleappbinariesandconstructthecontrolflow graph cfg of each function in a binary.
if a cfg is flattened mostofitsbasicblockswillbeincludedbyasingleloop whichcan be captured bya standard loop detection algorithm .
also the diameter of the loop which is defined as maximum length of the shortest path from the loop header to other basic blocks should be ofthelogarithmicorderofthetotalnumberofallbasicblocksin the loop.
based on these two characteristics we can find functions with flattened control flows.
for exotic string encoding it is hard to develop automatic detection methods since there is no standard implementation of such techniques.iniosexecutablebinaries stringliteralsarestoredin dedicatedregions.wescantheseregionsforcharactersequences that cannot be decoded or those that can be normally decoded but do not seem to possess reasonable meanings.
we then manually investigate how these sequences are utilized in the code and see if theyaretransformedbyanadhocdecodingprocedureatcertain program points.
.
.
identifying obfuscated third party libraries.
asintroduced in section .
.
we need additional manual effort to identify thirdpartylibrariesintheexaminediosappsifthelibrarycodecontains any obfuscation by themselves.
we decide if an obfuscated code regionbelongstosomethird partylibrarybyobservingwhether therearesimilarcodepatternsappearinginmultiplesamplesdevelopedbydifferentvendors.typicalsignaturesofcodepatterns include control flow graphs special algorithms and uncommondata structures.
once a library is detected we try to identify itsorigin through public information searching with clues such as namesoflibraryapisandspecialstringliterals e.g.
stringsused for logging and generating crash reports.
some libraries do not provideeventhe mostsubtle informationthatcan helprevealtheiridentities.insuchcases weextractedthesemanticsignaturesofob fuscatedcode e.g.
controlflowpatternsanduniquedatastructures and check if they appear in different apps.
.
cross validation to ensure the accuracy and consistency of manual analysis the two authors performing per app inspections were first asked to independentlyexaminethesame50appinstancesinthesamplesetandcomparetheirresults.divergencesamongresultsfromdifferent authorswerediscusseduntilanagreementwasreached.thetwo authors then independently analyzed another apps based on theregulationsmadeinthepreviousdiscussions.forthesecond round theinspectionresultswereconsistentforall25apps.inthis authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
empirical study on mobile app obfuscation icse may june gothenburg sweden way weestablishedahighlyaccurateandcross validatedprotocols for the manual analysis on obfuscated ios apps.
detecting symbol obfuscation inpractice obfuscationtendstoreplacehuman madesymbolswith randomly generated gibberish which can be detected by natural languageprocessing nlp techniques.previousresearchdiscovered that human written source code is natural in the sense that it can be described by statistical language models .
based on this insight unnatural symbol names are possibly obfuscated.
.
an nlp based detection model innlp theperplexitymeasureisusedtoquantifyhow surprising it is for a sequence of words to appear within a statistical language model.oftentimes thelog transformedversionofperplexity called cross entropy is more preferable in the literature.
given a word sequence s x1 xkof length kand a language model m the cross entropy of swithinmis defined as hm s kk summationdisplay.
i 1log2p xi x1 xi we use cross entropy to capture the naturalness of an identifier.
intuitively lower hm s means sis more natural within m.i n particular we adopt the n gram language modelthat assumes the wordsequencessuitan n ordermarkovprocess.historically ngramhasbeenutilizedinvarioussoftwareengineeringapplications includingautomatedcodecompletion andbugdetection .
within an n gram model the definition of cross entropy can be further formulated as hn gram s kk summationdisplay.
i 1log2p xi xi n xi a notable difference between our method and previous work is thatourstatisticallanguagemodelisappliedtoindividualidentifiers rather than sequences of terms.
as a consequence we need to firstsegmentanidentifierintoseveralpartsbeforefittingittoan n gram model.
naturally we adopt the segmentation that makes most sensewithin the n gram modelby enumerating allpossibilities.therefore thelikelihoodof anidentifier ibeing surprising or obfuscated can be defined by the following formula l i min s sihn gram s where siis the set of all possible word sequences obtained by segmenting iindifferentways.givenanempiricallydecidedthreshold h w ed ee m ias an obfuscated symbol name if l i h. .
implementation considering that identifiers are usually not too lengthy we can efficiently compute l i in equation using the viterbi algorithm with the complexity of o nl2 where nis length of the identifier andlisthelengthofthelongestpossiblewordinthelanguage .
in fact the worst cases can often be avoided since most normal symbol names are already naturally segmented by programmers withunderscoresorthecamelcasescheme.wefirstcomputethe cross entropy of an identifier by assuming the symbol is naturallysegmented.iftheentropycomputedthiswayisalreadylowenough we can skip the relatively expensive viterbi segmentation.
ourn gram corpus contains two parts i.e.
the natural language corpusandthesoftwaresourcecodecorpus.mostidentifiersinthe crawledappsarenamedinenglish buttherearealsomanywritten in chinese pinyin or even a mixture of english and chinese.
for english weuseaportionofthegooglewebtrillionwordcorpus introduced by franz and brants and derived by norvig .
forchinese weemploythelancastercorpusofmandarinchinese lcmc .
as for the source code part we crawled all identifiers appearinginiosofficialapis whichareallnaturallysegmented.
eachidentifieristhenturnedintoawordsequence thusforminga n gram corpus.
the probability of occurrence for an n gram is defined as the average of its probabilities in three corpora.
if an n gram does not appearinanycorpus weassignitalowprobabilitypenalizedbyits length.
this is a necessary heuristic since there are a large number of unlisted words in program identifiers.
formally the occurrence probability of an n gram sis defined as p s pen s pcn s pcode s 3pen s pcn s pcode s s h pen s pcn s pcode s where s is the number of characters in the n gram and his the threshold defined earlier in this section.
whendecidingthevalueof n weobservedthatpatternsofword sequences in different applications are quite unique and rarely occur in the corpus.
the consequence is that any ngreater than oneleadstotoomanyfalsepositives.therefore thebestoptionfor the problem is to set nto namely to adopt the unigram model.
in this study the threshold his set to .
.
with this configuration a total of positives were reported.
potentially we could find more positivesby employing a larger h but the results thenwillexceedthemaximumnumberofsampleswecanafford to verify.
after manually examining symbols in the initial positives we confirmed that of them are truly obfuscated.
the falsepositivesare mostlycausedbyuses ofnon englishlanguage and out of vocabulary abbreviations.
findings inthissectionwepresent8findingsofourempiricalstudy grouped by their relevance to research questions raised in section .
.
rq1 characteristics of obfuscated apps we first discuss what factors might lead to the adoption of obfuscation in mobile app development.
finding a. .
a considerable portion of apps containing obfuscationare passively obfuscatedduetotheinclusionofobfuscated third party libraries.
aspreviouslymentioned wepaidspecialattentiontothird party libraries when inspecting the obfuscated apps.
the examination shows that these libraries indeed make a major source of obfus cation.
in total we captured third party libraries.
the major functionalityofeachlibrary inferredbyanalyzingtheircodeand retrieving publicly available information onthe web is presented in table .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang et al.
table obfuscated libraries grouped by functionality functionality count including apps advertising promotion security authentication digital right management payment banking location visualization analytics fraud detection peripheral control speech to text app only third party libs only app and third party libs135 .
.
figure origins of obfuscation in 539obfuscated apps a number of apps including each third party library b distributionofappsregardingthenumberofobfuscatedlibrariesincluded figure popularity of obfuscated third party libraries figure shows the breakdown of the origins of obfuscated code in the samples.
among the apps employing obfuscation of them include at least one obfuscated third party library.
inparticular for344 .
apps theobfuscationissolelyintroduced by libraries.
the popularity of these libraries can be further demonstrated intwo aspects.
figure4a shows foreach library the number of including apps and figure 4b shows the distribution of apps including obfuscated third party libraries regarding the number of libraries.data for app store from statista figure distributions of apps regarding their categories figure3indicatesthattheoccurrencesofobfuscationaremainly caused by the practice of depending on third party libraries rather thanappdevelopersactivelyconsideringsoftwareprotection.based onthe observation webelievethat itisimportantto considerthe impactofthird partylibrariesforempiricalsoftwareengineering research whenever app obfuscation is involved.
to distinguish different sources of obfuscation we henceforth call an app is actively obfuscated if its obfuscation is notentirely contributed by thirdparty libraries otherwise it is called passively obfuscated.
the most notable kind of third party libraries is for advertising purposeswithbothmetricsbeingthehighestintable1.ourprelim inary analysis on some of these libraries shows that the obfuscated parts are used for communicating with the back end ad servers.
itisknownthatmobileadvertisinghasbeenbotheredbyreverse engineering throughwhichamaliciouspartyinstrumentsadvertising libraries to forge fake advertisement display or user clicks and tricksadprovidersintopayinginvain .foradproviders obfuscating their libraries is a reasonable response to such malicious attempts.
findinga.
.
thelikelihoodofappsandlibrariesbeingobfuscated is strongly correlated to their categories of functionality.
we found thatin contrast tothe distribution ofall apps in app storeregardingtheircategories thedistributionofobfuscatedapps has a vastly different pattern.
this pattern varies further when the impact of third party libraries is considered.
figure shows thedifferences between these distributions leading to the following key observations the proportions of obfuscated apps in certain categories areexceptionallyhighcomparedtothesharesofallappsinthese categories acrossapp store nomatter whether passiveobfuscationistakenintoaccount.thesecategoriesarefinance .
.
vs. .
utilities .
.
vs. .
music .
.
vs. .
and medical .
.
vs. .
.
according to our investigation most of the obfuscatedmusicappsprovidestreamingservicesforcopyrighted authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
empirical study on mobile app obfuscation icse may june gothenburg sweden musical contents.
the inspected utilities apps are mainly toolkitsoftware providingassistance todailyactivities the majority of which regularly record user data that may be closely tied to personal privacy or enterprise secrets.
forsomeother categories thesituationisflipped namely the proportions of apps carrying obfuscated code are significantlylowerthanthestore wideratios.categoriesofsuchinclude education .
.
vs. .
book .
.
vs. .
food drink .
.
vs. .
and reference .
.
vs. .
.
the distributions of obfuscated apps in the games finance and utilities categories are heavily influenced by obfuscated third party libraries.
apps in the games category are easily passivelytaintedbylibraries.thefinanceandutilitiesapps on the other hand have a relatively higher rate for being actively obfuscated.
the first two points suggest that mobile apps related to health finance privacy and intellectual property safety are more likely to get obfuscated both actively or passively.
despite being a fairly expectedphenomenon itinformsusthatsoftwareobfuscationat this point is still not a general interest to mobile development.
we mayinferthatalthoughdevelopersworkingonsecurity sensitive businesssectorsdoviewmaliciousreverseengineeringasanonneglectable threat the obfuscation applied to their works is mostly for protecting the information encapsulated in the apps rather than the design and implementation of the software.
regardingthethirdpoint itturnsoutthatamongthe112games apps with obfuscation are passively obfuscated and of them are solely tainted by obfuscated advertising libraries.
the statistics fitthegeneralperceptionsofthemobilegamebusinessmodelin whichpublishingthird partyadvertisementsisthemajormonetization method for free game apps.
for finance and utilities apps the fractions of passively obfuscated ones are comparatively lower outof85and18outof45 respectively suggestingthatsoftware protection is more seriously considered in these sectors.
.
rq2 obfuscation patterns before presenting our findings regarding rq2 we first present an overviewontheobfuscationpatternsextractedfromthesamples.
we studied the pattern of obfuscation in three aspects how many and what kinds of obfuscation techniques are found in the code inwhatscopestheobfuscationalgorithmsareappliedtothe code i.e.
at the function level class level or module1level whether multiple obfuscation methods are applied to the same code region to achieve a synergy effect which we call synergistic obfuscation.
weperformedthispatternanalysisonactivelyobfuscatedappsand obfuscatedthird partylibrariesseparately.theresultsarepresented in table and table respectively.
duetolimitedspace weonlylistcategorieswithsignificantrelevancetothediscussionsinfindinga.
.itmaycauseconfusionthat asmallnumberofappsorlibrariesdonotemploysymbolrenaming 1a module is defined as functionality related classes coupled through method calls.even though it is the baseline obfuscation method in sample collection.
the reason is that we detect symbol scrambling in obfuscated app instances as a whole.
in some cases we accidentally detectobfuscated apps or libraries without scrambled symbols because they are mingled with obfuscated parts developed by others that indeedcontainsuchsymbols.nevertheless suchcasesarerarely seen among actively obfuscated apps out of .
interestingly allfivethird partylibrariesthatdidnotscramble theirsymbolsaredevelopedbyinternetgiantslikegoogle amazon yahoo tencent and alibaba suggesting that large scale enterprises and smaller mobile development teams may favor quite different obfuscation patterns which is worth further investigation.
findingb.
.
mobileappsaremostlyobfuscatedatalargescale suggesting a wide adoption of automated obfuscation tools.
intheory obfuscationcanbemanuallyconductedwithoutthe aidfromautomatedtools .nevertheless webelievethisisnot thecaseinmobiledevelopment.foractivelyobfuscatedapps the proportion of those employing module level obfuscation is .
out of .
for third party libraries the rate is even higher reaching71 .
25outof35 .comparedtofunction levelandclasslevel obfuscation the workload of protecting one or more modules issignificantlyheavier implyingthat mostmobiledevelopersrely on automated tools for obfuscation.
on the other hand it is extremely rare that an entire app or library is obfuscated.
throughout the inspection we only identifiedtwoactivelyprotectedappsthatarefullycoveredbysymbol scrambling obfuscation.
for all other apps and libraries the obfuscationcoversonlyasmallportionofthecode.thisphenomenon shows that applying obfuscation to mobile software comes with non negligible cost even if the processcan be automated.
presumably the cost of obfuscation can include but not limited to increasedconfigurationeffort increasedcompilationtime and run time performance penalty additionalcostofsoftwarecrashforensicsduetoscrambled symbol names and obscure control flows and risksofappsbeingrejectedbysoftwarepublisherforbloated or unanalyzable code see finding c. for more discussions .
althoughitishardtoconfirmtheseitemswithoutcontactingthe developers wecanstillgetsomehintsbyanalyzingotheraspectsof the obfuscation patterns as demonstrated by the following finding.
findingb.
.
thepopularityofobfuscationmethodfamiliesdecreases as the implementation and performance cost grows.
it ismade clear by table2 and thatthe popularity ofthe four obfuscationfamiliesvastlydiffers.thenumberofappsandlibraries containing decompilation disruption and control flow flattening is remarkablysmallerthanthenumberofappsandlibrariesprotected with scrambled symbol names and exotic string encoding.
due tooursamplingmethodology symbolscramblingisnaturallythe mostpopularobfuscationtechniqueacrossthedataset.however evenwithoutsymbolscramblingconsidered itisstilltrueforthe other three families of techniques that the more costly it is toimplement and deploy an obfuscation algorithm the less widelyit is adopted.
to elaborate on this trend we roughly discuss the difficultyofautomatingobfuscationeachmethodandtheirimpacts on run time performance in an increasing order.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang et al.
table numbers of actively obfuscated apps employing different obfuscation patterns category totalapplied obfuscation families of families scope of obfuscation synergic obfuscationsymbol string anti decomp.
flattening function class module finance utilities games music medical others all table numbers of third party libraries employing different obfuscation patterns category totalapplied obfuscation families of families scope of obfuscation synergic obfuscationsymbol string anti decomp.
flattening function class module advertising security drm payment others all automaticallyscramblingsymbolnamesisrelativelyeasyand can be implemented through various options like preprocessor macros compiler instrumentation and even binary rewriting.
renamingsymbolscanbeimplementedinawaythatitcausesalmost no performance degradation during program execution.
re encoding string literals in an automated manner requires moreeffortsinceitchangesprogramsemantics.however theobfuscation only needs to operate on strings and therefore light weight programtransformationsaresufficient.atruntime theobfuscated stringsneedtobedecodedbeforeuse butitisone timecostand only manifests when programs launch.
comparedwiththefirsttwofamiliesofobfuscation decompilation disruption is significantly more difficult to implement for obfuscatorwritersneedreverseengineeringexperience tounderstandhowtodisruptadecompiler.itishardtoanalyzetherun time costofthisobfuscationsincetechniquesinthisfamilycanvarya lot.
nevertheless the performance penalty is not constant and will keep accumulating as programs run.
implementingcontrolflowflatteningrequiresdeepcustomizationofthecompilerwhichfallsoutoftheskillsetsofmostcommon mobiledevelopers.same asdecompilationdisruption eachexecutionofflattenedcontrolflowstakesanadditionalamountoftime.
it is also worth noting that control flow flattening can increase the size of obfuscated binaries significantly.
currently we are unable to confirm whether the difference of popularity results from exact one of thetwo factors i.e.
implementationcostandperformancepenalty orbothofthem.theoretically iftheobfuscationisconductedwiththird partytools thetechnical challenges in implementing each obfuscation method should notbeaproblem leavingperformancetobetheprimaryconcern.
otherwise if the intention of apply software protection is really blockedbytechnicalissues therewillbemanyopportunitiesfor obfuscation toolkit providers to improve their products and attractmoremobiledeveloperstoembedadvancedobfuscationtechniques into their apps and libraries.
it would be interesting future work to investigate which is the case.
findingb.
.
appsandlibrariesofcertaincategoriestendtoadopt more complicated obfuscation patterns than others.
finding a. shows that apps serving life money and privacycritical purposes are more likely to be obfuscated.
it is further suggestedbytable2andtable3thatthesecuritystrengthofobfuscationappliedtoappsandlibrariesofthesekindsisalsonotablystronger.ingeneral thefinance utilities games andmusicapps ifobfuscated aremorewillingtoemployexpensiveobfuscationtechniques i.e.
decompilationdisruptionandcontrolflowflattening.
these apps also tend to employ more different families of obfuscationtechniques.forexample overhalf 20outof39 oftheactively obfuscated finance apps contain plural kinds of obfuscation.
moreover in many cases out of these different methods were appliedtothesamepartofthecode achievingsynergisticobfuscation.
also the scope of obfuscation in these apps is often larger mostly reaching module level protection.
theobservationaboveappliestoobfuscatedthird partylibraries aswell.overall theobfuscationpatternsfoundinlibrariesarevery similar to those in actively obfuscated apps in most aspects.
therefore itcanbedifficulttodistinguishactivelyandpassivelyobfuscated mobile apps by simply analyzing their obfuscation patterns.
findingb.
.
anincreasingnumberofmobileappsstarttointegrate obfuscation into the development process.
as aforementioned our sample crawling was continuous and lastedforninemonths.forappsgettingversionupdatesduringthe crawlingperiod wewereabletoanalyzethetemporalevolutionof their obfuscation patterns.
with these historical versions andsome additional examinations we confirmed that of the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
empirical study on mobile app obfuscation icse may june gothenburg sweden actively obfuscated apps were unobfuscated at the beginning of the crawlingperiod.
itis verylikely thatdevelopers ofthese apps were newly attracted by the benefits of software protection and started to employ it as part of their software engineering routines.
notethat27isapossiblyuntightlowerboundbecausetherecorded versionhistoriesmaybeincompletebecauseofthelimitedworkload capacity of our crawler.
unfortunately the same analysis does not apply to passively obfuscatedapps sincetheymayincludedifferentthird partylibraries indifferentversions.thechangeofobfuscationstatusintheseapps may not reflect the intention of their developers.
the analysis is alsonotapplicabletothird partylibraries becausewewereunabletoobtainthedevelopmentdatesofeachversionofthesamelibrary.
.
rq3 impact of distributor code review centralizedsoftwaredistributionusuallyfeaturesavettingprocessinwhichanappmustbereviewedbythedistributorbeforeallowed for publication.
through this vetting process software publishers aimtofilteroutmaliciousormisbehavingapplicationsthatcanhurt user experience or security thus affecting the healthiness of the ecosystem.
both ios and android employ this centralized model.
hypothetically this mandatory app review process can affect developer incentive to obfuscate their products in two opposite ways.
firstly although software obfuscation is a legit approach toprotectingappsfromundesiredreverseengineering ithinders distributor reviews as well.
if the reviewer acts conservatively and considersunanalyzablecodemalicious theobfuscatedappsmaybe constantlyrejected makingdevelopersreluctanttoadoptheavyweightobfuscationalgorithms.ontheotherhand somedevelopers maybestimulatedto obfuscatetheircodesothatthey areableto circumvent certain checks allowing their apps to possess features forbidden by publisher policies.
we have encountered two cases supportingbothpossibilities respectively.althoughnotqualified as solid evidence to validate our hypotheses these case studies can indeed provide valuable insight on the problem.
findingc.
.
codereviewsenforcedbymobilesoftwarepublishers may influence the adoption of obfuscation in different directions.
thefirstcaseisaheavilyobfuscatedappdevelopedbyareputed commercial ios security service provider which only published that single app in app store.
judged from the simplicity of its functionality this app is merely a minimal working example of iosdevelopment whereas it is protected by all four kinds of obfus cation techniques considered by our study.
only two among the actively obfuscated apps are obfuscated in this pattern.
we speculate that the security solution provider submitted this app to addresstheconcernsthattheirobfuscation algorithms maycause distributor review alarms to the detriment of the sales of theirservices.
it is known that app store have various constraints onsubmitted apps some of which may not be clearly documented.
forexample eachsliceofanexecutablefileiniosappsmustnot exceed mb if the app is to be compatible with older versions ofios limitingtheuseofcodetransformationsthatbloatbinary size too much.
these constraints intrigue obfuscator writers to test the boundaries of acceptable obfuscation techniques.
this case suggeststhat developingnewmobileobfuscationalgorithmshasto take the app vetting process into account to be practical.in the second case we found that a third party advertising librarycontainscodeforcallingprivateiosapis whichisstrictly forbiddenbyappleappstoresecuritypolicies.tocircumventstore reviews thelibrarywriterusesthe dlopen systemcalltoavoid directlinkagetointernaliosframeworksprovidingprivateapis.
thelibrarythenusesexoticstringencodingtoobfuscatethestring literals provided to dlopen as parameters.
in this way apple s vetting analysis failed to detect this violation.
by searching related information on the internet we learned that this library was once caughtusingprivateiosapisin2015 longbeforewestarted crawlingsamplesfromappstore.shortlyaftertheincidentwasre ported appleannouncedthatithadremovedallappscontaminated by this library from app store.
yet our findings show that either authorsofthelibrarymanagedtobypasstheappreviewprocess for another time or apple failed to detect all apps including this library.
whichever is the case this finding serves as empirical evidencethat obfuscationisnotonlyemployedtorepelmaliciousreverse engineeringbutalsoforinfiltratingpublisherinspection eventhough this practice is previously regarded as a signature of malware.
by nature ad providers are impelled to collect as much client dataaspossiblefordevelopingmoreeffectiveaddistributingstrategies potentially placing themselves on the verge of infringing user privacy.consideringthelargequantityofobfuscatedthird party advertising libraries and their wide spread in the sample set we areconcernedbythepossibilitythatabusingobfuscationtobypass publishersecuritypolicyenforcementisbecomingacommonpracticeforaggressiveadwareonthemobile.mobileappsfallingwithin a gray area that are controversially benign or malicious aka.
grayware has drawn attention from the security community .
.
rq4 effectiveness of obfuscation we now present our findings regarding the effectiveness of realworld obfuscation for mobile apps.
it should be emphasized that ourgoal isnotto accessthesecurity strengthofobfuscation techniques themselves like previous literature review did but to investigatewhetheriosdevelopersareabletoappropriatelyutilize these techniques and optimize the protection effects.
with limited labor we cannot afford to conduct comprehensive penetration tests for all apps in our sample set.
even though we foundthatamodestamountofreverseengineeringeffortisenoughto reveal some information that possibly leads to security breaches.
weinspectedtheactivelyobfuscatedappsintwoaspects.firstly wescannedallsymbolnames searchingforcommonkeyphrases related to security such as private key and secret .
secondly during the detection of exotic string encoding we payed attention to string literals that are not obfuscated and seem to leak sensitive information.
findingd.
.
aconsiderableportionofobfuscatedappsremain vulnerabletolow effortreverseengineering whichcouldhavebeen avoided if the obfuscation was performed more appropriately.
with preliminary reverse engineering effort we found that among the actively obfuscated apps there are that may leave certain sensitive information unprotected due to lack of certain obfuscation techniques or insufficient coverage by the right techniques.
there are mainly three kinds of such information authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden p. wang et al.
tokensassignedtoappsforaccessingthird partyservices.
some enterprise entities provide apis for mobile apps to retrieve proprietary information or upload app usage data for analytics usuallyataprice.requestsforaccessingtheseservices has to be sent with tokens issued by service providers toprovetheidentitiesofrequestingclients.wefoundthat someappsstorethesetokensasplaintextinvariableswhose names are not scrambled.
in app secrets.
apps may encrypt their private data suchas execution logs and intermediate results before storing them on mobile devices.
some poorly obfuscated apps store encryption keys in plaintext as string literals.
informationaboutback endserversconnectedwiththeapps andthe correspondingcommunication protocols.
inparticular we found 4apps which are the mobile clients of some financial institutions leaking the urls or ip addresses of theirback endtestinginfrastructures.
surprisingly accessingthese infrastructures does not require any authentication.
the communicationprotocolsandeveninternaldocumentations are exposed to anyone knowing the urls or ips.
itistruethatinformationleakedabovedoesnotnecessarilyleadto exploitable security vulnerabilities.
per common software security principles however such information should not be exposed to unauthorizedpartiesinthefirstplace.althoughleakagesdiscovered by our study were caused by series of inappropriate software engineering practices the problem will be less severe if the apps are more properly obfuscated.
in our opinion the current status of software protection on mobile platforms is far from satisfactory.
implications of the results through this empirical study we learned that third party libraries playasignificantroleiniosappobfuscation whichisconsistent with the situation on android .
being a major source of obfuscated code third party libraries affect software attributes in various aspects without app developers being aware.
we urge that future studies on ios app repositories to take obfuscated third partylibrariesintoconsiderationanddevelopdedicatedanalysis techniques to handle them.
wehavefoundaposteriorievidenceindicatingthecorrelation betweenthelikelihoodofmobileappsbeingobfuscatedandtheir functionality.
particularly apps related to finance privacy intellectual properties and monetization are more likely to be obfuscated.
itmay beworthwhilefor obfuscationserviceproviders totakean in depthstudyonthecharacteristicsoftheseappsandspecialize their products to better fit the demands of their vendors.
ourstudysuggeststhattheadoptionofobfuscationonmobile platformsmaybeaffectedbymandatorycodereviewsfromappdis tributors.sinceobfuscationisinherentlyunfriendlytocodereviewsand may causes disapproval from the reviewer app developers will likely face the dilemma between improved security and shorter timetomarketoftheirproducts.thisfactorneedstobeconsidered when developing or advocating new obfuscation techniques for mobileplatforms particularlyios whosevetting processismuch more strict that android.
we noticed an increasing trend in the number of mobile apps getting obfuscated.
for a notable portion of these apps however theobfuscationwasnotappropriatelyconducted leavingthemstill vulnerable to certain lo w effort reverse engineering techniques.
as such webelievethatfutureeffortsonsoftwareprotectionshould not only focus on developing new obfuscation techniques but also proposingaccessiblepoliciesandstrategiesthatcanguidemobile developers to maximize the efficacy of existing techniques.
related work to the best of our knowledge most historical work on mobile appanalysistargetstheandroidplatform.theandroidmalware genome project is among the earliest research efforts that perform large scale analysis on mobile app repositories .
by working onover1200samples theauthorsmanagedtopresentasystematic characterizationonexistingandroidmalware.accordingtothisresearch mobilemalwareauthorsbythenhadalreadystartedto applyobfuscationtobypassanti virusanalysis.besidesmalware thatharmsusers mobileapprepackagingthatharmstheinterestofdevelopershasalsodrawnattention.varioustoolsandsystemshave beendevelopedtodetectandanalyzeclonedmobileapplications withbothaccuracyandscalability .researchershave also worked on examining third party libraries used by mobile developers.
tools like libradar and libd were developed to detect third party libraries in android apps and classify them.
researchbychenatal.
detectslibrariespotentiallyharmfulto user security and privacy for both android and ios.
despite the progress in mobile app analysis most studies of this kindeitherignoredorspentverylimitedeffortinhandlingthepresence and influence of software obfuscation.
one of the few studies thatsystematicallyinvestigatedtheimpactofobfuscationonmobile developmentisfromlinares v squezetal.
whoresearchedhow obfuscationcanaffectthedetectionofandroidcodecloning .
similar to our work linares v squez et al.
spent extensive manual workinidentifyingobfuscatedcode buttheiranalysisonlycovered 120appsanddidnotconsiderobfuscationmethodsotherthanidentifier scrambling.
codematch is a similar project that focuses on obfuscation resilient android library detection .
xue et al.
proposed adaptive unpacking of android apps to recover dex code which can potentially enable obfuscation resilient clone or library detection.
conclusion in this work we empirically investigated the status of software obfuscation in the mobile software industry.
we collected a large set of obfuscated ios applications in the real world and performed indepth analysis on these samples.
with the information gathered in the study we revealed factors potentially affecting the deployment ofobfuscationtechniquesinmobileappsandtypicalobfuscation patternsadoptedbymobiledevelopers.webelievethatfindingsdevelopedinthisresearchwillshedlightonfutureresearchthataims to understand and improve the state of art of software protection.