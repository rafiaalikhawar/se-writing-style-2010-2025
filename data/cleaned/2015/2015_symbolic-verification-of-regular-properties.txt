symbolic verification of regular properties hengbiao yu1 zhenbang chen1 j iw a n g1 zhendong su3 wei dong1 1college of computer national university of defense technology changsha china 2statekeylaboratoryofhighperformancecomputing nationaluniversityofdefensetechnology changsha china 3department of computer science university of california davis usa hengbiaoyu zbchen wj nudt.edu.cn su cs.ucdavis.edu wdong nudt.edu.cn abstract verifying the regular properties of programs has been a significant challenge.
this paper tackles this challenge by presenting symbolic regularverification srv thatoffers significantspeedups overthe state of the art.srvisbasedondynamicsymbolicexecution dse and enabled by novel techniques for mitigating path explosion a regular property oriented path slicing algorithm and a synergisticcombinationofproperty orientedpathslicingandguiding.
slicing prunes redundant paths while guiding boosts the search for counterexamples.
we have implemented srv for java and evaluatediton15real worldopen sourcejavaprograms totaling259k lines of code .
our evaluation results demonstrate the effectiveness andefficiencyofsrv.comparedwiththestate of the art pure dse pureguiding andpurepathslicing srvachievesaverage speedups of more than .4x .6x and 7x respectively making symbolic regular property verification significantly more practical.
ccs concepts software and its engineering software verification and validation keywords regularproperty verification dynamicsymbolicexecution slicing guiding acm reference format hengbiao yu zhenbang chen ji wang zhendong su and wei dong.
.
symbolic verification of regular properties.
in icse icse 40th international conference on software engineering may june gothenburg sweden.
acm newyork ny usa 11pages.
.
.
introduction regular properties are ones that can be specified by finite state machines fsms .theyarewidelyusedforpropertyspecification insoftwareanalysisandverification e.g.
model basedtesting zhenbang chen and ji wang are the corresponding authors.
hengbiao yu and zhenbang chen contributed equally to this work.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
modelchecking andperformanceanalysis .however scalableregularpropertyverificationisdifficult andpracticalverificationofregularpropertiesofreal world programs is a significant software engineering research challenge.
two main lines of research exist on regular property verification staticanddynamic verification.
static verification such as soundlyabstractsprogramsforverification which usuallyhashighcodecoverage butsuffersfromfalsealarms.dynamic verification such as in contrast executes the program and monitors program executions online.
hence dynamic verification ensures completeness i.e.
every discovered violation is real.
however dynamic approaches only verify a program s behavior under specific inputs thus may miss bugs.
symbolicexecution achievestrade offsbetweenstatic and dynamic verification by using symbolic values for program execution.
a key step in symbolic execution is to explore all possible caseswhenencounteringabranchviaforkingstatesorre executing the program.
compared with static and dynamic approaches symbolic execution achieves better precision or coverage respectively.
ourgoalistodevelopapracticaltechniqueforsymbolicregular propertyverification.atthehigh level itworksasfollows.fora regular property and program p a nevent in s fsm represents theexecutionofoneormorestatementsof p.forexample amethod invocationmayproduceanevent.hence w.r.t.
anexecutionpath pofpgenerates anevent sequence denotedas seq p .i fseq p is empty pis anirrelevant path otherwise pisrelevant.
to verify thatpsatisfies we adopt symbolic execution to explore p s path space.
if there exists a path pthat violates i.e.
seq p is accepted by the fsmof denoted by fsm a violationis found and p is acounterexample path.
otherwise psatisfies .
however symbolicexecutionishinderedbytheproblemof path explosion exponentialpathspace w.r.t.thenumberofbranches in the program.
thus how to steer symbolic execution to completelyexplorethepathspaceand findcounterexamples assoon as possible is critical.
this paper tackles these challenges and introducesascalableverificationtechnique called symbolicregular verification srv forregularpropertiesviadynamicsymbolicexecution dse .
srv is inspired by two key observations.
first there usually exist a large number of irrelevant paths in p w.r.t.the regular property .
second many of the relevant paths inpare equivalent i.e.
the paths having identical event sequence w.r.t.
.
therefore during dse it is desirable to prune both irrelevantand equivalent relevant paths and explore counterexamplepathsasearlyaspossible.
verification to find counterexamples and finish path exploration more promptly.
toverifyaregularproperty foraprogram the keyideaofsrv isto sliceapath w.r.t.relatedstatementsof whichresultsin acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hengbiao yu zhenbang chen ji wang zhendong su and wei dong prunedpathsrelatedtotheslicedbranches and use toguide the selection of branches to explore for finding counterexample paths early.
the main technical novelty of srv is the design of a slicealgorithmandaverificationframework.thealgorithmisaregular property oriented slicing algorithm based on path slicing .
besides control and data dependencies our algorithm also exploits property relatedprograminformationtoperformslicing.thealgorithm can slice the branches along which no counterexample pathexists besides thebranchesalongwhicheachcounterexample path has an equivalent previously explored path can also be sliced.
the verification framework combines regular property oriented path slicing and the property oriented guiding technique i na synergisticmanner inwhichthecombinedtechniquescomplement and also boost each other.
we have implemented srv for java utilizing a regular property guidedsymbolicexecutionengine andadynamicslicingtool javaslicer .srvhasbeenextensivelyevaluatedon15real world open sourcejavaprogramsusingregularpropertiesinvolvingbothsingleormultipleobjects.theevaluationresultsdemonstratesrv s effectiveness and efficiency for regular property verification.
this paper makes the following main contributions aproperty orientedpathslicingalgorithmthatcanprunepaths forverification w.r.t.regularproperties.theexploredpathsusingourslicingalgorithmistwoordersofmagnitudelessthan that using path slicing .
amethodthatenhancesregularpropertyguideddse for supporting multi object regular properties.
a dse based framework that integrates slicing and guiding for practical regular property verification.
aprototypeimplementationforjavathatsignificantlyoutperformsthestate of the art successfullyverified outof39 verification tasks on a total of 259k lines of code within hour whilepuredse guiding andpathslicingverified22 23tasks respectively and on the successfully verified tasks offered more than .4x .6x 7x average speedups over pure dse guiding and path slicing respectively.
therestofthispaperisorganizedasfollows.section2motivates and illustrates symbolic regular verification srv via a concrete example andsection3presentsthedetailsofsrv.section4explains ourimplementationandempiricalevaluationofsrv.finally we survey related work section and conclude section .
illustrating example this section uses an example to motivate and illustrate our symbolicregularpropertyverificationtechnique.figure1showsajava program snippet that uses an iterator to access an arraylist .
theinputparametersarean arraylist arr andanintegervariable m. first we increase mb y1i fmis greater than .
then we obtain arr s iterator and assign it to iter.
the following forloop lines finds the maximum value of the first half of arr and stores it inmax.
next maxwill be removed from arrif its value equals .
the following whileloop lines iterates arrby using the iterator iter.duringtheiteration weupdatethevalueof maxto thevalueofanelementiftheelementisbiggerthan max.finally the addition of mandmaxis returned.1public int test arraylist integer arr int m if m q0 m q0 int max q0 iterator iter arr.iterator q1 q4 for int i i arr.size i q1 q4 if arr.get i .intvalue max q1 q4 max arr.get i .intvalue q1 q4 q1 q4 if max q1 q4 arr.remove max q3 q4 while iter.hasnext q1 q3 q4 int temp iter.next q3 q4 if temp max q3 q4 max temp q3 q4 q4 return m max q4 figure an example program.
for the motivation program we are interested in the correct usageofacollection s iterator i.e.
thecollectioncannotbemodified while being iterated and the iterator should invoke method hasnextbeforenext.
note that such a safety property involves two objects.the property can be specified as a regular property and fsm is shown in figure where aandirepresent an arraylist object and the corresponding iterator object respectively.
for brevity we use a.updateto represent adding an element toaorremovinganelementfrom a.eventa.iteratordenotesthe accessingof a siterator.weuse i.hasnextandi.nexttorepresent invoking the method hasnextandnext respectively.
obviously when the first half of arraylist has an element that equals a violationof occurs i.e.
the arraylist removesanelementwhile being iterated.
in this paper we assume that every event is atomic i.e.
no other events may be generated during its execution.
q0 start q1 q2 q3 q4a.iteratora.update i.hasnext a.update i.nexti.hasnext a.updatei.next i.hasnext a.updatei.next i.hasnext i.next a.update figure the fsm of iterator bug involving multi objects.
when using pure dse to verify the program w.r.t.
it requires many iterations to unfold the two loops.
in addition the branch at line2 doublesthehugepath space.symbolicregularverification srv aims to finish the path exploration and find counterexample pathsassoonaspossible.fortheexampleprogramandtheproperty srv needsonly twoiterations tofinishthepathexploration and finds the first counterexample path in the second iteration.
srv procedure consists of two stages.
at the first stage the program is statically analyzed w.r.t.fsm through a backward authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symbolic verification of regular properties icse may june gothenburg sweden data flow analysis to calculate the future behavior information calledpostset of every program location.
a postsetof a location loccontains some states of fsm and each state qindicates that there mayexist a subsequent path pafterlocandseq p can drive fsm fromqto an accepted state.
the comment of each line in figure shows the postsetof the location afterthe line.
for brevity we use qj qk to represent ql j l k .
for example after line there exists a subsequent path pthat seq p angbracketleftupdate hasnext next angbracketright whichcandrive q1totheaccepted state.
hence the postsetof the location after line contains q1.
at the second stage the program will be analyzed via dse.
duringdse the postsetinformationcalculatedearlierwillbeusedto select the paths to explore.
because dse also runs the programconcretely we can use the available runtime information to calculatecertainhistoryinformation called preset ofabranchtobe explored.
same as postset thepresetof a branch balso contains some states of fsm .
a stateqinpresetindicates that qcan be reached from the initial state via the path from the beginning of the program to b. based on the historyandfutureinformation we can prune the redundant program paths which include irrelevantpaths non counterexamplepathsandtheequivalentpaths ofpreviouslyexploredpaths and evaluatethepossibilityofa branch for generating a counterexample path.
whenapath pisexploredbydse property orientedpathslicing is employed on pto slice the branches w.r.t.
.
slicing uses static dependence analysis and the historyandfutureinformation to reasonaboutpossiblyacceptedeventsequencesalongabranch.ifa branchb s intersection of the presetandpostsetis empty it means nocounterexamplepathalong bexists.besides ifallthecounterexample paths along bhave equivalent pathsexplored previously it is also no need to explore b. under both of these conditions bwill bepruned whichresultsinpruningallthepathsalong b.onthe otherhand wealsousetheintersectionofthe presetandpostsetto calculate the heuristic value of b. if the size of the intersection is larger thepossibilityofhavingacounterexamplepathalong bis considered higher.
hence bwill be selected with a higher priority.
considertheprograminfigure1andthefsm infigure2.to analyzetheprogramviadse thetwoinputparametersaremade symbolic variables.
we assume that the arraylist arr has a fixed lengthandcontainstwoelements arr andarr .supposetheinitialinputto testis angbracketleftarr m angbracketright.thefirstiterationgenerates theeventsequence angbracketleftiterator hasnext next hasnext next hasnext angbracketright and is not a counterexample path.
figure shows the execution treeafter the first iteration where dashedstates are candidate states toexplore.the presetandpostsetofacandidatebranchareabove and below the branch respectively.
for example b3corresponds to the true branch of line and b3 spresetandpostsetare q1 and q1 q2 q3 q4 respectively.
the prunedcandidate branches aredashedandgrey while the remaining are dottedandblack.
theslicingofthefirstpathprunesbranches b1 b4 andb5 which means the paths along these pruned branches are redundant for verification.branch b1canbeprunedaccordingtopathslicing .
the reason is that there is no events transitively data or control dependon m whichmeanschangingthevalueof mcannotgenerate new event sequences.
on the other hand the reason for prun ingb 4andb5is the intersection of presetandpostsetis empty s0 s1 s3 s5 s7 s9s2 s4 s6 s8 s10pre q0 pre q1 pre q1 pre q1 pre q1 post q0 post q1 q4 post q1 q4 post q3 q4 post q3 q4 m arr arr nequal100 arr arr arr arr b1 b2 b3 b4 b5 figure execution tree after the first iteration.
whichimpliesnocounterexamplepathsalongthesebranchesexist.
both of b2andb3have the same result of intersecting preset andpostset.
in this situation srv will select the deeper branch i.e.
b3 to explore.
the path condition for generating the next input ism arr arr .
through solving the new path condition we assume that the generated input is angbracketleftarr m angbracketright.theseconditerationgeneratesanaccepted eventsequence angbracketleftiterator update hasnext next angbracketright.thus thepathis a counterexample path.
s0 s1 s3 s5 s7 s9s4 s6pre q1 pre q1 pre q1 post q1 q4 m arr arr nequal100 arr arr arr arr arr 100b2 figure execution tree after the second iteration.
figure shows the execution tree after the second iteration.
for brevity weomittheprunedcandidatebranchesandstatesgenerated in the first iteration.
note that the second path terminates in theaccepted state s6 because a runtime property violation happens.
forbranch b2 withthehelpofour property orientedslicing method we can infer that all possible event sequences along b2accepted by fsm areequivalenttotheoneexploredintheseconditeration i.e.
angbracketleftiterator update hasnext next angbracketright.
hence b2can be pruned.
in total srv needs two iterations to explore the full path space andfindsthecounterexamplepathintheseconditerationregardless ofarr s size.
if we use depth first search dfs or breadth first search bfs the exploration will get stuck due to unfolding thetwo loops failing to quickly find the counterexample path.
if we usepurepathslicing onlybranch b1canbepruned andthe exploration will also get stuck due to the two loops.
if we use pure regular property guiding it will find the counterexample path during the second iteration but no path pruning happens hence it fails to complete the path exploration.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hengbiao yu zhenbang chen ji wang zhendong su and wei dong srv symbolic regular verification thissectionpresentsthetechnicaldetailsofsrv.itfirstpresents theoverallsynergicverificationframework thenthetwocombined techniques and finally discusses srv.
.
synergic verification framework srv skeyinsightistouseslicing w.r.t.
topruneredundantprogrampaths andtheguidingmethodin tofindcounterexamples earlier.
more precisely in addition to the synergy between slicing and guiding srv s property oriented slicing method can prune additional paths through exploiting the guiding information i.e.
presetandpostset compared with path slicing and srv enhancestheguidingmethod withthesupportofmulti object regularproperties.srvaimsfor fullverification whichmeansexploringtheprogram swholepathspacetosuccessfullyverifythe program or find all inequivalent violations of the property.
algorithm dse based regular property verification srv p m i0 data programp fsmm and an initial input i0 1begin 2worklist x pc true i i0 postset computefutureinfo p m 4whiletruedo pc pathc preset runandmonitor i m ifaccept m seq pathc then x x lseq pathc report a counterexample path rs slice p pathc m preset postset update worklist rs pc ifworklist timeoutthen exit pc select worklist preset postset i solve pc algorithm1showstheoverallframework ofsrv.theinputto srvconsistsofaprogram p anfsm m forthenegationofthe regular property to be verified and an initial input i0top.
the algorithm first computes the postsetinformation of pw.r.t.
m line3 cf.section3.
thatwillbeusedbyslicingandguidinglater.
itusesaworklisttostorethebranchestobeexploredand xtostore the accepted event sequences.
during each iteration the algorithm runspandchecksthepropertyonthefly line5 cf.section3.
.besidesthepathcondition pc thecurrentpath pathcisalsocollected along with dse.
at the same time the presetinformation is also calculatedforeachbranchalong pathcw.r.t.m cf.section3.
.
ifpathcis a counterexample path line we add lseq pathc i.e.
the generated event sequence with program location information to xand report pathc.
once a path is terminated the property orientedpathslicingalgorithm slice cf.algorithm2 is invoked to prune branches along the path line .
then updateis invoked to save new branches to worklist and prune the branches inworklistaccording to the slicing result.
based on the heuristic value of each branch cf.section .
selectselects a branch to generate the path condition for the next iteration line .
theinputsofthenextiterationcanbegeneratedbyinvokingabackend smtsolver line14 .thealgorithmrepeatsthisprocessuntilthe worklist becomes empty or timeout lines .
.
statically compute future information for slicing and guiding we calculate the postsetfor each static programlocation.weimprovethe postsetcalculationmethodin in twodimensions extendingtheflowfunctionsinifdstosupport multi object regular properties and enhancing the data facts and flow functions in ifds to record encountered event sequences foraprogramlocation.foreachlocation l thepostsetcontainstwo typesofinformation fromwhichstatestherestprogramafter lcandrive m toanacceptedstate and thegeneratedevent sequences after lthat can drive a state to an accepted state.
more precisely we first construct the reversed fsm denoted by m o fm which accepts the reversed ones of m s accepted paths.
for example figure shows m of the fsm in figure and m accepts angbracketlefti.next a.iterator angbracketrightthat is the reverse of angbracketlefta.iterator i.next angbracketrightaccepted by the fsm in figure .
observe that one state of m may correspond to a set of states of m .
for example figure s fsm has a state q1 q3 q4 to which there existsatransitionfromstate q4 .thetransitionmeansthereexists a transition from state q1to stateq4in the fsm in figure .
q4 start q1 q3 q4 q1 q4 q3 q4 q0 i.nexta.update i.hasnext a.update i.next i.hasnexta.iteratora.update i.hasnext i.next a.iteratori.next i.hasnexta.update figure the reversed fsm of iterator bug.
to calculate the postset we update the data facts during exploringtheprogramstatementsaccordingtothetransitionsin m and merge the data facts at merging points in the control flow graph.
taketheprograminfigure1forexample andthereexistsadata fact o1 o2 q3 q4 before exploring the statement at line whereo1ando2correspondtothe arraylist objectand iterator object respectively.
according to the transitions in figure the datafactbecomes o1 o2 q1 q4 afterexploring o1.remove.actually thedatafact o1 o2 q3 q4 alsoexploresthefalsebranch that has no effect on the fact because no events can be encountered in the branch.
hence there exist two data facts at line through merging the data facts from the true and false branches i.e.
o1 o2 q1 q4 and o1 o2 q3 q4 .
to make the postsetanalysis inter procedural we carry out a dataflowanalysisontheprogram sinter proceduralcontrolflow authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symbolic verification of regular properties icse may june gothenburg sweden graph icfg w.r.t.
m .
the data flow analysis is implemented by employing the ifds framework .
for a multi object property involving kobjects a data flow fact in ifds is an element ta qr b s in the domain uniontext.
n kon s b e denoted by d whereois the set of the identities of staticobjects i.e.
thestaticlocationsofobjectcreations sis the state set of the reversedfsm m of bis the set of the basic blocks in the program and eis the set of event sequences.
forexample adatafact o1 o2 q b s ofaprogramlocation l means that from state qthe program after lcan drive m to anacceptedstate theeventsequence scanbegeneratedby o1 ando2afterl and3 scandrive m toanacceptedstatefrom q. the relationship between an event and its corresponding object can be obtained through checking whether the class or interface of the event corresponds to the type of the object.
for example thereexistsadatafact o1 o2 q1 q4 b angbracketleftupdate hasnext next angbracketright inthepostsetofline10intheexampleprograminfigure1 where o1ando2represent the identity of the arraylist anditerator objects and bisthecorrespondingbasicblockofline10.obviously angbracketleftupdate hasnext next angbracketrightcan drive state q1to the accepted state of the fsm in figure and updateis related to the arraylist object whilehasnextandnextare related to the iterator object.
two different typed static objects o1ando2arerelatedif their types are specified by .
take the motivation program for example aniterator object is related with an arraylist object according tothepropertyspecificationinfigure2.withoutlossofgenerality we assume specifies two objects for brevity.
there are four kinds offlowfunctionsin ifds call to start exit to return call to return andnormalfunctions.
the normal and exit to return functions do not have any influence on calculating postset and both of them areidentityfunctions.ifamethodinvocationstatementdoesnot produceanyevent itscall to startfunctionistheidentityfunction otherwise itisa killallfunction thatkillsallthedatafacts.the call to return functionfcr d dis the main one that drives the calculation of postset.
for a method invocation statement obj.meth ... if the statement does not produce an event its fcris the identity function.
otherwise supposetheidentitysetof objisos theproducedevent ise1that can make the transition from q1toq2in m and the block of the statement is bn thenfcris the smallest function satisfying the following conditions where s1 s2represents the concatenation of sequences s1ands2 for each d domain fcr anddis o1 q1 b s ifo1 nelementos and no element in osis related to o1 thend ran e fcr ifo1 os then o1 q2 bn angbracketlefte1 angbracketright s ran e fcr if there existso2 os ando2isrelatedto o1 then o1 o2 q2 bn angbracketlefte1 angbracketright s ran e fcr and also d ran e fcr .
on the other hand ifdis o1 o2 q1 b s and o1 o2 osis not empty then o1 o2 q2 bn angbracketlefte1 angbracketright s ran e fcr .
all possible cases of related objects are considered.
iftheinitialstateof m canmakeatransitionto qeviae1 then for eacho os we have o qe bn angbracketlefte1 angbracketright ran e fcr .
ifobjpoints to multiple static objects i.e.
os then we havedomain fcr range fcr .
we adopt weak update t o achieve an over approximation.when calculating the fixed point in ifds the first three parts ta q b of a data fact constitute the keythat identifies the data fact.hence consideringthenumbersofstates staticobjects and basicblocksarefinite theterminationofifdsisguaranteed.given astaticlocation theremayexistsmultipledatafactswithasame key and these facts have different event sequences.
each of the sequences is a possibly produced event sequence after the location.
forexample infigure1 the postsetbelowline10containsfour data facts with a same key o1 o2 q1 q4 b but having the followingfoureventsequences angbracketleftu h n angbracketright angbracketleftu h n h angbracketright angbracketleftu h n h n angbracketright angbracketleftu h n h n h angbracketright where u handndenoteupdate hasnextand next respectively o1ando2aretheidentitiesofthe arraylist and iterator objects and bis the basic block of line .
forthefutureinformationofabranch br denotedby postset br whoselocationis l itssoundnessmeansthatthe postsetoflincludes thedata factsofall thepossiblecasesthat canreach anaccepted state after executing the remaining program after l. the following theorem gives a sufficient condition that makes postsetsound.
theorem .
.
given a program pand a regular property i f is only parametric with objects and the related objects of when runningpare not data dependent on the inputs postset is sound.
proof.postsetis computed by ifds framework and the flow functions result in an over approximation when the event information is computed soundly.
if there are some events of the property inwhichtherequirementsofvaluesexist e.g.
thereturnvalueofa method invocation must be true it is beyond the capability of our staticdataflowanalysis.becausetheproperty isonlyparametric with objects and we use pointer to analysis to get the information ofstaticobjects theeventinformationcomputedbyourstaticanalysis is static object sensitive.
furthermore the related objects of whenrunning pdonotdependontheinputs.hence wecanobtain sound results of computing events and thus postsetis sound.
square .
compute history information different from postset presetis calculateddynamically.
the preset of a location contains the states that are reached via the execution from the program entry to the location.
similar to the guidingmethod we adopt runtime verification to calculate the presetinformation.notethatweenhancethecalculationmethod to support multi object properties.
aruntimeobjectisa sensitiveobject ifthecorrespondingclass orinterfaceisspecifiedbytheproperty e.g.
thesensitiveobjects ofthepropertygivenbyfigure2includethe arraylist objectand theiterator object.wecreateamonitortomonitorthemethod invocations ofevery sensitive object andrecord the currentstate of each monitored object.
note that for a multi object property the monitors of related objects will be merged according to the property specification.
presetis a set of monitors.
formally we use is q torepresentamonitor where isisasetofobjectidentities andqis a state of the fsm m .
if any object s method invocation results in an event of m the monitor performs a state transition w.r.t.
m to compute preset which we formalize as is q1 o.e1 is q2 whereo is andstate q1 m istransitedtostate q2byevente1 generated by the method invocation on the object identified by o. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hengbiao yu zhenbang chen ji wang zhendong su and wei dong foramulti objectproperty amonitor ssensitiveobjectsarenot created simultaneously.
suppose sensitive object oproduces event e1 i fois related to the objects in isw.r.t.the property ando nelementis following rule is used where e1makes a transition from q1toq2 is q1 o.e1 is o q2 taketheseconditerationofthemotivationprogram cf.figure forexample andsuppose o1ando2representtheidentitiesofthe arraylist anditerator objects respectively.obviously theencountered event sequence at line is angbracketlefto1.iterator o1.remove angbracketright.a s a result according to the fsm in figure the presetof location line is o1 o2 q3 .
for a given branch br the soundness of history information means that presetcontains all the reached states from the initial state via the path from the beginning of the program to branch b. theorem .
.
givenaprogram pandaregularproperty ifthe sensitiveobjectsof parenotdata dependentontheinputs presetis sound.
proof.recall that we compute the history information along with dse and presetis calculated as the reached state set of the otherbranchof br denotedby br executedinthecurrentpath.
supposethecorrespondingeventsequenceto bris angbracketleft angbracketrightor angbracketlefte0 ... ei angbracketright wherei .
because the sensitive objects do not depend on the inputs the event sequence of bris the same as that of br.
hence presetofbrcontainsthe same reachedstatesof br which implies the soundness of preset.
square astaticobjectisidentifiedbyitscreationlocation.werelatea runtimeobjectwithastaticobjectbytheircreationlocations.given thepresetandpostsetof a branch br thereintersection denoted by preset br intersectionsqpostset br isdefinedasfollows where st is represents thesetofthecreationlocationsoftheobjectsidentifiedby is s ta denotesthesetofallelementsintuple ta andm x1 x2 denotes x1 x2 x2 x1.
q is q preset ta qr b s postset m st is s ta q qr take the candidate branch b3in the first iteration of the motivationprogram cf.figure3 forexample.thereexistsadatafact i.e.
o1 o2 q1 q4 b angbracketleftu h n angbracketright in thepostsetbelow line where o1ando2correspond to the identities of the static arraylist and iterator objects respectively.thecomputed presetatline10is o prime o prime q1 whereo prime 1ando prime 2representthe arraylist objectand iterator object respectively.
clearly the set of the creation locations ofo prime 1ando prime 2is equal to o1 o2 .
besides since q1 q1 q4 we haveq1in the intersection of presetandpostset.
.
regular property oriented path slicing we now describe the algorithm for regular property oriented path slicing which is based on path slicing .
specifically our slicing algorithm enhances path slicing through exploiting the guiding information i.e.
presetandpostset to prune additional branches.
before elaborating the slicing algorithm we first give the definition of the equivalence relation of event sequences.
an fsm mis a triple q q0 f where istheeventalphabet qisthestate set q0istheinitialstate q qisthetransitionfunction andfisthesetofacceptedstates.aneventsequence s angbracketlefte1 ... en angbracketright n is accepted by mif for each ei where i n there existsqi qsuch that qi ei qi andqn f.w eu s er s to denote the event sequence after removing any event ekinsthat makes a self circled transition i.e.
qk ek qk andqk 1is equal toqk.
definition3.
.
givenanfsm mandtwoacceptedeventsequence s1ands2ofm s1ands2areequivalent denoted by s1 ms2 i ff r s1 r s2 .
for example the sequences angbracketleftiterator update hasnext next angbracketrightand angbracketleftiterator update hasnext next hasnext angbracketrightare equivalent w.r.t.the fsm in figure .
algorithm regular property oriented path slicing slice p pathc m preset postset data programp a pathpathc and fsm m 1begin 2i tail l pathc s 3whilei nequalnulldo ifi is a branch instruction then ifpreset i intersectionsqpostset i nequal then t concatenate i if s1 t s2 x s2 ml s1 then ifanye seq pathc depends on i i can reach any new event then s s i else ifanye seq pathc depends on i then s s i i before i 15returns algorithm gives our regular property oriented path slicing.
theinputtothe algorithmconsistsoftheprogram punderverification the current path pathc and the fsm m corresponding to thenegationoftheregularpropertytobeverified.thealgorithm processestheinstructionsin pathcinabackwardmanner where l pathc denotes the instruction list of pathc.
finally all the remaininginstructionsarestoredin sandreturned.thebranches not insare pruned.
forabranchinstruction iinl pathc weuse itorepresent i s branchnotexploredin pathc.todecidewhether icanbepruned we exploit presetandpostsetin two ways.
first considering that bothpreset i andpostset i aresound theemptinessoftheirintersectionimpliesthatthereexistsnopathalong ithatcanviolate theproperty.hence wecanslicebranch iifpreset i intersectionsqpostset i is empty lines .
second we also prune branch iif all possible accepted event sequences of ihave an equivalent accepted event sequence explored before lines .
the concatenate operationconcatenatestheeventsequencebefore i recordedduring running andthepossibleeventsequencesafter i calculatedin postset and produces an acceptedevent sequence set t.i fe v e r y sequence in thas an equivalent sequence in x cf.algorithm whichmeansthatallthepossibleacceptedeventsequencesalong i havebeenexploredinanequivalentmanner icanbesliced.wealso use the criteria in path slicing to further slice the instructions authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symbolic verification of regular properties icse may june gothenburg sweden thatcannotaltertheeventsequenceofthecurrentpath pathc i.e.
a branch instruction ican be sliced if there is no event in seq pathc transitivelydata orcontrol dependsonitandnoneweventcan be reached along the direction of i lines similar rules also apply to the remaining types of instructions lines .
path slicing also slices a program execution path in a backward manner.
more precisely it keeps track of a set of variables calledlive set that determines the feasibility of the suffix of the path seventsequenceandthelatestremainedinstruction called step location .
a branch instruction iwill be remained if one of the following three conditions is satisfied.
ican bypass the step location and thereexistsapathinthedirectionof ithat can modify the sensitive variables in live set and there exists apathinthedirectionof ithatcanreachanewevent.actually thefirsttwoconditionscorrespondtotransitivedataandcontrol dependence respectively.
on the other hand a normal instruction will be remained if it can modify the variables in live set.
concatenation.
the insight of concatenation isto infer the possibleacceptedeventsequencesofabranch brbasedon preset br andpostset br .
for an element ta qr b s inpostset br w eu s e aes br q to represent the set of statically calculated event sequencesthatcandrive qtoanacceptedstate whichcanbederived frompostsetas follows where dcis the set of calculated data facts during data flow analysis and dc d. aes br q si ta qr b si dc q qr then we define concatenate br as the following set s1 s2 q preset br intersectionsqpostset br s2 aes br q wheres1istheeventsequencebefore br.anaturalwaytoobtain theacceptedevent sequencesalong bristoconcatenate theevent sequenceproducedbefore brandtheeventsequencesin aes br q .
in principle to ensure the soundness of slicing both s1and aes br q need to be context and flow sensitive .
in practice aes br q is flow sensitive but not context sensitive.
we check the equivalence relation w.r.t.alocation sensitive variant of m denoted by ml .
the intuition is that the reasons of the bugs causedbythesamestatementunderdifferentcontextstendtobe thesame.
ml canbecomputedaccordingtotheprogram pintwo steps.first wecollectallpossiblestaticlocationsforeveryevent by an inter procedural control flow analysis.
second we replace every transition with the transitions of location sensitive events.
intheillustrationexample aftertheseconditeration cf.figure4 theacceptedsequence angbracketleftiterator update11 hasnext next13 angbracketrightisadded tox.ml is the fsm after replace the event of each transition in figure2bytheeventwithlocationinformation.then accordingto thepresetandpostsetofb2 preset b2 intersectionsqpostset b2 only contains q1.
based on the example in section .
aes b2 q1 has four event sequences.
besides the sequence before b2is angbracketleftiterator angbracketright.
hence concatenate b2 containsfouracceptedeventsequences eachof which is equivalent to angbracketleftiterator update11 hasnext next13 angbracketrightw.r.t.
ml .
therefore b2is pruned.
.
branch selection for a regular property only the relevant paths with specific event sequences can violate .
it is desirable to evaluate a branch s probability of generating the accepted paths w.r.t.m .
then afterslicing thebranchwithahigherprobabilitywillbeselectedfirst in order to find counter example paths earlier.
same as the regular property guided dse we usethe size of preset intersectionsqpostsetas the main heuristic value forevaluating a branch.
when two branches havethesamesizeof preset intersectionsqpostset thedeeperonewillbeselected for efficient exploration.
.
discussions in principle slicing and guiding are the orthogonal techniques that are synergistically combinedin srv.
slicing prunes irrelevant and equivalentrelevantpathsduringdse whileguidingboostsfinding counterexamplepaths.bothareimportantforboostingverification.
since slicing is used when a path is completed the effectiveness of slicing is related to how fast completed paths are generated.
for example ifthereexistveryshortpathsinaprogram bfsmaybeagoodchoice.ontheotherhand guidingisinsensitivetothesearch strategy.
without any knowledge of the shape of the path space we integrate these two techniques with the dfs strategy.
inadditiontotheircompatibility slicingcanboosttheefficiency of property guiding.
finding accepted paths may be hindered byexploring relevant paths due to the imprecision of the guidingmethod.
with the help of slicing after one path is explored theequivalent ones of the path can be pruned.
therefore compared with pure guiding srv tends to find counterexamples faster.
since slicing performs static analysis its overhead may be high e.g.
whenthepathislongandthecontrolflowgraphiscomplex.to improve the performance we perform slicing selectively based on thehistoryresultsofslicing.theintuitionisthelocalityofprogram paths i.e.
ifabranchcannotbepruned ittendsnottobepruned either along the nearby paths.
if the branch of any constraint in the current path is pruned at last time or first encountered slicing would be carried out.
with the help of such a lightweight dynamic prediction we can reduce the effort of slicing achieving a good balance between path pruning and slicing overhead.
theorems3.
.2givesufficientconditionsforthesoundness ofpresetandpostset respectively.
even though there still exist a largenumberofpropertiesandprogramssatisfyingsuchconditions e.g.
the ones used in our experiment.
however considering our approach for computing the event sequences in postsetis not context sensitive srv is not sound i.e.
srv may miss bugs resulting from different contexts but having same static location.
we believe srvispractical becausetherootcausesforthebugsofthesame statement under different contexts tend to be the same.
implementation and evaluation wehaverealizedaprototypeofsrvbasedonaregularproperty guided dse tool which is implemented on the dse engine jpf jdart and wala static analysis platform.
we have developed aproperty oriented path slicerfor java bytecodebasedon javaslicer i.e.
a dynamic slicing tool.
we evaluate srv along two dimensions effectivenessandefficiencyofsrv .cansrveffectivelyverifyregularpropertiesforreal worldjavaprograms?howefficientissrvcomparedwithdfs pureguidingandpureslicing?
synergybetweenslicingandguiding .canslicingboostguiding in finding counterexample paths?
how significant is the improvement?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hengbiao yu zhenbang chen ji wang zhendong su and wei dong .
evaluation setup table lists the programs in our evaluation which are all realworldopen sourcejavaprograms totaling259klinesofcode loc .
rhino a andsoot ccomefromtheashesbenchmark1suite.
jlex is a java lexical analyzer.
bloatis from the dacapo benchmark suite .bmpdecoder is a decoder for bmp files.
ftpclient is an ftp client.
the six programs pobs jpat jericho nano xml htmlparser and xml are parser programs.
the remaining i.e.
fastjason jepandudl are library programs.
table programs in the experiments program locbrief description rohino a 19799javascript interpreter soot c 32358static analysis editor jlex 4400lexical analyzer bloat 45357java bytecode optimization bmpdecoder 531bmp file decoder ftpclient 2436ftp client in java pobs 5488java parser objects jpat 3254java string parser jericho 25657jericho html parser nano xml 3317non validating xml parser htmlparser 21830html parser in java xml 5138xml parser in java fastjson 20223json library from alibaba jep 42868mathematics library udl 26896udl language library total open source programs as table shows we applied srv to verify widely used regular properties includingbothsingle andmulti objectones.properties withsuperscript aremulti objectones theremainingaresingle object properties.
in addition we also verify some user defined properties.forexample thepropertywedefinedfor htmlparser requiresthattheinputstringisinthejspformat i.e.
... .
table regular properties in the experiments property meaning enumeration call hasmoreelements before nextelement iteratorcall hasnext before next do not update the collection while iterating readerdo not read a closed stream no read if dependent input stream closed writerdo not write a closed stream no write if dependent output stream closed socket do not use a closed socket sincemostoftheprogramsareviolationfree tofurtherevaluate our method wemutate the programs.first we collect allthe branchstatementsalongdse thenwerandomlyselectabranchto automaticallyinjectanevent e.g.
acloseoperationforthe reader property.
we generate three mutants for each program except for those with user definedproperties.
note that such injections may not necessarily lead to real violations.
an evaluation task comprises a program and a property.
a task wasruninfourmodes dfs d pureguiding g purepathslicing s and srv s prime .
under each mode the time limit is hour.
all the experiments are carried out on the identical servers each of which has 256gb ram and four .13ghz xeon cpus with cores.
evaluation results table lists evaluation results.
the first column gives the verification tasks including the names of the programs and the verified properties where a multi object property has a superscript .
the secondcolumn typeindicateswhetherananalyzedprogramhas been mutated or not with orepresents the original program and bugitheithmutant.thecolumn totaltime s liststimeconsumed for each verification task in four modes where to represents timeout.
in our evaluation completing a verification means having exploredallthepathspace.thetimeforfindingthefirstcounterexample is shown in the column first violation time s where no meansnocounterexamplepathandnarepresentsunknowndueto timeout.
table shows that srv completes tasks in while dfs d pure guiding g and pure slicing s complete and tasks respectively.comparedwiththesealternatives srvachieves and improvement respectively.
for the successfully verified tasks srv at least has an average .4x .6x and 7x speedupsoverdfs pureguidingandpureslicing respectively.2we inspected the programs that srv fails to verify i.e.
jlex rhino a htmlparser andudl andfoundthatthoseprogramshavecomplex andsensitivecontrolflow.mostpathsofthoseprogramsarerelevant andonlyafewpathsarecounterexamplepaths.asaresult the overhead of static analysis used in slicing and guiding becomes very high and only a small part of path space can be pruned.
6001020304050d g s s figure completed tasks under a time threshold.
figure shows the relationship between the number of completed verification tasks and the time threshold.
the x axis varies the time threshold from five minutes to one hour while the y axis is the number of completed verification tasks.
srv can complete the most tasks under a given time threshold.
in addition all the completed30tasksbysrvarecompletedwithin5minutes demonstrating srv s efficiency.
to show the effectiveness of property guiding we also collect the time for finding the first counterexample path.
for the tasks in which violations exist pure guiding is the most efficient to find the firstviolation.duetotheoverheadofslicing srvisslowerthan pureguidinginmosttasks buthasthesameorderofmagnitude intime.bothsrvandpureguidingachieveordersofmagnitude 2a timeout is counted as hour.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symbolic verification of regular properties icse may june gothenburg sweden table experiment results of analysis time d dfs g pure guiding s pure path slicing s prime srv program property typetotal time s first violation time s d g s s primed g s s prime soot c writer o28.
.
.
.
no no no no bug1 .
.
.
.
.
.
.
.
bug2 .
.
.
.
.
.
.
.
bug3 .
.
.
.
.
.
.
.
soot c writer o27.
.
.
.
no no no no bug4 .
.
.
.
no no no no bug5 .
.
.
.
.
.
.
.
bug6 .
.
.
no no no no bloat iterator o24.
.
.
.
.
.
.
.
bloat iterator o27.
.
.
.
no no no no bug1 .
.
.
.
no no no no bug2 .
.
.
.
.
.
.
.
bug3 .
.
.
.
.
.
.
.
bmpdecoder reader o8.
.
.
.
no no no no bug1 .
.
.
.
no no no no bug2 .
.
.
.
.
.
.
bug3 .
.
.
.
no no no no ftpclient socket o12.
.
.
.
no no no no bug1 .
.
.
.
.
.
.
.
bug2 .
.
.
.
.
.
.
.
bug3 .
.
.
.
no no no no jlex reader oto to to29.
na na na no bug1 to to to to12.
.
.
.
bug2 to to to to na .
na27.
bug3 to to to to na na na na jlex reader oto to to29.
na na na no bug4 to to to to na .
na52.
bug5 to to to to217.
.
na109.
bug6 to to to to51.
.
na na rhino a enumeration oto to to to na na na na jpat userdefined oto to to46.
na .
na43.
nano xml userdefined oto to to19.
na .
na19.
pobs userdefined oto to21.
.
na .
.
.
jericho userdefined oto to .
.
na .
.
.
fastjason userdefined oto to to102.
na na na102.
jep userdefined o2590.
.
to167.
.
.
na167.
htmlparser userdefined oto to to to27.
.
na106.
udl userdefined oto to to to na2829.
na na xmlparser userdefined oto to to24.
na .
na24.
speedupsoverdfsandpurepathslicinginfindingthefirstcounterexamples.whenaviolationisverydeepandtherepossiblyexist a large number of relevant paths it cannot be detected without slicing.
for example for fastjason pure guiding fails to detect aviolationwithinonehour whilesrvneedsonly102.6seconds.
withinonehour guidingandsrvcanfindacounterexamplefor 23and22programsrespectively whiledfsandpurepathslicing can only find and indicating the effectiveness and efficiency of guiding.
pruningbrancheswithpositiveheuristicvaluescanboostfinding counterexamples.
for the tasks with counterexamples found slicing can boost guiding by reducing the number of iterations forfindingthefirstcounterexamplein7 tasks.notably for fastjason srv needs only iterations but all the other modes failtodetectaviolationafterthousandsofiterations.toinspecttheboosting of slicing to guiding further we collect the information of the pruned branches with positive heuristic values.
figure7showstheimprovementbysynthesizingtheresultsof allthetasks wherethe x axisisthepathorderforthefirst2000 paths and the y axis is the number of the pruned branches with a positiveheuristic valueforguiding.
asshownin thefigure much oftheboostinghappensduringtheearlystage i.e.
inthefirst1500 paths which indicates the necessity of selective slicing.
in addition we collect the information about iterations and the resultsshowthatsrvusesthefewestiterationstocompletepath exploration.
specifically the iterations using our slicing algorithm is two orders of magnitude less than that using path slicing .
furthermore weadjustthetimethresholdto24hoursforthefailed tasks and found that all the tasks were still failed to be verified except that program jepcan be verified in pure slicing mode.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden hengbiao yu zhenbang chen ji wang zhendong su and wei dong 2000number of pruned branches path order figure branch pruning of each path.
threats to validity.
threats to the validity of our results are mainlyexternal.theprogramsarerepresentativebecause the programs are of various types such as parser and network manipulation the programs are of different sizes i.e.
from .5k to 45k loc and 259k in total and they are commonly used for evaluating java program analyses .
furthermore the verified regular properties are mainly common contracts o f java programs.
user defined properties have practical meanings w.r.t.functionalities.
although srv is implemented and evaluated forjava itisgeneralandcanbeappliedtoprogramsinotherlanguages such as c and c .
finally we set the time threshold to be 1hour whichisfairlyenoughforaverificationtask.increasingthe timethresholdto24hoursonlyresultsinonemorecompletedtask.
related work theclosestrelatedworktosrvisregularpropertyguideddse and woodpecker .
different from the objective of i.e.
finding an accepted path as soon as possible srv aims to quickly completethe pathexplorationof theprogram byemployingslic ing to prune redundant paths and the slicing can also reducethe iterations for finding counterexample paths.
compared with woodpecker which uses path slicing to prune redundant paths for verifying system rules via symbolic execution as demonstratedbytheevaluationresults cf.section4.
srvismore scalable because it can prune more paths and find violations faster.
meta compilation mc is a scalable static approach todetectingviolationsofpropertiesspecifiedbyastatemachinelanguage.
mc is neither sound nor complete.
esp is a pathsensitivestaticverifierforregular properties.espachievesstrong scalability by merging symbolic states.
however esp may produce false alarms due to imprecise modeling of program statements.in astagedstatictypestateproperty verificationframework is proposed based on a parametric abstract domain.
the false alarmscanbeeliminatedgraduallybythestagedanalysis.clara employs forward and backward data flow analysis to remove instrumentationsforruntimemonitoringoftypestateproperties.our guidingmethod makesthe backwardanalysis ofclarato beinterproceduralforcalculating postset.comparedwithstaticapproaches srv enjoys completeness by trading scalability because it executes the program under verification.
dynamic methods are mainly from runtime verification .
thebasicprocedureistogenerateamonitorforverificationfromaproperty and the monitor is usually implemented via instrumentations to the program.
the verification takes place at runtime based on the information collected by instrumentations.
hence dynamicapproaches verify a single program path.
javamop and tracematches arerepresentativetoolsforruntimeverificationofjava programs.
the calculation of presetuses the idea of monitoring inruntimeverification andthemonitoringisimplementedatthe virtualmachinelevel.comparedwithdynamicapproaches srvemploys dse to explore the path space of the program systematically which improves code coverage and finds more bugs.
software model checking has also been used for regular property verification.
slam uses predicate abstraction to obtain an abstract model of a program.
then at the model level slamuses model checking to verify regular properties.
when a counterexample is found by model checking it is reported when it is a real violation otherwise the counterexample is used to refine the abstract model.
yogi improves slam by integrating dse to speed up mo del refinement and finding real counterexamples.
compared with these approaches srv is lightweight and scalable because it adopts efficient static analysis to boost verification.
furthermore guidingandpruningarecommonlyinvestigated for improving the scalability of symbolic execution.
for guiding symbolic execution different methods are proposed w.r.t.different goals including improving code coverage reachingaprogramlocation targetingthedifferences between two program versions aiming at the unverified path space and generating a path satisfying a regular property .ontheotherhand pruningpathspaceisalsoaneffective methodtomitigatepathexplosion.sameasguiding theexisting work on pruning also differs in their perspectives to decide redundance such as read write information assertion violation and rule violation .
srv extends the existing work by the syn ergy of guiding and pruning for verifying regular properties.
conclusion this paper presents symbolic regular verification a practical dsebased technique for verifying regular properties.
to improve scalability we introduce a synergistic combination of property oriented path slicing and guiding.
srv s property oriented path slicing prunes redundant paths while guiding helps finding counterexamplesquickly.thetwocombinedtechniquesnotonlycomplement butalsostrengtheneachother.wehavedevelopedaprototypeof srv for java and evaluated it on real world programs w.r.t.widelyusedregularproperties.ourextensiveevaluationdemonstratesthat srv is effective and efficient and outperforms the state of the art significantly for regular property verification.
interesting future workincludes techniquestofurtherreduceslicingoverheadand furtherimprovementstoourtool susability andfeasibilityfor releasing to and benefiting the community.
acknowledgement this research was supported by national key r d program of china no.
2017yfb1001802 and nsfc program no.
and .zhendongsuwassupportedinpartbytheunitedstatesnationalsciencefoundation nsf grants and and by a google faculty research award.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symbolic verification of regular properties icse may june gothenburg sweden