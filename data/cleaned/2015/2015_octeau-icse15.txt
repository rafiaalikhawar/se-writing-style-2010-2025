composite constant propagation application to android inter component communication analysis damien octeau1 daniel luchaup1 matthew dering2 somesh jha1 and patrick mcdaniel2 1department of computer sciences university of wisconsin 2department of computer science and engineering pennsylvania state university 3cylab carnegie mellon university octeau cs.wisc.edu luchaup andrew.cmu.edu dering cse.psu.edu jha cs.wisc.edu mcdaniel cse.psu.edu abstract many program analyses require statically inferring the possible values of composite types.
however current approaches either do not account for correlations between object fields or do so in an ad hoc manner.
in this paper we introduce the problem of composite constant propagation.
we develop the first generic solver that infers all possible values of complex objects in an interprocedural flow and context sensitive manner taking field correlations into account.
composite constant propagation problems are specified using coal a declarative language.
we apply our coal solver to the problem of inferring android inter component communication icc values which is required to understand how the components of android applications interact.
using coal we model icc objects in android more thoroughly than the state of the art.
we compute icc values for applications from the play store.
the icc values we infer are substantially more precise than previous work.
the analysis is efficient taking slightly over two minutes per application on average.
while this work can be used as the basis for many whole program analyses of android applications the coal solver can also be used to infer the values of composite objects in many other contexts.
i. i ntroduction program analyses sometimes need to statically infer the possible values of object fields.
such a program analysis that has recently received interest is the inference of messages communicated between android applications.
the components of android applications can interact with one another using platform specific constructs.
this inter component communication icc facilitates the reuse of functionality both within and between applications.
for example an application may need to render a map centered on specific geographic coordinates.
in android this application simply needs to send an icc message which will be relayed to an appropriate target by the operating system.
the target will then render the map based on passed values.
this development model potentially presents concerns.
first exposed application components may be activated in unexpected ways leading for example to privilege escalation attacks .
second icc messages can be intercepted by malicious recipients with consequences ranging from data leaks to piracy .
finally since information may flow between components secure information flow analysis must account for inter component flows.
without icc analysis in order to remain conservative static taint analyses in android have to assume that any data coming from another component is tainted .
with icc analysis such a taint analysis can precisely determine if inter component links carry tainted data.
thus icc analysis has proven very valuable in many contextssuch as information flow analysis patch generation for privilege escalation vulnerabilities and detection of stealthy behavior .
in order to infer facts about interactions between components we need to find all possible values of the fields of icc objects at program points where message passing occurs.
unfortunately existing studies of application interfaces are limited.
the epicc tool tries to determine the specifications of icc interfaces.
unfortunately it only addresses intent messages and a small subset of uri messages for which all fields are constant values.
adding complete support for uris using the same approach as for intents would result in a significant increase in the complexity of the formulation and implementation of the data flow functions.
while this is possible in theory it is not feasible in practice.
apposcopy also infers intent values but does not compute all fields of an intent.
in particular similarly to epicc uri data is not inferred.
in this paper we define the problem of multi valued composite mvc constant propagation.
unlike most constant propagation analyses we attempt to find all possible values of objects of interest at important program points making our analysis multi valued .
our analysis targets composite constants i.e.
we determine the values of complex objects that may have multiple fields taking the correlations between fields into account.
problems are specified using the coal declarative language.
we design a coal solver which takes coal specifications and programs as input and outputs composite constant values at program points of interest.
in order to automatically generate data flow functions it utilizes the concept of field transformers which express how fields are changed by program statements.
while mvc constant propagation was motivated by android icc analysis this work applies to a wide variety of static program analyses where the range of values of objects needs to be determined.
it is valuable in various areas such as software security maintenance and modeling.
it can apply to many object oriented programming languages.
as an application of our composite constant propagation solver we implemented and evaluated ic3 a new tool for android icc analysis.
in the coal language we modeled all icc messages with about lines of coal specification.
since android icc messages heavily rely on strings of characters we devised and implemented a string analysis that is both efficient and more precise than the one in epicc.
we computed icc values in applications from the official play store.
we1void map float latitude float longitude intent intent new intent intent.setaction view uri geouri uri.parse geo latitude longitude intent.setdata geouri startactivity intent a intent targeted at components that can render a map.
activity android name maprenderingactivity intent filter action android name view data android scheme geo category android name default intent filter activity b example intent filter declaration to receive the intent in a .
activity android name dialeractivity intent filter action android name view action android name dial data android scheme tel category android name default intent filter activity c example intent filter declaration to dial phone numbers.
fig.
.
example intent and intent filter used for rendering a map and for displaying a dialer.
the real string values have been abbreviated for clarity.
inferred precise icc values in of cases.
epicc on the other hand could only infer precisely.
the remaining of values could not be determined because of constructs not yet handled by our string analysis and other pathological cases.
computing icc values is efficient taking on average slightly over two minutes per application.
the extra precision in inferring icc values directly translated to a significant increase in precision when matching messages with potential receivers.
since the matching process is an overapproximation of actual runtime communication having fewer links is desirable.
in our experiments with applications such a matching yielded links with icc values computed by epicc whereas values computed with ic3 produced only potential links.
we make the following contributions we introduce the mvc constant propagation problem.
we define coal a declarative language to specify mvc constant propagation problems and query their solution.
we formally define an approach to solve mvc constant propagation problems in an interprocedural flow and context sensitive manner.
we implement a coal solver based on this formalism and open source it at .
we build ic3 an icc analysis tool that relies on the coal solver.
as a part of ic3 we develop a string analysis that is finely tuned for the most typical cases found in android applications.
we make its source code available at .
ii.
a m otivating example android icc android applications are composed of four different types of components.
activities represent the user interface.
services are used for background processing.
content providers allow for sharing of structured data between components.
broadcast receivers receive messages sent to the entire system.
components can communicate with one another using two kinds of objects.
uniform resource identifiers uris are used to address data in content providers.
intent object are used in all other cases.
the target component of an intent can be specified by explicitly naming it or it can be determined automatically by the operating system based on the fields of the intent.
an intent resolution procedure maps a givenintent to possible targets.
several fields of an implicit intent are used to match it with potential targets.
the action field represents the operation that the receiving component should perform.
the categories field adds information about the component that the system can use.
for instance the system places components with the launcher category in the main application launcher.
the data field includes data that the receiving component should act on.
it has the form of a uri.
components can subscribe to receive implicit intents by specifying intent filters which describe the actions categories and data of the intents that should be addressed to them.
most intent filters are specified in the manifest file that is included with every application.
figure shows a representative example of android icc.
in this figure and in the remainder of this paper we abbreviate string values for ease of exposition.
figure a shows a method that sends an intent in order to render a map centered at given coordinates.
an intent intent is created.
its action is set to view which is a generic action used to display many kinds of data.
the data of the intent is defined to be a uri with the geo scheme followed by coordinates.
when thestartactivity framework method is called the operating system os resolves potential target components prompting the user to choose a recipient if several components match.
figure b is a component declaration as it can be found in an application manifest.
the activity element line declares that the application contains an activity component with name maprenderingactivity that includes a single intent filter.
the action line specifies that the action field of intents received by the component should have value view .
the data declaration at line specifies that any received intent should carry data in the form of a uri with a geo scheme.
finally thecategory line declares that received intents can carry thedefault category.
this category is added by the os to implicit intents targeting activities such as the one on line of figure a .
therefore maprenderingactivity could receive the intent created in figure a .
in order to statically know how application components communicate with one another we need to determine the values of icc objects at message passing program points.
for example in figure a we want to know all the possible values ofintent at statement startactivity intent .
objects of interest are intents intent filters and uris.
it is very challenging to write data flow models separately for all of these.
that is why previous work has not properly handled uris which has two negative consequences.
first interactions with content providers cannot be determined.
second the data field of intents cannot be known which significantly limits the intent resolution process.
any field that cannot be known results in a loss of precision.
for example mapping the intent from figure a with the component from figure b requires knowing the action and the uri data of the intent.
when the data field is not known any attempt to resolve the possible targets ofintent from figure a has to conservatively assume that the data field can take any value.
figure c declares a dialer activity dialeractivity .
it is similar to maprenderingactivity except that it adds support for a dial action and it handles tel uri schemes.
because of1public class intent private string action private set string categories new hashset private string data private string mimetype public void setaction string act this .action act public void addcategory string cat this .category cat public void setdataandtype string d string t this .data d this .mimetype t public void setdata uri u this .data u.getdata this .mimetype null 18public class uri private string data public void setdata string d this .data d public void getdata return this .data a simplified intent and uri classes.
the real ones comprise and sloc respectively.1class intent 2string action string categories string data string mimetype 4mod intent void setaction string replace action 6mod intent void addcategory string add categories 8mod intent void setdataandtype string string replace data replace mimetype mod intent void setdata uri replace data type uri data clear mimetype query context void startactivity intent type intent 17class uri string data mod uri void setdata string replace data source uri string getdata string data c coal specification for the constant propagation problem.
each modifier specification mod describes the influence of a method call on the fields of an intent.
a query indicates that all intent values at calls to startactivity should be computed.
a source indicates how the value of a field flows out of an object.
1void sendmessage context c boolean b string mimetype intent intent new intent intent.setaction view uri uri new uri if b intent.addcategory browsable uri.setdata conferences.org intent.setdata uri else uri.setdata file florence.jpg intent.setdataandtype uri.getdata mimetype c.startactivity intent b message passing code.
we assume that the mimetype argument may have value either image jpg orimage .value value value action view view view categoriesfbrowsableg ?
?
data file ... file ... mimetype ?
image jpg image d possible values of the fields of intent at the startactivity call.
we have abbreviated the uri strings for space reasons however our system would infer complete strings.
value is for the first branch after the ifstatement lines in b .
values and account for the fall through branch of the ifstatement where argument mimetype may have two different values.
fig.
.
running example.
its inability to infer intent uri data the current state of theart would infer that both maprenderingactivity and dialeractivity can receive the intent.
in reality only the former is able to do so.
thus more precision is needed to avoid such false positives.
we address this issue in this paper.
in sections iii through vi we introduce a novel approach to statically infer the set of values that objects can take.
in section vii we apply this approach to the problem of inferring android icc values.
iii.
o verview a. the mvc constant propagation problem consider obj an object of type class pairfint x int y g. assume that at some program location obj can be either x y or .
we would like an analysis that can determine this fact.
classical constant analysis applied for each field fails at determining a useful value because none of the fields is the same constant across all paths.
multi valued constant analysis could determine that obj x2 f1 2gand obj y2f10 20g.
these constraints accurately describe the individual fields but they allow for imprecision in the object because they allow the possibility that obj .
we define the multi valued composite mvc constant propagation problem to be the problem of determining the set of values that an object viewed as a tuple such as x y can have.
note that the above multi valued constant analysis applied to individual fields is a possible solution it may just not beprecise enough for certain analyses.
we will show how to efficiently find more precise solutions.
we now introduce a running example that will be used throughout.
figure a shows code for a hypothetical intent class that contains data used for passing messages between application components.
it uses a data field which is copied from a uri object for which code is also shown in figure a .
figure b defines method sendmessage which we assume to be called as part of an android application.
this method creates an intent object and sets its action field.
then depending on the value of a boolean one of two things can happen.
in the first branch after the ifstatement a value is added to the categories field ofintent .
then the data field of a uri object is copied to the data field ofintent at line .
in the fall through branch the data andtype fields of the intent variable are set using a call to setdataandtype line .
finally the intent object is sent to another component using thestartactivity method.
the data flow problem we are solving is to determine all the possible values of the fields of intent at the call tostartactivity .
in our propagation framework defined below the problem can be specified using coal a declarative language we designed for this purpose.
the function of coal constant propagation language is to specify multi valued composite mvc constant propagation problems .
it specifies the types of variables for which values should be inferred intermediate representation generationapplication icfg construction mvc data flow analysiscomposite constantsfig.
.
general overview of the mvc constant analysis process.
coal specification ide solverlatticesdata flow functionscomposite constantsargument analysesicfgcoal solver fig.
.
the mvc data flow analysis process step from figure .
and how these values are modified by program statements.
it enables abstract reasoning on the semantics of api methods.
the coal language is recognized by our coal solver which outputs solutions for many propagation problems solely from their coal specification and an input program.
figure c shows how to specify the problem with our framework using coal.
the coal specification is manually written once and it can subsequently be used to solve the same problem for an arbitrary number of applications.
it is composed of field declarations modifiers and a query.
the field declarations specify the fields that are being tracked and their type.
note that for each field we keep track of sets of values even though the field declaration only specifies the type of each individual field value.
the first modifier indicates how thesetaction method influences the modeled value of an intent object.
a modifier specification starts with the signature of the modeled method.
each line in a modifier declaration is an argument whose value is used to modify the intent value.
each argument declaration is composed of several attributes.
an integer declares the position of the argument in the array of arguments to the method with indices starting at .
after the argument index an operation and a field are declared.
they describe both the field that is modified by the method and how it is modified.
for example in the setaction modifier replace action means that the action field is replaced with the value of the first argument to setaction .
other modifiers are declared in a similar manner except when the type of an argument is a class that is modeled with coal.
in that case atype attribute is used in order to specify which field of the argument object is used.
for example in the setdata modifier the replace data type uri data argument means that the data field of the uri argument is used to replace thedata field of the intent being modified.
the query statement indicates that we are querying the solution at all calls to startactivity .
similarly to the modifier declaration we specify a list of arguments.
they describe the arguments whose value we would like to query.
in this case it is the first argument as described by the 0attribute which is an intent object.
the source at line indicates how a field value flows out of an object.
this is useful when the value subsequently flows into a coal modifier since the coal solver can then infer the correct value.
figure d shows the expected result of our analysis.
we want our analysis to recover the three possible valuesof intentintent .
these values correspond to all possible execution paths of the program from figure b .
we wish to recover exactly these possible values and we do not want all the possible combinations of fields.
for example it is not possible in our problem to have an intent value with category browsable and mime type image jpg .
as a result our analysis does not simply track fields individually as separate variables but rather propagates composite constants.
b. mvc constant propagation analysis figure shows a general overview of the analysis process that takes an application as input and outputs the values of composite objects.
it starts by converting the program to an intermediate representation that is suitable for further analysis step .
it then generates an interprocedural control flow graph icfg step .
an icfg is a collection of cfgs of all the procedures in the program connected with each other at procedure call sites.
this includes building a call graph for the entire program.
finally the actual mvc data flow analysis takes place in step and outputs the mvc constant values.
existing work can perform steps and .
therefore the scope of this paper is limited to the mvc data flow analysis step which is performed using our coal solver.
figure depicts a more detailed overview of the coal solver which takes two inputs.
first it uses the icfg of the program being analyzed.
second it takes a coal specification for the problem being solved.
this coal specification describes the structure of the composite objects for which constant propagation should be performed.
it also describes the methods that can modify these objects and the program locations where the constants should be computed.
the specification is written using the coal language which allows mvc constant propagation problems to be specified easily.
it should be noted that for a given problem the coal specification need only be written once after which an arbitrary number of programs can be analyzed.
for each program the coal specification is parsed to build a model of the problem by creating problem specific lattices of values and data flow functions.
these are input with the icfg into a solver for interprocedural distributive environment ide problems .
we present the generic ide model for constant propagation in section v. finally since the values of arguments to functions have to be known we use argument value analyses e.g.
integer and string analyses to generate the data flow functions.
the ide solver outputs the analysis results.
the coal language allows specification of program points of interest queries where the mvc constant values should be computed.
this is useful in cases where the program points of interest are known in advance.
in other cases we also allow lower level queries to the ide solver as part of the coal solver api.
the results can then be output in a simple text format or accessed using a programmatic interface api .
note that it is possible to write mvc data flow models for individual classes in an ad hoc manner without using an mvc constant solver.
however given the complexity of a typical mvc model so is time consuming and prone to errors.
in contrast the approach we present relies on ahmodeli class htypei fhfieldijhmodifierijhqueryijhconstanti jhsourceig hfieldi htypeihfield namei hmodifieri mod hmethod sigi fhmodifier argig hqueryi query hmethod sigi fhquery argig hconstanti constant hfield sigi fhfield namei hinline valuei g hsourcei source hmethod sigi hfield namei hmodifier argi hoperationihfieldi harg typei hfield namei hquery argi harg numberi harg typei harg numberi hintegerij hintegerif hintegerig harg typei type htypei hfield sigi htypei htypeihfieldi fig.
.
coal language for specifying mvc constant propagation problems.
single generic and formally defined mvc data flow model.
instead of specifying data flow models for each class being analyzed mvc constant propagation problems are specified by writing coal specifications.
this approach has several advantages over the ad hoc one.
first it is easier to implement and maintain since coal specifications are written using a simple declarative language.
second it is easier to ensure that the models and their implementation are correct.
correctness of the generic model is discussed in section vi a and in an accompanying technical report .
since coal specifications only describe the relationships between fields and methods without specifying semilattices or flow functions their correctness is relatively simpler to verify.
third the generic data flow model used by the coal solver can be changed without having to rewrite all the coal specifications that have been written so far.
in particular we are currently using an ide model but it is possible to use reductions to other types of problems .
finally when modeled types interact with one another the data flow functions in the ad hoc approach become much more complex.
on the other hand the fixed point iteration described in section vi c supported by the coal constructs demonstrated at line of figure c enables seamless support for inter object data flows.
iv.
t hecoal l anguage the goal of the coal language is to specify and query a wide variety of mvc constant propagation problems.
coal specifications are used by our solver to automatically generate semilattices of values and data flow functions.
a simplified grammar for this language is presented on figure .
thefgcharacters symbolize repetition while characters surround optional parts of a production.
the model for a given object is composed of field declarations modifiers constants and sources.
queries can also be specified using the coal language to specify program points where mvc constants should be inferred.
field declarations a field declaration specifies a field that is part of the modeled class.
it describes a data type and a name for the field.
in figure we use non terminals htypei andhfield nameito represent valid types and field names.
modifiers modifiers represent method calls where constant values flow to the modeled object.
the specification of the modifiers comprises a method signature hmethod sigithat identifies the method of interest.
it also includes a set of arguments that describe how the method arguments are usedto modify the fields of the modeled object.
a modifier argument has several attributes.
an argument index identifies the method argument of interest.
in some cases several arguments contribute to the value of a single field.
that is why the language supports sets of argument indices.
a field operation to be performed is also specified.
this allows the solver to create appropriate data flow functions.
natively supported field operations are add add argument value to the field remove remove argument value from field replace replace field with argument value and clear clear field value .
a modifier specification also includes a field name that identifies the field being modified.
in the case where an argument is a class modeled with coal an argument type and additional field name are specified.
this indicates to the solver that the value of a field of a modeled class flows to the object being modified.
constants many languages allow the specification of constants e.g.
static final fields in java .
the constants of a class are initialized in the class initializer the first time the class is referenced.
a na ve way to deal with constants would consist in tracking the constant creation and initialization as it is done for all modeled objects.
we would then propagate them throughout the entire program at the cost of performance.
as a performance optimization we allow constant modeled objects to be specified in coal.
where these values are used the coal solver uses the specified value.
sources sources model the case where a modeled field value flows to an argument value.
for example the source at line of figure c allows the coal solver to infer that thedata field of the uri object flows to the intent variable.
using this information allows the solver to infer the correct value for the data field ofintent .
queries queries specify statements of interest where modeled values should be determined.
the mvc constant propagation problem from figure b can be solved by inputting the program and the specification from figure c into our coal solver.
alternative methods such as code annotations could be used to specify these problems.
however our approach specifies all analysis parameters in a single location and does not require the source code of the modeled objects.
annotations on the other hand would require source code and they would have to be spread over the modeled code.
in our motivating example of android this implies spreading specifications over thousands of lines code.
v. a g eneric model for mvc c onstant propagation the purpose of the coal language and the associated constant propagation solver is to determine the possible values of composite objects by only defining a coal specification.
the coal solver automatically converts the coal specification to an instance of an interprocedural distributive environment ide problem using the model defined in section v. given an ide problem existing algorithms can compute a solution .
this section presents the analysis domain and a space fof functions that model the influence of coal modifiers.
they will subsequently be used in section vi to automatically build reductions to ide problems.
interested readers are referred to the technical report for a more detailed presentation.a.
thelsemilattice of values for any set x we denote the power set of xby2xand the set of functions from xtoxbyxx.
we are trying to determine the value of an object with nfields taking values in finite sets v1 v n. if fieldihas a container type e.g.
set of integers viis the contained type e.g.
integer .
for i2f1 ng letpi 2vi f!g where!represents an undefined value.
let b p1 pn.
we define l 2b a join semilattice with a bottom element ?
?.
the join operation on lis the set union .
the top element of l is the set of all elements in b. setsv1 v nare the domains of the field values we are trying to determine.
for example v1could be the set of constant strings of characters in the program.
a value in b represents a value as it is seen on a single path.
finally values inlrepresent values of objects taking into account several paths of a program.
note from the definition of p1 p n that we keep track of sets of values even for scalar fields.
a scalar is simply represented by a set with a single value.
let us consider the example from figure a .
we are interested in four fields action categories data andmimetype .
letsbe the set of string constants in the program.
in this case we consider p1 p2 p3 p4 2s f!g.
in other words we consider all four fields to take values in the power set ofs.
we haveb p1 p2 p3 p4andl 2b .
in methodsendmessage the value associated with the intent variable is initially ?before line .
line transforms this value tof ?
?
?
?
g. right after line the value is f fviewg ?
?
?
g after the ifstatement at line the value is f fviewg fbrowsableg f g ?
fviewg ?
ffile florence.jpg g fimage jpgg fviewg ?
ffile florence.jpg g fimage g g b. transformers on l the intuition behind the coal language is that each argument in a coal modifier represents the influence of the method call on a field.
accordingly we introduce transformers that are defined at the granularity of fields.
in this section we assume that the value of uriis available where necessary.
we revisit this assumption in section vi c. definition fori2f1 ng we definefia non empty subset ofppi iclosed under composition.
each 2fiis called afield transformer .
in this paper we consider field transformers such that type !
!and for all x2pisuch that x6 !
x x kill gen for some constant setsgen andkill inpi.
such a function will also be denoted as kill gen .
this is used for the add and remove field operations in coal.
type for all x2pi x gen for somegen inpi.
this case is also denoted by gen .
this is used for the replace andclear field operations in coal.
it is easy to verify that the set of such field transformers is closed under composition.
let us denote the identity field transformer by id.
we have id ?
?.
the important idea is that each modifier argument in coal is mapped to a single field transformer.
for example let us consider the statement at line of figure b .
using the definition above and the fact that this method replaces the existing action value we can model it using type field transformer fv iewg.
field transformers are used as basic building blocks for data flow functions.
we define the set lof functions from bto bsuch that for any l2l there exists n 2f1 fnsuch that for any b n 2b l b n n .
we notel n. recall that the influence of the statement at line of figure b on field action is modeled by field transformer fv iewg.
the function inlthat models the influence of the setaction call on the action field is quite naturally fviewg id id id2l.
this function solely modifies the action field.
functions inlmodel the influence of a single execution path.
we can define their composition as follows.
for any l1 nandl2 ninl we have l1 l2 n n using definition lis closed under composition.
we now define a set fof functions from ltolusing functions inl.
functions in fcan model the influence of several execution paths on all fields of an object.
more specifically any f2fis writtenf fl1 l mg with l1 l m2l such that for anyb2b f fbg sm i 1li b for anyv fb1 b kg2l f v sk i 1f fbig .
the identity over lis denoted by idl.
additionally f contains which is such that for all v2l v ?.
informally the function is used to kill data flow facts.
this only happens when a variable is assigned a new value.
finally fcontainsinitvfunctions which are such that initv ?
v withv2l.
informally init functions generate data flow facts and associate them with an initial value.
let us now consider the ifstatement in figure b .
the influence of the two branches is summarized by fid ?
fbrowsable g f g ?
id id ffile florence.jpg g fimage jpg g id id ffile florence.jpg g fimage gg where ?clears the value of the mimetype field.
we can verify that applying this function to the value given by equation yields the value given by equation .
by defining the composition of elements of fin a standard way it is possible to prove the following proposition which will be used in the next section.
proposition fis closed under composition.
finally we define the operator such that for f1 fl1 l1 mgandf2 fl2 l2 kg f1 f2 fl1 l1 m l2 l2 kg.
vi.
f rom coal s pecifications to ide p roblems this section presents how coal specifications are used to automatically generate instances of ide problems by generating data flow functions in f. recall that ide problems can then be solved using existing algorithms .
we first outline the requirements of ide problems.
a. environment transformers letdbe the set that comprises all variables in the program and a special symbol which represents the absence of a dataalgorithm generate functions in ffrom coal modifiers.
procedure generate function modifier statement result idl3 for all arguments arg inmodifier args do values null ifarg number !
null then values getargument values statement arg number arg type argfunction null ifvalues6 null then for all argument values value invalues do current build funcinf arg op value arg field ifargfunction null then argfunction current else argfunction argfunction current else argfunction build funcinf arg op null arg field result result argfunction return result flow fact.
an environment is a function from dtol where lwas introduced in section v a. the set of environments ise.
a join operation tis defined on esuch that for anye1 e22eandd2d e1te2 d e1 d e2 d .
environment transformers are used to model the influence of program statements on the values of variables.
they are functions from etoe.
for example before a program statements the values associated with each variable of interest are given by environment e12e.
statement stransforms e1to a new environment e22e which is modeled by an environment transformer tsuch thate2 t e1 .
the ide framework requires that environment transformers be distributive .
an environment transformer tis said to be distributive if for every e1 e2 2eand for any d2d t tiei d i t ei d .
the main function of the coal solver is to turn coal specifications into distributive environment transformers.
we can show that the functions in fare distributive and that they can be used to easily build distributive environment transformers which ensures the correctness of our approach.
b. generating functions in f since producing environment transformers from functions infis trivial this section addresses how the coal solver builds elements of ffrom coal specifications.
algorithm is used by the coal solver to generate a function in ffrom a statement and a modifier specification for the statement.
it computes functions in ffor each argument and composes them recall from proposition that fis closed under composition .
a modifier argument arg has several attributes i an operation op which is performed by the modifier method ii an argument number number which indicates the position of the arguments of interest in the modifier method iii an argument type type which can be declared as part of the field declaration see line of figure c and iv field the index or the name of the modified field.
we assume the existence of a procedure g etargument values which computes the possible values of a method argument given an invoke statement an argument number and an argument type.
for most value types this procedure simply traverses the interprocedural control flow graph starting at the method call looking for assignments to the variable that is used as an invocation argument.
for string arguments we use the analysis described in section vii a. note thatthe argument type is needed by the coal solver to select the argument analysis that should be used.
we also assume that there is a procedure b uild funcinf that generates a function in fgiven an operation an argument value and a field.
in the interest of space we only summarize its main steps.
it starts by generating a field transformer using the operation and the argument value.
the field index or name allows the creation of a function l2l of the form l id id id id.
the corresponding function infis simplyflg.
when a modifier method argument may have several values resulting in possible functions f1 f n we compute f1 fn line .
to illustrate this procedure let us consider line of figure b .
the coal solver determines that this is a modifier with two arguments see figure c lines .
considering the first argument replace data and given the fact that data is a string field the g etargument values procedure finds that the method argument has value file florence.jpg .
since a replace operation is requested the b uild funcinf procedure generates field transformer ffile florence.jpg g. using the fact that data is the third field line of figure c it generates function fid id ffile florence.jpg g idg considering argument replace mimetype the solver finds that there are two possible values for the mimetype variable.
thus lines of the algorithm yield function fid id id fimage jpg g id id id fimage gg where line utilizes the definition of the operator on f from section v. finally line of algorithm composes the two functions given by equations and which yields fid id ffile florence.jpg g fimage jpg g id id ffile florence.jpg g fimage gg c. fixed point iteration let us consider method sendmessage from figure b .
so far we have assumed that the value of the uri uriat line of figure c is available when we generate field transformers forintent .
in reality it is not initially available because when we solve the problem for the first time values for intent anduriare computed in the same iteration.
thus in order to fully resolve all values we run several iterations of the coal solver.
for example in the first iteration the transformer that is generated for statement intent.setdata uri is f intent intent intent intent 4g fid id id uri 1g where uri 1is a transformer that indicates that the value of thedata field ofintent refers to the first field of uri uri.
we initially start with intent i and uri 1mapping to !
for i .
we then iterate until a fixed point is reached for intent i and uri .
the same process allows the solver to resolve the value of intent at line of figure b .
vii.
a pplication to android icc as an application of the coal language and solver we built ic3 inter component communication analysis with coal an icc inference tool that is based on coal specifications.
the main icc classes are intents intent filters and uris.
for completeness we also model the component name bundle pending intent and uri builder classes since they are referenced by the main class types.
recall from figure that as a prerequisite to the mvc constant propagation it is necessary to generate an inter mediate representation ir that is suitable to generate an icfg.
the coal solver is currently implemented using the soot framework and the heros ide solver .
soot converts java bytecode to an internal ir that is recognized by its spark call graph construction module which is used to build an icfg.
however android applications present additional challenges.
first they are distributed in a platformspecific bytecode format.
we therefore preprocess them with dare which converts android to java bytecode.
second android applications are composed of components that may be started in an arbitrary order.
additionally they are eventbased programs that declare callbacks that may be called in an arbitrary order.
in order to address this challenge in a conservative manner we adopt the call graph construction procedure from flowdroid which generates a wrapper entry point method that simulates the application lifecycle and the arbitrary event and component call order.
the coal solver takes aliasing into account.
when a method modifies a variable o1that is a possible alias for another object o2 our analysis generates two values for o2.
one of them takes the call into account and the other one does not.
the one that does not models the case where the alias analysis results in a false positive i.e.
detecting that a value may point to a certain heap location even though it does not .
this is similar to the standard idea of weak updates .
a. string analysis strings are ubiquitous in android applications.
many arguments to icc methods are strings.
because of the limited set of predefined intent fields e.g.
default action and category strings in many cases the value of string fields is determined by a finite set of constants.
however the way these constants are transferred or combined is not trivial and a string analysis is required to determine the set of possible values that a given variable can have.
our string analysis determines a safe overapproximation of such sets.
it was inspired by jsa although our analysis is highly customized for the purposes of android.
conversely jsa is more generic but significantly slower for our purposes.
our analysis works in two stages constraint generation and constraint solving.
constraint generation simply gathers the dataflow facts for string variables.
constraint solving determines regular sets described as regular expressions that satisfy the constraints.
in the first stage we generate constraints for all string operations modeling the string and stringbuilder classes.
our goal is to have a representation that can be used either by a constraint solver or by abstract interpretation.
this is why the constraints are a symbolic representation of the original program operations.
the analysis is flow sensitive.
constraints model idioms that are common in android operations concatenation string fields function calls etc.
in the second stage a solver uses the constraints to answer queries about variable values.
as a proof of concept we implemented a simple solver that given a variable xproduces a regular expression that overapproximates the set of values thatxcan take.
it works by finding the constraints associated withxand by traversing the flow graph and interpreting the nodes.
we avoid non termination by detecting self dependencecycles and widening to .
that is?
.
similarly we widen to.
when we detect calls to functions outside the analysis for which we have not generated constraints .
although our widening method may be less accurate than that in our simple solver is faster and can still be more accurate because of context sensitivity.
our analysis is interprocedural context sensitive flow sensitive field sensitive but not objectsensitive.
additional details about the string analysis can be found in the technical report .
b. evaluation the evaluation of our approach was aimed at answering three central questions q1 can ic3 precisely infer field values of icc objects?
q2 as an application of our analysis how precisely can icc messages be matched with their targets?
q3 are the computational costs of ic3 feasible in practice?
the answer to these questions determines how effectively our analysis can be used as the basis of inter component analyses.
highlights of our evaluation are ic3 infers precise field values for of icc values.
epicc can only infer .
this is a significant increase in precision.
when matching components that may communicate with one another specifications from ic3 lead to fewer component links than the current state of the art.
on average our analysis takes seconds per application.
this makes it feasible in practice to use our analysis as the first step of inter component analyses.
for performance reasons we generally do not allow the constant propagation to analyze the android framework code.
the only exception is when a framework class may create or modify icc objects which only occurs in a few classes of the framework.
in the few cases where icc method arguments are not strings of characters e.g.
integer arguments we use a simple analysis that looks for definitions of constant values for that argument.
it simply traverses the interprocedural control flow graph starting at the method call keeping track of all possible values.
when a constant value cannot be found a special!value is conservatively returned.
we performed our experiments on a corpus of applications.
they were randomly selected from a set of applications downloaded from the google play store between january and september .
some application could not be processed because of insufficient memory errors or timeout so we report numbers for applications.
precision of field values we first measured the precision of the fields of the icc values inferred by ic3 at program points of interest i.e.
sending a message or programmatically registering a component with an intent filter .
the list of these program points is given in .
we counted the number of icc values inferred by ic3 and epicc for which no field value used for intent or uri resolution is completely unknown e.g.
a .
string value .
we modified epicc such that it used the same entry point construction procedure from .
the precision results are presented in table i. the third line shows the results for intents and intent filters whereas the fourth line shows statistics for uris.
the value count column shows thetable i icc value field precision results .
value icc values with precise fields icc values with imprecise fields missing icc values count epicc ic3 epicc ic3 epicc ic3 intents filters uris total total number of icc objects that were detected.
the third and fourth columns present the number of icc values discovered by epicc and by ic3 that only have precise e.g.
not equal to .
field values.
the fifth and sixth columns show the number of imprecise values detected by each tool.
finally the missing columns show the number of locations where an icc value was missed by either tool.
we observe that the precision of the values inferred by ic3 for intents intent filters and uris was high with of values being detected accurately by our tool.
epicc on the other hand could only precisely detect .
of the intent and filter values that ic3 detected precisely but epicc did not were due to the presence of uri data in intent values which is not handled by epicc.
in cases epicc missed a value that ic3 did not.
the remaining cases that were precisely detected by ic3 and not by epicc were due to the more powerful string analysis.
there was also a clear difference in the case of uris with ic3 precisely determining values compared to for epicc.
that is because epicc does not include a thorough model for uris.
in particular a number of methods refer to other modeled objects.
since this is handled in an ad hoc manner in epicc good coverage of these methods cannot be achieved resulting in a lot of missed values.
on the other hand using coal specifications ic3 achieves much better coverage of uri methods.
in particular